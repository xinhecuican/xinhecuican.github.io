<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序</title>
      <link href="/post/a444b428.html"/>
      <url>/post/a444b428.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed May 27 2020 19:56:46 GMT+0800 (中国标准时间) --><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>稳定？不稳定： 稳定指的是两个相同的元素排序完成之后在表中相对位置不变。</p><h2 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h2><p>当插入第i个时，前i-1个已经排好了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        tag = a[i];</span><br><span class="line">        <span class="built_in">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i<span class="number">-1</span>; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k]&gt;tag)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">                temp = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[k+<span class="number">1</span>] = tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>默认第一个已经排好，从第二个开始从后往前排，如果第k个数比要比较的数大就把这个数往后排。</p><p>复杂度： n^2</p><h2 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h2><p>折半排序基于前面的直接插入，不同的是它通过二分找插入位置。然后再移动</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    tag = a[i];</span><br><span class="line">    <span class="built_in">int</span> low=<span class="number">0</span>, high=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;tag)</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//high+1是插入位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=i<span class="number">-1</span>; k&gt;=high+<span class="number">1</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    a[high+<span class="number">1</span>] = tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度 n^2</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>思想： 把序列按gap划分成若干个子序列。例如有6个元素，gap是3，那么第0个和第3个是一个序列，第1个和第4个是一个序列。之后在每个子序列中直接插入。然后折半缩小gap。</p><p>第一个gap一般取n/2。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> gap = n/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(gap != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=gap; i&lt;n; i++)<span class="comment">//从gap开始是因为直接插入排序中默认第一个已经排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        tag = a[i];</span><br><span class="line">        <span class="built_in">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i-gap; k&gt;=<span class="number">0</span>; k-=gap)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k]&gt;tag)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k+tag] = a[k];</span><br><span class="line">                temp = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[temp+tag] = tag;</span><br><span class="line">    &#125;</span><br><span class="line">    gap /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度：n(longn)^2。但这是一种不稳定的排序</p><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><p>起泡排序是过程是逐个比较，比较出最小的放到第一个，然后放到第二个。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> flag=<span class="number">0</span>,exchange=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag&lt;n<span class="number">-1</span> &amp;&amp; exchange==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    exchange = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n<span class="number">-1</span>; i&gt;flag; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a[i<span class="number">-1</span>] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            a[i] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            a[i<span class="number">-1</span>] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            exchange = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这一步后小的在前面，然后下一次又是把i-1和i-2比，如果i-1小，又跑到前面</span></span><br><span class="line">        <span class="comment">//这样第i-1个一直是最小的（相对于它后面的元素）</span></span><br><span class="line">    &#125;</span><br><span class="line">    flag++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度 n^2</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><a href="https://xinhecuican.github.io/post/11306.html">以前的一篇</a></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><p>这个就不多说了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> min = <span class="number">2147483647</span>;</span><br><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=i+<span class="number">1</span>; k&lt;n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[k]&lt;min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = a[k];</span><br><span class="line">            tag = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap（a[i], a[tag]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是完全二叉树产生的数组。然后建立一个父节点比子节点大/小的数组。父节点比子节点大的叫大顶堆，父节点比子节点小的叫小顶堆。</p><p>假设父节点是i，那么两个子节点分别是i<em>2和i</em>2+1。下标要从1开始</p><p>过程，以小顶堆为例</p><ul><li>初始化，首先构造一个大顶堆，过程是用这个节点和它的父节点进行比较，如果小就交换位置，然后再和新位置的父节点进行比较。先拿第一个数和第二个数进行比较，如果第一个数比第二个数小那个交换位置。然后第三个数和第一个数比较。此外，还可以从小到大直接建</li></ul><p>之后第4个数是插入到第二个数上的，就拿第四个数和第二个数比较，如果第四个数比第二个数小就把第二个数往上提，之后再和第一个数进行比较。然后依此类推。</p><p><img src="/images/%E6%8E%92%E5%BA%8F.png" alt></p><ul><li>把第一个元素和最后一个元素进行交换，然后对前n-1个元素进行处理。开始我们建立的是大顶堆，现在我们把最大的放到后面就变成小顶堆了。并且这时不仅满足小顶堆，还满足左儿子一定比右儿子小。</li></ul><p><img src="/images/%E6%8E%92%E5%BA%8F2.png" alt></p><ul><li>之后就是用根节点左右儿子中比较大的节点和根节点进行比较。然后如果比根节点大就进行换位。然后再在新位置和新的子节点进行比较。完成之后又把根节点放到最后。之后就重复第二步和第三步。（不画图了，难死我了）</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据上面自己写的，拿过几个数据代过，如果想看更标准的可以看下面模板(饶命)</span></span><br><span class="line"><span class="built_in">void</span> Heap(<span class="built_in">int</span> *a, <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> now = i;</span><br><span class="line">        <span class="keyword">while</span>((now&lt;&lt;<span class="number">1</span>) &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> largest ;</span><br><span class="line">            <span class="built_in">int</span> l = now &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> r = (now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span> == n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[l] &gt; a[now])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">int</span> temp = a[l];</span><br><span class="line">                    a[l] = a[now];</span><br><span class="line">                    a[now] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[l] &gt; a[r])</span><br><span class="line">            &#123;</span><br><span class="line">                largest = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                largest = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[largest] &gt; a[now])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = a[largest];</span><br><span class="line">                a[largest] = a[now];</span><br><span class="line">                a[now] = temp;</span><br><span class="line">                now = largest;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//初始化</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">1</span>] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        a[i] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((now&lt;&lt;<span class="number">1</span>) &lt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> big;</span><br><span class="line">            <span class="keyword">if</span>((now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span> == i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = now&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[now] &lt; a[temp])</span><br><span class="line">                &#123;</span><br><span class="line">                    a[now] = a[temp] ^ a[now];</span><br><span class="line">                    a[temp] = a[temp] ^ a[now];</span><br><span class="line">                    a[now] = a[temp] ^ a[now];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//只有左节点</span></span><br><span class="line">            <span class="keyword">if</span>(a[now&lt;&lt;<span class="number">1</span>] &lt; a[(now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                big = (now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                big = now&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[big] &gt; a[now])</span><br><span class="line">            &#123;</span><br><span class="line">                a[big] = a[big] ^ a[now];</span><br><span class="line">                a[now] = a[big] ^ a[now];</span><br><span class="line">                a[big] = a[big] ^ a[now];</span><br><span class="line">                now = big;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>模板</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆长度</span></span><br><span class="line"><span class="built_in">int</span> heapsize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//大顶堆化</span></span><br><span class="line"><span class="built_in">void</span> MAX_HEAPIFY(<span class="built_in">int</span> A[], <span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> l = <span class="number">2</span> * i;<span class="comment">//把 i 的左儿子 下标 赋给l</span></span><br><span class="line"><span class="built_in">int</span> r = <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//把 i 的左儿子 下标 赋给r</span></span><br><span class="line"><span class="built_in">int</span> largest;<span class="comment">//3个里面最大的下标</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (l &lt;= heapsize &amp;&amp; A[l]&gt;A[i])</span><br><span class="line">largest = l;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">largest = i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (r &lt;= heapsize &amp;&amp; A[r]&gt;A[largest])</span><br><span class="line">largest = r;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (largest != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换 A[largest] 和 A[i]</span></span><br><span class="line"><span class="built_in">int</span> tmp = A[largest];</span><br><span class="line">A[largest] = A[i];</span><br><span class="line">A[i] = tmp;</span><br><span class="line"> </span><br><span class="line">MAX_HEAPIFY(A, largest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="built_in">void</span> BUILD_MAX_HEAP(<span class="built_in">int</span> A[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = (<span class="built_in">int</span>)(heapsize / <span class="number">2</span>); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">MAX_HEAPIFY(A, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">printf(<span class="string">"%d "</span>, A[j]);</span><br><span class="line">printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="built_in">void</span> HEAPSORT(<span class="built_in">int</span> A[])</span><br><span class="line">&#123;</span><br><span class="line">BUILD_MAX_HEAP(A);<span class="comment">//ok</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="built_in">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (i = heapsize; i &gt;= <span class="number">2</span>; i--)<span class="comment">//A[1] 必定是最大的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换 A[1] 和 A[i]</span></span><br><span class="line">tmp = A[<span class="number">1</span>];</span><br><span class="line">A[<span class="number">1</span>] = A[i];</span><br><span class="line">A[i] = tmp;</span><br><span class="line"> </span><br><span class="line">heapsize--;</span><br><span class="line">MAX_HEAPIFY(A, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> A[<span class="number">11</span>] = &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//ok</span></span><br><span class="line"><span class="built_in">int</span> n = sizeof(A) / sizeof(<span class="built_in">int</span>) - <span class="number">1</span>;</span><br><span class="line">heapsize = n;</span><br><span class="line"> </span><br><span class="line">HEAPSORT(A);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">printf(<span class="string">"%d "</span>, A[i]);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度： nlogn.但是不稳定</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><a href="https://xinhecuican.github.io/post/63711.html">以前博客</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java I/O</title>
      <link href="/post/5be7e977.html"/>
      <url>/post/5be7e977.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 19:34:07 GMT+0800 (中国标准时间) --><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java.io.InputStream代表字节输入流，java.io.OutputStream代表输出流。他们都是抽象类，InputStream中有以下方法：</p><ul><li>int read():读入一个字节，并且转化成unsigned int型整数</li><li>int read(byte[] b): 从输入流中读取若干字节，保存在b数组中。如果到了输入流的结尾，返回1</li><li>int read(byte[] b, int off, int len): 如上，这里只是多了在b数组中的开始位置和读取数目</li><li>void close()： 关闭输入流。如果不关闭的话其他需要这个文件的就无法读取这个文件信息。类似于打开了一个应用程序再打开就说有一个实例正在运行。</li><li>int available(): 放回从输入流中读取字节数目</li><li>skip(long n): 从输入流中跳过n个字节</li><li>boolean markSupported(),void mark(int readLimit), void reset(): 如果想要重复读入数据，就先用markSupported()判断这个流是否支持重复读入数据，如果支持，通过mark在当前位置开始设置readLimit字节的标记，然后用reset()可以使输入流定位到做标记的起始位置，然后通过read()就可以重复读数据了。</li></ul><p>OutputStream中方法：</p><ul><li>void write(): 输出一个字节</li><li>void write(byte[] b): 同上</li><li>void write(byte[] b, int off, int len): 同上</li><li>void close()</li><li>void flush(): OutputStream本身的flush()不执行操作。但是如果是一些有缓冲区机制的实现类就有用了。在有缓冲区的输出流中，一般都是先把输出存在缓冲区中，等到了一定大小才会输出，<strong>这个方法的作用是强制输出缓冲区中数据</strong>。</li></ul><p>设置缓冲区的原因是输出并不是直接输出到屏幕中间要经历一系列的过程，耗时比较长，如果先存到缓冲区然后一次性输出就可以减少时间。</p><h1 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h1><h2 id="ByteArrayInputStream-字节数组输入流"><a href="#ByteArrayInputStream-字节数组输入流" class="headerlink" title="ByteArrayInputStream,字节数组输入流"></a>ByteArrayInputStream,字节数组输入流</h2><p>这个类从字节数组读取数据，可能会想直接用字符数组不就行了吗，为什么还要弄一个输入流类。ByteArrayInputStream实际上是一个<a href="https://xinhecuican.github.io/post/5951da65.html">适配器</a></p><p>构造方法：</p><p>ByteArrayInputStream(byte[] buf)</p><p>ByteArrayInputStream(byte[] buf, int offset, int length)</p><p>使用就是用上面的方法</p><h2 id="FileInputStream文件输入流"><a href="#FileInputStream文件输入流" class="headerlink" title="FileInputStream文件输入流"></a>FileInputStream文件输入流</h2><p>构造方法：</p><p>FileInputStream(File file)</p><p>FileInputStream(String name):通过name指定路径</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamTester</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span>((data=in.<span class="built_in">read</span>()) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(data+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果文件很大，为了提高读取效率，可以利用一个缓冲区。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        final <span class="keyword">int</span> SIZE = <span class="number">1024</span>;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FIleOutputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">        <span class="keyword">int</span> len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        <span class="keyword">while</span>(len != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out.<span class="built_in">write</span>(buff, <span class="number">0</span>, len);</span><br><span class="line">            len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">        out.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果要打开的文件和这个类在同一文件夹下，可以用Class类的个体ResourceAsStream()方法,<strong>这时可以用相对路径</strong>。例如：</p><p><code>InputStream in = UseBuffer.getClass().getResourceAsStream(&quot;test.txt&quot;);</code></p><h2 id="PipedInputStream管道输入流"><a href="#PipedInputStream管道输入流" class="headerlink" title="PipedInputStream管道输入流"></a>PipedInputStream管道输入流</h2><p>管道输入流是从管道输出流中读取数据的。一般是一个线程从管道中输出，然后另外一个接受。使用管道的优点是如果管道中没有数据就会阻塞，有数据才会恢复运行，这样就可以对产生的数据进行处理。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Sender extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PipedOnputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getPipedOutputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-127</span>; i&lt;=<span class="number">128</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                out.<span class="built_in">write</span>(i);</span><br><span class="line">                <span class="built_in">yield</span>();<span class="comment">//让步给sender处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            out.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="title">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">private</span> PipedInputStream in;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span><span class="params">(Sender sender)</span><span class="keyword">throw</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//通过这个构造方法确定了两者的关系</span></span><br><span class="line">            in = <span class="keyword">new</span> PipedInputStream(sender.getPepedOutputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data;</span><br><span class="line">            <span class="keyword">while</span>((data=in.<span class="built_in">read</span>()) != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(data):</span><br><span class="line">            &#125;</span><br><span class="line">            in.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h2 id="SequenceInputStream-顺序输入流"><a href="#SequenceInputStream-顺序输入流" class="headerlink" title="SequenceInputStream 顺序输入流"></a>SequenceInputStream 顺序输入流</h2><p>它可以把几个输入流混合到一起输入。</p><p>构造方法：</p><p>SequenceInputStream(Enumeration e): e是枚举类型，包含若干个输入流</p><p>SequenceInputStream(InputStream s1, InputStream s2):只合并两个</p><p>它关闭的时候只需要关闭SequenceInputStream就会一次关闭所有的输入流。</p><h2 id="装饰器设计模式"><a href="#装饰器设计模式" class="headerlink" title="装饰器设计模式"></a>装饰器设计模式</h2><p>假设有一个类要子类实现三种方法，并且有的子类只需要实现一个，有的要实现多个，那么就要2^3-1个子类，数量过多。我们可以采用装饰器思想减少子类数目。</p><p>装饰器也是一个子类。这个子类的特殊之处在于他实现了某一个方法并且它内部封装了父类的实例。它的构造方法是：<code>decorate(Base base)</code></p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">B </span><span class="keyword">extends </span>A</span><br><span class="line"></span><br><span class="line"><span class="keyword">B </span><span class="keyword">b </span>= new <span class="keyword">B();</span></span><br><span class="line"><span class="keyword">decorate1 </span>dec1 = new decorate1(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec1.method1();</span></span><br><span class="line"><span class="keyword">decorate2 </span>dec2 = new decorate2(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec2.method2();</span></span><br></pre></td></tr></table></figure></div><h2 id="FilterInputStream-过滤输入流"><a href="#FilterInputStream-过滤输入流" class="headerlink" title="FilterInputStream 过滤输入流"></a>FilterInputStream 过滤输入流</h2><p>过滤输入流其实就是一个装饰器</p><p><strong>种类</strong></p><table><thead><tr><th>过滤输入流</th><th>描述</th></tr></thead><tbody><tr><td>DataInputStream</td><td>与DataOutputStream搭配使用，按照和平台无关的方式从流中读取基本类型（int，char，long等）</td></tr><tr><td>BufferedInputStream</td><td>利用缓冲区提高效率</td></tr><tr><td>PushbackInputStream</td><td>把督导的一个字节压回缓冲区中，编译器用</td></tr></tbody></table><p>这些都是FileterInputStream的子类,并且也是装饰器。</p><h3 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h3><p>它的不同方法可以按不同编码读取数据，并且都是以read开头：</p><ul><li>readByte()</li><li>readLong()</li><li>readFloat()</li><li>readUTF(): 从输入流中读取若干字节，并转化成UTF-8编码字符串</li></ul><p>UTF-8如果是ascii就只用一个字节，如果是其他字符就用两个或两个以上字节。</p><p>DataInputStream应该和DataOutputStream配套使用。只有配套使用才会保证数据的正确性（因为这里的UTF-8是java本土化的UTF-8,本来的UTF-8好像是稳定3个字节的）。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileOutputStream out1 = <span class="keyword">new</span> <span class="type">FileOutputStream</span>();</span><br><span class="line">        BufferedOutputStream out2 = <span class="keyword">new</span> <span class="type">BufferedOutputStream</span>(out1);</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> <span class="type">DataOutputStream</span>(out2);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><p>BufferedInputStream覆盖了读数据的行为，它利用缓冲区提高读取的效率。</p><p>构造方法：</p><ul><li>BufferedInputStream(InputStream in)</li><li>BufferedInputStream(InputStream in, int size):size指定缓冲区大小</li></ul><p>当数据源是文件时，可以用BufferedInputStream装饰数据流，然后再进行其他操作可以提高效率。</p><h3 id="PushbackInputStream"><a href="#PushbackInputStream" class="headerlink" title="PushbackInputStream"></a>PushbackInputStream</h3><p>它有一个后推缓冲区，用于存放已经读入的字节。</p><h1 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h1><p>输出流种类和输入流大致类似，sequenceInputStream对应的没有了，多了ObjectOutputStream。</p><p>ByteArrayOutputStream是把信息输出到字节数组中。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ByteArrayOutputStream <span class="keyword">out</span> = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">out</span>.write(<span class="string">"你好"</span>.getBytes(<span class="string">"UTF-8"</span>);<span class="comment">//String的getBytes可以放回制定类型的编码</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">out</span>.toByteArray();<span class="comment">//获得字符数组的方法</span></span><br><span class="line">        <span class="keyword">out</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>先用write把要输入的数据输入到输出流中，然后通过toByteArray方法输出到字节数组中。</p><p><strong>文件输出流</strong></p><p>前面大致类似，多了一种构造方法<code>FileOutputStream(String name, boolean append)</code></p><p>其中append是为了确定是不是要在末尾追加数据。</p><h2 id="FilterOutputStream-过滤输出流"><a href="#FilterOutputStream-过滤输出流" class="headerlink" title="FilterOutputStream 过滤输出流"></a>FilterOutputStream 过滤输出流</h2><p>同样有DataOutputStream和BufferedOutputStream，大致和输入流类似，多了一种PrintStream类</p><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><p>PrintStream和DataOutputStream类似，都可以输出格式化数据。他有如下方法。</p><ul><li>print(int i): 输出一个int</li><li>print(float i):</li><li>print(String i):</li><li>println(int i): 输出int型数据和换行符</li><li>println(float f):</li><li>println(String s):</li></ul><p>前面提到过，DataOutputStream和DataInputStream最好匹配使用是因为他们使用了特殊化的UTF-8编码。而PrintStream使用的是普通的UTF-8编码。</p><p>PrintStream的print()没有抛出IOException，但是他有checkError()判断写数据是否成功，如果返回true，则代表出现了错误。</p><p>PrintStream自带缓冲区。但是这和BufferedInputStream提供的缓冲区还有所不同。后者只有缓冲区满的时候才会输出，前者可以由用户决定数据量多少的时候输出。当然，默认还是满的时候输出。PrintStream还提供了一个自动化的输出方案：</p><ul><li>PrintStream(OutputStream out, boolean autoFlash)。当满足以下情况就会自动输出<ul><li>输出一个字节数组</li><li>输出一个换行符，即执行print(“\n”)或println()<h1 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader/Writer"></a>Reader/Writer</h1></li></ul></li></ul><p>InputStream和OutputStream处理的是字节，但是在很多场合要处理的是字符（java中字符时2字节）。Reader和Writer就是处理这些的。</p><p>java中字符时Unicode编码，但是文本文件中不一定是Unidcode编码，还有可能是UTF-8，GBK甚至ascii，因此如何处理不同类型编码就是一个难点。</p><p>String的getBytes(String encode)返回特定类型的编码，encode参数指定编码类型。如果不带参数就使用本地操作系统默认编码。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获得本地编码</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">"file.encoding"</span>)</span>);</span><br><span class="line">或：</span><br><span class="line">Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(cs);</span><br></pre></td></tr></table></figure></div><p>Reader类可以把其他类型的编码转换成java所使用的编码。Writer可以把Unicode转换成其他类型的编码。</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>Reader和InputStream类的种类大致类似.</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>CharArrayReader</td><td>把字符数组转换成Reader，从字符数组中读取字符</td></tr><tr><td>BufferedReader</td><td>装饰器，提供缓冲区。同时他的readLine()方法还可以读入一个字符串</td></tr><tr><td>LineNumberReader</td><td>提供缓冲区。并且可以跟踪字符输入流中中的行号</td></tr><tr><td>StringReader</td><td>把字符串转成Reader（数据源是字符串，和CharArrayReader类似），从字符串中读字符</td></tr><tr><td>PipedReader</td><td>连接PipedWriter</td></tr><tr><td>FilterReader</td><td>扩展其他Reader功能</td></tr><tr><td>InputStreamReader</td><td>把InputStream转换成Reader，可以指定数据源编码</td></tr><tr><td>FileReader</td><td></td></tr></tbody></table><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>构造方法：</p><ul><li>InputStreamReader(InputStream in): 按照本地的字符编码解读输入流中的字符</li><li>InputStreamReader(InputStream in, String charsetName): 按照charsetName指定的方式读取输入流中的字符</li></ul><p>这里的read读出来的不是一个字节而是一个字符</p><p>一些常用的方法：</p><ul><li>readLine(),一次读入一行</li><li>readFile(String fileName, String charsetName):从文件中读取字符串，并输出到控制台中</li><li>copyFile(String from, String charsetFrom, String to, String charsetTo): 把原文件复制到目标文件中，可以指定文件编码</li></ul><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>Writer和OutputStream大致类似，也有PrintWriter,区别是PrintStream只能用系统本地编码，而PrintWriter可以使用任意编码。PrintWriter构造方法：</p><ul><li>PrintWriter(Writer writer, boolean autoFlush)</li><li>PrintWriter(OutputStream out, boolean autoFlush)</li></ul><h1 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h1><p>在System类中，有三个静态变量：</p><ul><li>System.in: 代表标准输入流。默认输入时键盘</li><li>System.out: 是PrintStream类型（所以方法和PrintStream一样）。</li><li>System.err: 代表错误输出流，默认输出时输出到控制台。</li></ul><h2 id="对标准输入输出包装"><a href="#对标准输入输出包装" class="headerlink" title="对标准输入输出包装"></a>对标准输入输出包装</h2><p>可以利用到前面所学的只是对标准输入输出进行包装。System.in是InputStream类型，可以先用InputStreamReader变成Reader，然后在用BufferedReader装饰。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> <span class="constructor">InputStreamReader(System.<span class="params">in</span>)</span>;</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> <span class="constructor">BufferedReader(<span class="params">reader</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>重定向方法：</p><ul><li>setIn(InputStream, in): 对标准输入重定向</li><li>setOut(printStream out):</li><li>setErr(PrintStream out):</li></ul><p>这些方法时System的静态方法，所以写的时候是System.setIn()</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void redirect(InputStream <span class="keyword">in</span>, PrintStream out, PrintStream err)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">In(<span class="params">in</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Out(<span class="params">out</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Err(<span class="params">err</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String<span class="literal">[]</span> args)throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    InputStream stdin = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span><span class="keyword">in</span>;<span class="comment">//重定向之后标准输入就变了，所以最好先保存</span></span><br><span class="line">    PrintStream stdout = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out;</span><br><span class="line">    PrintStream stderr = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>err;</span><br><span class="line">    InputStream <span class="keyword">in</span> = <span class="keyword">new</span> <span class="constructor">BufferedInputStream(<span class="string">"D:\\temp.txt"</span>)</span>;</span><br><span class="line">    PrintStream out = <span class="keyword">new</span> <span class="constructor">BufferedOutputStream(<span class="string">"D:\\tempout.txt"</span>)</span>;</span><br><span class="line">    redirect(<span class="keyword">in</span>, out, stderr);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="RandomAccessFile-随机访问文件"><a href="#RandomAccessFile-随机访问文件" class="headerlink" title="RandomAccessFile 随机访问文件"></a>RandomAccessFile 随机访问文件</h1><p>随机访问文件就是可以从文件任意位置读写数据，他有如下定位方法：</p><ul><li>getFilePointer(): 返回当前位置</li><li>seeek(long pos): 设置位置，与未见开头相距pos</li><li>skipBytes(int n): 从当前开始跳过n个字节</li><li>length(): 返回文件包含的字节数</li></ul><p>RandomAccessFile实现了DataInput和DataOutput接口，可以读取格式化数据；</p><ul><li>RandomAccessFile(File file, String mode)</li><li>RandomAccessFile(String name, String mode):name指定路径</li></ul><p>其中mode是访问模式，可以有”r”和”rw”。表示只读和读写，但是”w”是非法的。</p><h1 id="新-I-O库"><a href="#新-I-O库" class="headerlink" title="新 I/O库"></a>新 I/O库</h1><p>这些类位于java.nio包中，nio是newio。他映入了四个数据类型</p><ul><li>Buffer： 缓冲区</li><li>Charset： 把Unicode和其他类型相互转换</li><li>Channel： 数据传送通道，把Buffer内容输出或读入到Buffer</li><li>Selector： 支持异步I/O操作，也叫非阻塞I/O操作</li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>缓冲区有两个作用：</p><ul><li>减少读取次数</li><li>和<a href="https://xinhecuican.github.io/post/7d1c86da.html">高速缓存</a>有关，这一段内存一直被重用。</li></ul><p>层次：<br><img src="/images/java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.jpg" alt></p><p>他有以下属性：</p><ul><li>容量</li><li>极限： 表示当前所使用缓冲区大小.极限可以修改</li><li>位置： 表示<strong>下一个</strong>读写单元位置</li></ul><p>他有如下设置属性方法：</p><ul><li>clear(): 把极限设置成容量，并且把位置变成0</li><li>flip(): 把极限设置成位置，然后把位置变成0</li><li>rewind(): 不改变极限，把位置变成0</li></ul><p>Buffer类是一个抽象类，他有8个具体类。最基本的是ByteBuffer类，他没有公开构造方法，但是有静态工厂。</p><ul><li>allocate(int capacity):</li><li>directAllocate(int capacity): 返回一个直接缓冲区。直接缓冲区速度较快，但是分配所需时间较多，所以一般只在所需空间较大并且长期使用的情况下才会用它。</li></ul><p>除了boolean类型之外，其他类型都有缓冲区（感觉和c的allocate有点类似），例如LongBuffer。此外，还有一种MappedByteBuffer，这是ByteBuffer的子类。它可以把缓冲区和文件某个区域直接映射（输出）。</p><p>共用方法：</p><ul><li>get(): 从当前位置读一个单元，然后位置加*ex位置读一个单元</li><li>put(): 向当前位置写入一个数据，然后位置加1</li><li>put(int index):</li></ul><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel用来连接缓冲区和数据源。它是一个接口，有两个方法：</p><ul><li>close(): 关闭通道</li><li>isOpen(): 判断通道是否打开</li></ul><p>通道会在创建时被打开，一旦被关闭就不能再次打开。</p><p>子接口ReadableByteChannel声明了read(ByteBuffer dst),把数据源数据读入到缓冲区中。WritableByteChannel声明了write(ByteBuffer src)，这个把src缓冲区中的数据输出。</p><p>ByteChannel扩展了上面说的两个接口，可以同时读写</p><p>ScatteringByteChannel扩展了ReadableByteChannel，可以分散读取数据。分散读取是指可以一次把数据放到多个缓冲区中。</p><p>GatheringByteChannel接口扩展了WritableByteChannel,可以把多个缓冲区中的数据一次性输出。他的wirte(ByteBuffer[] srcs)用来输出数据。</p><p><strong>这些方法都是缓冲区没满就继续读入</strong></p><p>FileChannel是Channel的实现类，他实现了ByteChannel，ScatteringByteChannel，GatheringByteChannel接口。支持上面所有操作。但是他没有公开构造方法，但是FileInputStream，FileOutputStream，RandomAccessFile类中提供了getChannel()方法，返回相应的FileChannel对象。</p><h2 id="Charset"><a href="#Charset" class="headerlink" title="Charset"></a>Charset</h2><p>Charset类每个实例代表特定的字符编码类型。他有以下用于编码转换的方法：</p><ul><li>ByteBuffer encode(String str): 把str转换成当前编码</li><li>ByteBuffer encode(CharBuffer cb): 把cb指定的字符缓冲区变成当前编码</li><li>CharBuffer decode(ByteBuffer bb): 把bb指定的ByteBuffer变成Unicode编码</li></ul><p>Charset有一个defaultCharset(): 返回代表本地平台编码的Charset对象。</p><h2 id="FileChannel读写文件"><a href="#FileChannel读写文件" class="headerlink" title="FileChannel读写文件"></a>FileChannel读写文件</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">&#123;</span><br><span class="line">    final <span class="built_in">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    FileChannel fc = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">"你好"</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//向文件末尾添加</span></span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">RandomAccessFile(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.position(fc.size<span class="literal">()</span>);<span class="comment">//定位到文件末尾</span></span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">"朋友"</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    </span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    ByteBuffer buff = <span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>allocate(BSIZE);</span><br><span class="line">    fc.read(buff);</span><br><span class="line">    buff.flip<span class="literal">()</span>;</span><br><span class="line">    Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line">    S</span><br><span class="line">    ystem.out.println(cs.decode(buff));</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><strong>控制缓冲区</strong></p><p>前面说的clear(),flip，rewind看似没用，但是它可以方便我们读入输出数据</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">buff </span>= <span class="keyword">ByteBuffer.allocate(BSIZE);</span></span><br><span class="line"><span class="keyword">while(in.read(buff) </span>!= -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">buff.flip();</span></span><br><span class="line"><span class="keyword"> </span>   out.write(<span class="keyword">buff);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">buff.clear();</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这段代码前面的flip是为了保证只操作当前数据，而clear()是为了保证接受尽可能多的数据。</p><p><strong>字符编码转换</strong></p><p>CharBuffer存放的数据单元室Unicode字符，ByteBuffer中的asCharBuffer()可以把Byte中数据转换成Unicode字符，并且存放在CharBuffer中。</p><h2 id="缓冲区视图"><a href="#缓冲区视图" class="headerlink" title="缓冲区视图"></a>缓冲区视图</h2><p>ByteBuffer类提供了asCharBuffer(),asIntBuffer(),和asFloatBuffer()来生成视图。通过视图，可以读取或写入各种类型的数据。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span>(bb.hasRemaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    bb.rewind();</span><br><span class="line">    CharBuffer cb = bb.asCharBuffer();</span><br><span class="line">    cb.<span class="built_in">put</span>(<span class="string">"你好"</span>);</span><br><span class="line">    whlie(bb.hasremaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h2><p>用于创建和修改那些因为太大而不能放入内存的文件。</p><p>FIleChannel类提供了获得MappedByteBuffer的map方法：</p><ul><li>MappedByteBuffer map(FIleChannel.MapMode mode, long position, long size)</li></ul><p>position是文件映射起始位置，size是映射区域大小，mode是模式，有三种：</p><ul><li>MapMode.READ_ONLY</li><li>READ_WRITE</li><li>MapMode.PRIVATE: 对MappedByteBuffer的修改不会保存到文件中，且其他程序不可见。</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">0x8000000</span>;</span><br><span class="line">    MappedByteBuffer mb = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D:\\test.txt"</span>,<span class="string">"rw"</span>).getChannel()</span><br><span class="line">    .<span class="built_in">map</span>(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, capacity);</span><br><span class="line">    mb.flip();</span><br><span class="line">    System.out.<span class="built_in">println</span>(Charset.forName(<span class="string">"GBK"</span>).decode(mb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h2><p>他允许程序同步访问作为共享资源的文件，但是可能发生同一时间多个线程同时访问的情况，甚至还有可能要和其他进程竞争。所以java中的文件锁是其他线程可见的。</p><p>FileChannel的tryLock()或Lock()用于锁定文件，如果成功放回FileLock对象，如果不成功就立刻返回null。lock()是阻塞式的，如果没有获得线程就会进入阻塞状态。</p><p>也可以部分加锁</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br><span class="line">lock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br></pre></td></tr></table></figure></div><p>上面的shared如果为true表示共享锁，如果是false是排他锁。</p><ul><li>共享锁，如果一个线程获得了共享锁，那么其他线程还可以获得共享锁，但是不能获得排他锁</li><li>排他锁，如果一个县城获得了排他锁，那么其他线程不可以获得共享锁或排他锁。</li></ul><p>可以用FileLock的isShared()判断锁的类型，如果是true，则是共享锁。release()用于释放文件锁。</p><h1 id="自动释放资源"><a href="#自动释放资源" class="headerlink" title="自动释放资源"></a>自动释放资源</h1><p>因为和c++中的delete一样，经常会忘了close(),所以从JDK7开始，绝大多数I/O类都实现了AutoCloseable接口。他会在一定条件下自动关闭：</p><ul><li>定义在try块中，退出try块时会自动调用close()(无论是正常出去还是非正常退出）。</li></ul><h1 id="用File来查看，创建，删除文件目录"><a href="#用File来查看，创建，删除文件目录" class="headerlink" title="用File来查看，创建，删除文件目录"></a>用File来查看，创建，删除文件目录</h1><p>File表示真实系统中的一个文件，他有如下构造方法：</p><ul><li>File(String pathname):</li><li>File(String parent, String child):parent表示根路径，child表示子路径。</li><li>File(File parent, String child)</li></ul><p>一般来说，如果只要处理一个文件，那么使用第一种构造方法，否则就用后面几种。</p><p>还提供管理文件方法：</p><ul><li>boolean canRead().测试程序是否能对进行读操作</li><li>boolean canWrite()</li><li>boolean delete():删除文件，如果删除的是目录并且目录中有东西就不能删除</li><li>boolean exists():看这个文件时候存在</li><li>String getAbsolutePath():获取文件绝对目录</li><li>String getChanonicalPath(): 获取真正的路径，没有<code>.</code>和<code>..</code></li><li>String getName()</li><li>String getParent()</li><li>String getPath(): 相对目录</li><li>String[] list(): 返回当前目录下所有文件列表</li><li>File[] listFiles().返回目录下的所有文件和目录的File对象</li><li>boolean mkdir(): 创建目录</li><li>boolean createNewFile(): 如果FIle表示文件且在当前目录下不存在，就创建</li></ul><h2 id="操作目录树"><a href="#操作目录树" class="headerlink" title="操作目录树"></a>操作目录树</h2><p>Files类： 有移动文件的move(),复制文件的copy()，搜索目录树的find().此外newDirectoryStream()回创建一个目录流，程序可以通过这个目录流遍历整个目录，用walkFileTree()遍历。</p><p>Path接口： 表示一个路径。</p><p>Paths类： 提供创建Path的静态方法，他的get(String first, String… more)返回一个Path对象，这个对象以first为根路径，以more为子路径.例如：<code>Paths.get(&quot;/root&quot;, &quot;dir1&quot;, &quot;dir2&quot;)</code>返回路径<code>/root/dir1/dir2</code>.</p><p><strong>查看zip</strong></p><p>可以通过FileSystems的newFileSystem()创建表示zip文件的FileSystem对象。然后可以用walkFileTree()遍历zip中所有文件。</p><p>其中walkFileTree可以查看官方文档。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lambda（学完stream要来看）</title>
      <link href="/post/d431fab4.html"/>
      <url>/post/d431fab4.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat May 23 2020 21:27:14 GMT+0800 (中国标准时间) --><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names.<span class="keyword">forEach</span>((<span class="type">name</span>)-&gt;<span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span>));</span><br><span class="line">names.<span class="keyword">forEach</span>(<span class="keyword">System</span>.<span class="keyword">out</span>::println);//可以通过这种方式直接调用println</span><br></pre></td></tr></table></figure></div><p>基本语法； <code>(Type1 param1,Type2 param2,...)-&gt;{statment1, statment2... return statmentM;}</code></p><p>一般来讲，这个其实是接口或抽象类的简化。但是不是所有的类都可以使用Lambda的。</p><p>只有声明了函数式接口：<code>public @interface FunctionalInterface</code>才可以被Lambda赋值。这个就是可以简写的原因。通过函数式接口可以直接定位到这个类的某一个函数，然后就可以省略函数名等一系列要素.</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(String <span class="type">name</span>)-&gt;&#123;</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span>);</span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></div><p>这个是基础型，还有许多简化型：</p><ul><li>参数类型可以省略。例如上面可以把String省略，因为一般编译器都可以判断出来</li><li>当参数只有一个时，可以省略小括号（但是私以为还是写上的好，为了统一）</li><li>只有一条语句时，可以省略大括号。并且如果return没有返回值，也可以省略。也就是最前面第一个例子的写法。</li><li>也可以只包含一个普通表达式。语法：<code>(Type val1,Type val2...)-&gt;(expression)</code>。例如：<code>(int a, int b)-&gt;(a*b+2)</code></li></ul><h1 id="用Lambda代替内部类"><a href="#用Lambda代替内部类" class="headerlink" title="用Lambda代替内部类"></a>用Lambda代替内部类</h1><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(()</span>-&gt;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"Hello world!"</span>)).start<span class="literal">()</span>;<span class="comment">//方法1</span></span><br><span class="line"></span><br><span class="line">Runnable race = <span class="literal">()</span>-&gt;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"Hello world!"</span>);<span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(<span class="params">race</span>)</span>.start<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></div><p>上面这个例子完整写法是：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">       <span class="keyword">new</span> Runnable()</span><br><span class="line">       &#123;    <span class="comment">//这是一个Runnable的匿名类</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.<span class="built_in">println</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="comment">//匿名类定义结束</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>至于匿名内部类，<a href="https://xinhecuican.github.io/post/348d4e04.html">可以参考</a></p><p>省去new和类名/接口名。并且直接实现run方法。此外()代表的是接口内部方法的参数，因为run()没有参数，所以这里也不写</p><h1 id="forEach-和排序"><a href="#forEach-和排序" class="headerlink" title="forEach()和排序"></a>forEach()和排序</h1><p>forEach定义： forEach(Consumer&lt;? super T&gt; action);</p><p>其中action实例必须实现Comsumer接口的accept(T t)方法。action指定具体的行为。</p><p>从jdk5开始，集合都实现了Iterable接口。也就是可以使用forEach()</p><p>例如：<code>names.forEach((name)-&gt;System.out.println(name+&quot;,&quot;));</code></p><p>上面的Lambda表达式相当于Consumer的匿名对象。</p><p><strong>排序</strong><br>实际上就是简化了Comparator接口或者其他有关排序接口的写法。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Comparator</span>&lt;<span class="keyword">String&gt; </span>sortByName = (<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>)-&gt;(<span class="built_in">s1</span>.compareTo(<span class="built_in">s2</span>))<span class="comment">;</span></span><br><span class="line"><span class="symbol">Collections.sort</span>(names,sortByName)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="symbol">Collections.sort</span>(names,(<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>)-&gt;(<span class="built_in">s1</span>.compareTo(<span class="built_in">s2</span>)))<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><h1 id="和streamapi联合"><a href="#和streamapi联合" class="headerlink" title="和streamapi联合"></a>和streamapi联合</h1><h1 id="Lambda表达式变量作用域"><a href="#Lambda表达式变量作用域" class="headerlink" title="Lambda表达式变量作用域"></a>Lambda表达式变量作用域</h1><p>Lambda可以访问外部类的所有变量。还可以使用this，这里this引用的是外部类。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">String</span>[] data = &#123;<span class="string">"Tom"</span>, <span class="string">"Mike"</span>, <span class="string">"Mary"</span>&#125;;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; names = Arrays.asList(data);</span><br><span class="line">        <span class="keyword">char</span> var2 = <span class="string">','</span>;</span><br><span class="line">        names.forEach((name)-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            var1++;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="keyword">this</span>.var1+<span class="string">":"</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> A().test();</span><br><span class="line">    |</span><br><span class="line">|</span><br></pre></td></tr></table></figure></div><p>但是要注意一点，只能使用final修饰或者程序中不会改变的局部变量。这个类似于匿名内部类（实际上Lambda有匿名内部类的功能）。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java 泛型</title>
      <link href="/post/70263071.html"/>
      <url>/post/70263071.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu May 21 2020 20:49:10 GMT+0800 (中国标准时间) --><h1 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h1><p>由父类转给子类时允许的，但是会抛出ClassCastException。这种异常是运行时异常，编译期不会检查，这就加大了检查的难度。为了解决这个问题，从jdk5开始引入了泛型。泛型可以把ClassCastException转换成编译时类型不兼容错误。</p><p>泛型符号是&lt;&gt;,里面可以使任意一种类（不能是int等基础类型，可以是Integer).</p><p>例如： <code>Set&lt;Object&gt; set = new HashSet&lt;Object&gt;();//实例中的类型必须要和前面相同</code></p><h1 id="泛型类，数组，接口，方法"><a href="#泛型类，数组，接口，方法" class="headerlink" title="泛型类，数组，接口，方法"></a>泛型类，数组，接口，方法</h1><p><strong>泛型类</strong></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bag</span><span class="params">(T content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Bag&lt;<span class="keyword">String</span>&gt; bag = <span class="keyword">new</span> Bag&lt;<span class="keyword">String</span>&gt;(<span class="string">"mybook"</span>);</span><br><span class="line">        Integer content1 = bag.<span class="built_in">get</span>();<span class="comment">//出错</span></span><br><span class="line">        <span class="keyword">String</span> content2 = bag.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这和c++中的模板十分类似。同样泛型参数可以有许多个，例如：<code>public class A&lt;str,inte,dou&gt;{...}</code></p><p><strong>注意</strong> 如果没有传入泛型实参的话，泛型变量可以使任何类型。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> <span class="constructor">Generic(<span class="string">"111111"</span>)</span>;</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> <span class="constructor">Generic(4444)</span>;</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> <span class="constructor">Generic(55.55)</span>;</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> <span class="constructor">Generic(<span class="params">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.get<span class="constructor">Key()</span>);</span><br></pre></td></tr></table></figure></div><p><strong>泛型接口</strong></p><p>泛型接口和泛型类类似，但是它的实现类如果实现的是泛型接口，那么它的实现类也要是泛型。例如：</p><p><code>public class A&lt;T&gt; implements B&lt;T&gt;</code></p><p>如果<code>public class A implements B&lt;T&gt;</code>会报错</p><p>但是如果实现的是一个确定类型的接口，那么前面就不是必须加</p><p><code>public class A implements B&lt;Integer&gt;</code>可以</p><p><strong>数组</strong></p><p>以前我们都是 int[], double[],现在我们把前面的类型变成泛型。例如<code>T[]</code>。</p><p>这里要注意一点，不能使用泛型创建实例。例如<code>T[] content = new T[10];</code>是错误的。</p><p><strong>方法</strong></p><p>在普通类和泛型类中都可以定义泛型方法。泛型方法只需要在方法头部定义泛型符号就可以了，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    Integer[] b = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    a.printArray(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>感觉泛型方法很方便，直接传入参数就可以了，不用管类型。但是这样势必会增大时间开销。</p><h1 id="extends限定类型参数"><a href="#extends限定类型参数" class="headerlink" title="extends限定类型参数"></a>extends限定类型参数</h1><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> 类名&gt; 必须要是这个类或者子类</span><br><span class="line">&lt;T <span class="keyword">extends</span> 接口名&gt;</span><br></pre></td></tr></table></figure></div><h1 id="使用？通配符"><a href="#使用？通配符" class="headerlink" title="使用？通配符"></a>使用？通配符</h1><p>前面已经说过，实例中泛型类型必须要和定义时泛型类型相同。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; s1 =  <span class="keyword">new</span> HashSet&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; s2 = <span class="keyword">new</span> HashSet&lt;<span class="built_in">Integer</span>&gt;();//报错</span><br></pre></td></tr></table></figure></div><p>为了防止上述错误，可以使用通配符？，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; listInteger = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        listInteger.add(<span class="number">11</span>);</span><br><span class="line">        <span class="built_in">print</span>(listInteger);</span><br><span class="line">        printNew(listInteger);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Collection&lt;Object&gt; collection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj: collection)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNew</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj: collection)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>print会出现问题，因为只能接受Object的泛型类型，后面一个就可以。</p><p>还可以和extends结合。例如：</p><p><code>TreeSet&lt;? extends Number&gt; x = new TreeSet&lt;Integer&gt;();//可以，Integer是Number的子类</code></p><p>这个和前面说的区别是前面是在定义时决定的，这个是在具体写代码时决定的，个人认为这种更为灵活。</p><p>还有super，后面类型只能是前面类型的父类或者他自己。例如：<code>TreeSet&lt;? super Integer&gt; x = new TreeSet&lt;Number&gt;();</code></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>看上去不同的泛型类型导致了不同的类。例如<code>A&lt;Integer&gt;</code>和<code>A&lt;String&gt;</code>是不同的类，但是实际上泛型的类型在编译时期已经赋给内部的变量了，这个时候泛型被擦除了，所以实际上创建实例时还是调用了方法区中的A。</li><li>因为上一条，所以不允许出现名字相同只有泛型类型不同的重载，例如：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"String"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;Integer&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Integer"</span>);</span><br><span class="line">&#125;</span><br><span class="line">会报错</span><br></pre></td></tr></table></figure></div></li><li>不能对确切的泛型使用instanceof符号，例如：<code>Collection cs = new ArrayList&lt;String&gt;(); cs instanceof Collection&lt;String&gt;; 报错</code></li></ul><p>但是如果后面使用通配符就可以，<code>cs instanceof Collection&lt;?&gt;通过</code></p><ul><li>不能使用泛型类型进行强制类型转换，例如：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection cs = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = (ArrayList&lt;<span class="keyword">String</span>&gt;)cs;<span class="comment">//会警告并且运行时容易出现异常</span></span><br></pre></td></tr></table></figure></div></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java 集合，列表，队列，映射</title>
      <link href="/post/d5381517.html"/>
      <url>/post/d5381517.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 25 2020 13:31:40 GMT+0800 (中国标准时间) --><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>Set（集），集合中对象不以特定方式排序（有的实现类可以），没有重复元素</li><li>List(列表），按照索引排序，可以有重复对象。List和数组类似。</li><li>Queue（队列），先进先出</li><li>Map（映射）： 有键值对。没有重复键对象，可以有重复值对象</li></ul><p>定义：</p><p><code>Set&lt;String&gt; set = new HashSet&lt;String&gt;();</code></p><h2 id="Collection-和-Interator接口"><a href="#Collection-和-Interator接口" class="headerlink" title="Collection 和 Interator接口"></a>Collection 和 Interator接口</h2><p>Collection声明了上面这些数据结构（不包含map）通用的方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean add(Object o)</td><td>加入对象</td></tr><tr><td>void clear()</td><td>删除所有对象</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否有特定对象</td></tr><tr><td>boolean isEmpty()</td><td></td></tr><tr><td>Iterator iterator()</td><td>返回一个Iterator对象（<a href="https://xinhecuican.github.io/post/37318.html">迭代器</a>）</td></tr><tr><td>boolean remove(Object o)</td><td></td></tr><tr><td>int size()</td><td>返回数目</td></tr><tr><td>Object[] toArray()<t>T[]toArray(T[] a)</t></td><td>返回一个数组，包含集合中所有元素</td></tr></tbody></table><p>Set接口，List接口，Queue接口都继承了Collection接口。</p><p>Inerator接口定义了如下方法：</p><ul><li>hasNext()：判断集合中的元素是否遍历完毕，如果没有返回true</li><li>next(): 返回下一个元素。例如iter.next()是让iter这个迭代器进一位</li><li>remove(): 删除由next()返回的元素</li></ul><p>如果先用iterator()得到一个Iterator对象后，又用Collection的其他方法，再用next()可能会抛出ConcurrentModifcationException异常。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LISP"><figure class="iseeu highlight /lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; a = new HashSet&lt;Integer&gt;()<span class="comment">;</span></span><br><span class="line">for(<span class="name">int</span> i=0<span class="comment">; i&lt;10; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    a.add(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;Integer&gt; iter = a.iterator()<span class="comment">;</span></span><br><span class="line">while(<span class="name">iter</span>.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="name">iter</span>.next())<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="添加基本类型数据"><a href="#添加基本类型数据" class="headerlink" title="添加基本类型数据"></a>添加基本类型数据</h2><p>实际上集合中只能存放对象。但是经常可以看到list.add(2)之类的操作。实际上在添加的时候已经隐式转换成Integer对象了。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>set本身是不排序的。但是它的实现类TreeSet具有排序功能。</p><h2 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h2><p>当添加一个新的元素时，首先要检查这个对象是否已经存在于集合中。如果存在就不添加。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> Set&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">String</span> s1 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">String</span> s2 = s1;</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(s1);</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(s2);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">set</span>.<span class="built_in">size</span>());</span><br><span class="line">结果放回<span class="number">1</span></span><br></pre></td></tr></table></figure></div><h2 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h2><p>HashSet使用哈希算法存放集合中对象。具有良好的查找和存取性能。</p><p>前面说过在Object类中有hashCode()方法返回哈希值，而这个有使用hash算法存储的，所以判断两个对象是否相等还可以<code>customer1.hashCode() == customer2.hashCode();</code></p><p>如果一个类覆盖了equals()方法，那么就应该实现hashCode()方法，保证党两个对象相等时，hashcode相同。</p><h2 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h2><p>TreeSet类实现了SortedSet接口，可以对集合中对象排序。TreeSet支持两种排序方法：自然排序和客户化排序。默认使用自然排序。</p><p><strong>自然排序</strong></p><p>TreeSet实现了Comparable接口的compareTo(Object o)方法比较集合中对象大小。如果返回值大于0，代表这个值大于o。<strong>只有实现了Comparable接口的对象才可以使用TreeSet进行排序</strong>。compareTo方法最好要从小到大进行排序，以便和其他的进行匹配。</p><p>下面列举了一些实现了Comparable接口的类</p><table><thead><tr><th>类</th><th>排序</th></tr></thead><tbody><tr><td>BigDecimal BigInteger Byte Double Float Integer Long Short</td><td>按数字大小</td></tr><tr><td>Character</td><td>按字符 Unicode值</td></tr><tr><td>String</td><td>按字符串中Unicode值</td></tr></tbody></table><p>如果是自己定义的类，首先要实现Comparable接口。并且最好也是通过返回值大于零小于零来判断谁大谁小的。</p><p>注意，如果把一个对象加入TreeSet并且修改它的属性TreeSet是不会重新排序的。所以适合排序的是不可变类。</p><p><strong>客户化排序</strong></p><p>客户化排序可以降序排序。首先实现java.util.Comparator<t>接口。Comparator有个compare(T x, T y)方法用于比较两个对象的大小，如果返回值大于0，表示x&gt;y。</t></p><p>如果想实现降序排序，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">CustomerComparator</span> <span class="symbol">implements</span> <span class="symbol">Comparator</span>&lt;<span class="symbol">Customer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> compare(Customer c1, Customer c2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c1,getName().compareTo(c2.getName())&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c1.getName().compareTo(c2.getName())&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Set&lt;Customer&gt; <span class="keyword">set</span> = new TreeSet&lt;Customer&gt;(new CustomerComparator());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Set有个构造方法 Set(Comparator comparaotr)可以使用Comparator来确定升序还是降序。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>list的实现类有：</p><ul><li>ArrayList： ArrayList代表长度可变数组。ArrayList实现了RandomAccess接口，这个接口不包含任何方法，仅仅表示有良好的随机访问性能。</li><li>LinkedList： 链式结构。LinkedList不仅仅可以做数组，还可以做堆栈，队列，双向队列。</li></ul><h2 id="访问元素和排序"><a href="#访问元素和排序" class="headerlink" title="访问元素和排序"></a>访问元素和排序</h2><p>list中get(int index)方法可以返回集合中索引位置的数。List中的iterator()和Set中的iterator()一样，也可以用来遍历。</p><p>此外，还可以用foreach来遍历</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LESS"><figure class="iseeu highlight /less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">for</span>(Integer <span class="attribute">i</span>: list)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.print</span>(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>至于排序，只能对集合中的对象按索引进行排序，如果想用其他方式，可以实现collections类和Comparator接口。Collections类中的sort方法可以用来排序</p><ul><li>sort(List list) 对List对象进行自然排序</li><li>sort(List list, Comparator comparator)进行客户化排序</li></ul><h2 id="ListIterator-接口"><a href="#ListIterator-接口" class="headerlink" title="ListIterator 接口"></a>ListIterator 接口</h2><p>List中listIterator()返回一个ListIterator对象，这个对象继承了Iterator接口，此外还有一些独有的方法</p><ul><li>add() 向列表中插入一个元素</li><li>hasNext() 判断列表中是否还有下一个元素</li><li>hasPrevious(): 判断列表中是否还有上一个元素</li><li>next(): 返回下一个元素</li><li>previous(): 返回上一个元素</li></ul><p>![](/images/java 集合，列表，队列，映射.jpg)</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue提供了add()和offer()两种方法来从队尾加元素，如果是add队满就会抛出IllegalStateException，如果是offer()会返回false。</p><p>删除也有两种，一种是remove()，一种是poll()。如果是remove，队空后会跑出NoSuchElementException，如果是poll，空了会返回null</p><p>获取元素，一种是element(),一种是peek().如果不成功（队空），那么会出现和删除队空同样的情况。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deque是一个接口</p><p>从头或尾添加元素</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addFirst</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="function"><span class="title">addLast</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">offerFirst</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">offerLast</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br></pre></td></tr></table></figure></div><p>如果队满，都会抛出IlllegalStateException.后两种方法返回false</p><p>删除</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">E</span> <span class="function"><span class="title">removeFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">removeLast</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">pollFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">pollLast</span>()</span></span><br></pre></td></tr></table></figure></div><p>和前面队空判断一样</p><p>获取</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">E</span> <span class="function"><span class="title">getFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">getLast</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">peekFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">peekLast</span>()</span></span><br></pre></td></tr></table></figure></div><p>就是把上面的queue加了个first和last</p><p>LinkedList和ArrayList都实现了Deque接口，</p><h2 id="PriorityQueue-优先队列"><a href="#PriorityQueue-优先队列" class="headerlink" title="PriorityQueue 优先队列"></a>PriorityQueue 优先队列</h2><p>优先队列使用堆进行排序。并且因为要排序，所以想用优先队列要首先实现Comparable接口。</p><p>这里的remove总会首先删除最小的元素。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>定义： Map&lt;type1, type2&gt; map = new HashMap&lt;type1, type2&gt;();</p><p>其中type1是键类型，type2是值类型。</p><p>Map叫映射，就是给出键返回值。可以使用get(Object key)得到值。通过put(Object key, Object value)插入键值对。</p><p>Map的键不允许有重复，但是值可以有重复。</p><p>Map有两种常用实现，HashMap和TreeMap，HashMap用哈希算法来存取键对象，有良好的取性能。为了保证能正常工作，也要确保通过equals()比较为true时，两个对象返回哈希码相同。</p><p>TreeMap实现了SortedMap接口，可以对键进行排序。如果想进行客户化排序，可以调用TreeMap(Comparator comparator)构造函数。</p><p>Map的keySet()返回所有键对象的集合。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; <span class="keyword">set</span> = map.entrySet();<span class="comment">//注意</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iter = <span class="keyword">set</span>.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>=<span class="number">0</span></span><br><span class="line"><span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>=<span class="number">2</span></span><br><span class="line"><span class="number">3</span>=<span class="number">3</span></span><br><span class="line"><span class="number">4</span>=<span class="number">4</span></span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">6</span>=<span class="number">6</span></span><br><span class="line"><span class="number">7</span>=<span class="number">7</span></span><br><span class="line"><span class="number">8</span>=<span class="number">8</span></span><br><span class="line"><span class="number">9</span>=<span class="number">9</span></span><br></pre></td></tr></table></figure></div><p>set内的类型是Map.Entry,可以使用getKey()返回键，使用getValue()返回值。</p><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>适用于List的方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STATA"><figure class="iseeu highlight /stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span>(<span class="keyword">List</span> dest, <span class="keyword">List</span> src): 把一个<span class="keyword">list</span>复制到另一个<span class="keyword">list</span>中</span><br><span class="line">fill(<span class="keyword">List</span> <span class="keyword">list</span>,Object o) 想列表中填充元素</span><br><span class="line"><span class="keyword">sort</span>(<span class="keyword">List</span> <span class="keyword">list</span>) 排序</span><br><span class="line">binarySearch(<span class="keyword">List</span> <span class="keyword">list</span>, Object key) 如果有序就可以用这个</span><br><span class="line">shuffle(<span class="keyword">List</span> <span class="keyword">list</span>): 对<span class="keyword">List</span>中元素随机排列</span><br></pre></td></tr></table></figure></div><p>适用于Map或Collection的：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> max(Collection coll):返回集合中最大的元素</span><br><span class="line"><span class="built_in">Object</span> max(Collection coll, Comparator comp):采用指定规则进行比较，返回最大元素</span><br><span class="line"><span class="built_in">Object</span> min(Collection coll)</span><br><span class="line"><span class="built_in">Object</span> min(Collection coll, Comparator comp)</span><br><span class="line"><span class="built_in">Set</span> singleton(<span class="built_in">Object</span> o): 返回一个不可变的<span class="built_in">Set</span></span><br><span class="line"><span class="built_in">List</span> singletonList(<span class="built_in">Object</span> o) 返回不可改变的<span class="built_in">List</span></span><br><span class="line"><span class="built_in">Map</span> singletonMap（<span class="built_in">Object</span> key, <span class="built_in">Object</span> value):</span><br><span class="line">Collection synchronizedCollection(Collection c): 在原来的基础上，返回支持同步的集合</span><br><span class="line"><span class="built_in">Map</span> synchronizedMap(<span class="built_in">Map</span> m)</span><br><span class="line"><span class="built_in">Set</span> ...</span><br><span class="line"><span class="built_in">List</span> ...</span><br><span class="line">Collection unmodifiableCollection(Collection c): 在原来结合的基础上，返回不可改变的集合视图</span><br><span class="line">其他三个相同</span><br></pre></td></tr></table></figure></div><p>前面的singleton是指这个集合中只有一个元素，并且不允许修改</p><p>而后面的unmodifiable是返回这个集合，但是如果原集合修改，这个集合也会跟着修改。不允许修改指的是不允许修改这个集合视图</p><p><strong>线程安全的集合</strong></p><p>在平常情况下集合的实现类都没有同步锁机制，这样可以加快速度。但是当有多个线程同时操作一个锁的时候就需要同步机制了。一种方式就是在可能导致问题的代码块用synchronized，另一种就是上面讲的方法。</p><h1 id="集合批量操作"><a href="#集合批量操作" class="headerlink" title="集合批量操作"></a>集合批量操作</h1><p>前面说的都是一次处理一个元素，如果要处理多个元素，可以采用Collection中的方法：</p><ul><li>boolean retainAll(Collection&lt;?&gt; c)修改集合，保留在c中的元素并删去其他元素</li><li>boolean removeAll(Collection&lt;?&gt; c)删去集合中c的元素。</li><li>boolean addAll(Collection&lt;? extends E&gt; c): 把c中元素加入到当前集合中</li><li>boolean containsAll(Collection&lt;?&gt; c): 判断当前集合是否全部包含c</li></ul><h1 id="其他集合类"><a href="#其他集合类" class="headerlink" title="其他集合类"></a>其他集合类</h1><p>Properties是一种特殊的Map类。他可以用load()从输入流中读取键和值。例如；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties ps = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span><br><span class="line">InputStream <span class="keyword">in</span> = <span class="module-access"><span class="module"><span class="identifier">PropertiesTester</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ResourceAsStream(<span class="string">"myapp.properties"</span>)</span>;</span><br><span class="line">ps.load(<span class="keyword">in</span>);</span><br><span class="line"><span class="keyword">in</span>.close<span class="literal">()</span>;</span><br><span class="line">print(ps);</span><br><span class="line">ps=<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Properties()</span>;</span><br><span class="line">print(ps);</span><br></pre></td></tr></table></figure></div><p>可以使用System.getProperties()返回一个Propertiese对象。这个对象中包含一系列系统属性。</p><p>BitSet表示一组boolean数据集合。类似于boolean[]数组。最小初始容量是64位，可以通过BitSet(int bits)设置初始容量。如果达到了初始容量会自动增加。</p><p>BitSet中有以下方法：</p><ul><li>set(int index) 把index位置的元素设置成true</li><li>clear(int index) 把index位置的元素设false</li><li>get(int index): 获得index位置的元素值</li><li>and(BitSet bs): 与bs进行与运算，结果保存在当前BitSet中</li><li>or(Bitset bs)</li><li>xor(BitSet bs)</li></ul><p>BitSet在c++中是返回二进制信息，在这里也可以有这个作用。可以自己建立byteToBitSet()计算出byte类型的二进制位，其他类型类似。printBitSet()打印BitSet二进制信息。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte </span>a = <span class="number">125</span>;</span><br><span class="line"><span class="keyword">short </span><span class="keyword">b </span>= -<span class="number">125</span>;</span><br><span class="line">int c = -<span class="number">125</span>;</span><br><span class="line">long d = <span class="number">125</span>;</span><br><span class="line">printBitSet(<span class="keyword">byteToBitSet(a), </span><span class="keyword">BYTE_SIZE);</span></span><br><span class="line"><span class="keyword">printBitSet(shortToBitSet(b), </span><span class="keyword">SHORT_SIZE);</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure></div><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>位置： java.lang.Enum。这个类是抽象类</p><p>此外，还提供了关键字enum。例如 public enum Gender{FEMALE, MALE}</p><p>Enum类有如下非抽象方法（一般直接使用enum就可以了，也有这些)：</p><ul><li>intcompareTo(E o) 比较当前常量与指定对象的顺序</li><li>Class<e>getDeclaringClass()返回当前类型的class对象</e></li><li>String name() 返回当前枚举常量的名称。例如调用Gender.FEMALE的name()方法，会返回FEMALE</li><li>intordinal() 返回当前枚举常量在声明时的位置</li><li>toString() 返回枚举常量的名称</li><li><code>static&lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)</code>返回制定枚举类型和名称返回的枚举常量</li><li>static Enum[] values() 以数组的方式返回所有的枚举常量</li><li>range(from， to)用来迭代</li></ul><p>range用法例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">for(WeekDayEnum</span> <span class="string">day : EnumSet.range(WeekDayEnum.Mon, WeekDayEnum.Fri)) &#123; </span></span><br><span class="line">    <span class="meta">System.out.println(day);</span> <span class="string"></span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">输出</span></span><br><span class="line"><span class="attr">Mon</span> <span class="string"></span></span><br><span class="line"><span class="attr">Tue</span> <span class="string"></span></span><br><span class="line"><span class="attr">Wed</span> <span class="string"></span></span><br><span class="line"><span class="attr">Thu</span> <span class="string"></span></span><br><span class="line"><span class="attr">Fri</span></span><br></pre></td></tr></table></figure></div><p>枚举类型最大的作用就是可以用于switch，相当于扩充了switch的范围。</p><h2 id="枚举类型构造方法"><a href="#枚举类型构造方法" class="headerlink" title="枚举类型构造方法"></a>枚举类型构造方法</h2><p>这个构造方法时private，或friendly类型的，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Gender</span><br><span class="line">&#123;</span><br><span class="line">    MALE(<span class="string">"男性"</span>),</span><br><span class="line">    FEMALE(<span class="string">"女性"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> description;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Gender</span><span class="params">(<span class="keyword">String</span> description)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Gender g = Gender.valueOf(<span class="string">"FEMALE"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (g)<span class="comment">//必须要是实例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.<span class="built_in">println</span>(g.getDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.<span class="built_in">println</span>(g.getDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意前面定义时的符号，如果是基础类型，那么最后一个不用跟任何符号，如果不是，那么最后一个必须要封号。并且前面只能是逗号</p><p>enum是构造对象时产生的，因此看起来相同的两个类型实际上比较时也可能不相同。</p><h2 id="EnumSet和EnumMap"><a href="#EnumSet和EnumMap" class="headerlink" title="EnumSet和EnumMap"></a>EnumSet和EnumMap</h2><p>前面一个把枚举转化成集合，它的静态allOf()方法把枚举类所有常量实例存放到一个EnumSet类型的集合中，然后放回这个集合。</p><p>EnumMap转换成映射，它的EnumMap(Class<k>keyType)来指定具体的枚举类型。枚举常量以key的方式存到Map中。例如：</k></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EnumSet&lt;WeekDayEnum&gt; <span class="built_in">subset</span> = EnumSet.of(WeekDayEnum.Mon, WeekDayEnum.Wed); </span><br><span class="line">     <span class="keyword">for</span> (WeekDayEnum <span class="built_in">day</span> : <span class="built_in">subset</span>) &#123; </span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="built_in">day</span>);  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java 数组</title>
      <link href="/post/325cdbf2.html"/>
      <url>/post/325cdbf2.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>可以这样声明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] scores<span class="comment">;</span></span><br><span class="line">String[] names<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>也可以这样声明</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int scores[]<span class="comment">;</span></span><br><span class="line">String names[]<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>二维更为古怪</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-attr">[]</span><span class="selector-tag">x</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-tag">x</span><span class="selector-attr">[]</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">x</span><span class="selector-attr">[]</span><span class="selector-attr">[]</span>;</span><br></pre></td></tr></table></figure></div><p>这里注意一点，声明时不能往括号中加东西，会报错。例如：<code>int x[1];//报错</code></p><p>java中推荐吧括号放到前面，可能int[]也成了一个对象？</p><h2 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h2><p>创建数组对象语法和c++中创建动态数组类似。</p><p><code>int[] scores = new int[100];</code></p><p>上面这个代码首先要在堆中分配空间，然后把里面的数据初始化。</p><p>括号中的数字可以使常量，也可以是变量，甚至可以是0(表示里面没有数据).</p><h2 id="访问数组的元素和长度"><a href="#访问数组的元素和长度" class="headerlink" title="访问数组的元素和长度"></a>访问数组的元素和长度</h2><p>和c++一样，下标索引。如果越界，会抛出ArrayIndexOutOfBoundsException异常</p><p>所有数组都有length属性，表示数组的长度: <code>public final length</code>.</p><p>所以我们可以直接输出这一属性，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x<span class="literal">[]</span> = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="number">40</span>]</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.length); <span class="comment">//输出length</span></span><br></pre></td></tr></table></figure></div><p>如果是对象数组，那么数组中的元素时对象的引用，因此当我们不使用数组的时候最好把值赋null触发垃圾回收机制。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> sb = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">String</span> sbs[] = <span class="keyword">new</span> <span class="built_in">String</span>[](sb,<span class="keyword">null</span>);</span><br><span class="line">...</span><br><span class="line">sbs[<span class="number">0</span>] = <span class="keyword">null</span>;<span class="comment">//清除数组对象的引用</span></span><br><span class="line">sbs = <span class="keyword">null</span>;<span class="comment">//清除数组引用</span></span><br></pre></td></tr></table></figure></div><h2 id="多维数组和不规则数组"><a href="#多维数组和不规则数组" class="headerlink" title="多维数组和不规则数组"></a>多维数组和不规则数组</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[<span class="string"></span>][<span class="symbol"></span>] rooms = new String[<span class="string">2</span>][<span class="symbol"></span>];</span><br><span class="line">rooms[<span class="string">0</span>] = new String[]("Tom","Mike");</span><br><span class="line">rooms[<span class="string">1</span>] = new String[]("Mary");</span><br></pre></td></tr></table></figure></div><p>可以用不等长数组是因为每一行都是一个数组元素，都有自己的length变量</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;rooms.<span class="built_in">length</span>; <span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">0</span>; k&lt;rooms[<span class="built_in">i</span>].<span class="built_in">length</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(rooms[<span class="built_in">i</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>第一个循环的length是rooms引用多少个数组，rooms[]指的是每个数组的长度。</p><p>要注意只有最后一个括号可以不加数字，我的理解是只有最后一层才是真正的数组对象，才有length，同时，前面不确定就不知道要开多少个数组对象。</p><h2 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h2><p>在c++中数组是不能作为返回值的，因为c++中数组是一个指针，而又不能像其他指针一样确定它的大小。而在java中数组是一个对象，可以返回它的引用。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>平常我们想找某一个值都是通过遍历数组得到的，我们也可以用值通过某种映射关系得到在数组中的位置。这就是哈希表</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>%<span class="number">10</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个例子中value就是值，返回的是下标。但是这时如果超过十就会出现重复，这叫做哈希冲突。我们可以设计更复杂的映射来处理哈希冲突。</p><p>判断重复的条件是 object1.equals(boject2)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    private</span> Object value;</span><br><span class="line">    private <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(Object</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getValue()</span><br><span class="line">    &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">Node</span> <span class="title">getNext</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNext(<span class="keyword">Node</span> <span class="title">next</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyhashSet</span><br><span class="line">&#123;</span><br><span class="line">    private <span class="keyword">Node</span><span class="title">[] array</span>;</span><br><span class="line">    private int size = <span class="number">0</span>;//数组元素数目</span><br><span class="line">    public MyHashSet(int length)</span><br><span class="line">    &#123;</span><br><span class="line">        array = new <span class="keyword">Node</span><span class="title">[length</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    public int size()</span><br><span class="line">    &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int hash(Object o)//哈希算法</span><br><span class="line">    &#123;</span><br><span class="line">        int h = o.hashCode();//Object类中有这个方法</span><br><span class="line">        h += ~(h <span class="tag">&lt;&lt; 9);</span></span><br><span class="line"><span class="tag">        h ^= (h &gt;</span>&gt;&gt; <span class="number">14</span>);</span><br><span class="line">        h += (h <span class="tag">&lt;&lt; 4);</span></span><br><span class="line"><span class="tag">        h ^= (h &gt;</span>&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int indexFor(int hashCode)</span><br><span class="line">    &#123;</span><br><span class="line">        return hashCode &amp; (array.length-<span class="number">1</span>);//返回索引</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void add(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">newNode</span> = new <span class="keyword">Node</span><span class="title">(value</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array(index);</span><br><span class="line">        if(<span class="keyword">node</span> <span class="title">== null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            array(index) = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        else//处理哈希冲突</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">Node</span> <span class="title">nextNode</span>;</span><br><span class="line">            while(!<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value) &amp;&amp;</span><br><span class="line">            (nextnode = <span class="keyword">node</span>.<span class="title">getNext</span>()) != null)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= nextNode</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //不允许加入重复元素</span><br><span class="line">            if(!<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">node</span>.<span class="title">setNext</span>(newNode);</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //测试是否有这个对象</span><br><span class="line">    public boolean contains(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array[index];</span><br><span class="line">        while(<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; !<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">node</span> <span class="title">= node</span>.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">!=null</span> &amp;&amp; <span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean remove(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array[index];</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">!=null</span> &amp;&amp; <span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            array[index] = <span class="keyword">node</span>.<span class="title">getNext</span>();</span><br><span class="line">            size--;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">Node</span> <span class="title">lastNode</span> = null;</span><br><span class="line">        while(<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; !<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            lastNode.setNext(<span class="keyword">node</span>.<span class="title">getNext</span>());</span><br><span class="line">            size--;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object[] getAll()</span><br><span class="line">    &#123;</span><br><span class="line">        Object[] values = new Object[size];</span><br><span class="line">        int index = <span class="number">0</span>;</span><br><span class="line">        for(<span class="keyword">Node</span> node:<span class="title"> array</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            while(<span class="keyword">node</span> <span class="title">!= null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                values[index++] = <span class="keyword">node</span>.<span class="title">getValue</span>();</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= node</span>.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p>java.util.Arrays类，有一系列操作数组的方法。这是一个私有类</p><p>静态方法：</p><ul><li>equals(): 比较两个数组是否相同</li><li>fill(): 向数组中填充数据</li><li>sort(): 把数组升序排列</li><li>parallelSort(): 开启多个线程，以并发的方式对数组中元素进行排序，提高效率</li><li>asList()把一个数组变成List</li></ul><p>例： Arrays.sort(a);</p><h1 id="用-…-声明数目可变参数"><a href="#用-…-声明数目可变参数" class="headerlink" title="用 … 声明数目可变参数"></a>用 … 声明数目可变参数</h1><p>可以用int… a代替 int[] a;这种模式下如果输入立即数可以转化成数组类型：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>... datas)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//可以直接输入数据</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure></div><p>但是必须要放在参数列表的最后一位</p><p>```<br>pubilc void max(int… data, String p)//错误，int… 必须放在最后<br>{<br>…<br>}</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存</title>
      <link href="/post/f79e4123.html"/>
      <url>/post/f79e4123.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 14:30:29 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>我们在生成程序的时候，会发现每个程序的起始地址都是一样的，那么这种一样的地址怎么赋给实际的物理地址上的呢？这就要依靠虚拟内存机制了。</p><p>虚拟内存着力于解决进程间内存分配的问题，并且它还有一个作用是使进程之间相互隔绝。例如不小心产生了一个野指针指向了其他内存的位置，但是实际上却不会破坏其他程序而只会破坏自己的程序，这是因为虚拟内存限制了每个程序所使用的空间，如果超出限制就会报错。</p><p>程序中所使用的空间叫做虚拟空间，一共有2的n次方。而系统上有一个物理地址空间。虚拟内存做的其实是把虚拟空间上的内存地址映射到物理空间上。在cpu中，有一个叫MMU的部件专门做虚拟地址和物理地址转化。</p><h1 id="虚拟内存的组织形式"><a href="#虚拟内存的组织形式" class="headerlink" title="虚拟内存的组织形式"></a>虚拟内存的组织形式</h1><p>虚拟内存中的内存其实是按页进行划分的。这类似与磁盘中的扇区概念，即使那个扇区中只有一个字节的数据，取数据时也是把一个扇区全取出来。</p><p>虚拟内存页的大小一般是4kb到2mb之间。而物理内存也是按页进行分块，并且块的大小和虚拟内存页的大小相同。</p><p>其实把程序加载到内存时也不是一股脑直接加载的，而是一块一块逐个加载，并且如果内存满了还有块替换策略，这实质上是把内存当做一级缓存使用。</p><p>虚拟页有三种情况：</p><ul><li>未分配的， 这部分内存就是虚拟内存预留出来的部分，例如malloc使用的空间，各个段之间预留出来的空间等。</li><li>缓存的， 就是加载到内存中的</li><li>未缓存的，是程序的组成部分但是还没有加载到缓存中。</li></ul><p>由于磁盘访问速度过慢（比SRAM小100000倍），所以我们要尽可能的降低未命中率。第一个办法就是增大每一块的大小（所以才会有一块甚至到2mb，有的小程序都没这么大）。第二个办法是全相连。全相连可以极大降低冲突不命中概率。第三个是使用复杂的块替换策略，这和缓存不同，因为缓存和内存之间速度也就十倍差距，所以块替换策略越简单越好，但是内存与磁盘间不命中惩罚太大，大到情愿花一些时间来找那个最不可能被替换掉。最后是使用回写策略。 <a href="https://xinhecuican.github.io/post/7d1c86da.html">缓存</a></p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>页表是存放于物理内存中的，页表中中的内容代表虚拟内存中这片地址是否被使用，如果被使用，还要存放实际的物理地址。</p><p>页表的大小是由虚拟内存大小和页大小决定的。假设虚拟内存大小矢2的n次方，页大小矢2的p次方，那么页表就有2的n-p次方条。这实际上是一种以空间换时间的策略。每个进程都有一个页表。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt></p><p>上图中左边就是页表，右下角代表磁盘。页表中灰色代表未缓存，未缓存的地址就指向磁盘。而白色代表未分配，地址直接是NULL。如果我们访问0，因为0是未缓存并且内存已满，所以要替换一块下来，假设替换第四块，那么就要把页表中三的地址给改为内存中的物理地址并且把4的地址改为磁盘中的地址。</p><p>所以当我们访问内存时，如果访问到未加载的地址，那么会触发<a href="https://xinhecuican.github.io/post/28877bf.html#more">故障异常</a>,故障异常就会把磁盘中的内存加载进来并且重新执行这条指令。</p><p>如果我们加载到页表地址是NULL的地方，那么就会抛出segmentation fault。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.PNG" alt></p><p>通过页表，我们可以让物理内存彼此分离。并且还可以让两个进程数据共享，这也使动态库可能实现。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.PNG" alt></p><p>虚拟内存还提供了安全保护机制</p><p>这个是比较完整的页表，其中多了一些权限位。后面三个是读写和执行标志位，如果读的时候没有权限，那么就会抛出保护异常，这种异常一般都会终止程序。</p><p>第一个是模式标志位。有些操作系统专有的指令用户不能执行，有些专用寄存器用户不能访问。例如关机的指令即使用户特意编写也不会执行，因为它没有权限。</p><p>操作系统下的内存空间普通用户是没有办法去访问的。如果想调用操作系统的函数，可以使用陷阱异常，产生陷阱异常时，会转到特权模式。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>首先虚拟地址的低p位是页内偏移，因为虚拟内存页的大小和实际内存页的大小相同，所以二者偏移量相同。虚拟地址高n-p位是页号。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%984.PNG" alt></p><p>这张图表示了大致过程。cpu发出虚拟地址，mmu把地址解析成两部分。然后从内存中取出对应页号的地址（cpu中有页的基地址寄存器，页地址是根据页号*每页的大小+基地址得出）。然后mmu又根据取回来的页决定是否要去取内容。如果取，那么这个页中包含了物理页号，然后根据物理页号和偏移量得出实际地址。</p><p>如果标志位是0，那么还要到磁盘中去取出对应页放到内存中并且更新页表。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%985.PNG" alt></p><p>虚拟内存最大的问题就是显著增加了访问时间，本来只要访问一遍的现在要访问两遍。所以在mmu中又加了tlb寄存器专门用来存放页表。现在访问页表不用找内存了，直接找这个寄存器就可以了。如果没有找到再去内存中找并且更新tlb。</p><p>但是现代cpu都是多进程的。每个进程都有自己独立的页表，即使对应的内存相同可能标志位不同，也就是说每次更换进程都要把tlb清空一遍。一种解决办法是传给tlb页号的同时也传递一个进程信息，tlb也储存一个进程信息。</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>假设虚拟内存大小是2的48次方，每页大小矢4kb，每个页表项8字节，那么页表大小矢2的39次方也就是512G。这在现实中显然是不可能实现的，所以要想办法把页表压缩。</p><p>我们很容易想到的一个办法是那些未分配的虚拟内存就不要建立页表项了，但是这样会带来一个问题。原来我们在查找页表的时候都是直接寻址，这是因为假设页表中每一项都存在，现在我们有一些项缺失了，直接根据页号查表的方法也就不行了，只有一个个比对，这样有增大了时间消耗。</p><p>我们可以建立一个多级页表，外层页表每一个页表项缓存的比较大，例如2mb甚至4Gb等，然后这一项中的内容不是物理页号，而是下一级页表的地址，之后下一级页表比上一级小，到最后一级就存储物理页号。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.jpg" alt></p><p>如上图，最外面一层就占着最高位，然后依次递减。这是因为一旦最外层选中了就说明最高几位是那几号，那么就不用管了。</p><p>这样看起来好像是用空间并没有减少，因为到最后一层还是要建立，并且中间几层还要额外消耗空间。实际上如果某个缓存块是未分配的，那么就不会建立下一级页表了。而外面几层页表锁包含的比较大，这样一下就可以排除几百个G的未分配空间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先补充一下前面tlb结构。tlb也是一个缓存并且是组相联结构，这就代表着传递信息中必须要包含组号，然后剩余的是标志位。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.jpg" alt></p><p>上图中tlbi就是组号，前面的是标志位。mmu传给tlb的只有vpn。</p><p>先是cpu发出虚拟内存地址，然后mmu开始解析，解析处vpn传给tlb，如果tlb解析成功那么再传给mmu物理页号并与vpo合成成物理地址。之后在把物理地址发给缓存。按缓存的方式处理。</p><p>如果tlb未命中，那么会到内存系统（包括缓存）中用页表基地址寄存器（CR3）找到最外层的页表然后一层层解析找到物理页号，然后把页号发给mmu的同时缓存那一片区域给tlb。</p><p>如果内存系统中也没有命中（未缓存或者未分配），那么就出触发缺页异常，通过缺页异常判断是未分配还是未缓存还是其他情况。</p><p>缺页异常时判断与一个链表有关。我们知道虚拟内存时分为若干个段的，每个段都有起始地址和终止地址还有一些权限标志位，这个链表就是存放这些信息。当2发生缺页异常时，会判断这个地址是否是在这些段中，如果不在，那么直接抛出Segmentation Fault。如果在那么判断标志位，如果判断不成功会抛出保护异常，如果判断成功了然后再去磁盘中取数据。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异常处理</title>
      <link href="/post/28877bf.html"/>
      <url>/post/28877bf.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 25 2020 13:31:40 GMT+0800 (中国标准时间) --><h3 id="产生过程"><a href="#产生过程" class="headerlink" title="产生过程"></a>产生过程</h3><p>当程序运行时，可能会产生异常，当cpu检测到这些时间发生时，就会通过异常表跳转到异常处理程序，然后进行处理。</p><p>异常表示常驻于内存中的，每个异常都有一个异常号，事件发送的是异常号，之后根据异常号找到异常表中的对应项再跳转过去。异常表的首地址存放在一个特殊的寄存器中。</p><p>当一场处理结束之后，可能会跳转到下一条语句，可能跳转到当前语句，也可能终止程序。</p><p>要注意，这里讲的异常是系统提供的异常，要把用户程序中设定的异常区分开。</p><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是用来和外部设备进行交互的，例如网卡，usb和磁盘。</p><p>每当这些设备有操作完成时，都会发给cpu一个信号叫cpu去取数据（cpu上有一个特殊的引脚专门去接受这些数据）。之后cpu就会执行中断程序然后去取数据。</p><p>一个显著的例子就是scanf，cpu不可能一到scanf就停止运行，肯定还要继续做各种各样的事。他只是调用了scanf函数给标准输入发出信号，有数据来了就告诉我。之后标准输入输入完成之后并不是直接存到内存中，而是先存到一个缓存中（例如键盘有usb缓存），然后告诉cpu要读数据，cpu才会执行中断去读数据。</p><p>执行中断程序之前，首先要把所有寄存器的值都保护好，之后才去执行。</p><h4 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h4><p>陷阱又叫系统调用。它是一种故意的中断，是执行一条指令的结果。执行完后回到下一条指令。</p><p>这是用户向系统请求服务，例如读文件，打开文件，创建文件，终止进程等。</p><p>系统提供了syscall n 指令专门用来调用这些功能。当这条指令执行时，会中断当前线程然后跳到内核中执行相应的代码，执行完成之后又会返回。</p><h4 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h4><p>故障是有可能修复的异常，这种异常执行完成之后会跳转到当前语句再执行一次。</p><p>一种典型的故障是缺页异常，缺页异常是虚拟内存的东西（现在还没学，就不瞎比比了）。</p><h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>终止是不可恢复的错误，通常是硬件错误，例如突然缺少什么信息等等。一般这种异常都会直接调用abort终止程序。</p><p><img src="/images/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.jpg" alt></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="/post/33cb1151.html"/>
      <url>/post/33cb1151.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --><h3 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>就是一个个找，过程不必多少。</p><p>如果查找每个元素概率相等，那么查找第n个元素只需要一次，第n-1需要两次…。所以平均查找次数是 1+2+…+n / n = （n+1)/2</p><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>其实就是二分查找,<a href="https://xinhecuican.github.io/post/41829.html">代码</a></p><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>分块查找就是每个找出每个块中最大的元素然后单独建一个表，之后就可以先查找这个表然后根据表来查找。大致意思就是这样，<a href="https://blog.csdn.net/To_Be_IT_1/article/details/25333253" target="_blank" rel="external nofollow noopener noreferrer">具体代码</a></p><h3 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h3><h4 id="二叉排序树（查找树）"><a href="#二叉排序树（查找树）" class="headerlink" title="二叉排序树（查找树）"></a>二叉排序树（查找树）</h4><p>二叉查找树特点是左儿子都比父亲小，右儿子都比父亲大。</p><p><img src="/images/%E6%9F%A5%E6%89%BE.PNG" alt></p><p>上面就不是二叉排序树，因为66比50还要大。</p><p>用链表进行存储。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    node</span> *lchild;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*rchild</span>;</span><br><span class="line">    int val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>二叉树的查找算法：</p><ol><li>如果二叉树是空，那么直接返回</li><li>如果该节点的val正好是要查找的数，则查找成功</li><li>如果大，那么去右边找</li><li>如果小，去坐标找</li></ol><p><strong>插入</strong></p><p>先要进行查找，如果查找不成功才会插入。</p><p>插入过程最好单独写一个函数，因为使用递归。如果要插入的点比当前点大，那么就去右边，反之就去左边。知道这个点是空为止，把要插入的点插入到这个空的点中。</p><p><strong>删除</strong></p><p>如果要删除的点是叶结点，那么直接把这个点变成空（因为父亲节点的儿子指针就指向这个节点，现在把这个节点变成空，那么儿子指针就指向空）</p><p>如果要删除的节点只有左子树或者右子树，那么让父亲对应指针指向那个子树就可以了。所以最好把父亲节点也用一个变量存储。</p><p>如果要删除的节点左右子树都有，就用它的前驱替代，然后删除前驱。</p><p><img src="/images/%E6%9F%A5%E6%89%BE2.PNG" alt></p><p>左边是删除前，右边是删除后。</p><p><img src="/images/%E6%9F%A5%E6%89%BE3.PNG" alt></p><p>前面一段代码是找前驱，前驱是s，而q是s的父亲，如果p==q说明p的左孩子就是s并且没有没有其他分支</p><p>效率 2logn</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树的特点是左右子树深度之差小于等于1.</p><p><strong>构造方法</strong></p><p>加入一个代表深度差的标记bf，如果左边比右边深为正，右边比左边深为负。例如：</p><p><img src="/images/%E6%9F%A5%E6%89%BE4.PNG" alt></p><p>上面的数字就是bf值。这个例子中是失去平衡的右子树的右子树导致的，也就是右右，可以向左旋转。让5做8的左节点，8连接根节点，19连接右节点。</p><p>如果是左左，那么向右旋转。</p><p>如果是左右，那么先左旋再右旋。</p><p>如果是右左，那么先右旋再左旋。</p><p>那么现在就知道如果不平衡应该怎么做了。但是插入时怎么判断平不平衡呢？</p><p>如果是空树，那么把这个点做根节点。</p><p>否则就按照二叉排序树的方法进行插入，插入完成之后又从底部递归。如果最终插入到右边就让父亲-1，如果插入到左边就让父亲加一。如果父亲&gt;=2就找左儿子，如果左儿子是1那么就是左左的情况，那么右旋，反之先左旋再右旋。如果&lt;=-2也是同样的方法。</p><p><img src="/images/%E6%9F%A5%E6%89%BE5.PNG" alt></p><p><img src="/images/%E6%9F%A5%E6%89%BE6.PNG" alt></p><p>注意，左旋和右旋是以根节点为基准的。在左左或右右的情况中，根节点是最上面那个点p，右旋就是把p和lc互换。但是在左右和右左的情况中不是这样。</p><p>如果是左右的情况，先以第二层的点作为根，右旋就是第二层的点和第三层的点换一下位置，顺便把原来第三层的左儿子挂到原来第二层的右儿子上（因为原来第三层的点变成第二层，右儿子没有了）。</p><p><img src="/images/%E6%9F%A5%E6%89%BE7.PNG" alt></p><p>最后除此之外还要注意左右或右左的情况中旋转之后的bf值会不同。</p><p><img src="/images/%E6%9F%A5%E6%89%BE8.PNG" alt><br><img src="/images/%E6%9F%A5%E6%89%BE9.PNG" alt><br><img src="/images/%E6%9F%A5%E6%89%BE10.PNG" alt></p><p>可以通过c点来区分</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>一种多路平衡查找树</p><p>每个节点至多m个儿子，如果根节点不是叶子节点，那么<strong>最少2棵</strong>子树。根节点之外的非叶子节点都<strong>至少有 m/2</strong>个子树。</p><p>非终端节点包含n, A0, k1, A1, k1, A2…其中k是关键字，且k&lt;k+1.n是关键字的数目</p><p>所有叶子节点都在同一层次且是空指针。</p><p><img src="/images/%E6%9F%A5%E6%89%BE11.PNG" alt></p><p>从上图中可以看出，对于每一个节点还是符合左边小右边大的规律的。</p><p>结构：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> keynum;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*parent</span>;</span><br><span class="line">    int key[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*p</span>[m+<span class="number">1</span>];</span><br><span class="line">    int *record[m+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">struct result</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*pt</span>;</span><br><span class="line">    int i;//节点中关键字序号</span><br><span class="line">    int success;//是否找到</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>查找</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="NIX"><figure class="iseeu highlight /nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">result search(node *head, int key)</span><br><span class="line">&#123;</span><br><span class="line">    node *<span class="attr">p</span> = head;</span><br><span class="line">    mode *q;</span><br><span class="line">    int <span class="attr">found</span> = <span class="number">0</span>;</span><br><span class="line">    while(p &amp;&amp; !found)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">n</span> = p-&gt;keynum;</span><br><span class="line">        int <span class="attr">i</span> = search(p, key);//这个函数是找第一个大于等于key的</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; p-&gt;key[i] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">found</span> = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">q</span> = p;</span><br><span class="line">            <span class="attr">p</span> = p-&gt;p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(found != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result a.<span class="attr">pt</span> = p;</span><br><span class="line">        a.<span class="attr">i</span> = i;</span><br><span class="line">        a.<span class="attr">success</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result a.<span class="attr">pt</span> = q;//因为没找到最后一定会到<span class="literal">null</span>，所以返回它父亲</span><br><span class="line">        a.<span class="attr">i</span> = i;</span><br><span class="line">        a.<span class="attr">success</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>插入</strong></p><p>节点插入首先是查找，前面查找的时候已经返回了他应该在的位置。但是如果插入后超过了上限那么还要把中间节点提到上面去（主要讲三叉）。同时让左右两边的做往上提节点的左右两边。</p><p><img src="/images/%E6%9F%A5%E6%89%BE12.PNG" alt><br>上面是插入85</p><p>算法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void insert(node *head, int key, node *<span class="built_in">in</span>, int position)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//in是要插入的节点，例如上面就是g节点</span></span><br><span class="line">    <span class="comment">//position是插入位置，也可以先用一次查找</span></span><br><span class="line">    int x = key；</span><br><span class="line">    node *ap = NULL;</span><br><span class="line">    int finish = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &amp;&amp; !finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(int k=position; k&lt;<span class="built_in">in</span>-&gt;</span>keynum-<span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">in</span>-&gt;</span><span class="function"><span class="title">key</span>[k+1] = <span class="built_in">in</span>-&gt;</span>key[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">for</span>(int i=position+1; i&lt;<span class="built_in">in</span>-&gt;</span>keynum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">in</span>-&gt;</span><span class="function"><span class="title">p</span>[i+1] = <span class="built_in">in</span>-&gt;</span>p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">in</span>-&gt;</span>key[position] = x;</span><br><span class="line">        <span class="function"><span class="title">in</span>-&gt;</span>keynum++;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="built_in">in</span>-&gt;</span>keynum &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            finish = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要把数往上提</span></span><br><span class="line">            int temp = (m%<span class="number">2</span>==<span class="number">0</span>) ? m/<span class="number">2</span> : m/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="title">x</span> = <span class="built_in">in</span>-&gt;</span>key[temp];</span><br><span class="line">            <span class="comment">//分裂</span></span><br><span class="line">            <span class="function"><span class="title">ap</span> = <span class="built_in">in</span>-&gt;</span>parent;</span><br><span class="line">            <span class="function"><span class="title">for</span>(int i=0; i&lt;ap-&gt;</span>keynum-<span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span>(ap-&gt;</span>key[i] &lt; x)</span><br><span class="line">                &#123;</span><br><span class="line">                    position = x;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//search</span></span><br><span class="line">            <span class="function"><span class="title">for</span>(int i=position+1; i&lt;ap-&gt;</span>keynum; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">ap</span>-&gt;</span><span class="function"><span class="title">p</span>[i+1] = ap-&gt;</span>p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            node *left = new node;<span class="comment">//拆分后左边节点</span></span><br><span class="line">            node *right = new node;<span class="comment">//拆封后右边节点</span></span><br><span class="line">            <span class="comment">//拆分具体过程就不写了，一系列的赋值</span></span><br><span class="line">            <span class="function"><span class="title">ap</span>-&gt;</span>p[position] = left;</span><br><span class="line">            <span class="function"><span class="title">ap</span>-&gt;</span>p[position+<span class="number">1</span>] = right;</span><br><span class="line">            <span class="built_in">in</span> = ap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">head</span>-&gt;</span>keynum++;</span><br><span class="line">        <span class="function"><span class="title">head</span>-&gt;</span>key[<span class="number">0</span>] = key;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这是自己写的并且没有验证，只有借鉴作用</span><br></pre></td></tr></table></figure></div><p><strong>删除</strong></p><ul><li>如果删除这个值后节点的key数大于 m/2-1（此时分支数是m/2)。那么只需要删除对应部分，其他不变。</li><li>如果删除节点后key=m/2-1<ol><li>如果它父亲左边或者右边Key数大于m/2-1，那么先把左边最大（右边最小）提到上面，再把那个值放下来<img src="/images/%E6%9F%A5%E6%89%BE13.PNG" alt></li><li>如果左右两边正好都等于m/2-1，那么把左边右边合并并且把这个值也放下来<img src="/images/%E6%9F%A5%E6%89%BE14.PNG" alt></li><li>不会有小于m/2-1的了，不符合定义</li></ol></li><li>如果删除后<strong>双亲</strong>key值小于m/2-1,层层向上合并（不清楚具体过程）</li></ul><p><strong>B+树</strong></p><p>b+树key和q一样多，并且子节点中包含父节点中的信息。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>基本思想：建立要存的数和存的位置之间的映射关系（最理想的情况是一一映射），此后在查找元素时，只需要用hash函数就可以找到再表中的位置。</p><p>哈希函数就是将值转化成存的位置的函数。</p><p>举个例子： 比如哈希函数是 x%10-1,那么可以输入x就可以得到元素在表中的位置。</p><p>但是这里有个问题，例如11的哈希值和1的哈希值相同，那么存的位置也相同，这显然是不允许的，这叫做哈希冲突。判断哈希函数优劣就是哈希冲突越少越好。</p><p><a href="https://xinhecuican.github.io/post/11491.html">字符串哈希</a></p><h5 id="直接定值法"><a href="#直接定值法" class="headerlink" title="直接定值法"></a>直接定值法</h5><p>hash(key) = key 或 hash(key) = a * key + b</p><p>这种方法仅适合哈希表和取值范围一样大的情况（如果取值到十亿我就呵呵）</p><h5 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h5><p>这是利用所选数字中的一些规律来的。例如某一串数字最高若干位都相同，只有一两位不同，那么我们就可以只取一两位</p><h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><p>就是先把数字平方然后再取中间几位，它的目的是扩大差别从而缩小冲突几率。适用于每一位都有高概率的重复数字。</p><h5 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h5><p>将关键字分成若干块然后叠加。可以直接分成若干块叠加。也可以正的加一块然后把数倒过来加一块，这种方法使用于位数多的情况。</p><h5 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h5><p>hash(key) = key % p;//p是不大于表长且不大于最大值的素数</p><h5 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h5><p>hash(key) = random(key);//这是伪随机数</p><h5 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h5><p><strong>开放地址法</strong></p><p>把冲突的地址求一个地址序列：h0,h1…</p><p>h(i) = (h(key) + d(i) ) mod m // m是表长</p><p>d(i) = c + i c可以随便取</p><p>或d(i) = (-1)^(i-1) * (i/2)^2 //这里的i/2是向上取整也就是1/2=1</p><p>或d(i)=random(i)//伪随机数</p><p>或d(i) = i*h2(key)</p><p>注意，这里的d(i)要保证完备性，也就是要保证s(m-1)个h(i)均不相同并且要覆盖到所有地址。那么就要求</p><ol><li>表长要是 4*k+3</li><li>m与d(i)没有公因子</li></ol><p><strong>链地址法</strong></p><p>把哈希值相同的记录在一个链表里。其实就是构建一个链表，如果不冲突就只有一个值，冲突就往后面加。</p><p><strong>再哈希法</strong></p><p>发生冲突时，选用另外一个哈希函数，直到不冲突。</p><p><strong>建立公共溢出区</strong></p><p>一旦发生冲突，就把有冲突的数据都填充到溢出表。</p><h5 id="哈希表查找"><a href="#哈希表查找" class="headerlink" title="哈希表查找"></a>哈希表查找</h5><p>就是先计算处hash(key)，如果找到直接填充，如果发现冲突就在通过冲突处理方法进行查找</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java 多线程</title>
      <link href="/post/f8648a1d.html"/>
      <url>/post/f8648a1d.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri May 15 2020 17:23:19 GMT+0800 (中国标准时间) --><h3 id="java线程运行机制"><a href="#java线程运行机制" class="headerlink" title="java线程运行机制"></a>java线程运行机制</h3><p>java虚拟机中，执行程序是由线程完成的，每个线程都有独立的程序计数器（PC或rip<br>)和栈</p><p>栈中有三个区，局部变量区，操作数栈和栈数据区。</p><p>操作数栈是线程的工作区，用来存放运算过程产生的临时变量（怎么有种寄存器的感觉）。</p><p>栈数据区为线程执行指令提供相关信息，例如定位到堆区和方法区的特定数据（类成员变量），正常退出方法等（存放地址信息）。</p><p>每次java虚拟机启动一个虚拟机进程时，虚拟机都会创建一个主线程。该线程从main开始执行。</p><p>例如在一个类中定义了一个实例变量a,然后再main函数中调用了这个类的成员函数A()，这个函数会让成员变量加一。首先进入这个方法，然后发现a++;就去栈数据区取出a的地址，之后定位到堆区取出a进行操作。</p><ul><li>方法区存放了字节码</li><li>堆区存放了线程所需要长时间保存的数据（类）</li><li>栈区存放了临时数据，栈帧和跳转到其他区域地址。</li></ul><h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>我们现在免费有了一个主线程，如果我们还想要创建其他线程的话，有两种方式。</p><ul><li>扩展java.lang.Thread类</li><li>实现Runnable接口</li></ul><p>要注意一点，创建了线程并启动之后会有自己的栈区，堆区，方法区，也就是说可以把它看成一个新的程序，里面的变量都是最原始的，不要认为主线程中操作的变量还有用。但是有些时候也可以使用主线程的对象</p><p><strong>一个线程只可以被启动一次</strong>。</p><h4 id="扩展java-lang-Thread类"><a href="#扩展java-lang-Thread类" class="headerlink" title="扩展java.lang.Thread类"></a>扩展java.lang.Thread类</h4><p>thread是线程，它的最主要的两个方法是：</p><ul><li>run(): 包含线程运行时执行的代码（相当于main方法）</li><li>start()： 用于启动线程，不需要覆盖</li></ul><p>start方法用来确定什么时候开始执行，可以在别的main函数中执行，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Machine</span> <span class="symbol">extends</span> <span class="symbol">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">50</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Machine machine = new Machine();</span><br><span class="line">        machine.start(); <span class="comment">//启动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>注意</strong>，调用了start并不是指立刻执行这个线程，而是让这个线程进入就绪状态，如果想让这个线程执行可以使用yield。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>java不允许一个类继承多个类，所以一旦继承了Thread类，那么就不能继承其他类。所以说接口这时就体现出优越性了。定义如下：</p><p><code>public void run();</code></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    [</span></span><br><span class="line"><span class="function">        Machine machine </span>= <span class="keyword">new</span> Machine();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> thread(machine);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Thread构造方法中有Runnable接口的，这个时候Thread就掌管了run方法，只要使用start就可以启动。</p><h4 id="主线程和用户自定义线程并发运行"><a href="#主线程和用户自定义线程并发运行" class="headerlink" title="主线程和用户自定义线程并发运行"></a>主线程和用户自定义线程并发运行</h4><p>并发运行指的是一个线程没有结束另一个线程开始执行，上面举的例子都是并发运行。</p><p>Thread中的currentThread()静态方法返回当前线程的引用，getname()返回当前线程的名字，main方法名字是main，用户创建的线程根据顺序从Thread-0，Thread-1一直往后排，可以用setName()设置名字。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line">相当于</span><br><span class="line">Thread thread = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">String name = thread.get<span class="constructor">Name()</span>;</span><br></pre></td></tr></table></figure></div><p>为了让每个线程轮流获得cpu，可以使用sleep(time)放弃cpu并睡眠若干时间。</p><h4 id="多个线程共享一个对象的实例变量"><a href="#多个线程共享一个对象的实例变量" class="headerlink" title="多个线程共享一个对象的实例变量"></a>多个线程共享一个对象的实例变量</h4><p>例：</p><ul><li>方法内部局部变量不共享</li></ul><p>这是因为这些数据都是动态在栈中分配的，每个线程都有自己的堆栈。</p><ul><li>成员变量，如果是指向同一个对象就共享</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Analy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Num i=<span class="keyword">new</span> Num(<span class="number">0</span>);    <span class="comment">//新建对象，准备传递给线程</span></span><br><span class="line">        <span class="keyword">new</span> OwnThread(i).start();    <span class="comment">//新建线程，并启动</span></span><br><span class="line">        <span class="keyword">new</span> OwnThread(i).start();    <span class="comment">//新建线程，并启动</span></span><br><span class="line">        System.out.println(<span class="string">"主线程中i的值变为了："</span>+i.i);    <span class="comment">//获取目前对象i的数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OwnThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Num id;    <span class="comment">//申明对象，默认null，就是没有指向任何实体</span></span><br><span class="line">    <span class="keyword">int</span> sno;    <span class="comment">//申明int变量。因为系统默认初始化为0，所以应该是定义一个int变量</span></span><br><span class="line">    OwnThread(Num id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sno=id.i;    <span class="comment">//保存id.i的数值，到线程私有变量sno</span></span><br><span class="line">                id.i++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">","</span>+sno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span>    //定义一个类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Num(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序中主函数定义了Num对象的实例i，定义线程是传递到了Thread0和Thread1这样三个变量就共享了一个Num对象的实例。而线程Thread0和线程Thread1又有自己的私有变量sno，可以用来保存某一时刻的共享变量的数值。</p><p>(1)Java中判断对象是否为同一个对象使用地址判断的。地址相同就是同一个对象，上面的三个就是同一个对象。</p><p>(2)如果把上面的例子中共享的对象实例用基本数据类型替换是不行的。因为基本数据类型程序会自动的用默认值初始化，也就是申明和定义时一起的。此时在main函数中定义线程，传递的基本数据类型参数，只能是初始化线程中的另一个对象，而不是同一个对象。</p><p>也就是说，只有类才可以共享，并且用同一个实例启动多个线程的时候这个实例是共享的，并且也只有这个实例时共享的，如果在线程中创建的新实例也不是共享的。</p><p><a href="https://www.cnblogs.com/xudong-bupt/archive/2013/05/22/3087864.html" target="_blank" rel="external nofollow noopener noreferrer">这里来自这篇博客</a></p><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><p><strong>新建状态</strong></p><p>也就是只有new没有start状态。</p><p><strong>就绪状态</strong></p><p>调用了start方法后，就进入了就绪状态。虚拟机会为他创建栈和rip，这个线程在运行池中等待cpu使用权。</p><p><strong>运行状态</strong></p><p>就是得到了cpu使用权，如果是多个cpu，那么可以同时运行多个线程。</p><p><strong>阻塞状态</strong></p><p>阻塞状态优先级比就绪状态低，阻塞状态过去后首先进入就绪状态然后进入运行状态。</p><ul><li><p>如果调用了某个对象的wait()方法，那么会进入这个对象等待池中。</p></li><li><p>如果试图获得某个对象的同步锁（后面说）但是被其他线程使用时，会把这个线程放到这个对象的锁池中。</p></li><li><p>调用sleep。</p></li><li><p><em>死亡状态*</em></p><p>当退出了run后，进入死亡状态。前面已经提到过一个线程不能呗start两次。可以用Thread的isAlive()方法判断这个线程是否活着。如果处于新建状态时，也是false。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3></li></ul><p>线程调度就是确定cpu的使用权在那个线程手上，cpu通常只有一个。有两种调度模型：分时调度和抢占型调度。</p><p>分时型调度就是让每个线程都执行一定时间。</p><p>抢占型是java虚拟机采用的方式。它是将所有线程规定一个优先级，优先让优先级高的线程运行，如果优先级都相同，那么随机选取一个线程。一旦抢到cpu，那么它将会一直运行直到被迫停止运行。</p><p>被迫停止运行的可能：</p><ul><li>虚拟机让当前线程放弃cpu。</li><li>当前线程进入阻塞状态</li><li>线程运行结束</li></ul><p>不同操作系统对抢占型的实现不同，有的是会一直让这个线程运行，有的是一段时间后停止运行。</p><h4 id="调整优先级"><a href="#调整优先级" class="headerlink" title="调整优先级"></a>调整优先级</h4><p>可以使用Thread的setPriority(int)和getPriority()设置优先级，可以使用currentThread().setPriority(?)设置等级。</p><p>三个静态常量：</p><ul><li>MAX_PRIORITY 10级，最高等级</li><li>MIN_PRIORITY 1,最低等级</li><li>NORM_PRIORITY 5, 默认等级</li></ul><p>如果将主线程优先级更改然后再创建其他线程，那么其他线程优先级也会更改。被创建者的默认优先级和创建者优先级保持相同。</p><p>注意，上面三个静态常量在不同操作系统中是不同的，例如windows只有七个优先级，所以最好只使用上面三种优先级。</p><h4 id="Thread-sleep-线程睡眠"><a href="#Thread-sleep-线程睡眠" class="headerlink" title="Thread.sleep()线程睡眠"></a>Thread.sleep()线程睡眠</h4><p>如果使用sleep方法，那么他会放弃cpu进入阻塞状态。sleep后面的数据是以毫秒做单位。完成之后也不是立刻重新开始执行，而是先进入就绪状态，如果没人和它抢cpu就开始执行。</p><p>例如： sleep(100);表示阻塞100毫秒</p><p>可以使用sleep让两个线程比较同步的执行。例如每个线程都会调用sleep(100)，那么第一个线程调用睡眠后第二个线程开始执行，如果执行时间小于100ms那么第二个线程执行完后第一个线程仍在睡眠，如果大于100ms第一个线程会立刻开始执行。因为它已经睡了100ms进入就绪状态了（同样也是只有两个线程的情况）。</p><p>可以使用sleep.interrupt()中断睡眠</p><p>如果线程在睡眠时被中断，那么就会抛出InterruptedException，程序跳到异常处理代码块。</p><h4 id="Thread-yield-线程让步"><a href="#Thread-yield-线程让步" class="headerlink" title="Thread.yield()线程让步"></a>Thread.yield()线程让步</h4><p>执行yield后，如果有相同或者更高优先级的线程在就绪状态，那么将会把当前线程放入运行池中并让优先级高的线程执行。</p><h4 id="join-等待其他线程结束"><a href="#join-等待其他线程结束" class="headerlink" title="join()等待其他线程结束"></a>join()等待其他线程结束</h4><p>当前线程可以调用另一个线程的join()方法，直到另一个线程结束这个线程才会又开始执行（进入就绪状态）。</p><p>如果加了参数，那么类似于sleep()将会休眠若干时间，不同的是join是给指定的线程执行。</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>例如垃圾回收线程，只有当前台所有线程都停止之后，后台线程才会结束生命周期。</p><p>主线程默认是前台线程，前台线程创建的线程默认也是前台线程。</p><p>可以调用Thread的setDaemon(true)方法，把线程设置成后台线程。可以用isDaemon()判断是否是后台线程。</p><p>只有在线程启动前（使用start())之前才可以设置成后台。并且后台创建的线程还是后台线程。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>java.util包中提供了定时器Timer，TimerTask类表示定时器执行的一项任务。例；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> usetimer;</span><br><span class="line">improt java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.start();<span class="comment">//想自定义start必须要先用父类的start</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(ture);<span class="comment">//把Timer关联的线程设为后台线程</span></span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;<span class="comment">//匿名类，便于设置定时任务</span></span><br><span class="line">        timer.schedule(task, <span class="number">10</span>, <span class="number">50</span>);<span class="comment">//设置定时任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">":"</span>+a++);</span><br><span class="line">        &#125;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>TimerTask类是一个抽象类，它实现了RUnnable接口。start()中匿名类继承了TimerTask类。</p><p>TImer(boolean isDaemon)可以把相关联的线程设置成后台线程。如果是true就是后台</p><p>schedule(TimerTask task, long delay, long period)用来设置定时任务。所以前面的匿名类就是用来启动定时任务的。delay是推迟多少毫秒之后执行，period是每次执行任务的间隔。其中delay只在第一次运行时有效。</p><p>还可以不要period参数，表示只执行一次。例如,timer.schedule(task, 10);</p><p>同一个定时器可以执行多个任务。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>有时候线程的抢占可能导致问题。例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//共享</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a+=i;</span><br><span class="line">            Thread.<span class="built_in">yield</span>();<span class="comment">//让给其他线程执行</span></span><br><span class="line">            a-=i;</span><br><span class="line">            System.out.<span class="built_in">println</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Mahcine();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(machine);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(machine);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个程序本来是要一直输出零的，但是因为让给了t2执行，所以会输出1 2 2 3 …。这样就和原来的逻辑不符。</p><p>逻辑紧密相关的一组操作叫做原子操作，为了防止原子操作被打断，就提出了线程同步思想。</p><h4 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h4><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">String</span> goods = <span class="built_in">buffer</span>[<span class="built_in">point</span>];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样就设置了this对象的锁。</p><ul><li>如果这个锁被其他线程占用，那么就会把该线程加入锁池中，进入阻塞状态</li><li>如果没有线程占用，那么他就会占用并执行代码块。</li></ul><p>也可以这样写；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized <span class="keyword">String</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意，在同步代码块中同样也可以使用sleep和yield，同样也是把cpu给其他线程。只是如果其他线程正好碰到了同步代码块那么又要将控制权归还，</p><p>synchronized不会被继承，也就是说哪怕父类中写了synchronized如果子类没写也不是同步的。</p><p>同步代码块中应包含尽量少的操作，因为操作多了可能一线程要在这里工作很久，其他线程就会都进入锁池中无法工作，这样会给一些需要即时反应的线程带来麻烦</p><h4 id="释放对象的锁"><a href="#释放对象的锁" class="headerlink" title="释放对象的锁"></a>释放对象的锁</h4><p>释放锁的情况：</p><ul><li>执行完同步代码块，会释放锁</li><li>线程异常终止时</li><li>执行了锁所属对象的wait()方法，这个线程会释放锁，并进入等待吃</li></ul><p>但是使用sleep或yield只会放弃cpu，并不会释放锁。还有suspend方法</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁指的是a在等b锁释放，b在等a锁释放，这样就永运无法释放，最为关键的是虚拟机并不会检查这类问题，所以只有程序员自己注意。</p><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>线程通信就是一个线程告诉另外一个线程某个信息，通过配合完成某件事。</p><p>java.lang.Object类中有两个用于线程通信的方法：</p><ul><li>wait() 释放对象的锁，然后把该线程放入等待池中，等待其他线程把它唤醒</li><li>notify() 唤醒在等待池中的线程。随机选取等待池中的线程，并加入锁池中。</li></ul><p>进入等待池后，锁和cpu全部放弃。如果使用notify也只是进入锁池，还要和其他线程争夺锁。</p><p>notifyAll() 唤醒所有在等待池中的线程。</p><p>注意：wait()方法必须放在一个循环中。因为在调用notify后并不是立刻可以得到执行，而是先要获得该对象的锁和cpu执行权限才可以运行。这个时候可能其他线程又将状态改变了，这时又要重新运行。</p><p><strong>要注意的是想要唤醒等待池中的线程首先自己要掌握这个锁</strong>，也就是说必须在同步代码块中写notify，不然会报IllegalMonitorStateException错误。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public synchronized String pop<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    this.notify<span class="constructor">All()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(point<span class="operator"> == </span>-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.ptintln(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">":wait"</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            this.wait<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="params">e</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面例子中，首先point是-1就要让一个线程处理，现在point是-1，然后一个线程调用wait()进入等待池，之后另一个线程操作了这个方法唤醒了该线程，但是这个时候线程并没有执行，而是先让其他的线程执行了一会才开始执行。但是其他线程执行过程中又把point变成-1了，这个时候处理线程已经结束，就会出现问题。</p><p>此外，<strong>wait必须写在synchronized中，不然运行时会报错。</strong></p><h3 id="中断阻塞"><a href="#中断阻塞" class="headerlink" title="中断阻塞"></a>中断阻塞</h3><p>当线程A处于阻塞状态的时候，B调用A的interrupt()方法，那么A会发送一个InterruptedExecption。</p><p>实际上interrupt方法如果处理处于阻塞状态的线程（如wait，sleep，join等）才会抛出异常，实际上它是把一个中断线程的标志位设为true，因为处于阻塞状态，所以抛出异常，仅此而已。决定是否退出线程还是由我们自己决定的，如果我们在catch块中没有退出，那么还是会继续运行。</p><p>如果interrput一个正在处于运行的线程，那么只会把标志位设置成true，不会做其他事。</p><p>可以通过isinterrupt来看标志位是否变成true</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Timer timer = <span class="keyword">new</span> Timer(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread = Thread.currentThread();</span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">publc <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"has waited for 3s"</span>);</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                timer.schedule(timerTask, <span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(InterruptException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(thread.getName);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a++;</span><br><span class="line">            System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段程序作用是如果a&gt;3，那么就把线程放入等待池，如果等待时间超过三秒，那么就抛出InterruptException信号从而中断线程。</p><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><ul><li>start() 启动线程</li><li>suspend() 使线程暂停</li><li>resume() 使暂停的线程恢复运行</li><li>stop() 终止线程</li></ul><p>但是其实后面三种已经被废弃了，但是可以通过编程实现同样的功能</p><h4 id="用编程方式控制线程"><a href="#用编程方式控制线程" class="headerlink" title="用编程方式控制线程"></a>用编程方式控制线程</h4><p>可以设置一个标志变量来表示现在的状态，假设标志变量有三个值。</p><ul><li>SUSP， 暂停状态</li><li>STOP， 终止状态</li><li>RUN， 运行状态</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUSP = <span class="number">1</span>;<span class="comment">//设置静态变量的话所有类都可以看到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUN = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> state = RUN;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">if</span>(state == RUN)</span><br><span class="line">        &#123;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">checkState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(state == SUSP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"wait"</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(state == STOP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过上面的两个方法，就可以对线程进行控制，但注意这种控制不是实时的，也就是说即使执行了setState也不会立刻进入暂停状态，而是machine先获得cpu，开始执行checkState方法时才会进入暂停状态。</p><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>ThreadGroup类表示线程组，他可以对一组线程集中管理。用户创建的线程都属于某个线程组。</p><p>指定线程组： <code>Thread(ThreadGroup group, String name)</code></p><p>如果线程A创建线程B且创建时没有指定线程组，那么会自动加入A的线程组中。一旦线程<strong>加入线程组，就不能退出</strong>。</p><p>用户创建的线程组都有父线程组，默认情况下，如果A创建了一个新线程组，那么A所在的线程组就是父亲线程组。</p><p>指定父亲线程组： <code>ThreadGroup(ThreadGroup parent, String name)</code></p><p>可以使用activeCount()返回当前活着的线程，enumerate(Thread[] tarray)把或者的线程复制到tarray中。</p><h3 id="处理线程未捕获的异常"><a href="#处理线程未捕获的异常" class="headerlink" title="处理线程未捕获的异常"></a>处理线程未捕获的异常</h3><p>如果线程没有捕获异常，那么虚拟机会找UncaughtExceptionHandler实例（这东西是个接口）。并且调用它的uncaughtException(Thread t, Throwable e)方法</p><p>设置异常处理类：</p><p><code>setDefaultUncaughtExcpetionHandler(Thread.UncaughtExceptionHandler eh)</code><br><code>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code></p><p>第一个是设置默认异常处理器（静态方法），第二个是设置当前异常处理器（实例方法）。</p><p>ThreadGroup线程组实现了这个接口。每次出现未捕获异常时，先找当前线程的异常处理器，如果没找到就用线程组的异常处理器。</p><p>并且线程组的异常处理器还不是直接调用。如果这个线程有父线程，那么就调用父线程的。如果没有父线程，那么如果自己实现了这个接口，那么就用。如果没有，那么就打印调用堆栈的异常信息。</p><h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><p>这个类用来存放线程的局部变量。这些局部变量是每个线程独有的，不会共享。</p><p>主要有三个方法：</p><p><code>public T get(): 返回当前线程局部变量 protected T initialValue(): 返回局部变量初始值 public void set(T value): 设置局部变量</code></p><p>其中initialValue()只会在第一次调用get()或set()时才会被使用，并且只会执行一次。</p><h3 id="concurrent并发包"><a href="#concurrent并发包" class="headerlink" title="concurrent并发包"></a>concurrent并发包</h3><p>在编写多线程程序时，既要考虑并发，又要防止死锁，还要考虑性能，难度很大。为了降低难度，增加了java.util.concurrent包。下面是包含的类和接口</p><h4 id="Lock外部锁"><a href="#Lock外部锁" class="headerlink" title="Lock外部锁"></a>Lock外部锁</h4><p>这个主要用于线程同步。这是由类提供的锁，区别于对象的锁（可以叫内部锁）。他有几个方法。</p><ul><li><p>lock() 获得当前线程的锁，如果被占用，那么进入阻塞状态。这和内部锁是一样的</p></li><li><p>tryLock() 试图获得当前线程的锁（看看现在锁是不是有人用），如果被占用，就返回false，否则返回true。</p></li><li><p>tryLock(long time, TimeUnit unit)，如果超过了设置时间没有获得锁，放回false。例如 tryLock(50L, TimeUnit.SECONDS)表示时间限制50s</p></li><li><p>unlock() 释放线程锁占用的锁。</p><p>Lock接口有一个实现类ReentrantLock，构造方法ReentrantLock(boolean fair).fair如果是真，那么会采用公平策略。公平策略是指让阻塞时间长的更有可能获得锁。这是以性能作为代价的。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();<span class="comment">//创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>外部锁可以用来弥补内部所的一些不足，我们可以直接用lock，unlock而不使用synchronized。</p><h4 id="Condition-线程通信接口"><a href="#Condition-线程通信接口" class="headerlink" title="Condition 线程通信接口"></a>Condition 线程通信接口</h4><p>java.lang.concurrent.locks.Conditon用于线程通信。Lock接口的newCondition()方法返回Condition的实例。</p><p>方法：</p></li><li><p>await() 和wait()相似</p></li><li><p>await(long time, TimeUnit unit):和上面类似，如果超过时间线程没有被唤醒，返回false。</p></li><li><p>signal()： 和notify()类似。</p></li><li><p>signalAll()：和notifyAll()类似</p><h4 id="Callable和Feture"><a href="#Callable和Feture" class="headerlink" title="Callable和Feture"></a>Callable和Feture</h4><p>这两个是用来做异步计算的。Runnable接口的返回值是void，如果其他线程需要这个线程的返回值怎么办呢？这个可以通过共享变量来实现，但是共享变量需要共享类，这又可能导致问题。所以这两个接口就是解决这类麻烦。</p><p>Callable接口：和Runnable接口类似，Runnable中的run()相当于Callable中的call()。但是call可以有泛型的返回值。此外，这个不能作为Thread类的参数。</p><p>Future接口： 保存运算结果，以下参数</p></li></ul><ul><li>get()：返回异步运算的结果。如果结果没有出来，当前线程就会被阻塞直到运算结束。</li><li>get(long timeout, TimeUnit unit): 和第一个类似。只是如果超出时间还没有得到结果就会抛出TimeoutException。</li><li>cancel(boolean mayInterrupt): 取消该运算，如果运算没有开始，就立刻取消。如果已经开始，如果mayInterrrupt为true，那么也取消。</li><li>isCancelled()：判断运算时候被取消</li><li>isDone()：判断运算是否已经完成。</li></ul><p>FutureTask：这是一个适配器，同时实现Runnable和Future接口。还关联了一个Callable实例。FutureTask可以作为Thread类的参数。FutureTask类的构造函数可以带Callable的参数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LASSO"><figure class="iseeu highlight /lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Callable myComputation = <span class="literal">new</span> <span class="params">...</span></span><br><span class="line">FutureTask&lt;<span class="built_in">Integer</span>&gt; task = <span class="literal">new</span> FutureTask&lt;<span class="built_in">Integer</span>&gt;(myComputation);<span class="comment">//Integer是返回值</span></span><br></pre></td></tr></table></figure></div><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Machine implements Callable&lt;<span class="type">Integer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">Integer</span> <span class="keyword">call</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            catch(<span class="keyword">Exception</span> e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(Stirng[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FutureTask&lt;<span class="type">Integer</span>&gt; task = <span class="built_in">new</span> FutureTask&lt;<span class="type">Integer</span>&gt;(<span class="built_in">new</span> Machine());</span><br><span class="line">        Thread thread = <span class="built_in">new</span> Thread(task);</span><br><span class="line">        threadMachine.<span class="keyword">start</span>();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("从1到100的和"+task.<span class="keyword">get</span>());//调用<span class="keyword">get</span>返回值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="通过线程池管理多个线程"><a href="#通过线程池管理多个线程" class="headerlink" title="通过线程池管理多个线程"></a>通过线程池管理多个线程</h4><p><img src="/images/java%E7%BA%BF%E7%A8%8B.jpg" alt></p><p>Executor表示线程池，execute方法用来执行command的run()中指定的任务，线程会调度空闲的线程来执行该任务。到底什么时候执行，这是由cpu决定的。</p><ul><li>shutdown(): 预备关闭线程池。如果有任务提交上去，那么要等这些任务执行完后，才会关闭线程池，并且拒绝新任务的入内。</li><li>shutdownNow(): 终止已经开始的任务，立刻关闭线程池</li><li>isTermination(): 判断线程池是否关闭，如果关闭返回true</li><li>awaitTermination(): 等待线程池关闭。</li></ul><p>submit(Callable<t>task)和submit(Runnable task)和execute(Runnable command)类似，但是这个支持异步运算。他们都会返回异步运算结果的Future对象。</t></p><p>Excutors中静态方法：</p><ul><li>newCachedThreadPool(): 创建有缓存的线程池，有任务才创建新线程，空闲的线程停留60s。</li><li>newFixedThreadPool(int nThreads): 创建有固定数目线程的线程池，空闲线程一直保留</li><li>newSingleThreadExecution(): 创建只有一个县城的线程池。这个与newFixedThreadPool(1)不同之处在于这个终止就终止了，Fixed的终止了还会创建一个新的。</li><li>newScheduledThreadPool(int corePoolSize): 线程池会按时间计划创建任务。corePoolsize是线程<strong>最小</strong>数目。</li><li>newSingleThreadScheduledExecutor(): 创建只有一个线程的线程池，这个线程池按计划进行任务。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Machine</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Machine(i));</span><br><span class="line">        &#125;</span><br><span class="line">        service.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里创建了5个线程给线程池，然后线程池中两个空白线程接到任务开始工作，工作完这两个线程后又执行下面两个线程，直到执行完5个线程。然后执行shutdown()关闭线程池。</p><h4 id="BlockingQueue-阻塞队列"><a href="#BlockingQueue-阻塞队列" class="headerlink" title="BlockingQueue 阻塞队列"></a>BlockingQueue 阻塞队列</h4><p>java.util.concurrent.BlockingQueue接口继承了java.util.Queue接口。BlockingQueue接口为多个线程同时操作一个队列提供了方案。</p><table><thead><tr><th>操作</th><th>抛出异常</th><th>放回特定值</th><th>线程阻塞</th><th>超时</th></tr></thead><tbody><tr><td>添加元素</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>删除元素</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>读取元素</td><td>element()</td><td>peek()</td><td>无</td><td>无</td></tr></tbody></table><p>前面两个是队列的，后面两个是阻塞队列的。这个具体等到队列那里再说。这里先把几个BlockingQueue的实现类列一下：</p><ul><li>LinkedBlockingQueue类： 默认情况下，LinkedBlockingQueue的容量是没有上限的，也可以指定大小，这是基于链表的队列</li><li>ArrayBlockingQueue类： ArrayBlockingQueue(int capacity, boolean fair)可以设定容量，并且可以选择是否采用公平策略。这是基于数组的队列。</li><li>PriorityBlockingQueue：这是优先队列（堆）</li><li>DelayQueue: 这个队列中存放的是延期元素。这些元素必须实现java.util.concurrent.Delayed接口。只有延期满的元素才可以被取出或者删除。</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c 文件操作</title>
      <link href="/post/e0f8cb74.html"/>
      <url>/post/e0f8cb74.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>文件总的来说其实就只有两个操作，打开（关闭）和读写。本文也围绕这两个方面展开</p><p><strong>文件格式</strong></p><p>文件一般由三部分组成：路径，文件名，后缀。</p><p>例：<code>&quot;E:\\ch10.doc&quot;或者&quot;E:/ch10.doc&quot;</code></p><p>之所以要两个\是因为在c语言中\作为转义字符。</p><p><strong>流</strong></p><p>流按方向分为：输入流和输出流。从文件获取数据的流称为输入流，向文件输出数据称为输出流。</p><p>例如，从键盘输入数据然后把该数据输出到屏幕上的过程，相当于从一个文件输入流（与键盘相关）中输入（读取）数据，然后通过另外一个文件输出流（与显示器相关）把获取的数据输出（写入）到文件（显示器）上。</p><p><strong>换行符</strong></p><p>在Linux系统中，换行符是0x0a（LF）。因为c是在unix上发展起来的，所以访问Linux文件时，不需要转换，直接可以访问。</p><p>在windows系统中使用0x0d(CR ‘\r’） 和 0x0a(LF ‘\n’)合起来作为换行符。所以把windows下文件给c程序还要先把CR-LF转换成LF</p><p><strong>缓冲文件系统</strong></p><p>缓冲文件系统：系统自动为每个打开的文件在内存开辟一块缓冲区，缓冲区的大小一般由系统决定。当程序向文件中输出（写入）数据时，程序先把数据输出到缓冲区，待缓冲区满或数据输出完成后，再把数据从缓冲区输出到文件；当程序从文件输入(读取)数据时，先把数据输入到缓冲区，待缓冲区满或数据输人完成后，再把数据从缓冲区逐个输入到程序。</p><p>c语言就是用的缓冲文件系统。其实这和vim有点像。</p><p>ANSI C 为正在使用的每个文件分配一个文件信息区，该信息区中包含文件描述信息、 该文件所使用的缓冲区大小及缓冲区位置、该文件当前读写到的位置等基本信息。这些信息保存在一个结构体类型变量中，该结构体类型为 FILE 在 stdio.h 头文件中定义，不允许用户改变。</p><h3 id="文件打开和关闭"><a href="#文件打开和关闭" class="headerlink" title="文件打开和关闭"></a>文件打开和关闭</h3><p>文件指针 file* 用来引用一个文件。</p><p><strong>打开</strong></p><p>原型：<code>FILE * fopen(char *filename, char *mode);</code></p><p>filename指的是文件名，可以包括路径。</p><p>mode是打开方式。下面列举了一些打开方式</p><table><thead><tr><th>模式</th><th>含 义</th><th>说 明</th></tr></thead><tbody><tr><td>r</td><td>只读</td><td>文件必须存在，否则打开失败</td></tr><tr><td>w</td><td>只写</td><td>若文件存在，则清除原文件内容后写入；否则，新建文件后写入</td></tr><tr><td>a</td><td>追加只写</td><td>若文件存在，则位置指针移到文件末尾，在文件尾部追加写人，故该方式不 删除原文件数据；若文件不存在，则打开失败</td></tr><tr><td>r+</td><td>读写</td><td>文件必须存在。在只读 r 的基础上加 ‘+’ 表示增加可写的功能。下同</td></tr><tr><td>w+</td><td>读写</td><td>新建一个文件，先向该文件中写人数据，然后可从该文件中读取数据</td></tr><tr><td>a+</td><td>读写</td><td>在” a”模式的基础上，增加可读功能</td></tr><tr><td>rb</td><td>二进制读</td><td>功能同模式”r”，区别：b表示以二进制模式打开。下同</td></tr><tr><td>wb</td><td>二进制写</td><td>功能同模式“w”。二进制模式</td></tr><tr><td>ab</td><td>二进制追加</td><td>功能同模式”a”。二进制模式</td></tr><tr><td>rb+</td><td>二进制读写</td><td>功能同模式”r+”。二进制模式</td></tr><tr><td>wb+</td><td>二进制读写</td><td>功能同模式”w+”。二进制模式</td></tr><tr><td>ab+</td><td>二进制读写</td><td>功能同模式”a+”。二进制模式</td></tr></tbody></table><p>按照mode 规定的方式，打开由pname指定的文件。若找不到由pname指定的相应文件，就按以下方式之一处理：</p><p>（1） 此时如mode 规定按写方式打开文件，就按由pname指定的名字建立一个新文件；<br>（2） 此时如mode 规定按读方式打开文件，就会产生一个错误。</p><p>例： fopen(“example.txt”, “rw”);</p><p>如果返回失败，那么将返回NULL。</p><p><strong>关闭</strong></p><p>int fclose(FILE *fp);</p><p>如果关闭不正常，返回-1（EOF).</p><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="按字符输入输出"><a href="#按字符输入输出" class="headerlink" title="按字符输入输出"></a>按字符输入输出</h4><p>原型：<code>int fgetc (FILE *fp);</code></p><p>作用：一次读入一个字符。如果读入出现问题，返回-1(EOF)</p><p>注意：由于 fgetc 是以 unsigned char 的形式从文件中输入（读取）一个字节，并在该字节前面补充若干 0 字节，使之扩展为该系统中的一个 int 型数并返回，而非直接返回 char 型。当输入失败时返回文本文件结束标志 EOF 即 -1，也是整数。故返回类型应为 int 型，而非 char 型。</p><p>也就是说最好不要用char类型去接收字符而使用unsigned_char，这样在碰到特殊字符就不会出现错误。</p><p>由于在 C 语言中把除磁盘文件外的输入输出设备也当成文件处理，故从键盘输入字符不仅可以使用宏 getchar() 实现，也可以使用 <strong>fgetc (stdin)</strong> 实现。其中，stdin 指向标准输入设备—键盘所对应的文件。stdin 不需要人工调用函数 fopen 打开和 fclose 关闭。</p><p><strong>按字符输出</strong></p><p>原型： <code>int fputc (int c, FILE *fp);</code></p><p>向fp文件中输出字符c。如果想输出到屏幕，可以<code>fputc(c, stdout)</code></p><p>对一个文件进行读写操作时，经常会把一个文件中读写位置重新调整到文件的开始处，可以使用函数 rewind 实现。</p><p>原型: <code>void rewind (FILE *fp);</code></p><p>作用：把<strong>读写</strong>位置跳到函数开头。</p><h4 id="按字符串输入输出"><a href="#按字符串输入输出" class="headerlink" title="按字符串输入输出"></a>按字符串输入输出</h4><p><strong>输入</strong></p><p>原型： <code>char * fgets (char *s, int size, FILE * fp);</code></p><p>作用： 从文件中读取长度为size（到了末尾会终止）的字符串，并且自动加入’\0’后输出，遇到空格不会终止。</p><p><strong>输出</strong></p><p>原型： <code>int fputs (const char *str, FILE *fp);</code></p><p>作用：把str输出到文件中。</p><h4 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h4><p>这个与scanf和printf类似，只是目标变成了文件。</p><p><strong>输入</strong></p><p>原型： <code>int fscanf (文件指针，格式控制串，输入地址表列);</code></p><p>作用：从文件中输入到格式化字符串中，遇到空格会终止输入。</p><p>返回值：返回整型，输入成功时，返回输入的数据个数；输入失败，或已读取到文件结尾处，返回 EOF(-1)</p><p>例： fscanf (fp,”%d,%d”, &amp;a, &amp;b); //两个%d之间也必须用逗号隔开</p><p><strong>输出</strong></p><p>int fprintf (文件指针，格式控制串，输出表列)；</p><p>作用： 把格式字符串中的数据输出到文件中。</p><h4 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h4><p><strong>输入</strong></p><p>原型：<code>unsigned fread (void *buf, unsigned size, unsigned count, FILE* fp);</code></p><p>作用：从 fp 指向的文件中读取 count 个数据块，每个数据块的大小为 size。把读取到的数据块存放到 buf 指针指向的内存空间中。</p><p>返回值：返回实际读取的数据块（非字节）个数，如果该值比 count 小，则说明已读到文件尾或有错误产生。这时一般采用函数 feof 及 ferror 来辅助判断。</p><p><strong>输出</strong></p><p>原型：<code>unsigned fwrite (const void *buf,unsigned size,unsigned count,FILE* fp);</code></p><p>作用： 把buf中count个大小为size的数据块写到文件中</p><p><strong>文件检查</strong></p><p>原型： <code>int feof (FILE * fp);</code></p><p>作用：检查是否到了文佳末尾，如果到了，返回非0</p><h4 id="随机读写"><a href="#随机读写" class="headerlink" title="随机读写"></a>随机读写</h4><p>随机读写就是不是在文件开头而是制定一个位置开始读写。首先要把文件指针移到对应位置，然后开始读写。</p><p>原型： <code>int fseek(FILE *fp, long offset, int origin);</code></p><p>作用：把fp读写指针设置到origin+offset的位置上，origin是起始位置。offset是偏移量。</p><p>起始位置有三种快捷的设置。分别是：</p><ul><li>SEEK_SET:文件开头，即第一个有效数据的起始位置。</li><li>SEEK_CUR：当前位置。</li><li>SEEK_END:文件结尾，即最后一个有效数据之后的位置。注意：此处并不能读取到最后一个有效数据，必须前移一个数据块所占的字节数，使该文件流的读写指针到达最后一个有效数据块的起始位置处。</li></ul><p>可以通过<code>long ftell (FILE *fp);</code>获得当前指针对于文件开始位置的偏移量</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java 内部类</title>
      <link href="/post/348d4e04.html"/>
      <url>/post/348d4e04.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat May 23 2020 21:27:14 GMT+0800 (中国标准时间) --><p>内部类就是在类的内部又定义一个类。</p><h3 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h3><p>实例内部类就是没有static修饰的内部类。他有以下几点需要注意</p><ul><li>在创建内部类的实例时，外部类必须已经创立。例如：</li></ul><p><code>Outer.InnerTool tool = new Outer().newInnerTool();</code>这个语句相当于</p><p><code>Outer outer = new Outer(); Outer.InnerTool Tool = outer.new InnerTool();</code></p><ul><li><p>内部类也是在外部类的内部，可以访问外部类的任何级别的成员方法和成员变量。这是因为想要创建内部类，首先要创建外部类，这个时候可以看成内部类有外部类的引用。</p></li><li><p>一个外部类可以对应多个内部类，一个内部类对应一个外部类。外部类不能直接访问内部类的成员，必须要通过实例去访问。例如</p></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> b1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> b2 = <span class="number">2</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">C</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v1 = b1;<span class="comment">//不能直接访问内部类成员，错误</span></span><br><span class="line">        B.C c1 = <span class="keyword">new</span> C();<span class="comment">//错误</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();<span class="comment">//正确，因为在类内部相当于已经有实例</span></span><br><span class="line">        <span class="keyword">int</span> v2 = b.b1;<span class="comment">//正确，可以通过内部类实例直接访问</span></span><br><span class="line">        B.c c2 = b.<span class="keyword">new</span> C();<span class="comment">//正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>在内部类中不能定义静态成员。</li><li>如果内部类和外部类A有同名的成员。那么this代表外部，A.this代表内部</li><li>如果有两个内部类且一个定义成private，那么另一个类不能访问。因为两个是同级的，可以把两个内部类看成继承于同一个父类的类。并且如果想在一个内部类中使用另一个内部类，则必须用完整类名</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        A.B b = <span class="keyword">new</span> <span class="type">A</span>().<span class="keyword">new</span> <span class="type">B</span>();<span class="comment">//使用A.B而不能像前面一样直接使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类也是一种静态变量。但是这种类比较神奇，本来static是不能修饰类的，但是内部类的static和普通的静态变量有所不同。它可以创建实例，也就是说不局限于方法区，只是为了有特殊的权限而把static安上去而已。</p><p>静态变量可以直接创建，不必先创建外部类。例如<code>A.B b = new A.B();</code>。</p><p>正因为如此，所以静态内部类想访问外部类实例变量需要先创建实例。但是静态变量可以直接访问。</p><p>静态类的特点就是可以定义静态成员。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是在一个方法中定义的类，它的可见范围是这个方法。局部内部类不能使用访问权限修饰符（public等），其实本来就没有必要，只能在这个方法内了还要访问权限干什么。</p><p>局部类也不能包含静态成员。依我看这就是java中的struct（不知道java中有不）。</p><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>这种类的特殊之处就是没有名字，这种类实际上是内部类的简写形式（虽然也简单不到哪去），如果只需要创建一个内部类实例，就可以考虑匿名类。例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> A</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    A a = new A()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        void method()</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            System.out.println("from");</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line">        a<span class="function">.<span class="keyword">method</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>匿名类本身没有构造方法，但是他会调用父类的构造方法。匿名类和内部类的访问权限相同，也可以访问外部所有变量。</p><p>传递参数时要注意，如果传递的是外部类的参数，必须要加final。因为内部类和外部类编译时生成的是两个文件，也就是说可能是值传递。但是内部类和外部类按道理应该是同一个类，内部类改变了参数，外部类也要跟着改变。为了避免这种矛盾，干脆直接定义成final不可改变了。</p><p>语法： <code>new 类名/接口名(构造方法参数){内容}</code></p><p>匿名内部类实现接口（注意是实现），其实就是创造了一个类</p><h3 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h3><p>如果一个外部类继承了另一个外部类的内部类的实例，那么这个外部类会自动引用另一个外部类。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    pubilc <span class="keyword">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> print()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("a="+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Sample extends <span class="keyword">Outer</span>.<span class="keyword">Inner</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">public</span> Sample(<span class="keyword">Outer</span> o)</span><br><span class="line">   &#123;</span><br><span class="line">       o.super();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">public</span> static <span class="type">void</span> main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">Outer</span> outer1 = <span class="built_in">new</span> <span class="keyword">Outer</span>();</span><br><span class="line">       <span class="keyword">Outer</span>.<span class="keyword">Inner</span> <span class="keyword">inner</span> = outer1.<span class="built_in">new</span> <span class="keyword">Inner</span>();</span><br><span class="line">       Sample s1 = <span class="built_in">new</span> Sample(outer1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Sample必须要提供如上所述的构造函数。因为如果不提供，那么就不知道引用的是哪一个Outer。此外，Java虚拟机会自动使内部类的实例引用外部类的实例。例如上面inner实例会自动引用outer1实例。</p><h3 id="内部类用途"><a href="#内部类用途" class="headerlink" title="内部类用途"></a>内部类用途</h3><p>第一个作用就是封装。例如顶层类只有public和默认级别，而内部类四种级别都可以有。</p><p>第二个作用是访问外部类的属性。这个访问不代表创建一个内部类的实例就可以直接访问外部类的属性了，那反而是对封装的破坏，这里指的是在定义的时候可以随意使用外部类的属性。</p><p>第三个作用是<strong>回调</strong>。这个的含义是可以实现类和接口中同名的方法。例如两个接口或一个类一个接口中定义了重名的方法，那么可以让内部类实现接口然后外部覆盖方法。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span>//<span class="title">Base</span>调节速度，<span class="title">Adjustable</span>调节温度</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> speed)</span><span class="comment">//覆盖</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustTemperature</span><span class="params">(<span class="keyword">int</span> temperature)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Adjustable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> temperature)</span><span class="comment">//实现</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            adjustTemperature(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Adjustable <span class="title">getCallBackReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意这里内部类是通过调用外部类的方法来实现的，虽然应该也可以直接在内部类中实现，频繁的跳转反而会带来性能的降低。但是某些时候想使用外部类的private类型时可以使用这种方法。</p><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>对于每个内部类，java都会生成.class文件。</p><ul><li>成员内部类 外部类名字$内部类名字. 例： A$B.class</li><li>局部内部类 外部类名字$数字加内部类名字</li><li>匿名类 外部类名字$数字</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链接</title>
      <link href="/post/4551c130.html"/>
      <url>/post/4551c130.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>记得gcc编译器编译的步骤吗？预处理，编译，汇编，链接。首先前两步是为了生成.s的汇编文件，然后第三步就是生成机器码。但是如果第三步就已经完成了所有事为什么还要第四步呢？</p><p>首先我们要知道，编译时是各个文件独立编译的，也就是说这个时候如果分配了地址很可能发生这个函数的地址和另外一个文件中函数的地址相同的尴尬事情发生，为了避免这种事情，在编译到.o文件的时候一些其他文件要用的函数和变量使用一个符号来表示的，然后在链接阶段再来连连看把地址安上。</p><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p>目标文件有三种：</p><ul><li>可重定位目标文件，也就是汇编后形成的.o文件。可以和其他文件链接新城可执行文件</li><li>可执行目标文件，也就是可执行文件</li><li>共享目标文件，一种特殊的可重定向目标文件，可以在运行时重定向（动态链接）</li></ul><h4 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h4><p><img src="/images/elf.png" alt></p><p>上面是一个elf文件结构图，这是现在linux中目标文件格式。各种目标文件中都有类似的格式。</p><ol><li>ELF头，存放了一些基础信息，例如大端序还是小端序，文件类型等等。</li><li>.text节，已编译的机器代码。</li><li>.rodata。只读数据，例如printf中的格式串和跳转表</li><li>.data；以初始化全局和静态变量</li><li>.bss； 未初始化全局和静态变量</li><li>.symtab。符号表</li><li>rel.text； .text节位置列表。可执行文件中不存在，一般会省略</li><li>.rel.data； 同上</li><li>.line； 源程序中行号和.text节机器指令间的映射，可以使用-g选项启用它</li><li>…</li><li>节头部表； 存放每一节相对于elf开始位置的偏移量。</li></ol><h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><p>每个.o文件中都有一个符号表。总共有三种符号</p><ul><li>全局符号：由该文件定义并且能被其他模块引用的全局符号。全局符号表示非静态函数和全局变量</li><li>外部符号：有其他模块定义并且被该模块引用的符号。这些符号叫外部符号。对应其他模块（文件）的非静态函数和全局变量</li><li>局部符号。这是带static的函数和全局变量。这些符号在函数内部都可见，但是不能呗其他函数引用。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">符号表的构成：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Symbol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;<span class="comment">//在符号表中的字节偏移</span></span><br><span class="line">    <span class="keyword">char</span> type:<span class="number">4</span>,<span class="comment">//符号类型，是数据还是函数还是文件还是未定义</span></span><br><span class="line">       binding:<span class="number">4</span>;<span class="comment">//符号是本地（static）还是全局的</span></span><br><span class="line">    <span class="keyword">char</span> reserved;</span><br><span class="line">    <span class="keyword">short</span> section;</span><br><span class="line">    <span class="keyword">long</span> value;<span class="comment">//符号地址</span></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">size</span>;<span class="comment">//符号大小，对于函数是函数指令字节总个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>例：<img src="/images/%E7%AC%A6%E5%8F%B7%E8%A1%A8.webp" alt></p><p>其中ndx中的UND是undefine。</p><h3 id="静态链接完成的任务"><a href="#静态链接完成的任务" class="headerlink" title="静态链接完成的任务"></a>静态链接完成的任务</h3><p>静态链接就是编译时完成的链接，与之对应的运行时的链接。静态链接主要完成了两个任务，符号解析和重定位</p><h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><p>符号解析就是将上面的符号表一一对应起来，例如上面第二种符号就匹配其他文件的第一种符号。</p><p>但是这里还有一些问题，因为开始编译是各做各的，所以难免出现名字相同的情况，甚至一个文件中也有函数重载导致重名的情况。这是符号解析中的难题。</p><p>对于一个文件中的重载，gcc链接器会对这些符号进行重整。例如同样是A函数，可能通过链接器的重整一个符号名就成了A1，另外一个成了A2。</p><p>如果是全局（其他模块可见）的变量之间导致重名。有以下方法。</p><p>在编译时，编译器想汇编器输出每个全局符号，分成强弱两类。函数和以初始化的全局变量时强符号，未初始化全局变量时弱符号。</p><p>链接规则：</p><ol><li>不能出现同名的强符号</li><li>如果一个强符号，其他都是弱符号，那么其他弱符号都使用强符号地址</li><li>如果都是弱符号，那么随机选取一个弱符号，其他弱符号使用这个弱符号地址</li></ol><p>注意第二点和第三点，系统都只分配了一片内存空间，其他符号都是共用这片内存空间，这就可能导致一些奇奇怪怪的错误，例如数据莫名被修改。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sum.<span class="keyword">c</span></span><br><span class="line"></span><br><span class="line">int <span class="keyword">x</span><span class="comment">;</span></span><br><span class="line"><span class="comment">int y;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a.c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int x;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为x都是弱符号，所以随便选一个，然后让另一个共享内存空间，也就是在sum.c中进行更改会导致a.c中x的更改。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sum.c</span></span><br><span class="line"><span class="comment">int x;</span></span><br><span class="line"><span class="comment">int y;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a.c</span></span><br><span class="line"><span class="comment">double x;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这种问题更为严重，如果选到了a.c中的x，那么空间是8字节，而这时在sum.c中x和y是连到一起的也是8字节，这就意味着这次对a.c中x改变可能会导致y改变。</span></span><br></pre></td></tr></table></figure></div><p>上面这个问题在编译阶段很难发现，所以只有养成良好习惯，才可以减少这类问题。下面是几点建议。</p><ol><li>能不使用全局变量就不使用全局变量</li><li>使用全局变量记得初始化</li><li>确定要引用外部变量时用extern</li></ol><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>重定位有两步</p><ol><li>重定位节和符号定义：这一部分是把上面所说的每一个文件中的节。例如所有文件的.data节合成为一个节。之后就把内存地址赋给新的节，并且赋给每个符号。这时就有运行时的内存地址了。</li><li>重定位节的符号引用。</li></ol><h5 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h5><p>在重定位之前，符号并没有赋值，这个时候就有重定位条目确定我们要怎么把地址赋给每一个符号。</p><p>代码重定位条目存放在.rel.text中，数据重定位条目在.rel.data中。</p><p>重定位条目内容：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Rela</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> offset;<span class="comment">//相对于函数首地址的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> type:<span class="number">32</span>,<span class="comment">//类型</span></span><br><span class="line">        symbol:<span class="number">32</span>;<span class="comment">//对应的符号</span></span><br><span class="line">    <span class="keyword">long</span> addend; <span class="comment">//附加信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里只讲两种基本类型：R_X86_64_PC32(相对引用，32位），R_X86_64_32(绝对引用）。</p><p>这种重定位类型只支持小型代码模型，只能引用-2G到2G的范围。</p><p>下面讲怎么重定位。</p><p>如果是相对地址：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">refaddr = ADDR + <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>offset;<span class="comment">//ADDR是函数首地址，例如main函数首地址，offset是偏移量</span></span><br><span class="line"><span class="comment">//refaddr是需要修改内存的首地址，例如e8 00 00 00 00，后面四个零就是我们要填充的地址，那么refaddr是第一个00的地址</span></span><br><span class="line">*refptr(refaddr地址的内容) = <span class="constructor">ADDR(<span class="params">r</span>.<span class="params">symbol</span>)</span> + r.addend - refaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这一段就是计算相对跳转地址的，addr是对应符号的绝对地址，本来addr-refaddr就是相对跳转地址，但是注意这里的相对跳转地址是当前指令的，而我们要从下一条指令进行跳转，所以要加上一个addend，用下一个指令起始地址来减，所以这里的addend是-4，因为refaddr指向e8后面，加上4就是下一条指令，而因为是末地址减首地址所以addend是负数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绝对地址</span></span><br><span class="line"></span><br><span class="line">refaddr 同上;</span><br><span class="line">*refptr = <span class="constructor">ADDR(<span class="params">r</span>.<span class="params">symbol</span>)</span> + r.addend;</span><br><span class="line"><span class="comment">//这个相对简单，内容就是对应符号绝对地址嘛，但是这里也要加addend因为有可能是数组等因此还要加上数组的偏移量。</span></span><br></pre></td></tr></table></figure></div><h3 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h3><p>过去我们有两种选择进行连接，第一种是把一堆常用函数放到一个可重定向文件中，另一种是把所有常有函数都分开，然后一个个链接。第一种占用空间太大，可能为了一两个函数加了一两千个函数，第二中编译时太难写，所以使用了静态链接库。</p><p>静态链接库集合了上面两种方法，首先它是一个可重定向目标文件。但是不同在于他有一个符号表需要哪个函数就把那个函数链接进去，这样就兼顾上面二者的优点。</p><p>可以使用<code>gcc -static -o prog2c main2.c -L. -lvector</code>其中L是链接库的路径，l是库名，一般库开头都是lib所以lib可以省略，后缀名可以省略。</p><p>可以使用<code>ar rcs libvector.a addvec.o multvec.o</code>来创建静态库，libvector.a是库名</p><p>为了效率考虑，链接时从左向右每个文件只会扫描一次，这样就可能导致问题。例如，最右边的模块有外部符号（引用其他文件的），这时因为扫描已完毕，所以就会报错。</p><p>此外，对于一些常用函数如cout等，如果每个程序都复制一次，那么还是太浪费空间。</p><p>而且如果库函数有错误或者考虑不周需要修改，那么对于绝大多数程序来说都是一个灾难，因为大型程序重新编译一下可能会导致冲突等不可预料的后果。</p><p>为了解决这些问题，提出了动态链接</p><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>动态链接库指的是在程序加载或运行阶段进行链接。在程序开始时（程序不是从main开始，前面还有一段代码负责初始化）会启用动态链接器。</p><h4 id="pic数据引用"><a href="#pic数据引用" class="headerlink" title="pic数据引用"></a>pic数据引用</h4><p>GOT 全局偏移量表，这个表用来存全局变量的地址，在data段开始的地方，而静态链接的时候那些符号的跳转地址都是跳转到这个表中，然后在运行时这个跳转表才会真正赋予地址。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MEL"><figure class="iseeu highlight /mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov <span class="number">0x100010</span>(%rip), %rax</span><br><span class="line">addl $0x1, (%rax)</span><br><span class="line"></span><br><span class="line">第一行就是跳转到跳转表然后取出里面地址，然后第二段取出之歌地址中的值并加一</span><br></pre></td></tr></table></figure></div><p>PLT 过程链接表。举个例子</p><p><img src="/images/%E9%93%BE%E6%8E%A5.jpg" alt></p><p>这个例子是从右上角开始的，先调用函数到了PLT表，之后跳转到GOT[4]所指位置，第一次GOT[4]指向4005c6也就是下一条指令，第一次后GOT[4]就会变成函数地址。</p><p>4005c6是把addvec的ID拖入栈中，然后跳转到GOT[2]的位置同时把GOT[1]放到栈中，GOT[1]是解析函数用到的信息，GOT[2]是动态链接器地址。跳到GOT[2]后就根据栈中的内容链接函数并把GOT[4]的值变成函数首地址。</p><h3 id="库打桩技术"><a href="#库打桩技术" class="headerlink" title="库打桩技术"></a>库打桩技术</h3><p>总体来说库打桩是指自己写一个库然后先于系统库加载这时程序运行的就是你自己写的库了。</p><h4 id="链接时库打桩"><a href="#链接时库打桩" class="headerlink" title="链接时库打桩"></a>链接时库打桩</h4><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(ptr) myfree(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(%d)=%p\n"</span>, (<span class="keyword">int</span>)<span class="built_in">size</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"free(%p)\n"</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>通过上面就可以实现不使用库函数而使用自己的函数了。这个函数便于跟踪内存请求和释放情况。但是每个文件都要写太过麻烦。</p><p>也可以把这个单独写成一个文件，然后通过编译器<code>gcc -Wl ,--wrap,malloc -Wl,--wrap,free -o int1 int.0 mymalloc.o</code>进行链接</p><h4 id="运行时库打桩"><a href="#运行时库打桩" class="headerlink" title="运行时库打桩"></a>运行时库打桩</h4><p>运行时库打桩基于LD_PRELOAD环境变量。在这个变量路径下的库会先于系统库进行加载。</p><p><a href="https://blog.csdn.net/qq_18150497/article/details/78010331" target="_blank" rel="external nofollow noopener noreferrer">更多内容请看</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java 对象的生命周期</title>
      <link href="/post/53677394.html"/>
      <url>/post/53677394.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><p>有四种显式创建的方式：</p><ul><li>new创建</li><li>运用反射，调用java.lang.Class或java.lang.reflect.Constructor类的newInstance()方法</li><li>调用对象的clone()方法</li><li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射创建</span></span><br><span class="line">Class objClass = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"Customer"</span>)</span>;</span><br><span class="line">Customer cl = (Customer)objClass.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line"><span class="comment">//通过克隆创建</span></span><br><span class="line">Customer c3 = (Customer)c2.clone<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></div><p>通过new或反射的方法创建的时候，都会调用构造方法。但是通过克隆创建不会执行构造方法。在Object类中就定义了clone()方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASPECTJ"><figure class="iseeu highlight /aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object clone()<span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Cloneable))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportException();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这种方式下如果对应类没有实现cloneable接口，那么clone（）方法会抛出异常。<strong>如果想用clone，那么必须要实现Cloneable接口</strong>。</p><p>clone会创建一个对象，对象的属性值相同，但是内存地址不同。</p><p><strong>隐式创建对象</strong></p><ul><li>输入main的参数都会转化成String对象</li><li>+号对String类型创建新对象</li><li>加载一个类时，会创建Class实例</li></ul><p><strong>创建对象步骤</strong></p><ol><li>给对象分配内存</li><li>将实例变量自动初始化成默认值</li><li>初始化对象。例如private int a = 1;在第二步赋值成0，在第三步中才会变成1.</li></ol><p>对于第三步，如果是通过clone的方法创建，那么将原来成员变量的值赋给新的成员变量。如果是用第四种方法，那么是通过输入流读入序列化数据。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法时负责初始化的，可以提供参数，也可以不提供，一般设置一个默认构造函数有好处。</p><ul><li>方法名要与类名相同</li><li>不声明返回类型</li><li>不能被static,final,synchronized,abstract,native修饰</li></ul><p><strong>重载构造方法</strong></p><p>这是为了满足多样化的需求。需要注意一点在一个构造方法中可以用this调用另一个构造方法。但是如果在一个构造方法中使用了this语句，那么它必须在第一行。</p><h4 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h4><p>其实和c++一样，在没有构造方法的时候会提供一个默认构造方法，如果写了一个构造方法那么系统就不会提供构造方法。但是最好要有一个不带参数的构造方法。</p><h4 id="子类调用父类构造方法"><a href="#子类调用父类构造方法" class="headerlink" title="子类调用父类构造方法"></a>子类调用父类构造方法</h4><p>父类构造方法不能被子类继承。在构造子类时，先执行祖先的构造方法，然后一次向下。这样可以确保子类从父类继承的东西可以被使用。可以用super(…)调用父类构造方法。如果没有用super显示构造，那么子类会用父类的默认构造方法。如果子类没有构造方法，将会出现编译错误</p><h4 id="构造方法的访问级别"><a href="#构造方法的访问级别" class="headerlink" title="构造方法的访问级别"></a>构造方法的访问级别</h4><p>这里主要将private的访问级别的意义。</p><p>当构造函数是private时，只有当前类可以访问它。这也代表不能有子类。所以只有一些特殊的场合才会使用它。</p><ol><li>只有静态方法，没有实例方法</li><li>禁止被继承。这个与final的区别就是private不允许其他类创建它的实例，而final可以。</li><li>这个类要把自己封装起来。</li></ol><h3 id="静态工厂办法"><a href="#静态工厂办法" class="headerlink" title="静态工厂办法"></a>静态工厂办法</h3><p>创建实例最常见的方法是用new调用类的构造方法。在这种情况下，可以创建任意多的实例。如果类想要进一步封装创建实例的细节，并控制实例数目，可以用静态工厂的方法。</p><p>静态工厂方法指的是在类中提供一个公有的静态方法，返回类的一个实例。</p><p>静态工厂实际上是一种普通的方法，但是它有平常创建实例时所不具有的灵活性。</p><p><strong>特点一</strong>： 可以有不同于类的名字，这样在重构构造方法时可以更清晰的说明其中的不同，使可读性增大。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Person get<span class="constructor">ManInstance(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">       return <span class="keyword">new</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>, SEX.<span class="params">man</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public static Person get<span class="constructor">WomanInstance(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">       return <span class="keyword">new</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>, SEX.<span class="params">woman</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>一般都喜欢把静态工厂取名为valueof或getInstance。</p><p><strong>特点二</strong>： 可以不创建新对象。重复利用原有对象</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> A init = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">getinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>特点三</strong>： 可以创建子类的实例</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public static <span class="type">A</span> getson()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Sub</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>因为静态工厂每次不一定创建新的实例，所以在一些特殊的场合有应用。</p><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>单例类就是只有一个实例的类，这种类只有一个实例。一般是系统中具有唯一性的组件才会使用。这种类一般要消耗很多内存，为了防止随便开然后爆内存，所以设置成单例类。</p><p>一种办法是提供public static final的静态常量，然后该常量引用唯一实例。在把构造方法定义成private类型。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Globalconfig</span><br><span class="line">&#123;</span><br><span class="line">    public static final GlobalConfig<span class="built_in"> INSTANCE </span>= new GlobalConfig();</span><br><span class="line">    private GlobalConfig();</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另一种办法就是把构造方法定义成private类型，然后提供构造工厂。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Globalconfig</span><br><span class="line">&#123;</span><br><span class="line">    public static final GlobalConfig<span class="built_in"> INSTANCE </span>= new GlobalConfig();</span><br><span class="line">    private GlobalConfig()&#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">    public static GlobalConfig getInstatnces()</span><br><span class="line">    &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>枚举类是实例数目有限的类。比如，表示性别的Gender类，他只会有两个类。</p><p>设计时，同样把构造方法定义成private，然后创建若干个public static final的静态变量。还可以提供静态工厂。另外如果想使用这些实例，直接用类名即可。</p><h4 id="不可变类和实例缓存"><a href="#不可变类和实例缓存" class="headerlink" title="不可变类和实例缓存"></a>不可变类和实例缓存</h4><p>不可变类指的是创建之后就不可以更改属性值，和final类似。例如Long类，String类。</p><p>创建不可变类时，要考虑一下内容：</p><ul><li>把属性定义成final类型</li><li>不对外公开的（private）set方法</li><li>public的get方法</li><li>在构造方法中初始化所有属性</li><li>覆盖Object类的equals()和hashCode()方法。</li></ul><p>对于不可变类，因为数据成员不会改变，所以在创建实例时，如果二者数据成员相同，那么可以共有一份空间，这样就减小了内存消耗。这叫做实例缓存。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(10)</span>;</span><br><span class="line">Integer b = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(10)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(a<span class="operator"> == </span>b);<span class="comment">//会打印true</span></span><br></pre></td></tr></table></figure></div><p>关于两个对象的等于，在<a href="https://xinhecuican.github.io/post/4b1879e3.html">前面一篇博客</a>中已有说明。</p><p>这就说明了两者共用了内存空间。那么我们应该如何实现实例缓存呢？</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> <span class="type">Name</span></span><br><span class="line">&#123;</span><br><span class="line">    private static final <span class="keyword">Set</span>&lt;SoftReference&lt;<span class="type">Name</span>&gt;&gt; names = <span class="built_in">new</span> HashSet&lt;SoftReference&lt;<span class="type">Name</span>&gt;&gt;();//实例缓存，存放<span class="type">Name</span>的软引用</span><br><span class="line">    <span class="built_in">public</span> sattic <span class="type">Name</span> valueOf(String firstname, Stirng lastname)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(SoftReference&lt;<span class="type">Name</span>&gt; <span class="keyword">ref</span>:names)//循环查看是否已经存在</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Name</span> <span class="type">name</span> = <span class="keyword">ref</span>.<span class="keyword">get</span>();//获得软引用的<span class="type">Name</span>对象</span><br><span class="line">            <span class="keyword">if</span>(<span class="type">name</span> != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; <span class="type">name</span>.firstname.equals(firstname)</span><br><span class="line">            &amp;&amp; <span class="type">name</span>.lastname.equals(lastname))</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果缓存中不存在<span class="type">Name</span>对象，就创建新对象，并加入到实例缓存</span><br><span class="line">            <span class="type">Name</span> <span class="type">name</span> = <span class="built_in">new</span> <span class="type">Name</span>(firstname, lastname);</span><br><span class="line">            names.<span class="keyword">add</span>(<span class="built_in">new</span> SoftReference&lt;<span class="type">Name</span>&gt;(<span class="type">name</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当然，实例缓存也需要消耗内存空间，如果对所有不可变类都使用，可能有的反而会减少内存。当有如下情况时，才会使用实例缓存。</p><ul><li>不可变类实例种类有限</li><li>需要频繁访问某些特定的实例。</li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>在c++中，内存回收是程序员自己负责，因为人难免犯错嘛，可能会导致一系列奇奇怪怪的错误。所以在java中，内存回收是java虚拟机做的。</p><p>只有对象不被任何变量引用时，它的内存才会被回收。当垃圾回收器回收内存时，会先调用该对象的finalize()方法，该方法可能使对象复活，导致垃圾回收器取消回收内存。</p><p>对垃圾回收器来说，程序由三种状态：</p><ol><li>可触及状态：只要还有引用变量引用对象，那么这个对象就处于可触及状态。</li><li>可复活状态： 当程序中没有引用2变量引用时，就进入了可复活状态，复活的关键是finalize方法，这个方法有可能使他复活</li><li>不可触及状态： 也就是调用了finalize状态并且没有复活之后。这种状态下虚拟机才会真正回收内存。</li></ol><h4 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h4><p>finalize()方法就是要销毁时执行的方法，如果finalize方法如果出现异常系统也不会报错而是直接清除。下面讲一下如何把它变成可触及状态。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ghost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Map&lt;<span class="keyword">String</span>, Ghost&gt; ghosts = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>,Ghost&gt;();</span><br><span class="line">    <span class="keyword">String</span> name ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ghost <span class="title">getInstance</span><span class="params">(<span class="keyword">String</span> name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Ghost ghost = ghost(name);</span><br><span class="line">        <span class="keyword">if</span>(ghost == null)</span><br><span class="line">        &#123;</span><br><span class="line">            ghost = <span class="keyword">new</span> Ghost(name);</span><br><span class="line">            ghosts.<span class="built_in">put</span>(name, ghost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ghost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ghosts.<span class="built_in">put</span>(name, <span class="keyword">this</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"execute finalize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个程序在将要被销毁时会调用finalize，之后就把这个对象有放回了Map中，又把这个对象复活了。</p><p>但是实际最好不要用finalize，因为这会扰乱正常的回收机制，导致永远无法回收。</p><p><strong>清除过期引用</strong></p><p>正常情况下，虚拟机都会很好的执行垃圾回收，但是在对象数组等线性结构中，如果只让指针减一，是无法进行垃圾回收的，因为这个数组仍保留对它的引用，但是这个被清除的数据已经无意义了，下面举个例子</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">Object</span>[] elements = <span class="keyword">new</span> <span class="keyword">Object</span>[capacity];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements[--<span class="built_in">size</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个方法的确没什么问题，也可以得到正确的执行，但是实际上size位置的引用并没有被清除，所以当你不断的增加然后开始不断的删除时，这个栈一直在占用大量的空间。所以要想办法除法java的回收机制</p><p>方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">Object</span> object = elements[--<span class="built_in">size</span>];</span><br><span class="line">    elements[<span class="built_in">size</span>] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="强引用，弱引用，软引用，虚引用"><a href="#强引用，弱引用，软引用，虚引用" class="headerlink" title="强引用，弱引用，软引用，虚引用"></a>强引用，弱引用，软引用，虚引用</h3><p>在早期的java中，并没有各种引用。这些引用代表的是清除的级别，如果空间不够了，那么先清除级别低的，这样对程序造成的影响就小。</p><p>在java.lang.ref包中，有Reference的抽象父类，下面有SoftReference,WeakReference,PhantomRefence，分别代表软引用，弱引用，虚引用。<br>ReferenceQueue表示引用队列，它可以和上面三种引用联合使用，以便跟踪虚拟机回收所引起的对象的活动(具体的现在不清楚）。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用就是普通的引用。如果一个类是强引用，那么除非没有变量引用它，虚拟机绝对不会回收它，甚至空间不足的时候虚拟机抛出OutOfMemoryError也不会回收。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>如果一个对象只有软引用，那么空间足够就会留着它，空间不足就会回收它。前面就有一个软引用的例子。</p><p>软引用可以和引用队列（ReferenceQueue）配合使用，如果软引用所引用的对象被回收，那么虚拟机就会把这个软引用加入到与之关联的引用队列中</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用比软引用更没人权。一旦垃圾回收器发现了弱引用，不管有没有内存，都会回收它。只是因为垃圾回收是一个优先级比较低的线程，所以不一定会很快发现弱引用。</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>弱引用都如此了，虚引用肯定更倒霉。同样也是一旦被发现分分钟清除的货。而且优先级比弱引用还要低。虚引用并不会决定对象生命周期。对象持有虚引用和没有引用一样，如果只有虚引用，还是会被清除。</p><p>弱引用<strong>必须</strong>要和引用队列一起使用。当回收一个对象时，如果发现它有虚引用，那么就会在回收对象之前，把这个虚引用对象加入引用队列中。</p><p>那么它的作用是什么？因为虚引用会被放到引用队列中，所以可以设一个虚引用，然后通过虚引用是否在引用队列中来判断这个对象时候要被回收。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">"hello"</span>);<span class="comment">//创建强引用</span></span><br><span class="line">ReferenceQueue&lt;<span class="keyword">String</span>&gt; rq = <span class="keyword">new</span> <span class="type">ReferenceQueue</span>&lt;<span class="keyword">String</span>&gt;();<span class="comment">//创建引用队列</span></span><br><span class="line">WeakReference&lt;<span class="keyword">String</span>&gt; wf = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;<span class="keyword">String</span>&gt;(str,rq);<span class="comment">//创建弱引用</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="/post/50daec4.html"/>
      <url>/post/50daec4.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="AOV网络"><a href="#AOV网络" class="headerlink" title="AOV网络"></a>AOV网络</h3><p>aov网络指的是用顶点表示活动的网络。讲个例子吧</p><p>例如学习课程有个前后顺序，前面一门课没有学完后面一门课动不了手。这样就可以用顶点表示课程，然后用有向箭头表示学习的次序，这样就是一种AOV网络。并且显然每个点都要走，因为每门课都要学。</p><p><img src="/images/%E7%BD%91%E7%BB%9C1.PNG" alt="后面这个数字代表先修课程"><br><img src="/images/%E7%BD%91%E7%BB%9C2.PNG" alt></p><p>检测有向环可以用对AOV网络构造拓扑序列。构造方法等会讲，如果有环，那么就会出现永远都有入度的情况，就说明有环。</p><p><strong>构造过程</strong></p><p>就拿上面一个图来说吧。必须先要学完c1，c2才可以学c3.学了c1又可以学c8，按照这样的顺序就可以得出学习顺序是C1C2C3C5C4C8C9C7C6。当然，还有许多其他的次序。</p><p>从中我们可以发现一个规律，假如每当我们学一门课就删去这些边，那么我们可以学习一个课程时入度一定为0.例如我们学完1和2后3入度就是0所以现在我们可以学了。如果入度不为0说明我们还有前置知识我们没有掌握，就不能学。</p><p>总结：找出入度为0的点，删去与之相邻的边，然后找新的入度为0的点，重复上述过程。</p><p>下面给出模板：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAXIMA"><figure class="iseeu highlight /maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    int val;//边权</span><br><span class="line">    int <span class="built_in">last</span>;</span><br><span class="line">    edge* next;</span><br><span class="line">&#125;;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int insum;//入度</span><br><span class="line">    edge* <span class="built_in">first</span>;</span><br><span class="line">&#125;;</span><br><span class="line">node nod[<span class="number">100</span>];//随便设的数字，也可以<span class="built_in">new</span>来构建</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nod[i].<span class="built_in">first</span> = NULL;</span><br><span class="line">        nod[i].insum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void addedge(int <span class="built_in">sum</span>, int <span class="built_in">first</span>, int <span class="built_in">last</span>)</span><br><span class="line">&#123;</span><br><span class="line">    //用后插法</span><br><span class="line">    edge* temp = <span class="built_in">new</span> edge;//needfree</span><br><span class="line">    temp-&gt;val = <span class="built_in">sum</span>;</span><br><span class="line">    temp-&gt;<span class="built_in">last</span> = <span class="built_in">last</span>;</span><br><span class="line">    temp-&gt;next = nod[<span class="built_in">first</span>].<span class="built_in">first</span>;</span><br><span class="line">    nod[<span class="built_in">first</span>].<span class="built_in">first</span> = temp;</span><br><span class="line">    nod[<span class="built_in">last</span>].insum++;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">sum</span>, <span class="built_in">first</span>, <span class="built_in">last</span>;</span><br><span class="line">    node* tempnode;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;<span class="built_in">sum</span>&gt;&gt;<span class="built_in">first</span>&gt;&gt;<span class="built_in">last</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addedge(<span class="built_in">sum</span>, <span class="built_in">first</span>, <span class="built_in">last</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node* aovstack = <span class="built_in">new</span> node;//needfree,链栈，用来存放入度为<span class="number">0</span>的节点</span><br><span class="line">    int <span class="built_in">time</span> = <span class="number">0</span>;//记录栈中有多少元素</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nod[i].insum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tempnode = nod[i];</span><br><span class="line">            tempnode-&gt;<span class="built_in">first</span> = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">            aovstack-&gt;<span class="built_in">first</span> = tempnode;</span><br><span class="line">            <span class="built_in">time</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">time</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">time</span>--;</span><br><span class="line">        tempnode = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">        node* temp = aovstack;</span><br><span class="line">        aovstack = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">        <span class="built_in">delete</span> temp;</span><br><span class="line">        edge* tempedge = tempnode-&gt;<span class="built_in">first</span>;</span><br><span class="line">        <span class="keyword">while</span>(tempedge != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--nod[tempedge-&gt;<span class="built_in">last</span>].insum == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">time</span>++;</span><br><span class="line">                tempnode = nod[tempedge-&gt;<span class="built_in">last</span>];</span><br><span class="line">                tempnode-&gt;<span class="built_in">first</span> = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">                aovstack-&gt;<span class="built_in">first</span> = tempnode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/******************</span></span><br><span class="line"><span class="comment">            *output...</span></span><br><span class="line"><span class="comment">            ***************/</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***************</span></span><br><span class="line"><span class="comment">    * delete...</span></span><br><span class="line"><span class="comment">    *******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="AOE网络"><a href="#AOE网络" class="headerlink" title="AOE网络"></a>AOE网络</h3><p>这个是用边表示活动，顶点表示事件。</p><p><img src="/images/%E7%BD%91%E7%BB%9C3.PNG" alt></p><p>这是一个AOE网络图，注意和上面类似这里每一条边都是要到的。我们要找的就是花费时间最长的那条路，因为那条路走完了所有活动才完成。那么这条路叫做关键路径，这条路径上的活动叫做关键活动。如果我们想缩短工期的时间，那么我们就要先缩短关键活动的时间。</p><p><strong>几个名词</strong></p><p>事件最早可能开始时间 ve(i)</p><p>事件最迟允许开始时间 vl(i)</p><p>活动最早可能开始时间 e[i]</p><p>活动最迟开始时间 l[i]</p><p><strong>所以关键活动就是 e[i] == l[i]</strong> ，因为最早时间和最晚时间相同说明耽误不得。</p><p><strong>求法</strong></p><p>代码比较简单，这里只讲一下思路。</p><p>同样使用邻接表。用四个数组分别表示上面四个名词。首先求前面两个。</p><p>事件最早时间这么多到那个点的路径中最晚的那个。例如上面的6点应该是40而不是30，因为只有最晚的那个完成了才能算真正到了那个点。</p><p>事件最晚开始时间要从后往前算。最后那个点的最晚开始时间我们一般是知道的，就是截至时间。然后往前面去减，如果有多条路径到那个点就选最小的。同样的道理因为所有边走完这件事才算做完了，如果你选大的相当于到最后那个点的所需时间少，结果这边走完了那个时间小的还没有走完。</p><p>举个例子：假设8点的截至时间是60，那么4点的截至时间应该是从8到7到5那一条。</p><p>活动最早开始时间是活动的起点的最早开始时间</p><p>活动的最晚开始时间是活动的终点的最晚开始时间减去这条边的权</p><p><img src="/images/aoe%E7%BD%91%E7%BB%9C.PNG" alt></p><p>从这个代码中我们看出每个顶点遍历就可以了。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java 类的生命周期</title>
      <link href="/post/61eaf19a.html"/>
      <url>/post/61eaf19a.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="类的加载连接和初始化"><a href="#类的加载连接和初始化" class="headerlink" title="类的加载连接和初始化"></a>类的加载连接和初始化</h3><ol><li><p>加载： 查找并加载类的二进制数据</p></li><li><p>链接： 包括验证，准备和解析类的二进制数据</p><ul><li>验证： 确保加载类的正确性。</li><li>准备： 为类的静态变量分配内存，将其初始化为默认值（也就是0）</li><li>解析： 将类的符号引用<a href="符号引用就是在编译阶段，虚拟机并不知道所有引用类的地址（因为还没有加到内存中），就用一个符号表示地址。而直接引用就是真实的地址。">^1</a>变成直接引用</li></ul></li><li><p>初始化： 把类的静态变量赋予正确的初始值。</p></li></ol><h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><p>类的加载是指把类的.class文件中的二进制数据读入到内存中，把它存放在方法区中。然后再兑取川家一个java.lang.Class对象，用来封装类在方法区的数据结构。<strong>通俗的来讲就是把代码加载到内存中</strong>。</p><p>类的加载是由虚拟机自带的加载器来完成的，但是我们也可以自己去定义。用java.lang.ClassLoader类的子类的实例。</p><p>类加载器允许某个类将要被使用时预先加载它。如果预先加载过程中遇到了.class的错误。那么类加载器在首次主动使用这个类的时候报错（LinkageError)</p><h4 id="类的链接"><a href="#类的链接" class="headerlink" title="类的链接"></a>类的链接</h4><p><strong>类的验证</strong></p><p>类的验证主要验证一下内容：</p><ul><li>类文件格式， 看看后缀是否符合</li><li>语义检查 看看是否符合java语义（例如把一个String给int或final是否有子类）</li><li>字节码验证，字节码代表java方法。</li><li>二进制兼容验证。查看这个类引用的另一个类的方法的=在另一个类中是否存在。</li></ul><p><strong>类的准备</strong></p><p>为类的静态变量分配内存，并设置成0（boolean是false，char是’\u0000’)</p><p><strong>类的解析</strong></p><p>符号引用上面已经解释过了，其实也就是这个类引用的其他类或其他类的成员变量和方法等。因为这些类在编译阶段并没有加载，所以虚拟机也不知道要到哪里去找这些方法，所以先弄一个符号代表这个方法。</p><h4 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h4><p>静态变量的初始化有两种途径。（1） 声明时直接赋值 （2） 在静态代码块中初始化。</p><p>初始化并不是直接初始化。如果没有加载和链接，那么先加载和链接。如果父类没有初始化，那么先初始化父类。</p><p>虚拟机只有首次启用一个类的时候才会初始化它。也就是说，创建对象实例，或者访问使用静态变量，还有是某个正在初始化类的父类时都会初始化它。</p><p>此外，当final类型的静态变量，如果能直接计算出值，那么会当成常量，不会导致初始化。反之，会导致初始化。</p><h3 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h3><p>类加载和Linux进程生成类似，都是先有一个根加载器，然后其他类加载器只有一个父加载器。父加载器不是加载自己，而是加载子类，但是是子类请求父类加载自己。</p><p>有三类自带的加载器：</p><ul><li>根加载器，负责加载一些核心库，例如java.lang.*</li><li>扩展加载器，它的父加载器是根加载器。他从java.ext.dirs系统属性指定的目录中加载扩展。或者从JDK的jre\lib\ext中加载扩展</li><li>系统加载器：也叫应用类加载器。它的父加载器是扩展加载器。他从classpath环境变量或者子系统属性java.class.path中加载类，它是用户自定义加载器的默认父加载器。</li></ul><p><strong>类加载的过程</strong></p><p>例如要加载一个类，首先请求父类加载器代为加载，父类再向它的父类代为加载…。一直到根加载器，如果根加载器不能加载，那么就让扩展加载器加载，如果不能加载…。直到找到一个可以加载的。如果所有加载器都不能加载，那么返回ClassNotFoundException。</p><p>成功加载那个类的加载器叫定义类加载器。</p><p>这种机制是为了安全考虑，因为在这种严密的机制下，用户自定义的加载器不可能取代由父加载器完成的任务。</p><p>这里加载器并不一定是和类一样的父子关系。一对父子加载器可能是同一个类的两个实例。</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>每个类加载器都有自己的命名空间，命名空间由该加载器和所有父加载器所加载的类组成。在同一个命名空间中，不可能出现名字（包括包名）完全相同的两个类。不同的命名空间中就有可能出现。</p><h4 id="运行时包"><a href="#运行时包" class="headerlink" title="运行时包"></a>运行时包</h4><p>同一加载器加载的属于相同包的类组成了运行时包。包名相同不一定默认访问级别可以访问，必须要组成运行时包才可以访问默认访问级别。</p><h3 id="创建用户自定义加载器"><a href="#创建用户自定义加载器" class="headerlink" title="创建用户自定义加载器"></a>创建用户自定义加载器</h3><p>首先介绍自定义类的应用场景：</p><p>（1）加密：Java代码可以轻易的被反编译，如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用Java的ClassLoader去加载类了，这时就需要自定义ClassLoader在加载类的时候先解密类，然后再加载。</p><p>（2）从非标准的来源加载代码：如果你的字节码是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。</p><p>（3）以上两种情况在实际中的综合运用：比如你的应用需要通过网络来传输 Java 类的字节码，为了安全性，这些字节码经过了加密处理。这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出在Java虚拟机中运行的类。</p><p>要扩展自己的类加载器，只需扩展java.lang.Classloader类，瑞啊后覆盖findClass(String name)方法。该方法根据参数指定类的名字，返回对应Class对象的引用。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.<span class="keyword">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyClassLoader <span class="keyword">extends</span> ClassLoader</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyClassLoader()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> MyClassLoader(ClassLoader parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"D:/People.class"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(<span class="keyword">file</span>);</span><br><span class="line">            <span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</span></span><br><span class="line">            <span class="keyword">Class</span>&lt;?&gt; c = <span class="keyword">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(<span class="keyword">File</span> <span class="keyword">file</span>) <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里要读入.class的字节，因此要使用字节流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">file</span>);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.<span class="keyword">read</span>(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.<span class="keyword">write</span>(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/SEU_Calvin/article/details/52315125" target="_blank" rel="external nofollow noopener noreferrer">这段代码是扒下来的</a></p><h4 id="URLClassLoader加载类"><a href="#URLClassLoader加载类" class="headerlink" title="URLClassLoader加载类"></a>URLClassLoader加载类</h4><p>在java.net包中，提供了URLClassLoader类，它可以从网上下载类。可以直接使用这个类作为自定义加载器。</p><p>构造方法: <code>URLClassLoader(URL[] urls)//父加载器是系统加载器</code></p><p><code>URLClassLoader(URL[] urls, ClassLoader parent)//指定父加载器</code></p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>java自带类加载器所加载的类是永远不会被卸载的。而用户自定义的类加载器可以被卸载。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java 异常处理</title>
      <link href="/post/e058ffd8.html"/>
      <url>/post/e058ffd8.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>有两种办法抛出异常：</p><ul><li>通过try-catch抛出，例如</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span> <span class="title">A</span><span class="params">(int money)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    try</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        if(--money&lt;=0)</span></span></span><br><span class="line"><span class="function"><span class="comment">        &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">            throw new SpecialException("Outof money");</span></span></span><br><span class="line"><span class="function"><span class="comment">        &#125;</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="title">catch</span><span class="params">(SpecialException e)</span></span></span><br><span class="line"><span class="function">    <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        处理异常</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><ul><li>在方法声明处声明抛出</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span> <span class="title">A</span><span class="params">(int money)</span><span class="title">throws</span> <span class="title">SpecialException</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    if(--money&lt;=0)</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        throw new SpecialException("Out of money");</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><p>每次抛出异常之后，都要找到catch块，如果在当前方法中没有找到，那么它将会弹出栈帧，到了上一级继续寻找知道找到。找到之后就执行catch块内容然后退出。</p><p>如果到最底部也没有找到catch块，那么就调用异常对象的printStackTrace()方法，打印异常信息。</p><p>如果该线程不是主线程，那么就会退出这一个线程，如果是主线程（main），那么就会退出程序。</p><p>抛出异常和处理异常最好在同一方法，不然对性能影响较大。</p><h4 id="finally-在任何情况下都要执行的代码"><a href="#finally-在任何情况下都要执行的代码" class="headerlink" title="finally 在任何情况下都要执行的代码"></a>finally 在任何情况下都要执行的代码</h4><p>因为异常处理会打断正常进程，所以可能会导致一些占用的资源不会被释放。在c++中就是动态内存分配的问题，在java中额例如关闭数据库链接，关闭输入流。</p><p>finally跟在catch后面，并且一定不能在前面。</p><h4 id="throws-抛出可能的异常"><a href="#throws-抛出可能的异常" class="headerlink" title="throws 抛出可能的异常"></a>throws 抛出可能的异常</h4><p>如果一个方法需要抛出异常，但没有能力解决异常，可以在方法头声明throws语句，在前面已经举过例子了。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>try后面可以有多个catch块，只能有至多一个finally块，也可以只跟finally块。</li><li>在try块中定义的变量，在catch和finally中不能访问。</li><li>每当try后面有多个catch时，会依次对catch块进行匹配，只需要匹配同一继承分支上的父类就会执行。例如， IOException是Exception的子类，如果抛出IOExpception且Exception的catch块在前那么就只会执行Exception。例：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code1;<span class="comment">//抛出FileNotfoundException</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLExceptio e)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"SOLException"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Exception"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"IOException"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个只会输出Exception，因为Exception和FileNotFoundException在还有IOException在同一继承分支上，每一次直接走Exception了，而不会走IOException。<strong>所以让子类的catch在前面，防止错误的catch</strong>。</p><ul><li>为了简化，可以用 | 分隔两个异常在一个catch块中进行处理。例如 catch( FileNotFoundException | InterruptedIOException e){…}</li><li>如果一个地方出现受检查异常，要么用throws，要么用try，不然会出现编译错误（这样也就方便些try了，不然写代码的时候还真不好说哪里有异常）。</li></ul><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p>正常流程是捕捉异常，执行catch，执行finally，退出。有两种退出方式</p><p>第一种使用System.exit(number);这种方法会直接退出程序，</p><p>第二种是return，退出本方法，这个时候如果有返回值还可以弄个返回值以便其他部分正常运行。finally执行于return之前。一般return是在catch中的，但是也可以在finally中，但是这样可能会导致问题。</p><ul><li>返回值覆盖，因为catch执行于return之前，所以如果要执行catch中的return，会先执行finally中的return，这个时候catch中的return就不会执行了。</li><li>丢失异常，如果在catch中抛出异常且finally中有return就可能发生异常丢失。这个时候catch中的异常就不会被抛出。此外，如果catch和finally中都抛出异常，那么catch中的异常将会丢失。</li></ul><p>为了解决丢失异常的问题，Throwable接口中有两个默认实现的方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> addSuppressed(Throwable exception)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Throwable[] getSuppressed()</span><br></pre></td></tr></table></figure></div><p>其中addSuppressed()方法就是把丢失的异常保存下来，getSuppressed就是返回所有保存下来的异常。当然，并不是系统自动添加，还要手动用这些方法去添加。</p><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p>java中用类来描述异常。所有异常的祖先是java.lang.Throwable类。它的实例就是具体的异常，可以通过throw抛出。它提供了一些常用方法，包括</p><ul><li>getMessage() 返回String类型的异常信息</li><li>printStackTrace() 打印跟踪方法调用栈获得的详细异常信息</li></ul><p>例如catch到这个异常后，可以<code>System.out.println(e.getMessage())</code>来输出异常信息。例如e里面的信息时Out of money（就是前面的），那么就会输出这个异常信息。</p><p>而如果用后面那个方法，将会说明哪个类，哪一行出现了异常。</p><p><img src="/images/20160603151809323" alt="异常类图"></p><ul><li>Error类，表示单靠程序本身无法恢复的严重错误，例如内存不足，或者栈溢出。</li><li>Exception类，表示程序可以处理的异常。出现这些异常时，可以进行处理而不退出程序。</li><li>IOException 输入输出时产生的异常。</li><li>ArithmeticException 数学异常。例如除以0</li><li>NullpointerException，空指针异常。当引用变量时null是，试图使用这个变量将会出现。</li><li>IndexOutOfBoundsException 下标越界异常</li><li>ClassCastException 类型转换异常，例如父类转子类</li><li>IllegalArgumentException 非法参数，例如 if(name==null)throw new IllegalArgumentException(“姓名不能为空”)。</li></ul><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>RuntimeException一个子树都可以叫运行时异常。这种异常特点是编译器不会检查他。例如上面说的数学异常。当这种异常出现的时候程序将异常终止。其他的都是受检查异常。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>可以通过继承来实现自定义异常。一般挂在Exception或RuntimeException上。</p><p>自定义异常要一般要写以下部分。</p><p>异常数据，异常原因（String类型），然后是一个带参数的构造函数。之后提供方法说明这个异常。</p><h4 id="异常转义异常链"><a href="#异常转义异常链" class="headerlink" title="异常转义异常链"></a>异常转义异常链</h4><p>原始的异常对于用户来说看不懂，这个时候我们就要抛出一些更人性化的异常。但是与此同时我们也要把原始异常保存易于我们排错。这个时候我们就可以在原始异常上进行扩展。扩展类的数据域中可以来一个Throwable的引用变量，然后在构造函数中把原始异常导入。这样就保存了原始异常。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Throwable</span> cause = <span class="literal">null</span>;</span><br><span class="line">    public <span class="type">BaseException</span>();</span><br><span class="line">    public <span class="type">BaseException</span>(<span class="type">Throwable</span> cause)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">BaseException</span>(<span class="type">String</span> msg, <span class="type">Throwable</span> cause)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div><h4 id="处理多样化异常"><a href="#处理多样化异常" class="headerlink" title="处理多样化异常"></a>处理多样化异常</h4><p>就是一次性抛出多个异常，这就需要先自定义一个异常类，收集多种异常然后一次性输出。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> int size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">List</span>&lt;<span class="type">Throwable</span>&gt;exceptions = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="type">Throwable</span>&gt;();</span><br><span class="line">    public void addExcpetion(<span class="type">BaseException</span> ex)</span><br><span class="line">    &#123;</span><br><span class="line">        exceptions.add(ex);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>记录日志的作用：监视代码中变量情况，周期性的记录到文件中供其他应用统计分析。承担继承开发环境中调试器作用。</p><p>要在程序中输出日志，最普通的办法是用println输出。比较好的做法是用一个日志操作类。</p><p>现在可以直接使用java.util.logging日志操作包。这个包中主要有四个类</p><ul><li>Logger类：生成日志，并对日志信息分级筛选，确定什么等级被输出，什么不输出。</li><li>Handler： 负责输出日志信息。它有两个子类：ConcoleHandler（输出到Dos控制台），FileHandler（输出到文件中）</li><li>Level类： 表示日志各个界别。</li></ul><h4 id="创建及设置级别"><a href="#创建及设置级别" class="headerlink" title="创建及设置级别"></a>创建及设置级别</h4><p>创建 <code>Logger mylogger = Logger.getLogger(&quot;mylogger&quot;);</code></p><p>getlogger就是用来创建对象的。如果mylogger存在，那么直接返回引用。</p><p>级别： SEVERE(严重）， WARNING(警告），INFO , CONFIG(确认），FINE（好），CONFIG,FINE,FINER,FINEST</p><p>默认情况下，只会输出最高三个级别的。可以使用Logger类的setLevel()来设置级别。例：<code>mylogger.setLevel(&quot;Level.FINE&quot;)//把日志设置成FINE级别</code>。这样设置FINE及以上级别都会被设置。还有Level.on开启所有级别和Level.off关闭所有级别。</p><p><code>mylogger.info(&quot;这是一条普通提示消息&quot;)</code>用级别的名字设置提示消息</p><h4 id="输出日志到文件"><a href="#输出日志到文件" class="headerlink" title="输出日志到文件"></a>输出日志到文件</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileHandler fileHandler = <span class="keyword">new</span> <span class="constructor">FileHandler(<span class="string">"C:\\test.log"</span>)</span>;</span><br><span class="line">fileHandler.set<span class="constructor">Level(Level.INFO)</span>;<span class="comment">//设定向文件中写日志的级别</span></span><br><span class="line">mylogger.add<span class="constructor">Handler(<span class="params">fileHandler</span>)</span>;<span class="comment">//将FileHandler与Logger关联</span></span><br></pre></td></tr></table></figure></div><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>语法： assert 条件表达式 或 assert 条件表达式 : 包含错误信息的表达式。</p><p>作用： 当条件表达式为false时，会抛出AssertError，这是一个错误。如果后面有包含错误信息的表达式，那么将会输出后面的内容</p><p>例如： assert b!=0 : ”b不能为0“；</p><p>启用断言需要-ea参数，而IDEA中默认是关闭的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/post/5951da65.html"/>
      <url>/post/5951da65.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="接口的基本特征"><a href="#接口的基本特征" class="headerlink" title="接口的基本特征"></a>接口的基本特征</h3><p>在java中接口有两种意思</p><ul><li>第一种是概念性的接口，指的是封装的内容对外界提供的服务（一开始一听接口一定以为就是这个吧）</li><li>第二种是一种接口类型</li></ul><p>定义接口使用interface关键字，实现接口使用implement关键字。这个类似于父类和子类。</p><p>注意点：</p><ul><li>接口成员变量默认是public或static或final类型的，必须显示初始化。例如<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> b;</span><br><span class="line">    <span class="built_in">int</span> c = <span class="number">3</span>;<span class="comment">//正确，显式初始化表示定义同时要赋值，并且默认是上面三种类型</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure></div></li><li>方法默认是public abstract类型。JDK8开始才可以有默认方法和静态方法之前只能有抽象方法。默认方法用<strong>default关键字</strong>声明，可以有自己的实现，接口实现类可以直接访问默认方法，也可以覆盖它。静态方法可以在接口内部访问或者实现接口的类通过使用接口名字来访问。<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span>;<span class="comment">//默认是public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method3</span>(<span class="params"></span>)</span>;<span class="comment">//编译器默认是public的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span>(<span class="params"></span>)</span>;<span class="comment">//不可以，必须要有abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li>接口没有构造方法，不能够被实例化</li><li>接口可以继承于多个接口，但是不能实现接口。例如：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">&#125;</span><br><span class="line">public<span class="built_in"> interface </span>B</span><br><span class="line">&#123;&#125;</span><br><span class="line">public<span class="built_in"> interface </span>C extends A,B</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>与子类继承抽象父类相似，当类实现某个接口时，<strong>必须要重写接口中的所有抽象方法，否则这个类必须定义成抽象类</strong>。</li><li>不允许创建接口的实例，但允许创建接口类型的引用变量，该变量引用实现了接口的类的实例（也可以看成是子类的实例）</li><li>一个类只能够继承一个父类，但可以实现多个接口。例如：<br><code>public class A extends Base implement intera, interb{...}</code>。并且一个接口也可以由多个类来实现。</li></ul><p>接口可以在一定程度上弥补一个类只能有一个直接父类的遗憾，有利于扩展。</p><h3 id="接口模式"><a href="#接口模式" class="headerlink" title="接口模式"></a>接口模式</h3><h4 id="定制服务模式"><a href="#定制服务模式" class="headerlink" title="定制服务模式"></a>定制服务模式</h4><p>这种模式就是利用接口可以继承多个接口，把多个子功能整合到一起变成一个大的服务。例如一个套餐里面有流量服务，电话服务，语音服务等等。这些都是一个接口。之后整合成整个的套餐包含上述服务</p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>适配器就是用来做两个系统之间转换的。有两种方式实现转换。</p><p>第一种就是通过继承，继承源类的实例和目标类的接口。</p><p>第二种是通过组合，组合两种类的接口，然后实现。</p><p>例如，一个接口有add（a,b)函数，另一个有addone(a)函数，第二个函数不能作用是让a+1，但是它没有加法（假设）。这时我们设计一个接口，继承上面两个接口，这样我们就有办法用原接口的实现类从而实现加法完成第二个方法。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>这种适配器其实是一个类，因为接口中都是抽象函数，所以当你使用适配器的时候不得不实现所有功能-即使你只想实现一个。所以干脆实现了一种类，这个类实现了所有抽象方法，但是内容全是空。这样再用其他类继承这个类就可以一次实现一种了。</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理人其实就是中间人，代理类和代理人类似，这个类负责预处理一些消息，例如钱少于多少就直接拒绝。也负责向委托类传递信息。</p><h4 id="标识类型模式"><a href="#标识类型模式" class="headerlink" title="标识类型模式"></a>标识类型模式</h4><p>标识类型一般是标识某一类事物。例如事物，树，人物等等。使用这种接口而不是直接使用一个类的好处是便于同一管理。</p><h4 id="常量接口"><a href="#常量接口" class="headerlink" title="常量接口"></a>常量接口</h4><p>常量接口就是把一些常量放到一起。要使用的时候直接implements就可以了。</p><p>但是这种接口有一个弊端，就是破坏了封装性。为了解决这个问题，可以使用import static语句。import static允许直接访问另一个类的静态常量</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java 继承和多态</title>
      <link href="/post/17862176.html"/>
      <url>/post/17862176.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>利用extends来进行继承，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以上表明Sub类继承Base类，具体继承还要分两种情况。</p><ul><li>如果在同一个包中，那么Sub继承了Base中的public，protected和默认访问级别的成员变量和方法</li><li>如果在不同的包中，不继承默认访问级别的成员变量和成员方法，其他和上一个相同。</li></ul><p>默认访问级别就是前面没有加任何关键字。</p><p>java不支持多继承，一个类只能继承于一个类，但是父类可以有多个子类，就像一棵树。下级继承会继承同一分支上所有的成员和方法。</p><p>java中有一个所有类的祖先叫object类，如果没有使用extends关键字那么会自动继承这个类。</p><h3 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h3><p>覆盖指的是父类中的函数在子类中重新写。要满足下列条件：</p><ul><li>子类方法名称，函数签名（包括参数位置）和返回类型都要和父类方法一致</li><li>在子类中，必须要先覆盖函数，才可以重写函数</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Base类中：</span><br><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Sub</span>类中：</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">int</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">这样会报错</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果<span class="title">Sub</span>类这样</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">int</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function">这样可以编译通过</span></span><br></pre></td></tr></table></figure></div><ul><li>子类方法不可以缩小父类的访问权限，如果父类的方法时private那么子类就不能写public</li><li>子类不能抛出比父类更多的异常</li><li>子类无法覆盖父类的静态方法，只能够隐藏。这两者的区别是覆盖的话父类可以使用子类的，子类也可以使用父类的。隐藏的话父类只能使用父类的，子类只能使用子类的。这是由于static定义的区域所决定的。<br>例：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package newpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------</span><br><span class="line">package newpackage;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newsec</span> <span class="title">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Sub"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Sub"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base a = <span class="keyword">new</span> newsec();</span><br><span class="line">        a.method();</span><br><span class="line">        a.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出时Base和Sub</span><br></pre></td></tr></table></figure></div><ul><li>可以扩大访问权限。并且如果是抽象类，子类可以只扩大访问范围而不做任何事.但是必须要实现它，不然只能让子类也定义成抽象类。</li></ul><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">父类定义类A()的抽象方法，子类可以这样</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">这也算实现</span><br></pre></td></tr></table></figure></div><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super和this一样都是指向一个对象，不同的是super指向父类，this指向自己。</p><p>使用场合：</p><ul><li>局部变量和类变量重名</li><li>子类覆盖了父类的方法或成员变量时，可以用这种方法使用父类的方法</li></ul><p>需要注意，如果父类成员变量和方法被定义成private，那么子类无论如何都无法访问他们。不能再静态方法区使用super关键字。</p><p>此外如果在父类第一行使用super()是调用父类构造函数</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是父类可以使用子类，子类也可以使用父类（自我理解）。下面讲具体使用规范。<br>儿子可以用爸爸一切公有的，而爸爸如果引用了自己的实例就不能用儿子的，只有引用了儿子的实例才可以使用儿子继承于爸爸的。</p><ul><li>对于一个引用类型变量，编译器按声明变量进行处理。例如</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Base </span>who = new <span class="keyword">Sub();</span></span><br><span class="line"><span class="keyword">who.subVar </span>= <span class="string">"123"</span>;</span><br><span class="line">这里编译会出错，无论后面引用了谁，who都是<span class="keyword">Base类，而父类不能直接使用子类的变量</span></span><br></pre></td></tr></table></figure></div><ul><li><p>编译器允许继承分支关系的类进行类型转换。对于向上转型（子类使用父类的），编译器会自动类型转换。对于向下转型则需要强制类型转换。在运行时，子类可以转换成父类，但是父类实际上无法转换成子类。因为父类有的子类一定有，子类有的父类却不一定有。</p></li><li><p>对于引用对象绑定，遵循如下规则</p><ol><li>对于实例方法和引用变量是由实际使用的对象进行绑定。这个是动态的，也就是说方法的实际输出是由实际类型所决定。例如 Base a = new Sub();输出时Sub的。如果这个时候Sub的子类b = a;那么输出还是Sub的。但是如果使用了子类中独有的方法会报错</li><li>静态方法和成员变量由前面定义的类型所决定，这属于静态绑定，在编译时期已经决定。无论引用了谁都不会改变。</li></ol></li></ul><h3 id="继承的使用"><a href="#继承的使用" class="headerlink" title="继承的使用"></a>继承的使用</h3><p>继承树的最上层一般是抽象层。并且继承树上有接口类型，那么尽可能的把应用变量声明成继承树上层的接口类型。因为实例可以是子类，向上转型不会出现问题，这样便于使用多个子类，如果想用子类独有的东西就把引用变量定义成子类。</p><p>继承关系会打破封装，因为上层类改变会使下层类也跟着改变。所以对上层类定义要谨慎。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><table><thead><tr><th>修饰符</th><th>类</th><th>成员方法</th><th>构造方法</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>abstract（抽象的）</td><td>有</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>static（静态的）</td><td>无</td><td>有</td><td>无</td><td>有</td><td>无</td></tr><tr><td>public</td><td>有</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>protected</td><td>无</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>private</td><td>无</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>synchronized（同步的）</td><td>无</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>native（本地的）</td><td>无</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>transient（暂时的）</td><td>无</td><td>无</td><td>无</td><td>有</td><td>无</td></tr><tr><td>volatile（易失的）</td><td>无</td><td>无</td><td>无</td><td>有</td><td>无</td></tr><tr><td>final（不可改变的）</td><td>有</td><td>有</td><td>无</td><td>有</td><td>有</td></tr></tbody></table><p>表中的类指的是顶层类，与内部类相对应（内部类是定义在类或方法中的类）。</p><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><p>访问控制指的是其他类或对象可以查看的东西。一共有四种访问级别</p><ul><li>public 所有都是可以给外部看的</li><li>protected 只对子类和一个包中的类公开</li><li>默认级别 没有修饰符 只对同一个包中的类公开，不对子类公开</li><li>private 不对外公开</li></ul><p>public&gt;protected&gt;默认&gt;private。public与其他不同是其他包也可以查看</p><p>顶层类只能是public或protected，不然会出现编译错误。</p><p>访问级别是对成员变量和类来说的，对局部变量没有意义，局部变量的访问范围就是方法内部。</p><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p>用abstract修饰的类表示抽象类，抽象类不允许实例化，也就是抽象类不允许创建实例</p><p>用abstract修饰的方法表示抽象方法，抽象方法内部没有内容，只有一个函数头。</p><p>注意，如果有抽象方法，这个类必须定义成抽象类。此外，没有抽象静态方法，abstract和static是互相矛盾的。</p><p>抽象类本身不可以实例化，但是可以创建一个抽象类的引用变量然后引用具体类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base a = <span class="keyword">new</span> <span class="type">Base</span>();<span class="comment">//不可以，因为Base是抽象类</span></span><br><span class="line">Base b = <span class="keyword">new</span> <span class="type">Sub</span>(); <span class="comment">//Sub是具体类</span></span><br></pre></td></tr></table></figure></div><p>抽象方法不可以用private修饰，因为抽象出来本来就是要让子类去实现的，private一下子类就无法使用了。</p><p>子类必须实现抽象类的所有抽象方法。</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final有不可改变的含义。</p><p>用final修饰的类不能被继承，没有子类</p><p>用final修饰的方法不能被覆盖</p><p>final修饰的变量表示常量，只能赋一次值</p><p>final不能用来修饰构造方法。</p><p>final修饰引用变量，这个变量不能只能引用一个实例，但是可以对这个实例进行修改。</p><p>不允许覆盖就是不能用相同的函数签名去重写这个函数</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul><li>static修饰的成员变量时静态变量，可以直接通过类名进行访问，并且所有实例共用一个静态变量</li><li>修饰成员方法表示静态方法，可以直接通过类名访问</li><li>修饰的程序代码块叫做静态代码块，加载类时会执行这些代码块</li></ul><p>静态变量只有一份备份，处于方法区，在加载类的时候随之加载。</p><p>注意，在静态方法中没办法用this，因为静态方法时所有类共有的，this表示的是某个特定的类。所以在main方法中不能用this和super，因为main是static的，如果想访问这个类的内容，可以先定义一个该类的引用变量。</p><p>如果直接访问了，编译器会报<strong>在静态方法内不允许访问非静态变量</strong>。</p><p>main函数必须是static的原因是只要加载了main所在的类main就被加载了，可以直接去执行，不然还要先创建一个类然后使用main方法。</p><p>类中可以包含一些静态代码块，这些代码块不存在与任何方法中，加载类时一次执行这些代码块。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"First Static code i="</span> + i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>static代码块和静态方法一样，不可以直接调用实例变量和实例方法，只用通过先引用之后才可以进行调用。</p><h5 id="static进行静态导入"><a href="#static进行静态导入" class="headerlink" title="static进行静态导入"></a>static进行静态导入</h5><p>静态导入类似于c++中的using namespace std;可以简写代码。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">import</span>.<span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out.<span class="built_in">println</span>(MIN_VALUE);<span class="comment">//原来是Integer.MIN_VALUE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>但是如果静态导入过多，可能会导致冲突，因此尽量导入的时候具体一点。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java switch foreach</title>
      <link href="/post/4c720881.html"/>
      <url>/post/4c720881.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch的条件（switch括号中的内容）可以有一下几种。</p><ul><li>可以自动转换成int的类型（byte,short,int,char)</li><li>字符串类型<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AUTOIT"><figure class="iseeu highlight /autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> color = <span class="string">"red"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">switch</span>(color)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">   System.out.println(<span class="string">"红色"</span>)<span class="comment">;</span></span><br><span class="line">   <span class="built_in">break</span><span class="comment">;</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">"blue:</span></span><br><span class="line"><span class="string">   System.out.println("</span>蓝色<span class="string">");</span></span><br><span class="line"><span class="string">   break;</span></span><br><span class="line"><span class="string"> default:</span></span><br><span class="line"><span class="string">   System.out.println("</span>其他颜色<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div></li><li>枚举类型<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRYSTAL"><figure class="iseeu highlight /crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Colour</span>(<span class="title">red</span>,<span class="title">blue</span>);</span></span><br><span class="line">Colour c = Colour.red;</span><br><span class="line">Switch(c)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><h3 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h3></li></ul><p>foreach是for的特殊简化版本。用来遍历数组或集合</p><p>语法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(变量类型 变量名 : 待输出的集合或数组)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其实这也只能说是稍稍简化，直接写for就可以了。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java 操作符</title>
      <link href="/post/4b1879e3.html"/>
      <url>/post/4b1879e3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>c++中没有 &gt;&gt;&gt;(逻辑右移）操作符，这是在java中才有的。c++想要实现逻辑右移的功能要么进行更复杂的运算要么用unsigned。<a href="https://xinhecuican.github.io/post/61738.html">这篇博客中详细讲了算术右移和逻辑右移</a></p><p>浮点数不支持移位运算。并且如果其中一个浮点数是double型，结果就是double型。</p><table><thead><tr><th>逻辑运算符（部分）</th><th>操作</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>短路与</td></tr><tr><td>&amp;</td><td>非短路与</td></tr><tr><td>两竖线</td><td>短路或</td></tr><tr><td>一竖线</td><td>非短路或</td></tr></tbody></table><p>短路与非短路的区别是对于短路运算符如果左边可以判断，那么就不会去判断右边。非短路运算符无论条件如何都会执行两边。</p><p>非短路运算符的作用是有时我们先要进行一些运算再判断，非短路运算符可以确保运算的执行。例如 if(b == true &amp; (output+=10) == 20 ).其中output+=10就是运算，</p><h3 id="操作符在对象中"><a href="#操作符在对象中" class="headerlink" title="==操作符在对象中"></a>==操作符在对象中</h3><p>当==操作符在对象中时，两个引用变量必须是引用同一个对象，结果才为true。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Integer <span class="built_in">int</span>1 = new Integer(<span class="number">1</span>);</span><br><span class="line">Integer <span class="built_in">int</span>2 = new Integer(<span class="number">1</span>);</span><br><span class="line">Integer <span class="built_in">int</span>3 = <span class="built_in">int</span>1;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="built_in">int</span>1 == <span class="built_in">int</span>2);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="built_in">int</span>1 == <span class="built_in">int</span>3);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></div><p>可见哪怕赋了一样的值两个对象还是不同的。</p><h4 id="与多态"><a href="#与多态" class="headerlink" title="== 与多态"></a>== 与多态</h4><p>想要使用必须要两个类是相同的或者处于同一分支。例如 cat和dog都继承与animal类，cat可以和animal进行比较，但是cat不能和dog进行比较。</p><p>数组也是引用类型，可以用==进行比较，但是前提是两边变量类型必须相同，例如一个int型和一个long型进行比较就会报错。</p><h4 id="对象的equal（）方法"><a href="#对象的equal（）方法" class="headerlink" title="对象的equal（）方法"></a>对象的equal（）方法</h4><p>有些jdk中的一些类覆盖了object类的equal（）。这种情况下比较就是如果类型一致且内容一致（数据域），那么就返回true，否则返回false。例如String类。</p><p>所以如果要进行字符串比较的话，必须使用equal方法。不然除非是复制的两个字符串，不然即使内容相同也会出错。</p><h3 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h3><p>instanceof操作符用于判断引用类型所引用的对象是否是一个类或其祖先的实例。如果是返回true。</p><p>格式： 实例名 instanceof 类名或接口名</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = <span class="keyword">new</span> <span class="constructor">Dog()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(dog instanceof Dog);</span><br><span class="line"></span><br><span class="line">output: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">同时如果Dog替换成dog的父类或祖先类，或Dog类或其祖先实现的接口时，都会返回<span class="literal">true</span></span><br></pre></td></tr></table></figure></div><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><strong>自动类型转换</strong></p><p>总的规则就是小的和大的相乘结果是大的。浮点数和整数相乘结果是浮点数。</p><p><strong>强制类型转换</strong></p><p>把高位类型赋值给低位类型，结果一定要进行强制类型转换（显式转换）。由小到大进行自动类型转换。</p><p>例 ：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">int</span> i = (<span class="built_in">int</span>)<span class="number">3.14</span>;</span><br><span class="line">long j = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">int</span> i2 = (<span class="built_in">int</span>)j;</span><br><span class="line"></span><br><span class="line">其中只有第一个是不合法的，因为浮点数默认是<span class="built_in">double</span>型。</span><br></pre></td></tr></table></figure></div><p>此外，如果超过了数据范围也必须强制类型转换。</p><p>char c = -1;//错误，因为超过了数据范围</p><p>char c = 97;//正确</p><p><strong>引用类型的强制转换</strong></p><p>子类复制给祖先类，会自动进行类型转换。而父类给子类则必须进行强制类型转换。</p><p>如果不在统一继承分支上则不可以进行转换。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EBNF"><figure class="iseeu highlight /ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Animal cat</span> = new Cat();</span><br><span class="line"><span class="attribute">Dog dog</span> = (Dog)cat;</span><br></pre></td></tr></table></figure></div><p>上面的代码可以通过编译，但是在运行时会跑出ClassCastException异常</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java 数据类型和变量</title>
      <link href="/post/f201f9fd.html"/>
      <url>/post/f201f9fd.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>因为是记笔记，这里只说一下和c++不同的地方。</p><p>定义及使用的方式和c++基本一致，就是有些名字改了而已。</p><p>类变量自动初始化，boolean初始化为false，其他初始化为0。但是普通的变量还有自己初始化。这里和c++不同的是如果没有初始化会报错。当然，如果一直没有使用的话不初始化也不会报错。</p><p>boolean 就是c++中的bool型。但是有一点不同，这里只能赋true or false，赋一个整数变成bool型是不可以的。但是无语的是底层实现其实还是非零是true，零是false。也就是说，在java中,int i = 1; if(i)的行为是不被允许的，因为整型不可以变成boolean型。</p><p>byte 一个字节，和char不同，这个是整型的。当然，java中也有char</p><p>在java中，如果数学表达式都是整数，则返回值只能是int或long型。如果把返回值赋给byte型，要进行强制类型转换。<strong>强制类型转换例：byte a = (byte)(1+1);</strong></p><p>可以用下划线分隔，例如：int a = 10_000_000;实际上就是1000万，这样可以增加可读性。</p><p>此外，可以在后面加尾标表示类型。例如 l是long型，f是float，D是double。S是short，C表示char。例如： 100L。</p><p>小数没有后缀默认是double型</p><h4 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h4><ul><li>如果int型直接赋给byte，short或char型的时候，如果在数据范围内，可以直接赋值，如果超出数据范围，必须要进行强制类型转换，而且是显式的，不然会报错。超出部分直接截断，没超出的再按对应编码方式解释。</li></ul><p>byte b = 129;//错</p><p>byte b = (byte)129;//对</p><ul><li>浮点型赋给整型必须要进行强制类型转换，而整型给浮点型不要</li><li>double给float要强制类型转换，而float给double不要</li></ul><p><strong>java语言编码</strong></p><p>java采用UCS-2编码，字符占两个字节，把字符看成无符号整数对待。一般来说不用记字符的编码，但是像一些特殊的例如<code>&#39;</code>如果直接char c = ‘’’就会出错。所以可以加反斜线进行转义。char c = ‘&#39;‘</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用可分为类引用，接口引用，数组引用。</p><p>类引用引用类的实例，接口引用引用接口的实例，数组引用引用数组的实例（数组页看成对象）。无论是哪种，都是引用一个对象</p><p>如果没有引用一个实例，可以赋值成null，例如：</p><p>Doll a = null;</p><p>Doll a = new Doll(“beibei”);</p><p>用new关键字可以创建一个对象，它做了下面的事：</p><ul><li>为对象分配空间，并将变量初始化</li><li>调用构造方法</li><li>返回对象引用</li></ul><h4 id="实例变量和静态变量和静态函数"><a href="#实例变量和静态变量和静态函数" class="headerlink" title="实例变量和静态变量和静态函数"></a>实例变量和静态变量和静态函数</h4><p>类的成员变量有两种，一种是static修饰的变量，叫做类变量，或静态变量。一种是普通的实例变量。</p><p>静态变量就是归所有实例所共享的。而普通变量就是每一个实例所独有的。</p><p>静态变量储存在方法区，而普通变量存放在堆区。想到java类方法的访问过程就可以知道方法区是存放一些共有的东西，例如方法的二进制代码。每个类使用方法时直接调用就可以了。</p><p>静态函数有几个特点：</p><p>如果不是类中的静态函数，那么只能在当前文件中使用，相当于权限是private。</p><p>如果是类中的静态函数，只能使用静态变量，也不能调用类中的非静态成员函数。</p><p><strong>this</strong></p><p>java中也有this指针，也是指向当前对象，但是使用的是点操作符而不是箭头。使用上与c++大致相同，</p><p>例： owner.setdog(this)//this代表当前dog的对象</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>如果传递的是基本数据类型，那么就传递参数的值（值传递？）。如果是对象或者数组，那么就是引用传递。注意数组不是指针传递了，因为java中好像没有指针的概念。所以这里数组应该也可以作为返回值（纯推测，还没看到）。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java初探</title>
      <link href="/post/912b2566.html"/>
      <url>/post/912b2566.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h3><p>java源文件可能包含以下内容：</p><ul><li>包声明语句</li><li>包引入语句</li><li>类声明</li><li>接口声明</li></ul><p>这些内容都不是必须的。此外要注意只能有一个类或接口是public的（一般也是private）。</p><h4 id="包声明语句"><a href="#包声明语句" class="headerlink" title="包声明语句"></a>包声明语句</h4><p>包声明语句把类放到特定的包中。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="NIMROD"><figure class="iseeu highlight /nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package com.abc.dollapp;</span><br><span class="line">public calss appmain<span class="meta">&#123;...&#125;</span>;</span><br><span class="line">class doll<span class="meta">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure></div><p>在这个例子中appmain和doll都在com.abc.dollapp包中。</p><p>在一个java文件中，只能有一个package语句。如果没有提供package，那么就表明在系统默认的包中。</p><h5 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h5><ol><li>用于区分名字相同的类。例如定义了两中车类名都叫car，一种实际上是奔驰，一种是宝马。把他们丢在不同的包中就可以区分他们，相当于使用了不同的命名空间[^1]。</li></ol><p>[^1]:命名空间实际上就是在函数前的一些附加消息。因为可能同时引入了多个库，库文件中可能某些函数名字相同，这个时候只有通过前面添加一些信息来辨别。典型例子就是using namespace std;这个含义就是使用标准命名空间。不然就要写std::cout来进行辨别。<br>2. 有助于访问权限的控制。但不同包之间进行访问时，就会受到访问权限的控制。<br>3. 有助于组织划分各个类。</p><h5 id="包的命名规范"><a href="#包的命名规范" class="headerlink" title="包的命名规范"></a>包的命名规范</h5><p>包的名字通常用小写，一般包含以下信息：</p><ol><li>类的创建者信息</li><li>类所属软件信息</li><li>类在具体项目中所处的位置</li></ol><p>jdk提供了一些基本包</p><ul><li>java.lang包，包含线程类（Thread)，异常类（Exception），系统类（System），整数类（Integer），字符串类（String）等。这个包系统会自动引入。</li><li>java.awt。抽象窗口工具包。用于构建GUI界面和绘图类</li><li>java.io 输入输出包。例如文件输入类（FileInputStream类）</li><li>java.util 实用类，例如日期类（Date）集合类（Collection）</li><li>java.net 支持TCP/IP网络协议。</li></ul><h5 id="包引入"><a href="#包引入" class="headerlink" title="包引入"></a>包引入</h5><p>如果一个类访问了另一个包的类，那么一定要引入这个类（就像c++中的库引入一样）。</p><p>语法： import 包名.类名</p><p>如果想引入一个包中所有类， 可以 import 包名.*</p><p>要注意最好使用第一种语法，因为第二种不仅耗时大并且还可能带来类名重复的问题，这个时候每写一个类都要写它的包名。</p><p>并且如果包中还有包的话，第二种语法是不会把内层包的类引入的。之所以可以包中有包是为了保证层次结构。例如前面提到的com.abc其实就是包中有包，com是外层，abc是内层。</p><p>package语句必须在import前</p><h4 id="方法（函数）声明"><a href="#方法（函数）声明" class="headerlink" title="方法（函数）声明"></a>方法（函数）声明</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DUST"><figure class="iseeu highlight /dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">返回值 函数名（参数）</span></span><br><span class="line"><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    主体</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这里的函数和c++大致相同</p><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>main方法和c++不一样了，要包含几个要素</p><ul><li>访问限制 public</li><li>静态方法 static</li><li>参数 main(String args[])</li><li>返回类型 void</li></ul><p>所以合起来就是 static public void main（String args[])</p><h5 id="给main传递参数"><a href="#给main传递参数" class="headerlink" title="给main传递参数"></a>给main传递参数</h5><p>格式： java classname [args…]</p><p>classname指的是类名</p><p>例如： java com.abc.dollapp.main.MainApp parameter0 parameter1</p><p>也就是c++中的argc，argv</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>第一种 //</p><p>第二种 <code>/*...*/</code></p><p>第三种 <code>/**...*/</code>，当这种注释出现在类的声明时，会作为javadoc的内容</p><h4 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h4><p>关键字之后慢慢就会知道</p><p>标识符命名规则：</p><ul><li>首字母必须是字母，下划线（_)，符号￥或符号$。</li><li>除开首字母其他字符可以用数字</li><li>没有长度限制</li></ul><h3 id="用jdk管理java应用"><a href="#用jdk管理java应用" class="headerlink" title="用jdk管理java应用"></a>用jdk管理java应用</h3><p>java常用目录（防止以后看到这些目录都不知道是干什么的）</p><table><thead><tr><th>src</th><th>存放源文件</th></tr></thead><tbody><tr><td>classes</td><td>存放编译生成的java文件</td></tr><tr><td>lib</td><td>存放第三方java软件的JAR文件（不要问我这是什么）</td></tr><tr><td>doc</td><td>存放帮助文档</td></tr><tr><td>doc\api</td><td>存放javadoc文档</td></tr><tr><td>deploy</td><td>存放打包文件，jar文件</td></tr></tbody></table><h3 id="使用javadoc文档"><a href="#使用javadoc文档" class="headerlink" title="使用javadoc文档"></a>使用javadoc文档</h3><p>java中有一个程序，可以识别类中的注释并将其转化成html文件。只有满足规范的文件才可以转化。</p><p>首先的规范就是注释要<code>/**...*/</code>才可以。里面可以有普通文件，html标记和javadoc标记。</p><p>范围：javadoc命令只处理类声明，接口声明，成员方法声明，成员变量声明，以及构造方法<strong>之前</strong>声明的注释。也就是说要在函数或类等的外面去声明。</p><h4 id="javadoc标记"><a href="#javadoc标记" class="headerlink" title="javadoc标记"></a>javadoc标记</h4><table><thead><tr><th>标记</th><th>说明</th></tr></thead><tbody><tr><td>@version</td><td>版本</td></tr><tr><td>@since</td><td>指定最早出现在哪个版本</td></tr><tr><td>@author</td><td>作者</td></tr><tr><td>@see</td><td>生成参考其他javadoc的链接</td></tr><tr><td>@link</td><td>生成链接，但是还可以添加其他的话</td></tr><tr><td>@deprecated</td><td>表示某些类或方法不提倡使用，之后可能会被废弃</td></tr><tr><td>@param</td><td>描述方法参数</td></tr><tr><td>@return</td><td>返回值</td></tr><tr><td>@throws</td><td>描述方法抛出的异常，指出抛出异常的条件</td></tr></tbody></table><p>@see用于生成到其他文档的链接。例如<code>@see #setWord</code>生成到setWord的链接。一共有三种格式</p><ul><li>set com.abc.dollapp.doll 生成到其他类的javadoc文档</li><li>set #setWord 生成当前类不同方法的javadoc文档</li><li>set com.abc.dollapp.doll#speak 生成到其他类的某一个方法的javadoc文档</li></ul><p>至于link在语法上与set大致相同，但是他可以用大括号插入到某一句话中，例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 如果&#123;<span class="variable">@link</span> <span class="comment">#word word成员变量&#125;不为NULL；</span></span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure></div><p>输出： 如果word<u>成员变量</u>不为NULL；</p><p>javadoc命令用法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="D"><figure class="iseeu highlight /d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">public</span> 仅为<span class="keyword">public</span>级别的类建立文档</span><br><span class="line">-<span class="keyword">protected</span> 进位<span class="keyword">public</span>和<span class="keyword">protected</span>建立文档 默认选项</span><br><span class="line">-<span class="keyword">package</span></span><br><span class="line">-<span class="keyword">private</span></span><br><span class="line">-<span class="keyword">version</span> 解析<span class="keyword">version</span>标记，默认情况会忽略</span><br><span class="line">-author </span><br><span class="line">-sourcepath&lt;path&gt; 指定源文件路径</span><br><span class="line">-classpath</span><br><span class="line">-d &lt;directory&gt; 指定javadoc的输出目录</span><br></pre></td></tr></table></figure></div><p>语法： javadoc [options] [packagenames] [sourcefiles]</p><h3 id="java虚拟机运行java的基本原理"><a href="#java虚拟机运行java的基本原理" class="headerlink" title="java虚拟机运行java的基本原理"></a>java虚拟机运行java的基本原理</h3><p>过程：先进行编译，之后进入虚拟机中变成机器指令。具体过程就不解释了，但是这里有一步就是根据操作系统进行运行。而java程序使运行在虚拟机上的。所以编译出来的文件可以在任何平台上运行。</p><p>系统会先给虚拟机分配一个空间。虚拟机又会把这个空间分成若干个部分。主要包括堆区，栈区，方法区等等。堆中存放对象，方法区中存放类的类型信息，方法信息和静态变量等等。</p><p>运行程序时，先要把程序的二进制加载到内存，然后对程序进行验证（包括初始化），之后再执行。</p><p>当生成一个实例时，虚拟机会先搜索方法区，如果方法区没有，那么就会先加载这个类。之后在堆区分配一片内存用来存放实例，实例有一个指向方法区的指针。这个实例用一个局部指针指向它（也就是实例名，和数组很像，不是说java不提供指针吗）。</p><p>所以运行一个java方法的过程是：先由类名到堆区，然后堆指向方法区的指针把对应的方法取出来（机器指令）。</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title> UML简介</title>
      <link href="/post/5f9e4eff.html"/>
      <url>/post/5f9e4eff.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>简单来说UML就是结构图，表示对象与类，类与类之间的联系。</p><p>UML主要包含以下框图：</p><ul><li>用例图 从用户角度描述系统功能，简单来说就是用户让系统干什么（也可以说是系统的输入）</li><li>类框图 表示类与类之间的联系</li><li>状态转换图 这是针对有不同状态的类。类如开关的开和关就是状态的转换</li><li>时序图和协作图 时序图是在时间维度上描述用户的输入和类的使用。协作图则用箭头表示而不是通过时间轴表示</li></ul><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>用例图的要素有</p><ul><li>用户 画成一个人型</li><li>用例 系统的某一个功能，大多数时候就是某一个函数，用椭圆表示</li><li>关系，用箭头表示</li></ul><p>也可以用用例文档补充描述。</p><ul><li>前置条件，什么时候才可以输入</li><li>主事件流，也就是这个用例干了什么事</li><li>其它事件流， 比如错误了该干什么事</li><li>后置条件 用例必须为真条件（个人理解是什么时候可以输出）</li></ul><h3 id="类框图"><a href="#类框图" class="headerlink" title="类框图"></a>类框图</h3><p>类框图是表示类与类之间的关系（静态）。这个意思就是这个关系使不变的，做了一个就要去做另一个。</p><p>要素： 用一个方框表示类，方框的上面是类名，下面是函数名。用箭头表示方框之间关系。</p><h3 id="时序图与协作图"><a href="#时序图与协作图" class="headerlink" title="时序图与协作图"></a>时序图与协作图</h3><p>时序图有两个要素，</p><p>垂直上表示时间，水平上表示发送消息的过程。（用函数名和箭头表示）</p><p><img src="/images/%E4%B8%8B%E8%BD%BD.png" alt></p><p>协作图就用一个个箭头表示时间之间关系的。</p><p><img src="/images/20151113162700894" alt></p><h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p>要素：</p><ul><li>初始点 实心圆</li><li>状态之间的转换 箭头</li><li>状态 用圆点表示</li><li>终止点 用一个圆里面再加一个实心圆表示</li></ul><p>例：<br><img src="/images/20170305152530328.png" alt></p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><ul><li>关联 一个类和另一个类的实例有联系，例如老师和学生有联系。</li><li>依赖 A类访问类B提供的服务。例如A调用B的函数</li><li>聚集 A为整体类，B为局部类。A对象有B的对象组合而成（有个体组合成整体）。例如个人和人类。人类类中成员就是个人，人类类还有一些自己专属的方法。或者汽车和零部件。</li><li>泛化 A继承B</li><li>实现 A实现B的接口</li></ul><p>依赖和关联不同。关联是对应实例（也就是定义出来的东西），而关联是定义类是两个类总监有关系</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>储存设备</title>
      <link href="/post/7d1c86da.html"/>
      <url>/post/7d1c86da.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed May 13 2020 09:52:30 GMT+0800 (中国标准时间) --><h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p><img src="/images/%E7%A1%AC%E7%9B%98.jpg" alt></p><p>结构： 由若干个盘片组成，每个盘片有2两面，每一面上有若干个磁道，每个磁道上又划分成若干个扇区，扇区是数据访问的最小单位。中间的轴在不停转动。每个扇区都有一个编号。</p><p>显然如果扇区划分时是从中心发出多根射线的话是不好的。因为内圈的扇区划分小，外面的扇区划分大，因此每个扇区读写数据数目可能会有较大的差距。但是很可能只需要利用其中很小一部分，这样就造成了浪费。所以磁道与磁道之间扇区数目是不同的，尽量使数据分布均匀。</p><p>图中左边的架子是读写头，可以前后滑动。数据就是通过读写头进行读写的。</p><p><strong>大致过程</strong>：先移动到对应扇区（寻道），然后等待读写头划过我们要读取的扇区。之后在读取这个扇区。要注意即使只需要读取一个字节也要把这个扇区全部读取完。如果是写的话，先把扇区中数据读取出来，然后再在这些数据中进行更改，最后再把这些数据写入到扇区中。</p><p>一般寻道在2-9ms，旋转也是10ms左右，而读取只需要0.02ms，所以说大头都在寻找过程中。并且要比dram慢2500倍，比sram慢40000倍。</p><p>机械硬盘扇区的读取次数是由限制的，大概是十万到100万次左右。如果某一扇区坏了是不是会导致整个硬盘都异常呢？当然这是不可能的，那样也太不经用了。</p><p>为了解决这个问题，可以用逻辑编号代替物理编号，然后用一定的映射规则转换到物理编号，如果某一个扇区损坏，硬盘中有一些备用的扇区可以替补上，这样就可以解决某一个扇区损坏的问题。可能某些逻辑扇区会被频繁的使用，如果对应规则是确定的那么可能很快那个扇区就会损坏，所以对应规则也要不断变化使每个扇区利用大致平均。</p><h3 id="固态硬盘（ssd）"><a href="#固态硬盘（ssd）" class="headerlink" title="固态硬盘（ssd）"></a>固态硬盘（ssd）</h3><p>结构： 固态硬盘最小的结构是页，每一页有若干个字节。之后若干个页组成了块。它是由闪存构成的（就是usb所使用的）</p><p>读写过程：读的过程是以<strong>页</strong>作为单位，也需要通过一定的映射使之利用均衡。但是写的过程却是以<strong>块</strong>作为单位，就算只改一个字节也需要读取整个块，并且写的过程中需要先把原来的内容全部擦除，所以写过程比读过程慢的多。</p><p>ssd好处是读写较快，但是价格贵，并且读写次数少，只有1万到10万次。</p><h3 id="局部性和高速缓存"><a href="#局部性和高速缓存" class="headerlink" title="局部性和高速缓存"></a>局部性和高速缓存</h3><p>局部性分为时间局部性和空间局部性。</p><p>时间局部性指的是在短时间内多次重复使用某个内存。</p><p>空间局部性指的是一个内存被使用，很可能接下来会使用这段内存附近的数据。</p><p>现代计算机cpu运算速度已经很快了，但是内存的访问速度却跟不上cpu的运算速度。因此现在更重要的是解决内存读取速度的问题。</p><p>根据上面所说的局部性原理（这是人们通过大量观察总结得出的规律），人们想到可以把常用的数据放在一个更快的储存器里，这样就可以提高运算速度。</p><p>于是就有了高速缓存。高速缓存（cahce）是用sram制成的，它的速度很快但是容量很小，直接集成到了cpu内部，每次cpu访问内存的时候都会先从高速缓存中读取。如果高速缓存中没有才会去内存中查找。从内存中取出数据并不是只取那几个字节，而是把附近的指令都放到高速缓存中（因为局部性原理），这样就可以提高速度。</p><h3 id="高速缓存运行原理"><a href="#高速缓存运行原理" class="headerlink" title="高速缓存运行原理"></a>高速缓存运行原理</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png" alt></p><p>一共有S个组，每个组有E行，每行有B个字节。S，E，B都是2的n次方，记S是2的s次方，E是2的e次方，B是2的b次方。</p><p>每一行的B字节都是由三部分组成。最高位叫做有效位，用来判定这一行中是否储存了数据。之后又t字节标记位，用来进行判别，后面的位才是实际从内存中取出来的内容。</p><p>每次cpu访问一个地址时，可以把地址分成3个部分。最低b位是块偏移，中间s位是组索引，高t位是标记。</p><p>进行查询时，先用中间s位找出组索引。例如中间s位是010，那么组索引是2.找到组索引后就用高t位的标记进行比对，如果对应行中最高位为1且标记位正好符合那么就通过最后的b字节找到块偏移。然后取出数据。</p><p>注意，我们只需要找到对应的组就行了，cpu可以自动对该组所有行同时进行比对而不用一一比对。</p><p>例 cpu发出一个指令，要从0111位置取出两字节数据。首先高速缓存中有四组，每组一行。每行四字节。所以这里块偏移是1组索引是11，标记是0.那么我们先通过中间的11确定是第三组，之后再和第三组最高位为1的进行比对，如果有一行标记位正好是0，那么就算出偏移量是1，所以从后面开始的第一位（有第零位）取出两个字节。</p><h4 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h4><p>直接映射高速缓存的特点是每一组只有一行。所以找到组后直接进行比对即可。但是这里有一个问题，例如组索引是1，标记位有两位。那么可能频繁的取出组索引相同但是标记位不同的数据，那么我们就要频繁的从内存中取出数据（miss），这样就降低了速度。</p><h4 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h4><p>组相联高速缓存和直接告诉缓存的不同是组相联高速缓存中每一组有多个行，这样就更可以存放更多的标记位，miss的可能性也就越低。但是这个的问题是因为要同时访问多行，所以硬件设计比较困难。</p><h4 id="全相连高速缓存"><a href="#全相连高速缓存" class="headerlink" title="全相连高速缓存"></a>全相连高速缓存</h4><p>全相连高速缓存中只有一个组，因此没有组索引（想要有组索引最少要有两个组）。</p><p>因此把cpu发送的内存地址分成两个部分，块偏移和标记。因为没有组索引，所以这两部分一般比较大。它可以同时匹配所有的行，也就少了寻找组索引的计算，但是如果行太多设计极为困难，所以只适合做小的高速缓存。</p><h4 id="直写与回写"><a href="#直写与回写" class="headerlink" title="直写与回写"></a>直写与回写</h4><p>直写就是每次都要写到内存或者硬盘中，回写就是每次先在缓存中写，等到这个缓存被替换的时候再写回。毫无疑问回写要快，但是直写也有用武之地。</p><h4 id="块替换策略"><a href="#块替换策略" class="headerlink" title="块替换策略"></a>块替换策略</h4><p>每次未命中时并且缓存中已经全部使用的时候就要进行块替换。块替换有两种策略，第一种是把最近没有使用的块替换出去，第二种是把最不经常使用的块替换出去。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程和作业控制</title>
      <link href="/post/31a6b40.html"/>
      <url>/post/31a6b40.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>进程就是加载到内存中准备执行的程序。当进程创建的时候，内核赋予了唯一的标识号，这个标识号叫做进程ID或PID。</p><p>进程同一时间内可达数百个之多，为了管理这么多的进程。系统提供了一个调度器来维护。调度器维护一个所有进程的列表，每次选择一个进程（实际上可以一次选择多个进程），然后执行一个短暂的时间（时间片）。</p><p>典型的时间片是10毫秒。为了为了下一个时间片还可以顺利的执行，系统必须要保存下一条指令的位置，环境的副本等。</p><h3 id="进程分叉到死亡"><a href="#进程分叉到死亡" class="headerlink" title="进程分叉到死亡"></a>进程分叉到死亡</h3><p>当进程需要使用内核的服务时，会使用<strong>系统调用</strong>发送请求。在编写程序时，系统调用的使用方法取决于语言。例如，c语言使用标准库中的函数进行调用。</p><p>下面列举一些常见的系统调用函数</p><table><thead><tr><th>系统调用</th><th>作用</th></tr></thead><tbody><tr><td><strong>进程控制</strong></td><td></td></tr><tr><td>fork</td><td>创建当前进程的一个副本</td></tr><tr><td>wait</td><td>等待另一个程序结束后执行（强制暂停当前进程）</td></tr><tr><td>exec</td><td>在当前进程中执行一个新进程</td></tr><tr><td>exit</td><td>中止当前进程</td></tr><tr><td>kill</td><td>杀死子进程</td></tr><tr><td><strong>文件I/O</strong></td><td></td></tr><tr><td>open</td><td>打开一个用于读取或写入的文件</td></tr><tr><td>read</td><td>从文件中读取数据</td></tr><tr><td>write</td><td>向文件中写入了数据</td></tr><tr><td>close</td><td>关闭文件</td></tr></tbody></table><p>fork打开的一个新进程叫做当前进程的子女，当前进程是新进程的双亲。</p><p>例如，shell打开内部命令时首先就要调用fork创建一个新进程，当子进程结束时会调用exit释放资源，被杀死的进程叫做僵进程。但是进程表中却仍然保存子进程的数据，因为父进程可能需要这些数据。。</p><p>当子进程创建时，父进程停止运行，等到子进程被杀死之后，父进程先看一眼进程表中子进程的数据，然后开始运行，与此同时，子进程从进程表中被销毁。</p><h3 id="孤儿进程，父进程，子进程"><a href="#孤儿进程，父进程，子进程" class="headerlink" title="孤儿进程，父进程，子进程"></a>孤儿进程，父进程，子进程</h3><p>孤儿进程指的是父进程意外死亡，这时只有子进程。所以当子进程结束时，因为没有人来接受它，会一直留在进程表中，直到系统结束才会死亡。</p><p>当然，现代系统没有这么傻。孤儿进程会自动被init进程收养，通过这种方式，每当产生孤儿进程时，都会迅速的被init进程销毁。</p><p>除了父进程意外死亡外子进程也可能一直不死，这种情况一般是程序出现bug无法正常退出时产生的，这个程序会一直消耗系统资源。kill可以解决这种问题。kill会杀死父进程然后让init进程托管，在适当的时候会杀死子进程（我估计是一定时间，猜测）。</p><p>关于父进程，fork创建一个和父进程一模一样的副本，那么这时如何知道谁是父进程，谁是子进程呢？其实fork创建子进程完成之后会返回给父进程和子进程一个值，子进程返回值是零，父进程返回值大于零。如果某个进程得到了零，那么他就会开始工作，得到大于零的就会停止工作（通过wait使自己暂停）</p><h3 id="init-第一个进程"><a href="#init-第一个进程" class="headerlink" title="init 第一个进程"></a>init 第一个进程</h3><p>假设进程是通过分叉创建的，那么除第一个进程外的进程一定会有父进程，也一定会有第一个进程。</p><p>实际上也是这样，Linux在启动时会创建一个特殊的进程，PID是0，这个进程叫做空闲进程。</p><p>在进行了一些操作之后，0号进程开始分叉创建1号进程。之后0号进程就会死亡，然后由1号进程进行剩余的初始化步骤，例如进行多次分叉创建其他进程。因为 他要执行初始化步骤，所以叫初始化进程，也就是init进程。</p><h3 id="前台和后台进程"><a href="#前台和后台进程" class="headerlink" title="前台和后台进程"></a>前台和后台进程</h3><p>前台进程就是当前需要我们交互的进程，后台进程就是自己跑的进程。</p><p>例如： sort &lt; temp &gt; temp2 &amp;。后面的与符号就是让程序自己去后面跑，这时我们就可以直接使用shell了。</p><p>但是后台进程不能从标准输入中读取，可以输出到标准输出中，这就带来一个问题。如果这个程序需要输入但是你却把它划分成后台程序，那么他会一直等待输入。</p><h3 id="sleep-创建延迟"><a href="#sleep-创建延迟" class="headerlink" title="sleep 创建延迟"></a>sleep 创建延迟</h3><p>语法： sleep interval [s | m | h | d ]</p><p>interval是时间间隔，后面是单位，默认是秒。</p><p>例如 sleep 5 表示中断5秒。</p><h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><p>作业就是每一条输入的指令，该作业有一个唯一的作业号来标识。作业控制就是对输入的指令进行调控。常见的作业控制命令如下表。</p><table><thead><tr><th>作业控制命令</th><th></th></tr></thead><tbody><tr><td>jobs</td><td>显示作业列表</td></tr><tr><td>ps</td><td>显示进程列表</td></tr><tr><td>fg</td><td>将作业移至前台</td></tr><tr><td>bg</td><td>将作业移至后台</td></tr><tr><td>suspend</td><td>挂起当前shell</td></tr><tr><td>^Z</td><td>挂起当前前台作业</td></tr><tr><td>kill</td><td>终止作业</td></tr><tr><td>suspend</td><td>挂起shell，例如超级用户暂时返回普通用户</td></tr></tbody></table><p>echo $$ 显示当前shell的PID</p><p>echo $! 显示上一条移至后台的PID</p><p>stty tostop 挂起试图向终端写数据的后台作业</p><p>set -o monitor 允许作业控制</p><p>set -o notify 当后台作业结束时立刻通报</p><h3 id="在后台运行作业"><a href="#在后台运行作业" class="headerlink" title="在后台运行作业"></a>在后台运行作业</h3><p>为了在后台运行作业，需要在命令的最后加一个&amp;符号。</p><p>每次在后台运行作业时，系统都会自动分配一个作业号，从1开始，依次向后增加。</p><p>每次后台作业完成时，都会向终端发送一个信息表示已经完成。</p><h3 id="fg-将作业移至前台"><a href="#fg-将作业移至前台" class="headerlink" title="fg 将作业移至前台"></a>fg 将作业移至前台</h3><p>挂起可能令人有些误解，其实就是暂停程序。可以用fg将挂起的作业恢复。</p><p>例如当你用vi编辑一个文件时，突然忘了某些东西想通过man查一下，可以先用ctrl+Z把vi挂起，然后查找，查找完了之后又用fg命令将vi唤醒。</p><p>如果有挂起的程序那么关机时系统会给你提示，你可以选择关机或者先把挂起的程序移至前台。</p><p>语法： fg %[job]</p><p>fg %%代表唤起当前进程。因为一般进程挂起后都是运行别的进程，运行完了才又唤醒进程，此时挂起的进程又成了最前面的进程。</p><p>后面的job是作业编号，可以通过jobs程序查看。</p><p>bg和fg大致相同。</p><h3 id="ps程序"><a href="#ps程序" class="headerlink" title="ps程序"></a>ps程序</h3><p>ps程序是用来显示进程状态的</p><p>语法： ps [-aefFly] [-p pid] [-u userid]</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ps</span> <span class="string">显示与当前用户标识和终端相关的进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-a 所有与用户标识进程与终端相关的非守护进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-e 所有进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-p pid 显示指定pid的进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-u userid 显示指定userid的进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-ef 显示所有用户的进程，完整输出</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-t 显示所有守护进程</span></span><br></pre></td></tr></table></figure></div><p>下面列举了ps输出时的标题和所代表的含义</p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>ADDR</td><td>进程表中虚拟地址</td></tr><tr><td>C</td><td>处理器利用率</td></tr><tr><td>CMD</td><td>命令名称</td></tr><tr><td>F</td><td>进程相关的标志</td></tr><tr><td>NI</td><td>nice值，用于设置优先级</td></tr><tr><td>PID</td><td>进程ID</td></tr><tr><td>PPID</td><td>父进程ID</td></tr><tr><td>PRI</td><td>优先级（大数字 = 小优先级 ）</td></tr><tr><td>RSS</td><td>内存预留空间大小</td></tr><tr><td>S</td><td>状态代码（D,R,S,T,Z）</td></tr><tr><td>STIME</td><td>累计系统时间</td></tr><tr><td>SZ</td><td>物理页大小</td></tr><tr><td>TIME</td><td>累计cpu时间</td></tr><tr><td>TTY</td><td>控制终端完整名称</td></tr><tr><td>UID</td><td>用户标识</td></tr><tr><td>WCHAN</td><td>等待通道</td></tr></tbody></table><p>状态代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">D</span> <span class="string">不可中断睡眠，等待事件结束</span></span><br><span class="line"><span class="attr">I</span> <span class="string">空闲，超过20s的睡眠</span></span><br><span class="line"><span class="attr">R</span> <span class="string">正在运行或者可运行（可运行是在运行队列中等待）</span></span><br><span class="line"><span class="attr">S</span> <span class="string">可中断睡眠，等待时间结束</span></span><br><span class="line"><span class="attr">T</span> <span class="string">挂起</span></span><br><span class="line"><span class="attr">Z</span> <span class="string">僵进程</span></span><br></pre></td></tr></table></figure></div><p>-ly 显示状态代码</p><h3 id="监视系统进程"><a href="#监视系统进程" class="headerlink" title="监视系统进程"></a>监视系统进程</h3><p>语法： top [-d delay] [-n count] [p pid[,pid]…]</p><p>top的作用是动态显示进程信息。</p><p>-d 每隔多少秒刷新一次</p><p>-n 只在特定的时间进行刷新</p><p>-p 对某几个进程进行监视</p><h3 id="显示进程树"><a href="#显示进程树" class="headerlink" title="显示进程树"></a>显示进程树</h3><p>语法： pstree [-aAcGnpu] [pid | userid]</p><p>作用：因为进程几乎都是通过分叉产生的，所以这个作用是显示进程之间的关系（即谁是父进程谁是子进程）。</p><p>具体的可以去看联机手册</p><h3 id="kill-杀死进程，向进程发送信号"><a href="#kill-杀死进程，向进程发送信号" class="headerlink" title="kill 杀死进程，向进程发送信号"></a>kill 杀死进程，向进程发送信号</h3><p>语法： kill [-signal] pid… | jobid…</p><p>| signal | 含义 |<br>| 1 | 中止，注销或终端失去连接时发送给进程 |<br>| 2 | 中断，按下^C时发送 |<br>| 9 | 杀死，立刻杀死，进程不能捕获 |<br>| 15 | 终止，请求终止，进程不能捕获 |<br>| 18 | 继续，恢复挂起的进程，由fg或bg发送 |<br>| 19 | 停止（挂起），按^Z发送 |</p><h3 id="设置进程优先级-nice，renice"><a href="#设置进程优先级-nice，renice" class="headerlink" title="设置进程优先级 nice，renice"></a>设置进程优先级 nice，renice</h3><p>优先级决定了你能享有的系统资源。nice程序用于设定优先级。</p><p>语法： nice [-n adjustment] command</p><p>使用nice时要注意，只能对外部程序例如软件和自己写的程序设置优先级，系统内部命令不能设定优先级。其次，一般只对后台程序降低优先级，对前台程序降低优先级是自己找罪受。</p><p>不使用nice时优先级是0，使用nice默认的优先级是10，数字越大优先级越低，最大可以设到20，最小可以设到-20.当设负数的时候是提高优先级。</p><p><strong>renice</strong>重新设置优先级。</p><p>语法： renice niceness -p processid</p><p>niceness是nice值，processid是进程ID。</p><p>niec程序是在程序开始运行时确定的，使用nice程序后command程序便开始运行。而renice是对已运行的程序重新设置优先级。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>很多程序并不是由用户运行的，由系统运行的程序就是守护程序。相当于windows中的服务程序。这些程序不受终端控制</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="/post/95495db.html"/>
      <url>/post/95495db.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="touch-创建文件"><a href="#touch-创建文件" class="headerlink" title="touch 创建文件"></a>touch 创建文件</h3><p>创建文件有许多种方式，例如用vi创建文件，利用重定向创建文件。</p><p>语法： touch [-acm] [-t time] file…</p><p>作用： 创建文件，改变文件的修改时间和访问时间。</p><p>-m 改变修改时间</p><p>-a 改变访问时间</p><p>-t 用一个具体的时间去替换</p><p>如果不加参数会将修改时间和访问时间全部修改。</p><p>例如： touch * ，这个命令会修改目录下的所有文件的访问时间和修改时间。</p><p>如果后面接的文件名不存在，touch将会创建一个文件。</p><p>-c 不创建文件。如果文件存在，会修改时间，如果文件不存在，不进行操作。</p><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>要求：</p><ol><li>文件名最长是255个字符</li><li>文件名可以包含除了/外的任何字符</li></ol><p>虽然说创建文件名的时候没有太多的要求，但是最好创建有意义的名字并且不要实用一些特殊字符。例如-，虽然创建的时候不会出现问题，但是使用命令进行操作的时候却会带来麻烦。</p><h3 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp 复制文件"></a>cp 复制文件</h3><p>语法： cp [-ip] file1 file2</p><p>file1是已有文件 file2是目标文件</p><p>例如： cp /etc/passwd ~/pword</p><p>这个命令会复制passwd文件到pword中，如果pword不存在，那么就会创建。这时需要特别小心，如果目标文件存在，那么复制完之后原来的内容咩有办法找回。</p><p>如果想追加数据，则不能用cp，只能用cat重定向追加内容。</p><p>cp很容易错误的清楚数据，为了保险起见，可以用-i选项。这个选项会在替换已有文件时先询问。可以在初始化文件中直接设定。</p><p>还有一个选项是-p，这个命令使目标文件和原文件有相同的修改时间访问时间和权限。</p><p><strong>-r</strong>，将一个目录复制到另一个目录中。</p><p><strong>将文件复制到不同目录中</strong></p><p>就是将file2变成directory。</p><h3 id="mv-移动文件"><a href="#mv-移动文件" class="headerlink" title="mv 移动文件"></a>mv 移动文件</h3><p><a href="https://xinhecuican.github.io/post/61312.html#more">在前面博客中已经提到</a></p><h3 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm 删除文件"></a>rm 删除文件</h3><p>语法： rm [-fir] file…</p><p>rm删除同样是不可恢复的。为了防止误删文件，可以使用-i选项，每次删除之前请求许可。</p><p>-f 强制删除文件，不考虑权限和-i。</p><p>-r 删除整个目录树，这个选项会将从工作目录开始的所有文件全部删除</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>权限一共有三种，读权限，写权限，执行权限。这些权限和用户标识也有关，如果是普通用户，可能对一些文件没有写权限和执行权限。</p><p>设置权限有两个目的，限制其他用户的访问和避免自己错误的使用。</p><p>下面是权限的作用</p><table><thead><tr><th>文件</th><th></th></tr></thead><tbody><tr><td>读</td><td>读取文件(没有这个权限使用命令也无法查看文件）</td></tr><tr><td>写</td><td>写入文件，没有写权限的话在删除和替换时都会先询问</td></tr><tr><td>执行</td><td>执行文件</td></tr><tr><td>** 目录**</td><td></td></tr><tr><td>读</td><td>读取（查看）目录</td></tr><tr><td>写</td><td>创建、移动、复制或删除目录</td></tr><tr><td>执行</td><td>搜索目录</td></tr></tbody></table><p>例如，有这个文件的写权限和执行权限，那么无法看到它（也就是点文件），但是如果知道它的位置，还是可以对他进行操作。</p><h4 id="id-groups-维护文件权限"><a href="#id-groups-维护文件权限" class="headerlink" title="id groups 维护文件权限"></a>id groups 维护文件权限</h4><p>创建文件的用户标识就是文件的属主。每个用户都属于一个组，第二组是组中其他人，第三组是其他人，可以为这三组设置读写和执行权限。</p><p>系统中组标识的列表在/etc/group中，这个文件可以自由查看</p><p>id就是用来查看当前用户标识和属于那个组的。groups命令是同样的作用。</p><h4 id="ls-l显示文件权限"><a href="#ls-l显示文件权限" class="headerlink" title="ls -l显示文件权限"></a>ls -l显示文件权限</h4><p>使用-l时，从左边开始会有一些字符。例如-rwx等等</p><p>首先第一个字符是-或者d，-代表普通文件，d代表目录。之后会有9个字符分成3组，分别代表个人权限，族权限，其他人权限。</p><p>除了这种表示方法，还可以用三个数字表示三中类型的权限</p><ul><li>r: 读权限 数字 4</li><li>w: 写权限 数字 2</li><li>x: 执行权限 数字 1</li><li>-: 没有权限 数字 0</li></ul><p>例如只有读写权限，那么就可以用6来代表。</p><h4 id="改变文件权限"><a href="#改变文件权限" class="headerlink" title="改变文件权限"></a>改变文件权限</h4><p>可以使用chmod（change file mode）来改变文件权限</p><p>语法： chmod mode file…</p><p>这里的mode是使用数字表示的，并且一次要写三种类型。</p><p>例如： chmod 644 file1</p><h3 id="shred-清空文件内容"><a href="#shred-清空文件内容" class="headerlink" title="shred 清空文件内容"></a>shred 清空文件内容</h3><p>前面讲的rm命令只是删除了文件，但是文件所在的空间还是可以重新被使用的。甚至这个时候如果用昂贵的设备，那么其中的内容还是可以恢复的。如果使用了shred，那么就会毁坏硬盘（后备隐藏能源？），这时数据就永远无法恢复了。这里就不展开了。</p><h3 id="stat-ls-i-链接的概念"><a href="#stat-ls-i-链接的概念" class="headerlink" title="stat ls -i 链接的概念"></a>stat ls -i 链接的概念</h3><p>当linux创建文件时，进行两个操作。在储存设备上保留一块空间来保存数据，之后创建一个索引节点（i节点）来存放数据的基本信息。i节点包含使用文件所需的全部信息</p><p>stat命令就是查看i节点的内容</p><p>所有的i节点存放于一个大表中，称为i节点表。在节点表中，每个i节点由索引号和i节点号表示。为了查看节点号，可以使用ls -i选项。如果想查看所有节点，可以使用ls -il。</p><p>处理目录时，其实我们处理的是i节点号和节点名称。所以目录实际上很小。只有一个名称，每一个名称对应一个i节点号。</p><p>例如，我们现在bin目录中创建swap文件。那么先保留一块空间，如果查看i节点表，查找一个空闲的i节点。然后linux将信息填充到属于这个文件的i节点中。之后在bin目录中放入一个条目，该条目有名称和i节点号。</p><p>文件名和i节点之间的连接叫链接。</p><h3 id="多重链接，一个文件，多个名字"><a href="#多重链接，一个文件，多个名字" class="headerlink" title="多重链接，一个文件，多个名字"></a>多重链接，一个文件，多个名字</h3><p>多重链接就是一个文件可以有不同的名称。因为文件标识实际上是i节点号，我们从目录中查询的时候也是查询i节点号然后根据节点号中的信息去访问。因此我们可以在不同目录中创建指向同一个节点号的文件，这其实就是快捷方式。</p><h4 id="ln-创建新链接"><a href="#ln-创建新链接" class="headerlink" title="ln 创建新链接"></a>ln 创建新链接</h4><p>语法： ln file newname</p><p>作用：每当创建文件时，系统都会自动在文件和文件名间创建一个链接。如果我们想为已有文件创建一个新链接，就可以用ln（link）。</p><p>我们也可以将newname改成directory，那么就是创建快捷方式</p><p><strong>移除链接</strong></p><p>直接用rm命令即可，除非所有链接都被删除，不然文件不会被删除。</p><h3 id="符号链接-ln-s"><a href="#符号链接-ln-s" class="headerlink" title="符号链接 ln -s"></a>符号链接 ln -s</h3><p>前面讲的链接有两点限制。一，不能为目录创建链接。二，不能为不同文件系统创建链接。（因为目录没有i节点）</p><p>如果想克服上述情况，就需要创建符号链接。符号链接包含的不是文件的i节点号，而是原文件的路径名。</p><p>但是用ls -l时，左边会有一个l代表链接。实际符号链接在右边。用一个-&gt;符号后面加上指向的真实文件名表示。因为符号链接只存一个路径，所以大小也只有4字节。注意这是符号链接才会有-&gt;符号，一般的链接不会显示。</p><p>一般的链接叫做硬链接，就是起了一个别名。符号链接叫做软链接，实际上并不是存放那个文件，只是存放一个指向文件的地址。</p><p>硬链接数量ls -l可以显示，但是软链接无法显示，因为系统也不知道有多少软链接。并且当文件被删除时，软链接也不会被删除，只是打开时发生错误</p><h4 id="目录使用符号链接"><a href="#目录使用符号链接" class="headerlink" title="目录使用符号链接"></a>目录使用符号链接</h4><p>当我们对目录使用符号链接之后，cd时到底应该显示真实的目录还是符号链接目录呢？实际上两种都可以。</p><p>如果使用cd -L选项，将把符号链接视为真实目录，使用-P选项将用真实目录替换符号链接，也就是直接进入真实目录。默认情况是-L。</p><p>我们使用-L情况是和-P一样的，使用-L时目录显示与原文件相同，就是实际对源文件进行操作的时候想要进行跳转。</p><h3 id="locate-通过数据库查看文件"><a href="#locate-通过数据库查看文件" class="headerlink" title="locate 通过数据库查看文件"></a>locate 通过数据库查看文件</h3><p>语法： locate [-bcirS] pattern…</p><p>作用： 在一个特殊的数据库（包含所有的可公共访问的文件，且定期更新）查找文件。</p><p>如果想使用正则表达式，可以使用-r选项 ，可以用^和$表示开头和结尾。</p><p>例如 locate -r ‘.jpg$’ 是找jpg图片</p><p>locate -ir ‘^/usr*x11$’ 是找以/usr开头，x11结尾的。</p><ul><li>-c 统计数目，而不显示位置</li><li>-i 忽略大小写</li></ul><h3 id="find-搜索目录树查找文件"><a href="#find-搜索目录树查找文件" class="headerlink" title="find 搜索目录树查找文件"></a>find 搜索目录树查找文件</h3><p>语法： find path… test… action…</p><p>输入命令后，find执行三步</p><ol><li>路径，先查看每个路径，检查这个路径代表的整个目录树</li><li>测试，对于遇到的每个文件，find用指定的测试条件进行测试，成功就进行下一步</li><li>动作，一旦搜索完成，对成功通过上面两个步骤的文件做的操作</li></ol><p>例如： find /home/harley -name important -print</p><p>路径： /home/harley。表示从harley目录开始进行搜索，也就是home目录不搜索。路径可以有多个</p><p>动作： -name important。这个的含义是查找名字是important的文件</p><p>动作： -print。输出路径名</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>下列是一些模式</p><table><thead><tr><th>文件名</th><th></th></tr></thead><tbody><tr><td>-name pattern</td><td>包含pattern的文件名</td></tr><tr><td>-iname pattern</td><td>不区分大小写</td></tr><tr><td><strong>文件特征</strong></td><td></td></tr><tr><td>-type [df]</td><td>文件类型 d：目录 f：普通文件</td></tr><tr><td>-perm mode</td><td>文件权限</td></tr><tr><td>-user userid</td><td>文件属主</td></tr><tr><td>-group groupid</td><td>组为groupid</td></tr><tr><td>-size [-+]n[cbkMG]</td><td>大小为n[字节，块，kb，mb，gb]</td></tr><tr><td>-empty</td><td>空文件</td></tr><tr><td><strong>访问时间，修改时间</strong></td><td></td></tr><tr><td>-amin [-+]n</td><td>n分钟之前访问，-是小于这个时间</td></tr><tr><td>-atime [-+]n</td><td>n天之前访问</td></tr><tr><td>-anewer file</td><td>file之后访问</td></tr><tr><td>-cmin [-+]n</td><td>n分钟之前状态改变</td></tr><tr><td>-cnewer file</td><td>file状态改变之后改变</td></tr><tr><td>-time [-+]n</td><td>…</td></tr><tr><td>-mmin [-+]n</td><td>n分钟之前修改</td></tr><tr><td>-mtime [-+]n</td><td>n天之前修改</td></tr><tr><td>-newer file</td><td>file文件之后修改</td></tr></tbody></table><p>最重要的是type和name。中括号中的加减号代表的是大于和小于。</p><p>type控制查找那些类型。除了上面的之外，还有b(块设备），c（字符设备），p（命名管道），l（符号链接）</p><p>例如： <code>find . -type f -name important -print</code></p><p>其中name后面的pattern可以用通配符。</p><p>cmin代表的是访问或修改。</p><p>例如： find ~ -cmin -10 -print</p><p>这个的含义是查找10分钟内被访问或修改的文件。</p><h4 id="使用！对测试求反"><a href="#使用！对测试求反" class="headerlink" title="使用！对测试求反"></a>使用！对测试求反</h4><p>使用!时要注意两个问题：</p><ol><li>！号两边要有空格</li><li>必须要引用！，可以<code>\!</code>,也可以’!’</li></ol><p>并且一个感叹号只对一个测试有效。</p><h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><table><thead><tr><th>动作</th><th></th></tr></thead><tbody><tr><td>-print</td><td>将路径名写入标准输出</td></tr><tr><td>-fprint file</td><td>将输出写入file中</td></tr><tr><td>-ls</td><td>显示长目录列表，和ls -l输出样式差不多</td></tr><tr><td>-fls file</td><td>输出写入file中</td></tr><tr><td>-delete</td><td>输出文件</td></tr><tr><td>-exec command {} ;</td><td>执行command，{}指示匹配的文件名</td></tr><tr><td>-ok command {} ;</td><td>同exec，在执行command前先确认</td></tr></tbody></table><p>exec后面的command是linux的程序例如ls，echo等。这条命令以;（封号）结尾，前面的\是转义字符。而{}有些系统必须要加转义字符。</p><p>例如： <code>find . -name &#39;*.backup&#39; -exec ls -dils {} \;</code></p><h4 id="xargs-处理查找到的文件"><a href="#xargs-处理查找到的文件" class="headerlink" title="xargs 处理查找到的文件"></a>xargs 处理查找到的文件</h4><p>对于查找到的文件可以用exec处理，但是这里专门有一个程序去处理。</p><p>语法： xargs [-prt] [-i string] [command | argument…]</p><p>command是希望运行的程序，string是占位符，argument是从标准输入中读取的参数。</p><p>例如： find ~ -type f | xargs ls -s</p><p>如果想多次运行同一命令，那么需要使用-i选项，并且后面要使用 { }作为占位符，占位符在命令开始之前会被参数替代。</p><p>例如： find . -type f | xargs -i echo { } { }</p><p>这条命令将会连续输出两次。如果想自己指定占位符，可以直接在-i后面添加字符串。</p><p>例如： find . -type f | xargs -iXX mv XX ~/backups/XX.old</p><p>这条命令即移动又进行了重命名（变成XX.old)</p><p>-p 运行命令之前先提示</p><p>-t 运行命令不会请求许可但是会显示在标准输出中。</p><p>-r 如果没有参数，则不执行。</p><p>例如： <code>find . -empty | xarg -r ls -l</code></p><p>原本如果是没有空文件的话ls将会输出整个目录，这当然不对，所以没有空文件的时候就可以让他忽略。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>流水线</title>
      <link href="/post/b4c1d206.html"/>
      <url>/post/b4c1d206.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>cpu运算可以简化成两大块，运算单元和寄存器。大致过程是先从寄存器中取值然后放入运算单元中运算完成之后又放入寄存器中。大致过程可分为六个部分</p><ol><li>fetch(取指），读入指令</li><li>decode(译码),解码然后把寄存器中的值放到运算单元中</li><li>execute(执行), 进行计算</li><li>memory(访存),把结果放到内存中</li><li>write back（写回），把结果放到寄存器中</li><li>PC（更新PC）</li></ol><p>这六个部分和把数据放到寄存器所用的总时间就是执行一条指令所需要的时间。cpu中有一个时钟，时钟以特定的周期进行高电压和低电压的变换。每一个周期内cpu执行一条指令，这个周期就是时钟周期。</p><p>但是这样速度不够快，因为cpu同一时间内只有一部分在工作，其他的都处于待机状态，所以可以用一种办法把其他部分利用起来。</p><p>之前我们之所以不能连续送入多条指令的原因是如果牵一条指令还未执行完成后一条指令便开始执行很可能导致电路出现问题（先这样理解吧）。如果我们在中间插入寄存器的话便不存在这个问题了。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GHERKIN"><figure class="iseeu highlight /gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> 算术单元 </span>|<span class="string"> 寄存器 </span>|</span><br><span class="line">|<span class="string"> 300ps   </span>|<span class="string">  20ps  </span>|</span><br><span class="line">|<span class="string"> 算术单元1 </span>|<span class="string"> 寄存器1 </span>|<span class="string"> 算术单元2 </span>|<span class="string"> 寄存器2 </span>|<span class="string"> 算术单元3 </span>|<span class="string"> 寄存器</span></span><br><span class="line">|<span class="string"> 100ps    </span>|<span class="string"> 20ps   </span>|<span class="string"> 100ps    </span>|<span class="string"> 20ps   </span>|<span class="string"> 100ps    </span>|<span class="string"> 20ps</span></span><br></pre></td></tr></table></figure></div><p>乍一看加了寄存器之后时钟周期反而变长了，便成360ps。但实际上现在可以每120ps送入一条指令，先前的运算结果可以先储存在寄存器中，新一个时钟周期时把寄存器中的值送入下一个运算单元，这样就节省了时间</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VIM"><figure class="iseeu highlight /vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果把时间分成<span class="number">3</span>部分来运算</span><br><span class="line">abcabcabc  不用流水线</span><br><span class="line"><span class="keyword">abc</span></span><br><span class="line"> <span class="keyword">abc</span>      用流水线</span><br><span class="line">  <span class="keyword">abc</span></span><br></pre></td></tr></table></figure></div><p>可以看出使用流水线后时间明显缩短</p><p>但是流水线也有一些问题。</p><ol><li>不能无限划分，随着划分的增多价格问题也越来越严重，性能提升却不大。甚至无限划分的时候，时间反而会变成无穷大（因为寄存器上时间过多，永远也执行不了指令）。</li><li>不一致的划分，因为流水线的时钟频率是根据耗时最长的那一阶段来确定的，所以如果划分不一致，就会导致最长的那段时间增大。正因如此，cpu一般把取指和PC这两个阶段当做一个阶段在最开始执行。</li><li>数据相关。 程序中上一条指令和下一条指令很可能有关联[例]<br>[例]: movq rax rbx movq rbx rcx</li><li>控制相关。 主要是条件跳转指令，因为一次输入了多条指令，所以很可能前面的判断没有完成的时候条件判断语句后面的指令已经开始计算了，这时候如果条件跳转指令跳转到了另一个地方，那前面开始计算的部分全部要清空，然后重新载入流水线。这样就会极大的影响效率。</li></ol><p>解决办法：</p><p>对于数据相关可以中间插入一个空命令例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a阶段只有命令的传入，并没有涉及到数据的传入,假设第一条和第二条有冲突</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br><span class="line">  空</span><br><span class="line">    <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br><span class="line">      <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br></pre></td></tr></table></figure></div><p>但是这样还是会导致效率的降低。</p><p>一个更好的办法是在cpu内部对命令进行重排，但是又不影响运行逻辑。</p><p>对于控制相关可以使用数据传输指令，但是数据传输指令也具有局限性。</p><p>还可以通过分支预测的方法。如果是第一次进入分支，直接顺序传入指令，如果不是第一次，可以传入上一次分支运行时的指令。这样对循环具有优化作用。</p><p>此外在编译器层面，可以提前预测那种可能性比较大。然后把可能性大的部分放在分支语句的后面。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux目录操作</title>
      <link href="/post/61312.html"/>
      <url>/post/61312.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="目录名和工作目录"><a href="#目录名和工作目录" class="headerlink" title="目录名和工作目录"></a>目录名和工作目录</h3><p>斜杠表示根目录，如果最后一个名称代表的是文件名。当然，这个文件名也可以是一个目录。</p><p>工作目录又叫当前目录，也是进行操作的根目录（但不是系统的根目录），如果命令后面直接输入一个文件名，那么就是代表这个目录在工作目录中，系统也只会在当前目录中搜寻。</p><h3 id="绝对目录和相对目录"><a href="#绝对目录和相对目录" class="headerlink" title="绝对目录和相对目录"></a>绝对目录和相对目录</h3><p>绝对目录就是从根目录开始。在Linux系统中，根目录是home（这个根目录是当前用户的根目录）目录。</p><p>相对目录就是从工作目录（当前目录）开始。大多数时候我们输入一个文件名其实都是输入相对目录，我们也可以输入绝对目录，但那样过于麻烦。</p><h3 id="路径名缩写"><a href="#路径名缩写" class="headerlink" title="路径名缩写"></a>路径名缩写</h3><p><strong>第一个</strong>： ..（两个点号）。这个符号的含义是父目录，也就是上级目录。用..可以回到上级目录然后在进入子目录</p><p>例：现在绝对目录是 /home/abcd/ceshi，如果我想进入abcd的gongzuoqu目录，那么输入cd ../gongzuoqu即可。这是从左向右读的， ..代表进入父目录，然后再进入父目录中的工作区目录。</p><p><strong>第二个</strong>： .(一个点号）。代表的是当前目录，注意<strong>任何不以/开头的路径名都被认为相对于工作目录</strong>。所以大部分情况下直接输入文件名即可，但是在某些情况下必须输入完整的目录，因此这个时候就需要.代表当前目录便于输入。</p><p>unix只能运行它能找到的程序，也就是在path环境变量中的路径。但是如果我们输入绝对路径的话，程序也能运行，因此这里我们就可以简单的用 . 来代替长长的绝对路径名。</p><p>如果我们想运行new程序，而这个程序不在搜索路径中，那么可以用 ./new来运行它</p><p>一个点号和两个点号都是缩写，所以其实我们运用点号时都是输入<strong>绝对路径名</strong></p><p><strong>第三个</strong> ~(波浪号）。 用这个符号代表home目录（这里的home是系统的根，也就是没有目录包含它）。</p><h3 id="cd-pwd-在目录树中移动"><a href="#cd-pwd-在目录树中移动" class="headerlink" title="cd pwd 在目录树中移动"></a>cd pwd 在目录树中移动</h3><p>pwd命令是显示当前的绝对目录</p><p>cd 命令</p><p>语法： cd [-LP] [directory | - ]</p><p>其中dircetory是你想切换到的目录的名称。</p><p>如果只输入cd，那么会进入home目录下。如果输入cd -， 那么将会进入前一个目录，与cd ..命令效果相同。</p><p>如果使用绝对路径名，那么第一个符号是/。</p><p>例如 cd /home/abcd/gongzuoqu</p><p>如果使用相对路径名，那么第一个就没有/</p><p>例如 cd gongzuoqu/temp</p><h3 id="mkdir-rmdir新建目录和移除目录"><a href="#mkdir-rmdir新建目录和移除目录" class="headerlink" title="mkdir rmdir新建目录和移除目录"></a>mkdir rmdir新建目录和移除目录</h3><p>语法： mkdir [-P] dictory…</p><p>首先，可以使用字母，数字和没有特殊含义的标点符号作为文件名。</p><p>创建目录要遵循两条规则。第一条，不能在一个目录下创建两个同名的目录。第二条，默认情况下，如果父目录不存在，那么就无法创建目录。可以使用-p选项忽略第二条规则。</p><p>语法： redir [-p] directory …</p><p>这里要注意只能移除空的目录。如果想要移除非空的目录，可以使用rm程序</p><p>如果想一次性移除一串目录，那么可以使用-p选项。但是有一个不是空的就不行（除了在这条链上的目录外）</p><p>其次，不能移除根目录和工作目录之间的任何程序。也就是说就算是使用了绝对地址，如果它在工作目录外部，那么也无法移除它。</p><h3 id="mv-移动或重命名目录"><a href="#mv-移动或重命名目录" class="headerlink" title="mv 移动或重命名目录"></a>mv 移动或重命名目录</h3><p>语法： mv directory target</p><p>target如果是一个路径，那么一定是移动目录，如果是名字，那么要看情况。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HASKELL"><figure class="iseeu highlight /haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home/harley/<span class="class"><span class="keyword">data</span></span></span><br><span class="line">/home/harley/storge</span><br><span class="line"></span><br><span class="line"><span class="title">mv</span> <span class="class"><span class="keyword">data</span> storage</span></span><br><span class="line"></span><br><span class="line">现在的位置： /home/harley/storge/<span class="class"><span class="keyword">data</span></span></span><br></pre></td></tr></table></figure></div><p>也就是说，如果该路径下没有这个名字的目录，那么就会重命名，但是如果有这个名字的目录，那么就会移动到这个目录下。</p><h3 id="pushd-popd-dirs-使用目录栈"><a href="#pushd-popd-dirs-使用目录栈" class="headerlink" title="pushd,popd,dirs 使用目录栈"></a>pushd,popd,dirs 使用目录栈</h3><p>语法： pushd [directory | +n]</p><p>pop [+n]</p><p>dirs [-c] [-l] [-v]</p><p>push是将目录的名称压入栈中，pop是弹出栈中，dirs是显示栈的内容，n是标识符</p><table><thead><tr><th>命令</th><th>动作</th></tr></thead><tbody><tr><td>dirs</td><td>显示名称，home显示为~</td></tr><tr><td>dirs -l</td><td>home显示为完整路径</td></tr><tr><td>dirs -v</td><td>每行一个显示名称，并有标识符</td></tr><tr><td>pushd directory</td><td>将其压入栈中</td></tr><tr><td>push +n</td><td>把n移到栈顶</td></tr><tr><td>popd +n</td><td>把n移除</td></tr><tr><td>dirs -c</td><td>除当前目录外，移除所有目录</td></tr></tbody></table><p>在任何时候，栈顶都是存放当前工作目录的名称。每当改变工作目录时，栈顶元素也会随之改变。</p><p>如果我们使用了pushd命令，这时我们也会进入这个目录，同时只能进入自己的下级目录。</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>语法： ls [aCdFglrRs1] [name…]</p><p>作用，列举该目录下的文件名称。</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-C 横的列举文件</span></span><br><span class="line"><span class="deletion">-1 竖的列举文件 可以与wc -l组成管道</span></span><br><span class="line"><span class="deletion">-r 按字母表相反顺序进行排序。</span></span><br><span class="line"><span class="deletion">-R 递归。也就是列举完这一层继续列举下一层。如果这个很长的话，可以用less程序</span></span><br><span class="line"><span class="deletion">-F 检查文件类型，会增加几种标识，如下表所示</span></span><br><span class="line"><span class="deletion">--color 使用不同颜色来显示不同类型文件</span></span><br><span class="line"><span class="deletion">-l 显示长列表</span></span><br><span class="line"><span class="deletion">-u 显示访问时间</span></span><br><span class="line"><span class="deletion">-r reverse 从旧的到新的</span></span><br><span class="line"><span class="deletion">-h 自动显示大小</span></span><br><span class="line"><span class="deletion">-d 显示目录本身的信息。</span></span><br><span class="line"><span class="deletion">-a 显示隐藏文件</span></span><br></pre></td></tr></table></figure></div><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>空</td><td>非可执行文件</td></tr><tr><td>*</td><td>可执行文件</td></tr><tr><td>/</td><td>目录</td></tr><tr><td>@</td><td>符号链接</td></tr><tr><td>竖线</td><td>命名管道 /FIFO</td></tr></tbody></table><h4 id="hs-du-df-quota-掌握磁盘空间使用情况"><a href="#hs-du-df-quota-掌握磁盘空间使用情况" class="headerlink" title="-hs du -df -quota 掌握磁盘空间使用情况"></a>-hs du -df -quota 掌握磁盘空间使用情况</h4><p>-s 前面以字节为单位输出文件的大小</p><p>-sh 自动选择合适的单位</p><p>du（disk usage) 显示文件的大小，这是一个程序</p><p>语法： du [-achs] [name…]</p><p>-h 显示单位</p><p>如果不指定名称，du会递归搜索整个目录树</p><p>-s 显示总和</p><p>-c 是先输出每个文件的大小，最后输出总量</p><p>df 显示磁盘可用空间</p><p>quota 显示配额</p><h3 id="file-检查文件类型"><a href="#file-检查文件类型" class="headerlink" title="file 检查文件类型"></a>file 检查文件类型</h3><p>file的使用相当直接，只需要file + 路径就可以检查那个路径下的文件类型，但是比ls显示的更为详细。</p><p>可能显示下列几种类型：</p><ul><li>ELF:可执行和链接模式</li><li>32-bit： 字长</li><li>LSB： 采用最低有效字节编译（小端序）</li><li>executable： 可执行文件</li><li>Intel 80386： 内部文件格式版本</li><li>GNU/linux2.6.9 操作系统和内核版本</li><li>dynamically linked 使用共享库</li><li>stripped 将符号表移除的可执行文件</li></ul><h3 id="块和分配单元"><a href="#块和分配单元" class="headerlink" title="块和分配单元"></a>块和分配单元</h3><p>在文件系统中，空间以固定大小进行分配，我们把固定大小的组块叫做块。块的大小在不同系统中不同。块的大小有512,1,2,4kb等。典型的linux系统是1kb。</p><p>此时我们只是说在文件系统中的分配方式。但是写入到磁盘中时出于效率的考虑，磁盘中也有特定的单元叫做分配单元或者簇。例如，分配单元为8kb代表即使只有1btye的数据系统也会自动分配8kb</p><h3 id="使用通配符进行通配"><a href="#使用通配符进行通配" class="headerlink" title="使用通配符进行通配"></a>使用通配符进行通配</h3><p>使用通配符可以指定特定的文件名，类似于正则表达式。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>匹配任何0个或多个字符组成的序列</td></tr><tr><td>？</td><td>匹配任何单个字符</td></tr><tr><td>[list]</td><td>匹配list中任意字符</td></tr><tr><td>[^list]</td><td>匹配不再list中任意字符</td></tr><tr><td>{string1竖线string2}</td><td>匹配任意一个字符串</td></tr></tbody></table><p>其实就是一个简化版的正则表达式。例如： ls h*表示显示所有以h为开头的文件或目录</p><p>此外，还可以使用一些预定义字符类，例如[[:lower:]]等</p><h3 id="显示目录树"><a href="#显示目录树" class="headerlink" title="显示目录树"></a>显示目录树</h3><p>语法： tree [-adfFilrst] [-L level] [directory…]</p><p>level是树的深度</p><p>作用：绘制文件系统中任意部分的图形（真的就是一个目录图表，可以自己试一下）。</p><p>选项：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-a 显示所有文件，包括点文件</span></span><br><span class="line"><span class="deletion">-s 显示文件大小</span></span><br><span class="line"><span class="deletion">-F 显示标识文件的标志</span></span><br><span class="line"><span class="deletion">-r 以相反顺序输出</span></span><br><span class="line"><span class="deletion">-t 按修改时间顺序输出</span></span><br><span class="line"><span class="deletion">-d 只显示目录</span></span><br><span class="line"><span class="deletion">-i 省略缩进，这种模式只会输出一条条路径，但是不会生成一个图标</span></span><br><span class="line"><span class="deletion">-L 限制树的深度。后面的数字就是树的深度</span></span><br></pre></td></tr></table></figure></div><p>个人意见可以重定向到一个文件中然后再文件中查找。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gdb</title>
      <link href="/post/63002.html"/>
      <url>/post/63002.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="进入gdb"><a href="#进入gdb" class="headerlink" title="进入gdb"></a>进入gdb</h3><p>首先gdb一般都是用来调试c或c++的，gdb是要运行可执行文件的，所以先要进行编译。具体命令如下：</p><p><code>gcc -g 源文件.c -o 输出的目标文件</code></p><p>-g是用来插入编译所需的信息, -o是用来生成可执行文件</p><p>生成的时候会产生一大堆信息，如果不想看的话可以使用 -q 选项，如果想永久设定可以在bashrc中设置别名 alias gdb = ‘gdb -q’</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>start</td><td>进入main函数</td><td>无</td></tr><tr><td>run</td><td>重新开始运行 run-text 加载文本文件 run-bin加载二进制文件</td><td>r</td></tr><tr><td>next</td><td>执行一行程序，不进入函数，直接把函数执行完</td><td>n</td></tr><tr><td>step</td><td>执行一行程序，进入函数</td><td>s</td></tr><tr><td>list</td><td>查看程序，list+函数名查看函数</td><td>l</td></tr><tr><td>continue</td><td>继续执行到断点处</td><td>c</td></tr><tr><td>quit</td><td>终止程序</td><td>q</td></tr><tr><td>set 参数</td><td>设置断点</td><td>无</td></tr><tr><td>nexti</td><td>运行一条机器指令</td><td>ni</td></tr><tr><td>jump + 标号</td><td>跳转到某一位置执行</td><td>j</td></tr><tr><td>run &lt; input.txt</td><td>重定向</td><td>无</td></tr></tbody></table><p>注意jump命令跳转后仍是一直执行，所以要在某一位置手动设置断点</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>return</td><td>退出函数且不执行后面代码，也可以return+参数指定返回值</td><td>无</td></tr><tr><td>finish</td><td>退出函数且执行完剩下的代码</td><td>无</td></tr><tr><td>call/print</td><td>直接调用函数执行</td><td>无</td></tr><tr><td>info files</td><td>显示所有程序及位置</td><td>无</td></tr><tr><td>info functions（regex）</td><td>显示函数（可加正则表达式）</td><td>无</td></tr><tr><td>set step-mode on</td><td>进入不带调试信息的函数（如printf）</td><td>无</td></tr><tr><td>set args val1 val2…</td><td>设置函数参数</td><td>无</td></tr></tbody></table><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>break</td><td>设置断点</td><td>b</td></tr><tr><td>tbreak</td><td>设置临时断点（只能使用一次）</td><td>tb</td></tr><tr><td>info breakpoints</td><td>查看当前所有断点</td><td>i b</td></tr><tr><td>enable/disable breakpoints</td><td>启用/禁用断点</td><td>无</td></tr><tr><td>clear+编号</td><td>删除断点</td><td>无</td></tr><tr><td>** break参数 **</td><td></td><td><strong>例</strong></td></tr><tr><td>*+地址</td><td>在某一地址设置断点</td><td>b *0x400522</td></tr><tr><td>函数名</td><td>在某一函数进入前停止</td><td>b main</td></tr><tr><td>行号</td><td>在某一行号处设置断点</td><td>b 7</td></tr><tr><td>+offset/-offset</td><td>在当前行前后offset行设置</td><td>无</td></tr><tr><td>break … if &lt; condition&gt;</td><td>只有在条件满足时，断点才会被触发</td><td>b 10 if i==101</td></tr><tr><td>ignore bnum count</td><td>忽略bnum次编号为count的断点</td><td>ignore 1 5</td></tr><tr><td><strong>观察点</strong></td><td>观察变量值的变化</td><td></td></tr><tr><td>watch</td><td>当一个值发生变化时，程序会停下来，相当于是写观察点</td><td>无</td></tr><tr><td>reatch</td><td>当一个值发生读行为时，程序停止</td><td>无</td></tr><tr><td>awatch</td><td>每次读取或改变a的值都会让程序停下来</td><td>aw</td></tr><tr><td>info watch</td><td>显示观察点</td><td>i watch</td></tr><tr><td><strong>catchpoint</strong></td><td>当程序异常终止或加载链接库时停止运行，这里不展开</td><td></td></tr></tbody></table><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">）设置catchpoints:</span></span><br><span class="line"><span class="attr">a. catch event:</span> <span class="string">当事件event发生的时候，程序停止运行，这里event的取值有：</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">）throw:</span> <span class="string">C++抛出异常</span></span><br><span class="line"><span class="number">2</span><span class="string">）catch:</span> <span class="string">C++捕捉到异常</span></span><br><span class="line"><span class="number">3</span><span class="string">）exec:</span> <span class="string">exec被调用</span></span><br><span class="line"><span class="number">4</span><span class="string">）fork:</span> <span class="string">fork被调用</span></span><br><span class="line"><span class="number">5</span><span class="string">）vfork:</span> <span class="string">vfork被调用</span></span><br><span class="line"><span class="number">6</span><span class="string">）load:</span> <span class="string">加载动态库</span></span><br><span class="line"><span class="number">7</span><span class="string">）load</span> <span class="attr">libname:</span> <span class="string">加载名为libname的动态库</span></span><br><span class="line"><span class="number">8</span><span class="string">）unload:</span> <span class="string">卸载动态库</span></span><br><span class="line"><span class="number">9</span><span class="string">）unload</span> <span class="attr">libname:</span> <span class="string">卸载名为libname的动态库</span></span><br><span class="line"><span class="number">10</span><span class="string">）syscall</span> <span class="string">[args]:</span> <span class="string">调用系统调用，args可以指定系统调用号，或者系统名称</span></span><br><span class="line"><span class="attr">b. tcatch event:</span> <span class="string">设置只停一次的catchpoint，第一次生效后，该catchpoint被自动删除</span></span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/kevinx_xu/article/details/36261571" target="_blank" rel="external nofollow noopener noreferrer">这一段从网上扒的</a></p><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>disassemble 如果不带参数，会自动显示后面若干条汇编指令。简写disas</p><p>如果带一个参数，可以带函数名也可以带某一个地址，都是显示那个地址处的函数的汇编代码。</p><p>如果带两个参数，也就是起始地址和终止地址，那么就会显示两个之间的代码</p><h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>reverse-continue</td><td>反向运行程序知道遇到一个能使程序中断的事件（比如断点，观察点，异常）</td><td>无</td></tr><tr><td>reverse-step</td><td>返回到上一次执行的源代码行</td><td>无</td></tr><tr><td>reverse-stepi</td><td>返回上一条机器指令</td><td>无</td></tr><tr><td>reverse-next</td><td>返回上一次执行的源代码行，但不执行函数</td><td>无</td></tr><tr><td>reverse-nexti</td><td>反向运行到上一条机器指令，除非这条指令用来返回一个函数调用、整个函数将会被反向执行。</td><td>无</td></tr><tr><td>reverse-finish</td><td>反向运行程序回到调用当前函数的地方</td><td>无</td></tr></tbody></table><p>注意，想使用回退功能先要用record命令对指令进行录制</p><h3 id="调试带参数的程序"><a href="#调试带参数的程序" class="headerlink" title="调试带参数的程序"></a>调试带参数的程序</h3><p>方法1： gdb启动时候加参数</p><p>gdb –args ./main aaaa bb</p><p>方法2：</p><p>gdb main //先启动起来</p><p>(gdb)run aaaa bb</p><p>方法3</p><p>gdb main //先启动起来</p><p>(gdb)set args aaaa bb</p><p>(gdb)run //或者start</p><p>(gdb)show args</p><p><a href="https://blog.csdn.net/mw_nice/java/article/details/100991341" target="_blank" rel="external nofollow noopener noreferrer">这部分照搬的</a></p><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>** 函数栈帧打印**</td><td></td><td></td></tr><tr><td>i frame</td><td>输出了当前函数堆栈帧的地址，指令寄存器的值，局部变量地址及值等信息</td><td>无</td></tr><tr><td>frame n</td><td>打印第n层的函数栈帧</td><td>无</td></tr><tr><td>up/down n</td><td>向上/向下切换栈帧</td><td>无</td></tr><tr><td>print + 数组名</td><td>打印数组内容</td><td>p</td></tr><tr><td>set print array-indexes on</td><td>打印数组时打印下标</td><td>无</td></tr><tr><td>info locals</td><td>打印局部变量值</td><td>i locals</td></tr><tr><td>backtrace full n</td><td>由内向外显示n个栈帧的值</td><td>bt</td></tr><tr><td>set print pretty on</td><td>打印结构体</td><td>无</td></tr><tr><td>p *array@len</td><td>array数组名 len 数据长度</td><td>无</td></tr><tr><td>p $寄存器名</td><td>查看某个寄存器的值</td><td>无</td></tr><tr><td>info register</td><td>查看所有寄存器</td><td>i reg</td></tr></tbody></table><h4 id="x-显示内存中内容命令"><a href="#x-显示内存中内容命令" class="headerlink" title="x 显示内存中内容命令"></a>x 显示内存中内容命令</h4><p>格式: x /nfu<addr></addr></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">n表示要显示的内存单元的个数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">f表示显示方式,</span> <span class="string">可取如下值</span></span><br><span class="line"><span class="attr">x</span> <span class="string">按十六进制格式显示变量。</span></span><br><span class="line"><span class="attr">d</span> <span class="string">按十进制格式显示变量。</span></span><br><span class="line"><span class="attr">u</span> <span class="string">按十进制格式显示无符号整型。</span></span><br><span class="line"><span class="attr">o</span> <span class="string">按八进制格式显示变量。</span></span><br><span class="line"><span class="attr">t</span> <span class="string">按二进制格式显示变量。</span></span><br><span class="line"><span class="attr">a</span> <span class="string">按十六进制格式显示变量。</span></span><br><span class="line"><span class="attr">i</span> <span class="string">指令地址格式</span></span><br><span class="line"><span class="attr">c</span> <span class="string">按字符格式显示变量。</span></span><br><span class="line"><span class="attr">f</span> <span class="string">按浮点数格式显示变量。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">u表示一个地址单元的长度</span></span><br><span class="line"><span class="attr">b表示单字节，</span></span><br><span class="line"><span class="attr">h表示双字节，</span></span><br><span class="line"><span class="attr">w表示四字节，</span></span><br><span class="line"><span class="attr">g表示八字节</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>unix文件系统</title>
      <link href="/post/35532.html"/>
      <url>/post/35532.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>文件就是任意源，有一个名称，可以从中写入读出数据。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>unix中有三种文件类型，普通文件，目录和伪文件。</p><p>普通文件是大多数时候所使用的文件，包括文本文件和二进制文件。例如，纯文本，shell脚本，源程序，配置文件，html文件等。</p><p>目录不同之处在于他们用来组织，访问其他文件。从概念上讲，目录包含其他文件。这个文件其实类似于windows下的文件夹。</p><p>伪文件有时候也称为设备文件。这种文件是物理设备的内部表示。例如键盘，显示器，打印机等，这些设备都可以当成一个文件进行访问。</p><p>有一种特殊的伪文件时proc文件，这种文件可以访问linux内核中的信息，设置可以修改Linux内核中的数据。</p><h3 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h3><p>特殊文件就是表示物理设备的伪文件。这些文件都被存放于/dev下</p><p>一些常见的设备如下</p><table><thead><tr><th>位置</th><th>硬件</th></tr></thead><tbody><tr><td>/dev/sda</td><td>SCSI硬盘</td></tr><tr><td>/dev/sda</td><td>第一分区</td></tr><tr><td>/dev/hda</td><td>硬盘</td></tr><tr><td>/dev/Ip0</td><td>打印机</td></tr><tr><td>/dev/tty</td><td>当前终端</td></tr><tr><td>/dev/random</td><td>随机数生成器</td></tr><tr><td>/dev/null</td><td>放弃输入 输入不返回内容</td></tr><tr><td>/dev/zero</td><td>放弃送站，输入返回0</td></tr></tbody></table><p>写入到/dev/null 或/dev/zero 中的任何文件都会被抛弃，因此这些文件又叫做位桶。</p><p>如果想读取随即数，只需要读取/dev/random。</p><h3 id="mkfifo-命名管道"><a href="#mkfifo-命名管道" class="headerlink" title="mkfifo 命名管道"></a>mkfifo 命名管道</h3><p>在前面我们已经介绍过了管道，那种管道是匿名管道，就是只有当程序运行的时候它才被创建。</p><p>命名管道与匿名管道的显著区别就是必须显式的创建管道，其次，当命令结束之后，管道并不会消失，而是会继续存在，除非使用命令删除他们。</p><p>通常将命名管道称为FIFO，实际上就是队列。</p><p>语法： mkfifo [-m mode] pipe</p><p>其中，mode是chmod程序使用的一种文件类型，pipe是希望创建的管道名称。</p><p>用途：经常被用来两个进程中的通信。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfifo fifotest</span><br><span class="line"><span class="keyword">grep</span> bash <span class="regexp">/etc/</span>passwd &gt; fifotest <span class="comment">//第一个窗口上的命令</span></span><br><span class="line">wc -l &lt; fifotest <span class="comment">//这是第二个窗口上的命令</span></span><br></pre></td></tr></table></figure></div><p>如果想要去除管道，只需要rm + 管道名即可。</p><h3 id="proc文件"><a href="#proc文件" class="headerlink" title="proc文件"></a>proc文件</h3><p>proc文件时那些提供一些简单途径来检查多种类型的系统信息的伪文件。proc文件可以直接从内核中提取数据。</p><p>所有的proc文件都存放在/proc目录下，在这个目录中，可以发现每一个进程对应一个子目录。</p><p>如果想提取这些进程的信息，可以使用cat命令去找到当前有那些进程正在执行，如果进入这些目录，还可以知道这些进程的详细状态。</p><p>有一个特殊的proc文件，/proc/kcore，这个文件表示计算机的实际物理内存。可以使用ls -l选项查看这个文件的大小。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="根目录-子目录"><a href="#根目录-子目录" class="headerlink" title="根目录 子目录"></a>根目录 子目录</h4><p>目录是一个树形结构，对于每一层一定会有一个根，而用root过于麻烦，所以一般用/表示根目录。</p><p>例如 ls / 表示列举根目录下的所有文件。这样 ls /bin代表列bin目录下的所有文件。但是实际上如果列举根目录下的文件是不需要加/的，直接加上名字就好了，如果想访问根目录下子目录中的文件，就需要在子目录和子目录文件之间加一个/</p><p>例如： ls homework/bomb</p><h4 id="mount-umount挂载文件系统"><a href="#mount-umount挂载文件系统" class="headerlink" title="mount umount挂载文件系统"></a>mount umount挂载文件系统</h4><p>在系统中，有许多设备，也就有许多个文件系统。但是如果都是完全分隔的话，没办法在不同文件系统之间进行访问，所以一定有一颗主树，然后其他树挂载在主树上，这一个个文件系统其实类似于windows下的磁盘分区。</p><p>当小的文件系统连接上主树时，我们称为挂载。小文件系统附加到主树上的目录叫做挂载点</p><p>一般来说，系统已经自动挂载好了子树，但是有时候需要我们手动挂载子树（例如插入u盘时，当然现在也是自动挂载了）。这时需要mount程序。这里不再展开</p><h4 id="漫游根目录"><a href="#漫游根目录" class="headerlink" title="漫游根目录"></a>漫游根目录</h4><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>/</td><td>根目录</td></tr><tr><td>/bin</td><td>基本程序</td></tr><tr><td>/boot</td><td>启动系统时所需要的文件</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/dev</td><td>设备文件</td></tr><tr><td>/home</td><td>用户home目录</td></tr><tr><td>/lib</td><td>基本共享库，内核模块</td></tr><tr><td>/lost+found</td><td>由fsck恢复的受损文件</td></tr><tr><td>/media</td><td>可移动介质的挂载点</td></tr><tr><td>/mnt</td><td>不能挂载在其他位置的挂载点</td></tr><tr><td>/opt</td><td>第三方应用程序</td></tr><tr><td>/proc</td><td></td></tr><tr><td>/root</td><td>超级用户home目录</td></tr><tr><td>/srv</td><td>本地系统提供服务的数据</td></tr><tr><td>/tmp</td><td>临时文件</td></tr><tr><td>/usr</td><td>静态数据使用的文件系统</td></tr><tr><td>/var</td><td>可变数据使用的文件系统</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线索二叉树</title>
      <link href="/post/43817.html"/>
      <url>/post/43817.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>普通的二叉树中空节点数量很多，例如一个有2n条分支的二叉树，其中节点数只有n-1个，空节点有n+1个，因此就要想办法把这些没用到的节点利用起来。</p><p>可以用原来的空节点去存放指针，指向其他节点，这中指针叫做线索。</p><p>记ptr指向二叉链表中的一个结点，以下是建立线索的规则：</p><p>（1）如果ptr-&gt;lchild为空，则存放指向中序遍历序列中该结点的前驱结点。这个结点称为ptr的中序前驱；</p><p>（2）如果ptr-&gt;rchild为空，则存放指向中序遍历序列中该结点的后继结点。这个结点称为ptr的中序后继；</p><p>显然，在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继，需要一个区分标志的。因此，我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是区分0或1数字的布尔型变量，其占用内存空间要小于像lchild和rchild的指针变量。结点结构如下所示。<br><img src="/images/26548237_13584034551s55.jpg" alt></p><p>ltag = 0 表示指向左孩子，= 1 表示指向前驱</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉线索存储结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;Link, Thread&#125;PointerTag;    <span class="comment">//Link = 0表示指向左右孩子指针；Thread = 1表示指向前驱或后继的线索</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="keyword">char</span> data;                                      <span class="comment">//结点数据</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>                <span class="comment">//左右孩子指针</span></span><br><span class="line">       PointerTag  Ltag;                               <span class="comment">//左右标志</span></span><br><span class="line">       PointerTag  rtal;</span><br><span class="line">&#125;BitNode, *BiTree;</span><br></pre></td></tr></table></figure></div><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以，线索化的过程就是在遍历的过程中修改空指针的过程。<br></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> BiTree pre = NULL;                 <span class="comment">//全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"><span class="comment">//中序遍历进行中序线索化</span></span><br><span class="line">void InThreading(BiTree p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>lchild);          <span class="comment">//递归左子树线索化</span></span><br><span class="line">                <span class="comment">//===</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(!p-&gt;</span>lchild)           <span class="comment">//没有左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>ltag = Thread;    <span class="comment">//前驱线索</span></span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>lchild = pre; <span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(!pre-&gt;</span>rchild)     <span class="comment">//没有右孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rtag = Thread;  <span class="comment">//后继线索</span></span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rchild = p; <span class="comment">//前驱右孩子指针指向后继(当前结点p)</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">                <span class="comment">//===</span></span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>rchild);      <span class="comment">//递归右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>上述代码除了//===之间的代码以外，和二叉树中序遍历的递归代码机会完全一样。只不过将打印结点的功能改成了线索化的功能。<p></p><p>因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if(!pre-&gt;rchild)表示如果为空，则p就是pre的后继，于是pre-&gt;rchild = p，并且设置pre-&gt;rtag = Thread，完成后继结点的线索化。</p><p>前驱指的是某种遍历顺序中在你前面的节点，而后继就是在你后面的节点，这也是为什么pre = p 要写在InThreading(p-&gt;lchild)后面的原因，中序遍历是先做子树的，那么它只能是右子树的前驱而不能是左子树的前驱</p><p>遍历代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点。</span></span><br><span class="line"><span class="comment">//中序遍历二叉线索树表示二叉树t</span></span><br><span class="line">int InOrderThraverse_Thr(BiTree t)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="function"><span class="title">p</span> = t-&gt;</span>lchild;                               <span class="comment">//p指向根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != t)                               <span class="comment">//空树或遍历结束时p == t</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span>ltag == Link)                       <span class="comment">//当ltag = 0时循环到中序序列的第一个结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">printf</span>("%c ", p-&gt;</span><span class="keyword">data</span>);                      <span class="comment">//显示结点数据，可以更改为其他对结点的操作</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">rtag</span> == Thread &amp;&amp; p-&gt;</span>rchild != t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;</span><br><span class="line">            <span class="function"><span class="title">printf</span>("%c ", p-&gt;</span><span class="keyword">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;                         <span class="comment">//p进入其右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树链表构建和应用</title>
      <link href="/post/11799.html"/>
      <url>/post/11799.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>中序</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void inorder(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> != NULL)</span><br><span class="line">    &#123; </span><br><span class="line">        inorder(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">T</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">        inorder(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>前序</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void preorder(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">T</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">        preorder(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        preorder(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>后序遍历同理。</p><p>这个算法是以当前节点为基点，先输出当前节点数值，然后再去输出左子树数值，然后再递归输出左子树数值知道NULL，才又递归输出右子树数值。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="二叉树构建"><a href="#二叉树构建" class="headerlink" title="二叉树构建"></a>二叉树构建</h4><p>如果我们只给出数值和构建顺序，是无法构建二叉树的。例如，给出三个数，然后给出构建顺序是123这样总共有5中构建方法。因此还要把空节点加上才可以构建。空节点的值为-1或@</p><p>前序遍历构建</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="R"><figure class="iseeu highlight /r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void create(binarytree *<span class="literal">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'@'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">T</span> = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">T</span> = new binarynode;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">T</span> == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">T</span>-&gt;data = c;</span><br><span class="line">        create(<span class="literal">T</span>-&gt;left);</span><br><span class="line">        create(<span class="literal">T</span>-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里是先构造当前节点，如果当前节点不是空节点，那么构造左节点和右节点。如果是，直接空节点返回。</p><h4 id="计算叶结点个数"><a href="#计算叶结点个数" class="headerlink" title="计算叶结点个数"></a>计算叶结点个数</h4><p>叶节点的特点就是左右子树都是空。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="COQ"><figure class="iseeu highlight /coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int calculate(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)//空树</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;<span class="built_in">left</span> == NULL &amp;&amp; T-&gt;<span class="built_in">right</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(T-&gt;<span class="built_in">left</span>) + calculate(T-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="计算节点个数"><a href="#计算节点个数" class="headerlink" title="计算节点个数"></a>计算节点个数</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="COQ"><figure class="iseeu highlight /coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int calulate(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + calculate(T-&gt;<span class="built_in">left</span>) + calculate(T-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="计算二叉树高度"><a href="#计算二叉树高度" class="headerlink" title="计算二叉树高度"></a>计算二叉树高度</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> counthigh(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = counthigh(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">n</span> = counthigh(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">        return m &gt; <span class="built_in">n</span> ? m+<span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>它的思想是比较左子树和右子树高度，然后再加上根的高度。</p><h4 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h4><p>按前序遍历的方法最好复制</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">binode* <span class="keyword">copy</span>(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    binode *<span class="keyword">temp</span> = <span class="built_in">new</span> node;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">temp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">exit</span>(overflow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">temp</span>-&gt;data = T-&gt;data;</span><br><span class="line">    <span class="keyword">temp</span>-&gt;left = <span class="keyword">copy</span>(T-&gt;left);</span><br><span class="line">    <span class="keyword">temp</span>-&gt;right = <span class="keyword">copy</span>(T-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="非递归搜索二叉树"><a href="#非递归搜索二叉树" class="headerlink" title="非递归搜索二叉树"></a>非递归搜索二叉树</h3><p>非递归构造二叉树主要用到了栈来模拟递归过程。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> inorder(binode *T)</span><br><span class="line">&#123;</span><br><span class="line">    binode *p;</span><br><span class="line">    stack&lt;binode*&gt; s;<span class="comment">//如果不行就自己构建一个栈</span></span><br><span class="line">    s.<span class="keyword">push</span>(T);<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( p == s.gettop() &amp;&amp; p != <span class="keyword">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">push</span>(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="comment">/*因为是push左子树，所以最后先push进一个空然后才会退出循环</span></span><br><span class="line"><span class="comment">        所以要先把这个NULL去掉*/</span></span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p = s.gettop();</span><br><span class="line">            cout &lt;&lt; p-&gt;data;</span><br><span class="line">            s.<span class="keyword">pop</span>();<span class="comment">//去掉p节点</span></span><br><span class="line">            s.<span class="keyword">push</span>(p-&gt;right);</span><br><span class="line">            <span class="comment">/*如果p是叶结点，那么push右边也是NULL,内层循环不会执行，然后</span></span><br><span class="line"><span class="comment">            执行pop取点NULL，之后if中又会取出上一层节点继续找右子树*/</span></span><br><span class="line">            <span class="comment">//如果右子树中还有分支，那么会继续这个过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段程序的含义是先找左节点，然后把中间节点退出去，找右节点，在右节点中重复找左节点。</p><p><strong>前序遍历</strong>又稍有不同，因为前序遍历是先直接输出根节点，所以根节点就不需要存入栈中，实际栈中存入的是右节点。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(binode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;binode*&gt; s;</span><br><span class="line">    binode *p = T;</span><br><span class="line">    s.push(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;left;<span class="comment">//进入左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s.gettop();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码是先输出根，然后把右子树拖入栈中，进入左子树，如果左子树遍历完了，p-&gt;left == NULL,之后就到右子树那边去遍历。</p><p><strong>后序遍历</strong>更为麻烦，stack要用自己的，设置一个标志位确定现在是左子树还是右子树</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stacknode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    binode *ptr;</span><br><span class="line">    <span class="keyword">enum</span> tag&#123;L,R&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(binode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> s;</span><br><span class="line">    stacknode w;</span><br><span class="line">    binode *p = T;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            w.ptr = p;</span><br><span class="line">            w.tag = L;</span><br><span class="line">            push(s,w);</span><br><span class="line">            p = p-&gt;leftchild;</span><br><span class="line">        &#125;<span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">continue</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">continue</span> != <span class="number">0</span> &amp;&amp; !stackempty(s))</span><br><span class="line">        &#123;</span><br><span class="line">             pop(s,w);</span><br><span class="line">             p = w.ptr;</span><br><span class="line">             <span class="keyword">switch</span>(w.tag)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">case</span> L: w.tag = R;<span class="comment">//这时算作根节点，根节点为R那么下次就会输出</span></span><br><span class="line">                      push(s,w);</span><br><span class="line">                      <span class="keyword">continue</span> = <span class="number">0</span>;<span class="comment">//退出循环</span></span><br><span class="line">                      p = p-&gt;right;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> R: <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(p != <span class="literal">NULL</span> || !stackempty(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程的储存和缓冲区溢出</title>
      <link href="/post/27045.html"/>
      <url>/post/27045.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p>用户空间是用户可以使用的空间，与之对应的是内核空间，这是系统所使用的空间。用户空间的大小有2的48次方，远远超出了内存的大小。</p><p>用户空间主要分为四个区域：</p><ul><li>栈，栈位于用户空间的最高处，从高处向低处生长。linux系统中栈空间大小是8MB</li><li>堆， 用于存放一些动态分配的数据</li><li>数据， 用来存放全局变量，静态变量，字符串常量</li><li>代码， 存放指令和共享库</li></ul><p>在Linux中，对于大小小于某一阈值的数据，在堆中分配时是从低地址向高地址生长。反之，从高地址向低地址生长</p><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>常见原因： 申请了一个数组但是访问时越界。</p><p>我们可以把数组叫做缓冲区，超出边界就是缓冲区溢出。</p><p>常见表现，对于输入的字符串没有进行长度检查直接赋值。如果缓冲区分配在栈中，就有可能造成栈中数据的破坏。如果造成了返回地址的破坏，可能直接导致程序的崩溃。这种错误叫做 segmentation fault</p><p>这里便可以被黑客利用，先故意把返回地址破坏了并且让返回地址到他自己写的程序上，这样retq时就可以调用自己写的程序。这种方法叫做注入。一般注入的数据有三部分，第一部分是恶意的指令。第二部分是占位数据，这部分数据没什么含义，只是和指令加起来正好到返回地址处，第三部分就是篡改的地址，篡改后的地址指向缓冲区底部即恶意指令所在的地方。</p><h3 id="防御代码注入攻击"><a href="#防御代码注入攻击" class="headerlink" title="防御代码注入攻击"></a>防御代码注入攻击</h3><ul><li>程序员：不要使用不安全的函数</li><li>系统： 栈基地址随机化分配。设置可执行权限位（就是设置一些地方的bit只能当做数据而不能当做指令）</li><li>编译器： 添加栈破坏检测。通过添加金丝雀值（canary value），位于当前栈帧底部。如果金丝雀值被破坏，那么就终止程序。</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>结构体</title>
      <link href="/post/6880.html"/>
      <url>/post/6880.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="结构体的构成"><a href="#结构体的构成" class="headerlink" title="结构体的构成"></a>结构体的构成</h3><p>首先位于结构体中的元素在计算机也是对应存储的。而结构体的名字其实就可以看成是第一个变量的首地址。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在内存中是这样的</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| val | c | a[<span class="number">0</span>] | a[<span class="number">1</span>]</span><br><span class="line">p   p+<span class="number">4</span>   p+<span class="number">5</span>   p+<span class="number">9</span></span><br></pre></td></tr></table></figure></div><p>而变量在内存中的位置于定义时的位置是对应的</p><h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>首先说明什么事字节对齐。它指的是变量在内存中的首地址是变量的长度的整数倍。</p><p>例如定义一个int型变量，那么这个变量首地址尽量要是4的整数倍。也就是地址最后两位一定为零，如果是long型，地址最后三位一定为零</p><p><strong>为什么要字节对齐？</strong></p><p>字节对齐可以加快访问数据的效率。原因是64位处理器数据总线是64位的，一次传过来8个字节的数据，所以如果我们是按8的整倍数进行存放，那么一定可以一次性取完，但是如果不是8的整倍数，例如int型首地址是6，那么就不可以一次性取完，要两次来取。而如果我们放在4这个位置，那么一定可以一次性取完。</p><p>此外例如首地址是2，这样也可以一次性取完，但是这样会造成空间浪费，因为现在不能再存int型了，可能会导致剩下4个字节都不能用。</p><p>对于x86系列，可以通过拼凑的方式把数据合起来。但是arm系列，如果没字节对齐，甚至会直接报错。</p><p>因此对于上面这个例子在c这个位置后面应该是p+8,为了让后面的整型保持对齐。而这多出的三个字节不会被使用（从此我们可以得出定义char型最好定义4个，不然多浪费）</p><p>此外，结构体的首地址的倍数由后面元素中占用空间最多的那个来决定。<strong>结尾的地址也要是占用空间最多的整倍数</strong>。结尾也要符合标准是为了便于用数组，因为数组的地址是连续的，所以每个的头和尾都要满足要求。</p><p>字节对齐还有利于结构体中元素的访问。我们之所以可以直接写a.data是因为每个元素在结构体中所占用的空间大小是一样的（考虑字节对齐），这样我们就可以像数组那样直接加上一个偏移量去访问。</p><p><strong>提示</strong>，为了节省空间，把相同类型的元素放到一块写，</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">|</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodeb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>可以看出，第一种写法为保证字节对齐需要多消耗6字节的空间，而第二种写法只需要消耗两字节的空间。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vi</title>
      <link href="/post/20198.html"/>
      <url>/post/20198.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="启动vi"><a href="#启动vi" class="headerlink" title="启动vi"></a>启动vi</h3><p>语法： vi [-rR] [file…]</p><p>如果用vi启动了一个不存在的文件，那么他将新建这个文件。如果只输入vi，那么他将在当前文件夹下创建一个空文件</p><p>-R 以只读模式启动</p><p>vim是vi的进阶版本</p><p>语法： vi -C [-rR] [file…]</p><p>-C是兼容模式，它将尽可能的和vi保持一样</p><h3 id="命令模式和编辑模式"><a href="#命令模式和编辑模式" class="headerlink" title="命令模式和编辑模式"></a>命令模式和编辑模式</h3><p>当使用vi时，存放数据的区域叫做编辑缓冲区（editing buffer),如果想编辑文件，那么vi就将文件的内容复制到缓冲区中，然后再缓冲区中编辑。因此处理的其实是文件的副本。</p><p>在命令模式中，输入的一切字符都是命令。例如，在命令模式中，单个字母x就是删除一个字符。dd就是删除整行的命令。</p><p>第二种模式就是输入模式。这种模式下，任何内容都会输入到缓冲区中。</p><p>在启动过程中，vi完成三件事情。将文件中的内容复制到编辑缓冲区，将光标定位到缓冲区第一行的开头。最后vi进入命令模式。</p><h3 id="数据的恢复和关闭vi"><a href="#数据的恢复和关闭vi" class="headerlink" title="数据的恢复和关闭vi"></a>数据的恢复和关闭vi</h3><p>当使用vi时，数据会保存在编辑缓冲区内，因此当程序非正常终止时，临时文件依然存在。使用-r(recovery)就可以重新打开缓冲区</p><p>如果需要先保存再退出，使用的命令时ZZ,即先按下shift键，然后按z两次。这个命令不需要按enter键</p><p>如果不保存直接退出，可以 :q!，然后按return键</p><h3 id="vi屏幕的格式即vi和ex命令"><a href="#vi屏幕的格式即vi和ex命令" class="headerlink" title="vi屏幕的格式即vi和ex命令"></a>vi屏幕的格式即vi和ex命令</h3><p>屏幕底部的一行叫做命令行。这一行有两种功能：显示消息和显示键入时的命令。</p><p>大多数时候vi编辑的数据都是纯文本（字母，数字，标点符号等）。如果想输入控制字符，需要使用^v。 例如，如果想输入^c,那么需要输入^v^c.</p><p>vi和ex命令其实都是vi编辑器中的命令。大多数vi命令都是单字母或双字母形式。大多数vi命令无需按下return键。例如，一但输入dd，那么立刻会删除一行。</p><p>ex命令一般都比较长，并且在键入过程中会显示在屏幕下方。如果键入有错误，可以backspace删除单个字符或者^x/^u删除所有字符。</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>h 向左移动一个字符</p><p>j 向下移动一个字符</p><p>k 向上移动一个字符</p><p>l 向右移动一个字符</p><p>另外一种方式是上下左右键。</p><p>此外，backspace 向左移动一个位置，space向右移动一个位置。-号移动到上一行，+号移动到下一行。</p><p>0移动到当前行的开头，$移动到当前行的结尾。^移动到第一个非制表符/空格字符上</p><p>w移动到下一个单词的开头，e移动到下一个单词的结尾。b移动到上一个单词的开头</p><p>W，E，B的作用和w，e，b的作用相同，但是忽略标点符号</p><p>( 移动到上一个句子</p><p>) 移动到下一个句子</p><p>{ 移动到上一个段落</p><p>} 移动到下一个段落</p><p>句子的定义时一个字符串，以句号，逗号，问号和感叹号结尾，并且后面要接一个新行字符或者两个空格</p><p>H 移动到屏幕的顶部（是当前屏幕，不是整个文章）</p><p>M 移动到屏幕的中间</p><p>L 移动到屏幕的底部</p><p>为了增强命令的功能，可以在命令之前输入数字确定重复次数。例如：10w代表跳过十个单词。不需要输enter。</p><h4 id="整屏移动"><a href="#整屏移动" class="headerlink" title="整屏移动"></a>整屏移动</h4><p>^f(ctrl+f,forward) 移动到下一屏</p><p>^B(backward) 移动到上一屏</p><p>^d 下移半屏，^u 上移半屏</p><p>这里^d和^u前面加数字与前面略有不同。前面只对该次有效，而这里是一直有效</p><h4 id="跳转到前一位置"><a href="#跳转到前一位置" class="headerlink" title="跳转到前一位置"></a>跳转到前一位置</h4><p>可以使用两个反引号跳转到前一位置。这个前一位置并不简单指的是上一条指令的位置。如果你一直使用行跳转的话那么这条指令将会带你去没进行行跳转时的位置。其实相当于保存了两个地址，你可以在两个地址之间跳转进行修改，第一个地址就是每跳转之前的地址。第二个地址就是跳转之后的地址。如果你现在位于第二个地址上，那么进行跳转只会改变第二个地址。用了反引号后直接回到第一个地址，然后如果再在第一个地址上跳转，那么只会修改第一个地址。</p><p>第二个跳转地址是在你第一次使用移动命令后产生的，也可以看为开始第一个地址和第二个地址再同一位置。之后一直都是在对第二地址进行修改。</p><p>如果使用两个单引号，那么将会回到对应地址的开头。</p><p>此外，我们还可以通过设置标识来新增跳转地址。先键入m，再输入标识符，之后就可以直接跳转到有标识符的位置。标识符是不可见字符，所以最好自己先记好。</p><p>例如： ma设置a标识符。 `a回到a的位置</p><h3 id="搜索模式"><a href="#搜索模式" class="headerlink" title="搜索模式"></a>搜索模式</h3><p>符号： / ?</p><p>/ 向下面搜索，/+字符表示要搜索哪个字符。如果还想继续搜索该字符只需要输入/然后回车就会搜索下一个</p><p>？ 用法相同，向上搜索</p><p>或者按n继续向下搜索，N继续向上搜索</p><p>此外，还可以使用正则表达式中的锚</p><h3 id="使用行号和切换模式"><a href="#使用行号和切换模式" class="headerlink" title="使用行号和切换模式"></a>使用行号和切换模式</h3><p>可以通过 :set number 设置显示行号</p><p>如果行号关闭，可以通过 ^G键查看现在在文本中的哪个位置</p><p>可以通过 数字+G（大写）跳转到任意一行</p><p>此外，还可以通过 :+数字跳转到任意一行，其中 :$ 跳转到文本末尾</p><p>前文已经说了vi有两种模式，一种是编辑模式，一种是命令模式，从编辑模式切换成命令模式只有一种方法，按esc键。但是从命令模式转换到编辑模式有十二种之多</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">i</span> <span class="string">在当前光标之前插入字符</span></span><br><span class="line"><span class="attr">a</span> <span class="string">在光标之后插入字符</span></span><br><span class="line"><span class="attr">I</span> <span class="string">在当前行的开头插入字符</span></span><br><span class="line"><span class="attr">A</span> <span class="string">在当前行的末尾插入字符</span></span><br><span class="line"><span class="attr">o</span> <span class="string">在当前行下面插入一行</span></span><br><span class="line"><span class="attr">O</span> <span class="string">在当前行上面插入一行</span></span><br></pre></td></tr></table></figure></div><h3 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h3><p>如果只需要修改一个字符的话，那么可以在命令模式下输入r+字符就可以修改光标后面的字符（注意不是增加而是直接把光标后面的字符变成输入的字符）</p><p>如果想要修改很多字符，可以输入R，这时会切换到输入模式。随后键入的每个字符都会替换当前字符。</p><p>如果想要修改的字符数与原来并不相同，那么可以使用s（substitute)命令把一个字符变成许多个字符。如果输入了s，那么将回到输入模式，且此时光标后面的后面的字符将会变成$，然后再输入字符，$就会变成对应的字符</p><p>例如 m|a,输入s后变成 m|$，然后输入other，就会变成 mother</p><p>此外C命令是将光标后面的字符都替换，如果输入了这个命令，那么在该行的最后将会出现$</p><p>cc命令可以替换一整行，无论光标在哪里</p><p>c+移动光标命令，这将替换从光标处到移动后的光标处所有的字符，可以有重复次数</p><h3 id="替换文本"><a href="#替换文本" class="headerlink" title="替换文本"></a>替换文本</h3><p>这里我们主要谈论的是ex命令。这些命令都以 ： 为开始。</p><p>替换语法： :s/pattern/replace/</p><p>这条命令的含义是替换第一个pattern，如果后面加上g（global），那么将替换所有pattern。</p><p>如果希望改变之前先请求同意，可以在后面加上 c（confirm）。也可以同时使用gc</p><p>如果想要删除某些pattern，只需要 :s/pattern//g即可</p><p>在s前面加上数字表示替换某些行。例如： :57s/unix/linux 表示把第57行第一次出现的unix变成linux。</p><p>如果想从当前行到末尾，那么可以使用 : . , $s/pattern/replace/</p><p>其中 .(点）表示当前行，$表示最后一行，中间用逗号分割开来。</p><h3 id="删除字符"><a href="#删除字符" class="headerlink" title="删除字符"></a>删除字符</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">x</span> 删除右边的字符</span><br><span class="line"><span class="selector-tag">X</span> 删除左边的字符</span><br><span class="line"><span class="selector-tag">D</span> 删除当前光标到本行末尾的字符</span><br><span class="line"><span class="selector-tag">d</span>+移动指令 删除从当前光标到移动指令后的字符</span><br><span class="line"><span class="selector-tag">dd</span> 删除当前行</span><br><span class="line"><span class="selector-tag">ex</span> 命令</span><br><span class="line"><span class="selector-pseudo">:lined</span> 删除指定行</span><br><span class="line"><span class="selector-pseudo">:line</span>,<span class="selector-tag">lined</span> 删除多个行</span><br></pre></td></tr></table></figure></div><p>如果要删除所有行，一种是 :1,$d，另一种是:%d，%指的是所有行</p><h3 id="撤销或重复改变"><a href="#撤销或重复改变" class="headerlink" title="撤销或重复改变"></a>撤销或重复改变</h3><p>撤销就是如果命令输入错误，可以使用命令撤销</p><p>u 撤销上一命令对缓冲区进行的修改</p><p>U 恢复当前行</p><p>. 重复上一命令对编辑缓冲区进行的修改</p><p>其中 U 指的是将撤销至移动到当前行的那一刻起，对当前行所进行的所有改变</p><p>.命令可以用来重复，但是如果使用了撤销，那么它将会使用撤销所恢复的命令</p><h4 id="恢复删除"><a href="#恢复删除" class="headerlink" title="恢复删除"></a>恢复删除</h4><p>每当删除<strong>一行或者多行</strong>文本时，vi都将文本储存在一个缓冲区中，这个缓冲区称为编号缓冲区。vi有9个缓冲区。在任何时候，都可以将一个编号缓冲区中的内容插入到编辑缓冲区中。这样做时，需要键入一个双引号（“），后面跟着缓冲区的编号，再后面跟着一个p（put)命令，p是在当前行下面插入，P是在当前行上面插入。</p><p>如果你忘记是哪个编号缓冲区的话，可以先撤销一次，然后使用.号重复插入，这时vi将自动把缓冲区编号加1</p><h3 id="移动文本"><a href="#移动文本" class="headerlink" title="移动文本"></a>移动文本</h3><p>vi总是在一个称为无名缓冲区的地方为上一次删除保存一个副本。与编号缓冲区不同，编号缓冲区只会保存删除的多行，删除少数字符是不会被保存的。</p><p>p 命令用来把无名缓冲区的内容插入到当前位置之后</p><p>考虑组合命令xp，x是删除当前光标处的字符。p是把字符插入光标的右边。这样相当于把两个自住房换了一下顺序。</p><p>另一个重要的组合命令是deep，这个命令是将两个单词换序</p><p>ddp 调换两行，因为dd是删除一行，删除这行后光标在原本该行的下一行，然后p是插入到这一行的后一行，相当于两行换了位置。</p><h3 id="复制文本"><a href="#复制文本" class="headerlink" title="复制文本"></a>复制文本</h3><p>复制文本分为三步：</p><ol><li>使用y，yy或Y命令将文本有编辑缓冲区复制到无名缓冲区中，但不删除原始文本。</li><li>将光标移动到希望插入文本的位置。</li><li>使用p或P命令命令执行插入</li></ol><p>在不删除文本的情况下将文本复制到无名缓冲区，叫做接出（yank)，因此将命令命名为y，yy，Y。y，yy命令和d命令执行情况相同，</p><h3 id="改变字母大小写"><a href="#改变字母大小写" class="headerlink" title="改变字母大小写"></a>改变字母大小写</h3><p>符号： ~</p><p>该命令会改变vi当前字母的大小写，然后将光标向前移动一个字符。改变大小写的意思是把大写变成小写，小写变成大写。</p><p>有些版本的vi使用这个命令不会超过一行，just like me。</p><h3 id="设置选项"><a href="#设置选项" class="headerlink" title="设置选项"></a>设置选项</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> showmode 输入模式提醒</span><br><span class="line">:<span class="builtin-name">set</span> number 显示行号</span><br><span class="line">:<span class="builtin-name">set</span> nonumber 不显示行号</span><br><span class="line">:<span class="builtin-name">set</span> tabstop = number 设置制表符间距</span><br><span class="line">:<span class="builtin-name">set</span> autoindent 缩进以匹配上一行/下一行</span><br><span class="line">:<span class="builtin-name">set</span> autowrite 如果文本已修改，则在切换文件前保存</span><br><span class="line">:<span class="builtin-name">set</span> errorbells 显示错误信息时发出声音</span><br><span class="line">:<span class="builtin-name">set</span> list 将制表符显示成^I,将行的结束显示成$</span><br><span class="line">:<span class="builtin-name">set</span> showmatch 显示匹配的 () &#123;&#125; []</span><br><span class="line">:<span class="builtin-name">set</span> wrapscan 环绕文本进行搜索</span><br><span class="line">:<span class="builtin-name">set</span> lines 设置文本行数</span><br><span class="line">:<span class="builtin-name">set</span> wrapmargin = n 在键入过程中自动换行，n是离右边缘的位置，例如<span class="attribute">n</span>=6意味着在例右边缘6个字符的地方换行，为0关闭自动换行</span><br></pre></td></tr></table></figure></div><p>如果想查看当前选项是在什么状态，可以使用:set 选项？</p><p>如果显示所有选项的值，可以使用 :set all</p><h3 id="复制移动行"><a href="#复制移动行" class="headerlink" title="复制移动行"></a>复制移动行</h3><p>如果想指定行号进行移动，可以使用ex命令中的 :co(copy) :m(move)</p><p>:5co10,复制第5行，并将其放在第10行的下面</p><p>:4,8co20 复制4到8行，并将其放在20行的下面</p><h3 id="输入shell命令"><a href="#输入shell命令" class="headerlink" title="输入shell命令"></a>输入shell命令</h3><p>可以通过 :!+命令的方式，在不退出vi的情况下进行shell命令</p><p>:!! 重复上一条shell命令</p><p>如果现在缓冲区中直接插入shell命令的输出，可以使用 :r !</p><p>例如 :1r !date，就是将date输出插入第一行的后面</p><p>如果直接用感叹号，那么就会将文件中的数据交给shell命令进行操作，然后再将操作后的文件复制到原位置</p><p>例如： 5!!sort ，这个命令将会从当前开始把接下来5行排序。</p><p>!}sort 这个命令是将接下来一段排序。</p><h3 id="将文件中的数据插入编辑缓冲区中"><a href="#将文件中的数据插入编辑缓冲区中" class="headerlink" title="将文件中的数据插入编辑缓冲区中"></a>将文件中的数据插入编辑缓冲区中</h3><p>语法： :[line]r file</p><p>line 是行号 file是文件名</p><p>:r命令读取文件中的内容，然后将其插入指定行的后面</p><h3 id="不退出vi的情况下进行保存"><a href="#不退出vi的情况下进行保存" class="headerlink" title="不退出vi的情况下进行保存"></a>不退出vi的情况下进行保存</h3><p>:w 将数据写入原有文件<br>:w file 将数据写入一个新文件中<br>:w! file 覆盖原有文件<br>:w&gt;&gt; file 将数据追加到一个新文件中<br>:10w! save 将特定行保存到文件中<br>:wq 保存退出vi 和 ZZ有同样的效果</p><h3 id="切换到一个新文件"><a href="#切换到一个新文件" class="headerlink" title="切换到一个新文件"></a>切换到一个新文件</h3><p>:e + 文件名</p><p>当编辑一个新文件时，原有缓冲区内容会消失，所以首先要使用 :w保存.当使用:e时，系统会自动检查是否保存，如果没有保存，不允许切换到新文件。如果希望忽略这种保护，可以使用:e!命令</p><h3 id="使用缩写"><a href="#使用缩写" class="headerlink" title="使用缩写"></a>使用缩写</h3><p>:ab [short long]</p><p>short是缩写，long是缩写的原文。如果确定了缩写，那么在编辑模式下，如果拼写了缩写，系统会自动变成全称。当然，只有在这个缩写是一个单词（两边有空格）的情况下才会变全称。</p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>:map命令可以创建命令模式下的缩写，实际上，这就可以自己创建命令。这些命令叫做宏</p><p>语法： :map [x commands]</p><p>x是一个字符，commands是vi或ex命令序列</p><p>例如 :map K deep就是将两个单词换位的命令设置成一个宏</p><h3 id="初始化文件"><a href="#初始化文件" class="headerlink" title="初始化文件"></a>初始化文件</h3><p>对于vim来说，初始化文件是.vimrc,</p><p>如果想删除一个缩写，可以使用 :una short</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编 函数</title>
      <link href="/post/30479.html"/>
      <url>/post/30479.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>进入函数在汇编中其实就是callq，出函数就是retq。</p><p>而callq和retq的功能之前已经提到过</p><h3 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h3><p>在x86-64位系统中，有六个寄存器负责传入参数，分别是rdi，rsi，rdx，rcx,r8,r9，同时程序返回时返回值放在rax中。如果大于6个，多的部分就要放在栈上。如果我们想操作在栈上的参数，就要通过 x(%rsp)来操作了。</p><p>例如有7个参数，此时第7个参数就放在栈上那么 8(%rsp)就可以访问这个参数了，pushq操作分为两部分，首先是rsp-8，然后把数据放进去。这个时候其实数据就是在rsp-rsp+8的区域中，也就是说我们直接movq (%rsp)…就可以访问到我们刚才放进去的元素了</p><p>我们这里不采用(%rsp)的原因是因为调用函数是callq，在最后应该是把rip放到栈中，所以要加8到下一个元素。</p><p>如果有8个参数，那么栈中要先存第8个，然后再存第7个。</p><h3 id="栈上的局部储存"><a href="#栈上的局部储存" class="headerlink" title="栈上的局部储存"></a>栈上的局部储存</h3><p>由于现代编译器的不断优化和寄存器的增多，我们一般不把局部变量放到栈中，但是有的时候我们不得不把他们放到栈中。</p><ol><li>寄存器不足时</li><li>某一变量用了&amp;（取地址），因此这个时候不得不把它放到栈中，这样才有一个地址</li><li>当局部变量是数组或结构体时</li></ol><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PERL"><figure class="iseeu highlight /perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">long <span class="keyword">caller</span>()</span><br><span class="line">&#123;</span><br><span class="line">    long <span class="keyword">x</span> = <span class="number">534</span>;</span><br><span class="line">    long <span class="keyword">y</span> = <span class="number">1057</span>;</span><br><span class="line">    long sum = swap_add(&amp;<span class="keyword">x</span>, &amp;<span class="keyword">y</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">汇编代码为：</span><br><span class="line"><span class="keyword">caller</span>:</span><br><span class="line">  subq $16, %rsp</span><br><span class="line">  movq $534, (%rsp)</span><br><span class="line">  movq $1057, <span class="number">8</span>(%rsp)</span><br><span class="line">  leaq <span class="number">8</span>(%rsp), %rsi</span><br><span class="line">  movq %rsp, %rdi</span><br><span class="line">  callq swap_add</span><br><span class="line">  ...</span><br><span class="line">  addq $16,%rsp</span><br></pre></td></tr></table></figure></div><p>汇编中第一行代码为rsp-16，这是为局部变量分配内存空间。534存在最近的一个，1057存在较远的一个，这与前面多个参数存储符合。</p><p>注意在这个函数结束时，分配的栈空间也要清除，也就是最后的addq</p><p>例2：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">long call_proc()</span><br><span class="line">&#123;</span><br><span class="line">    long <span class="keyword">x</span><span class="number">1</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="comment">    int x2 = 2;</span></span><br><span class="line"><span class="comment">    short x3 = 3;</span></span><br><span class="line"><span class="comment">    char x4 = 4;</span></span><br><span class="line"><span class="comment">    proc(x1,&amp;x1,x2,&amp;x2,x3,&amp;x3,x4,&amp;x4);</span></span><br><span class="line"><span class="comment">    return x1-x2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">汇编：</span></span><br><span class="line"><span class="comment">call_proc:</span></span><br><span class="line"><span class="comment">  subq $32,%rsp</span></span><br><span class="line"><span class="comment">  movq $1, 24(%rsp)</span></span><br><span class="line"><span class="comment">  movq $2, 20(%rsp)</span></span><br><span class="line"><span class="comment">  movq $3, 18(%rsp)</span></span><br><span class="line"><span class="comment">  movq $4, 17(%rsp)</span></span><br><span class="line"><span class="comment">  leaq 17(%rsp), %rax</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  movq %rax, 8(%rsp)</span></span><br><span class="line"><span class="comment">  movl $4, (%rsp)</span></span><br><span class="line"><span class="comment">  leaq 18(%rsp), %r9</span></span><br><span class="line"><span class="comment">  movl $3, %r8d</span></span><br><span class="line"><span class="comment">  leaq 20(%rsp), %rcx</span></span><br><span class="line"><span class="comment">  movl $2,%edx</span></span><br><span class="line"><span class="comment">  leaq 24(%rsp), %rsi</span></span><br><span class="line"><span class="comment">  movl $1, %edi</span></span><br><span class="line"><span class="comment">  call proc</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">  add $32,%rsp</span></span><br></pre></td></tr></table></figure></div><p>注意空行前面是存储地址，因为后面函数的参数中有使用。空行后面就是把8个参数赋值。可能这里会有疑问就是这里把参数都赋了值，那么函数返回到原函数时那些参数值不都变了吗？</p><p>按照惯例，寄存器 %rbx，%rbp 和 %r12到%15被划分成被调用者保存寄存器，也就是说，这些寄存器在被调用的函数中都会保存好，因此我们可以把参数存在这些寄存器中，然后需要的时候又从这些寄存器中取出来，这样就保证了参数值不会被改变。其他寄存器[1]<br>。叫做调用者保存寄存器，这些寄存器由调用者自己去保护，例如rdi，rsi等，被调用者并不会保护这些寄存器，也就是说传入参数时，要先把这些寄存器压入栈中，以防止被改变<br>[1]:rsp除外</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PERL"><figure class="iseeu highlight /perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">long p(long <span class="keyword">x</span>, long <span class="keyword">y</span>)</span><br><span class="line">&#123;</span><br><span class="line">    long u = <span class="string">q(y)</span>;</span><br><span class="line">    long v = <span class="string">q(x)</span>;</span><br><span class="line">    <span class="keyword">return</span> u+v;</span><br><span class="line">&#125;</span><br><span class="line">汇编：</span><br><span class="line">p:</span><br><span class="line">  pushq %rbp</span><br><span class="line">  pushq %rbx</span><br><span class="line">  subq $8,%rsp</span><br><span class="line">  movq %rdi, %rbp</span><br><span class="line">  movq %rsi, %rdi</span><br><span class="line">  call <span class="keyword">q</span></span><br><span class="line">  movq %rax, %rbx//保存得到的函数值</span><br><span class="line">  movq %rbp, %rdi</span><br><span class="line">  calll <span class="keyword">q</span></span><br><span class="line">  addq %rbx, %rax</span><br><span class="line">  addq $8, %rsp</span><br><span class="line">  popq %rbx</span><br><span class="line">  popq %rbp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure></div><p>这段代码开始把rbp和rbx拉进栈，是因为后面要改变rbx和rbp，而p本身也是一个函数，要保证被调用者保存寄存器不会被改变，之后在q函数传递参数前先把p的参数保存到rbp和rbx中，这样就保证了参数在函数中不会被破坏。之后传递参数时也可以直接从rbp中传入，</p><h3 id="栈中的内容"><a href="#栈中的内容" class="headerlink" title="栈中的内容"></a>栈中的内容</h3><p>从上面我们可以看到，栈中的内容可能会有寄存器，局部变量，下一个函数所需要的参数等。</p><p>有三类函数，一种是只有调用者的身份，一种是既有调用者又有被调用者的身份，第三种是只有被调用者的身份。</p><p>对于第一种。首先保存参数，之后保存调用者保存寄存器和局部变量，然后保存返回地址。</p><p>对于第二种，同样首先保存参数，之后保存局部变量，但是这里还可能要保存被调用者保存寄存器。同样保存返回地址</p><p>对于第三种，其他大致相同，但是不需要保存被调用者保存寄存器了。</p><p>对于函数的大致过程，首先传入参数，然后运用call进入函数。然后里面可能有一些局部变量需要保存或者寄存器需要保存，这时我们需要分配一个栈帧。之后如果进入函数，首先我们要传递参数（如果进入多个函数且这些函数运动了调用者函数的参数那此时先要把调用者参数放到被调用者保存寄存器中，防止调用者的参数被破坏）。然后call进入函数，被调用者函数返回前先要把被调用者保存寄存器中的内容弹出，和把栈帧释放。之后在调用者函数返回之前要先把调用者保存寄存器弹出，最后返回。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
          <category> AT&amp;T </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>压缩矩阵</title>
      <link href="/post/56929.html"/>
      <url>/post/56929.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>对于特殊的矩阵，例如上下三角矩阵，对称矩阵，三对角矩阵，可以转化成1维矩阵，减小空间的消耗。</p><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>对称矩阵有 aij=aji的特性，因此可以只保存一边，也就是压缩成 <code>n(n+1)/2</code>个</p><p>如果我们用一个一维数组s[n(n+1)/2]来保存，那么它域原矩阵的对应关系</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k= <span class="built_in">i</span>(<span class="built_in">i</span><span class="number">-1</span>)/<span class="number">2</span>+<span class="built_in">j</span><span class="number">-1</span> <span class="built_in">i</span>&gt;=<span class="built_in">j</span></span><br><span class="line">    <span class="built_in">j</span>(<span class="built_in">j</span><span class="number">-1</span>)/<span class="number">2</span>+<span class="built_in">i</span><span class="number">-1</span>  <span class="built_in">i</span>&lt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure></div><p>这个式子先只考虑一边，先看i&gt;=j的情况。此时第一行中压缩矩阵只保存一个值，第二行两个值，依此类推。所以对于第i行先把前i-1行中对应压缩矩阵的值的数量加起来，也就死i(i-1)/2，之后再加上第j行的第j-1个（这里因为数组下标是从0开始）。</p><p>这个例子中的行数是从第一行开始，实际上应该从第0行开始，所以</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k= <span class="built_in">i</span>(<span class="built_in">i</span>+<span class="number">1</span>)/<span class="number">2</span>+<span class="built_in">j</span> <span class="built_in">i</span>&gt;=<span class="built_in">j</span></span><br><span class="line">  <span class="built_in">j</span>(<span class="built_in">j</span>+<span class="number">1</span>)/<span class="number">2</span>+<span class="built_in">i</span> <span class="built_in">i</span>&lt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure></div><p>举个例子，第0行第0个在k中对应位置就是0</p><h4 id="上下三角矩阵"><a href="#上下三角矩阵" class="headerlink" title="上下三角矩阵"></a>上下三角矩阵</h4><p>对称矩阵行数和列数相同</p><p>上三角矩阵其实就是对称矩阵中 i&gt;=j的那一段</p><p>下三角矩阵中第一行的压缩矩阵元素数量是n,第二行是n-1,以此类推，我们也可以得到相应的关系式</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=（<span class="number">2</span>*n-<span class="built_in">i</span><span class="number">-1</span>)*<span class="built_in">i</span>/<span class="number">2</span>+<span class="built_in">j</span> <span class="built_in">i</span>&lt;=<span class="built_in">j</span></span><br><span class="line">  (<span class="number">2</span>*n-<span class="built_in">j</span><span class="number">-1</span>)*<span class="built_in">j</span>/<span class="number">2</span>+<span class="built_in">i</span> <span class="built_in">i</span>&gt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure></div><h4 id="三对角矩阵"><a href="#三对角矩阵" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h4><p>除了第一行和最后一行有两个元素之外，其他行都有三个元素</p><p>对于<code>a[i][j]</code>来说，前面有 3*i-1个元素，本行它前面有j-i+1个位置。所以k=2 * i+j</p><p>反之，如果在压缩矩阵中是第k个位置，那么在原矩阵中 i=(k+1)/3 j=k-2*i</p><h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p>对于非零元素较少的矩阵，可以直接用一个结构体保存 i,j ,sum，然后再用一个结构体数组来保存所有的值。这个数组是从左至右扫描遍历的。一般稀疏矩阵中元素只占5%</p><h5 id="稀疏矩阵转置的算法"><a href="#稀疏矩阵转置的算法" class="headerlink" title="稀疏矩阵转置的算法"></a>稀疏矩阵转置的算法</h5><p>首先，如果用朴素的算法，就是从第零行开始遍历每一列，然后把列变成行。</p><p>如果我们用两个数组分别保存 每一列中元素的数量以及每一列在新的稀疏矩阵中的位置，就有办法可以加快速度</p><p>例如：<img src="/images/%E6%8D%95%E8%8E%B71.PNG" alt></p><p><img src="/images/%E6%8D%95%E8%8E%B7.PNG" alt></p><p>cpot 第一个位置是一是因为数组下标从1开始</p><p>for循环中注意q=cpot[col]，代表现在这个位置已经有东西了，所以再最后++cpot[col]代表现在这一列在新稀疏矩阵的首位置要后移一位。</p><p>其次，因为转置前行号已经是从小到大排了，所以行号小的一定在前面。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>union</title>
      <link href="/post/9197.html"/>
      <url>/post/9197.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>首先看一下结构体，c语言中的结构体占用字节数是所有类型字节数的总和。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>用sizeof测试一下结果是8，但是如果用union呢？会发现结果是4</p><p>union中的参数共用同一块内存空间，它们在内存中起始地址都相同，也就是说同一时间内联合体中其实只会有一个参数存在，当另一个参数被赋值时，此时内存中存的就是另一个参数的值，而前面的参数会被覆盖</p><p>但是size并不一定是根据最长的那个长度来决定的（实测不是，但是不懂），还要考虑内存对齐的问题</p><p>如果此时已经给某一变量赋上了值，再用另外一个变量输出，那么内存中的编码并不会改变，只是会按找相应类型的编码方式进行编码然后输出。</p><ul><li>在c++中的使用</li></ul><p>大致相同，但是union中不能有类，如果我们在再类CA中添加了构造函数，或者添加析构函数，我们就会发现程序就会出现错误。由于union里面的东西共享内存，所以不能定义静态、引用类型的变量。由于在union里也不允许存放带有构造函数、析构函数和复制构造函数等的类的对象，但是可以存放对应的类对象指针</p><ul><li>应用 类型转换</li></ul><p>因为union共用一片地址，所以我可以通过不同的定义去访问这片地址。例如一个double类型的数据，我可以用int型访问低四字节和高四字节，并且不改变位级别的数据，这就相当于类型转换</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>广义表</title>
      <link href="/post/14379.html"/>
      <url>/post/14379.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>广义表一般记作：LS=（a1,a2,…)</p><p>其中ai在线性表中只可以是单个元素，而在广义表中即可以是单个元素，也可以是广义表。如果是单个元素，叫做原子，如果是广义表，叫做子表。当广义表非空时，第一个元素叫做广义表的表头，其余所有元素叫做广义表的表尾。</p><p>例如： A（），空表</p><p>B（e) 只有一个原子元素e,长度为1</p><p>c（a,(b,c,d)) 长度是2</p><p>d( a ( d)) 递归表</p><ul><li>广义表的储存结构</li></ul><p>通常用链式存储结构</p><p>每个节点有tag域（标志域），hp，tp三个域，但是原子节点（就是表头节点）只有两个域，标志域和值域</p><p>定义：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRYSTAL"><figure class="iseeu highlight /crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">glnnode</span></span></span><br><span class="line">&#123;</span><br><span class="line">    int tag;<span class="regexp">//</span>表示是原子节点还是表结点</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        int atom;<span class="regexp">//</span>原子节点值域</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ptr</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            glnnode *hp,*tp;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>除了空表表头指针为空外，其他表表头指针必定指向一个表节点</p><p>同一层次的表可以从第一个节点通过尾节点依次往后数，而头结点则指向一个原子节点或者是一个子表。</p><p>例如，画出c表的表示</p><p>| | | 代表tag， 头结点，尾结点</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GHERKIN"><figure class="iseeu highlight /gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c-&gt; 1|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> -&gt; 1</span>|<span class="string"> </span>|<span class="string"> NULL</span></span><br><span class="line"><span class="string">    </span>|<span class="string">      </span>|<span class="string">  </span></span><br><span class="line"><span class="string">    -&gt;0</span>|<span class="string">a</span>|<span class="string">   -&gt;1</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt;1</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt;1</span>|<span class="string"> </span>|NULL</span><br><span class="line">             |<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">             -&gt;0|<span class="string">b</span>|<span class="string">  -&gt;0</span>|<span class="string">c</span>|<span class="string">  -&gt;0</span>|<span class="string">c</span>|</span><br></pre></td></tr></table></figure></div><p>这个代表的是 c=（a,(b,c,d))，可以看到，第一层节点的数目就是表的长度，第一层如果头结点接一个原子节点，那么在表中代表一个数，如果接一个表节点，代表一个子表，同理，第二层头节点如果是一个数，那么就代表第二层增加一个元素，如果头结点接一个表节点，那么说明还有一个子表</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编指令 AT&amp;T版 64位</title>
      <link href="/post/1326.html"/>
      <url>/post/1326.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>用g++ -Og -S -masm=intel name.c 可以生成intel格式的汇编代码，-S是生成汇编代码，-Og是省去不重要的部分，如果不加这个，可能5条指令要变成十多条指令</p><p>-fno-if-conversion 分支语句不要采用条件传输的方式，条件跳转的方式</p><p>-g debug</p><p>objdump -d 反汇编</p><p>gdb 调试 b+ 标号 设置断点 info register 查看寄存器 r 执行到断点出</p><p>n（next） 执行下一条命令</p><h4 id="mov-移动指令"><a href="#mov-移动指令" class="headerlink" title="mov 移动指令"></a>mov 移动指令</h4><p>格式： movq a,b</p><p>a是原操作数，b是目标操作数</p><p>这个指令中的q代表的是64位</p><table><thead><tr><th>长度</th><th>类型</th><th>别名</th><th>缩写</th></tr></thead><tbody><tr><td>1</td><td>char</td><td>byte</td><td>b</td></tr><tr><td>2</td><td>short</td><td>word</td><td>w</td></tr><tr><td>4</td><td>int</td><td>double word（long word）</td><td>l</td></tr><tr><td>8</td><td>long</td><td>quad word</td><td>q</td></tr><tr><td>8</td><td>char*</td><td>quad word</td><td>q</td></tr><tr><td>4</td><td>float</td><td>…</td><td>s</td></tr><tr><td>8</td><td>double</td><td>…</td><td>l</td></tr></tbody></table><table><thead><tr><th>源操作数</th><th>目标操作数</th></tr></thead><tbody><tr><td>立即数（idata)</td><td>寄存器 ，地址</td></tr><tr><td>寄存器</td><td>寄存器，地址</td></tr><tr><td>地址</td><td>寄存器</td></tr></tbody></table><table><thead><tr><th>操作数</th><th>符号</th></tr></thead><tbody><tr><td>立即数</td><td>$</td></tr><tr><td>寄存器</td><td>%</td></tr><tr><td>地址</td><td>（）</td></tr><tr><td>地址中数据</td><td>不加任何符号</td></tr></tbody></table><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PERL"><figure class="iseeu highlight /perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $2,%rax</span><br><span class="line">movq %rax,%rbx</span><br><span class="line">mov<span class="string">q (%rax)</span>,%rbx</span><br></pre></td></tr></table></figure></div><p>注意；</p><ul><li>当源操作数为地址的时候，目标操作数不能也是地址，因为一定要通过cpu进行调控，从地址到地址代表没有经过cpu（解释是这样，但我觉得不太合理）</li><li>立即数不能为8字节，使用 movabsq 可以让立即数为8字节</li><li>地址都是8字节，也就是上面的char*</li><li>如果把一个32位数给64位寄存器，那么高三十二位自动变成0.但是如果是16位或者8位的话高位不会改变</li></ul><p>例如：</p><p>movabsq $0x0011223344556677,%rax</p><p>movq $-1,%rax</p><p>%rax= 00000000ffffffff</p><h5 id="地址的写法"><a href="#地址的写法" class="headerlink" title="地址的写法"></a>地址的写法</h5><p>地址可以写为一个四元组 A（寄存器1，寄存器2，B）</p><p>这个四元组其实是 寄存器1+B*寄存器2+A</p><p>其中B可以是1,2,4,8。从数组的角度来看，寄存器1相当于起始地址，寄存器2相当于偏移地址，B是一个数据的字节数</p><p>同时 64位寄存器前缀是r，三十二位前缀是e，16位没有前缀，8位后面是l和h</p><p>例：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rax</span></span><br><span class="line"><span class="built_in">eax</span></span><br><span class="line"><span class="built_in">ax</span></span><br><span class="line"><span class="built_in">al</span></span><br><span class="line"><span class="number">ah</span></span><br></pre></td></tr></table></figure><h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>格式 movzab</p><p>a代表原格式，b代表现格式，一般是从小的转换成大的。而z代表多的位补0</p><p>例： movzlq</p><p>特殊形式： cltq 把32位寄存器扩展到64位并且赋值给自己，</p><p>movsab 有符号扩展，最高位为1那么扩展出来的位全是1。</p><h4 id="leaq-地址转移"><a href="#leaq-地址转移" class="headerlink" title="leaq 地址转移"></a>leaq 地址转移</h4><p>格式 leaq 地址，寄存器</p><p>看起来与mov没什么区别，但是mov中的地址是要取地址中的数，而这里的地址只是把对应地址给寄存器</p><p>例如： leaq (%rax,%rbx,4),%rdx 这条指令类似于把数组中某一元素的地址给了rdx</p><p>它还可用来求值</p><p>例如 要求x* 12</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PERL"><figure class="iseeu highlight /perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mul(<span class="keyword">int</span> <span class="keyword">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">   lea<span class="string">q (%rdi,%rdi,2)</span>,%rax</span><br><span class="line">   salq %rax,<span class="number">2</span>//左移指令</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">x</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码只要看中间两条指令就可以了，leaq 中的数运算之后是3rdi，然后左移两位就是12了。</p><p>但是这条指令不会判断溢出，且不会改变标志寄存器</p><h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><p>这里涉及到标志寄存器，<a href="https://xinhecuican.github.io/2020/01/29/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/">在前面一篇博客中已经提到</a></p><p>cmpq 比较指令</p><p>textq 与比较</p><p>textq b a 把a与b相与，不改变a和b的值，只会改变标志寄存器中的zf和sf。</p><p>这个指令通常用来判断某一位是否是1，例如 textq a,0x1 ，如果最低位为1，那么zf就是0，说明最低位是1</p><h5 id="标志寄存器的访问"><a href="#标志寄存器的访问" class="headerlink" title="标志寄存器的访问"></a>标志寄存器的访问</h5><table><thead><tr><th>操作名</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>sete</td><td>ZF</td><td>Equal</td></tr><tr><td>setne</td><td>~ZF</td><td>not equal</td></tr><tr><td>sets</td><td>SF</td><td>sign</td></tr><tr><td>setns</td><td>~SF</td><td></td></tr><tr><td>setg</td><td><del>(SF^OF)&amp;</del>ZF</td><td>greater 有符号数</td></tr><tr><td>setge</td><td>~(SF^OF)</td><td>大于等于</td></tr><tr><td>setl</td><td>(SF^OF)</td><td>less</td></tr><tr><td>setle</td><td>…</td><td>小于等于</td></tr><tr><td>seta</td><td><del>CF&amp;</del>ZF</td><td>above 无符号数</td></tr><tr><td>setb</td><td>CF</td><td>below 小于</td></tr></tbody></table><p>这些指令都是返回到8位寄存器上，将高七位置0，最低位依据含义所进行的运算来判断是0还是1</p><p>之后可以 movzbl %al,%eax，这时高三十二位也会被清零</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p><a href="https://xinhecuican.github.io/2020/01/31/%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%8C%87%E4%BB%A4/">前面博客中也已谈到过</a></p><p>这里再补充jg和gb等，其实就是上面同样的模式</p><p>此外，由于是64位系统，没有cs寄存器，且intel使用cisc指令集，所以会自动根据指令长度进行判断用多少位长来储存位移</p><p>此外 x86 64位系统中 还提供了一种 jmp *(%rax) 也就是把rax作为地址，取内存中的内容</p><h4 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h4><p>格式： cmov +后缀 a b，后缀格式就是前面set的格式</p><p>作用: 如果满足条件，则把a赋值给b，如果不满足，则不做处理</p><p>现代编译器在遇到分支语句时会尽量用条件跳转的格式执行，因为cpu采用了流水线作业的模式（就是一次提前搬运多条指令） 但是条件跳转指令会使流水线停止运行，而流水线可以明显增加cpu速度。</p><p>条件跳转的格式就是先把 if 和else的内容都计算出来，然后在最后用条件跳转指令进行比较。</p><p>例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SAS"><figure class="iseeu highlight /sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line"><span class="meta">if</span>(<span class="meta">x</span>&gt;y)</span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="meta">x</span>-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">else</span></span><br><span class="line">&#123;</span><br><span class="line">    a=y-<span class="meta">x</span>;</span><br><span class="line">&#125;</span><br><span class="line">汇编模式</span><br><span class="line">movq <span class="name">%rdi</span>,<span class="name">%rax</span></span><br><span class="line">subq <span class="name">%rsi</span>,<span class="name">%rax</span></span><br><span class="line">movq <span class="name">%rsi</span>,<span class="name">%rdx</span></span><br><span class="line">subq <span class="name">%rdi</span>,<span class="name">%rdx</span></span><br><span class="line">cmovle <span class="name">%rdx</span>,<span class="name">%rax</span></span><br></pre></td></tr></table></figure></div><p>可以看出，用条件跳转模式会多计算一些指令，不会破坏流水线，如果在流水线上减少的时间大于多进行指令所消耗的时间，那么用条件跳转指令比较合适。反之，直接用条件指令。</p><p>下列几种情况不适合用条件跳转指令</p><ol><li>分支语句计算量大（执行时间过多，划不来）</li><li>在要判断是否可以运算的情况，例如 var=p ？*p ： 0，这条语句意思是如果p不为空指针那么将p的内容赋给var，否则赋0.但是如果用条件跳转会出错，因为空指针不能取值</li><li>计算可能产生副作用（即前后两个分支之间会产生影响）。例如 var=x&gt;0 ? x*=3 : x+=6,这个分支前面对后面会产生影响，因此不能简单粗暴的直接条件跳转</li></ol><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ul><li>do-while循环</li></ul><p>do-while循环用goto语句表达成</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ADA"><figure class="iseeu highlight /ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br></pre></td></tr></table></figure></div><p>这段代码便是先执行，后比较。很容易就可以转化成汇编。goto可以用条件转移指令代替。</p><ul><li>while循环</li></ul><p>while循环有两种形式，第一种是在最开始进行一次跳转，如果符合则进入循环，不符合则退出</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ADA"><figure class="iseeu highlight /ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!x) <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></div><p>第二种是先跳过第一次循环直接进行判断。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SUBUNIT"><figure class="iseeu highlight /subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goto test;</span><br><span class="line">loop:</span><br><span class="line">statement;</span><br><span class="line">test:</span><br><span class="line">if(x) goto loop;</span><br></pre></td></tr></table></figure></div><p>由于cpu流水线的限制，两条连续的跳转指令会减慢cpu运行的速度，因此最好采用第一种办法（虽然代码多）</p><ul><li>for循环</li></ul><p>for(init; test; update)</p><p>可以转化成</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init<span class="comment">;</span></span><br><span class="line">while(test)</span><br><span class="line">&#123;</span><br><span class="line">  statement<span class="comment">;</span></span><br><span class="line">  update<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>再然后就可以变成汇编代码</p><h4 id="switch-汇编实现"><a href="#switch-汇编实现" class="headerlink" title="switch 汇编实现"></a>switch 汇编实现</h4><p>首先要了解条件语句和switch的区别，if语句要从上倒下一条一条判断，如果数量多的话时间开销大。而switch是根据标号直接跳转，无论要跳转到哪一个时间开销都一定。</p><p>内存中实际上在编译时已经设定了一个跳转表，这个跳转表的标号是一个固定的地址，不能被改变，这个标号内的数据就是每一条指令的跳转地址，而且是8字节。</p><p>因此跳转语句可以这样写: jmp .L4(,%rdi,8)</p><p>其中.L4代表的是跳转表的标号（不一定是这个名字，举个例子）而rdi就是switch中的x，</p><p>如果标号很大，例如10000甚至1000000开始的时候，如果把前面的查找表一个个全部设置出来，空间开销会很大，所以编译器会先自动的减去一个数使他处于较小的范围，但是这种情况只适用于数据密集的情况。</p><p>如果数据稀疏例如一个是1一个是10000，这个时候偏移也不行了，只有通过先排序再二分搜索来查找标号，这个复杂度是logn</p><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul><li>inc 自增</li><li>dec 自减</li><li>neg 取负 -x</li><li>not 取非 ~x</li><li>imul 乘</li><li>xor 异或</li><li>or 或</li><li>and 与</li><li>sal shl 左移</li><li>sar 算数右移</li><li>shr 逻辑右移</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AT&amp;T </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在不更改注册表的情况下把程序移出c盘</title>
      <link href="/post/44336.html"/>
      <url>/post/44336.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>这里用的类似于快捷方式。用mklink命令，这个命令可以将两个文件夹连接，一个是真实存放内容的文件夹，另一个只有名称，实际内容并不放在哪里。所以我们可以创建一个这样的文件夹来骗过程序。例如 office</p><p>首先要用cmd而不能用powershell，这是系统自带命令.然后在其他盘建一个同名的文件夹。注意c盘的文件夹不要创建，执行命令后系统自动创建。</p><p><code>mklink /J &quot;C:\Program Files (x86)\Microsoft Files&quot; &quot;D:\Program Files (x86)\Microsoft Files&quot;</code></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c语言的动态内存分配</title>
      <link href="/post/8039.html"/>
      <url>/post/8039.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>头文件： malloc.h</p><p>原型 void* malloc( size)（不标准写法）</p><p>其中size表示的是你想申请的字节数，为了准确我们一般使用sizeof函数，而返回的是一个void指针，这就导致了我们一般都要强制类型转换到对应的类型。</p><p>例： int* p=(int*)malloc(sizeof(int))</p><p>int* p=(int<em>)malloc(10</em>sizeof(int)) //数组</p><p>前面的int* 就是强制类型转换</p><p>此外，malloc一般分配完内存后还要进行检查看是否分配成功</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AWK"><figure class="iseeu highlight /awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p==NULL)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);<span class="regexp">//</span>退出程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>而且malloc是不会自动初始化的，所以在分配完内存后最好先用NULL初始化一下。</p><h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><p>字面意思，就是给一个已经分配内存的指针增加内存,原内存中的数据不变</p><p>头文件 #include &lt;stdlib.h&gt; 有些编译器需要#include &lt;alloc.h&gt;</p><p>原型： void* realloc(void *mem_address, unsigned int newsize);</p><p>mem_address是原指针，newsize是新的空间，可以大可以小</p><p>可能有下列几种情况</p><ol><li>如果原有空间后面还有足够的内存空间，那么直接在后面增加内存空间</li><li>如果原有空间不足，会重新分配空间到其他地方，同时原地址中的数据也会复制过去</li><li>如果没有可供分配的空间，返回NULL。此时，原指针仍然有效</li></ol><p>注意，如果分配成功，无论是否分到新空间，原指针都会被释放掉</p><p>如果 mem_address为0 那么和malloc相似，也是分配一块内存空间</p><p>如果 newsize为0，相当于free</p><p>也就是说，最好不要出现 p=realloc(p,size)这种写法，防止分配失败后指针直接丢失。好的办法是先用另一个参数接受realloc的内容，如果不为null，再让p=q</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* q;</span><br><span class="line">q=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(p,newsize);</span><br><span class="line"><span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>释放动态申请的内存空间</p><p>原型： void free(void* ptr)</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序的进入与退出</title>
      <link href="/post/27890.html"/>
      <url>/post/27890.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="程序进入"><a href="#程序进入" class="headerlink" title="程序进入"></a>程序进入</h3><p>在c++中，程序的入口是main函数，并且main函数有两个参数</p><p>int main(int argc,char* argv[])</p><p>argc是用来记录输入的参数的数量，而argv是用来记录输入的参数。</p><p>例如： ls -la，这个输入中有两个参数，第一个参数是ls，第二个参数是-la</p><h3 id="程序退出"><a href="#程序退出" class="headerlink" title="程序退出"></a>程序退出</h3><p>return 是退出当前函数，例如退出主函数或者退出任意函数</p><p>而 exit 是退出当前进程，也就是说就算是在调用的函数中，这个程序也会直接结束</p><p>exit(0)表示正常退出，exit(1)表示异常退出，更深入的内容涉及到进程。</p><p>exit函数在stdlib.h头文件中</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过滤器</title>
      <link href="/post/3257.html"/>
      <url>/post/3257.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中），但是在最前面的和在最后面的不一定是过滤器。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="cat-复制"><a href="#cat-复制" class="headerlink" title="cat 复制"></a>cat 复制</h4><p>cat的用途就是把标准输入中的数据复制到标准输出中</p><p>应用：可以与重定向结合。cat &gt; data，这样从键盘中输入的数据将直接传到data文件中</p><p>此外还可以让文件内容显示在控制台上，有 cat &lt; data，标准输入变成了data文件，标准输出是屏幕。为了方便，直接cat 文件名也是可以的</p><p>此外，tail也有类似的功能，但是它只能显示最后的十行</p><p>另外一个应用就是把一个文件复制到另一个文件。例如，cat &lt; data &gt; newdata</p><h5 id="增强cat功能"><a href="#增强cat功能" class="headerlink" title="增强cat功能"></a>增强cat功能</h5><p>cat &lt; file…= cat file …</p><p>有三个点说明了可以同时输入多个文件，这样就为组合多个文件提供了途径</p><p>cat data1 data2 data3 &gt;file</p><p>后缀：</p><pre><code>-n 在每行后面加一个行号-b 与-n一起使用，不要对空白行加行号-s 将多个连续的空白行变成一个空白行</code></pre><h4 id="split-分为不同文件"><a href="#split-分为不同文件" class="headerlink" title="split 分为不同文件"></a>split 分为不同文件</h4><p>语法 split [-d] [-a num] [-l lines] [file [prefix]]</p><p>作用： 将一个大文件分解成几个小文件。默认情况下，split将创建1000行长的空间</p><p>参数：</p><pre><code>-l 创建一个5000行的空间-d 将文件名改为从00开始编号-a 后面加数字，例如3表示从000开始，总共1000个文件名</code></pre><p>默认情况下，split创建的文件将以x开头，后面加aa，ab等</p><h4 id="tac-反转复制"><a href="#tac-反转复制" class="headerlink" title="tac 反转复制"></a>tac 反转复制</h4><p>相关过滤器： cat，rev</p><p>作用：和cat类似，但是在写入文件时把文件内容反转（tac是将cat反过来）。注意，这里的反过来并不是指从后往前倒着写，而是把行与行将顺序反过来。</p><h4 id="rev-反转字符顺序"><a href="#rev-反转字符顺序" class="headerlink" title="rev 反转字符顺序"></a>rev 反转字符顺序</h4><p>相关过滤器： cat tac</p><p>作用： 将各行字符顺序反转</p><p>语法： rev [file…]</p><p>例如： 有一个文件data，里面有</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345</span></span><br><span class="line">abcde</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure></div><p>之后用rev后会变成</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54321</span></span><br><span class="line">edcba</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure></div><p>rev也是直接输出到标准输出上的，也就是说并不会对源文件造成改变，如果想输出到文件中，还要重定向一下</p><h4 id="head，tail-从数据开头或者结尾读取"><a href="#head，tail-从数据开头或者结尾读取" class="headerlink" title="head，tail 从数据开头或者结尾读取"></a>head，tail 从数据开头或者结尾读取</h4><p>语法： head/tail [-n lines]，lines是希望选择的数据行</p><p>默认情况下，head和tail都只会选择十行数据，用-n可以选择任意行数</p><p>例： calculate | tail -n 15</p><h4 id="colrm-删除数据列"><a href="#colrm-删除数据列" class="headerlink" title="colrm 删除数据列"></a>colrm 删除数据列</h4><p>相关过滤器： cut paste</p><p>colrm（“column remove”)程序从标准输入中读取数据，删除指定数据列（也就是竖的删除），将剩余数据写入标准输出</p><p>语法： colrm [startcol [endcol]]，编号从1开始</p><p>例： colrm 14 30 &lt;students | less</p><h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><h4 id="cmp-比较两个任意文件"><a href="#cmp-比较两个任意文件" class="headerlink" title="cmp 比较两个任意文件"></a>cmp 比较两个任意文件</h4><p>相关过滤器：comm diff sdiff</p><p>语法: cmp file1 file2</p><p>cmp程序逐字节的比较文件，查看两个文件是否相同。如果两个文件相同，那么不做任何处理，如果不同，将会返回第一个不同的行和列</p><h4 id="comm-比较有序文件"><a href="#comm-比较有序文件" class="headerlink" title="comm 比较有序文件"></a>comm 比较有序文件</h4><p>语法：comm [-123] file1 file2</p><p>comm程序一行一行的比较两个有序的文本间，程序输出三列，第一列输出只包含在第一个文件中的行，第二列输出只包含在第二个文件中的行，第三列输出两个文件中都有的行。</p><p>因为comm是逐行比较，所以在比较之前最好使用sort进行排序</p><p>参数： -1 -2 -3 取消第一二三列的输出</p><h4 id="diff-比较无序文件"><a href="#diff-比较无序文件" class="headerlink" title="diff 比较无序文件"></a>diff 比较无序文件</h4><p>语法： diff [-bBiqswy] [-c| -Clines | -u | -Ulines] file1 file2</p><p>lines是说明上下文关系的行号</p><p>输出： diff的输出有三个不同的单字符指示： c（change） d（delete） a（append）。这三个字符说明了要想让两个文件相同需要做哪些改变。</p><p>这三个字符左右两边都会有数字，代表着需要修改的行号。例如，3c3代表把左边文件中的第三行变成右边文件中的第三行。</p><p>diff要求改变时，就会给出每一个文件的实际行，第一个文件中的行用小于号标记，第二个文件中的行用大于号标记。两组行之间还会有横线分隔开</p><p>例如，第一个文件为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br><span class="line">asdf</span><br><span class="line"><span class="keyword">as</span> df</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure></div><p>第二个文件为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EBNF"><figure class="iseeu highlight /ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>     </span><br><span class="line"><span class="attribute">abcd</span></span><br><span class="line"><span class="attribute">asdf</span></span><br><span class="line"><span class="attribute">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure></div><p>结果为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">0a1</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">a</span>     </span><br><span class="line"><span class="number">3</span><span class="string">,4c4</span></span><br><span class="line"><span class="string">&lt;</span> <span class="string">as</span> <span class="string">df</span></span><br><span class="line"><span class="string">&lt;</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure></div><p>a左边的数代表在左边数后面追加一行，例如0a1代表在第0行后面加上右边的第一行</p><p>d一般只需要管左边的数字，它的意思是删去左边的那一行</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-i 忽略大小写区别</span></span><br><span class="line"><span class="deletion">-w（whitespace) 忽略所有空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别，就是把多个空白符看成一个</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行，</span></span><br><span class="line"><span class="deletion">-q 当两个文本不同时，忽略所有细节，只说两文本不同</span></span><br><span class="line"><span class="deletion">-s 会明确告诉两个文本相同</span></span><br><span class="line"><span class="deletion">-c 全文比较，+代表要增加，-代表要减少，！代表要替换</span></span><br><span class="line"><span class="deletion">-u 与-c类似，但是把两个文件混合在一起显示，两个重复行只输出一个</span></span><br><span class="line"><span class="deletion">-y 把两个文件并排输出</span></span><br></pre></td></tr></table></figure></div><h4 id="sdiff"><a href="#sdiff" class="headerlink" title="sdiff"></a>sdiff</h4><p>语法： sdiff [-bBilsW] [-w columns] file1 file2</p><p>作用：与 diff -y 类似，并排比较<br>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-l 当两个文件有共同行时，只显示左边的列</span></span><br><span class="line"><span class="deletion">-s 不显示两个文件中任何相同的行</span></span><br><span class="line"><span class="deletion">-w+数字 改变列的宽度</span></span><br><span class="line"><span class="deletion">-i 忽略大写和小写的区别</span></span><br><span class="line"><span class="deletion">-W 忽略所有的空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行</span></span><br></pre></td></tr></table></figure></div><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p>例如： diff game1_ver1.0.c game2_ver2.0.c &gt; game2_ver2.1</p><p>这个命令会把第一个文件和第二个文佳之间的差保存下来，这样可以节省空间，此外在日后不慎丢失文件时也有办法快速找回</p><h4 id="cut-抽取数据列"><a href="#cut-抽取数据列" class="headerlink" title="cut 抽取数据列"></a>cut 抽取数据列</h4><p>相关过滤器： colrm join paste</p><p>语法： cut -c list [file…]</p><p>list就是要抽取的数据列，各个列之间用逗号隔开，不能有空格，或者14-19表示从14列到19列</p><p>作用：抽取指定的列</p><p>这种按列切分遇到长度不同的数据时就显得无能为力，因此还有另一种抽取方式，抽取字段，即按照一定的定界符进行分割（如逗号，空格等）</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SAS"><figure class="iseeu highlight /sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c  <span class="meta">list</span> [<span class="meta">file</span>...] <span class="meta">list</span>表明抽取第几个字段</span><br><span class="line">-f  <span class="meta">list</span> [-d <span class="meta">delimiter</span>] [-s] [<span class="meta">file</span>...]  -d后面是定界符种类 -s（suppress 抑制）抛弃没有定界符的行。例如 cut -f 1 -d <span class="string">':'</span> ./temp</span><br></pre></td></tr></table></figure></div><h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>语法： paste [-d char…] [file…]</p><p>其中char是用来做分隔符的字符，默认情况为一个制表符或者是空格</p><p>作用： 把几个文件组合成一个表格（组合数据列）</p><p>如果指定了不止一个定界符，那么将会轮流使用定界符</p><p>例如： paste -d ‘|%’ name phone ，这个指令中就有两个定界符</p><h3 id="统计和格式化"><a href="#统计和格式化" class="headerlink" title="统计和格式化"></a>统计和格式化</h3><h4 id="nl-创建行号"><a href="#nl-创建行号" class="headerlink" title="nl 创建行号"></a>nl 创建行号</h4><p>语法： nl [-v start] [-i increment] [-b a] [-n ln|rn|rz] [file…]</p><p>start是起始行号 ，increment是增量</p><p>作用：希望在一些数据中永久的插入行号，在输出中临时插入行号。一般状况下，插入的行号都是临时的，原始数据并不会发生改变，除非重定向输出到文件中。</p><p>默认情况下，不会对空行编号</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-v 改变起始编号，默认起始编号是1</span></span><br><span class="line"><span class="deletion">-i 改变增量，默认增量为1</span></span><br><span class="line"><span class="deletion">-b a 对所有行编号，包括空行</span></span><br><span class="line"><span class="deletion">-n ln 左对齐 rn 右对齐 rz 右对齐，有前导0</span></span><br></pre></td></tr></table></figure></div><h4 id="wc（word-count）统计行单词和字符的数量"><a href="#wc（word-count）统计行单词和字符的数量" class="headerlink" title="wc（word count）统计行单词和字符的数量"></a>wc（word count）统计行单词和字符的数量</h4><p>语法： wc [-clLw] [file…]</p><p>作用：统计行，单词，字符的数量。所统计的数据可以来自另一个程序或者是一个或多个文件</p><p>输出依次输出行，单词数，字符数 和文件名。如果不止一个文件，那么会为每一个文件显示一个输出，然后最后一行是一个总输出。</p><p>参数</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-l 统计行</span></span><br><span class="line"><span class="deletion">-w 统计单词</span></span><br><span class="line"><span class="deletion">-c 统计字符</span></span><br><span class="line"><span class="deletion">-L 该选项显示输入中最长行的长度</span></span><br></pre></td></tr></table></figure></div><p>此外，还可以用wc来统计某一目录中文件的数量，假设一个文件一行，用ls file | wc -l.</p><h4 id="制表符和空格"><a href="#制表符和空格" class="headerlink" title="制表符和空格"></a>制表符和空格</h4><p>在老式机器中，会在某些特定的为做一些机器标记，这些标记叫做制表位，如果按了制表位，那么机器会直接跳转到下一个制表位上，tab键与这个作用类似。一旦按了tab键，那么他将会自动跳转到下一个制表位。例如输入<code>A&lt;Tab&gt;BBBB&lt;Tab&gt;CCC</code>，实际上看起来中间有空格，实际上只有一个Tab</p><p>可视化制表符</p><p>第一种办法是在vi中，set list 那么制表符会转化成^I符号</p><h4 id="expand-将制表符转化成空格"><a href="#expand-将制表符转化成空格" class="headerlink" title="expand 将制表符转化成空格"></a>expand 将制表符转化成空格</h4><p>语法： expand [-i] [-t size] [-t list] [file…]</p><p>其中size是固定宽度制表符的大小（默认为8)，list是制表位列表</p><p>作用：expand将输入文件中所有的制表符转化成空格，别切维持与原文本相同的对齐方式</p><p>-i 只转换开头的制表符，其他的制表符保持不变</p><h4 id="unexpand-将空格转化成制表符"><a href="#unexpand-将空格转化成制表符" class="headerlink" title="unexpand 将空格转化成制表符"></a>unexpand 将空格转化成制表符</h4><p>语法： unexpand [-a] [-t size] [-t list] [file…]</p><p>其中size是制表符的大小（希望设置的），list是制表位列表</p><p>一般情况下，unexpand只转化第一行的空格，如果想要转换所有行的空格，那么需要-a选项</p><h4 id="fold-格式化行"><a href="#fold-格式化行" class="headerlink" title="fold 格式化行"></a>fold 格式化行</h4><p>相关过滤器： fmt ,pr</p><p>语法： fold [-s] [w witch] [file…]</p><p>其中witch是新行的宽度。</p><p>作用： 将长的行分割成短行。也就是把一行分成多行。其实就是在适当位置插入一个回车符</p><p>默认状态下，80个字符为一行。</p><p>-s选项是告诉程序不要分割单词，也就是说如果那个单词正好在要分割的位置，那么现在会先显示这个单词在转到下一行。</p><h4 id="fmt-格式化段落"><a href="#fmt-格式化段落" class="headerlink" title="fmt 格式化段落"></a>fmt 格式化段落</h4><p>语法： fmt [-su] [-w width] [file…]</p><p>作用：让各行连接在一起，并且不改变空白符。</p><p>当它读取文本时，假定段落由空行分隔。一个“段落”就是一个或多个连续的文本行，不包括空行。fmt根据下列规则读取一个段落</p><ul><li>行宽： 让每行尽可能的长，并且不超过指定的长度。默认情况下，每行最多75个字符</li><li>句子： 无论何时，尽可能在句子末尾分隔行。避免在句子的第一个单词之后或最后一个单词之前分隔行。</li><li>空白符： 保持单词及空行之间的所有缩进，空格。</li><li>制表符： 所有制表符转化成空格。并在最后输出时合适的位置插入制表符</li></ul><p>说起来复杂，其实就是让那些长短不一的段落尽量变得长。</p><p>例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SUBUNIT"><figure class="iseeu highlight /subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">As we all know,</span><br><span class="line"><span class="keyword">success </span>cones slowly and</span><br><span class="line">is due to a number of different factors all coming</span><br><span class="line">together</span><br><span class="line">over a period of years</span><br></pre></td></tr></table></figure></div><p>使用命令后</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">As</span> we <span class="keyword">all</span> know, <span class="type">real</span> success comes slowly <span class="keyword">and</span> <span class="keyword">is</span></span><br><span class="line">due <span class="keyword">to</span> a number <span class="keyword">of</span> different factors <span class="keyword">all</span> coming</span><br><span class="line">together <span class="keyword">over</span> a period <span class="keyword">of</span> years.</span><br></pre></td></tr></table></figure></div><p>此外，它是一段的作用，如果两行之间有个空行就把他们当成两段单独处理，互不影响</p><p>参数</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-u(uniform spacing 统一间距) 减少空格，每个单词之间最多只有一个空格，句子末尾最多只有两个空格。</span></span><br><span class="line"><span class="deletion">-w 设定宽度</span></span><br></pre></td></tr></table></figure></div><h4 id="pr-按页格式化文本"><a href="#pr-按页格式化文本" class="headerlink" title="pr 按页格式化文本"></a>pr 按页格式化文本</h4><p>语法： pr [-dt] [+beg[:end]] [-h text] [-l n] [-o margin] [-W width] [file…]</p><p>作用： 按页格式化文件，以便于打印。</p><p>其中 beg是需要格式化的第一页，end是最后一页，text是标题，n是每页的行数，margin是左边缘的大小，width是输出的宽度。</p><p>默认情况下，pr是通过顶端插入一个标题，左边插入一个边缘，底部插入一个页尾来格式化文件。标题包括修改时间，文件名称和页号。</p><p>如果想查看效果，最好在less程序中</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-d 双倍行距文本（word中的）</span></span><br><span class="line"><span class="addition">+begin;end 从那页到哪页格式化</span></span><br><span class="line"><span class="deletion">-l 改变每页总行数</span></span><br><span class="line"><span class="deletion">-o 设置左边缘</span></span><br><span class="line"><span class="deletion">-W 改变每一行的字符数（默认是72）</span></span><br></pre></td></tr></table></figure></div><p>还可以按列格式化文本</p><p>语法： pr [-mt] [-columns] [-l lines] [-W width] [file…]</p><p>column是输出列的数量，lines是每页的行数，width是每行的字符数。这个选项不建议用，会截断字符。</p><h3 id="选取，排序，组合，变换"><a href="#选取，排序，组合，变换" class="headerlink" title="选取，排序，组合，变换"></a>选取，排序，组合，变换</h3><h4 id="grep-选取特定模式的行"><a href="#grep-选取特定模式的行" class="headerlink" title="grep 选取特定模式的行"></a>grep 选取特定模式的行</h4><p>相关过滤器： look strings</p><p>语法： grep [-cilLnrsvwx] pattern [file…]</p><p>pattern是要搜索的格式</p><p>作用： 从标准输入或文件中读取数据，抽取所有包含特定模式的行，并写入标准输出。</p><p>这个模式可以是字符串标点符号等，但是如果是标号或者特殊字符时，最好用’’强引用，以防止歧义。</p><p>选项：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-c(count) 统计所抽取行的数量，但不显示行本身</span></span><br><span class="line"><span class="deletion">-i（ignore) 忽略大小写的区别</span></span><br><span class="line"><span class="deletion">-n 所选行在原文件中的位置</span></span><br><span class="line"><span class="deletion">-l（list），如果在不只一个文件中搜索，使用这个选项可以只把匹配的文件名列举出来，此时文件名也要输出多个</span></span><br><span class="line"><span class="deletion">-L 显示不包含该模式的文件名</span></span><br><span class="line"><span class="deletion">-v（reverse） 选取不包含模式的行</span></span><br><span class="line"><span class="deletion">-x 选取完全匹配的行</span></span><br><span class="line"><span class="deletion">-r（recursive递归） 搜索整个目录树</span></span><br></pre></td></tr></table></figure></div><h5 id="fgrep，egrep-grep变体"><a href="#fgrep，egrep-grep变体" class="headerlink" title="fgrep，egrep grep变体"></a>fgrep，egrep grep变体</h5><p>fgrep，历史上使用，现在基本不用</p><p>egrep grep扩展版本，功能比grep强大，可以通过 grep -E的方式<br>-w 只匹配完整的单词，并且最好配合-l使用。</p><h4 id="look-选取以特定模式开头的行"><a href="#look-选取以特定模式开头的行" class="headerlink" title="look 选取以特定模式开头的行"></a>look 选取以特定模式开头的行</h4><p>格式： look [-df] pattern file…</p><p>作用： 搜索以字母顺序排列的数据，并查找所有以特定模式开头的行。然后输出这些行</p><p>look其实并不是一个过滤器，它只能从文件中读入，因此只能写于管道线的开头</p><p>-d 忽略标点和其他字符，本来是指搜索第一个单词</p><p>-f（fold同等） 忽略大写和小写的区别</p><h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h4><p>格式 sort [-dfnru] [-o outfile] [infile…]</p><p>作用： 排序数据和查看数据是否已经有序。他可以比较整行，也可以从每行中选取一部分进行比较。</p><p>sort可以重定向输出到另一个文件，但是不能输出到输入文件</p><p>例如： sort temp &gt; temp 是不可以的</p><p>但是可以使用-o选项，此时该文件中原有数据将会被保存，排序后的数据也会被追加到这个文件中</p><h5 id="dfnr-控制数据排序的顺序"><a href="#dfnr-控制数据排序的顺序" class="headerlink" title="-dfnr 控制数据排序的顺序"></a>-dfnr 控制数据排序的顺序</h5><p>-d(dictionary) 只查看字母，数字和空白符，当确定有阻碍排序的因素（如标点符号等），可以使用这个选项。</p><p>-f（fold 等同）不区分大小写</p><p>-n（numeric 数字） 识别开头或者字段开头的数字，并按照数字进行排序</p><p>-r 反向排序</p><p>-u（unique 唯一） 对于相同行，只保留一行</p><h5 id="检测数据是否有序-c"><a href="#检测数据是否有序-c" class="headerlink" title="检测数据是否有序 -c"></a>检测数据是否有序 -c</h5><p>-c（check） 不会排列数据，只会告诉数据是否有序，如果有序，将不会显示任何内容</p><h4 id="uniq-查找重复的行"><a href="#uniq-查找重复的行" class="headerlink" title="uniq 查找重复的行"></a>uniq 查找重复的行</h4><p>语法： uniq [-cdu] [infile [outfile]</p><p>作用： 消除重复行，选取重复行，选取唯一行，统计重复行的数量。不加选项输出非重复行和只输出一次重复行</p><p>注意uniq的输入必须是有序的</p><p>-d 只查看重复行</p><p>-u 只查看非重复行</p><p>-c 统计重复行出现的次数</p><h4 id="join-合并两个文件的有序数据"><a href="#join-合并两个文件的有序数据" class="headerlink" title="join 合并两个文件的有序数据"></a>join 合并两个文件的有序数据</h4><p>相关过滤器： colrm cut paste</p><p>语法： join [-i] [-al|-vl] [-a2|-v2] [-l field1] [-2 field2] file1 file2</p><p>其中field是引用特定数段的数字</p><p>作用： 把两个文件中对应行合并到一起。但是这又和sort不同，sort是直接把两个文件拼接在一起，而join则是重复数据合并为一个输出。不重复数据直接输出。读取输入时，会忽略前导空白符。</p><p>不使用其他标号情况下，只会显示有匹配的连接字段（也就是两个文件对应行有相同字段），如果使用-a(all)选项，将会显示整个文件，后面要加a1或a2。a1代表把第一个文件中不匹配的内容也加上去。如果是v1，显示V1中不匹配的行</p><p>-1+sum 将第一个文件中的第sum个字段和第二个文件中的第一个字段进行匹配</p><h4 id="tsort-由偏序创建全序"><a href="#tsort-由偏序创建全序" class="headerlink" title="tsort 由偏序创建全序"></a>tsort 由偏序创建全序</h4><p>语法： tsort file</p><p>作用：将一系列的事一件一件从头到尾输出</p><p>例如：两个单词第二个单词代表在第一个单词后要做的事</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eat clean-<span class="keyword">dishes</span></span><br><span class="line"><span class="keyword">clean-dishes </span>watch-TV</span><br><span class="line"><span class="keyword">shop </span>cook</span><br><span class="line">cook eat</span><br></pre></td></tr></table></figure></div><p>在使用了tsort后，输出为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shop</span></span><br><span class="line"><span class="keyword">cook</span></span><br><span class="line"><span class="keyword">eat</span></span><br><span class="line"><span class="keyword">clean-dishes</span></span><br><span class="line"><span class="keyword">watch-TV</span></span><br></pre></td></tr></table></figure></div><h4 id="strings-在二进制文件中搜索字符串"><a href="#strings-在二进制文件中搜索字符串" class="headerlink" title="strings 在二进制文件中搜索字符串"></a>strings 在二进制文件中搜索字符串</h4><p>语法： strings [-length] file…</p><p>在现代软件中基本都有这种功能，不再展开</p><h4 id="转换字符-tr"><a href="#转换字符-tr" class="headerlink" title="转换字符 tr"></a>转换字符 tr</h4><p>语法： tr [-cds] [set1 [set2]]</p><p>set1是字符组</p><p>作用：可以将一个字符转化成另一个字符，例如将小写转化成大写，将制表符转化成空格，或者将0转化成x等。此外，还可以将多个字符变成一个字符，例如将多个空格转化成一个空格。最后，还可以删除指定字符，例如删除制表符。</p><p>例如： tr a A &lt; old tr a-z A-Z &lt; old</p><p>当需要替换的字符中出现由特殊意义的字符时，需要引用他们</p><p>还有几种特殊的缩写 [:lower:] 代表小写字母，[:upper:]代表大写字母，[:digit:]代表数字</p><p>tr还可以转换不可见字符</p><p>例如： tr ‘\n’ ‘\t’ &lt; old</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAML"><figure class="iseeu highlight /haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">s 多个字符变成一个字符 例如 tr -s <span class="string">' '</span> <span class="string">' '</span> &lt; old</span></span><br><span class="line"><span class="ruby">-d 删除指定字符</span></span><br><span class="line"><span class="ruby">-c 把没选上的字符变成另一个字符，例如 tr -c <span class="string">' \n'</span> x &lt; old，这个的意思就是除了空格和换行之外其他所有字符都变成x</span></span><br></pre></td></tr></table></figure></div><h4 id="sed-非交互式文本编辑"><a href="#sed-非交互式文本编辑" class="headerlink" title="sed 非交互式文本编辑"></a>sed 非交互式文本编辑</h4><p>交互式文本编辑就是有一个窗口，例如gedit vi等。而非交互式则需要提前设计命令，然后将命令发给程序。</p><p>语法： sed [-i] command | -e command… [file…]</p><p>command是sed命令</p><p>作用： sed是一个标准的过滤器，可以对标准输入或者标准输出进行修改</p><p>sed从输入流中每次读取一行。然后执行下面三个步骤</p><ol><li>从输入流中读取一行</li><li>执行指定的命令，对该行进行必要的修改</li><li>将该行写入输出流中</li></ol><p>因为是修改标准输入或者标准输出，所以源文件不会被修改，如果要修改原文件，可以加上-i(in-place)选项，这个选项会将输出保存到一个临时文件，一但所有数据处理完，sed就会把临时文件复制到原文件中</p><h5 id="使用sed进行替换"><a href="#使用sed进行替换" class="headerlink" title="使用sed进行替换"></a>使用sed进行替换</h5><p>想要用sed对标准输入或输出的内容进行修改，可以采用 s命令</p><p>形式： /address|pattern/ s /search/replacement/[g]</p><p>address 是输入流中一个行或者多个行的地址，pattern是一个字符串，search是正则表达式，replacement是一个替换文本</p><p>例如 sed s/harley/Harley,这个例子意思就是把每一行的第一个harley改成Harley，如果想把所有都改了，那么在后面要加上一个g</p><p>如果只对一些行进行操作，可以用下列语法：</p><p>number[,number] /regex/</p><p>number是行号</p><p>例如： sed ‘5s/harley/Harley/g’ names</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>加法溢出和乘法溢出</title>
      <link href="/post/41763.html"/>
      <url>/post/41763.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>无符号数加法便是两个数相加，如果超过最大值那么就截断超过的位数。截断超过的位数也就相当于mod2^n,因为这样做超过的位都会被模去变成0.</p><p>有符号数加法相对复杂。先是变成无符号数加法，加完 之后再按有符号数编码去理解，这样就会产生两种溢出，正溢出和负溢出。</p><p>首先，如果两个数一正一负，则不可能产生进位。</p><p>正溢出很好理解，最高一位为符号位，假如两个正数一加，超过了最大值，那么第2^w-1位就会变成1，这一位是符号位，因此这个数字便会变成负数。</p><p>如果是负溢出，因为两个数最高位一定为1，如果2^w-2位没有发生进位的话，那么就产生了溢出，此时最高位为0，变成正数</p><p>例如：10111111+10111111（-65）=01111110（126）</p><p>所以说如果是正数溢出，则需要-2^m,如果是负溢出，则需要加上2^m</p><p>判定是否发生溢出</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=a+b;</span><br><span class="line"><span class="keyword">if</span>((a&gt;<span class="number">0</span>==b&gt;<span class="number">0</span>)&amp;&amp;(a&lt;<span class="number">0</span>!=s&lt;<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"发生溢出"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"没有发生溢出"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>a&gt;0==b&gt;0的意义是判断a和b的符号是否相同,相同为真.a&lt;0!=s&lt;0的含义是判断a和s的符号是否<br>乘法溢出相对简单粗暴，直接把高位全部截断，也就是对2^w取模，有符号数乘法是先不管符号位直接把后面的位相乘，然后再把符号位补上。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 计算机系统基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重定向与管道</title>
      <link href="/post/22102.html"/>
      <url>/post/22102.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="标准输入-标准输出和标准错误"><a href="#标准输入-标准输出和标准错误" class="headerlink" title="标准输入 标准输出和标准错误"></a>标准输入 标准输出和标准错误</h3><p>基本思想：每个基于文本的程序都可以从任何源接受输入，并向任何目标输出</p><p>标准输入指的是一种读取数据的通用办法，标准输出有两种，一种是标准输出，另一种是标准错误</p><p>而输入输出其实正常情况下有shell决定。为了保证程序的输出，需要告诉shell将输出目标设置成文件。</p><h3 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h3><p>在登陆时，shell会自动将标准输入设置成键盘，将标准输出和标准错误设置成屏幕。</p><p>但是每次输入命令时，可以告诉shell在此命令执行期间更换输入输出对象。</p><p>如果想把一个命令输出送到一个文件中，例如sort命令 可以写成 sort &gt; names</p><p>以这种命令输出时，如果文件不存在，shell会自动创建这个文件。如果文件存在，那他将会把文件内容全部清空然后再把内容输入到里面去</p><p>如果我们只想追加内容到这个文件中，可以用 &gt;&gt; 。如果文件不存在，这个命令也会创建新文件，如果存在，那么会追加内容到后面。</p><p>如果取消清空文件重新输入的选项，可以设置nonclobber选项。但是设置完之后，如果确实想替换掉这个文件，可以临时忽略掉noclobber，这时需要用<code>&gt;|</code>替换 &gt;</p><h4 id="重定向标准输入"><a href="#重定向标准输入" class="headerlink" title="重定向标准输入"></a>重定向标准输入</h4><p>符号： &lt;</p><p>左边是你要运行的程序，右边是你有读入数据的文件</p><p>例如 sort &lt; /etc/passwd</p><p>标准输入和标准输出可以同时指定</p><p>例如 sort &lt; rawdata &gt; report，这个命令会把rawdata中的数据给sort处理，然后把结果给report文件</p><h4 id="重定向标准错误"><a href="#重定向标准错误" class="headerlink" title="重定向标准错误"></a>重定向标准错误</h4><p>shell提供两种输出目标，标准输出和标准错误。正常情况下，两种输出同时显示在屏幕上，在需要时，可以把两种输出分隔开。</p><p>首先对unix处理I/O过程了解。每个输入源和每个输出目标都有一个唯一的数字标识，，这个数字 称为文件描述符。例如一个进程可能从#8中读取数据，并将文件写入#6中</p><p>例如为了将输出写入到文件8中，可以sort 8&gt; results，results就是第8个文件</p><p>默认情况下，Unix为每个进程提供三个预定义的文件描述符。而且大多数时候都可以使用。0代表标准输入，1代表标准输出，3代表标准错误。</p><p>所以要想重定向输入，可以用 0&lt;</p><p>而要想重定向标准输出，可以用 1&gt; ,这样错误信息就会留在屏幕上便于我们查看，而输出信息在文件中。如果想让标准错误在文件中，可以 2&gt;</p><p>此外，平常写的 &gt; 实际上代表的是 1&gt;</p><h4 id="子shell"><a href="#子shell" class="headerlink" title="子shell"></a>子shell</h4><p>进程就是加载到内存中准备运行的程序，当进程需要启动另一个进程的时候，这个进程创建了一个副本进程，原始跌进程叫做父进程，而这个进程叫做子进程。</p><p>而子进程一旦结束，优惠唤醒父进程继续执行命令，此时子进程消失。</p><p>子shell指的是在父shell中重新开一个shell，这样在子shell中造成的改变不会影响父shell，甚至是环境变量也一样，除非把它写入初始化文件中，不然这个全局变量也会随着子shell进程的结束而消亡。</p><p>如果有时你想在子shell中执行一条指令，又不想启动一个全新的shell，那么一个办法就是在外面加上小括号(),例如 （date）</p><h4 id="组合标准重定向输出和错误"><a href="#组合标准重定向输出和错误" class="headerlink" title="组合标准重定向输出和错误"></a>组合标准重定向输出和错误</h4><p>在bash中，基本思想是建议将一种类型的输出重定向到一个文件，然后再追加</p><p>command x&gt; outputfile y&gt;&amp;x</p><blockquote><p>&amp; 符号的意思是替代</p></blockquote><p>y&gt;&amp; x的意思是把2的输出发送给1相同的位置。</p><p>例： sort 2&gt;&amp;1 &gt;output 这个意思是把2的输出发送到与一相同的位置，而一是发送到屏幕的，于是2也发送到屏幕了</p><h4 id="抛弃输出"><a href="#抛弃输出" class="headerlink" title="抛弃输出"></a>抛弃输出</h4><p>为什么要抛弃输出呢？</p><p>有时候，需要运行一个程序。因为可能你并不关心这个文件的输出。有时候，可能希望查看文件正常输出，而不关心错误信息。</p><p>那么这个时候只需要重定向输出到 /etc/null即可。这个文件的特殊之处在于发送给他的任何东西都会消失。所以 它有个奇怪的名字叫做 位桶(bit bucket)</p><h3 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h3><p>管道线的作用就是让各个程序组合发挥作用</p><p>shell允许创建一系列的命令，在这一系列的命令中，一个命令的标准输出可以发送给下一个程序的标准输入。当这样做时，两个程序之间的连接就是管道，而命令序列本身叫做管道线。</p><p>在创建管道线时，只需将希望键入的命令用竖线| （管道符号） 分隔开即可</p><p>能从标准输入读取文本，并向标准输出写入文本的程序，称为过滤器。</p><h4 id="管道线分流-tee"><a href="#管道线分流-tee" class="headerlink" title="管道线分流 tee"></a>管道线分流 tee</h4><p>有时候，可能希望把程序的输出发送到两个地方</p><p>语法： tee [-a] file…</p><p>file就是希望将数据发送到的文件的名称</p><p>例：cat name1 name2 | tee masterlist | grep Harley</p><p>这个指令中的tee 会将输出保存到masterlist中并且将cat的输出给grep</p><p>同样，如果这个文件存在，那么tee将会重写这个文件。如果想要追加内容，那么可以tee -a(append)</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初始化文件</title>
      <link href="/post/8274.html"/>
      <url>/post/8274.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>有两个初始化文件，第一个文件是在启动时执行的，叫做登录文件（login file).第二个文件是在启动shell时执行的，叫做环境文件(environment file)。<br>有的shell还有注销文件，注销文件指的是在shell关闭时执行的文件</p><p>bash shell中登录文件文件名（.Bash_profile .bash_login)，环境文件（.bashrc),注销文件（.bash_logout)</p><p>这些文件名都是以点开头，点文件的别名是隐藏文件，意义是除非你用ls指令去查看，通常状况你无法看到这个文件</p><p>登录shell指的是登录时默认启动的shell，非登录shel则需要在登录shell中执行命令才可以启动</p><p>登录shell执行登录文件和环境文件，非登录shell只执行环境文件</p><h4 id="初始化文件中放什么内容"><a href="#初始化文件中放什么内容" class="headerlink" title="初始化文件中放什么内容"></a>初始化文件中放什么内容</h4><p>登录文件有两项任务，设置环境和初始化工作对话（不知道什么意思）</p><p>所以登录文件有两项任务</p><ol><li>创建或修改环境变量的命令（PATH,PAGER等）</li><li>执行所有一次性操作的命令</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>宏定义</title>
      <link href="/post/39968.html"/>
      <url>/post/39968.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>宏定义就是在开始用井号（#）定义一个函数或者是常量，这种定义在编译器中被处理，运算速度快，但使用宏定义时可能会出现一些隐蔽的问题</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="FORTRAN"><figure class="iseeu highlight /fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="keyword">DATA</span> sizeof(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">for(<span class="built_in">int</span> i=cnt;i-<span class="keyword">DATA</span>&gt;=<span class="number">0</span>;i-=<span class="keyword">DATA</span>)</span><br></pre></td></tr></table></figure></div><p>乍一看这样做似乎没什么问题，要注意sizeof返回的是一个无符号数，有符号数和无符号数做比较的时候会先把有符号数变成无符号数。而负数的有符号数最高位一定为1，这样就可能会导致数据异常。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>delete的一个注意事项</title>
      <link href="/post/58313.html"/>
      <url>/post/58313.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>实际上delete后的指针并不会变成空指针，仍指向堆里的地址。但是这个时候这块空间已经可以被其他的new申请了，如果你没有把原指针更改的话，有可能对原指针进行的修改会影响到新指针。因此每次delete完之后最好把这个指针变成空指针</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算和移位运算</title>
      <link href="/post/61738.html"/>
      <url>/post/61738.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h3><p>这里的与运算并不是平常的bool运算，而是按位与。这种运算比加减法快</p><p>符号： &amp;</p><p>例： 1010&amp;1000=1000 1001&amp;0110=0000</p><p>含义： 1&amp;1=1,1&amp;0=0,0&amp;1=0,0&amp;0=0，只要不是两个都是,1，那么结果就是0</p><p>应用：</p><ul><li>替换指定位的值</li></ul><p>一个典型应用就是大小写转换，如果平常转换我们可能要写一大堆，但是经过仔细观察后发现大写字母和小写字母之间差距只有第5位，如果第五位为0，就是大写字母，为1就是小写字母，所以只要<code>a&amp;0b11011111</code>这一段代码就可以完成小写到大写的转换</p><ul><li>清零</li></ul><p>通过 a&amp;0b00000000 ,可以快速的把某个数变成零</p><ul><li>消去最后一位 1</li></ul><p>x &amp; (x-1) 例如 x 1010 x-1 1001 ，计算之后1000。减1就是让最小的那个1变成0然后后面全是1</p><ul><li>找到最小一位1</li></ul><p>x &amp; (-x) 在lowbit函数中用到， -x=~（x-1），大于最小一位1的都由于取反变成0，然后最小一位1及其后面本来是0111…,取反变成1000…，而原来是100…，所以最终是00…0100…</p><h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h3><p>符号： |</p><p>例： 1010|1000=1010 1001|0110=1111</p><p>含义： 1|1=1,1|0=1，0|1=1，0|0=0</p><p>应用：</p><ul><li>设定某一个数据位为1，例如想把第五位设为1，只要 a|0b00100000</li></ul><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>符号： ^</p><p>例： 1010^1000=0010, 1001^0110=1111</p><p>含义： 1^1=0,1^0=1,0^1=1,0^0=0，同为假，异为真</p><p>应用：</p><ul><li><p>x^11111…=~x;</p></li><li><p>异或满足交换率，结合率</p></li><li><p>x^x=0,x^0=x,自己是自己的逆元，0是幺元</p></li><li><p>a^b^a=b,因此可以用这种性质做许多应用，一个应用就是交换两个变量的值</p></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*&amp; a,<span class="keyword">int</span>*&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a=*a ^ *b;  <span class="comment">//a=a^b</span></span><br><span class="line">    *b=*a ^ *b; <span class="comment">//b=a^b^b=a</span></span><br><span class="line">    *a=*a ^ *b; <span class="comment">//a=a^b^a=b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另外还可以用来检查重复数或者在其余都是偶数个重复数字中找到一个奇数</p><p>例：1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现<br>一次。每个数组元素只能访问一次</p><p>将所有的数全部异或，得到的结果与1^2^3^…^1000的结果进行异或，得到的结果就是重复数。</p><h3 id="按位非"><a href="#按位非" class="headerlink" title="按位非"></a>按位非</h3><p>符号： ~</p><p>例： ~1001=0110， ~1010=0101</p><p>含义： <del>1=0，</del>0=1 ,取反</p><p>应用：</p><ul><li><p>对于有符号数 <del>a=-(a+1),因为一般采用补码，而补码的负数就是正数-1再取反得到，所以</del>(a-1)=-a，可得~a=-(a+1)</p></li><li><p>把最低位变成0，a&amp;~1</p><h3 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h3></li></ul><p>符号： &lt;&lt;</p><p>例 00001010&lt;&lt;1 =&gt; 00010100</p><p>含义： 把所有的位向左移位，高位删去，低位补零，相当于乘上2的n次方</p><p>注意：如果移动次数超过了最高位，那么这是一个未定义行为。所以不同编译器，不同cpu对其有不同解释。gcc会将其自动变成0，而微软的编译器会先将移动位数模上最大位数然后再左移相应位数。cpu中也是取模的方式。</p><p>例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;</span><br><span class="line">b=a&lt;&lt;<span class="number">40</span>;<span class="comment">//此时b=0，因为这个命令是在编译器中完成的</span></span><br><span class="line">a&lt;&lt;=<span class="number">40</span>;<span class="comment">//此时a！=0，因为这个命令是在cpu中完成的</span></span><br></pre></td></tr></table></figure></div><h3 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h3><p>符号： &gt;&gt;</p><p>含义 将所有位向右移位，高位视情况而定，低位舍弃</p><p>视情况而定是因为实际上有两种右移，第一种是逻辑右移，第二种是算术右移</p><ul><li>逻辑右移，高位直接取0</li><li>算术右移，高位要看情况，如果原来最高位是0，则取0。如果最高位是1，则后面加的都是1.</li></ul><p><strong>逻辑右移的符号： &gt;&gt;&gt;</strong>(java)</p><p>那什么时候用逻辑右移还是算术右移呢？一般来说，有符号数算术右移，无符号数逻辑右移。因为有符号数用的是补码，如果是负数右移最高位补1才能让这个数还是负数</p><p>应用：</p><ul><li>不用-号把1变成-1<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;</span><br><span class="line">a&gt;&gt;=<span class="number">31</span>;<span class="comment">//最高位为1，其余都为0</span></span><br><span class="line">a&lt;&lt;=<span class="number">31</span>;<span class="comment">//都为1</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="右移运算对整数的影响"><a href="#右移运算对整数的影响" class="headerlink" title="右移运算对整数的影响"></a>右移运算对整数的影响</h4><p>右移运算相当于除2，之后低位相当于小数点后面的数字。这时我们把它截断相当于取整，对于无符号数和有符号数中的非负数，这个取整是没什么影响的，但对于有符号数中的负数，取整却与除法取整有所偏差。</p><p>除法取整是趋向于零。也就是说，非负数向下取整，负数向上取整。而右移确是把小数后面的数全部舍弃，就相当于让这个数更小了。</p><p>例如： 假如右移后是 -1234.32423，结果是-1235.因为把小数点舍弃会使这个数更小。</p><p>有一种情况除外。就是右移产生的小数点位中全是0，这时舍弃它并不会产生影响，所以不会发生向下取整。</p><p>为了解决这个问题，一种办法就是 <code>(x+2^k-1)&gt;&gt;k</code>，为了加快速度，可以写成<code>(x+1&lt;&lt;k-1)&gt;&gt;k</code></p><p>现在来看这个式子的正确性，当最后几位全为0时，例如1000000右移三位，那么2^3-1=0b111,因为本来这个结果就是正确答案，现在加上111并没有改变它的值，0b1111000.111后面三位舍弃与原来相同，因此这个时候结论正确</p><p>如果后面不是全为0，那么这时必定产生进位，例如1101右移三位那么加上之后必定会使第四位进一位，这时我们再右移三位，便相当于让原来的答案加一，达到了向上取整的效果</p><p>最后，只有在有符号数中的负数中才要采用这种算法，在非负数中直接右移即可</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c++输出16进制，10进制和2进制</title>
      <link href="/post/8372.html"/>
      <url>/post/8372.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>hex是输出16进制，例如<br><code>cout&lt;&lt;hex&lt;&lt;18&lt;&lt;endl;</code></p><p>dec十进制</p><p>另外这两种用了之后后面输出一直是这种进制，如果用了hex之后想要用十进制要写dec</p><p>二进制bitset</p><p>bitset有头文件 <code>&lt;bitset&gt;</code></p><p>使用方法 bitset&lt;8&gt;(数字），其中8的含义是要输处几位二进制数，所以如果用int型是32，如果想把字符型转换就直接写8</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell内部命令与外部命令与搜索路径</title>
      <link href="/post/18431.html"/>
      <url>/post/18431.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>有些命令是shell外部的，shell会解析参数然后调用外部的程序去处理它，另外还有一些是对shell起作用的，叫shell内置命令</p><p>如果先查看内部命令，需要 man + shell名称 ，例如，man bash</p><h3 id="外部命令和搜索路径"><a href="#外部命令和搜索路径" class="headerlink" title="外部命令和搜索路径"></a>外部命令和搜索路径</h3><p>shell是如何知道那些程序都在哪呢？ 实际上shell是检查PATH环境变量，PATH包含一串字符，这串字符就是一系列目录名称，称作搜索路径。如果输入一个命令，shell会依次按这些目录去搜索命令</p><p>先要看PATH 直接 echo $PATH即可</p><h3 id="修改搜索路径"><a href="#修改搜索路径" class="headerlink" title="修改搜索路径"></a>修改搜索路径</h3><p>可以用export命令，export命令可以使PATH变量变成环境变量，这就意味着shell和随后所有进程都可以使用它，例如<code>export PATH=&quot;/bin:/usr/bin:/usr/ucb:/usr/local/bin&quot;</code></p><p>如果希望在搜索路径的末尾加上一条路径，可以 <code>export PATH=&quot;$PATH:$HOME/bin&quot;</code><br>如果想在最后加上一条指令，可以<code>export PATH=&quot;$HOME/bin:$PATH&quot;</code></p><p>如果把自己写的date命令放在开头，系统将会执行自己写的date命令，而不会执行系统本身的命令</p><p>实际上用export设置的环境变量在下次启动时就会失效，如果想一直保存需要修改一些特定的文件</p><h3 id="修改命令行提示"><a href="#修改命令行提示" class="headerlink" title="修改命令行提示"></a>修改命令行提示</h3><p>命令行提示的路径在PS1的环境变量当中,因此要修改的话只需要export PS1=”$ “就可以了</p><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>用反引号<code></code> `,用了这种符号会先执行反引号你饿不的命令然后再执行外部命令，</p><p>例如 <code>echo &quot;Date is</code>date` “</p><p>这个命令会显示Date is + 具体时间，注意要用双引号，单引号会把反引号引用掉</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>元字符的使用</title>
      <link href="/post/38072.html"/>
      <url>/post/38072.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>元字符指的是Linux中有特殊含义的字符，例如 ； 换行符等。</p><h3 id="字符引用和转义"><a href="#字符引用和转义" class="headerlink" title="字符引用和转义"></a>字符引用和转义</h3><p>如果不想用元字符内在含义，只想打出这个字符，那么就需要用到引用字符。</p><p>字符引用的方法有三种，使用反斜线，使用一对单引号或者使用一对双引号</p><p>例如 echo a ; b 这样就会把他们当成不同的指令，但是如果 echo a; b,这样就会当成同一个指令，实际上\是转义字符，转义字符指的是把一个字符从一中状态转移到另一种状态</p><p>单引号会将一切字符引用，这样有时例如我需要引用其中一个变量的值的时候就会出现问题</p><p>这时我们就可以用到双引号，双引号不会引用 $ , \ , `(反引号），</p><p>引用能力强弱 ，&gt;‘’&gt;””</p><p>如果输入换行字符，单引号并不会转义它，但是\会转义它</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="/post/52078.html"/>
      <url>/post/52078.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>顺序表就是将元素放入一个连续的内存空间里，它的优点是可以快速访问，缺点是插入和删除操作时间复杂度高</p><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> datasize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>* p;<span class="comment">//存储空间的基址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//现在有的元素数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(node&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.p=<span class="keyword">new</span> <span class="keyword">int</span>[datasize];</span><br><span class="line">    <span class="keyword">if</span>(a.p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"储存分配失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> [] a.p;</span><br><span class="line">    &#125;</span><br><span class="line">    a.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>初始化有两点要注意的地方，第一点是用了传引用，第二点是动态分配内存，这就表示如果使用完了要delete</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">find</span>(node&amp; a,int x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;a.<span class="built_in">length</span>;<span class="built_in">i</span>++)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(a.p[<span class="built_in">i</span>]==x)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">i</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入操作是把一个数插入第i位，其他位顺序后移</p><p>如果插入某一位概率相同，那么在第0位插入需要移动n个数，第一位插入需要移动n-1个数……在第n位插入需要移动0个数，总共有n-1中可能，总共需要移动的次数为n(n+1)/2,所以平均需要移动次数为n/2</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int insert(node&amp; a,int x,int <span class="built_in">i</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">i</span>&lt;<span class="number">0</span>||<span class="built_in">i</span>&gt;a.<span class="built_in">length</span>||a.<span class="built_in">length</span>==datasize)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">j</span>=a.<span class="built_in">length</span>;<span class="built_in">j</span>&gt;<span class="built_in">i</span>;<span class="built_in">j</span>--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="built_in">j</span>]=a[<span class="built_in">j</span><span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="built_in">i</span>]=x;</span><br><span class="line">    a.<span class="built_in">length</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>与上面操作类似，这里需要前移，并且平均操作次数为(n-1)/2</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> Delete(node&amp; a,<span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i;k&lt;a.length<span class="number">-1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.p[k]=a.p[k+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a.length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux指令学习</title>
      <link href="/post/26477.html"/>
      <url>/post/26477.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h5 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h5><p>一次输入多条命令，可以在命令之间用 <code>;</code>分割开来</p><p>语法： 命令名称 选项 参数</p><p><strong>选项</strong>有时被称为开关（switches）或标志（flags），选项通常是由一个连字符后面接着一些字母，或者两个连字符后接着一个单词构成。例如 –help，–version（显示版本信息）</p><p>使用多个单字符选项时，可以把他们连接在一起，用一个连字符来表示。例如 ls -lF<br>。注意，unix的选项区分大小写</p><p>实际上许多长参数有着对应的短参数，但是长参数是一个完整的单词，为了便于记忆，有时也是用长参数，这时就要用两个连字符</p><p>输入命令时，必须要把每个选项和参数用空格分隔开</p><p>有些命令有默认值，有些命令没有默认值，例如 ls 如果只输入ls的话他会返回当前工作目录下所有文件</p><p>手册中提示的语法</p><ol><li>方括号中的项是可选的</li><li>不再方括号中的项是必选项</li><li>黑体字必须原样输入</li><li>斜体字可以用适当的值代替</li><li>有省略号代表可以重复多次</li><li>如果一个单独的选项和参数组合在一起，这二者必须同时出现</li><li>由竖线（|）字符分开的两个或者多个项，宝石可以从这个列表中选择任意一项</li></ol><h5 id="用户提醒命令"><a href="#用户提醒命令" class="headerlink" title="用户提醒命令"></a>用户提醒命令</h5><ul><li>who 用来显示用这个计算机的用户</li><li>whoami 用来显示当前用户标识</li><li>quota 用来看自己拥有多少空间</li><li>lock 临时上锁 lock -5 锁5分钟</li><li>leave leave +15 十五分钟后离开 leave 1344 13点44分离开，到了时间它会不停的提醒你，相当于一个闹钟</li><li>id 用来显示你的基本信息</li><li>date 时间 date -u 协调世界时间（UTC时间）</li><li>cal 显示日历 cal+某一年份可以显示某一年份的日历 cal 7 2019 显示2019年7月的日历 cal -j +… 会显示第几天，所以想要知道这一年是不是闰年只需 cal -j 12 + 年份，看看12月最后一天是不是366天就可以了</li><li>su（substitute user） 这个指令是用来切换用户的，如果你知道一个用户的口令，那么就可以采用su+用户名的方式切换，这个时候用户标识改变了，但是你仍位于旧的环境之中。就像你让别人来你家做事，如果你想让别人在自己家做事，就要用su+’-‘+用户名</li></ul><p>特别的，如果你想拥有root权限，你需要 su - root ，这时你输入的是你自己的口令而不是root口令，因为在计算机中有特殊的配置文件，这个文件只有管理员能操作，他可以修改那些人可以通过su口令获得root权限</p><ul><li>man 联机文档帮助 当你查看联机文档时，可以用/符加上你想搜索的内容进行搜索，用n来显示下一个，用N来显示上一个。？符是向下搜索。<br>如果想在查看man文档时执行指令，只需输入！在输入命令，之后按enter键又能回到man文档中</li><li>foo bar 可以指代任意标识<br>man文档显示的内容</li></ul><ol><li>命令</li><li>系统调用</li><li>库函数</li><li>特殊文件</li><li>文件格式</li><li>游戏</li><li>杂项</li><li>系统管理</li></ol><ul><li><p>whatis 显示说明书页的第一行（名字和用途）例如 whatis time date，这样同时显示两条指令的信息。这种指令可以用 man -f 替换</p></li><li><p>apropos 搜索命令 他将显示所有带有该字符的命令。这种命令可以用man -k代替</p></li><li><p>info 另一种搜索命令，这种命令的特点是它有到其他命令的连接，就好像网页一样。这时一种树形结构，n跳转到下一个节点，p跳转到上一个节点，t跳转到当前文件的顶节点</p><h5 id="登入登出命令"><a href="#登入登出命令" class="headerlink" title="登入登出命令"></a>登入登出命令</h5></li><li><p>exit 退出当前用户，例如想从root模式退出用exit</p></li><li><p>sudo 以超级用户模式运行一条指令。如果你经常使用超级用户，可能在无意间删去一些重要文件导致系统出现故障，因此超级用户需慎用。因此要用可以用sudo命令。</p></li><li><p>less 浏览配置文件。例如我想浏览passwd文件，只需 less /etc/passwd</p></li></ul><p>配置文件就像windows系统下的注册表和ini文件</p><ul><li>dmesg 显示启动信息，但是这种显示太快，看不清</li><li>dmesg | less 显示启动信息</li><li>init 设置运行级别，1为单用户，2为多用户，等等，0是关机，6是重启</li></ul><p>如果想重启，可以用 sudo init 6</p><ul><li>reboot 重启 sudo reboot</li><li>shutdown 关机，这个要说关机时间，经常用的是sudo shutdown now</li></ul><h5 id="快捷键和便捷输入命令"><a href="#快捷键和便捷输入命令" class="headerlink" title="快捷键和便捷输入命令"></a>快捷键和便捷输入命令</h5><ul><li>erase 删除最好一个键入的字符，Ctrl+H</li><li>werase 删除最后一个单词 Ctrl+W</li><li>kill 删除一行 Ctrl+U</li><li>intr 停止程序 有些系统是Ctrl+C，有些是delete</li><li>quit 停止程序 Ctrl+\ 它不仅会停止程序，还会生成一个副本保存在core的文件中</li><li>stop 停止屏幕显示，Ctrl+S</li><li>start 开始屏幕显示 Ctrl+Q</li><li>eof 文件终止信号 Ctrl+D<br>可以通过Ctrl+D终止shell，但是有时候会不小心按到。为了让shell忽略eof，需要使用一个叫IGNOREEOF的环境变量，这个变量表示注销前BASH会忽略多少次eof，设置这个变量时，要 IGNOREEOF = 数字</li><li>stty -a 显示键盘映射，这个命令是表示各个快捷方式如erase的快捷键。stty是set terminal(设置终端）-a表示显示所有设置</li><li>stty 修改键映射。例如想修改kill命令 ，可以 stty kill Ctrl a</li><li>返回字符 ^M，指的是返回到这一行的开头</li><li>换行字符 ^J<br>文件每一行最后一定是一个返回加换行</li><li>stty sane，reset 候终端的设置被弄乱，可以采用这个命令是终端恢复到初始值</li><li>up 向上键，会转到上一条指令</li><li>down 转到下一条指令</li><li>fc 查看历史命令列表，用fc -l来查看，前面都有一个编号。如果想转到某一条指令，可以 fc -s(substitute) 编号。如果后面不接编号，则默认为上一条指令。但是用fc -s会立刻执行这条指令</li></ul><p>可以对这条命令进行小范围修改，格式为 fc -s pattern=replacement number<br>。pattern和replacement 都是字符串，而number是要修改时间的编号</p><ul><li>tab 自动补全命令，按一下如果有歧义，会发出提示声<h5 id="立即使用的程序"><a href="#立即使用的程序" class="headerlink" title="立即使用的程序"></a>立即使用的程序</h5></li><li>gedit 文本编辑器，相当于windows下的记事本</li><li>which 看某个命令会使用那些程序，如果显示地址，则说明有这些程序，如果没有输出，或者输出错误信息，则说明这个命令无法使用</li><li>quit 终止程序命令，但是也可以输入eof使程序终止</li><li>bc 计算器 如果想用bc内部的函数，要用bc -l命令（library)。如果是多个算式，中间要用”;”号隔开</li></ul><p>常用函数</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">s</span><span class="params">(x)</span></span> sinx  弧度制</span><br><span class="line"><span class="function"><span class="title">c</span><span class="params">(x)</span></span> cosx</span><br><span class="line"><span class="function"><span class="title">a</span><span class="params">(x)</span></span> arctanx</span><br><span class="line"><span class="function"><span class="title">ln</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">j</span><span class="params">(n,x)</span></span>  x的n次整阶贝塞尔函数</span><br></pre></td></tr></table></figure></div><p>如果想用小数运算，先要设置标度因子 scale 来确定精确到小数点后多少位。如果输入scale 则会返回scale的当前值 scale=3，则设置小数点后三位</p><p>有一点需要注意，当你用来 bc -l时，scale会自动设置为20</p><p>bc实际上是一套功能完整的数学编程语言，可以使用的变量有26个字母<br>例如 x=100 就是将x变量设为100</p><h5 id="变量显示命令"><a href="#变量显示命令" class="headerlink" title="变量显示命令"></a>变量显示命令</h5><p>环境变量实际上就是全局变量，用env显示环境变量，如果想让输出按字母表排序，可以用 env | sort | less</p><ul><li><p>set 显示shell变量</p></li><li><p>echo 显示赋予它对象的值，例如 echo I 将会输出I</p></li></ul><p>如果要显示一个变量的值，可以用$(美元符号），后面的变量最好加花括号（{}）</p><p>例如 echo ${TERM}</p><p>实际上，很多标点符号都有特殊的用途，为了能正确显示他们，要在最外面用双引号</p><ul><li><p>变量创建只需要一边写变量名，另一边写值即可。例如，HARLEY=cool，如果希望变量中有空格，则需使用双引号</p></li><li><p>export 将变量导出环境中（即变成全局变量）。还可以在创建同时导出。用 export 变量名=值即可</p></li><li><p>unset 删除变量。实际上没有办法简单的从环境中移除变量，因此最简单的办法是直接删除它。</p></li><li><p>set 显示shell所有选项的当前值，如果用 -o 则会简要的显示 +o是详细的显示。例如，set -o ignoreeof 这样在按 Ctrl+D的时候就不会突出shell了，如果想复位，只要+o</p></li><li><p>alias 建立别名，语法为alias name=command 例如 <code>alias It=&#39;-l temp*&#39;</code>。这种时候，单引号就比双引号要好，因为这样可以防止一些特殊字符被转义。此外，可以通过alias name 知道这个别名的当前值。可以只输入alias得知所有别名，通过unalias删去别名。如果想暂时不用别名，可以在命令之前输入” \ “</p></li></ul><h5 id="文件显示指令"><a href="#文件显示指令" class="headerlink" title="文件显示指令"></a>文件显示指令</h5><ul><li>less，这条指令是让大量的数据分成一页一页进行查看，如果不使用这个程序。那么输出时会直接到这些数据的末尾。less在正常情况下是区分大小写的，如果想不区分，可以使用I选项。此外，less命令内部还有许多搜索，翻页等指令，这些指令可以通过help去查看。</li></ul><p>less还有一个特殊的功能，就是直接跳转到某一页。less +5g …代表跳转到第5页，less +/buffer …是从第一个buffer处开始。</p><h6 id="显示十六进制文件"><a href="#显示十六进制文件" class="headerlink" title="显示十六进制文件"></a>显示十六进制文件</h6><p>显示二进制文件的命令是 hexdump（显示十六进制文件），od（显示八进制文件），</p><p>hexdump -C file。将自动选取适合的选项组合进行输出。</p><p>-s 偏移一定字节数开始输出。</p><p>-n 显示多少字节输出</p><h5 id="条件执行指令"><a href="#条件执行指令" class="headerlink" title="条件执行指令"></a>条件执行指令</h5><p>command1 &amp;&amp; command2</p><p>在条件1满足的情况下执行command2</p><p>command1|| command2</p><p>在条件1不满足的情况下也执行command2</p><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>regular expression 通常简写成regex或re，是一种指定字符串模式的输出方式。</p><p>例如： harley1 harley2 harley3 ，作为正则表达式，可以用harley[123]表达这组模式。</p><p>从这里我们可以了解到，正则表达式就像把许多字符串化为一个表达式。</p><p>下面介绍一些常用的正则表达式</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>除新行字符外，匹配任意的单个字符</td></tr><tr><td>^</td><td>锚，匹配行的开头</td></tr><tr><td>$</td><td>锚，匹配行的末尾</td></tr><tr><td>\ &lt;</td><td>锚，匹配单词的开头</td></tr><tr><td>\ &gt;</td><td>锚，匹配单词的末尾</td></tr><tr><td>[list]</td><td>字符类，匹配list中的任意字符</td></tr><tr><td>^[list]</td><td>子父类，匹配不再list中的任意字符</td></tr><tr><td>()</td><td>组，视为一个单独的单元</td></tr><tr><td>竖线</td><td>匹配选择之一</td></tr><tr><td>\</td><td>引用： 从字面上解释元字符</td></tr><tr><td><strong>注意</strong></td><td><strong>下面是判定匹配次数的字符</strong></td></tr><tr><td>*</td><td>匹配0次或者多次</td></tr><tr><td>+</td><td>匹配一次或者多次</td></tr><tr><td>？</td><td>匹配0次或1次</td></tr><tr><td>{n}</td><td>匹配n次</td></tr><tr><td>{0，m}</td><td>最多匹配m次</td></tr><tr><td>{n,}</td><td>最少匹配n次</td></tr><tr><td>{，m}</td><td>最多匹配m次</td></tr><tr><td>{n,m}</td><td>最少n次，最多m次</td></tr><tr><td><strong>注意</strong></td><td><strong>预定义字符类</strong></td></tr><tr><td>[:lower:]</td><td>小写字母</td></tr><tr><td>[:upper:]</td><td>大写字母</td></tr><tr><td>[:alpha:]</td><td>大小写字母</td></tr><tr><td>[:alnum:]</td><td>大小写字母，数字</td></tr><tr><td>[:digit:]</td><td>数字</td></tr><tr><td>[:punct:]</td><td>标点符号</td></tr><tr><td>[:blank:]</td><td>制表符或者空格</td></tr></tbody></table><h6 id="基本和扩展正则表达式"><a href="#基本和扩展正则表达式" class="headerlink" title="基本和扩展正则表达式"></a>基本和扩展正则表达式</h6><h6 id="匹配行和单词"><a href="#匹配行和单词" class="headerlink" title="匹配行和单词"></a>匹配行和单词</h6><p>有些元字符具有定位的作用，这些字符叫做<strong>锚</strong>。例如，harley$仍是匹配字符串harley，但是这个时候只匹配行末尾的字符了。</p><p>如果我们要找以harley开头的行，可以</p><p>grep ‘^harley’ data</p><p>注意，当我们使用含有元字符的表达式时，为了不干扰，最好加上单引号</p><p>通过使用 ^$ ，我们可以很方便的查找空行。这个的意思就是既找行首又找行尾，只有空行才满足这个条件。</p><p>例如： grep ‘^$’ data | wc -l</p><p>如果我们要找 某个字符位于开头的，可以用 &lt;</p><p>例如： grep ‘&lt;kn’ data，这个就是找kn为于单词开头的单词。或者grep ‘kn&gt;‘ data</p><p>在linux系统中，可以采用\b代替&lt;和&gt;，\b相当于边界标记。此外，要尊重客观规律，不能把开头标记和结尾标记都写在开头。</p><p>如果想匹配所有包含字母 H ，后面加a或者A的，可以用 grep ‘H[aA]’ data</p><p>如果想表示一个范围，可以用 [a-b]，例如 [3-6] 或 [a-z]，这应该是按ascii码来的</p><p>grep ‘[^A-Z,a-z]’ data可以用来搜索所有不包含字母的行</p><h6 id="重复使用运算符"><a href="#重复使用运算符" class="headerlink" title="重复使用运算符"></a>重复使用运算符</h6><p>例如，如果我想找首字母是大写H，后面接了0个或者多个字母的行，可以使用</p><p>grep ‘H[[:alpha:]]*’ data</p><p>如果想搜索一个或者多个，可以用+号，</p><p>例如： grep ‘variable[0-9]+’ data</p><p>到现在，我们一直使用单个字符作为查找对象，如果想用多个字符作为查找对象，就需要用到组（小括号）</p><p>例如： (xyz){5},这条命令就是查找重复出现xyz五次的字符串</p><p>如果我们想搜索多个单词，可以用 | 分隔开来。</p><p>例如： grep ‘(cat | dog | bird) ‘ data</p><p>如果我们想搜索有特殊含义的元字符，可以用(转义字符）把这些字符的含义变成常规字符，如果我们想搜索 \ 本身，那么可以用两个 \</p><p>例如： grep ‘$‘ data</p><h6 id="字典文件"><a href="#字典文件" class="headerlink" title="字典文件"></a>字典文件</h6><p>字典顾名思义，就是许多经常用的单词放到一起，每个单词一行，并且按照字母表顺序排列。一般储存在 /usr/share/dict/words中。</p><p>利用这个文件，我们就可以很方便的查找单词。例如，那些单词以qu开头并且以y结尾呢？</p><p>grep ‘^qu[a-z]+y$’ /usr/share/dict/words</p><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td>PATH</td><td>设置shell搜索路径</td></tr><tr><td>PS1</td><td>设置标识符</td></tr><tr><td>SHELL</td><td>shell路径</td></tr><tr><td>HISTSIZE</td><td>fc中最大保存的指令数</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开始使用unix</title>
      <link href="/post/9187.html"/>
      <url>/post/9187.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>当你使用Unix系统的时候，第一件要你做的事便是输入用户标识和口令（账号密码），注意，在Unix中，密码是完全不可见的，甚至连*号都不会出现。</p><p>登陆之后出现的欢迎界面，这一部分源于一个特殊的初始化文档，这就意味着你可以对文档内容进行修改从而定制化你的初始化界面。</p><p>一旦初始化命令结束执行，Unix将启动shell，并将控制权交给他。这时shell会出现一个提示-称为shell提示，并等待命令。接下来就可以输入各种命令了。</p><p>最终，没有命令时，你可以通过注销结束工作会话，此时shell将停止运行。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>unix基础</title>
      <link href="/post/10919.html"/>
      <url>/post/10919.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><ol><li>操作系统有初始化功能，初始化过程只是引导过程的一部分</li></ol><p>引导过程是计算机启动时会运行一个小程序，然后再运行另一个程序，逐层运行，最后运行一个十分复杂的程序，这个程序名字是内核。</p><p>内核是操作系统的核心，因此只要计算机开启，内核边一直运行。</p><p>内核可以分为微内核和单内核两种。单内核较大，运行速度较快，但是由于没有采用模块化设计，维护修改比较困难。而微内核自己只能运行最基本的功能，其他功能要交给服务器去运行（微内核调用的其他程序），微内核速度慢，但适用于定制化的任务，如移动电话。</p><h3 id="unix-内核-使用工具"><a href="#unix-内核-使用工具" class="headerlink" title="unix=内核+使用工具"></a>unix=内核+使用工具</h3><p>只有内核并不能带来很好的用户体验，因此还有许多其他的程序。最重要的是为用户提供计算机界面的程序，shell 和 GUI。</p><p>shell 是一种提供基于文本的界面的程序，也就是平时所说的命令提示符。</p><p>而 GUI（graphical user interface）是使用窗口，鼠标指针，图标等提供图形界面.</p><p>这些工具称为Unix实用工具，有几百个。</p><h3 id="服务器和客户端"><a href="#服务器和客户端" class="headerlink" title="服务器和客户端"></a>服务器和客户端</h3><p>早期由于主机昂贵而终端便宜，所以经常是多个主机连接一个终端。因此服务器和客户端的概念也因此产生。</p><p>提供某种类型的服务的程序叫做服务器，使用服务的程序叫做客户端。例如，但你用键盘键入字符时，是主机而不是终端把字符显示出来，终端只是向主机发出了一个输出字符的请求，然后主机进行解析然后把字符输出</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单调队列</title>
      <link href="/post/8498.html"/>
      <url>/post/8498.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>也就是有一个数列a，要求你求数列b和c，b[i]是a[i]…a[i+w-1]中的最小值，c[i]是最大值。如果a是1,3,-1,-3,5,3,6,7，则b为-1,-3,-3,-3,3,3，c为3,3,5,5,6,7。</p><p>这个问题相当于一个数据流（数列a）在不断地到来，而数据是不断过期的，相当于我们只能保存有限的数据（sliding window中的数据，此题中就是窗口的宽度w），对于到来的查询（此题中查询是每时刻都有的），我们要返回当前滑动窗口中的最大值\最小值。注意，元素是不断过期的。</p><p>解决这个问题可以使用一种叫做单调队列的数据结构，它维护这样一种队列：</p><p>a)从队头到队尾，元素在我们所关注的指标下是递减的（严格递减，而不是非递增），比如查询如果每次问的是窗口内的最小值，那么队列中元素从左至右就应该递增，如果每次问的是窗口内的最大值，则应该递减，依此类推。这是为了保证每次查询只需要取队头元素。</p><p>b)从队头到队尾，元素对应的时刻（此题中是该元素在数列a中的下标）是递增的，但不要求连续，这是为了保证最左面的元素总是最先过期，且每当有新元素来临的时候一定是插入队尾。</p><p>满足以上两点的队列就是单调队列，首先，只有第一个元素的序列一定是单调队列。</p><p>那么怎么维护这个单调队列呢？无非是处理插入和查询两个操作。</p><p>对于插入，由于性质b，因此来的新元素插入到队列的最后就能维持b)继续成立。但是为了维护a)的成立，即元素在我们关注的指标下递减，从队尾插入新元素的时候可能要删除队尾的一些元素，具体说来就是，找到第一个大于（在所关注指标下）新元素的元素，删除其后所有元素，并将新元素插于其后。因为所有被删除的元素都比新元素要小，而且比新元素要旧，因此在以后的任何查询中都不可能成为答案，所以可以放心删除。</p><p>对于查询，由于性质b，因此所有该时刻过期的元素一定都集中在队头，因此利用查询的时机删除队头所有过期的元素，在不含过期元素后，队头得元素就是查询的答案（性质a），将其返回即可。</p><p>由于每个元素都进队出队一次，因此摊销复杂度为O(n)。</p><p>这个讲的十分清楚，我只是<a href="https://blog.csdn.net/Baoli1008/article/details/47001513" target="_blank" rel="external nofollow noopener noreferrer">搬运</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双端队列deque</title>
      <link href="/post/35848.html"/>
      <url>/post/35848.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>普通的队列有许多限制，例如从一边删除插入，不能使用迭代器（因为空间不连续）等等。<br>双端队列就允许从两边插入</p><p>deque的特点：</p><p>1、支持随机访问，即支持[]以及at()，但是性能没有vector好。</p><p>2、可以在内部进行插入和删除操作，但性能不及list。</p><p>deque和vector的不同之处：</p><p>1、两端都能够快速插入和删除元素。vector只能在尾端进行。</p><p>2、deque的元素存取和迭代器操作会稍微慢一些。因为deque的内部结构会多一个间接过程。</p><p>3、迭代器是特殊的智能指针，而不是一般指针。它需要在不同的区块之间跳转。</p><p>4、deque可以包含更多的元素，其max_size可能更大。因为不止使用一块内存。</p><p>5、不支持对容量和内存分配时机的控制。</p><p>注意：在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector。因为其内部结构显示不需要复制所有元素。</p><p>迭代器属于随机存取迭代器。</p><p>以上都是复制粘贴的，从以上我们可以看出它与vector相似，不同在于它可以从两头插入，这样插入效率高，如果从中间插入，要把很多元素都移动一遍，效率低</p><p>格式： deque&lt;类型&gt; 标识符</p><p>当生成一个 deque 容器时，也可以用由两个迭代器标识的一段元素来初始化它：</p><p>std::deque<a href="std::string">std::string</a> words_part { std::begin(words),std::begin(words) + 5 };</p><p>deque的成员函数：</p><p>deq[ ]：用来访问双向队列中单个的元素。</p><p>deq.front()：返回第一个元素的引用。</p><p>deq.back()：返回最后一个元素的引用。</p><p>deq.push_front(x)：把元素x插入到双向队列的头部。</p><p>deq.pop_front()：弹出双向队列的第一个元素。</p><p>deq.push_back(x)：把元素x插入到双向队列的尾部。</p><p>deq.pop_back()：弹出双向队列的最后一个元素。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> stl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算几何基础</title>
      <link href="/post/8050.html"/>
      <url>/post/8050.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="判断两直线是否相交"><a href="#判断两直线是否相交" class="headerlink" title="判断两直线是否相交"></a>判断两直线是否相交</h3><p>P(x1,y1) Q(x2,y2) 两向量的叉积为 x1<em>y2-x2</em>y1</p><p>如果 p*q&gt;0 p在q的顺时针方向</p><p>p*q&lt;0 p在q的逆时针方向</p><p>=0 ，共线或反向</p><p><img src="/images/20170428234108337.png" alt></p><p>先做一次快速排斥实验，判断下一个线段中 x 较大的端点是否小于另一个线段中 x 较小的段点，若是，则说明两个线段必然没有交点，同理判断下 y</p><p>代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>x)&lt;min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>x)<span class="operator"> || </span>max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>y)&lt;min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>y) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">max(<span class="constructor">A</span>.x,<span class="constructor">B</span>.x)&lt;min(<span class="constructor">C</span>.x,<span class="constructor">D</span>.x) <span class="operator">||</span> max(<span class="constructor">A</span>.y,<span class="constructor">B</span>.y)&lt;min(<span class="constructor">C</span>.y,<span class="constructor">C</span>.y)</span></span><br></pre></td></tr></table></figure></div><p>如图所示，如果想判断两线段相交，只需要判断A 和 B在cd两侧即可</p><p>所以只需要 向量<code>AD*CD</code>与 BD*CD异号即可</p><p>如果端点正好在另一条线段上，两者乘积等于0</p><p>如果两者平行，叉积也为0但是可以在快速排斥实验中排除掉</p><p>总代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct Line &#123;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">x</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="comment">    double y1;</span></span><br><span class="line"><span class="comment">    double x2;</span></span><br><span class="line"><span class="comment">    double y2;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">bool intersection(const Line &amp;l1, const Line &amp;l2)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    //快速排斥实验</span></span><br><span class="line"><span class="comment">    if ((l1.x1 &gt; l1.x2 ? l1.x1 : l1.x2) &lt; (l2.x1 &lt; l2.x2 ? l2.x1 : l2.x2) ||</span></span><br><span class="line"><span class="comment">        (l1.y1 &gt; l1.y2 ? l1.y1 : l1.y2) &lt; (l2.y1 &lt; l2.y2 ? l2.y1 : l2.y2) ||</span></span><br><span class="line"><span class="comment">        (l2.x1 &gt; l2.x2 ? l2.x1 : l2.x2) &lt; (l1.x1 &lt; l1.x2 ? l1.x1 : l1.x2) ||</span></span><br><span class="line"><span class="comment">        (l2.y1 &gt; l2.y2 ? l2.y1 : l2.y2) &lt; (l1.y1 &lt; l1.y2 ? l1.y1 : l1.y2))</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //跨立实验</span></span><br><span class="line"><span class="comment">    if ((((l1.x1 - l2.x1)*(l2.y2 - l2.y1) - (l1.y1 - l2.y1)*(l2.x2 - l2.x1))*</span></span><br><span class="line"><span class="comment">        ((l1.x2 - l2.x1)*(l2.y2 - l2.y1) - (l1.y2 - l2.y1)*(l2.x2 - l2.x1))) &gt; 0 ||</span></span><br><span class="line"><span class="comment">        (((l2.x1 - l1.x1)*(l1.y2 - l1.y1) - (l2.y1 - l1.y1)*(l1.x2 - l1.x1))*</span></span><br><span class="line"><span class="comment">        ((l2.x2 - l1.x1)*(l1.y2 - l1.y1) - (l2.y2 - l1.y1)*(l1.x2 - l1.x1))) &gt; 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/HelloZEX/article/details/80880385" target="_blank" rel="external nofollow noopener noreferrer">参考</a></p><h3 id="判断点是否在多边形内部"><a href="#判断点是否在多边形内部" class="headerlink" title="判断点是否在多边形内部"></a>判断点是否在多边形内部</h3><p>我们先将横纵坐标存在一个数组内</p><p>第一步</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.x &lt; minX <span class="params">||</span> p.x &gt; maxX <span class="params">||</span> p.y &lt; minY <span class="params">||</span> p.y &gt; maxY) &#123;</span><br><span class="line">     /<span class="regexp">/ 这个测试都过不了。。。直接返回false；</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这个测试是画一个四边形</p><p>第二步， 这里我们就要讲一个定理了，以某一点为端点画一条射线，如果穿过图形次数为奇数次，则在图形内，如果是偶数次，在图形外</p><p>为了方便讨论，我们将以x轴正方向做一条射线</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int pnpoly (int nvert, float *vertx, float *verty, float testx, float testy) &#123;</span><br><span class="line">    int <span class="built_in">i</span>, <span class="built_in">j</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">i</span> = <span class="number">0</span>, <span class="built_in">j</span> = nvert<span class="number">-1</span>; <span class="built_in">i</span> &lt; nvert; <span class="built_in">j</span> = <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ( (verty[<span class="built_in">i</span>]&gt;testy) != (verty[<span class="built_in">j</span>]&gt;testy) ) &amp;&amp;</span><br><span class="line">(testx &lt; (vertx[<span class="built_in">j</span>]-vertx[<span class="built_in">i</span>]) * (testy-verty[<span class="built_in">i</span>]) / (verty[<span class="built_in">j</span>]-verty[<span class="built_in">i</span>]) + vertx[<span class="built_in">i</span>]) )</span><br><span class="line">            c = !c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>nvert 是 顶点数量，testx和testy是顶点横纵坐标</p><p>第一段的意思是</p><p>verty[i] &lt;testy &lt; verty[j]</p><p>或者</p><p>verty[j] &lt;testy &lt; verty[i]</p><p>这段代码是用来粗略判断射线是否会经过该边的（没考虑反向和端点）</p><p>第二段是用来判断测试点是否在两点连线之下，这里用了斜率（移下项）</p><p>c=!c;是用来判断奇数次还是偶数次的</p><h3 id="多边形的面积"><a href="#多边形的面积" class="headerlink" title="多边形的面积"></a>多边形的面积</h3><p>s=pow(p<em>(p-a)</em>(p-b)*(p-c),0.5),p=(a+b+c)/2</p><p>凸多边形都可以通过划分变成三角形</p><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>用最少的点把给出的点全部包住</p><h4 id="andraw算法"><a href="#andraw算法" class="headerlink" title="andraw算法"></a>andraw算法</h4><p>把所有点按第一关键字x第二关键字y按从小到大排序，并且删除重复点，得到序列p1…pn</p><p>把p1 p2放入凸包中，凸包中的点用栈来保存</p><p>然后 p1p2和p2p3叉积，如果叉积大于0，则说明p1p2在p2p3右边，说明p3在内部，我们就不选，反之则把它拖入栈中并且要把p2拖出栈中</p><p>这样一直到pn算完成了一遍（下凸包），我们还要从pn反过来到p1（上凸包）,合起来就是完整的凸包</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y==b.y&amp;&amp;a.x&lt;b.x)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">xcross</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b,<span class="built_in">point</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);<span class="comment">//斜率</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">point</span> node[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node,node+n,cmp);</span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">0</span>; num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;xcross(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">        top--;</span><br><span class="line">        top++;</span><br><span class="line">        num[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> basic=top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;basic&amp;&amp;xcross(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">        top--;</span><br><span class="line">        top++;</span><br><span class="line">        num[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> s;</span><br><span class="line">    s=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=dis(node[num[i<span class="number">-1</span>]],node[num[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1lf"</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h3><p>旋转卡壳可以用来求凸包的直径，宽度，两个不相交凸包间最大距离和最小距离等</p><p>如果过凸包上的两个点可以画一对平行直线，使凸包上所有点都夹在两<br>条平行线之间 || 落在平行线上，那么这两个点称为一对对踵点。</p><p><img src="/images/4429524-41118e7599b80fb5.webp" alt><br>其实简单来说就是用一对平行线“卡”住凸包进行旋转。<br>被一对卡壳正好卡住的对应点对称为对踵点，对锺点的具体定义不好说，不过从图上还是比较好理解的。可以证明对鍾点的个数不超过3*n/2</p><p>卡壳有两种情况，第一种是一点对一点， 也就是上图中的</p><p><img src="/images/4429524-6d28ceac8cc2b711.webp" alt></p><p>另一种是一边只有一点，另外一边有两个点</p><p>第二种情况中我们可以发现对鍾点到对应边的距离比其他的要大（不要问我为什么）</p><p>Step1：计算多边形 y 方向上的端点，称之为 ymin 和 ymax。</p><p>Step2：通过 ymin 和 ymax 构造两条水平切线，由于他们已经是一对对<br>踵点，计算他们之间的距离并维护一个当前最大值。</p><p>Step3：同时旋转两条直线到其中一条与多边形的一条边重合。</p><p>Step4：一个新的对踵点对此时产生，计算新的距离，并和当前最大值进<br>行比较，若大于当前最大值。则更新。</p><p>Step5：重复 Step3 和 Step4 的过程直到再次产生新的对踵点对。</p><p>Step6：输出最大直径的对踵点对。</p><p>听起来有点小麻烦，观察可以发现当平行线和多边形的一条边重合的时<br>候最会产生一对新的对踵点<br>这条边的两个端点和原来的点都可能更新最大值</p><p>不妨考虑找离每条边最远的点，显然，这条边的两个端点都和最远点是<br>对踵点<br>特殊情况，如果有两条边是平行的，必须考虑所有的对踵点。<br>旋转卡壳的均摊复杂度 O(n)，但这个问题需要求凸包，复杂度是<br>O(nlogn)</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void solve2(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ymax=-1e5,ymin=1e5<span class="comment">;</span></span><br><span class="line">    <span class="keyword">int</span> ymaxidx,yminidx<span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">int</span> i=<span class="number">1</span><span class="comment">;i&lt;=num;i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if(<span class="number">ch</span>[i].y&gt;ymax)</span><br><span class="line">        &#123;</span><br><span class="line">            ymax=<span class="number">ch</span>[i].y<span class="comment">;</span></span><br><span class="line">            ymaxidx=i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="number">ch</span>[i].y&lt;ymin)</span><br><span class="line">        &#123;</span><br><span class="line">            ymin=<span class="number">ch</span>[i].y<span class="comment">;</span></span><br><span class="line">            yminidx=i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx])<span class="comment">;</span></span><br><span class="line">    <span class="number">ch</span>[num+<span class="number">1</span>]=<span class="number">ch</span>[<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">int</span> t=<span class="number">1</span><span class="comment">;t&lt;=num;t++,yminidx=yminidx%num+1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        while(xmult(<span class="number">ch</span>[yminidx+<span class="number">1</span>],<span class="number">ch</span>[ymaxidx+<span class="number">1</span>],<span class="number">ch</span>[yminidx])&gt;xmult(<span class="number">ch</span>[yminidx+<span class="number">1</span>],<span class="number">ch</span>[ymaxidx],<span class="number">ch</span>[yminidx]))ymaxidx=ymaxidx%num+<span class="number">1</span><span class="comment">;</span></span><br><span class="line">        ans=max(ans,dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx]))<span class="comment">;</span></span><br><span class="line">        ans=max(ans,dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx+<span class="number">1</span>]))<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,ans)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数论</title>
      <link href="/post/15425.html"/>
      <url>/post/15425.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h3><p>如果a能被b整除，a=b*q，q为一整数记作b|a,a是被除的那个</p><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>如果a和bmod m 是同一个值，则称a和b同余，记作a (三横线） b(mod m)</p><p>例如： 3 和 8 关于5 同余 因为 3%5=3,8%5=3</p><p>重要性质：</p><pre><code>（a+b)%c=a%c+b%c(a*b)%c=(a%c*b%c)%c(a^b)%c=(a%c^b)%c</code></pre><h3 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h3><p>任何大于1的正整数n都可以被分解为若干质数的乘积</p><p>约数个数 例如 72=2^3<em>3^2 ，而72有 1 2 3 4 6 8 9 12 18 24 36 72 12个约数<br>，而我可以从2^3 中提取出0个2,1个2，两个2，三个2把其他的数放到另一边，这样我们就可以得到4个约数，3也同理，用一下分配率，就可以得到约数个数为3</em>4=12</p><p>约数和 因为约数是从2和3中随机挑出若干个数进行分配，所以用分配率可得约数和为</p><p>(1+2+2^2+2^3)(1+3+3^2)</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>如果p是质数且a与p互质，则</p><p>a^(p-1)%p=1(a的p-1次方和1关于p同余）</p><p>互质指的是 二者除了1以外没有相同的约数</p><h3 id="求质数的方法"><a href="#求质数的方法" class="headerlink" title="求质数的方法"></a>求质数的方法</h3><p><a href="http://localhost:4000/2020/01/04/%E5%9F%83%E6%B0%8F%E7%AD%9B/" target="_blank" rel="external nofollow noopener noreferrer">埃氏筛</a></p><p><a href="http://localhost:4000/2020/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B/" target="_blank" rel="external nofollow noopener noreferrer">线性筛</a></p><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>概念：表示0到n-1中与n互素的数的个数</p><p>积性函数：如果 m和n互质 ，则f(m<em>n)=f(m)</em>f(n)</p><p>欧拉函数的性质：</p><ol><li>对于质数p f(p)=p-1</li><li>如果n=p^k,则f(n)=p^k-p^k-1</li><li>欧拉函数是积性函数，但不是完全积性函数，当n为质数时成立，当m=2,n为奇数时，f(2*n)=n</li><li>n&gt;2时 f(n)是偶数</li><li>与n互质的数的和为 f(n)*n/2</li><li>n的因数的欧拉函数的和为n</li></ol><h3 id="模意义下的乘法逆元"><a href="#模意义下的乘法逆元" class="headerlink" title="模意义下的乘法逆元"></a>模意义下的乘法逆元</h3><p>例 1/5%7=?</p><p>3*5%7=1,所以1/5的逆元是3，所以1/5%7=3</p><p>逆元的求法</p><p>1 费马小定理</p><p>a*a^-1%p=1,a^p-1%p=1</p><p>可得 a^-1%p=a^p-2%p，然后用快速幂。但是费马小定理要求必须要是素数</p><p>2 线性求逆元（不理解）</p><p>公式：inv(a)=-p/a*inv(p%a)%p;</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">2</span>;<span class="built_in">i</span>&lt;=n;++<span class="built_in">i</span>)&#123;</span><br><span class="line">inv[<span class="built_in">i</span>]=((<span class="number">1</span>ll*(-p/<span class="built_in">i</span>)*inv[p<span class="comment">%i]%p)+p)%p;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>3 扩展欧几里得法</p><p>exgcd</p><p>exgcd用来求解ax+by=c，其中a，b，c都为整数</p><p>裴蜀定理</p><p>不定方程 ax+by=c存在整数解当且仅当gcd(a,b)|c ，当存在一组整数解时，必存在无限组解<br>ax+by=gcd(a,b)=&gt;bx1+a%by1=gcd(b,a%b)=&gt;x=x1,y=x1-(a/b)y1</p><p>x=x1+k<em>b/gcd(a,b) , y= y1-k</em>a/gcd(a,b)</p><p>之后一直求解直到x=1,y=0,这时b=0,所以gcd(a,b)=a,方程一定成立</p><p>在这里我们可以用递归反推，把x=1,y=0带入方程，一步步向上推</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> exgcd(<span class="built_in">int</span> a,<span class="built_in">int</span> b,<span class="built_in">int</span> &amp;x,<span class="built_in">int</span> &amp;y)&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> x1,y1;</span><br><span class="line">exgcd(b,a%b,x1,y1);</span><br><span class="line">x=y1;</span><br><span class="line">y=x1-(a/b)*y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里我们就可以得到第三种方法</p><p>求逆元可以转化为：求关于x的同余方程ax（三横）1 mod b的最小正整数解</p><p>ax%b=1 ax=kb+1</p><p>即 ax-by=1</p><p>最后 x1%b+b即是答案</p><p><a href="https://big-news.cn/2019/05/19/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/" target="_blank" rel="external nofollow noopener noreferrer">可以看这篇博客</a></p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>求C(m,n)%p的值</p><p>可变成 (n!/m!(n-m)!)%p</p><p>之后就用费马小定理求逆元</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> ksm(<span class="built_in">int</span> a,<span class="built_in">int</span> b,<span class="built_in">int</span> p)&#123;</span><br><span class="line"><span class="built_in">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=<span class="number">1</span>ll*ret*a%p;</span><br><span class="line">a=<span class="number">1</span>ll*a*a%p;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> fac[maxn];</span><br><span class="line"><span class="built_in">int</span> inv(<span class="built_in">int</span> x)&#123;</span><br><span class="line"><span class="keyword">return</span> ksm(x,p<span class="number">-2</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> C(<span class="built_in">int</span> n,<span class="built_in">int</span> m)&#123;</span><br><span class="line"><span class="built_in">int</span> qwq=<span class="number">1</span>ll*fac[n]*inv(fac[n-m])%p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>ll*qwq*inv(fac[m])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> n,m;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">fac[i]=<span class="number">1</span>ll*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"%d"</span>,C(n,m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图论基础</title>
      <link href="/post/15201.html"/>
      <url>/post/15201.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>如果图中有权值，称为网，仅在无向图中考虑这些问题，生成树指删去一些边变为树</p><h4 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h4><p>这个也被称为加边法，</p><ol><li>把图中所有边按权值从小到大排序</li><li>把图中n个点看为n个独立的连通块</li><li>选择端点分属两个联通块且权值最小的边，若可选择的边有多条，任选其中一条即可</li><li>重复三，直至只剩一个连通块</li></ol><p>如何存边？</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;x,<span class="keyword">const</span> node&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxm];</span><br></pre></td></tr></table></figure></div><p>其中u代表起点v代表终点，而w代表权值</p><p>采用了并查集的思想</p><p>怎么看加边后是否会变成环？只需要查找u，v的根节点，如果根节点相同则说明加边后 会变成环</p><p>模板，n个点m条边，找最小生成树</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,e,w;</span><br><span class="line">    <span class="keyword">friend</span> opoerator &lt; (<span class="keyword">const</span> node&amp; x,<span class="keyword">const</span> node&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=a;</span><br><span class="line">    <span class="keyword">while</span>(father[r]!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        r=father[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=a;</span><br><span class="line">    <span class="keyword">while</span>(father[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=father[x];</span><br><span class="line">        father[x]=x;</span><br><span class="line">        x=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">int</span> fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        father[fx]=fy;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; nod[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;nod[i].s&gt;&gt;nod[i].e&gt;&gt;nod[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nod.<span class="built_in">begin</span>(),nod.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(join(nod[i].s,nod[i].e))</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">                ans+=nod[i].val;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="prim-算法"><a href="#prim-算法" class="headerlink" title="prim 算法"></a>prim 算法</h4><p>先把点分为两个集合，在最开始的时候第一个集合中只有任意一点，其他点在另外一个集合中，之后选择属于集合一点在集合B中一点在集合A中且与A权值最小的边</p><p>选择时注意只要把最近选的那个点的权值与原来 权值相比就可以了</p><p>我们如何保存边？用邻接矩阵</p><p>在这里我们不用考虑形成环的问题，因为我们是从两个集合中拿边，而想要形成环必定是在一个集合内拿边</p><p>模板</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g[maxn][maxn],dis[maxn];<span class="comment">//dis用来记录以i为起点的最小权值</span></span><br><span class="line"><span class="keyword">bool</span> mark[maxn];<span class="comment">//用来判断某点是否加入</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,ox3f,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="keyword">sizeof</span>(mark));</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">1</span>,mi;</span><br><span class="line">    mark[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[v]=<span class="built_in">min</span>(dis[v],g[u][v]);<span class="comment">//将从前的最小值与第u个点的最小值相比</span></span><br><span class="line">        &#125;</span><br><span class="line">        mi=ox3f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mark[v]&amp;&amp;dis[v]&lt;mi)<span class="comment">//找到与A集合中权值最小的</span></span><br><span class="line">            &#123;</span><br><span class="line">                u=v;</span><br><span class="line">                mi=dis[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=mi;</span><br><span class="line">        mark[u]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意，g数组开始要初始化为正无穷</p><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><p>在有向网中，求结点之间边权和最小的路被称为最短路问题</p><h4 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h4><p>多源最短路指的是任意两点之间的最短路径</p><p>一般采用floyd-warshall算法，并且要求图中没有负权环（不然一直绕着环走就可以一直减小）</p><h6 id="flord算法"><a href="#flord算法" class="headerlink" title="flord算法"></a>flord算法</h6><p>用一个二维数组f[i][j]表示从i到j最小路长度，初始化时输入i，j点的路的长度并且f[i][i]=0.</p><p>我们怎么找到最短的路程呢？ 通过观察可以发现，如果我们把一些点作为中转点的话，有可能会让路程变小。例如，我们只用1作为中转，可以得到</p><p>f[i][j]=min(f[i][j],f[i][1]+f[1][j]);</p><p>如果我们拿1和2作为中转点，可以得到</p><p>f[i][j]=min(f[i][j],f[i][1]+f[1][j]);</p><p>f[i][j]=min(f[i][j],f[i][2]+f[2][j]);</p><p>这段代码的意思是我先拿1作为中转，找到1做中转的最小路径之后我再拿2做为中转</p><p>模板<br><img src="/images/%E5%9B%BE%E7%89%8715.png" alt><br>第一层是k，表示以1,2。。。n为中转</p><p>离散上的传递闭包<br><img src="/images/%E5%9B%BE%E7%89%8716.png" alt></p><h4 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h4><p>默认s可达全部点，用dis[i]表示从s到i的最短路径</p><p>它的基本思想是贪心，与prim算法类似</p><p>松弛操作</p><p>每次给目标集合加入一个点时，都要用该点重新判断最小的路径</p><p><img src="/images/%E5%9B%BE%E7%89%8717.png" alt></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void dijkstra(int x)</span><br><span class="line">&#123;</span><br><span class="line">int visit[maxn],<span class="built_in">i</span>,<span class="built_in">j</span>,<span class="built_in">min</span>,next=x;</span><br><span class="line">memset(visit,<span class="number">0</span>,sizeof(visit));</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=n;++<span class="built_in">i</span>)</span><br><span class="line">dis[<span class="built_in">i</span>]=map[x][<span class="built_in">i</span>];</span><br><span class="line">visit[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">2</span>;<span class="built_in">i</span>&lt;=n;++<span class="built_in">i</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span>=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=n;++<span class="built_in">j</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[<span class="built_in">j</span>]&amp;&amp;dis[<span class="built_in">j</span>]&lt;<span class="built_in">min</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span>=dis[<span class="built_in">j</span>];</span><br><span class="line">next=<span class="built_in">j</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visit[next]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=n;++<span class="built_in">j</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[<span class="built_in">j</span>]&amp;&amp;dis[<span class="built_in">j</span>]&gt;dis[next]+map[next][<span class="built_in">j</span>])</span><br><span class="line">dis[<span class="built_in">j</span>]=dis[next]+map[next][<span class="built_in">j</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title> 链式前向星</title>
      <link href="/post/8072.html"/>
      <url>/post/8072.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>静态链表（链式前向星）是表示图的另外一种方法</p><h3 id="前向星"><a href="#前向星" class="headerlink" title="前向星"></a>前向星</h3><p>前向星也称为邻接数组</p><p>例 <img src="/images/static_linked_list_example.svg" alt></p><p>总共有这几条边</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></div><p>现在将这些边按从小到大排序，变成</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>) --|</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>) --| =&gt; len[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>) --|</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>) =&gt; head[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><p>然后再将数据填入三个数组中，分别是</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">es</span><span class="selector-attr">[]</span> 这个数组是用来记录每条边的终点的，而因为前面已经排好了序，起点很容易知道</span><br><span class="line"><span class="selector-tag">head</span><span class="selector-attr">[]</span> 记录以<span class="selector-tag">i</span>为起点的边在数组中的第一个位置</span><br><span class="line"><span class="selector-tag">len</span><span class="selector-attr">[]</span> 记录以<span class="selector-tag">i</span>为起点的边有多少</span><br></pre></td></tr></table></figure></div><table><thead><tr><th>Array</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>es</td><td>2</td><td>3</td><td>4</td><td>4</td><td>2</td><td>4</td><td>3</td></tr><tr><td>head</td><td>1</td><td>4</td><td>5</td><td>7</td><td></td><td></td><td></td></tr><tr><td>len</td><td>3</td><td>1</td><td>2</td><td>1</td><td></td><td></td><td></td></tr></tbody></table><p>head[2]=4表示2为起点的第一条边在es中的位置为4</p><p>通过这几个函数我们就能很清楚的知道点与边的关系</p><p>例如，我们想知道起点为1的所有边，我们只需要知道len[1]和head[1],这样我们知道起点为1的边有三个且从es[1]开始</p><p>但是前向星要排序，时间复杂度高，因此并不怎么使用</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表通常用vector来实现</p><p>vector<int>g[max_v]，g[i]表示了以i为起点的所有边</int></p><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>其他部分与前向星相同，但是链式前向星多了一个next数组，取消了len数组（因为没有排序了）</p><p>next数组的含义是下一条以i为节点的边在es中的位置，如果这是最后一个节点，则令next[i]=0</p><p>例如</p><table><thead><tr><th>Array</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>es</td><td>2</td><td>4</td><td>4</td><td>3</td><td>3</td><td>2</td><td>4</td></tr><tr><td>head</td><td>1</td><td>2</td><td>3</td><td>5</td><td></td><td></td><td></td></tr><tr><td>next</td><td>4</td><td>0</td><td>6</td><td>7</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>举个例子，我们要求以1为起始边的所有节点</p><p>先从head中知道了第一个以1为起始点的边是1号，所以可以知道（1，2），然后next[1]=4,而4的es=3，所以（1,3）也知道，然后同理</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxn=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxm=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> head[maxn];</span><br><span class="line"><span class="built_in">int</span> n,m,nEdge;      <span class="comment">//n为顶点数，m为边数，nEdge为存储的边的数量</span></span><br><span class="line">                    <span class="comment">//如果边是双向的，那么存储的边的数量就是2m</span></span><br><span class="line">struct NODE<span class="comment">//这里是双向的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> to;</span><br><span class="line">    <span class="built_in">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">NODE edge[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">void</span> addedges(<span class="built_in">int</span> u,<span class="built_in">int</span> v)       <span class="comment">//将边(u,v)添加进去</span></span><br><span class="line">&#123;</span><br><span class="line">    nEdge++;</span><br><span class="line">    edge[nEdge].next=head[u];</span><br><span class="line">    edge[nEdge].to=v;</span><br><span class="line">    head[u]=nEdge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> foreach()       <span class="comment">//遍历边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=head[i];k!=<span class="number">-1</span>;k=edge[k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;edge[k].to&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> Init()</span><br><span class="line">&#123;</span><br><span class="line">    nEdge=<span class="number">-1</span>;</span><br><span class="line">    memset(head,<span class="number">0xff</span>,sizeof(head));</span><br><span class="line">    <span class="built_in">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        addedges(u,v);</span><br><span class="line">        addedges(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/post/61809.html"/>
      <url>/post/61809.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>并查集指的是一个图中的若干个连通分支，任意两个连通分支间没有关系，而每个连通分支内部可以以任意一个点作为根节点，根节点指向它自己，而其他点指向他们的上级节点（因为是连通图，两点之间必定可达），因此只要在同一连通分支，必定可以到同一根节点，从而判断两者可达</p><p>例如：pre[2]=3表示2的上级节点为3，pre[3]=3表示这是一个根节点</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                    <span class="comment">//查找我（x）的掌门</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=x;                      <span class="comment">//委托 r 去找掌门</span></span><br><span class="line">    <span class="keyword">while</span> (pre[r ]!=r)           <span class="comment">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）</span></span><br><span class="line">    r=pre[r ] ;                 <span class="comment">// r 就接着找他的上级，直到找到掌门为止。</span></span><br><span class="line">    <span class="keyword">return</span>  r ;                <span class="comment">//掌门驾到~~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另外如何将两个连通分支合并为一个连通分支呢？</p><p>我们可以把任意一个根节点指向另外一个根节点（因为我们不考虑内部的关系，指向知道是否可达），这样就变为一个连通分支了</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>          <span class="comment">//我想让虚竹和周芷若做朋友</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);         <span class="comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span></span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)                         <span class="comment">//玄慈和灭绝显然不是同一个人</span></span><br><span class="line">    pre[fx ]=fy;                       <span class="comment">//方丈只好委委屈屈地当了师太的手下啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>如果我们要经转很多个上级才能找到根节点，这样显然效率较低，假如我们可以直接让自己的上级是根节点，那就再好不过了</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> pre[<span class="number">1000</span> ];</span><br><span class="line"><span class="built_in">int</span> find(<span class="built_in">int</span> x)                                       <span class="comment">//查找根节点</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )                           <span class="comment">//返回根节点 r</span></span><br><span class="line">          r=pre[r];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">int</span> i=x , j ;</span><br><span class="line">    <span class="keyword">while</span>( i != r )                                   <span class="comment">//路径压缩</span></span><br><span class="line">    &#123;</span><br><span class="line">         j = pre[ i ]; <span class="comment">// 在改变上级之前用临时变量  j 记录下他的值 </span></span><br><span class="line">         pre[ i ]= r ; <span class="comment">//把上级改为根节点</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><p>带权值的并查集只不过是在并查集中加入了一个value[ ]数组<br>value[ ]可以记录很多种东西，不一定是类似距离这种东西，也可以是相对于根节点的状态</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GML"><figure class="iseeu highlight /gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int findfat(int <span class="symbol">x</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keywords">if</span>(fat[<span class="symbol">x</span>] == <span class="symbol">x</span>) <span class="keywords">return</span> <span class="symbol">x</span>;</span><br><span class="line">int tmp=fat[<span class="symbol">x</span>];</span><br><span class="line">fat[<span class="symbol">x</span>]=findfat(fat[<span class="symbol">x</span>]);</span><br><span class="line"><span class="comment">//在此处修改val比如：</span></span><br><span class="line">value[<span class="symbol">x</span>]=value[tmp]+<span class="number">1</span>;</span><br><span class="line"><span class="keywords">return</span> fat[<span class="symbol">x</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/liujian20150808/article/details/50848646" target="_blank" rel="external nofollow noopener noreferrer">参考文章</a></p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>int指令</title>
      <link href="/post/57453.html"/>
      <url>/post/57453.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>格式： int n，n为中断类型码</p><p>在程序中可以采用int指令调用任何一个中断处理程序</p><p>例如： int 0 ，就会调用除法溢出的处理程序</p><p>所以说，int指令最终的功能与call指令类似，都是调用一段程序</p><p>例 用中断程序实现循环</p><p>要想实现循环，需要知道两个量，第一个是循环次数，第二个是跳转位移。循环次数用cx来保存，跳转位移用bx来保存</p><p>而为了实现loop指令，中断例程需要实现两个功能</p><ol><li>dec cx</li><li>cx=0，则顺序执行，否则，跳转</li></ol><p>代码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ...安装</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bx</span>,offset s-offset se</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span></span><br><span class="line"><span class="symbol"> s:</span> <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="string">'!'</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">7ch</span>；这时<span class="built_in">ip</span>指向下一条指令即se标号</span><br><span class="line"><span class="symbol">se:</span> <span class="keyword">nop</span></span><br><span class="line"><span class="symbol">lp:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">dec</span> <span class="built_in">cx</span> <span class="comment">;cx--</span></span><br><span class="line">   <span class="keyword">jcxz</span> lpret</span><br><span class="line">   <span class="keyword">add</span> [<span class="built_in">bp</span>+<span class="number">2</span>],<span class="built_in">bx</span>//因为入栈顺序为标志寄存器，<span class="built_in">cs</span>，<span class="built_in">ip</span>，而<span class="keyword">add</span>是与后两个字节<span class="keyword">add</span></span><br><span class="line"><span class="symbol">ipret:</span> <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">     <span class="keyword">iret</span> //没到<span class="built_in">cx</span>=<span class="number">0</span>时也会终止，但这时<span class="built_in">ip</span>就不会回到s标号处</span><br></pre></td></tr></table></figure><h3 id="blos-和-dos中断例程安装过程"><a href="#blos-和-dos中断例程安装过程" class="headerlink" title="blos 和 dos中断例程安装过程"></a>blos 和 dos中断例程安装过程</h3><ol><li><p>开机后，cs：ip初始化为0ffff：0 ，这里有一条跳转指令，自动跳转到blos中的硬件系统检测和安装程序</p></li><li><p>初始化程序将建立blos所支持的中断向量，即把blos提供的中断例程载入中断向量表中</p></li><li><p>硬件检测完之后，调用int 19h进行操作系统的引导，从此把计算机给操作系统控制</p><h3 id="blos中断例程的应用"><a href="#blos中断例程的应用" class="headerlink" title="blos中断例程的应用"></a>blos中断例程的应用</h3><p>int 10h 中断例程是blos提供的，包含多个与屏幕输出有关的子程序</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span></span><br></pre></td></tr></table></figure><p>ah=2表示调用10h中的2号子程序，功能为设置光标的位置，</p><p>bh=0，dh=5，dl=12 设置光标到第0页，第5行，第12列</p><p>mov ah ，9 表示调用第9号子程序，功能为在光标位置显示字符，可以提供显示字符的各种属性</p></li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">9</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="string">'a'</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">11001010b</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span>//字符重复次数</span><br><span class="line">    <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="dos中断例程的应用"><a href="#dos中断例程的应用" class="headerlink" title="dos中断例程的应用"></a>dos中断例程的应用</h3><p>int 21h就是dos的中断例程，</p><p>我们一直使用的是int 21h中的4ch功能，即程序返回功能</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">4ch</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure><p>ah=4ch表示调用21h中的4ch号子程序</p><p>21h 中的光标位置显示字符功能</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ds:</span><span class="built_in">dx</span> 指向字符串</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>，<span class="number">9</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure><p>调用第九号子程序</p><p>dh中放行号，dl中放列号</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内中断</title>
      <link href="/post/44914.html"/>
      <url>/post/44914.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>一般cpu都有一种能力，就是接受cpu内部或外部发来的信号，停止当前程序而取执行其他的程序。这种信息叫做中断信息，中断信息指的是cpu接受到这种信息后立刻处理这个信息。接受到这个信息后cpu会交给专门的程序去处理，叫做中断处理程序</p><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>内中断指的是中断信息来自cpu内部。当cpu接受到相应几种情况时，会产生相应的中断信息</p><ol><li>除法错误 例如 ，div除法溢出</li><li>单步执行</li><li>执行into指令</li><li>执行int 指令</li></ol><p>我们先不需要了解具体含义。为了更方便的知道到底属于那种中断信息，8086cpu用了一个字节的中断类型码来确定。</p><ol><li>除法错误 0</li><li>单步执行 1</li><li>执行into指令 4</li><li>int： int n ，n就是中断类型码</li></ol><p>cpu根据cs:ip知道程序的入口，所以中断类型码中必定有cs:ip的信息，可cpu如何根据8位的类型吗知道程序的入口呢？</p><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>cpu通过中断类型码找到中断向量表，而中断向量表中就保存着程序的入口。中断向量表在内存中保存。中断内存表位于0000:0000 到 0000:03ff 1024个字节中</p><h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>找到cs：ip的过程叫做中断过程。</p><p>cpu收到中断信息后，要对中断信息进行处理。但是完成中断程序之后还要返回，就像call和ret一样。所以总过程如下</p><ol><li>获得中断类型码</li><li>标志寄存器的值入栈（因为中断过程会改变标志寄存器的值）</li><li>设置标志寄存器第8位和第九位的值为0</li><li>cs入栈</li><li>ip入栈</li><li>设置cs：ip</li></ol><p>更简洁的说明</p><ol><li>获得 中断类型码 n</li><li>pushf</li><li>tf=0 if=0</li><li>push cs</li><li>push ip</li><li>ip=n<em>4，cs=n</em>4+2</li></ol><h3 id="iret指令"><a href="#iret指令" class="headerlink" title="iret指令"></a>iret指令</h3><p>中断处理程序用iret进行返回</p><p>内容</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">popf</span><br></pre></td></tr></table></figure></div><p>这个正好与进栈顺序相反</p><h3 id="除法错误中断的处理"><a href="#除法错误中断的处理" class="headerlink" title="除法错误中断的处理"></a>除法错误中断的处理</h3><p>cpu如果产生除法溢出错误，将会产生中断类型码为0的中断信息。引发中断过程。然后中断处理程序会返回 divide overflow 再返回到主程序中</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span> do0安装程序</span><br><span class="line">     设置中断向量表</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00h</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol"> do0:</span> 显示字符串“overflow！”</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意：do0也要返回</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>用movsb指令，将do0的代码送入0:200处</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> 设置<span class="built_in">es</span>:<span class="built_in">di</span>指向目的地址</span><br><span class="line">     设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向源地址</span><br><span class="line">     设置传输长度</span><br><span class="line">     设置传输方向为正</span><br><span class="line">     <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line">     </span><br><span class="line">     设置中断表</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>我们如何知道do0代码长度？</p><p>可以用编译器来知道do0的长度</p><p><code>mov cx,offset do0end-offset do0</code></p><p>“-”是编译器识别的符号，编译器可以用它来做两个常数的减法</p><p>例如 mov ax,(5+3)*5/10 被编译器识别为 mov ax，4</p><h3 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h3><p>do0的主要任务是显示字符串</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0:</span> 设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向字符串</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">9</span></span><br><span class="line"><span class="symbol">  s:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">do0end:</span><span class="keyword">nop</span></span><br></pre></td></tr></table></figure><p>这个程序看起来对，实际上有问题，因为程序执行完后内存立刻被释放，其中保存的内容也可能被其他的程序覆盖。正确的程序如下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="symbol">do0:</span> <span class="keyword">jmp</span> short do0start</span><br><span class="line">   <span class="built_in">db</span> <span class="string">"overflow!"</span></span><br><span class="line"><span class="symbol">do0start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">202h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">9</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span>//用<span class="keyword">iret</span>也可以，用的话表示还会返回主程序中</span><br><span class="line"><span class="symbol">do0end:</span> <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h3><p>现在do0的入口为 0:200 ,写入中断向量表的0号表项中。使do0成为0号中断处理程序<br>0号表项地址为0:0 ，其中0:0存放偏移地址，0:2存放段地址。程序如下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>cpu执行完一条指令后，如果检测到tf=1，则产生单步中断，单步中断类型码为1，过程如下</p><ol><li>获得中断类型码</li><li>标志寄存器入栈，tf if设置为0</li><li>cs，ip入栈</li><li>ip=1<em>4 cs=1</em>4+2</li></ol><p>cpu为什么要提供单步中断呢？在debug的t命令中，为什么执行完一条 指令后，能够实时的反映寄存器的状态？这便是cpu单步中断导致可以一条条指令执行</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>df标志和传送指令</title>
      <link href="/post/28579.html"/>
      <url>/post/28579.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>flag第十位是df，方向标志位，在串处理指令中，控制每次操作后si，di的增减</p><p>df=0，每次操作后都是si，di增</p><p>df=1，减</p><h4 id="串传送指令"><a href="#串传送指令" class="headerlink" title="串传送指令"></a>串传送指令</h4><h5 id="movsb"><a href="#movsb" class="headerlink" title="movsb"></a>movsb</h5><p>格式： movsb</p><p>功能：</p><ol><li>es<em>16+di=ds</em>16+si</li><li>如果df=0，则 si=si+1，di=di+1，等于一相反</li></ol><p>汇编语言描述</p><ol><li>mov se:[di],byte ptr ds:[si] （汇编不支持这样的指令）</li><li>如果df=0 inc si inc di else dec si dec di</li></ol><p>movsb的功能是将ds：si中的数据传到 es：di中</p><h5 id="movsw"><a href="#movsw" class="headerlink" title="movsw"></a>movsw</h5><p>格式 movsw</p><p>这个是按字来传送，si和di+2或-2</p><h5 id="rep"><a href="#rep" class="headerlink" title="rep"></a>rep</h5><p>rep movsb</p><p>相当于</p><pre><code>s: movsb  loop s</code></pre><p>rep的作用是根据cx的值，重复执行后面的串传送指令</p><h4 id="df-设置指令"><a href="#df-设置指令" class="headerlink" title="df 设置指令"></a>df 设置指令</h4><p>cld 指令： 将df设置为0<br>std指令： 将df设置为1</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>检测比较结果的条件转移指令</title>
      <link href="/post/57449.html"/>
      <url>/post/57449.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>转移是指它可以修改ip，条件指在某种特定情况下才会修改</p><p>例如 jcxz就是一个条件转移指令，只有在cx=0的情况下才会跳转</p><p>下列转移指令都是根据cmp指令进行的转移</p><h3 id="无符号数情况下的转移"><a href="#无符号数情况下的转移" class="headerlink" title="无符号数情况下的转移"></a>无符号数情况下的转移</h3><table><thead><tr><th>指令</th><th>含义</th><th>检测的标志位</th></tr></thead><tbody><tr><td>je</td><td>等于则转移</td><td>zf=1</td></tr><tr><td>jne</td><td>不等于则转移</td><td>zf=0</td></tr><tr><td>jb</td><td>小于则转移</td><td>cf=1</td></tr><tr><td>jnb</td><td>大于等于则转移</td><td>cf=0</td></tr><tr><td>ja</td><td>高于则转移</td><td>cf=0且zf=0</td></tr><tr><td>jna</td><td>不高于则转移</td><td>cf=1或zf=1</td></tr></tbody></table><p>记忆方法：第一个字母都是j，代表jump</p><p>e：equal</p><p>ne：not equal</p><p>b：below</p><p>a：above</p><p>不一定要在前面是cmp指令，例如</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">je</span> s</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="symbol">s:</span> <span class="keyword">inc</span> <span class="built_in">ax</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>标志寄存器</title>
      <link href="/post/57339.html"/>
      <url>/post/57339.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>标志寄存器16位中只有9位有特殊作用</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>CF</td><td>0</td><td>PF</td><td>0</td><td>AF</td><td>0</td><td>ZF</td><td>SF</td><td>IF</td><td>DF</td><td>OF</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id="ZF"><a href="#ZF" class="headerlink" title="ZF"></a>ZF</h4><p>ZF含义是执行完指令后结果是否为0，为0,ZF=1，不为0,ZF=0</p><p>例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PERL"><figure class="iseeu highlight /perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,<span class="number">1</span> ;ZF=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">ax</span>,1 </span>;ZF=<span class="number">1</span></span><br></pre></td></tr></table></figure></div><h4 id="PF"><a href="#PF" class="headerlink" title="PF"></a>PF</h4><p>奇偶标志位，它记录相关指令执行后，其结果的所有bit为中1的个数是否为偶数，如果1的个数为偶数，pf=1,反之则为0</p><h4 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h4><p>符号标志位，看结果是否为负，如果为负，则SF=1</p><h4 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h4><p>进位标志位，一般情况下，对无符号数运算时，它记录了超过最高位的值</p><p>例如 ，add 255,255 这时已经超过最高位了，我们已经知道，超过最高位的数据都会被丢失，实际上它被保存在CF中，但只会保存一位</p><p>做减法时，还有可能发生错位，例如，两个8位数据，-4+5，将产生错位。错位后，相当于计算 252+5，超过255，因此会记录，因为无符号数中负数就是255-该值。<strong>小的减大的时会产生借位</strong></p><h4 id="OF"><a href="#OF" class="headerlink" title="OF"></a>OF</h4><p>溢出标志位，在有符号数运算时，可能会产生溢出，即小于最小值或大于最大值，如果超出，就会让OF=1</p><h4 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h4><p>adc是带进位加法指令，它利用了CF位上记录的进位值</p><p>格式 adc 对象1，对象2</p><p>功能 对象1=对象1+对象2+CF</p><p>例</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行后ax=4，adc执行时，相当于计算 ax+1+CF=2+1+1=4</p><p>这个指令有什么意义呢？实际上加法都可以分为两步操作，第一步是低位相加，第二步是高位相加再加上低位的进位，用汇编语言可以表示为</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="keyword">adc</span> <span class="number">ah</span>,<span class="number">bh</span></span><br></pre></td></tr></table></figure><p>这样我们就可以对更大的数据进行运算</p><p>例：计算1EF0001000H+2010001EF0H,结果放在ax（最高16位），bx，cx中<br>计算分三步</p><ol><li>先将低16位相加，完成后，CF记录本次进位值</li><li>再将中16位与CF相加，完成后，CF记录本次相加进位值</li><li>最后将高16位与CF相加<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">001eh</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0f000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">cx</span>,<span class="number">1ef0h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">0020h</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h4><p>带借位减法指令</p><p>格式 sbb 对象1，对象2</p><p>功能： 对象1=对象1-对象2-CF</p><h4 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h4><p>比较指令，相当于减法指令，但是不保存结果，只对标志寄存器产生影响</p><p>格式： cmp 对象1，对象2</p><p>功能： 对象1-对象2，但并不保存结果，对寄存器产生影响</p><p>例：</p><p>cmp ax，bx</p><ol><li><p>ax=bx，则ax-bx=0，zf=1</p></li><li><p>ax！=bx，则zf=0</p></li><li><p>ax&lt;bx, 将产生借位，cf=1</p></li><li><p>ax&gt;=bx, cf=0</p></li><li><p>ax&gt;bx ,不产生借位结果又不为0，所以zf=0，cf=0</p></li><li><p>ax&lt;=bx,可能产生借位结果也可能为0，所以zf=1或cf=1</p></li></ol><p>这是无符号位的，还有有符号位的</p><p>同理</p><ol><li>ax=bx，则zf=1</li><li>ax！=bx，zf=0</li></ol><p>但是这时就不能简单的用sf来判断了，因为sf只是符号标志位，它记录了计算结果的正负，但它并不能判断溢出。所以我们同时还要运用寄存器of来判断溢出</p><p>例： sf=1，of=0. of=0，说明没有溢出，直接用sf判断即可，sf=1说明ax&lt;bx</p><p>sf=1,of=1.这样就说明有溢出，<strong>因此说明是由于溢出导致结果为负，所以真正的结果必然为正</strong>，所以ax&gt;bx</p><p>sf=0,,of=1. 有溢出，ah&lt;bh</p><h4 id="标志寄存器在debug中的表示"><a href="#标志寄存器在debug中的表示" class="headerlink" title="标志寄存器在debug中的表示"></a>标志寄存器在debug中的表示</h4><table><thead><tr><th>标志</th><th>值为1的标记</th><th>值为0的标记</th></tr></thead><tbody><tr><td>of</td><td>ov</td><td>nv</td></tr><tr><td>sf</td><td>ng</td><td>pl</td></tr><tr><td>zf</td><td>zr</td><td>nz</td></tr><tr><td>pf</td><td>pe</td><td>po</td></tr><tr><td>cf</td><td>cy</td><td>nc</td></tr><tr><td>df</td><td>dn</td><td>up</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言写函数</title>
      <link href="/post/54613.html"/>
      <url>/post/54613.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>例,计算data段第一行的三次方，并储存到第二行上</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">    <span class="built_in">dd</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span></span><br><span class="line"><span class="symbol">  s:</span> <span class="keyword">mov</span> <span class="built_in">bx</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">call</span> cube</span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">di</span>].<span class="number">2</span>,<span class="built_in">dx</span> ；这个的含义是[<span class="built_in">di</span>]的第二个字节</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">4</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">cube:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"> code ends</span><br><span class="line"> end start</span><br></pre></td></tr></table></figure><p>这个程序函数是cube，注意想要跳转就用call，想要返回就用ret。这时返回值存在ax和dx中，参数在bx中，可如果有多个参数，寄存器不够时，可以用栈来传递参数</p><h3 id="用栈传递参数"><a href="#用栈传递参数" class="headerlink" title="用栈传递参数"></a>用栈传递参数</h3><p>例：计算（a-b）^3，a，b为字型数据<br>参数 进入子程序时，栈顶存放ip，后面依次存放a，b<br>结果：（dx：ax）=(a-b)^3<br></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">difcube:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">4</span>] <span class="comment">;将a的值送入栈中</span></span><br><span class="line">      <span class="keyword">sub</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">6</span>] ；减去b的值</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">ret</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><br>ret n的含义为，pop ip add sp，n<p></p><p>而ret 4 的原因是此时栈中有2个数据，要想把栈清空，要移动四个单位（字型）。而push bp ，pop bp 是为了保证bp中的数据没有改变</p><h3 id="寄存器冲突问题"><a href="#寄存器冲突问题" class="headerlink" title="寄存器冲突问题"></a>寄存器冲突问题</h3><p>例 将data段中的字母变为大写，以0结尾<br></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">   <span class="built_in">db</span> <span class="string">'fafdsfs'</span>,<span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">call</span> capital</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">5</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">capital:</span> <span class="keyword">mov</span> <span class="built_in">cl</span>,,[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">jcxz</span> ok</span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">jmp</span> short capital</span><br><span class="line"><span class="symbol">    ok:</span><span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><br>这个程序实际上是有问题的，因为进行一次capital后，cx的值一定为0，直接退出主程序的循环<p></p><p>要解决这个问题，有两种方案</p><ol><li>找另一个没有使用的寄存器</li><li>不要使用会发生冲突的寄存器</li></ol><p>这样实际上是不可能的，例如cx，循环便一定会冲突</p><p>解决方案就是，在进入函数前把所用到寄存器的内容保存起来，结束函数在进行使用</p><p>由此我们可以得到子程序设计的标准</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子程序开始： 子程序中使用的寄存器入栈</span><br><span class="line">         子程序内容</span><br><span class="line">         子程序所使用寄存器出栈</span><br><span class="line">         返回 （<span class="keyword">ret</span> ，<span class="keyword">retf</span>）</span><br></pre></td></tr></table></figure><p>这里要注意一个问题，当把寄存器内容入栈后，sp会发生改变，如果子程序中也要使用栈要注意地址的变化</p><p>同时还要注意入账和出栈的顺序<br>例<br></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">capital:</span> <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">      <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">cx</span></span><br></pre></td></tr></table></figure><br>后进先出<p></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mul指令</title>
      <link href="/post/40583.html"/>
      <url>/post/40583.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>两个相乘的数：</p><p>如果是8位，那么一个默认在al中，另一个在8位寄存器或内存字节单元中，如果是16位，一个在ax中，另一个在16位寄存器或内存字单元中</p><p>结果： 如果是8位，结果默认在ax中，如果是16位，高位默认在dx中，低位在ax中</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>call指令</title>
      <link href="/post/18912.html"/>
      <url>/post/18912.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>操作</p><ol><li>将当前的ip或cs压入栈中</li><li>转移</li></ol><p>这里的转移与jmp相同，也有位移和内存两种方式</p><h3 id="根据位移"><a href="#根据位移" class="headerlink" title="根据位移"></a>根据位移</h3><p>call 标号（将ip压入栈中后，转移到标号处进行指令）<br>过程：</p><ol><li>sp+=2，ss*16+sp=ip</li><li>ip=ip+16位位移</li></ol><p>16位位移=标号处地址-call指令后第一个字节的地址</p><p>相当于 push ip，jmp near ptr 标号</p><h3 id="根据目的地址"><a href="#根据目的地址" class="headerlink" title="根据目的地址"></a>根据目的地址</h3><p>call far ptr 实现段间转移</p><p>操作：</p><ol><li>sp-=2</li><li>ss*16+sp=cs</li><li>sp-=2</li><li>ss*16+sp=ip</li><li>cs=标号所在段地址，ip=；标号所在偏移地址</li></ol><p>段内转移一般是根据位移，段间转移一般是根据地址</p><p>如果地址在寄存器中， call reg，ip被修改</p><p>如果地址在内存中</p><p>1 call word ptr 内存地址</p><p>这种是段内转移，相当于 push ip，jmp word ptr</p><p>2 call dword ptr 内存地址</p><p>段间转移 例</p><p>call dword ptr ds：[0] ，这样ds:[0]和ds:[1]是ip ，ds:[2]和ds:[3]是cs</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret 和 retf</title>
      <link href="/post/29378.html"/>
      <url>/post/29378.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h3><p>ret指令用栈中的数据，修改ip中的内容，从而实现近转移</p><p>过程：</p><ol><li><p>ip=ss*16+sp</p></li><li><p>sp+=2</p></li></ol><p>相当于 pop ip</p><h3 id="retf"><a href="#retf" class="headerlink" title="retf"></a>retf</h3><p>修改cs和ip 的内容，实现远转移<br>过程</p><ol><li>ip=ss*16+sp</li><li>sp+=2</li><li>cs=ss*16+sp</li><li>sp+=2</li></ol><p>相当于 pop ip ，pop cs</p><p>例</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ss</span>:stack</span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这条指令相当于把ip变为0，指向第一条指令</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jmp进行跳转</title>
      <link href="/post/2647.html"/>
      <url>/post/2647.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="根据位移进行的转移"><a href="#根据位移进行的转移" class="headerlink" title="根据位移进行的转移"></a>根据位移进行的转移</h3><p>用jmp进行跳转时，会发现一个奇怪的问题，无论它要跳转到哪里，它的机器码始终不变，为EB03，那么它到底是怎么告诉cpu修改ip地址的呢？</p><p>先回忆一下cpu读取指令的过程</p><ol><li>cs=076a ip=0006，cs：ip指向eb03</li><li>读取指令码eb03到指令缓冲器</li><li>ip=ip+指令长度=0008h，cs：ip指向下一条指令</li><li>cpu执行指令缓冲器中的指令eb03</li><li>执行完缓冲器中的指令后，ip被修改+</li></ol><p>jmp指令并不需要转移的目的地址，但是它是凭借什么转移的呢？这里有个03，正好跳过三个字节之后就是要转移的地址。原来jmp指令只需知道当前指令的下一个指令（因为执行完这条指令后ip会增加）与要跳转的指令的位移就可以了</p><p>jmp short 标号 功能是 ip=ip+8位位移（一字节）</p><p>jmp near ptr 标号 是16位</p><p>jmp far ptr 标号 是段间转移，可以修改cs</p><p>还可以直接 jmp 寄存器1：寄存器2</p><h3 id="根据内存进行的转移"><a href="#根据内存进行的转移" class="headerlink" title="根据内存进行的转移"></a>根据内存进行的转移</h3><p>转移地址再内存中的转移有两种格式</p><ol><li>jmp word ptr（段内转移）</li></ol><p>例 jmp word ptr ds：[0]</p><p>jmp word ptr [bx]</p><p>2.jmp dword ptr (段间转移）后面接两个字，第一个是偏移地址，第二个是段地址</p><p>例 jmp dword ptr ds：[0],0 完成后段地址为0</p><p>注意</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">nop</span></span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,offset s</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,offset s2</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cs</span>:[<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="symbol">   s0:</span> <span class="keyword">jmp</span> short s</span><br><span class="line"><span class="symbol">   s1:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">       <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">   s2:</span> <span class="keyword">jmp</span> short s1</span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这个程序奇怪之处在于运行到mov cs：[di],ax后 s处会变为jmp 0000，这里就要记住jmp传递的是偏移地址，也就是说，jmp short s1这个指令并不是真的跳到s1处，而是往前跳8个字节</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作符offset</title>
      <link href="/post/59431.html"/>
      <url>/post/59431.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>offset是由编译器处理的符号，它的功能是获得标号的偏移地址</p><p>例</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset start//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">0</span></span><br><span class="line"><span class="symbol">   s:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset s//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">3</span></span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><p>上面的程序中offset获得了start和s的偏移地址0和3</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dup</title>
      <link href="/post/43878.html"/>
      <url>/post/43878.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>dup用来处理重复数据</p><p>例：db 3 dup (0) 这个意思是定义了三个0的字节型数据</p><p>db 3 dup （0,1,2) 定义了九个数据</p><p>db 3 dup (‘abc’,’ABC’)定义18个数据</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dd</title>
      <link href="/post/11051.html"/>
      <url>/post/11051.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>dd是用来定义双字型</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HASKELL"><figure class="iseeu highlight /haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> segment</span></span><br><span class="line">    dd <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> ends</span></span><br></pre></td></tr></table></figure></div><p>要注意dd要占两个字，db一个字节，dw一个字</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言数据位置的表达</title>
      <link href="/post/12334.html"/>
      <url>/post/12334.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h3><p>其实就是idata，这种数据执行前在cpu的指令缓冲器中，在汇编指令中直接给出</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>指令要处理的数据在寄存器中，在汇编指令中给出相应寄存器名</p><h3 id="段地址（SA）和偏移地址（EA"><a href="#段地址（SA）和偏移地址（EA" class="headerlink" title="段地址（SA）和偏移地址（EA)"></a>段地址（SA）和偏移地址（EA)</h3><p>这些数据在内存中，在汇编指令中可以用[x]的方式给出</p><h2 id="指令要处理数据有多长"><a href="#指令要处理数据有多长" class="headerlink" title="指令要处理数据有多长"></a>指令要处理数据有多长</h2><p>用寄存器的ax或al可以很方便的说明数据长度，但是如果是内存之间的传递可以用<br>x ptr 的方式确定是字型传递还是字节性传递</p><p>例： mov word ptr ds:[0],1</p><p>mov byte ptr ds:[0],1</p><p>另外，push操作无需指明，因为push只对字进行操作</p><h2 id="结构体的汇编表达"><a href="#结构体的汇编表达" class="headerlink" title="结构体的汇编表达"></a>结构体的汇编表达</h2><p>一般来说，我们可以用[bx+idata+si]的方式来表达结构体中的数据，用bx定位整个结构体，用idata定义某一个数据项，用si确定数据项中的一个元素</p><p>可以简写为 [bx].idata,[bx].idata[si]</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编中的多层循环</title>
      <link href="/post/6587.html"/>
      <url>/post/6587.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>因为唯一的用于统计循环次数的寄存器就是cx，所以有多层循环的时候就会碰到循环次数难以记录的问题，以下是一种解决办法</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span>//用另一个寄存器来存<span class="built_in">cx</span>的次数</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol"> s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>+<span class="built_in">bx</span>]</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">si</span>+<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">   <span class="keyword">loop</span> s</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>//这里把<span class="built_in">cx</span>次数取出来减一次</span><br><span class="line">   <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure><p>但是寄存器的数量是有限的，如果多次循环可能会导致寄存器不够用，因此可以先在数据段定义一个字型数据，然后直接把循环次数放到里面<br></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> </span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol">  s0:</span> <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">cx</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2</span></span><br><span class="line"><span class="symbol">  s:</span>  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">loop</span> s</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">     <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure><br>此外，还可以定义一个栈，直接用push，pop命令把cx值取出存入<p></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>si和di</title>
      <link href="/post/38145.html"/>
      <url>/post/38145.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>si和di在8086cpu中的功能与bx类似，si与di不能分为两个8位寄存器来使用</p><p>也就是说 ds：[si]是可以的</p><p>如果不用这些寄存器直接写的话就会出现之前所说的编译器和exe对程序的不同处理</p><p>例 mov ax,[si]在exe中就是 ds：[si]，但是如果是 mov，ax,[1]在exe中就是把ax中的数据放入1中</p><p>甚至可以直接用[bx+si]的方式或[bx+si+idata]的方式来指明内存地址</p><h3 id="不同寻址方式的比较"><a href="#不同寻址方式的比较" class="headerlink" title="不同寻址方式的比较"></a>不同寻址方式的比较</h3><p>[idata]用于一个常量的寻址，直接定位一个内存单元</p><p>[bx]用于一个变量来表示内存地址，间接定位内存单元</p><p>只有bx,bp,di,si具有寻址能力，例如ds:[dx]等都是错误的</p><p>并且这几个寄存器间组合还有要求，只有bx+si,bx+di,bp+si,bp+di这四种情况是正确的</p><p>只要使用bp，它的段寄存器默认为ss</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符形式 的数据</title>
      <link href="/post/30072.html"/>
      <url>/post/30072.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>首先要知道asc11码</p><p>形式： db ‘…’</p><p>无论多少个单词都只需要单引号</p><p>例 db‘unix’</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>将不同代码放入不同段中</title>
      <link href="/post/41840.html"/>
      <url>/post/41840.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>举个栗子</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code <span class="built_in">ds</span>:data <span class="built_in">ss</span>:stack</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0345h</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">20h</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span> //<span class="built_in">ds</span>:<span class="built_in">bx</span>指向data中第一个内存单元</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s0:</span><span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s0</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"> code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>看了这个就差不多了，前面定义的时候要注意不同段对应不同的寄存器，而后面要注意各个段有独自的segment与ends，而且从start开始要把各个段寄存器赋值，以备后面使用（mov ax，data）<strong>注意</strong> mov ds，data是错误的，8086cpu不允许直接把一个数值送入段寄存器中</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在代码段中使用栈</title>
      <link href="/post/44487.html"/>
      <url>/post/44487.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>实际上栈是我们人为定义的一段内存空间，所以先要用dw来申请</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>  //申请<span class="number">6</span>个字的内存空间，栈是由高内存地址到低内存地址，所以栈顶为<span class="built_in">cs</span>：<span class="number">Ch</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">Ch</span></span><br></pre></td></tr></table></figure><p>ss，sp就是前面所说的栈的指针</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dw</title>
      <link href="/post/58986.html"/>
      <url>/post/58986.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri May 15 2020 17:23:19 GMT+0800 (中国标准时间) --><p>dw即define word，定义字型数据。例如，dw 0123h,0456h,0789h.这样就定义了几个字型数据，那这些数据都在哪里呢，他们的段地址都是从cs开始的，而偏移地址从0开始，也就是说，0123h的偏移地址是0,0456h的偏移地址是2,0789h的偏移地址是6。</p><p>但是这样会带来一个问题，因为前十六个字节是dw所定义的字型数据，所以这样可能使程序的入口出现问题，所以可以</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span> <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里就是加上了一个标号start，这个标号的意思就是确定程序的入口，而最后在end这里还要来一个start，因为end的作用除了确定程序在哪里终止之外，还有一个作用是告诉编译器程序在哪里开始（因为这时一个伪指令）</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编指令学习（待补充）</title>
      <link href="/post/47075.html"/>
      <url>/post/47075.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><ul><li>mov 内存地址1：内存地址2。把地址上的数据从2赋值到1</li><li>sub 。。。 数据1-数据2</li><li>add 。。。 +</li><li>inc 寄存器 让寄存器上的数据+1</li><li>dw “define word” 定义字型数据</li><li>and 逻辑与命令，按位进行与运算 可以通过该命令将相应为变为0，其他位不变</li></ul><p>例如：</p><pre><code>mov al,01100011band al,00111011b</code></pre><p>执行后al=00100011b</p><ul><li>or 按位进行或运算 前面一个例子，如果是or的话为01111011b，可以通过该命令将相应位变为1，其他为不变</li><li>db，字符型数据</li><li>ptr word ptr,byte ptr ,确定是什么数据</li><li>div 除法指令，被除数要比除数多8位，如果除数为8位，被除数为16位，除数为16位，被除数为32位，被除数可以用dx和ax存放</li></ul><p>如果除数为8位，则用al储存商，ah储存余数，如果除数为16位，则用ax储存商，dx储存余数</p><p>例： div bl 这个就是除数为8位，默认被除数是ax</p><p>div bx 这个除数是16位，则要用dx和ax两个寄存器来储存被除数，先转为16进制，dx储存高位，ax储存低位</p><p>例 计算 100001/100<br>被除数大于65536，因此要用32位 寄存器，100001的16进制是186A1h<br></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>，<span class="number">1h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">86A1h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">100</span></span><br><span class="line"><span class="keyword">div</span> <span class="built_in">bx</span></span><br></pre></td></tr></table></figure><p></p><ul><li>diwdw（这不是关键字，这是一个子程序） 进行不会产生除法溢出的运算，被除数为dword型，除数为word型，结果为dword型</li></ul><p>参数： ax=dword 型数据低十六位</p><pre><code>dx=高十六位cx=除数</code></pre><p>返回：dx=结果高十六位，ax=结果低十六位 cx=余数</p><p>原理（公式）：x/n=int(h/n)<em>65536+[rem(h/n)</em>65536+l]/n</p><p>x：被除数 ， n：除数 h :x高十六位 ，l :x低十六位，int（）:取商，例 int（38/10)=3,rem()：取余数</p><ul><li>dd 双字型</li><li>dup 用于数据的重复</li><li>jmp 用于跳转</li><li>jcxz 格式 jcxz 标号（如果cx=0，则跳转到标号处运行） 这是短指令</li><li>ret 用栈数据修改ip</li><li>retf 用栈数据修改cs和ip</li><li>call 先把ip存入栈，再跳转</li><li>call far ptr 先存 ip，再存cs，再跳转</li><li>call word ptr 根据内存</li><li>mul 乘法指令</li><li>offset 获取标号的偏移地址</li><li>adc 带进位加法指令</li><li>sbb 带借位减法指令</li><li>cmp 比较指令</li><li>j… 例 je ja jb 带条件跳转指令</li><li>movsb， movsw ，串传送指令</li><li>rep 根据cx的值，重复执行串传送指令</li><li>cld df=0</li><li>std df=1</li><li>pushf，将标志寄存器的值压入栈</li><li>popf，将标志寄存器的值弹出栈</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>debug和源程序对指令的不同处理</title>
      <link href="/post/54300.html"/>
      <url>/post/54300.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3><a href="#" class="headerlink" title="[]"></a>[]</h3><p>debug程序中[0]表示 ds：0处的数据进行处理</p><p>而源程序中表示把0这个数据给要处理的数据</p><p>例 mov ax,[0]在debug中表示把ds：0处元素给ax，而在源程序中表示把0给ax</p><p>在程序中，可以直接使用段寄存器加偏移地址来确定访问的元素，例如：ds：[bx],cs:[bx],ss:[bx]等</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[bx]和loop</title>
      <link href="/post/3320.html"/>
      <url>/post/3320.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h3><p>mov ax,[bx]</p><p>这个的意思是把ds：bx处的内容放入ax中</p><p>mov [bx],ax</p><p>这个的意思是把ax中的内容放入 地址ds：bx处</p><h3 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h3><p>实际上还有更加灵活的方式指明内存地址，就是bx后加一个数据，这个数据可以是常数，也可以是变量</p><p>例 mov ax,ds:[bx+200]，也可以直接写为ds：200[bx]</p><p>这种处理方式可以方便的处理数组</p><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>格式：loop+标识符</p><p>执行过程：执行到loop时，先让cx-=1,再判断cx中的值，不为0则转至标号处继续执行，为0则进行下一步操作，寄存器cx用来储存循环次数</p><p>例</p><pre><code>mov cx,3mov ax,2s: add ax,ax  loop s</code></pre><p>这段程序的作用是计算2的三次方，首先让循环次数为3，ax=2，再从s处开始循环，当cx=0时退出，即进行3次</p><h3 id="用debug跟踪loop指令"><a href="#用debug跟踪loop指令" class="headerlink" title="用debug跟踪loop指令"></a>用debug跟踪loop指令</h3><p>tip：汇编程序中，数据不能以字母开头，所以如A231h等等前面都要加一个零</p><p>如果想直接结束循环可以用p命令，如果用t命令的话，只会结束这一次循环</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序执行过程的跟踪</title>
      <link href="/post/7564.html"/>
      <url>/post/7564.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>运用debug +程序名进入debug过程</p><p>例如 debug 1.exe</p><p>程序开始都是从0000的偏移地址开始的，设段地址为A，而程序开始有一段不做该程序内容，而有其他用途。这段程序占256个字节，叫psp，之后段地址偏移10h，所以真正的程序是从A+10:0 开始的（256个字节在16进制中是10，而A也是用16进制表示的）</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从asm到exe</title>
      <link href="/post/28954.html"/>
      <url>/post/28954.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>先要有masm.exe和link.exe，然后输入masm+程序名和link+程序名</p><p>或者masm+盘符+程序名，可以省略中间过程，节省时间<br>例：masm c:\1.asm</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编的第一个程序</title>
      <link href="/post/48220.html"/>
      <url>/post/48220.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>编译器中，包含两种指令，一种是汇编指令，一种是伪指令。伪指令是给编译器看的，最终不会被cpu执行。先了解三个最为基础的伪指令</p><ul><li>XXX segment，XXX ends，这两个是配套使用的。功能是定义一个代码段，一个段必须要有一个名称标识（XXX是也）</li></ul><p>例如codesg segment ，codesg ends</p><ul><li>assume</li></ul><p>这条指令作用是假设某一寄存器和程序中的某一个用segment和ends定义的段相关联，写在最开头。</p><ul><li>end</li></ul><p>没什么特别的，程序的结束标识，不写程序不知道在哪里结束</p><h3 id="一个程序"><a href="#一个程序" class="headerlink" title="一个程序"></a>一个程序</h3><pre><code>assume cs: codesgcodesg segment    mov ax,0123    mov bx,0456    add ax,bx    mov ax,4c00    int 21codesg endsend</code></pre><h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>在单任务操作系统上，一次只可以执行一个程序，那么当我们写的这个程序执行完之后，还要把cpu控制权交给dos，而mov ax，4c00 和 int 21 就是做这个工作的</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈.                                      </title>
      <link href="/post/51491.html"/>
      <url>/post/51491.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>栈是一段连续的内存空间，这个空间的特殊性在于，最后进入这个空间的数据，最先出去</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过ss sp 两个寄存器确定了一个栈顶指针，然后随着一些操作，这个指针会向上向下移动<br>例如 push ax，这条指令会将ax中的内容运到栈中，然后sp-2。<strong>注意</strong>，栈顶地址为低地址，栈底地址为高地址，因此增加元素会使sp值减小</p><p>在栈为空的时候，偏移地址为栈底地址加2，例如栈底为000F，则此时偏移地址为10，在拉一个元素进栈后，偏移地址为000E，恰好是数据最高位（一个数据一个字，两个字节，栈底为000F，用了两个空间，因此此时元素到了000E，恰好sp也是000E</p><h3 id="超界问题"><a href="#超界问题" class="headerlink" title="超界问题"></a>超界问题</h3><p>8086cpu并没有特定的机制来检查我们是否超界，只能够靠自己小心，超界是一个十分严重的问题，因为既然这一段被分配为栈了，说明其他的内存有其他的用途，如果超界，可能会干扰其他程序的运行。要注意，栈的范围最大是0到ffff即2的16次方字节</p><h3 id="push-pop-命令"><a href="#push-pop-命令" class="headerlink" title="push pop 命令"></a>push pop 命令</h3><p>push 寄存器 pop 寄存器<br>也可以是push内存地址，pop内存地址</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>debug</title>
      <link href="/post/41129.html"/>
      <url>/post/41129.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>这里列举几个debug的基本命令</p><h4 id="r"><a href="#r" class="headerlink" title="r"></a>r</h4><p>用来查看此时寄存器内的数值和下一步将要执行的命令<br>r 还可以接寄存器，用于修改寄存器内的内容<br>例：r ax 这样会出现ax的内容和一个冒号，然后就可以输入数据修改了</p><h3 id="d"><a href="#d" class="headerlink" title="d"></a>d</h3><p>格式：d 段地址：偏移地址<br>作用：列举出该地址下的机器码<br>例 d 1000:0,这样子将会列举从1000:0 到1000:7f的所有内容</p><h3 id="e"><a href="#e" class="headerlink" title="e"></a>e</h3><p>格式：e 段地址：偏移地址<br>作用：修改改地址下的机器码</p><h3 id="t"><a href="#t" class="headerlink" title="t"></a>t</h3><p>执行cs ip所指向内存地址的命令，直接输入t，不需要输入其他东西</p><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>作用：用汇编语言输入指令到内存上<br>写法： a 段地址：偏移地址<br>例： a 1000:0<br>输出1000：0 （input）mov ax，1<br>然后1000:0 到1000:3 就会输入这条指令了，之后将cs ip地址设置一下，然后用t指令运行</p><h3 id="u"><a href="#u" class="headerlink" title="u"></a>u</h3><p>作用：查看某地址下的汇编程序<br>写法： u 段地址：偏移地址<br>例 u 1000:0<br>然后就会输出1000:0 开始有的汇编指令了</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组和线段树</title>
      <link href="/post/58481.html"/>
      <url>/post/58481.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="lowbit函数"><a href="#lowbit函数" class="headerlink" title="lowbit函数"></a>lowbit函数</h3><p>lowbit函数指的是将元素与元素的补码按位与，即a&amp;-a，这个值返回的是从右数第一个1开始的值</p><p>例如 6&amp;-6， 6二进制位为110，所以6的lowbit函数值为10，即十进制下的二</p><pre><code>ll lowbit(ll num){    return num&amp;-num;}</code></pre><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>首先我们可以把一整个数组分为若干小部分，然后让这几个小部分叠加就可以得到数组总的和。例如，我想求a[91],我可以先求c[88],发现c[88]管理2个数，再找c[86]，这样一直进行下去就可以了。</p><p>c又是什么呢？例如c[6]，它的lowbit函数为2，因此它管理两位数，所以c[6]=a[5]+a[6]</p><p>奇数位的c[i]只有他自己，而偶数位c[i]为2的k次方</p><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">add</span>(int <span class="keyword">x</span>, int k) &#123;</span><br><span class="line">  while (<span class="keyword">x</span> &lt;= n) &#123;  //不能越界</span><br><span class="line">    <span class="keyword">c</span>[<span class="keyword">x</span>] = <span class="keyword">c</span>[<span class="keyword">x</span>] + k<span class="comment">;</span></span><br><span class="line"><span class="comment">    x = x + lowbit(x);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这个函数是把a[x]加上k，小于x的c不用修改</p><p>关键是x=x+lowbit(x)<br><img src="/images/1103198-20180725163149813-311841231.png" alt><br>从此图中我们可以看出，要想求偶数位节点大小，需要将所有子节点加起来，先要加自己和比自己小一位的奇数，再加上所有i+lowbit(i)=8的偶数</p><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GML"><figure class="iseeu highlight /gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int getsum(int <span class="symbol">x</span>) &#123;  <span class="comment">// a[1]……a[x]的和</span></span><br><span class="line">  int ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keywords">while</span> (<span class="symbol">x</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ans = ans + c[<span class="symbol">x</span>];</span><br><span class="line">    <span class="symbol">x</span> = <span class="symbol">x</span> - lowbit(<span class="symbol">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keywords">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">  <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; ++<span class="built_in">i</span>) &#123;</span><br><span class="line">    t[<span class="built_in">i</span>] += a[<span class="built_in">i</span>];</span><br><span class="line">    int <span class="built_in">j</span> = <span class="built_in">i</span> + lowbit(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">j</span> &lt;= n) t[<span class="built_in">j</span>] += t[<span class="built_in">i</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> kth(<span class="built_in">int</span> k) &#123;  <span class="comment">//权值树状数组查询第k小</span></span><br><span class="line">  <span class="built_in">int</span> cnt = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = log2(n); ~i; --i) &#123;</span><br><span class="line">    ret += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= n || cnt + t[ret] &gt;= k)</span><br><span class="line">      ret -= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cnt += t[ret];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>含义：线段树指的是将一个区间不断二分所形成的一个二叉树，根结点代表arr[0:N]区间所对应的信息，接着根结点被分为两个子树，分别存储arr[0:(N-1)/2]及arr[(N-1)/2+1:N]两个子区间对应的信息</p><p>初始化：注意此处我们对于segmentTree]数组的索引从1开始算起。则对于数组中的任意结点i，其左子结点为<code>2*i</code>，右子结点为<code>2*i + 1</code>，其母结点为i/2。<br><img src="/images/%E5%9B%BE%E7%89%879.png" alt><br><img src="/images/%E5%9B%BE%E7%89%8710.png" alt><br><img src="/images/%E5%9B%BE%E7%89%878.png" alt><br>递归实际意义是先向底层递归，然后从底层向上回溯，p的意思是节点的编号</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> build(<span class="built_in">int</span> s, <span class="built_in">int</span> t, <span class="built_in">int</span> p) &#123;</span><br><span class="line">  <span class="comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">  <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">int</span> m = (s + t) / <span class="number">2</span>;</span><br><span class="line">  build(s, m, p * <span class="number">2</span>), build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p>区间修改指的是把区间内连续多个数同时修改</p><p><img src="/images/%E5%9B%BE%E7%89%8711.png" alt>标记的作用是记录每次、每个节点要更新的值</p><p>另一种写法</p><p><img src="/images/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt></p><p>当使用lazy函数时，会让下一层的数加上相应的数并附上相应懒标记，同时根节点的懒标记将被清除，这样一层层往下就可以让每一个数都加上该值</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span>;</span><br><span class="line">    <span class="built_in">int</span> lz;</span><br><span class="line">&#125;sgm[<span class="built_in">MAX</span>*<span class="number">4</span>];</span><br><span class="line">#define <span class="built_in">mid</span> ((l+r)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">#define lc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">#define rc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">voide lazy(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> l,<span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">/*懒标记的作用是标记当前区间应该加上/减去的值，但是先不直接加，而是进行标记*/</span><br><span class="line">    sgm[lc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[lc].<span class="built_in">sum</span>+=(<span class="built_in">mid</span>-l+<span class="number">1</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].<span class="built_in">sum</span>+=(r-<span class="built_in">mid</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[<span class="built_in">n</span>].lz=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p><img src="/images/%E5%9B%BE%E7%89%8712.png" alt></p><p>这里的push_down就是另一种写法中的lazy</p><p>总代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define lc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">#define rc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">#define <span class="built_in">mid</span> ((l+r)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">#define <span class="built_in">MAX</span> <span class="number">100</span></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span>;</span><br><span class="line">    <span class="built_in">int</span> lz;</span><br><span class="line">&#125;sgm[<span class="built_in">MAX</span>*<span class="number">4</span>];</span><br><span class="line">void lazy(<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sgm[lc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[lc].<span class="built_in">sum</span>+=(<span class="built_in">mid</span>-l+<span class="number">1</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].<span class="built_in">sum</span>+=(r-<span class="built_in">mid</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[<span class="built_in">n</span>].lz=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">void build(<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> a[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=a[l];</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    build(l,<span class="built_in">mid</span>,lc,a);</span><br><span class="line">    build(<span class="built_in">mid</span>+<span class="number">1</span>,r,rc,a);</span><br><span class="line">    sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=sgm[lc].<span class="built_in">sum</span>+sgm[rc].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line">void update(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> L,<span class="built_in">int</span> R,<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>+=(r-l+<span class="number">1</span>)*num;</span><br><span class="line">        sgm[<span class="built_in">n</span>].lz+=num;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy(l,r,<span class="built_in">n</span>);</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(lc,L,R,l,<span class="built_in">mid</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(R&gt;<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(rc,L,R,<span class="built_in">mid</span>+<span class="number">1</span>,r,num);</span><br><span class="line">    &#125;</span><br><span class="line">    sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=sgm[lc].<span class="built_in">sum</span>+sgm[rc].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> ask(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> L,<span class="built_in">int</span> R,<span class="built_in">int</span> l,<span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        return sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy(l,r,<span class="built_in">n</span>);</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=ask(lc,L,R,l,<span class="built_in">mid</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(R&gt;<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=ask(rc,L,R,<span class="built_in">mid</span>+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a[<span class="number">10</span>];</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>,a);</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;sgm[i].<span class="built_in">sum</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    update(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ask(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串之KMP算法</title>
      <link href="/post/57671.html"/>
      <url>/post/57671.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="由（扯）来（蛋）"><a href="#由（扯）来（蛋）" class="headerlink" title="由（扯）来（蛋）"></a>由（扯）来（蛋）</h3><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这三人的姓氏命名此算法。</p><h3 id="最长前缀和与后缀和"><a href="#最长前缀和与后缀和" class="headerlink" title="最长前缀和与后缀和"></a>最长前缀和与后缀和</h3><p>例如给出一个字符串ABCDABD<br><img src="/images/331.jpg" alt><br>前缀和就是从前往后数i个，后缀和是从第n-i个数到最后一个，首先我们便要找到每一个字母的最长相同前缀后缀和，然后求next数组，注意，只有一个元素时是不计算前缀后缀的，直接看为0</p><h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>next数组考虑的是除当前字符外的最长相同前缀后缀，实际上就是前一个前缀后缀和，因为把最后一个字母上去之后必定会使后缀和少一个，因此前缀后缀和也会-1，注意next数组中会出现-1，<strong>实际上这个数组就是将原数组整体右移一位，然后在第0位补上-1</strong></p><p><img src="/images/3331.jpg" alt></p><p><img src="/images/3332.jpg" alt></p><h3 id="用next数组进行匹配"><a href="#用next数组进行匹配" class="headerlink" title="用next数组进行匹配"></a>用next数组进行匹配</h3><p>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀 pj-k pj-k+1, …, pj-1 跟文本串 si-k si-k+1, …, si-1 匹配成功，但 pj 跟 si 匹配失败时，因为 next[j] = k，相当于在不包含 pj 的模式串中有最大长度为 k 的相同前缀后缀，即 p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令 j = next[j]，从而让模式串右移 j - next[j] 位，使得模式串的前缀 p0 p1, …, pk-1 对应着文本串 si-k si-k+1, …, si-1，而后让 pk 跟 si 继续匹配。如下图所示：<br><img src="/images/323.jpg" alt></p><p><strong>解释</strong>：因为前缀和后缀和相等，当最后一个匹配失误的时候就可以直接跳到后缀和开始的地方，这样就一下子匹配到了几位数，加快速度，至于合理性 ，K M P 这三个人已经证明过，而具体要跳几位呢？</p><p>比如说你有7个数，前面6个数已经匹配好了，结果第七位出了问题，这时一找next数组，发现第6位前缀和为2，那我们就要跳到第五位上去，找找规律，就是j-next[j]呀，没错，就是要跳这么多位，忘了自己推一下就好了，挺好推的</p><p><strong><em>失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</em></strong></p><h3 id="next数组求法"><a href="#next数组求法" class="headerlink" title="next数组求法"></a>next数组求法</h3><p>这里运用了递归的思想，首先对于前一两个可以直接写出来，然后对于后面的，假如第j个next值我们已经求出来了，那么对于第j+1个，</p><ol><li>如果p[k]=p[j]，则next[j+1]=k+1</li></ol><p>例如<img src="/images/3343.jpg" alt><br>C为p[j]，E为p[j+1]，next[j]=2,则第一，第二个与第五，第六个相同，如果第三个和3七个相同，则最大相同长度就为3，即p[k]=p[j]</p><p>2.如果p[k]!=p[j],则递归找p[next[k]]是否等于p[j]，p[next[next[k]]]是否等于p[j],直到找到或到了开头</p><p>对于第二种情况，也可以通过图来展示<br><img src="/images/3344.jpg" alt><br>现在p[j]!=p[k]，那么肯定要缩小范围，我么已经知道第一个与第二个是匹配的了，那么第五个第六个对应与第一个第二个匹配，但如果那里面没有前后缀的话，你减去一个就相当于破坏了结构（前缀从前往后，后缀也是从前往后，减去一个便要求这这个前缀串里面前几个要和后缀串里面后面几个匹配，因此要求next[k]就是为了里面要匹配，这样只需比较p[next[k]]和p[j]即可），假如中间就碰到了，那么next[j+1]=next[next[k]]+1,如果没碰到，那么next[j+1]=0（一朝回到解放前）</p><p>代码实现：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> GetNext(char* p,<span class="built_in">int</span> next[])  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">int</span> pLen = strlen(p);  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k;  </span><br><span class="line">            ++j;  </span><br><span class="line">            next[j] = k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="nextval"><a href="#nextval" class="headerlink" title="nextval"></a>nextval</h3><p>nextval是next的进阶版。例如某一位是next[5]，但是next[5]和5的字符相同，这样肯定还是不行，所以多比了一次。</p><p>nextval判断方法：在next的基础上,s是用来匹配的串</p><p>s[next[i]] = s[i], 继续比较。如果next[i]和next[next[i]]还是相同，那么要继续比，直到不相同或者过了第一个为止</p><p>s[next[i]] != s[i] , nextval[flag] = next[i]</p><h3 id="匹配（最终代码）"><a href="#匹配（最终代码）" class="headerlink" title="匹配（最终代码）"></a>匹配（最终代码）</h3><p>匹配过程：</p><p>“假设现在文本串S匹配到 i 位置，模式串 P 匹配到 j 位置</p><p>如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符；</p><p>如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j] 位。</p><p>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。”</p><p>例 <img src="/images/3353.png" alt></p><p>例如此时i=10,j=6,此时文本串该位为空格，而匹配串为D，这时不匹配，就要让匹配串移动6-next[6]=4位，我令i=10,j=2,即匹配串为C,这就相当于让匹配位左移4位，而文本对应位不变，于是相当于匹配串右移4位（有种物理相对运动的既视感）</p><p>代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      </span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      </span></span><br><span class="line">            <span class="comment">//next[j]即为j所对应的next值        </span></span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>感到了代码的优美感有没有！</p><p>但是这样还可以优化</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AWK"><figure class="iseeu highlight /awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>优化过后的<span class="keyword">next</span> 数组求法  </span><br><span class="line">void GetNextval(char* p, int <span class="keyword">next</span>[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int pLen = strlen(p);  </span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;  </span><br><span class="line">    int k = -<span class="number">1</span>;  </span><br><span class="line">    int j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">//</span>p[k]表示前缀，p[j]表示后缀    </span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k])  </span><br><span class="line">        &#123;  </span><br><span class="line">            ++j;  </span><br><span class="line">            ++k;  </span><br><span class="line">            <span class="regexp">//</span>较之前<span class="keyword">next</span>数组求法，改动在下面<span class="number">4</span>行  </span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])  </span><br><span class="line">                <span class="keyword">next</span>[j] = k;   <span class="regexp">//</span>之前只有这一行  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="regexp">//</span>因为不能出现p[j] = p[ <span class="keyword">next</span>[j ]]，所以当出现时需要继续递归，k = <span class="keyword">next</span>[k] = <span class="keyword">next</span>[<span class="keyword">next</span>[k]]  </span><br><span class="line">                <span class="keyword">next</span>[j] = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            k = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里有点蒙，就先这样吧</p><p><a href="https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html" target="_blank" rel="external nofollow noopener noreferrer">参考文章（这篇文章真的太好了，生怕你不会）</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串之hash算法</title>
      <link href="/post/11491.html"/>
      <url>/post/11491.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="hash基础概念"><a href="#hash基础概念" class="headerlink" title="hash基础概念"></a>hash基础概念</h3><p>但在工程实践中，要查找的关键字往往都不是自然数，即使是自然数也有可能是很大的值。因此，只要我们提前把关键字转换为在固定较小范围内的自然数，就可以实现常数时间的查找。那么问题来了，如何实现该转换关系呢？这就是哈希函数所要完成的工作。</p><p>哈希函数：又称散列函数，是把一段有限二进制串（字符串，整数等）转换为自然数的一种函数。</p><p>哈希值：哈希函数输出的最终结果。</p><p>字符串哈希函数：输入是字符串的哈希函数。</p><p>注：实际上就是用一个函数将字符串转化为整数，然后尽可能使一个整数对应一个字符串</p><p>现在的哈希函数基本上都是满射，多个字符串会对应一个数字，这种情况佳作冲突，为了减小冲突，列举几种方法</p><p><img src="/images/%E5%9B%BE%E7%89%876.png" alt><br>这种方法就是用进制转换的观念，一般用128,但这样十分容易超int型的范围，因此要想办法减小范围，可以用一个较大的数去摸，这时又出现了冲突的问题，那可以用两个数同时去摸，这样用两个数表示一个字符串冲突的几率便大大降低</p><p>BKDRHash算法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BKDR Hash Function</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);<span class="comment">//ox7FFFFFFF代表int型最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&amp;是与运算符，<a href="https://blog.csdn.net/ssdjdk/article/details/90199634" target="_blank" rel="external nofollow noopener noreferrer">详细看这</a></p><p>关于 <a href="https://blog.csdn.net/MyLinChi/article/details/79509455" target="_blank" rel="external nofollow noopener noreferrer">BKDRHash算法可以看</a></p><p>最好用unsigned int 类型，<a href="https://www.cnblogs.com/lailailai/p/4030151.html" target="_blank" rel="external nofollow noopener noreferrer">这样相当于每次hash操作都取了一次模</a></p><p>APhash算法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LISP"><figure class="iseeu highlight /lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// AP Hash Function</span><br><span class="line">unsigned int APHash(<span class="name">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int hash = 0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    for (i=0; *str<span class="comment">; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if ((<span class="name">i</span> &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= ((<span class="name">hash</span> &lt;&lt; <span class="number">7</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">3</span>))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= (~((<span class="name">hash</span> &lt;&lt; <span class="number">11</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">5</span>)))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return (<span class="name">hash</span> &amp; <span class="number">0</span>x7FFFFFFF)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/MyLinChi/article/details/79508112" target="_blank" rel="external nofollow noopener noreferrer">这篇博客讲的很详细</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/post/55046.html"/>
      <url>/post/55046.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon May 25 2020 13:31:40 GMT+0800 (中国标准时间) --><h3 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h3><p>无后效性是一个问题可以用动态规划求解的标志之一，理解无后效性对求解动态规划类题目非常重要</p><p>概念：某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响（某度上找的定义）</p><p>理解：无后效性指的是之前做过的事现在还可以继续去做，这便是前一阶段做的事对后一阶段无影响。如果前面做过了后面便不能去做或者做的事受限这便是有后效性</p><p>例：<a href="https://blog.csdn.net/qq_30137611/article/details/77655707" target="_blank" rel="external nofollow noopener noreferrer">这篇博客讲的很清楚</a></p><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p><a href="https://xinhecuican.github.io/post/21624.html">之前的一篇博客</a></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Good&#123;</span><br><span class="line"><span class="code">    int w;</span></span><br><span class="line"><span class="code">    int v;</span></span><br><span class="line">&#125;goods[101];</span><br><span class="line">int dp[<span class="string">101</span>][<span class="symbol">1001</span>];</span><br><span class="line">int n,S;//n表示有n个物品，S表示背包的最大容积</span><br><span class="line">for (i = 1; i <span class="xml"><span class="tag">&lt;<span class="name">=</span> <span class="attr">n</span>; <span class="attr">i</span>++)</span></span></span><br><span class="line"><span class="xml">&#123;</span></span><br><span class="line"><span class="xml">    for (j = S; j &gt;</span>= goods[i].w; j--)</span><br><span class="line"><span class="code">        dp[j] = max(dp[j], dp[j - goods[i].w] + goods[i].v);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这段代码中，之所将j初始化为S，逆序循环更新状态是为了保证在更新dp[j]时，dp[j-goods[i].w]的状态尚未因为本次更新而发生改变，即等价于由</p><p>dp[i-1][j-goods[i].w]转移得到dp[i][j]。保证了更新dp[j]时，dp[j-goods[i].w]是没有放入物品i时的数据dp[i-1][j-goods[i].w]。</p><p>实际上01背包问题同一种思路代码写法有两种，如果s从0开始遍历就不需要逆序，但是从大于w[i]开始就需要逆序</p><p>实际上这里的二维数组可以优化变为一维数组</p><p>dp[i][j] = max{dp[i-1][j-w[i]]+v[i]，dp[i-1][j]，这里的i与i-1实际上是第i个物体与第i-1个物体，而这个可以用数组下标直接代替，这样便可以用一维数组解决背包问题，但是一维数组与二维数组的区别是二维数组保存了前i个物品所可以获得的最大价值，而一维数组只能保存题目要求的s个物品的最大价值，因此用一维还是用二维因题目而异</p><p>dp[j] = max{dp[j]，dp[j-w[i]]+v[i]}。从这个方程中我们可以发现，有两个dp[j]，但是要区分开。等号左边的dp[j]是当前i的状态，右边中括号内的dp[j]是第i-1状态下的值。</p><p>所以为了保证状态的正确转移，我们需要先更新等号左边中的dp[j]（当前状态的dp[j]）。</p><p>代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,maxv;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;maxv;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">1001</span>],v[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxv;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=maxv;k&gt;=w[i];k--)<span class="comment">/*这里是因为当背包体积小于物品体积时不可能成立，相当于if(k&lt;w[i])&#123;dp[i][k]=dp[i-1][k];&#125;*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[k]=<span class="built_in">max</span>(dp[k],dp[k-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[maxv]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>拓展问题</p><p>继续0-1背包问题，如果在上面的问题加上一个限制条件，所选择的物品必须恰好装满背包，否则输出-1。这时数组初始化为负无穷</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">int w<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int v<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int maxv;</span><br><span class="line">int n;</span><br><span class="line">int dp<span class="comment">[MAXSIZE]</span><span class="comment">[MAXSIZE]</span>;</span><br><span class="line"></span><br><span class="line">int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &gt; b)</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxv;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w<span class="comment">[i]</span> &gt;&gt; v<span class="comment">[i]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化，当容积为0时，即不能装入，最大价值即为0</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[0]</span> = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化为-1，表示没有装满</span><br><span class="line">    for (int i = 0; i &lt;= n; i++)</span><br><span class="line">    for (int j = 1; j &lt;= maxv; j++)</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[j]</span> = -1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = maxv; j &gt;= w<span class="comment">[i]</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1表示容积为j - w<span class="comment">[i]</span>时没有装满，所以当容积为j，装w<span class="comment">[i]</span>时一定不能装满</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt; dp<span class="comment">[i-1]</span><span class="comment">[j]</span>表示装入物品i时签好装满并且总价值比前i-1个物品的总价值要大</span><br><span class="line">            if (dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1 &amp;&amp; dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt;= dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>)</span><br><span class="line">                dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = w<span class="comment">[i]</span> - 1; j &gt;= 1; j--)</span><br><span class="line">            dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp<span class="comment">[n]</span><span class="comment">[maxv]</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它大致相同，现在dp[i][j]表示的是恰好装j空间时价值的最大值</p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>题目：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (j = goods<span class="comment">[i]</span>.w; j &lt;= S; j++)</span><br><span class="line">        dp<span class="comment">[j]</span> = max(dp<span class="comment">[j]</span>, dp<span class="comment">[j - goods<span class="comment">[i]</span>.w]</span> + goods<span class="comment">[i]</span>.v);</span><br><span class="line">&#125;//不是很理解，但是先把模板记下吧</span><br></pre></td></tr></table></figure><p>这个代码和01背包代码十分相似，只有循环方向不同，为什么可以这样做呢？因为01背包要求每个物品只能选一次，因此根据这个式子，有可能会导致多选的就是dp[j - goods[i].w],如果从前往后循环，j-goods[i].w可能是已经选择了当前物品的情况</p><p><a href="https://pangyuworld.github.io/2019/04/03/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/#%E9%A2%98%E7%9B%AE%E7%B1%BB%E5%9E%8B-1" target="_blank" rel="external nofollow noopener noreferrer">可以去看</a></p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>有N种物品和一个容量为V的背包。第 i 种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p>实际上可以转化为01背包，把每一种物品中多件拆开</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int k = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; <span class="built_in">i</span>++) &#123;</span><br><span class="line"><span class="keyword">while</span> (number[<span class="built_in">i</span>]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">w[k] = w[<span class="built_in">i</span>];</span><br><span class="line">value[k] =value[<span class="built_in">i</span>];</span><br><span class="line">k++;</span><br><span class="line">number[<span class="built_in">i</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; <span class="built_in">i</span>++) &#123;</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = v; <span class="built_in">j</span> &gt;= w[<span class="built_in">i</span>]; <span class="built_in">j</span>--) &#123;</span><br><span class="line">f[<span class="built_in">j</span>] = <span class="built_in">max</span>(f[<span class="built_in">j</span>], f[<span class="built_in">j</span> - w[<span class="built_in">i</span>]] + value[<span class="built_in">i</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>但是这样可能导致时间复杂度过高，可以考虑采用二进制思想，每一个数例如7可以用二进制来表示，而这样我们就可以把它拆为3个数，7二进制为111，所以可以拆为100,010,001，这样我们就只需要储存3个数，降低了时间复杂度。但是假如不是正好的话<br>例如13 ，二进制为1101，则可以分解为0110,0001,0010,0100（如果最好不足2^i，则取x-2^i-1)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num[maxn][<span class="number">2</span>], dp[maxn];</span><br><span class="line"><span class="built_in">int</span> N, V, c, w, n, tot;</span><br><span class="line">memset(dp, <span class="number">0</span>, sizeof dp);</span><br><span class="line">cin &gt;&gt; V &gt;&gt; N; tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; c &gt;&gt; w &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">1</span>; k &lt; n; k&lt;&lt;=<span class="number">1</span>)<span class="comment">//左移求下一个所需二进制数 </span></span><br><span class="line">&#123;</span><br><span class="line">num[tot][<span class="number">0</span>] = k*c;</span><br><span class="line">num[tot++][<span class="number">1</span>] = k*w;<span class="comment">//注意这时我们把若干物体看为1个物体，它的总重量也要变</span></span><br><span class="line">n -= k;</span><br><span class="line">&#125;</span><br><span class="line">num[tot][<span class="number">0</span>] = n*c;</span><br><span class="line">num[tot++][<span class="number">1</span>] = n*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; tot; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j = V; j &gt;= num[i][<span class="number">0</span>]; --j)</span><br><span class="line">dp[j] = max(dp[j], dp[j-num[i][<span class="number">0</span>]]+num[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先搜索和广度优先搜索</title>
      <link href="/post/37663.html"/>
      <url>/post/37663.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>基本思想：它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念</p><p>例<img src="/images/%E5%9B%BE%E7%89%871.png" alt></p><p>V0-&gt;V1-&gt;V4-&gt;V3-&gt;V5-&gt;V6,先从v0到V1，再从V1到V4，发现到了终点，就退回到V1继续寻找</p><p>代码</p><p>注意恢复初始状态十分重要，在一种情况走不了的情况下它可以使其恢复初始状态试下一条路</p><p><img src="/images/%E5%9B%BE%E7%89%872.png" alt></p><p>例题：<img src="/images/%E5%9B%BE%E7%89%873.png" alt></p><p>遍历连通图，能否从v0到v6</p><p>答案<img src="/images/%E5%9B%BE%E7%89%874.png" alt></p><p>说明，重要的便是模板，先判断当前情况是否满足，如果满足则退出，不满足则遍历所有情况，如果某一位置到了头便会返回false，然后返回到分叉点，搜索下一步（遍历作用在这），而最后一定要回到初始状态，因为别的搜索也可能用</p><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">广度优先搜索是最简便的图的搜索算法之一，别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中</span><br></pre></td></tr></table></figure></div><p>模板<br><img src="/images/%E5%9B%BE%E7%89%875.png" alt></p><p>说明：从某一个起始节点开始，看是否满足，如果不满足， 遍历所有可能的情况，这里便是tt，如果tt存在，那么就把它送入队列中，之后继续遍历可能情况，这里需要两个数组，一个数组是用来确定这点是否已经走过，另外一个数组是用来记录步数的。<a href="https://blog.csdn.net/freezhanacmore/article/details/8168265" target="_blank" rel="external nofollow noopener noreferrer">另外，有些题可能会导致数组超过范围，这时就要写一个判断条件排除掉越界的</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>scanf printf</title>
      <link href="/post/46925.html"/>
      <url>/post/46925.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>格式：scanf(const char *format, …)</p><p>format – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。</p><p>format 说明符形式为:</p><p>[=%[*][width][modifiers]type=]</p><p><code>*</code>这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。</p><p>width 这指定了在当前读取操作中读取的最大字符数。</p><p>modifiers 为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）</p><p>type 一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格</p><table><thead><tr><th>符号</th><th>作用</th><th>具体含义</th></tr></thead><tbody><tr><td>%a、%A</td><td>读入一个浮点值(仅 C99 有效)</td><td>float*</td></tr><tr><td>%c</td><td>单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td><td>char *</td></tr><tr><td>%d</td><td>十进制整数：数字前面的 + 或 - 号是可选的。</td><td>int *</td></tr><tr><td>%e、%E、%f、%F、%g、%G</td><td>浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4</td><td>float *</td></tr><tr><td>%i</td><td>读入十进制，八进制，十六进制整数 。</td><td>int *</td></tr><tr><td>%o</td><td>八进制整数。</td><td>int *</td></tr><tr><td>%s</td><td>字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td><td>char *</td></tr><tr><td>%u</td><td>无符号的十进制整数。</td><td>unsigned int *</td></tr></tbody></table><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>scanf读入数据时碰到空白符（空白符：指空格符、制表符、回车符）就会停止函数，例如 你输入 1\n ，这个时候scanf只会读入1，\n留在了缓冲区，但是这样会导致十分严重的问题，所以scanf还有一个特性，<strong>忽略在数据之前的空白符</strong>，而这样当你读取完之后，缓冲区中一般还有一个空白符，如果这个时候你用了”%c”，那么%c会毫不犹豫的把这个空白字符读入，%c是读入一个字符，无论这个字符是什么。%s就会忽略前面的空白符</p><p>这里有一个相对有用的方法 scanf（”%d\n”,…)这样就会在读入一个整数的同时把后面的\n也读入，但是如果不是换行符而是空格那就熟手无策了。</p><p>另外还有一种函数gets()，这个函数除了换行符其它一概不管，并且他会把换行符吃掉（变成NULL）</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>格式 printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p><p>声明 printf(const char *format, …)</p><p>format中有这几种：%[标志][最小宽度][.精度][类型长度]类型</p><h5><a href="#" class="headerlink" title="%"></a>%</h5><table><thead><tr><th>格式字符</th><th>意义</th></tr></thead><tbody><tr><td>d</td><td>以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td>o</td><td>以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td>x,X</td><td>以十六进制形式输出无符号整数(不输出前缀Ox)</td></tr><tr><td>u</td><td>以十进制形式输出无符号整数</td></tr><tr><td>f</td><td>以小数形式输出单、双精度实数</td></tr><tr><td>e,E</td><td>以指数形式输出单、双精度实数</td></tr><tr><td>g,G</td><td>以%f或%e中较短的输出宽度输出单、双精度实数</td></tr><tr><td>c</td><td>输出单个字符</td></tr><tr><td>s</td><td>输出字符串</td></tr><tr><td>p</td><td>输出指针地址</td></tr><tr><td>lu</td><td>32位无符号整数</td></tr><tr><td>llu</td><td>64位无符号整数</td></tr></tbody></table><h5 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h5><table><thead><tr><th>字符</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>-</td><td>减号</td><td>结果左对齐，右边填空格。默认是右对齐，左边填空格。</td></tr><tr><td>+</td><td>加号</td><td>输出符号(正号或负号)</td></tr><tr><td>space</td><td>空格</td><td>输出值为正时加上空格，为负时加上负号</td></tr><tr><td>#</td><td>井号</td><td>type是o、x、X时，增加前缀0、0x、0X。type是a、A、e、E、f、g、G时，一定使用小数点。默认的，如果使用.0控制不输出小数部分，则不输出小数点。type是g、G时，尾部的0保留。</td></tr><tr><td>0</td><td>数字零</td><td>将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用“-”）</td></tr></tbody></table><p>示例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LSL"><figure class="iseeu highlight /lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">printf(<span class="string">"%5d<span class="subst">\n</span>"</span>,<span class="number">1000</span>); <span class="comment">//默认右对齐,左边补空格</span></span><br><span class="line">printf(<span class="string">"%-5d<span class="subst">\n</span>"</span>,<span class="number">1000</span>); <span class="comment">//左对齐,右边补空格</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%+d %+d<span class="subst">\n</span>"</span>,<span class="number">1000</span>,<span class="number">-1000</span>);<span class="comment">//输出正负号</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"% d % d<span class="subst">\n</span>"</span>,<span class="number">1000</span>,<span class="number">-1000</span>);<span class="comment">//正号用空格替代，负号输出</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%x %#x<span class="subst">\n</span>"</span>,<span class="number">1000</span>,<span class="number">1000</span>);<span class="comment">//输出0x</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%.0f %#.0f<span class="subst">\n</span>"</span>,<span class="number">1000.0</span>,<span class="number">1000.0</span>)<span class="comment">//当小数点后不输出值时依然输出小数点</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%g %#g<span class="subst">\n</span>"</span>,<span class="number">1000.0</span>,<span class="number">1000.0</span>);<span class="comment">//保留小数点后后的0</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%05d<span class="subst">\n</span>"</span>,<span class="number">1000</span>);<span class="comment">//前面补0</span></span><br></pre></td></tr></table></figure></div><h3 id="输出最小宽度"><a href="#输出最小宽度" class="headerlink" title="输出最小宽度"></a>输出最小宽度</h3><p>这是指的小数点前的宽度，如果小于最小宽度，前面补空格，如果大于，那么直接输出。另外如果用了flag中的0，那么前面将会补零</p><table><thead><tr><th>width</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>数值</td><td>十进制整数</td><td>printf(“%06d”,1000);输出:001000</td></tr><tr><td>*</td><td>星号。不显示指明输出最小宽度，而是以星号代替，在printf的输出参数列表中给出</td><td>printf(“%0*d”,6,1000);输出:001000</td></tr></tbody></table><h3 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h3><p>精度以点<code>.</code>开头，后面再接</p><table><thead><tr><th>.precision</th><th>描述</th></tr></thead><tbody><tr><td>.数值</td><td>十进制整数。(1)对于整型（d,i,o,u,x,X）,precision表示输出的最小的数字个数，不足补前导零，超过不截断。(2)对于浮点型（a, A, e, E, f ），precision表示小数点后数值位数，默认为六位，不足补后置0，超过则截断。(3)对于类型说明符g或G，表示可输出的最大有效数字。(4)对于字符串（s），precision表示最大可输出字符数，不足正常输出，超过则截断。precision不显示指定，则默认为0</td></tr><tr><td>.*</td><td>以星号代替数值，类似于width中的*，在输出参数列表中指定精度。</td></tr></tbody></table><p>对于整数型，这个作用与最小宽度作用类似，例如，”%08d” 与 “%.8d”作用是一样的</p><h3 id="类型长度"><a href="#类型长度" class="headerlink" title="类型长度"></a>类型长度</h3><p>printf(“%hhd\n”,’A’); //输出有符号char</p><p>printf(“%hhu\n”,’A’+128); //输出无符号char</p><p>printf(“%hd\n”,32767); //输出有符号短整型short int</p><p>printf(“%hu\n”,65535); //输出无符号短整型unsigned short int</p><p>printf(“%ld\n”,0x7fffffffffffffff); //输出有符号长整型long int</p><p>printf(“%lu\n”,0xffffffffffffffff); //输出有符号长整型unsigned long int</p><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>用户在输入字符时，其实并不是直接显示到屏幕上，而是放在缓冲区中，在一些条件之下才会输出</p><p>printf在glibc中默认为行缓冲，在下列情况中会刷新缓冲区</p><ol><li>缓冲区填满</li><li>写入字符中有换行符（’\n’)或回车符（’\r’)</li><li>调用fflush手动刷新缓冲区</li><li>调用scanf读取数据时</li></ol><p>可使用setbuf(stdout,NULL)关闭行缓冲，或者setbuf(stdout,uBuff)设置新的缓冲区，uBuff为自己指定的缓冲区。也可以使用setvbuf(stdout,NULL,_IOFBF,0);来改变标准输出为全缓冲。全缓冲与行缓冲的区别在于遇到换行符不刷新缓冲区。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>在运用printf和scanf中，前面的format是一个字符串，所以可以作为参数传入</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putout</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(s,...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样可以用一个函数实现重复输出不同类型的进制数</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/post/26671.html"/>
      <url>/post/26671.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h3><p>队列是一种线性结构，有队头（front）队尾（rear）两个指针，每次拉进来一个元素会让队尾加一，而每次删除一个元素会让队头加一，这是一种先进先出的结构。</p><p>队列特殊情况判断</p><p>空队列 front=rear</p><p>满队列 rear-front=N（N指的是开的数组的大小）</p><p>POP 从队头删元素</p><p>push 拉元素到队尾</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">duilie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> front ,rear;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        front=rear=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front)==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear-front==N<span class="number">-1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(full())<span class="comment">//如果满了就不能拖进去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[++rear]=key;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>上面一种队列并不是真的有n个空间，如果pop了元素那空间就要减小，这样便浪费了许多空间，而用模运算组成一个循环可以使空间充分利用</p><p>特殊情况判断</p><p>空 ： front=rear</p><p>满 ：（ rear+1）% N=front</p><p>代码实现</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const <span class="built_in">int</span> Queue_Size=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">typedef <span class="keyword">struct</span> circlQueue</span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> *elem;</span><br><span class="line">       <span class="built_in">int</span> rear;</span><br><span class="line">       <span class="built_in">int</span> front;</span><br><span class="line">       <span class="built_in">int</span> queueSize;</span><br><span class="line">&#125;circlQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">void init<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem=<span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[Q<span class="identifier">ueue_Size</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;<span class="comment">//首尾指针相等说明队列为空。</span></span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=Queue_Size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*销毁队列*/</span></span><br><span class="line">void destroy<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       delete <span class="literal">[]</span><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*求队列的长度*/</span></span><br><span class="line"><span class="built_in">int</span>  length<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">int</span> length;</span><br><span class="line">       length=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear-<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;<span class="comment">/*一般情况下，rear在front的上方，此种算法是用于</span></span><br><span class="line"><span class="comment">  rear已到front的下方，即已出现假溢出的情况。*/</span></span><br><span class="line">       return length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*入队列*/</span></span><br><span class="line">void enter<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q,<span class="params">char</span> <span class="params">x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span>(((<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)<span class="comment">//判断栈满的情况</span></span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue OverFlow!"</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">rear</span>]</span>=x;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%Queue_Size;<span class="comment">//尾指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="built_in">char</span> output<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> e;</span><br><span class="line">       <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)</span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue Empty"</span>;</span><br><span class="line">       e=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">front</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;;<span class="comment">//头指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">       return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「hackerain」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/hackerain/article/details/5934240</span></span><br></pre></td></tr></table></figure></div><h3 id="队列的函数"><a href="#队列的函数" class="headerlink" title="队列的函数"></a>队列的函数</h3><p>push()：脱元素到队尾</p><p>pop()删队首元素</p><p>size()</p><p>front()返回队首元素</p><p>back()返回队尾元素</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>front无法使用迭代器，因为queue在物理地址上不连续，所以queue无法遍历，想要遍历只能不停top POP，这样会销毁队列</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>HDU 1387</li></ul><p>Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.<br>In a team queue each element belongs to a team. If an element enters the queue, it first searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.</p><p>Your task is to write a program that simulates such a team queue.</p><p>Input</p><p>The input will contain one or more test cases. Each test case begins with the number of teams t (1&lt;=t&lt;=1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0 - 999999. A team may consist of up to 1000 elements.</p><p>Finally, a list of commands follows. There are three different kinds of commands:</p><p>ENQUEUE x - enter element x into the team queue<br>DEQUEUE - process the first element and remove it from the queue<br>STOP - end of test case<br>The input will be terminated by a value of 0 for t.</p><p>Output</p><p>For each test case, first print a line saying “Scenario #k”, where k is the number of the test case. Then, for each DEQUEUE command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line"><span class="number">3</span> <span class="number">201</span> <span class="number">202</span> <span class="number">203</span></span><br><span class="line">ENQUEUE <span class="number">101</span></span><br><span class="line">ENQUEUE <span class="number">201</span></span><br><span class="line">ENQUEUE <span class="number">102</span></span><br><span class="line">ENQUEUE <span class="number">202</span></span><br><span class="line">ENQUEUE <span class="number">103</span></span><br><span class="line">ENQUEUE <span class="number">203</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">259001</span> <span class="number">259002</span> <span class="number">259003</span> <span class="number">259004</span> <span class="number">259005</span></span><br><span class="line"><span class="number">6</span> <span class="number">260001</span> <span class="number">260002</span> <span class="number">260003</span> <span class="number">260004</span> <span class="number">260005</span> <span class="number">260006</span></span><br><span class="line">ENQUEUE <span class="number">259001</span></span><br><span class="line">ENQUEUE <span class="number">260001</span></span><br><span class="line">ENQUEUE <span class="number">259002</span></span><br><span class="line">ENQUEUE <span class="number">259003</span></span><br><span class="line">ENQUEUE <span class="number">259004</span></span><br><span class="line">ENQUEUE <span class="number">259005</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">ENQUEUE <span class="number">260002</span></span><br><span class="line">ENQUEUE <span class="number">260003</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">1</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">201</span></span><br><span class="line"><span class="number">202</span></span><br><span class="line"><span class="number">203</span></span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">2</span></span><br><span class="line"><span class="number">259001</span></span><br><span class="line"><span class="number">259002</span></span><br><span class="line"><span class="number">259003</span></span><br><span class="line"><span class="number">259004</span></span><br><span class="line"><span class="number">259005</span></span><br><span class="line"><span class="number">260001</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> stl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/post/63711.html"/>
      <url>/post/63711.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>归并排序运用了分治的思想，先将数组二分成一个元素（一个元素时看为有序），然后将这些元素不断合并，每合并一次排一次序，最后就可以得到有序的数组。</p><p>比如说一个序列:12 ,23,1,44,233,10,9,8。我们先分成两段：12 ,23,1,44 和 233,10,9,8，<br>发现还能再分成4段：12 ,23 和 1,44——233,10 和 9,8。<br>再分成8段：12–23–1–44 和233–10–9–8。<br>这时候开始把子序列进行排序合并，一个元素就是有序的。所以不用排序。<br>合并成2个一组排序得到：12，23—-1，44—10，233—8，9。<br>再合并成4个一组排序得到：1，12，23，44—8，9，10，233。<br>最后合并得到最终结果：1，8，9，10，12，23，44，233。</p><p>合并过程看代码</p><p>链接：<a href="https://www.jianshu.com/p/b50a6034eb90" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/b50a6034eb90</a></p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/images/1024555-20161218163120151-452283750.png" alt></p><p>这个图片蓝色部分就是拆的过程，而绿的部分为并的过程</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paixu</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> mid,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span><span class="comment">//这是合并过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1=first,l2=mid+<span class="number">1</span>,r1=mid,r2=last;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1&amp;&amp;l2&lt;=r2)<span class="comment">//两部分都存在时看哪个小就加上哪个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l1]&lt;=a[l2])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1)<span class="comment">//第一部分有剩余就把第一部分剩下的全加上</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2&lt;=r2)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i+first]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xunhuan</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(first+last)/<span class="number">2</span>;</span><br><span class="line">        xunhuan(first,mid,a,temp);<span class="comment">//拆左边</span></span><br><span class="line">        xunhuan(mid+<span class="number">1</span>,last,a,temp);<span class="comment">//拆右边</span></span><br><span class="line">        paixu(first,mid,last,a,temp);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[last-first];<span class="comment">//建一个临时数组，合并时用</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="comment">//判断是否传入空数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xunhuan(first,last,a,p);</span><br><span class="line">    <span class="keyword">delete</span> [] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/post/26737.html"/>
      <url>/post/26737.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="前缀和概念"><a href="#前缀和概念" class="headerlink" title="前缀和概念"></a>前缀和概念</h3><p>前缀和指的是用另一个数组b[n]来保存a[n]中前n项的和</p><p>例如，b[0]=a[0],b[1]=a[0]+a[1],…</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="求数组某一区间长度数字的和"><a href="#求数组某一区间长度数字的和" class="headerlink" title="求数组某一区间长度数字的和"></a>求数组某一区间长度数字的和</h4><p>如果我给你一串长度为n的数列a1,a2,a3……an,再给出m个询问，每次询问给出L，R两个数，要求给出区间[L,R]里的数的和，一般可能是从L到R遍历一次，但这样很花时间，有了前缀和之后可以直接b[R]-b[L]就得到L到R的和</p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分就是将数列中的每一项分别与前一项数做差</p><p>一个序列1 2 5 4 7 3，差分后得到1 1 3 -1 3 -4 -3</p><p>这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0）<br>差分序列最后比原序列多一个数（相当于0减最后一个数）</p><p>例 给你一串长度为n的数列a1,a2,a3……an，要求对a[L]~a[R]进行m次操作：</p><p>操作一：将a[L]~a[R]内的元素都加上P</p><p>操作二：将a[L]~a[R]内的元素都减去P</p><p>最后再给出一个询问求a[L]-a[R]内的元素之和？</p><p>如果用一般做法就是遍历加减，时间复杂度高，现在可以直接让b[L] 加上P，再让b[R+1]减去P，这样因为b[L+1]=b[L]+a[L+1]，所以L到R上每一项都会加P，而b[R+1]减去P是为了对后面的数不产生影响</p><p>如果有多次修改操作，可以先将每次修改保存到一个数组中，然后求前缀和时再加上<br>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=1e5+9;<br>int a[maxn],b[maxn];<br>int main(){<br>int i,j,k,n,m,p;<br>cin&gt;&gt;n&gt;&gt;m;<br>for(i=1;i&lt;=n;i++){<br>cin&gt;&gt;a[i];<br>}<br>for(i=1;i&lt;=m;i++){<br>int L,R,t;<br>cin&gt;&gt;t&gt;&gt;L&gt;&gt;R&gt;&gt;p;<br>if(t==1){<br>b[L]+=p;b[R+1]-=p; //仔细想想为什么b[R+1]要减去p<br>}<br>else{<br>b[L]-=p;b[R+1]+=p;//这是减去p<br>}<br>}<br>int add=0;<br>for(i=1;i&lt;=n;i++){<br>add+=b[i];<br>a[i]+=a[i-1]+add;//这是求前缀和数组，并且add是把需要加p的地方加上<br>}<br>int x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>cout&lt;&lt;a[y]-a[x-1]&lt;&lt;endl;<br>}</p><h4 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4><p>1、差分序列求前缀和可得原序列</p><p>2、将原序列区间[L,R]中的元素全部+1，可以转化操作为差分序列L处+1，R+1处-1</p><p>3、按照性质2得到，每次修改原序列一个区间+1，那么每次差分序列修改处增加的和减少的相同</p><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>二维前缀和对应的是二维数组</p><p><img src="/images/20180817161822690.png" alt></p><p>b[2][4]表示的是b[1][1]+b[1][2]+b[1][3]+b[1][4]+b[2][1]+b[2][2]+b[2][3]</p><p>因此可以先加上b[1][4]+b[2][3]，这时重复了b[1][3]，再减去</p><p>因此公式<br>a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1]，因为这样，二维前缀和最好从一开始，0处全赋值为0</p><p>这时想知道从(x1,y1)到(x2,y2)的和要a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]</p><p>例如，求(3,3)到(4,4)的值，实际上是a[3][3]+a[3][4]+a[4][3]+a[4][4]</p><h3 id="二维差分（不是很清楚）"><a href="#二维差分（不是很清楚）" class="headerlink" title="二维差分（不是很清楚）"></a>二维差分（不是很清楚）</h3><p>和一维差分的第四个问题类似，让（x1,y1)和（x2,y2）矩形内的数都加上x</p><p>b[x1][y1]+=x; b[x2+1][y2+1]+=x;</p><p>b[x1][y2+1]-=x; b[x2+1][y1]-=x;</p><p>参考博客<a href="https://blog.csdn.net/k_r_forever/article/details/81775899" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/k_r_forever/article/details/81775899</a></p><p><a href="https://blog.csdn.net/Healer66/article/details/87201014" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/Healer66/article/details/87201014</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>memset</title>
      <link href="/post/46466.html"/>
      <url>/post/46466.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>memset(标识符，填充数据,大小)</p><p>memset是一个字节一个字节填充的，所以一般只能填充0或-1因为这个一个字节和四个字节相同</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>快速输入</title>
      <link href="/post/54778.html"/>
      <url>/post/54778.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="attribute">x</span>=0,f=1;</span><br><span class="line">    char <span class="attribute">ch</span>=getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span> (<span class="attribute">ch</span>=='-') <span class="attribute">f</span>=-1;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;<span class="attribute">x</span>=x*10+ch-'0';ch=getchar();&#125;</span><br><span class="line">    return x<span class="number">*f</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个快速输入只适合int类型，另外如果参加比赛，最好不要用cin，cout，速度较慢<br>用scanf，printf更好</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>qsort</title>
      <link href="/post/5490.html"/>
      <url>/post/5490.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>自带的快排函数</p><p>qsortvoid qsort(void <em>base, size_t nitems, size_t size, int (*compar)(const void *, const void</em>))</p><p>参数</p><p>base– 指向要排序的数组的第一个元素的指针。<br>nitems– 由 base 指向的数组中元素的个数。<br>size– 数组中每个元素的大小，以字节为单位。<br>compar– 用来比较两个元素的函数，即函数指针（回调函数）</p><p>回调函数：</p><p>回调函数就是一个通过函数指针调用的函数。如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。 [2]<br>compar参数<br>compar参数指向一个比较两个元素的函数。比较函数的原型应该像下面这样。注意两个形参必须是const void *型，同时在调用compar 函数（compar实质为函数指针，这里称它所指向的函数也为compar）时，传入的实参也必须转换成const void *型。在compar函数内部会将const void *型转换成实际类型。<br>int compar(const void *p1, const void *p2);</p><p>如果compar返回值小于0（&lt; 0），那么p1所指向元素会被排在p2所指向元素的左面；<br>如果compar返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定；<br>如果compar返回值大于0（&gt; 0），那么p1所指向元素会被排在p2所指向元素的右面。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> stl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pair</title>
      <link href="/post/27621.html"/>
      <url>/post/27621.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>pair实际上是一个结构体，它可以把两种类型结合起来使用,定义在<code>&lt;utility&gt;</code>中</p><p>定义：pair&lt;类型A,类型B&gt; 标识符</p><p>操作 pa.first 表示类型A pa.second 表示类型B</p><p>注意不能用-> 操作符，虽然我也不知道为什么</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> stl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器支持的运算</title>
      <link href="/post/37318.html"/>
      <url>/post/37318.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>之前写搜狗在线测试题目的时候，曾经想遍历一个set遍历。当时是这样写的。</p><p>set<int>::iterator b = a.begin()+1</int></p><p>后来发现程序报错。究其原因是，set迭代器不支持加减数操作。<br>查看了一下维基百科，下面是有关说明。</p><p>1.所有迭代器都应该实现自增算符：iter++,++iter</p><p>2.Bidirectional迭代器：是在前向迭代器的基础上，多了单步向后遍历的能力。也就是–iter,iter–。</p><p>3.Random Access迭代器：在双向迭代器基础上，具有直接访问各数据元素的能力。随机迭代器增加了“迭代器算术运算”：</p><p>iter+=i 迭代器递增i位</p><p>iter-=i 迭代器递减i位</p><p>iter+i 加i位后的迭代器</p><p>iter-i 减i位后的迭代器</p><p>iter[i] 加i位后的迭代器的解引用</p><p>iter&lt;iter1 如果迭代器iter的位置在iter1前，返回true，否则返回false</p><p>iter&lt;=iter1 如果iter的位置在iter1的前面或同一位置时返回true，否则返回false</p><p>iter&gt;iter1 如果迭代器iter的位置在iter1后，返回true，否则返回false</p><p>iter&gt;=iter1 如果iter的位置在iter1的后面或同一位置时返回true，否则返回false</p><p>4.在STL定义的容器中，string，vector与deque提供了随机访问迭代器，list、set、multiset、map、multimap提供了双向迭代器。</p><p>————————————————</p><p>版权声明：本文为CSDN博主「ShenYounger」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wusecaiyun/article/details/49563197" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/wusecaiyun/article/details/49563197</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> stl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/post/54708.html"/>
      <url>/post/54708.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h3><p>vector&lt;数据类型&gt; 标识符</p><h3 id="vector的函数"><a href="#vector的函数" class="headerlink" title="vector的函数"></a>vector的函数</h3><p>begin()返回开头元素的迭代器</p><p>end()同理</p><p>front() 返回开头元素的引用</p><p>back() 返回末尾元素的引用</p><p>size()返回vector内元素的数量</p><p>erase(迭代器) 删除一个元素</p><p>clear() 清空</p><p>insert(迭代器，a) 把a插入迭代器后</p><p><strong>例</strong>vector中现在有1 2 3 三个元素，vec.insert(vec.begin()+2,4)得到1 2 4 3</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>reverse(vec.begin(),vec.end()) <strong>(头文件<code>&lt;algorithm&gt;</code>)</strong></p><p>实际上不一定是begin到end，也可以begin()+1到、、、，只需要用迭代器就行了</p><p>sort排序，也要用<code>&lt;algorithm&gt;</code>默认升序</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> <span class="constructor">Comp(<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">a</span>,<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><pre><code>vector&lt;vector&lt;数据类型&gt; &gt; vec[3];//3行vector&lt;数据类型&gt; veci;for(int i=0;i&lt;3;i++){   for(int k=0;k&lt;4;k++)   {      veci.push_back();   }   vec.push_back(veci);}//四列</code></pre><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>prioity_queue</title>
      <link href="/post/54612.html"/>
      <url>/post/54612.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="prioity-queue"><a href="#prioity-queue" class="headerlink" title="prioity_queue"></a>prioity_queue</h3><p>实际上是一个大顶堆，定义在<code>&lt;queue&gt;</code>中</p><p><code>prioity_queue&lt;int&gt; qu</code>为大顶堆</p><p><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qu;</code>为小顶堆</p><p>.push()</p><p>.pop()取出元素，但不返回值</p><p>.top()不取出元素，返回值</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> stl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>set</title>
      <link href="/post/44250.html"/>
      <url>/post/44250.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="set之iterator"><a href="#set之iterator" class="headerlink" title="set之iterator"></a>set之iterator</h3><p>定义：set::iterator iter</p><p>运用：*iter</p><p>遍历 for(iter=set.begin();iter!=set.end();iter++)</p><p>还可以直接用auto it=set.begin() (auto是自动匹配类型)</p><p><strong>注意</strong><br>iterator只能用++，–运算符。不能*（iter-1），另外还要注意iter++后自身会改变</p><p>例：set中有0,2,4，iter指向2，现在cout&lt;&lt;<em>iter&lt;&lt;” “&lt;&lt;</em>(iter–)&lt;&lt;endl;</p><p>输出0,2，先执行iter–，我也不知道为什么</p><h3 id="set之lower-bound"><a href="#set之lower-bound" class="headerlink" title="set之lower_bound()"></a>set之lower_bound()</h3><p>lower_bound()返回从first开始的第一个大于或等于val的元素的地址。如果所有元素都小于val，则返回last的地址，所以必须要</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">iter=st.lower_bound(一个数字)</span><br></pre></td></tr></table></figure></div><p>upper_bound()返回最后一个大于等于val的元素的地址</p><h3 id="set基础"><a href="#set基础" class="headerlink" title="set基础"></a>set基础</h3><p>定义：set&lt;数据类型&gt; 标识符 ，set中元素都唯一</p><p>set实际上运用了红黑树。另外，set中元素会自动排序</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>begin()，返回的是开头元素迭代器</p><p>end()</p><p>clear()</p><p>empty()</p><p>size()</p><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>count(数据)判断某个值是否在set中</p><ul><li><p>erase(iterator) 删去迭代器所指向的值</p></li><li><p>erase(iteratora,iteratorb)删去a，b之间的值</p></li><li><p>erase(数据)删去该数据</p></li><li><p>set删除是不会检查任何错误的，使用时小心</p></li></ul><p>find(数据)返回指定元素的迭代器，没有则返回最后一个元素的迭代器</p><p>当set中没有元素的时候，*s.end()=0</p><p>insert(某一个值),将一个值插入set中，<strong>注意</strong>这是唯一的将元素弄到set中的方法，并且重复插入无效</p><h6 id="判断insert插入是否成功的方法（具体可看"><a href="#判断insert插入是否成功的方法（具体可看" class="headerlink" title="判断insert插入是否成功的方法（具体可看)"></a>判断insert插入是否成功的方法（<a href="https://blog.csdn.net/liyuqian199695/article/details/49100543" target="_blank" rel="external nofollow noopener noreferrer">具体可看</a>)</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef pair&lt;iterator, bool&gt; _Pairib;</span></span><br><span class="line">pair&lt;<span class="built_in">set</span>&lt;Student,FuncStudent&gt;::iterator,<span class="keyword">bool</span>&gt; pair1=set1.insert(s1);</span><br><span class="line"><span class="keyword">if</span>(pair1.second==<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"插入s1成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"插入s1失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> stl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&amp;&amp;与||小提示</title>
      <link href="/post/25699.html"/>
      <url>/post/25699.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h4 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h4><p>&amp;&amp;运算符从左自由依次判断 ，如果判断有一个为假则停止判断</p><h4><a href="#" class="headerlink" title="||"></a>||</h4><p>同理如果判断有一个为真则停止判断</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int a=0,b=1,c;    c = (a != b) || (++a == b++);    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;    return 0;}</code></pre><p>输出为0 1因为前面一个为真，直接退出判断</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符数组</title>
      <link href="/post/22493.html"/>
      <url>/post/22493.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="前方高能"><a href="#前方高能" class="headerlink" title="前方高能"></a>前方高能</h3><pre><code>char a[4]={&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;};cout&lt;&lt;a&lt;&lt;endl;</code></pre><p>这将输出什么呢，是<code>abcd</code>，实际上是<code>abcdPpB</code></p><p>这就有点神奇</p><h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>char +标识符+[]，注意字符数组的最后一定会有’\0’，</p><p>例如<code>char[]=&quot;abcd&quot;,这就是一个合法的赋值，但是char[4]=&quot;abcd&quot;是不合法的因为带双引号的为字符串，赋值给字符数组时编译器会自动加上&#39;\0&#39;这时需要5个空间</code></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为本来是要加上’\0’的，但是这时位子不够了，编译器只好帮它扩扩容，也就是说这是字符数组（其实现在已经不是字符数组了）长度已经不是4了，编译器会为后面几个位子附上值（不是随机的，我也有点不清楚，这样解释先），因此后面会多输出一些。但是如果开始就把长度设为5，这时’\0’就有位子放了，也就不会多出后面那些奇奇怪怪的字符</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>next主题出现404的一个解决方法</title>
      <link href="/post/7119.html"/>
      <url>/post/7119.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>在<code>主题配置文件中</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DTS"><figure class="iseeu highlight /dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">home:</span> /|| home</span><br><span class="line"></span><br><span class="line"><span class="symbol">about:</span> <span class="meta-keyword">/about/</span>|| user</span><br><span class="line"></span><br><span class="line"><span class="symbol">tags:</span> <span class="meta-keyword">/tags/</span>|| tags</span><br><span class="line"></span><br><span class="line"><span class="symbol">categories:</span> <span class="meta-keyword">/categories/</span>|| th</span><br><span class="line"></span><br><span class="line"><span class="symbol">archives:</span> <span class="meta-keyword">/archives/</span>|| archive</span><br><span class="line"></span><br><span class="line"><span class="meta">#schedule: /schedule/|| calendar</span></span><br><span class="line"><span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">#commonweal: /404/|| heartbeat</span></span><br></pre></td></tr></table></figure></div><p>注意/||，原来是/ ||，不要中间那个空格，亲测有效</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> next </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件输入输出</title>
      <link href="/post/7502.html"/>
      <url>/post/7502.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h4 id="文件输入in"><a href="#文件输入in" class="headerlink" title="文件输入in"></a>文件输入in</h4><p>文件输入指的是从文件_输入_给程序，对应的有in，get，read，seekg等</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seekg和seekp中有三个定位基址，分别是cur（当前）beg（开始），end（末尾）&lt;p&gt;</span><br><span class="line">例如 seekg（<span class="number">100</span>，ios：：beg）；seekg（<span class="number">2</span>*sizeof(Student)) student是一个类</span><br></pre></td></tr></table></figure></div><p></p><h4 id="文件输出out"><a href="#文件输出out" class="headerlink" title="文件输出out"></a>文件输出out</h4><p>文件输出指的是从程序<code>输出</code>给文件，对应的有out，put，write，seekp等</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/16107.html"/>
      <url>/post/16107.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external nofollow noopener noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external nofollow noopener noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external nofollow noopener noreferrer">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external nofollow noopener noreferrer">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external nofollow noopener noreferrer">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external nofollow noopener noreferrer">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="external nofollow noopener noreferrer">Deployment</a></p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索</title>
      <link href="/post/41829.html"/>
      <url>/post/41829.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 15:25:31 GMT+0800 (中国标准时间) --><h1 id="（主要是怕自己忘记了）"><a href="#（主要是怕自己忘记了）" class="headerlink" title="（主要是怕自己忘记了）"></a>（主要是怕自己忘记了）</h1><p>一个要点，用二分时要先排序</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> erfen(<span class="built_in">int</span> arr[],<span class="built_in">int</span> key,<span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> low=<span class="number">0</span>,high=<span class="built_in">n</span>-<span class="number">1</span>;</span><br><span class="line">        while(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span>=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">if</span>(arr[<span class="built_in">mid</span>]&lt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                low=<span class="built_in">mid</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span>(arr[<span class="built_in">mid</span>]==key)</span><br><span class="line">            &#123;</span><br><span class="line">                return <span class="built_in">mid</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span>(arr[<span class="built_in">mid</span>]&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                high=<span class="built_in">mid</span>-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -<span class="built_in">mid</span>-<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>合法的字符常量</title>
      <link href="/post/3526.html"/>
      <url>/post/3526.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>用英文单引号括起来的一个字符，例如’a’,’ ‘等等。空格也是一个字符常量</p><p>注意</p><p>1.转义字符也属于字符常量，例如'\t','\n'等，但是'\97'不算</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符常量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/post/11306.html"/>
      <url>/post/11306.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed May 13 2020 18:55:56 GMT+0800 (中国标准时间) --><p>步骤：<br>1.先从数列中取出一个数作为基准数。</p><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p><p>3．再对左右区间重复第二步，直到各区间只有一个数。</p><p>例 6 1 2 7 9 3 4 5 10 8 进行排序</p><p><br>1 以6为基准数，先从右边找比6小的数，我们用一个变量j一步步向左移动，好在移动三次后我<br>们找到了5，j为7。现在再让另一个变量i向右移动去找比6大的数，当i为3时找到了7.现在再让5<br>和7互换，得到了6 1 2 5 9 3 4 7 10 8,。在让j向左移动，找到了4，i向右找到了9，再让两个数<br>互换，j再向左到3，此时i向左也到3，两者相遇，便让3和6互换，第一次结束<br>（想想原因）</p><p><br>2 现在分为两部分，左边全比6小，右边全比6大，为3 1 2 5 4 6 9 7 10 8<br>再在3 1 2 5 4 中用同样的方法搜索一次得到2 1 3 5 4,再在2 1 中搜索得到1 2<br>然后在5 4 中搜索得到4 5，左边排序完成，右边用同样的方法排序就可得到答案</p><p>不说了，上代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> <span class="keyword">sort</span>(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span>(l&lt;r)<span class="comment">//l大于等于r时这一段排序结束</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i=l,j=r,x=a[l];</span><br><span class="line"> <span class="keyword">while</span>(i&lt;j)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;j&amp;&amp;a[j]&gt;=x)</span><br><span class="line">  &#123;</span><br><span class="line">      j--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;j&amp;&amp;a[i]&lt;=x)</span><br><span class="line">  &#123;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(a[i],a[j]);</span><br><span class="line"> &#125;</span><br><span class="line"> swap(a[l],a[i]);</span><br><span class="line"> <span class="keyword">sort</span>(a,l,i-<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">sort</span>(a,i+<span class="number">1</span>,r);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>引用 转载请标明出处，原文地址：<a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/morewindows/article/details/6684558</a><br>csdn 我见过最通俗易懂的快速排序过程讲解，转自《坐在马桶上看算法：快速排序》</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划背包问题</title>
      <link href="/post/21624.html"/>
      <url>/post/21624.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="第一类背包问题"><a href="#第一类背包问题" class="headerlink" title="第一类背包问题"></a>第一类背包问题</h3><p>问题，有N件物品和一个容量为V的背包。第i件物品的大小是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p><p><strong>思路</strong> 可以用一个二维数组a[i][j]，表示把前i个物体放入一个容量为j的容器中所获得的最大价值，而a[i][j]=max(a[i-1][j],a[i-1][j-c[i]]+w[i])</p><p>这个式子表示到底是不装第i个物品价值大还是花去c[i]的空间装获得w[i]的价值所得的总价值最大，</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n w v    <span class="number">1</span>   <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span></span><br><span class="line">a<span class="number">2</span><span class="number">6</span><span class="number">0</span><span class="number">6</span><span class="number">6</span><span class="number">9</span><span class="number">9</span><span class="number">12</span><span class="number">12</span><span class="number">15</span><span class="number">15</span><span class="number">15</span></span><br><span class="line">b<span class="number">2</span><span class="number">3</span><span class="number">0</span><span class="number">3</span><span class="number">3</span><span class="number">6</span><span class="number">6</span><span class="number">9</span><span class="number">9</span><span class="number">9</span><span class="number">10</span><span class="number">11</span></span><br><span class="line">c<span class="number">6</span><span class="number">5</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">6</span><span class="number">6</span><span class="number">6</span><span class="number">6</span><span class="number">6</span><span class="number">10</span><span class="number">11</span></span><br><span class="line">d<span class="number">5</span><span class="number">4</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">6</span><span class="number">6</span><span class="number">6</span><span class="number">6</span><span class="number">6</span><span class="number">10</span><span class="number">10</span></span><br><span class="line">e<span class="number">4</span><span class="number">6</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">6</span><span class="number">6</span><span class="number">6</span><span class="number">6</span><span class="number">6</span><span class="number">6</span><span class="number">6</span></span><br></pre></td></tr></table></figure></div><p>为了叙述方便，用e2单元格表示e行2列的单元格，这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了。</p><p>对于d2单元格，表示只有物品e，d时,承重为2的背包,所能装入的最大价值，仍然是0，因为物品e,d都不是这个背包能装的。</p><p>上代码</p><p>————————————————<br>版权声明：本文为CSDN博主「从杰」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/mu399/article/details/7722810" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/mu399/article/details/7722810</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性筛</title>
      <link href="/post/38035.html"/>
      <url>/post/38035.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed May 20 2020 13:57:29 GMT+0800 (中国标准时间) --><p>埃氏筛中有重复，例如6,2与3都筛了一次，效率低<br>线性筛定理，（口语不准确）一个数i乘以小于等于它的最小素因数的素数所得到的合数之间没有重复</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   #define N <span class="number">10000</span></span><br><span class="line"><span class="built_in">int</span> flag[N+<span class="number">1</span>],prime[N+<span class="number">1</span>],pnum;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flag[n] 表示n是否是素数，1是素数，0不是</span></span><br><span class="line"><span class="comment">prime   中是所有的素数按从小到大排列、</span></span><br><span class="line"><span class="comment">pnum  表示素数的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">void</span> CreatePrime()&#123;</span><br><span class="line">pnum=<span class="number">0</span>;<span class="comment">//初始化没有素数</span></span><br><span class="line"><span class="comment">//先将所有数看做素数，然后开始筛选</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;=N; i++)&#123;</span><br><span class="line">flag[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历筛去所有最大因数是i的合数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">2</span>; i&lt;=N; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag[i]==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//把素数记录下来</span></span><br><span class="line">p[pnum++]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历已知素数表中比i的最小素因数小的素数，并筛去合数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;pnum &amp;&amp; p[j]*i&lt;=N; j++)&#123;</span><br><span class="line"><span class="comment">//筛去合数</span></span><br><span class="line">flag[p[j]*i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i%p[j]==<span class="number">0</span>)</span><br><span class="line"><span class="comment">//找到i的最小素因数，找到了就终止</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>————————————————<br>版权声明：本文为CSDN博主「太上绝情」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/bjrxyz/article/details/8125913" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/bjrxyz/article/details/8125913</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>埃氏筛</title>
      <link href="/post/29949.html"/>
      <url>/post/29949.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed May 20 2020 13:57:42 GMT+0800 (中国标准时间) --><p>在筛质数时，我们会发现，筛去2后，2的倍数4、6、8等一定不是素数;筛去3后，3的倍数6、9、12等一定不是倍数。简单模拟这个过程如下</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> MAXN = <span class="number">1000000</span>；  </span><br><span class="line"><span class="built_in">void</span> Prime()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;MAXN; i++) prime[i]=<span class="number">1</span>;  <span class="comment">//先把每个数都定义为质数</span></span><br><span class="line">    prime[<span class="number">0</span>]=prime[<span class="number">1</span>]=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">2</span>; i&lt;MAXN; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!prime[i]) <span class="keyword">continue</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j=i*<span class="number">2</span>; j&lt;MAXN; j+=i) prime[j] = <span class="number">0</span>;  <span class="comment">//将i的倍数标记为合数</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组合</title>
      <link href="/post/44454.html"/>
      <url>/post/44454.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 24 2020 11:36:29 GMT+0800 (中国标准时间) --><p>本程序的思路是开一个数组，其下标表示1到n个数，数组元素的值为1表示其代表的数被选中，为0则没选中。</p><p>首先初始化，将数组前n个元素置1，表示第一个组合为前n个数。</p><p>然后从左到右扫描数组元素值的“10”组合，找到第一个“10”组合后将其变为“01”组合，同时将其左边的所有“1”全部移动到数组的最左端。</p><p>当第一个“1”移动到数组的n-m的位置，即n个“1”全部移动到最右端时，就得到了最后一个组合。</p><p>例如求5中选3的组合：</p><p>1 1 1 0 0 //1,2,3</p><p>1 1 0 1 0 //1,2,4</p><p>1 0 1 1 0 //1,3,4</p><p>0 1 1 1 0 //2,3,4</p><p>1 1 0 0 1 //1,2,5</p><p>1 0 1 0 1 //1,3,5</p><p>0 1 1 0 1 //2,3,5</p><p>1 0 0 1 1 //1,4,5</p><p>0 1 0 1 1 //2,4,5</p><p>0 0 1 1 1 //3,4,5</p><p>这里有一个关键是同时把所有的1移到左端，通过观察发现只有0在最左边的情况下才有可能要把1移动。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ZEPHIR"><figure class="iseeu highlight /zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line">using <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line">void output(<span class="keyword">int</span> *a,<span class="keyword">int</span> *<span class="keyword">use</span>, <span class="title">int</span> <span class="title">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">int</span> <span class="title">flag</span> = 0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">use</span>[<span class="title">i</span>]!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">flag</span> = <span class="title">i</span>;</span><br><span class="line">            cout&lt;&lt;a[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=flag+<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">use</span>[<span class="title">i</span>]!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">cout</span>&lt;&lt;" "&lt;&lt;<span class="title">a</span>[<span class="title">i</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void assemble(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">use</span>[<span class="title">n</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">use</span>[<span class="title">i</span>] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">use</span>[<span class="title">i</span>] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tag &lt; n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        output(a, <span class="keyword">use</span>, <span class="title">n</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">use</span>[0] == 0)//第一位是0</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">while</span>(<span class="title">tag</span> &lt; <span class="title">n</span>-1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title">if</span>(<span class="title">use</span>[<span class="title">tag</span>]==1 &amp;&amp; <span class="title">use</span>[<span class="title">tag</span>+1]==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="title">use</span>[<span class="title">tag</span>-1] = 0;</span><br><span class="line">                    <span class="keyword">use</span>[<span class="title">tag</span>] = 0;</span><br><span class="line">                    <span class="keyword">use</span>[<span class="title">tag</span>+1] = 1;</span><br><span class="line">                    tag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">use</span>[<span class="title">tag</span>] = 1;</span><br><span class="line">                tag++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tag &lt; n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">use</span>[<span class="title">tag</span>]==1 &amp;&amp; <span class="title">use</span>[<span class="title">tag</span>+1]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title">use</span>[<span class="title">tag</span>] = 0;</span><br><span class="line">                <span class="keyword">use</span>[<span class="title">tag</span>+1] = 1;</span><br><span class="line">                tag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tag++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n,c;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="keyword">int</span> a[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    assemble(a, n, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>————————————————<br>版权声明：本文为CSDN博主「文如王勃三生慧」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/hf19931101/article/details/79452799" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/hf19931101/article/details/79452799</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>string大小写字母转换</title>
      <link href="/post/14511.html"/>
      <url>/post/14511.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>在algorithm库中有transform函数<br>transform(str.begin(),str.end(),str.begin(),::toupper)<br>注意transform有四个输入参数<br>1：str.begin()字符串的起始地址；<br>2：str.end()字符串的终止地址；<br>3：str.begin()是转换之后，输出到原str字符串的起始地址；<br>4：转换操作，可以选择toupper，tolower。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> stl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“凸包”</title>
      <link href="/post/6589.html"/>
      <url>/post/6589.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>凸包就是把平面中所有点都包进去的凸多边形，当然多边形上的点也是题目中给出的点</p><p>分治法<br>1 首先，横坐标最小p1和最大pn的点一定是凸包上的点<br>2上包，即离p1pn最远的点，记pmax<br>3再把pmax与p1连接，求左侧的上包，重复上述过程即可求解<img src="/images/20150530094927274" alt></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>神奇的逗号运算符</title>
      <link href="/post/27980.html"/>
      <url>/post/27980.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>cout&lt;&lt;(a,c),此时只会输出c的内容，但是a中的内容也会被计算，例如a=5,b=6,c=7 cout&lt;&lt;(（d=a+b),c) 输出为7，d=11</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
