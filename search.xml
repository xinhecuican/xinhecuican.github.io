<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux文件操作</title>
    <url>/post/95495db.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="touch-创建文件"><a class="markdownIt-Anchor" href="#touch-创建文件"></a> touch 创建文件</h3>
<p>创建文件有许多种方式，例如用vi创建文件，利用重定向创建文件。</p>
<p>语法： touch [-acm] [-t time] file…</p>
<p>作用： 创建文件，改变文件的修改时间和访问时间。</p>
<p>-m 改变修改时间</p>
<p>-a 改变访问时间</p>
<p>-t 用一个具体的时间去替换</p>
<p>如果不加参数会将修改时间和访问时间全部修改。</p>
<p>例如： touch * ，这个命令会修改目录下的所有文件的访问时间和修改时间。</p>
<p>如果后面接的文件名不存在，touch将会创建一个文件。</p>
<p>-c 不创建文件。如果文件存在，会修改时间，如果文件不存在，不进行操作。</p>
<h4 id="文件命名"><a class="markdownIt-Anchor" href="#文件命名"></a> 文件命名</h4>
<p>要求：</p>
<ol>
<li>文件名最长是255个字符</li>
<li>文件名可以包含除了/外的任何字符</li>
</ol>
<p>虽然说创建文件名的时候没有太多的要求，但是最好创建有意义的名字并且不要实用一些特殊字符。例如-，虽然创建的时候不会出现问题，但是使用命令进行操作的时候却会带来麻烦。</p>
<h3 id="cp-复制文件"><a class="markdownIt-Anchor" href="#cp-复制文件"></a> cp 复制文件</h3>
<p>语法： cp [-ip] file1 file2</p>
<p>file1是已有文件 file2是目标文件</p>
<p>例如： cp /etc/passwd ~/pword</p>
<p>这个命令会复制passwd文件到pword中，如果pword不存在，那么就会创建。这时需要特别小心，如果目标文件存在，那么复制完之后原来的内容咩有办法找回。</p>
<p>如果想追加数据，则不能用cp，只能用cat重定向追加内容。</p>
<p>cp很容易错误的清楚数据，为了保险起见，可以用-i选项。这个选项会在替换已有文件时先询问。可以在初始化文件中直接设定。</p>
<p>还有一个选项是-p，这个命令使目标文件和原文件有相同的修改时间访问时间和权限。</p>
<p><strong>-r</strong>，将一个目录复制到另一个目录中。</p>
<p><strong>将文件复制到不同目录中</strong></p>
<p>就是将file2变成directory。</p>
<h3 id="mv-移动文件"><a class="markdownIt-Anchor" href="#mv-移动文件"></a> mv 移动文件</h3>
<p><a href="https://xinhecuican.github.io/post/61312.html#more">在前面博客中已经提到</a></p>
<h3 id="rm-删除文件"><a class="markdownIt-Anchor" href="#rm-删除文件"></a> rm 删除文件</h3>
<p>语法： rm [-fir] file…</p>
<p>rm删除同样是不可恢复的。为了防止误删文件，可以使用-i选项，每次删除之前请求许可。</p>
<p>-f 强制删除文件，不考虑权限和-i。</p>
<p>-r 删除整个目录树，这个选项会将从工作目录开始的所有文件全部删除</p>
<h3 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h3>
<p>权限一共有三种，读权限，写权限，执行权限。这些权限和用户标识也有关，如果是普通用户，可能对一些文件没有写权限和执行权限。</p>
<p>设置权限有两个目的，限制其他用户的访问和避免自己错误的使用。</p>
<p>下面是权限的作用</p>
<table>
<thead>
<tr>
<th>文件</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td>读取文件(没有这个权限使用命令也无法查看文件）</td>
</tr>
<tr>
<td>写</td>
<td>写入文件，没有写权限的话在删除和替换时都会先询问</td>
</tr>
<tr>
<td>执行</td>
<td>执行文件</td>
</tr>
<tr>
<td>** 目录**</td>
<td></td>
</tr>
<tr>
<td>读</td>
<td>读取（查看）目录</td>
</tr>
<tr>
<td>写</td>
<td>创建、移动、复制或删除目录</td>
</tr>
<tr>
<td>执行</td>
<td>搜索目录</td>
</tr>
</tbody>
</table>
<p>例如，有这个文件的写权限和执行权限，那么无法看到它（也就是点文件），但是如果知道它的位置，还是可以对他进行操作。</p>
<h4 id="id-groups-维护文件权限"><a class="markdownIt-Anchor" href="#id-groups-维护文件权限"></a> id groups 维护文件权限</h4>
<p>创建文件的用户标识就是文件的属主。每个用户都属于一个组，第二组是组中其他人，第三组是其他人，可以为这三组设置读写和执行权限。</p>
<p>系统中组标识的列表在/etc/group中，这个文件可以自由查看</p>
<p>id就是用来查看当前用户标识和属于那个组的。groups命令是同样的作用。</p>
<h4 id="ls-l显示文件权限"><a class="markdownIt-Anchor" href="#ls-l显示文件权限"></a> ls -l显示文件权限</h4>
<p>使用-l时，从左边开始会有一些字符。例如-rwx等等</p>
<p>首先第一个字符是-或者d，-代表普通文件，d代表目录。之后会有9个字符分成3组，分别代表个人权限，族权限，其他人权限。</p>
<p>除了这种表示方法，还可以用三个数字表示三中类型的权限</p>
<ul>
<li>r: 读权限  数字 4</li>
<li>w: 写权限  数字 2</li>
<li>x: 执行权限 数字 1</li>
<li>-: 没有权限 数字 0</li>
</ul>
<p>例如只有读写权限，那么就可以用6来代表。</p>
<h4 id="改变文件权限"><a class="markdownIt-Anchor" href="#改变文件权限"></a> 改变文件权限</h4>
<p>可以使用chmod（change file mode）来改变文件权限</p>
<p>语法： chmod mode file…</p>
<p>这里的mode是使用数字表示的，并且一次要写三种类型。</p>
<p>例如： chmod 644 file1</p>
<p>umask 可以改变默认权限，例如umask 022.则写权限变成0。umask444则所有读权限变成0.普通文件默认权限是644，目录文件默认权限是777.通过umask044,则普通文件默认权限变成600.</p>
<h3 id="shred-清空文件内容"><a class="markdownIt-Anchor" href="#shred-清空文件内容"></a> shred 清空文件内容</h3>
<p>前面讲的rm命令只是删除了文件，但是文件所在的空间还是可以重新被使用的。甚至这个时候如果用昂贵的设备，那么其中的内容还是可以恢复的。如果使用了shred，那么就会毁坏硬盘（后备隐藏能源？），这时数据就永远无法恢复了。这里就不展开了。</p>
<h3 id="stat-ls-i-链接的概念"><a class="markdownIt-Anchor" href="#stat-ls-i-链接的概念"></a> stat ls -i 链接的概念</h3>
<p>当linux创建文件时，进行两个操作。在储存设备上保留一块空间来保存数据，之后创建一个索引节点（i节点）来存放数据的基本信息。i节点包含使用文件所需的全部信息</p>
<p>stat命令就是查看i节点的内容</p>
<p>所有的i节点存放于一个大表中，称为i节点表。在节点表中，每个i节点由索引号和i节点号表示。为了查看节点号，可以使用ls -i选项。如果想查看所有节点，可以使用ls -il。</p>
<p>处理目录时，其实我们处理的是i节点号和节点名称。所以目录实际上很小。只有一个名称，每一个名称对应一个i节点号。</p>
<p>例如，我们现在bin目录中创建swap文件。那么先保留一块空间，如果查看i节点表，查找一个空闲的i节点。然后linux将信息填充到属于这个文件的i节点中。之后在bin目录中放入一个条目，该条目有名称和i节点号。</p>
<p>文件名和i节点之间的连接叫链接。</p>
<h3 id="多重链接一个文件多个名字"><a class="markdownIt-Anchor" href="#多重链接一个文件多个名字"></a> 多重链接，一个文件，多个名字</h3>
<p>多重链接就是一个文件可以有不同的名称。因为文件标识实际上是i节点号，我们从目录中查询的时候也是查询i节点号然后根据节点号中的信息去访问。因此我们可以在不同目录中创建指向同一个节点号的文件，这其实就是快捷方式。</p>
<h4 id="ln-创建新链接"><a class="markdownIt-Anchor" href="#ln-创建新链接"></a> ln 创建新链接</h4>
<p>语法： ln file newname</p>
<p>作用：每当创建文件时，系统都会自动在文件和文件名间创建一个链接。如果我们想为已有文件创建一个新链接，就可以用ln（link）。</p>
<p>我们也可以将newname改成directory，那么就是创建快捷方式</p>
<p><strong>移除链接</strong></p>
<p>直接用rm命令即可，除非所有链接都被删除，不然文件不会被删除。</p>
<h3 id="符号链接-ln-s"><a class="markdownIt-Anchor" href="#符号链接-ln-s"></a> 符号链接 ln -s</h3>
<p>前面讲的链接有两点限制。一，不能为目录创建链接。二，不能为不同文件系统创建链接。（因为目录没有i节点）</p>
<p>如果想克服上述情况，就需要创建符号链接。符号链接包含的不是文件的i节点号，而是原文件的路径名。</p>
<p>但是用ls -l时，左边会有一个l代表链接。实际符号链接在右边。用一个-&gt;符号后面加上指向的真实文件名表示。因为符号链接只存一个路径，所以大小也只有4字节。注意这是符号链接才会有-&gt;符号，一般的链接不会显示。</p>
<p>一般的链接叫做硬链接，就是起了一个别名。符号链接叫做软链接，实际上并不是存放那个文件，只是存放一个指向文件的地址。</p>
<p>硬链接数量ls -l可以显示，但是软链接无法显示，因为系统也不知道有多少软链接。并且当文件被删除时，软链接也不会被删除，只是打开时发生错误</p>
<h4 id="目录使用符号链接"><a class="markdownIt-Anchor" href="#目录使用符号链接"></a> 目录使用符号链接</h4>
<p>当我们对目录使用符号链接之后，cd时到底应该显示真实的目录还是符号链接目录呢？实际上两种都可以。</p>
<p>如果使用cd -L选项，将把符号链接视为真实目录，使用-P选项将用真实目录替换符号链接，也就是直接进入真实目录。默认情况是-L。</p>
<p>我们使用-L情况是和-P一样的，使用-L时目录显示与原文件相同，就是实际对源文件进行操作的时候想要进行跳转。</p>
<h3 id="locate-通过数据库查看文件"><a class="markdownIt-Anchor" href="#locate-通过数据库查看文件"></a> locate 通过数据库查看文件</h3>
<p>语法： locate [-bcirS] pattern…</p>
<p>作用： 在一个特殊的数据库（包含所有的可公共访问的文件，且定期更新）查找文件。</p>
<p>如果想使用正则表达式，可以使用-r选项 ，可以用^和$表示开头和结尾。</p>
<p>例如 locate -r ‘.jpg$’ 是找jpg图片</p>
<p>locate -ir ‘^/usr*x11$’ 是找以/usr开头，x11结尾的。</p>
<ul>
<li>-c 统计数目，而不显示位置</li>
<li>-i 忽略大小写</li>
</ul>
<h3 id="find-搜索目录树查找文件"><a class="markdownIt-Anchor" href="#find-搜索目录树查找文件"></a> find 搜索目录树查找文件</h3>
<p>语法： find path… test… action…</p>
<p>输入命令后，find执行三步</p>
<ol>
<li>路径，先查看每个路径，检查这个路径代表的整个目录树</li>
<li>测试，对于遇到的每个文件，find用指定的测试条件进行测试，成功就进行下一步</li>
<li>动作，一旦搜索完成，对成功通过上面两个步骤的文件做的操作</li>
</ol>
<p>例如： find /home/harley -name important -print</p>
<p>路径： /home/harley。表示从harley目录开始进行搜索，也就是home目录不搜索。路径可以有多个</p>
<p>动作： -name important。这个的含义是查找名字是important的文件</p>
<p>动作： -print。输出路径名</p>
<h4 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h4>
<p>下列是一些模式</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-name pattern</td>
<td>包含pattern的文件名</td>
</tr>
<tr>
<td>-iname pattern</td>
<td>不区分大小写</td>
</tr>
<tr>
<td><strong>文件特征</strong></td>
<td></td>
</tr>
<tr>
<td>-type [df]</td>
<td>文件类型 d：目录 f：普通文件</td>
</tr>
<tr>
<td>-perm mode</td>
<td>文件权限</td>
</tr>
<tr>
<td>-user userid</td>
<td>文件属主</td>
</tr>
<tr>
<td>-group groupid</td>
<td>组为groupid</td>
</tr>
<tr>
<td>-size [-+]n[cbkMG]</td>
<td>大小为n[字节，块，kb，mb，gb]</td>
</tr>
<tr>
<td>-empty</td>
<td>空文件</td>
</tr>
<tr>
<td><strong>访问时间，修改时间</strong></td>
<td></td>
</tr>
<tr>
<td>-amin [-+]n</td>
<td>n分钟之前访问，-是小于这个时间</td>
</tr>
<tr>
<td>-atime [-+]n</td>
<td>n天之前访问</td>
</tr>
<tr>
<td>-anewer file</td>
<td>file之后访问</td>
</tr>
<tr>
<td>-cmin [-+]n</td>
<td>n分钟之前状态改变</td>
</tr>
<tr>
<td>-cnewer file</td>
<td>file状态改变之后改变</td>
</tr>
<tr>
<td>-time [-+]n</td>
<td>…</td>
</tr>
<tr>
<td>-mmin [-+]n</td>
<td>n分钟之前修改</td>
</tr>
<tr>
<td>-mtime [-+]n</td>
<td>n天之前修改</td>
</tr>
<tr>
<td>-newer file</td>
<td>file文件之后修改</td>
</tr>
</tbody>
</table>
<p>最重要的是type和name。中括号中的加减号代表的是大于和小于。</p>
<p>type控制查找那些类型。除了上面的之外，还有b(块设备），c（字符设备），p（命名管道），l（符号链接）</p>
<p>例如： <code>find . -type f -name important -print</code></p>
<p>其中name后面的pattern可以用通配符。</p>
<p>cmin代表的是访问或修改。</p>
<p>例如： find ~ -cmin -10 -print</p>
<p>这个的含义是查找10分钟内被访问或修改的文件。</p>
<h4 id="使用对测试求反"><a class="markdownIt-Anchor" href="#使用对测试求反"></a> 使用！对测试求反</h4>
<p>使用!时要注意两个问题：</p>
<ol>
<li>！号两边要有空格</li>
<li>必须要引用！，可以<code>\!</code>,也可以’!’</li>
</ol>
<p>并且一个感叹号只对一个测试有效。</p>
<h4 id="动作"><a class="markdownIt-Anchor" href="#动作"></a> 动作</h4>
<table>
<thead>
<tr>
<th>动作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-print</td>
<td>将路径名写入标准输出</td>
</tr>
<tr>
<td>-fprint file</td>
<td>将输出写入file中</td>
</tr>
<tr>
<td>-ls</td>
<td>显示长目录列表，和ls -l输出样式差不多</td>
</tr>
<tr>
<td>-fls file</td>
<td>输出写入file中</td>
</tr>
<tr>
<td>-delete</td>
<td>输出文件</td>
</tr>
<tr>
<td>-exec command {} ;</td>
<td>执行command，{}指示匹配的文件名</td>
</tr>
<tr>
<td>-ok command {} ;</td>
<td>同exec，在执行command前先确认</td>
</tr>
</tbody>
</table>
<p>exec后面的command是linux的程序例如ls，echo等。这条命令以;（封号）结尾，前面的\是转义字符。而{}有些系统必须要加转义字符。</p>
<p>例如： <code>find . -name '*.backup' -exec ls -dils &#123;&#125; \;</code></p>
<h4 id="xargs-处理查找到的文件"><a class="markdownIt-Anchor" href="#xargs-处理查找到的文件"></a> xargs 处理查找到的文件</h4>
<p>对于查找到的文件可以用exec处理，但是这里专门有一个程序去处理。</p>
<p>语法： xargs [-prt] [-i string] [command | argument…]</p>
<p>command是希望运行的程序，string是占位符，argument是从标准输入中读取的参数。</p>
<p>例如： find ~ -type f | xargs ls -s</p>
<p>如果想多次运行同一命令，那么需要使用-i选项，并且后面要使用 { }作为占位符，占位符在命令开始之前会被参数替代。</p>
<p>例如： find . -type f | xargs -i echo { } { }</p>
<p>这条命令将会连续输出两次。如果想自己指定占位符，可以直接在-i后面添加字符串。</p>
<p>例如： find . -type f | xargs -iXX mv XX ~/backups/XX.old</p>
<p>这条命令即移动又进行了重命名（变成XX.old)</p>
<p>-p 运行命令之前先提示</p>
<p>-t 运行命令不会请求许可但是会显示在标准输出中。</p>
<p>-r 如果没有参数，则不执行。</p>
<p>例如： <code>find . -empty | xarg -r ls -l</code></p>
<p>原本如果是没有空文件的话ls将会输出整个目录，这当然不对，所以没有空文件的时候就可以让他忽略。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>KNN算法</title>
    <url>/post/94ceb2fd.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="大致步骤"><a class="markdownIt-Anchor" href="#大致步骤"></a> 大致步骤</h1>
<p>KNN是最临近规则分类算法。</p>
<p>为了判断未知分类，我们需要用已知分类进行参照。</p>
<ol>
<li>选择参照物个数k。 k的取值一般都比较小，可以是1,3,5,7等数，通过实验得知哪个比较好就用哪个。一般用奇数，避免两边数目相同</li>
<li>选择最近的k个实例然后看他们都属于哪个类，让这个实例成为数目最多的实例。</li>
</ol>
<p><strong>距离衡量方法</strong></p>
<ol>
<li>EUclidean Distance方法。和距离公式类似，对应特征值相减平方再开根号。<img src="/images/KNN1.PNG" alt="" /></li>
</ol>
<p>例：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">from</span> sklearn import neighbors</span><br><span class="line"><span class="attribute">from</span> sklearn import datasets # 这个库中自带一些有名的数据集</span><br><span class="line"></span><br><span class="line"><span class="attribute">knn</span> = neighbors.KNeighborsClassifier() # 创建分类器</span><br><span class="line"></span><br><span class="line"><span class="attribute">iris</span> = datasets.load_iris() # 导入数据集</span><br><span class="line"><span class="attribute">knn</span>.fit(iris.data, iris.target)</span><br><span class="line"><span class="attribute">predictedLabel</span> = knn.predict([[<span class="number">0</span>.<span class="number">1</span>, <span class="number">0</span>.<span class="number">2</span>, <span class="number">0</span>.<span class="number">3</span>, <span class="number">0</span>.<span class="number">4</span>]])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>K-means</title>
    <url>/post/766f9b60.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1>
<p>k-means算法属于非监督学习，也就是事先不知道给的数据属于那一类，需要自己去分类。它的基本思想是把数据点密集的一群分成一类。</p>
<p>具体过程：</p>
<ol>
<li>随机选择k个类的初始中心</li>
<li>在c次迭代中，对任意一个样本，求到各中心点之间的距离，将该样本归类到最近中心的那个类</li>
<li>使用均值等方法更新中心点。</li>
<li>如果两次更新匪类相同也结束</li>
</ol>
<p>例如划分三个点(1, 1) (2, 3) (4, 6)是一类，那么新的中心点是((1+2+4)/3, (1+3+6)/3),不一定要在原有点上</p>
<h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">import</span> numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function: K Means</span></span><br><span class="line"><span class="comment"># -------------</span></span><br><span class="line"><span class="comment"># K-Means is an algorithm that takes in a dataset and a constant</span></span><br><span class="line"><span class="comment"># k and returns k centroids (which define clusters of data in the</span></span><br><span class="line"><span class="comment"># dataset which are similar to one another).</span></span><br><span class="line"><span class="attribute">def</span> kmeans(X, k, maxIt): # maxIt是初始化次数</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">numPoints</span>, numDim = X.shape</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">dataSet</span> = np.zeros((numPoints, numDim + <span class="number">1</span>))</span><br><span class="line">    <span class="attribute">dataSet</span>[:, :-<span class="number">1</span>] = X # 初始化赋值</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize centroids randomly</span></span><br><span class="line">    <span class="attribute">centroids</span> = dataSet[np.random.randint(numPoints, size = k), :] # 随机选取中心点</span><br><span class="line">    <span class="comment">#centroids = dataSet[0:2, :]</span></span><br><span class="line">    <span class="comment">#Randomly assign labels to initial centorid</span></span><br><span class="line">    <span class="attribute">centroids</span>[:, -<span class="number">1</span>] = range(<span class="number">1</span>, k +<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize book keeping vars.</span></span><br><span class="line">    <span class="attribute">iterations</span> = <span class="number">0</span></span><br><span class="line">    <span class="attribute">oldCentroids</span> = None</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Run the main k-means algorithm</span></span><br><span class="line">    <span class="attribute">while</span> not shouldStop(oldCentroids, centroids, iterations, maxIt):</span><br><span class="line">        <span class="attribute">print</span> <span class="string">&quot;iteration: \n&quot;</span>, iterations</span><br><span class="line">        <span class="attribute">print</span> <span class="string">&quot;dataSet: \n&quot;</span>, dataSet</span><br><span class="line">        <span class="attribute">print</span> <span class="string">&quot;centroids: \n&quot;</span>, centroids</span><br><span class="line">        <span class="comment"># Save old centroids for convergence test. Book keeping.</span></span><br><span class="line">        <span class="attribute">oldCentroids</span> = np.copy(centroids)</span><br><span class="line">        <span class="attribute">iterations</span> += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Assign labels to each datapoint based on centroids</span></span><br><span class="line">        <span class="attribute">updateLabels</span>(dataSet, centroids)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Assign centroids based on datapoint labels</span></span><br><span class="line">        <span class="attribute">centroids</span> = getCentroids(dataSet, k)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># We can get the labels too by calling getLabels(dataSet, centroids)</span></span><br><span class="line">    <span class="attribute">return</span> dataSet</span><br><span class="line"><span class="comment"># Function: Should Stop</span></span><br><span class="line"><span class="comment"># -------------</span></span><br><span class="line"><span class="comment"># Returns True or False if k-means is done. K-means terminates either</span></span><br><span class="line"><span class="comment"># because it has run a maximum number of iterations OR the centroids</span></span><br><span class="line"><span class="comment"># stop changing.</span></span><br><span class="line"><span class="attribute">def</span> shouldStop(oldCentroids, centroids, iterations, maxIt):</span><br><span class="line">    <span class="attribute">if</span> iterations &gt; maxIt:</span><br><span class="line">        <span class="attribute">return</span> True</span><br><span class="line">    <span class="attribute">return</span> np.array_equal(oldCentroids, centroids)  </span><br><span class="line"><span class="comment"># Function: Get Labels</span></span><br><span class="line"><span class="comment"># -------------</span></span><br><span class="line"><span class="comment"># Update a label for each piece of data in the dataset. </span></span><br><span class="line"><span class="attribute">def</span> updateLabels(dataSet, centroids):</span><br><span class="line">    <span class="comment"># For each element in the dataset, chose the closest centroid. </span></span><br><span class="line">    <span class="comment"># Make that centroid the element&#x27;s label.</span></span><br><span class="line">    <span class="attribute">numPoints</span>, numDim = dataSet.shape</span><br><span class="line">    <span class="attribute">for</span> i in range(<span class="number">0</span>, numPoints):</span><br><span class="line">        <span class="attribute">dataSet</span>[i, -<span class="number">1</span>] = getLabelFromClosestCentroid(dataSet[i, :-<span class="number">1</span>], centroids)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="attribute">def</span> getLabelFromClosestCentroid(dataSetRow, centroids):</span><br><span class="line">    <span class="attribute">label</span> = centroids[<span class="number">0</span>, -<span class="number">1</span>];</span><br><span class="line">    <span class="attribute">minDist</span> = np.linalg.norm(dataSetRow - centroids[<span class="number">0</span>, :-<span class="number">1</span>])</span><br><span class="line">    <span class="attribute">for</span> i in range(<span class="number">1</span> , centroids.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="attribute">dist</span> = np.linalg.norm(dataSetRow - centroids[i, :-<span class="number">1</span>])</span><br><span class="line">        <span class="attribute">if</span> dist &lt; minDist:</span><br><span class="line">            <span class="attribute">minDist</span> = dist</span><br><span class="line">            <span class="attribute">label</span> = centroids[i, -<span class="number">1</span>]</span><br><span class="line">    <span class="attribute">print</span> <span class="string">&quot;minDist:&quot;</span>, minDist</span><br><span class="line">    <span class="attribute">return</span> label</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="comment"># Function: Get Centroids</span></span><br><span class="line"><span class="comment"># -------------</span></span><br><span class="line"><span class="comment"># Returns k random centroids, each of dimension n.</span></span><br><span class="line"><span class="attribute">def</span> getCentroids(dataSet, k): # 算出新的中心点</span><br><span class="line">    <span class="comment"># Each centroid is the geometric mean of the points that</span></span><br><span class="line">    <span class="comment"># have that centroid&#x27;s label. Important: If a centroid is empty (no points have</span></span><br><span class="line">    <span class="comment"># that centroid&#x27;s label) you should randomly re-initialize it.</span></span><br><span class="line">    <span class="attribute">result</span> = np.zeros((k, dataSet.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="attribute">for</span> i in range(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">        <span class="attribute">oneCluster</span> = dataSet[dataSet[:, -<span class="number">1</span>] == i, :-<span class="number">1</span>]</span><br><span class="line">        <span class="attribute">result</span>[i - <span class="number">1</span>, :-<span class="number">1</span>] = np.mean(oneCluster, axis = <span class="number">0</span>)</span><br><span class="line">        <span class="attribute">result</span>[i - <span class="number">1</span>, -<span class="number">1</span>] = i</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">return</span> result</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="attribute">x1</span> = np.array([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="attribute">x2</span> = np.array([<span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="attribute">x3</span> = np.array([<span class="number">4</span>, <span class="number">3</span>])</span><br><span class="line"><span class="attribute">x4</span> = np.array([<span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"><span class="attribute">testX</span> = np.vstack((x<span class="number">1</span>, x<span class="number">2</span>, x<span class="number">3</span>, x<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="attribute">result</span> = kmeans(testX, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"><span class="attribute">print</span> <span class="string">&quot;final result:&quot;</span></span><br><span class="line"><span class="attribute">print</span> result</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Lambda</title>
    <url>/post/d431fab4.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基本用法"><a class="markdownIt-Anchor" href="#基本用法"></a> 基本用法</h1>
<p>例如：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">names.<span class="keyword">forEach</span>((<span class="type">name</span>)-&gt;<span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span>));</span><br><span class="line">names.<span class="keyword">forEach</span>(<span class="keyword">System</span>.<span class="keyword">out</span>::println);//可以通过这种方式直接调用println</span><br></pre></td></tr></table></figure>
<p>基本语法； <code>(Type1 param1,Type2 param2,...)-&gt;&#123;statment1, statment2... return statmentM;&#125;</code></p>
<p>一般来讲，这个其实是接口或抽象类的简化。但是不是所有的类都可以使用Lambda的。</p>
<p>只有声明了函数式接口：<code>public @interface FunctionalInterface</code>才可以被Lambda赋值。这个就是可以简写的原因。通过函数式接口可以直接定位到这个类的某一个函数，然后就可以省略函数名等一系列要素.</p>
<p>例如：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">(<span class="built_in">String</span> name)</span>-&gt;</span>&#123;</span><br><span class="line">              System.out.println(name);</span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>这个是基础型，还有许多简化型：</p>
<ul>
<li>参数类型可以省略。例如上面可以把String省略，因为一般编译器都可以判断出来</li>
<li>当参数只有一个时，可以省略小括号（但是私以为还是写上的好，为了统一）</li>
<li>只有一条语句时，可以省略大括号。并且如果return没有返回值，也可以省略。也就是最前面第一个例子的写法。</li>
<li>也可以只包含一个普通表达式。语法：<code>(Type val1,Type val2...)-&gt;(expression)</code>。例如：<code>(int a, int b)-&gt;(a*b+2)</code></li>
</ul>
<h1 id="用lambda代替内部类"><a class="markdownIt-Anchor" href="#用lambda代替内部类"></a> 用Lambda代替内部类</h1>
<p>例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(()</span>-&gt;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Hello world!&quot;</span>)).start<span class="literal">()</span>;<span class="comment">//方法1</span></span><br><span class="line"></span><br><span class="line">Runnable race = <span class="literal">()</span>-&gt;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Hello world!&quot;</span>);<span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(<span class="params">race</span>)</span>.start<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<p>上面这个例子完整写法是：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">       <span class="keyword">new</span> Runnable()</span><br><span class="line">       &#123;    <span class="comment">//这是一个Runnable的匿名类</span></span><br><span class="line">           <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="comment">//匿名类定义结束</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>至于匿名内部类，<a href="https://xinhecuican.github.io/post/348d4e04.html">可以参考</a></p>
<p>省去new和类名/接口名。并且直接实现run方法。此外()代表的是接口内部方法的参数，因为run()没有参数，所以这里也不写</p>
<h1 id="foreach和排序"><a class="markdownIt-Anchor" href="#foreach和排序"></a> forEach()和排序</h1>
<p>forEach定义： forEach(Consumer&lt;? super T&gt; action);</p>
<p>其中action实例必须实现Comsumer接口的accept(T t)方法。action指定具体的行为。</p>
<p>从jdk5开始，集合都实现了Iterable接口。也就是可以使用forEach()</p>
<p>例如：<code>names.forEach((name)-&gt;System.out.println(name+&quot;,&quot;));</code></p>
<p>上面的Lambda表达式相当于Consumer的匿名对象。</p>
<p><strong>排序</strong><br />
实际上就是简化了Comparator接口或者其他有关排序接口的写法。例如：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">Comparator&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">sortByName</span> = <span class="params">(<span class="built_in">String</span> s1,<span class="built_in">String</span> s2)</span>-&gt;</span>(s1.compareTo(s2));</span><br><span class="line">Collections.sort(names,sortByName);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">Collections.sort<span class="function"><span class="params">(names,(<span class="built_in">String</span> s1,<span class="built_in">String</span> s2)-&gt;(s1.compareTo(s2)))</span>;</span></span><br></pre></td></tr></table></figure>
<h1 id="和streamapi联合"><a class="markdownIt-Anchor" href="#和streamapi联合"></a> 和streamapi联合</h1>
<p>Stream接口是JDK8开始提供的，它可以充当Java集合的适配器。</p>
<p>方法：</p>
<ul>
<li>filter(Predicate&lt;? super T&gt; predivate); 返回包含符合条件元素的流</li>
<li>forEach(Consumer&lt;? super T&gt; action); 遍历集合中的元素</li>
<li>limit(long maxSize): 返回maxSize个数的元素</li>
<li>max(Comparator&lt;? super T&gt; comparator): 根据规则返回最大的元素</li>
<li>min(Comparator&lt;? super T&gt; comparator)</li>
<li>sorted(): 对集合中的元素自然排序</li>
<li>sorted(Comparator&lt;? super T&gt;</li>
<li>mapToInt(ToIntFunction&lt;? super T&gt; comparator)： 返回一个intStream型对象</li>
<li>mapToLong(ToLongFunction&lt;? super T&gt; mapper)</li>
<li>toArray(): 返回包含集合所有元素的对象数组</li>
</ul>
<h1 id="lambda表达式变量作用域"><a class="markdownIt-Anchor" href="#lambda表达式变量作用域"></a> Lambda表达式变量作用域</h1>
<p>Lambda可以访问外部类的所有变量。还可以使用this，这里this引用的是外部类。例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">String</span>[] data = &#123;<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Mary&quot;</span>&#125;;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; names = Arrays.asList(data);</span><br><span class="line">        <span class="keyword">char</span> var2 = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        names.forEach((name)-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            var1++;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="keyword">this</span>.var1+<span class="string">&quot;:&quot;</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> A().test();</span><br><span class="line">    |</span><br><span class="line">|</span><br></pre></td></tr></table></figure>
<p>但是要注意一点，只能使用final修饰或者程序中不会改变的局部变量。这个类似于匿名内部类（实际上Lambda有匿名内部类的功能）。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Linux重定向与管道</title>
    <url>/post/22102.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="标准输入-标准输出和标准错误"><a class="markdownIt-Anchor" href="#标准输入-标准输出和标准错误"></a> 标准输入 标准输出和标准错误</h3>
<p>基本思想：每个基于文本的程序都可以从任何源接受输入，并向任何目标输出</p>
<p>标准输入指的是一种读取数据的通用办法，标准输出有两种，一种是标准输出，另一种是标准错误</p>
<p>而输入输出其实正常情况下有shell决定。为了保证程序的输出，需要告诉shell将输出目标设置成文件。</p>
<h3 id="重定向标准输出"><a class="markdownIt-Anchor" href="#重定向标准输出"></a> 重定向标准输出</h3>
<p>在登陆时，shell会自动将标准输入设置成键盘，将标准输出和标准错误设置成屏幕。</p>
<p>但是每次输入命令时，可以告诉shell在此命令执行期间更换输入输出对象。</p>
<p>如果想把一个命令输出送到一个文件中，例如sort命令 可以写成 sort &gt; names</p>
<p>以这种命令输出时，如果文件不存在，shell会自动创建这个文件。如果文件存在，那他将会把文件内容全部清空然后再把内容输入到里面去</p>
<p>如果我们只想追加内容到这个文件中，可以用 &gt;&gt; 。如果文件不存在，这个命令也会创建新文件，如果存在，那么会追加内容到后面。</p>
<p>如果取消清空文件重新输入的选项，可以设置nonclobber选项。但是设置完之后，如果确实想替换掉这个文件，可以临时忽略掉noclobber，这时需要用<code>&gt;|</code>替换 &gt;</p>
<h4 id="重定向标准输入"><a class="markdownIt-Anchor" href="#重定向标准输入"></a> 重定向标准输入</h4>
<p>符号： &lt;</p>
<p>左边是你要运行的程序，右边是你有读入数据的文件</p>
<p>例如 sort &lt; /etc/passwd</p>
<p>标准输入和标准输出可以同时指定</p>
<p>例如 sort &lt; rawdata &gt; report，这个命令会把rawdata中的数据给sort处理，然后把结果给report文件</p>
<h4 id="重定向标准错误"><a class="markdownIt-Anchor" href="#重定向标准错误"></a> 重定向标准错误</h4>
<p>shell提供两种输出目标，标准输出和标准错误。正常情况下，两种输出同时显示在屏幕上，在需要时，可以把两种输出分隔开。</p>
<p>首先对unix处理I/O过程了解。每个输入源和每个输出目标都有一个唯一的数字标识，，这个数字 称为文件描述符。例如一个进程可能从#8中读取数据，并将文件写入#6中</p>
<p>例如为了将输出写入到文件8中，可以sort 8&gt; results，results就是第8个文件</p>
<p>默认情况下，Unix为每个进程提供三个预定义的文件描述符。而且大多数时候都可以使用。0代表标准输入，1代表标准输出，3代表标准错误。</p>
<p>所以要想重定向输入，可以用 0&lt;</p>
<p>而要想重定向标准输出，可以用 1&gt; ,这样错误信息就会留在屏幕上便于我们查看，而输出信息在文件中。如果想让标准错误在文件中，可以 2&gt;</p>
<p>此外，平常写的 &gt; 实际上代表的是 1&gt;</p>
<h4 id="子shell"><a class="markdownIt-Anchor" href="#子shell"></a> 子shell</h4>
<p>进程就是加载到内存中准备运行的程序，当进程需要启动另一个进程的时候，这个进程创建了一个副本进程，原始跌进程叫做父进程，而这个进程叫做子进程。</p>
<p>而子进程一旦结束，优惠唤醒父进程继续执行命令，此时子进程消失。</p>
<p>子shell指的是在父shell中重新开一个shell，这样在子shell中造成的改变不会影响父shell，甚至是环境变量也一样，除非把它写入初始化文件中，不然这个全局变量也会随着子shell进程的结束而消亡。</p>
<p>如果有时你想在子shell中执行一条指令，又不想启动一个全新的shell，那么一个办法就是在外面加上小括号(),例如 （date）</p>
<h4 id="组合标准重定向输出和错误"><a class="markdownIt-Anchor" href="#组合标准重定向输出和错误"></a> 组合标准重定向输出和错误</h4>
<p>在bash中，基本思想是建议将一种类型的输出重定向到一个文件，然后再追加</p>
<p>command x&gt; outputfile y&gt;&amp;x</p>
<p><code>&gt;&amp;</code> 符号的意思是替代</p>
<p>y&gt;&amp; x的意思是把2的输出发送给1相同的位置。</p>
<p>例： sort 2&gt;&amp;1 &gt;output 这个意思是把2的输出发送到与一相同的位置，而一是发送到屏幕的，于是2也发送到屏幕了</p>
<h4 id="抛弃输出"><a class="markdownIt-Anchor" href="#抛弃输出"></a> 抛弃输出</h4>
<p>为什么要抛弃输出呢？</p>
<p>有时候，需要运行一个程序。因为可能你并不关心这个文件的输出。有时候，可能希望查看文件正常输出，而不关心错误信息。</p>
<p>那么这个时候只需要重定向输出到 /etc/null即可。这个文件的特殊之处在于发送给他的任何东西都会消失。所以 它有个奇怪的名字叫做 位桶(bit bucket)</p>
<h3 id="管道线"><a class="markdownIt-Anchor" href="#管道线"></a> 管道线</h3>
<p>管道线的作用就是让各个程序组合发挥作用</p>
<p>shell允许创建一系列的命令，在这一系列的命令中，一个命令的标准输出可以发送给下一个程序的标准输入。当这样做时，两个程序之间的连接就是管道，而命令序列本身叫做管道线。</p>
<p>在创建管道线时，只需将希望键入的命令用竖线| （管道符号） 分隔开即可</p>
<p>能从标准输入读取文本，并向标准输出写入文本的程序，称为过滤器。</p>
<h4 id="管道线分流-tee"><a class="markdownIt-Anchor" href="#管道线分流-tee"></a> 管道线分流 tee</h4>
<p>有时候，可能希望把程序的输出发送到两个地方</p>
<p>语法： tee [-a] file…</p>
<p>file就是希望将数据发送到的文件的名称</p>
<p>例：cat name1 name2 | tee masterlist | grep Harley</p>
<p>这个指令中的tee 会将输出保存到masterlist中并且将cat的输出给grep</p>
<p>同样，如果这个文件存在，那么tee将会重写这个文件。如果想要追加内容，那么可以tee -a(append)</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>SQL语句速查</title>
    <url>/post/d213fc7f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基础名词"><a class="markdownIt-Anchor" href="#基础名词"></a> 基础名词</h1>
<ul>
<li>数据库： 保存有组织数据的容器，一般是一个或一组文件</li>
<li>表： 表在数据库中，用来进行分类存储各式各样的信息。如果把数据库看为一个柜子，那么表就是一个个抽屉，里面装着一些文件。表在实际应用中可以是顾客清单，产品目录等。</li>
<li>列： 表是由列和行构成。例如一个城市信息表，它的列可以使地址，城市，州，邮政编码等等。</li>
<li>行： 行是表中的一个记录。例如一个学生信息表，一个行包含一个学生的名字、年龄、性别等信息。</li>
<li>主键： 是一列，这一列可以唯一的标识每一个行。例如身份证号可以唯一的标识每一个人，而姓名不可以。因此身份证号可以作为主键。</li>
</ul>
<h1 id="use和show"><a class="markdownIt-Anchor" href="#use和show"></a> USE和SHOW</h1>
<ul>
<li>USE 数据库名：
<ul>
<li>使用某个数据库</li>
</ul>
</li>
<li>SHOW DATABASES：
<ul>
<li>返回可用数据库的列表</li>
</ul>
</li>
<li>SHOW TABLES：
<ul>
<li>展示数据库内列表的信息</li>
</ul>
</li>
<li>SHOW COLUMNS FROM 列表名：
<ul>
<li>DESCRIBE 列表名作用与它相同</li>
<li>展示数据列（表头）的信息.下面是一个输出样例<img src="/images/MySQL%E8%AF%AD%E5%8F%A5%E9%80%9F%E6%9F%A51.PNG" alt="" /></li>
</ul>
</li>
<li>SHOW STATUS：
<ul>
<li>用于显示服务器状态信息</li>
</ul>
</li>
<li>SHOW CREATE DATABASE和 SHOW CREATE TABLE
<ul>
<li>分别用来显示创建特定数据库或表</li>
</ul>
</li>
<li>SHOW GRANTS：
<ul>
<li>用来显示用户的安全权限</li>
</ul>
</li>
<li>SHOW ERRORS和SHOW WARNINGS：
<ul>
<li>用来显示服务器错误或警告信息</li>
</ul>
</li>
</ul>
<h1 id="select"><a class="markdownIt-Anchor" href="#select"></a> SELECT</h1>
<ul>
<li>SELECT 列名 FROM 表名：
<ul>
<li>展示某个表中某一列的详细信息</li>
<li>列名可以有多个，同时检索多个列</li>
<li>列名前可以添加表名，表名前可以添加数据库名进行限定。</li>
<li>列名可以用<code>*</code>代替来检索所有列</li>
<li>可以通过DISTINCT来排除相同的行（这时不能同时检索多个列）。例如<code>SELECT DISTINCT order_num FROM orderitems;</code></li>
</ul>
</li>
<li>LIMIT子句可用于限制结果行数。例如 SELECT prod_name FROM products LIMIT 5;限制为5行。LIMIT 5, 5;只显示从第五行开始的五行。<strong>注意</strong>：下标也是从0开始。</li>
</ul>
<h2 id="order-by子句排序"><a class="markdownIt-Anchor" href="#order-by子句排序"></a> ORDER BY子句（排序）</h2>
<ul>
<li>ORDER BY + 要排序的列;
<ul>
<li>以升序进行排序。 例如<code>SELECT cust_address FROM customers ORDER BY cust_address;</code></li>
<li>要排序的列可以有多个，这时先对第一个列进行排序，然后对第二个列进行排序。</li>
<li>可以在后面加上 DESC表明是降序排序。例如<code>SELECT cust_address, cust_name FROM customers ORDER BY cust_address DESC, cust_name;</code></li>
</ul>
</li>
</ul>
<h2 id="where子句过滤数据"><a class="markdownIt-Anchor" href="#where子句过滤数据"></a> where子句（过滤数据）</h2>
<p>where子句挑选出满足限制条件的行。</p>
<p>例：<code>SELECT prod_name, prod_price FROM products WHERE prod_price=2.50;</code></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>…</td>
</tr>
<tr>
<td>&gt;=</td>
<td>…</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在指定的两个值之间，还要加上AND，例如<code>SELECT prod_name, prod_price FROM products WHERE prod_price BETWEEN 1 AND 2.5;</code></td>
</tr>
<tr>
<td>IS NULL</td>
<td>检测是否是空值,例如<code>SELECT cust_id FROM customers WHERE cust_email IS NULL</code></td>
</tr>
</tbody>
</table>
<p>进行比较的数据也可以是char型。例如：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> prod_name = <span class="string">&#x27;Fuses&#x27;</span>;</span><br><span class="line"></span><br><span class="line">输出: Fuses	3.42</span><br></pre></td></tr></table></figure>
<p>MySQL默认是不区分大小写的，但是有的软件会帮助区分。</p>
<h3 id="组合操作符andor-in-not"><a class="markdownIt-Anchor" href="#组合操作符andor-in-not"></a> 组合操作符（AND,OR， IN， NOT）</h3>
<p><strong>AND</strong></p>
<p>两个条件同时发生才为真。和c语言的&amp;&amp;作用类似。</p>
<p>例如：<br />
<code>SELECT vend_id, prod_price FROM products WHERE vend_id=1003 AND prod_price &lt; 10;</code></p>
<p><img src="/images/MySQL%E8%AF%AD%E5%8F%A5%E9%80%9F%E6%9F%A52.PNG" alt="" /></p>
<p><strong>OR</strong></p>
<p>和上面一个相似</p>
<p><strong>AND，OR组合</strong></p>
<p>AND和OR都可以有无数个，并且这两个还可以组合使用。</p>
<p>例如：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1002</span> <span class="keyword">OR</span> vend_id = <span class="number">1003</span> <span class="keyword">AND</span> prod_price &gt;= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">Fuses 3.42</span><br><span class="line">Oil can 8.99</span><br><span class="line">Detonator 13.00</span><br><span class="line">Bird seed 10.00</span><br><span class="line">Safe 	 50.00</span><br><span class="line">TNT    10.00</span><br></pre></td></tr></table></figure>
<p>上面的输出竟然有两个是小于10的，这是由于优先级导致的</p>
<blockquote>
<p>AND的优先级比OR高，因此在写复杂表达式时最好用括号包围表达式</p>
</blockquote>
<p><strong>IN</strong></p>
<p>IN和BETWEEN类似，都是用来表示条件的范围，例如：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1002</span>, <span class="number">1003</span>);</span><br><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">BETWEEN</span> <span class="number">1002</span> <span class="keyword">AND</span> <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>
<p>上面这两条语句的作用是相同的。</p>
<p>IN的优点如下：</p>
<ul>
<li>IN更方便、简洁；</li>
<li>IN比一般的OR执行更快；</li>
<li>IN中还可以包含其他SELECT语句。</li>
</ul>
<p><strong>NOT</strong></p>
<p>NOT的作用就是否定它之后的条件。可以对IN， BETWEEN和EXISTS子句取反。</p>
<p>例如：<code>SELECT prod_name, prod_price FROM products WHERE vend_id NOT IN (1002, 1003);</code></p>
<h1 id="通配符与正则表达式"><a class="markdownIt-Anchor" href="#通配符与正则表达式"></a> 通配符与正则表达式</h1>
<blockquote>
<p>想要使用通配符，必须要使用<strong>LIKE</strong>操作符。LIKE后面加上搜索模式进行匹配。</p>
</blockquote>
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%</td>
<td>匹配任意字符任意次数</td>
</tr>
<tr>
<td>_</td>
<td>匹配任意一个字符</td>
</tr>
</tbody>
</table>
<p>例如：<code>select cust_address FROM customers WHERE cust_address LIKE &quot;%Lane&quot;;</code></p>
<blockquote>
<p>使用正则表达式只需要将LIKE换成REGEXP即可。<a href="https://xinhecuican.github.io/post/26477.html">正则表达式语法可看这篇文章的正则表达式部分</a></p>
</blockquote>
<h1 id="拼接字段"><a class="markdownIt-Anchor" href="#拼接字段"></a> 拼接字段</h1>
<p>可以用Concat函数拼接不同的字段。例如：<code>Concat(vend_name, '(', vend_country, ')')</code>由四部分拼接而成。</p>
<p>有时候需要删除右侧多余的空格，可以使用<code>RTrim(str)</code>。如果想删除左侧空格或者两侧空格可以使用LTrim或Trim.</p>
<p>例：</p>
<p><code>SELECT Concat(RTrim(vend_name), ' (', RTrim(vend_country), ') ') FROM vendors ORDER BY vend_name;</code></p>
<p>结果输出： ACME (USA)</p>
<p>可以使用<strong>AS</strong>关键字为拼接后的字段赋予别名。</p>
<p>例：<code>SELECT Concat(RTrim(vend_name), ' (', RTrim(vend_country), ') ') AS vend_title FROM vendors ORDER BY vend_name;</code></p>
<p>输出</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">vend_title</span></span><br><span class="line"><span class="selector-tag">ACME</span> (USA) </span><br><span class="line"><span class="selector-tag">Anvils</span> <span class="selector-tag">R</span> <span class="selector-tag">Us</span> (USA) </span><br><span class="line"><span class="selector-tag">Furball</span> <span class="selector-tag">Inc</span>. (USA) </span><br><span class="line"><span class="selector-tag">Jet</span> <span class="selector-tag">Set</span> (England) </span><br><span class="line"><span class="selector-tag">Jouets</span> <span class="selector-tag">Et</span> <span class="selector-tag">Ours</span> (France) </span><br><span class="line"><span class="selector-tag">LT</span> <span class="selector-tag">Supplies</span> (USA) </span><br></pre></td></tr></table></figure>
<p>除了让Concat结果赋予名字外，还可以对算术计算结果赋予名字。算术计算支持加减乘除。</p>
<p>例如：<code>quantity * item_price AS expanded_price</code></p>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<h2 id="文本处理函数"><a class="markdownIt-Anchor" href="#文本处理函数"></a> 文本处理函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Left(str, len)</td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td>Length(str)</td>
<td>返回串的长度</td>
</tr>
<tr>
<td>Locate(substr, str, begin_len)</td>
<td>找出一个串的子串</td>
</tr>
<tr>
<td>Lower(str)</td>
<td>将串变成小写</td>
</tr>
<tr>
<td>LTrim(str)</td>
<td>去掉左边的空格</td>
</tr>
<tr>
<td>Right(str, len)</td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td>RTrim(str)</td>
<td>去掉串右边的空格</td>
</tr>
<tr>
<td>Soundex(str)</td>
<td>返回串的SOUNDEX值</td>
</tr>
<tr>
<td>SubString(str, pos, len)</td>
<td>返回子串的字符</td>
</tr>
<tr>
<td>Upper(str)</td>
<td>将串变成大写</td>
</tr>
</tbody>
</table>
<p>其中SOUNDEX是一个将字符串转化成按照语音表示的数字的算法。</p>
<p>例如：Y.lee和Y.lie虽然拼写不同但是读起来相同，这样他们的Soundex是相同的。</p>
<h2 id="日期和时间处理函数"><a class="markdownIt-Anchor" href="#日期和时间处理函数"></a> 日期和时间处理函数</h2>
<p>日期的格式是yyyy-mm-dd。例如2005-11-9.并且最好使用四位数的年份。</p>
<p>时间的格式是 hh:mm:ss</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AddDate(date, INTERVAL sum unit)</td>
<td>增加一个日期</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date(expr)</td>
<td>返回日期的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>更复杂的日期增加</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间</td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期中的天数部分</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>返回星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回分钟</td>
</tr>
<tr>
<td>Month()</td>
<td>…</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前的日期和时间</td>
</tr>
<tr>
<td>Second()</td>
<td>…</td>
</tr>
<tr>
<td>Time</td>
<td>返回一个日期和时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>例如 ：<code>SELECT DATE_ADD('1998-01-02', INTERVAL 31 DAY);</code></p>
<p>INTERVAL是经过的意思，也就是过31天。后面也可以加MONTH，YEAR，HOUR等。</p>
<p>expr就是标准的日期时间或只有日期。要注意日期都是字符串，都要加引号。</p>
<h2 id="数值处理函数"><a class="markdownIt-Anchor" href="#数值处理函数"></a> 数值处理函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Abs()</td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td>Cos()</td>
<td>…</td>
</tr>
<tr>
<td>Exp()</td>
<td>返回一个数的指数</td>
</tr>
<tr>
<td>Mod()</td>
<td>返回一个数的余数，相当于 %</td>
</tr>
<tr>
<td>Pi()</td>
<td>返回圆周率</td>
</tr>
<tr>
<td>Rand()</td>
<td>返回随机数</td>
</tr>
<tr>
<td>Sin()</td>
<td>…</td>
</tr>
<tr>
<td>Sqrt()</td>
<td>返回平方根</td>
</tr>
<tr>
<td>Tan()</td>
<td>返回一个数的正切值</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>RNN及其拓展</title>
    <url>/post/aa1eade8.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="rnn"><a class="markdownIt-Anchor" href="#rnn"></a> RNN</h1>
<p>RNN的特点是上一次输入会对下一次产生影响，相当于有了记忆功能，常用于自然语言处理。</p>
<p><img src="/images/RNN1.jpg" alt="" /></p>
<p>这是RNN的结构图，它与传统神经网络的区别是在隐藏层有了一个循环。</p>
<p><img src="/images/RNN2.jpg" alt="" /></p>
<p>这张图的含义是每一个时间点都可以有输出o，也可以没有。每一个时间点隐藏层输出作为下一个隐藏层的输入，也就是说该次训练对下一次训练会产生影响。</p>
<p>网上演示的时候隐藏层只有一层，这里就以一层为例。</p>
<p>隐藏层计算：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">z<span class="comment">(h)</span><span class="comment">(t)</span>=U⋅x<span class="comment">(t)</span>+W⋅s<span class="comment">(t−1)</span> <span class="attr">#s(t-1</span>)是前一刻隐藏层输出</span><br><span class="line">s<span class="comment">(t)</span>=fh<span class="comment">(z(h)</span><span class="comment">(t)</span>)</span><br></pre></td></tr></table></figure>
<p>s(t)是隐藏层输出， fh是激活函数，一般使用tanh或LeRu。</p>
<p>输出层使用softmax函数进行转换，然后损失函数使用交叉熵</p>
<p>Lt=−∑（N， i=0）yi(t)log(oi(t))</p>
<p>其中yi是真实值，oi是预测值</p>
<h2 id="bptt"><a class="markdownIt-Anchor" href="#bptt"></a> BPTT</h2>
<p>BPTT是RNN所使用的反向传播算法。它和传统反向传播算法的区别是它还要照顾到W（前一层到这一层的权重）</p>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C15.PNG" alt="" /></p>
<p>大体上还是使用这四个式子</p>
<p>δk(t) 表示t时刻损失函数对output layer 节点的输入zk(t)的导数（也就是求上面方程中第一个式子）。</p>
<p>δk(t) = o(t) - 1</p>
<p>所以∂Lt \ ∂V = (o(t) - 1) * s(t)</p>
<p>δk(h)(t) = [δ(o)(t) ⋅ Vk] ∙ [1 − sk(t)^2]</p>
<p>所以 ∂Lt \ ∂U = δ(h)(t) * x(t)</p>
<p>向w传播的 δ(h)(t−1)=[δ(h)(t)⋅W] ∙ <a href="%E8%BF%99%E9%87%8C%E5%8C%BA%E5%88%AB%E5%B0%B1%E6%98%AFs(t-1)%E5%92%8CW">1−s(t−1)^2</a></p>
<p>∂Lt \ ∂W = δ(h)(t) *  s(t-1)</p>
<h1 id="lstm"><a class="markdownIt-Anchor" href="#lstm"></a> LSTM</h1>
<p>RNN的缺陷是会出现梯度消失现象，因此无法保存长时间记忆。LSTM通过两条记忆途径使得可以保存长时间记忆。</p>
<p><img src="/images/RNN2.webp" alt="" /><br />
这是LSTM的结构图，其中上面那一条线代表长时间记忆，下面那一条代表短时记忆。而保存在尝试记忆中的信息由几个门控制。</p>
<p><img src="/images/RNN3.webp" alt="" /></p>
<p>这是第一个门控忘记门，用来剔除不重要的信息。至于为什么能忘掉不重要信息，只能说这是神经网络自己决定的（没找到解释）。如果某一项为0代表舍弃，为1代表全部保留。</p>
<p>公式中<code>Wf⋅[ht−1,xt] = Wfh * h(t−1) + Wfx * xt</code>。wf可以看成是两个矩阵拼接而成，然后对应和输入相乘。</p>
<p><img src="/images/DNN4.webp" alt="" /></p>
<p>记忆门，这个门决定我们要记忆什么，迁前一部分是删去要舍弃的记忆，后面一部分是加上要记住的东西。注意Ct是tanh</p>
<p><img src="/images/DNN5.webp" alt="" />更新长期记忆。</p>
<p><img src="/images/DNN6.webp" alt="" /> 输出门。更新ht并输出</p>
<h2 id="反向更新"><a class="markdownIt-Anchor" href="#反向更新"></a> 反向更新</h2>
<p>首先确定更新内容。我们要更新四个b，四个w。其中w又要拆分成两部分，所以总共更新12个量。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">δTo,<span class="built_in">t</span>=δTt⨀<span class="built_in">tanh</span>(ct)⨀ot⨀(<span class="number">1</span>−ot)</span><br><span class="line">δTf,<span class="built_in">t</span>=δTt⨀ot⨀(<span class="number">1</span>−<span class="built_in">tanh</span>(ct)<span class="number">2</span>)⨀ct−<span class="number">1</span>⨀ft⨀(<span class="number">1</span>−ft)</span><br><span class="line">δTi,<span class="built_in">t</span>=δTt⨀ot⨀(<span class="number">1</span>−<span class="built_in">tanh</span>(ct)<span class="number">2</span>)⨀ct^⨀it⨀(<span class="number">1</span>−it)</span><br><span class="line">δTc^,<span class="built_in">t</span>=δTt⨀ot⨀(<span class="number">1</span>−<span class="built_in">tanh</span>(ct)<span class="number">2</span>)⨀it⨀(<span class="number">1</span>−c^<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">yt=σ(Vht+by) // 当前状态输出</span><br><span class="line">δ<span class="built_in">t</span>=∂E \ ∂ht = Vσ`</span><br><span class="line"></span><br><span class="line">∂E \ ∂Woh,<span class="built_in">t</span> = δo,<span class="built_in">t</span> * h(<span class="built_in">t</span>−<span class="number">1</span>)</span><br><span class="line">其他三个 同理</span><br><span class="line"></span><br><span class="line">∂E \ ∂bo,<span class="built_in">t</span> = δo,<span class="built_in">t</span></span><br><span class="line">其他三个同理</span><br><span class="line"></span><br><span class="line">∂E \ ∂Wox = δo,<span class="built_in">t</span> * xt</span><br></pre></td></tr></table></figure>
<p><a href="https://ilewseu.github.io/2018/01/06/LSTM%E5%8F%82%E6%95%B0%E6%9B%B4%E6%96%B0%E6%8E%A8%E5%AF%BC/">反向更新具体过程可看</a></p>
<h1 id="gru"><a class="markdownIt-Anchor" href="#gru"></a> GRU</h1>
<p>GRU相比于LSTM所花的时间更短，但是达成的效果差不多。</p>
<p><img src="/images/RNN7.svg" alt="" />可以看到GRU只有一个参量要传递给下一个单元，并且需要更新的量也减少。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">Rt</span>=σ(Xt * Wxr+H(t−<span class="number">1</span>) * Whr+br)</span><br><span class="line"><span class="attr">Zt</span>=σ(Xt * Wxz+H(t−<span class="number">1</span>) * Whz+bz)</span><br></pre></td></tr></table></figure>
<p>这是重置门和更新门的计算公式，和LSTM计算方法相同，实际上GRU借鉴了LSTM的思想。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">H~<span class="built_in">t</span>=<span class="built_in">tanh</span>(Xt * Wxh + (Rt ⊙ H(<span class="built_in">t</span>−<span class="number">1</span>)) * Whh + bh) #重置门指的是重置H(<span class="built_in">t</span>-<span class="number">1</span>)</span><br><span class="line">Ht=Zt ⊙ H(<span class="built_in">t</span>−<span class="number">1</span>) + (<span class="number">1</span>−Zt) ⊙ H~<span class="built_in">t</span></span><br><span class="line">最后的zt和<span class="number">1</span>-zt决定要记住新内容多还是老内容多，例如 zt=<span class="number">1</span>/<span class="number">3</span>, 那么老内容一次运行就只剩下<span class="number">1</span>/<span class="number">3</span>.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Python 爬取</title>
    <url>/post/3de4bc69.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="requests"><a class="markdownIt-Anchor" href="#requests"></a> requests</h1>
<p>requests用来爬取网站上的信息。有七个主要方法</p>
<ul>
<li>r = requests.get(url， params， ** kwargs): url是你想爬取网站的url。通过get构造了一个向服务器请求资源的Request对象。返回一个包含服务器资源的Response对象。</li>
<li>head(): 获取网页头部信息</li>
<li>post(url, data, json, kwargs): 在后面添加数据。默认如果是列表等会存储到form字段下，如果是字符串会存在data字段下</li>
<li>put(): 覆盖网页某一字段数据。例如上传字符串会把data字段覆盖</li>
<li>patch(): 删改某一位置信息（和put的区别是put必须全部删除，patch只需要修改需要改的部分）</li>
<li>delete(): 删除url处的资源</li>
<li>request(method, url, ** kwargs): method有七种，分别是’GET’,'OPTIONS’等，注意其中delete是小写。</li>
</ul>
<p>kwargs参数（get,put, patch要比request少params，head,delete相同，post11个）：</p>
<ul>
<li>params： 输入参数</li>
</ul>
<p>例子 <img src="/images/python%E7%88%AC%E5%8F%963.PNG" alt="" /></p>
<ul>
<li>data： 提交资源，一般用用字典的形式</li>
<li>json： 可以作为request的内容</li>
<li>headers： http头字段</li>
<li>cookies：</li>
<li>auth： http认证功能</li>
<li>files： 传输文件时使用</li>
<li>timeout： 设定的超时时间</li>
<li>proxies： 设定访问代理服务器</li>
<li>allow_redirects: 默认是True。重定向开关</li>
<li>stream： 是否对获取内容立即下载。默认立即下载</li>
<li>verify： 认证SSL证书字段</li>
<li>cert： 保存本地ssl路径字段</li>
</ul>
<p>Response对象属性：</p>
<ul>
<li>status_code: 200表示成功，404表示失败（不是200就是失败）</li>
<li>text： 爬取内容的字符串形式。</li>
<li>encoding： 猜测的编码形式。这是从服务器的charset字段获得的。如果服务器中没有charset字段，那么会返回ISO-8859-1</li>
<li>apparent_encoding: 备选编码形式.它是根据内容分析的（可能这个更加准确）</li>
<li>content： 爬取内容的二进制形式</li>
<li>request: response对应的request对象</li>
</ul>
<h2 id="爬取模板"><a class="markdownIt-Anchor" href="#爬取模板"></a> 爬取模板</h2>
<p>requests异常种类：<img src="/images/python%E7%88%AC%E5%8F%961.PNG" alt="" /></p>
<p>模板：<img src="/images/python%E7%88%AC%E5%8F%962.PNG" alt="" /></p>
<p>有些网页会拒绝爬虫的爬取，这个时候我们可以通过更改头部信息让我们看上去是浏览器爬取。模板为：</p>
<p><img src="/images/python%E7%88%AC%E5%8F%964.PNG" alt="" /></p>
<p>想要运用爬虫使用搜索引擎。首先要知道搜索引擎的接口，百度的接口是<code>http://www.baidu.com/s?wd=keyword</code>.360的接口是 <code>http://www.so.com/s?q=keyword</code>。其中keyword就是我们要搜索的内容。所以我们只需要在搜索时让url加上wd或q字段即可。</p>
<p>模板：<img src="/images/python%E7%88%AC%E5%8F%966.PNG" alt="" /></p>
<p>获取图片要用二进制读取的方式，模板为<img src="/images/python%E7%88%AC%E5%8F%967.PNG" alt="" /></p>
<p>ip138是一个用来查询ip内容的网站。它的接口是<code>&quot;http://m.ip138.com/ip.asp?ip=...&quot;</code>于是我们可以通过这个接口去访问ip地址的内容。</p>
<p>模板：<br />
<img src="/images/python%E7%88%AC%E5%8F%968.PNG" alt="" /></p>
<h1 id="beautifulsoup4"><a class="markdownIt-Anchor" href="#beautifulsoup4"></a> beautifulsoup4</h1>
<p>beautifulsoup4可以用来解析html和xml。</p>
<p>导入： import bs4或from bs4 import Beautifulsoup</p>
<p>基本元素：</p>
<ul>
<li>Tag： 标签，如<code>&lt;&gt;&lt;/&gt;</code></li>
<li>Name: 标签的名字，如<code>&lt;p&gt;&lt;/p&gt;</code>中的p</li>
<li>Attribute： 标签属性，如<code>&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt;</code> 中的src和alt。它是一个字典类型，可以用<code>&lt;tag&gt;.attrs</code>访问</li>
<li>NavigableString: 两个标签之间的字符串。用<code>&lt;tag&gt;.string</code>访问</li>
<li>Comment： 标签中间字符串的注释</li>
</ul>
<p>一些函数：</p>
<ul>
<li>prettify(): 在标签之间添加换行符，让html文本易读。</li>
<li>find_all(name, attrs, recursive, string, ** kwargs); 查找所有标签，返回列表，它有一种简写形式,标签(…)，因为它十分常用。name是标签名字。attrs是对某一属性值的检索（如果某个标签有这个属性返回的还是这个标签）。recursive是是否对所有子孙进行搜索，默认是True。string是检索两个标签之间的字符串。</li>
<li>find(),find_parents(),find_parent(),find_next_siblings(),find_next_sibling,find_preivous_siblings,find_previous_sibling(): 这些方法的参数和使用方法相同。其中find()只返回第一个结果并且是字符串类型。</li>
</ul>
<p>解析器:  <img src="/images/python%E7%88%AC%E5%8F%969.PNG" alt="" /></p>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">&quot;F:/html/test.html&quot;</span>, <span class="keyword">encoding</span>=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    soup = BeautifulSoup(f, <span class="string">&quot;html.parser&quot;</span>) <span class="comment"># soup代指这个文档，算作一种标签</span></span><br></pre></td></tr></table></figure>
<h2 id="标签树的遍历"><a class="markdownIt-Anchor" href="#标签树的遍历"></a> 标签树的遍历</h2>
<p>任何html文档都可以看成是一个标签树，树的根节点就是<html>，因此我们可以从根节点出发得到整个标签树。</p>
<p>可以通过soup.html获得html标签。然后标签有如下属性：</p>
<ul>
<li>contents。子节点列表。\n也在列表中</li>
<li>children。子节点迭代类型，用于循环遍历儿子节点</li>
<li>descendants。包括所有的子孙节点，用于循环遍历</li>
<li>parent。 父亲标签</li>
<li>parents。 所有前辈</li>
<li>next_sibling: 返回html文本顺序的下一个平行标签(也就是父亲节点相同）。navigable_string也在列表中</li>
<li>previous_sibling： 返回html文本顺序的上一个平行标签</li>
<li>next_siblings</li>
<li>previous_siblings</li>
</ul>
<h1 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h1>
<p><img src="/images/python%E7%88%AC%E5%8F%9610.PNG" alt="" /><br />
<img src="/images/python%E7%88%AC%E5%8F%9611.PNG" alt="" /></p>
<p>例如： 0-99表示 [1-9]?/d</p>
<p>python使用rowstring类型来表达正则表达式，即r’…’。这种String不会出现转义现象</p>
<p>函数：</p>
<ul>
<li>re.compile(pattern, flags=0): 把正则表达式编译成对象，便于多次使用。形成对象之后就可以使用下面的六个方法，都是相对的少了pattern参数</li>
</ul>
<p><img src="/images/python%E7%88%AC%E5%8F%9612.PNG" alt="" /></p>
<ul>
<li>search(pattern, string, flags=0): pattern是正则表达式字符串后者原生字符串。因为原生字符串有些字符要转义，比较麻烦。String是要搜寻的文本，flags是控制标记</li>
<li>match匹配的字符串必须是从字符串开头开始。例如r3，如果我们用match搜寻数字，会返回空，因为数字不是从开头开始的。</li>
<li>split(pattern, string, maxsplit=0, flags=0): maxsplit是最大分割数，多余的部分将作为最后一个元素输出。split函数会去掉匹配上的部分，然后剩下的部分用一个列表输出，maxsplit就是最多去掉多少个匹配的</li>
<li>sub(pattern, repl, string, count=0, flags=0): repl是替换字符串，count是替换次数</li>
</ul>
<p><img src="/images/python%E7%88%AC%E5%8F%9613.PNG" alt="" />这是flags常用标记</p>
<p>match对象的属性：</p>
<ul>
<li>string： 待匹配的文本</li>
<li>re： 匹配时用的正则表达式</li>
<li>pos： 正则表达式搜索文本的开始位置</li>
<li>endpos： 结束位置</li>
</ul>
<p>match的方法：</p>
<ul>
<li>group(0): 获得匹配后的字符串</li>
<li>start(): 匹配字符串在原来字符串的开始位置</li>
<li>end(): 结尾位置</li>
<li>span(): 返回(start(), end())</li>
</ul>
<p>如果没有匹配上，会返回一个空指针</p>
<p>python默认是贪婪匹配，即返回多个匹配结果，例如search返回的就是最长的那个</p>
<p>如果我们想匹配最短字符串，就需要在匹配多个字符的后面加上一个问号。例如：</p>
<p><code>*?</code>、<code>+?</code>、<code>??</code>、<code>&#123;m, n&#125;?</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>[bx]和loop</title>
    <url>/post/3320.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="bx"><a class="markdownIt-Anchor" href="#bx"></a> [bx]</h3>
<p>mov ax,[bx]</p>
<p>这个的意思是把ds：bx处的内容放入ax中</p>
<p>mov [bx],ax</p>
<p>这个的意思是把ax中的内容放入 地址ds：bx处</p>
<h3 id="bxidata"><a class="markdownIt-Anchor" href="#bxidata"></a> [bx+idata]</h3>
<p>实际上还有更加灵活的方式指明内存地址，就是bx后加一个数据，这个数据可以是常数，也可以是变量</p>
<p>例 mov ax,ds:[bx+200]，也可以直接写为ds：200[bx]</p>
<p>这种处理方式可以方便的处理数组</p>
<h3 id="loop"><a class="markdownIt-Anchor" href="#loop"></a> loop</h3>
<p>格式：loop+标识符</p>
<p>执行过程：执行到loop时，先让cx-=1,再判断cx中的值，不为0则转至标号处继续执行，为0则进行下一步操作，寄存器cx用来储存循环次数</p>
<p>例</p>
<pre><code>mov cx,3
mov ax,2
s: add ax,ax
  loop s
</code></pre>
<p>这段程序的作用是计算2的三次方，首先让循环次数为3，ax=2，再从s处开始循环，当cx=0时退出，即进行3次</p>
<h3 id="用debug跟踪loop指令"><a class="markdownIt-Anchor" href="#用debug跟踪loop指令"></a> 用debug跟踪loop指令</h3>
<p>tip：汇编程序中，数据不能以字母开头，所以如A231h等等前面都要加一个零</p>
<p>如果想直接结束循环可以用p命令，如果用t命令的话，只会结束这一次循环</p>
]]></content>
  </entry>
  <entry>
    <title>c++函数指针备忘</title>
    <url>/post/9954ba8e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h1>
<p>返回值 (*指针名) (参数列表)</p>
<p>例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*func)(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line">    func = <span class="keyword">add</span>;</span><br><span class="line">    cout&lt;&lt; <span class="keyword">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line"></span><br><span class="line">这里将<span class="keyword">add</span>的函数首地址传给了这个函数指针，现在这个指针就指代这个函数，传入参数就可以使这个函数执行。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：int(*)(int a, int b)是一个函数指针类型，和int，double类似。而func相当与int a的a。</p>
</blockquote>
<p>根据上面这一条，我们可以用typedef测试一下</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">typedef <span class="built_in">int</span>(*<span class="function"><span class="keyword">Func</span>)<span class="params">(int a, int b)</span>;</span></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">Func</span> <span class="title">fn</span> = <span class="title">add</span>;</span></span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">可以运行</span><br></pre></td></tr></table></figure>
<p>我们也可以直接赋值并运行：<code>(void(*)(void))eip()</code>。这条语句前面是一个void(*)(void)的函数指针，它的值是eip.后面的括号表示运行它</p>
<h1 id="函数指针在类中的使用"><a class="markdownIt-Anchor" href="#函数指针在类中的使用"></a> 函数指针在类中的使用</h1>
<p>我们是不可以直接用函数指针指向类中的函数的，因为成员函数在创建时会隐式添加一个this参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(Adder::* Fm)</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function">Adder <span class="title">adder</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">Fm f = &amp;Adder::Add;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (adder.*f)(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">这样可以运行</span><br><span class="line">它的签名实际上是<span class="keyword">int</span>(*)(Adder *<span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br></pre></td></tr></table></figure>
<p>但是这样的话这个指针就只可以指向这一个类中的函数了，也就失去了函数指针的优势。</p>
<p>我们可以通过重载()运算符实现多个函数之间使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Adder(<span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Multiplier</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Multiplier(<span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b * c;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Do</span><span class="params">(T&amp; f, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = f(a, b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">    <span class="function">Adder <span class="title">adder</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Do(adder, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//输出4</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Multiplier <span class="title">multiplier</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    Do(multiplier, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//输出60</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title> UML简介</title>
    <url>/post/5f9e4eff.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>简单来说UML就是结构图，表示对象与类，类与类之间的联系。</p>
<p>UML主要包含以下框图：</p>
<ul>
<li>用例图 从用户角度描述系统功能，简单来说就是用户让系统干什么（也可以说是系统的输入）</li>
<li>类框图 表示类与类之间的联系</li>
<li>状态转换图 这是针对有不同状态的类。类如开关的开和关就是状态的转换</li>
<li>时序图和协作图 时序图是在时间维度上描述用户的输入和类的使用。协作图则用箭头表示而不是通过时间轴表示</li>
</ul>
<h3 id="用例图"><a class="markdownIt-Anchor" href="#用例图"></a> 用例图</h3>
<p>用例图的要素有</p>
<ul>
<li>用户 画成一个人型</li>
<li>用例 系统的某一个功能，大多数时候就是某一个函数，用椭圆表示</li>
<li>关系，用箭头表示</li>
</ul>
<p>也可以用用例文档补充描述。</p>
<ul>
<li>前置条件，什么时候才可以输入</li>
<li>主事件流，也就是这个用例干了什么事</li>
<li>其它事件流， 比如错误了该干什么事</li>
<li>后置条件 用例必须为真条件（个人理解是什么时候可以输出）</li>
</ul>
<h3 id="类框图"><a class="markdownIt-Anchor" href="#类框图"></a> 类框图</h3>
<p>类框图是表示类与类之间的关系（静态）。这个意思就是这个关系使不变的，做了一个就要去做另一个。</p>
<p>要素： 用一个方框表示类，方框的上面是类名，下面是函数名。用箭头表示方框之间关系。</p>
<h3 id="时序图与协作图"><a class="markdownIt-Anchor" href="#时序图与协作图"></a> 时序图与协作图</h3>
<p>时序图有两个要素，</p>
<p>垂直上表示时间，水平上表示发送消息的过程。（用函数名和箭头表示）</p>
<p><img src="/images/%E4%B8%8B%E8%BD%BD.png" alt="" /></p>
<p>协作图就用一个个箭头表示时间之间关系的。</p>
<p><img src="/images/20151113162700894" alt="" /></p>
<h3 id="状态转换图"><a class="markdownIt-Anchor" href="#状态转换图"></a> 状态转换图</h3>
<p>要素：</p>
<ul>
<li>初始点 实心圆</li>
<li>状态之间的转换 箭头</li>
<li>状态 用圆点表示</li>
<li>终止点 用一个圆里面再加一个实心圆表示</li>
</ul>
<p>例：<br />
<img src="/images/20170305152530328.png" alt="" /></p>
<h3 id="类之间的关系"><a class="markdownIt-Anchor" href="#类之间的关系"></a> 类之间的关系</h3>
<ul>
<li>关联 一个类和另一个类的实例有联系，例如老师和学生有联系。</li>
<li>依赖 A类访问类B提供的服务。例如A调用B的函数</li>
<li>聚集 A为整体类，B为局部类。A对象有B的对象组合而成（有个体组合成整体）。例如个人和人类。人类类中成员就是个人，人类类还有一些自己专属的方法。或者汽车和零部件。</li>
<li>泛化 A继承B</li>
<li>实现 A实现B的接口</li>
</ul>
<p>依赖和关联不同。关联是对应实例（也就是定义出来的东西），而关联是定义类是两个类总监有关系</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>c 文件操作</title>
    <url>/post/e0f8cb74.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h3>
<p>文件总的来说其实就只有两个操作，打开（关闭）和读写。本文也围绕这两个方面展开</p>
<p><strong>文件格式</strong></p>
<p>文件一般由三部分组成：路径，文件名，后缀。</p>
<p>例：<code>&quot;E:\\ch10.doc&quot;或者&quot;E:/ch10.doc&quot;</code></p>
<p>之所以要两个\是因为在c语言中\作为转义字符。</p>
<p><strong>流</strong></p>
<p>流按方向分为：输入流和输出流。从文件获取数据的流称为输入流，向文件输出数据称为输出流。</p>
<p>例如，从键盘输入数据然后把该数据输出到屏幕上的过程，相当于从一个文件输入流（与键盘相关）中输入（读取）数据，然后通过另外一个文件输出流（与显示器相关）把获取的数据输出（写入）到文件（显示器）上。</p>
<p><strong>换行符</strong></p>
<p>在Linux系统中，换行符是0x0a（LF）。因为c是在unix上发展起来的，所以访问Linux文件时，不需要转换，直接可以访问。</p>
<p>在windows系统中使用0x0d(CR ‘\r’） 和 0x0a(LF ‘\n’)合起来作为换行符。所以把windows下文件给c程序还要先把CR-LF转换成LF</p>
<p><strong>缓冲文件系统</strong></p>
<p>缓冲文件系统：系统自动为每个打开的文件在内存开辟一块缓冲区，缓冲区的大小一般由系统决定。当程序向文件中输出（写入）数据时，程序先把数据输出到缓冲区，待缓冲区满或数据输出完成后，再把数据从缓冲区输出到文件；当程序从文件输入(读取)数据时，先把数据输入到缓冲区，待缓冲区满或数据输人完成后，再把数据从缓冲区逐个输入到程序。</p>
<p>c语言就是用的缓冲文件系统。其实这和vim有点像。</p>
<p>ANSI C 为正在使用的每个文件分配一个文件信息区，该信息区中包含文件描述信息、 该文件所使用的缓冲区大小及缓冲区位置、该文件当前读写到的位置等基本信息。这些信息保存在一个结构体类型变量中，该结构体类型为 FILE 在 stdio.h 头文件中定义，不允许用户改变。</p>
<h3 id="文件打开和关闭"><a class="markdownIt-Anchor" href="#文件打开和关闭"></a> 文件打开和关闭</h3>
<p>文件指针 file* 用来引用一个文件。</p>
<p><strong>打开</strong></p>
<p>原型：<code>FILE * fopen(char *filename, char *mode);</code></p>
<p>filename指的是文件名，可以包括路径。</p>
<p>mode是打开方式。下面列举了一些打开方式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含 义</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>只读</td>
<td>文件必须存在，否则打开失败</td>
</tr>
<tr>
<td>w</td>
<td>只写</td>
<td>若文件存在，则清除原文件内容后写入；否则，新建文件后写入</td>
</tr>
<tr>
<td>a</td>
<td>追加只写</td>
<td>若文件存在，则位置指针移到文件末尾，在文件尾部追加写人，故该方式不 删除原文件数据；若文件不存在，则打开失败</td>
</tr>
<tr>
<td>r+</td>
<td>读写</td>
<td>文件必须存在。在只读 r 的基础上加 ‘+’ 表示增加可写的功能。下同</td>
</tr>
<tr>
<td>w+</td>
<td>读写</td>
<td>新建一个文件，先向该文件中写人数据，然后可从该文件中读取数据</td>
</tr>
<tr>
<td>a+</td>
<td>读写</td>
<td>在” a”模式的基础上，增加可读功能</td>
</tr>
<tr>
<td>rb</td>
<td>二进制读</td>
<td>功能同模式”r”，区别：b表示以二进制模式打开。下同</td>
</tr>
<tr>
<td>wb</td>
<td>二进制写</td>
<td>功能同模式“w”。二进制模式</td>
</tr>
<tr>
<td>ab</td>
<td>二进制追加</td>
<td>功能同模式”a”。二进制模式</td>
</tr>
<tr>
<td>rb+</td>
<td>二进制读写</td>
<td>功能同模式&quot;r+”。二进制模式</td>
</tr>
<tr>
<td>wb+</td>
<td>二进制读写</td>
<td>功能同模式”w+”。二进制模式</td>
</tr>
<tr>
<td>ab+</td>
<td>二进制读写</td>
<td>功能同模式”a+”。二进制模式</td>
</tr>
</tbody>
</table>
<p>按照mode 规定的方式，打开由pname指定的文件。若找不到由pname指定的相应文件，就按以下方式之一处理：</p>
<p>（1） 此时如mode 规定按写方式打开文件，就按由pname指定的名字建立一个新文件；<br />
（2） 此时如mode 规定按读方式打开文件，就会产生一个错误。</p>
<p>例： fopen(“example.txt”, “rw”);</p>
<p>如果返回失败，那么将返回NULL。</p>
<p><strong>关闭</strong></p>
<p>int fclose(FILE *fp);</p>
<p>如果关闭不正常，返回-1（EOF).</p>
<h3 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h3>
<h4 id="按字符输入输出"><a class="markdownIt-Anchor" href="#按字符输入输出"></a> 按字符输入输出</h4>
<p>原型：<code>int fgetc (FILE *fp);</code></p>
<p>作用：一次读入一个字符。如果读入出现问题，返回-1(EOF)</p>
<p>注意：由于 fgetc 是以 unsigned char 的形式从文件中输入（读取）一个字节，并在该字节前面补充若干 0 字节，使之扩展为该系统中的一个 int 型数并返回，而非直接返回 char 型。当输入失败时返回文本文件结束标志 EOF 即 -1，也是整数。故返回类型应为 int 型，而非 char 型。</p>
<p>也就是说最好不要用char类型去接收字符而使用unsigned_char，这样在碰到特殊字符就不会出现错误。</p>
<p>由于在 C 语言中把除磁盘文件外的输入输出设备也当成文件处理，故从键盘输入字符不仅可以使用宏 getchar() 实现，也可以使用 <strong>fgetc (stdin)</strong> 实现。其中，stdin 指向标准输入设备—键盘所对应的文件。stdin 不需要人工调用函数 fopen 打开和 fclose 关闭。</p>
<p><strong>按字符输出</strong></p>
<p>原型： <code>int fputc (int c, FILE *fp);</code></p>
<p>向fp文件中输出字符c。如果想输出到屏幕，可以<code>fputc(c, stdout)</code></p>
<p>对一个文件进行读写操作时，经常会把一个文件中读写位置重新调整到文件的开始处，可以使用函数 rewind 实现。</p>
<p>原型: <code>void rewind (FILE *fp);</code></p>
<p>作用：把<strong>读写</strong>位置跳到函数开头。</p>
<h4 id="按字符串输入输出"><a class="markdownIt-Anchor" href="#按字符串输入输出"></a> 按字符串输入输出</h4>
<p><strong>输入</strong></p>
<p>原型： <code>char * fgets (char *s, int size, FILE * fp);</code></p>
<p>作用： 从文件中读取长度为size（到了末尾会终止）的字符串，并且自动加入’\0’后输出，遇到空格不会终止。</p>
<p><strong>输出</strong></p>
<p>原型： <code>int fputs (const char *str, FILE *fp);</code></p>
<p>作用：把str输出到文件中。</p>
<h4 id="格式化输入输出"><a class="markdownIt-Anchor" href="#格式化输入输出"></a> 格式化输入输出</h4>
<p>这个与scanf和printf类似，只是目标变成了文件。</p>
<p><strong>输入</strong></p>
<p>原型： <code>int fscanf (文件指针，格式控制串，输入地址表列);</code></p>
<p>作用：从文件中输入到格式化字符串中，遇到空格会终止输入。</p>
<p>返回值：返回整型，输入成功时，返回输入的数据个数；输入失败，或已读取到文件结尾处，返回 EOF(-1)</p>
<p>例： fscanf (fp,&quot;%d,%d&quot;, &amp;a, &amp;b); //两个%d之间也必须用逗号隔开</p>
<p><strong>输出</strong></p>
<p>int fprintf (文件指针，格式控制串，输出表列)；</p>
<p>作用： 把格式字符串中的数据输出到文件中。</p>
<h4 id="二进制读写"><a class="markdownIt-Anchor" href="#二进制读写"></a> 二进制读写</h4>
<p><strong>输入</strong></p>
<p>原型：<code>unsigned fread (void *buf, unsigned size, unsigned count, FILE* fp);</code></p>
<p>作用：从 fp 指向的文件中读取 count 个数据块，每个数据块的大小为 size。把读取到的数据块存放到 buf 指针指向的内存空间中。</p>
<p>返回值：返回实际读取的数据块（非字节）个数，如果该值比 count 小，则说明已读到文件尾或有错误产生。这时一般采用函数 feof 及 ferror 来辅助判断。</p>
<p><strong>输出</strong></p>
<p>原型：<code>unsigned fwrite (const void *buf,unsigned size,unsigned count,FILE* fp);</code></p>
<p>作用： 把buf中count个大小为size的数据块写到文件中</p>
<p><strong>文件检查</strong></p>
<p>原型： <code>int feof (FILE * fp);</code></p>
<p>作用：检查是否到了文佳末尾，如果到了，返回非0</p>
<h4 id="随机读写"><a class="markdownIt-Anchor" href="#随机读写"></a> 随机读写</h4>
<p>随机读写就是不是在文件开头而是制定一个位置开始读写。首先要把文件指针移到对应位置，然后开始读写。</p>
<p>原型： <code>int fseek(FILE *fp, long offset, int origin);</code></p>
<p>作用：把fp读写指针设置到origin+offset的位置上，origin是起始位置。offset是偏移量。</p>
<p>起始位置有三种快捷的设置。分别是：</p>
<ul>
<li>SEEK_SET:文件开头，即第一个有效数据的起始位置。</li>
<li>SEEK_CUR：当前位置。</li>
<li>SEEK_END:文件结尾，即最后一个有效数据之后的位置。注意：此处并不能读取到最后一个有效数据，必须前移一个数据块所占的字节数，使该文件流的读写指针到达最后一个有效数据块的起始位置处。</li>
</ul>
<p>可以通过<code>long ftell (FILE *fp);</code>获得当前指针对于文件开始位置的偏移量</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>call指令</title>
    <url>/post/18912.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>操作</p>
<ol>
<li>将当前的ip或cs压入栈中</li>
<li>转移</li>
</ol>
<p>这里的转移与jmp相同，也有位移和内存两种方式</p>
<h3 id="根据位移"><a class="markdownIt-Anchor" href="#根据位移"></a> 根据位移</h3>
<p>call 标号（将ip压入栈中后，转移到标号处进行指令）<br />
过程：</p>
<ol>
<li>sp+=2，ss*16+sp=ip</li>
<li>ip=ip+16位位移</li>
</ol>
<p>16位位移=标号处地址-call指令后第一个字节的地址</p>
<p>相当于 push ip，jmp near ptr 标号</p>
<h3 id="根据目的地址"><a class="markdownIt-Anchor" href="#根据目的地址"></a> 根据目的地址</h3>
<p>call far ptr 实现段间转移</p>
<p>操作：</p>
<ol>
<li>sp-=2</li>
<li>ss<em>16+sp=cs<br />
3.sp-=2<br />
4.ss</em>16+sp=ip</li>
<li>cs=标号所在段地址，ip=；标号所在偏移地址</li>
</ol>
<p>段内转移一般是根据位移，段间转移一般是根据地址</p>
<p>如果地址在寄存器中， call reg，ip被修改</p>
<p>如果地址在内存中</p>
<p>1 call word ptr 内存地址</p>
<p>这种是段内转移，相当于 push ip，jmp word ptr</p>
<p>2 call dword ptr 内存地址</p>
<p>段间转移 例</p>
<p>call dword ptr ds：[0] ，这样ds:[0]和ds:[1]是ip ，ds:[2]和ds:[3]是cs</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>c++输出16进制，10进制和2进制</title>
    <url>/post/8372.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>hex是输出16进制，例如<br />
<code>cout&lt;&lt;hex&lt;&lt;18&lt;&lt;endl;</code></p>
<p>dec十进制</p>
<p>另外这两种用了之后后面输出一直是这种进制，如果用了hex之后想要用十进制要写dec</p>
<p>二进制bitset</p>
<p>bitset有头文件 <code>&lt;bitset&gt;</code></p>
<p>使用方法 bitset&lt;8&gt;(数字），其中8的含义是要输处几位二进制数，所以如果用int型是32，如果想把字符型转换就直接写8</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>c语言的动态内存分配</title>
    <url>/post/8039.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="malloc"><a class="markdownIt-Anchor" href="#malloc"></a> malloc</h3>
<p>头文件： malloc.h</p>
<p>原型 void* malloc( size)（不标准写法）</p>
<p>其中size表示的是你想申请的字节数，为了准确我们一般使用sizeof函数，而返回的是一个void指针，这就导致了我们一般都要强制类型转换到对应的类型。</p>
<p>例： int* p=(int*)malloc(sizeof(int))</p>
<p>int* p=(int*)malloc(10*sizeof(int)) //数组</p>
<p>前面的int* 就是强制类型转换</p>
<p>此外，malloc一般分配完内存后还要进行检查看是否分配成功</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p==NULL)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);<span class="regexp">//</span>退出程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且malloc是不会自动初始化的，所以在分配完内存后最好先用NULL初始化一下。</p>
<h3 id="realloc"><a class="markdownIt-Anchor" href="#realloc"></a> realloc</h3>
<p>字面意思，就是给一个已经分配内存的指针增加内存,原内存中的数据不变</p>
<p>头文件 #include &lt;stdlib.h&gt; 有些编译器需要#include &lt;alloc.h&gt;</p>
<p>原型： void* realloc(void *mem_address, unsigned int newsize);</p>
<p>mem_address是原指针，newsize是新的空间，可以大可以小</p>
<p>可能有下列几种情况</p>
<ol>
<li>如果原有空间后面还有足够的内存空间，那么直接在后面增加内存空间</li>
<li>如果原有空间不足，会重新分配空间到其他地方，同时原地址中的数据也会复制过去</li>
<li>如果没有可供分配的空间，返回NULL。此时，原指针仍然有效</li>
</ol>
<p>注意，如果分配成功，无论是否分到新空间，原指针都会被释放掉</p>
<p>如果 mem_address为0 那么和malloc相似，也是分配一块内存空间</p>
<p>如果 newsize为0，相当于free</p>
<p>也就是说，最好不要出现 p=realloc(p,size)这种写法，防止分配失败后指针直接丢失。好的办法是先用另一个参数接受realloc的内容，如果不为null，再让p=q</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* q;</span><br><span class="line">q=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(p,newsize);</span><br><span class="line"><span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="free"><a class="markdownIt-Anchor" href="#free"></a> free</h3>
<p>释放动态申请的内存空间</p>
<p>原型： void free(void* ptr)</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>debug</title>
    <url>/post/41129.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这里列举几个debug的基本命令</p>
<h4 id="r"><a class="markdownIt-Anchor" href="#r"></a> r</h4>
<p>用来查看此时寄存器内的数值和下一步将要执行的命令<br />
r 还可以接寄存器，用于修改寄存器内的内容<br />
例：r ax 这样会出现ax的内容和一个冒号，然后就可以输入数据修改了</p>
<h3 id="d"><a class="markdownIt-Anchor" href="#d"></a> d</h3>
<p>格式：d 段地址：偏移地址<br />
作用：列举出该地址下的机器码<br />
例 d 1000:0,这样子将会列举从1000:0 到1000:7f的所有内容</p>
<h3 id="e"><a class="markdownIt-Anchor" href="#e"></a> e</h3>
<p>格式：e 段地址：偏移地址<br />
作用：修改改地址下的机器码</p>
<h3 id="t"><a class="markdownIt-Anchor" href="#t"></a> t</h3>
<p>执行cs ip所指向内存地址的命令，直接输入t，不需要输入其他东西</p>
<h3 id="a"><a class="markdownIt-Anchor" href="#a"></a> a</h3>
<p>作用：用汇编语言输入指令到内存上<br />
写法： a 段地址：偏移地址<br />
例： a 1000:0<br />
输出1000：0  （input）mov ax，1<br />
然后1000:0 到1000:3 就会输入这条指令了，之后将cs ip地址设置一下，然后用t指令运行</p>
<h3 id="u"><a class="markdownIt-Anchor" href="#u"></a> u</h3>
<p>作用：查看某地址下的汇编程序<br />
写法： u 段地址：偏移地址<br />
例 u 1000:0<br />
然后就会输出1000:0 开始有的汇编指令了</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>dd</title>
    <url>/post/11051.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>dd是用来定义双字型</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> segment</span></span><br><span class="line">    dd <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> ends</span></span><br></pre></td></tr></table></figure>
<p>要注意dd要占两个字，db一个字节，dw一个字</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>debug和源程序对指令的不同处理</title>
    <url>/post/54300.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id=""><a class="markdownIt-Anchor" href="#"></a> []</h3>
<p>debug程序中[0]表示 ds：0处的数据进行处理</p>
<p>而源程序中表示把0这个数据给要处理的数据</p>
<p>例 mov ax,[0]在debug中表示把ds：0处元素给ax，而在源程序中表示把0给ax</p>
<p>在程序中，可以直接使用段寄存器加偏移地址来确定访问的元素，例如：ds：[bx],cs:[bx],ss:[bx]等</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>dup</title>
    <url>/post/43878.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>dup用来处理重复数据</p>
<p>例：db 3 dup (0) 这个意思是定义了三个0的字节型数据</p>
<p>db 3 dup （0,1,2) 定义了九个数据</p>
<p>db 3 dup (‘abc’,‘ABC’)定义18个数据</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>delete的一个注意事项</title>
    <url>/post/58313.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>实际上delete后的指针并不会变成空指针，仍指向堆里的地址。但是这个时候这块空间已经可以被其他的new申请了，如果你没有把原指针更改的话，有可能对原指针进行的修改会影响到新指针。因此每次delete完之后最好把这个指针变成空指针</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>df标志和传送指令</title>
    <url>/post/28579.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>flag第十位是df，方向标志位，在串处理指令中，控制每次操作后si，di的增减</p>
<p>df=0，每次操作后都是si，di增</p>
<p>df=1，减</p>
<h4 id="串传送指令"><a class="markdownIt-Anchor" href="#串传送指令"></a> 串传送指令</h4>
<h5 id="movsb"><a class="markdownIt-Anchor" href="#movsb"></a> movsb</h5>
<p>格式： movsb</p>
<p>功能：</p>
<ol>
<li>es<em>16+di=ds</em>16+si</li>
<li>如果df=0，则 si=si+1，di=di+1，等于一相反</li>
</ol>
<p>汇编语言描述</p>
<ol>
<li>mov se:[di],byte ptr ds:[si] （汇编不支持这样的指令）</li>
<li>如果df=0 inc si inc di else dec si dec di</li>
</ol>
<p>movsb的功能是将ds：si中的数据传到 es：di中</p>
<h5 id="movsw"><a class="markdownIt-Anchor" href="#movsw"></a> movsw</h5>
<p>格式 movsw</p>
<p>这个是按字来传送，si和di+2或-2</p>
<h5 id="rep"><a class="markdownIt-Anchor" href="#rep"></a> rep</h5>
<p>rep movsb</p>
<p>相当于</p>
<pre><code>  s: movsb
    loop s
</code></pre>
<p>rep的作用是根据cx的值，重复执行后面的串传送指令</p>
<h4 id="df-设置指令"><a class="markdownIt-Anchor" href="#df-设置指令"></a> df 设置指令</h4>
<p>cld 指令： 将df设置为0<br />
std指令： 将df设置为1</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>dw</title>
    <url>/post/58986.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>dw即define word，定义字型数据。例如，dw 0123h,0456h,0789h.这样就定义了几个字型数据，那这些数据都在哪里呢，他们的段地址都是从cs开始的，而偏移地址从0开始，也就是说，0123h的偏移地址是0,0456h的偏移地址是2,0789h的偏移地址是6。</p>
<p>但是这样会带来一个问题，因为前十六个字节是dw所定义的字型数据，所以这样可能使程序的入口出现问题，所以可以</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span> <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>这里就是加上了一个标号start，这个标号的意思就是确定程序的入口，而最后在end这里还要来一个start，因为end的作用除了确定程序在哪里终止之外，还有一个作用是告诉编译器程序在哪里开始（因为这时一个伪指令）</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>gdb</title>
    <url>/post/63002.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="进入gdb"><a class="markdownIt-Anchor" href="#进入gdb"></a> 进入gdb</h3>
<p>首先gdb一般都是用来调试c或c++的，gdb是要运行可执行文件的，所以先要进行编译。具体命令如下：</p>
<p><code>gcc -g 源文件.c -o 输出的目标文件</code></p>
<p>-g是用来插入编译所需的信息, -o是用来生成可执行文件</p>
<p>生成的时候会产生一大堆信息，如果不想看的话可以使用 -q 选项，如果想永久设定可以在bashrc中设置别名 alias gdb = ‘gdb -q’</p>
<h3 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
<th>简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>start</td>
<td>进入main函数</td>
<td>无</td>
</tr>
<tr>
<td>run</td>
<td>重新开始运行 run-text 加载文本文件 run-bin加载二进制文件</td>
<td>r</td>
</tr>
<tr>
<td>next</td>
<td>执行一行程序，不进入函数，直接把函数执行完</td>
<td>n</td>
</tr>
<tr>
<td>step</td>
<td>执行一行程序，进入函数</td>
<td>s</td>
</tr>
<tr>
<td>list</td>
<td>查看程序，list+函数名查看函数</td>
<td>l</td>
</tr>
<tr>
<td>continue</td>
<td>继续执行到断点处</td>
<td>c</td>
</tr>
<tr>
<td>quit</td>
<td>终止程序</td>
<td>q</td>
</tr>
<tr>
<td>set 参数</td>
<td>设置断点</td>
<td>无</td>
</tr>
<tr>
<td>nexti</td>
<td>运行一条机器指令</td>
<td>ni</td>
</tr>
<tr>
<td>jump + 标号</td>
<td>跳转到某一位置执行</td>
<td>j</td>
</tr>
<tr>
<td>run &lt; input.txt</td>
<td>重定向</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>注意jump命令跳转后仍是一直执行，所以要在某一位置手动设置断点</p>
<h3 id="程序"><a class="markdownIt-Anchor" href="#程序"></a> 程序</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
<th>简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>return</td>
<td>退出函数且不执行后面代码，也可以return+参数指定返回值</td>
<td>无</td>
</tr>
<tr>
<td>finish</td>
<td>退出函数且执行完剩下的代码</td>
<td>无</td>
</tr>
<tr>
<td>call/print</td>
<td>直接调用函数执行</td>
<td>无</td>
</tr>
<tr>
<td>info files</td>
<td>显示所有程序及位置</td>
<td>无</td>
</tr>
<tr>
<td>info functions（regex）</td>
<td>显示函数（可加正则表达式）</td>
<td>无</td>
</tr>
<tr>
<td>set step-mode on</td>
<td>进入不带调试信息的函数（如printf）</td>
<td>无</td>
</tr>
<tr>
<td>set args val1 val2…</td>
<td>设置函数参数</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="设置断点"><a class="markdownIt-Anchor" href="#设置断点"></a> 设置断点</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
<th>简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>设置断点</td>
<td>b</td>
</tr>
<tr>
<td>tbreak</td>
<td>设置临时断点（只能使用一次）</td>
<td>tb</td>
</tr>
<tr>
<td>info breakpoints</td>
<td>查看当前所有断点</td>
<td>i b</td>
</tr>
<tr>
<td>enable/disable breakpoints</td>
<td>启用/禁用断点</td>
<td>无</td>
</tr>
<tr>
<td>clear+编号</td>
<td>删除断点</td>
<td>无</td>
</tr>
<tr>
<td>** break参数 **</td>
<td></td>
<td><strong>例</strong></td>
</tr>
<tr>
<td>*+地址</td>
<td>在某一地址设置断点</td>
<td>b *0x400522</td>
</tr>
<tr>
<td>函数名</td>
<td>在某一函数进入前停止</td>
<td>b main</td>
</tr>
<tr>
<td>行号</td>
<td>在某一行号处设置断点</td>
<td>b 7</td>
</tr>
<tr>
<td>+offset/-offset</td>
<td>在当前行前后offset行设置</td>
<td>无</td>
</tr>
<tr>
<td>break … if &lt; condition&gt;</td>
<td>只有在条件满足时，断点才会被触发</td>
<td>b 10 if i==101</td>
</tr>
<tr>
<td>ignore bnum count</td>
<td>忽略bnum次编号为count的断点</td>
<td>ignore 1 5</td>
</tr>
<tr>
<td><strong>观察点</strong></td>
<td>观察变量值的变化</td>
<td></td>
</tr>
<tr>
<td>watch</td>
<td>当一个值发生变化时，程序会停下来，相当于是写观察点</td>
<td>无</td>
</tr>
<tr>
<td>reatch</td>
<td>当一个值发生读行为时，程序停止</td>
<td>无</td>
</tr>
<tr>
<td>awatch</td>
<td>每次读取或改变a的值都会让程序停下来</td>
<td>aw</td>
</tr>
<tr>
<td>info watch</td>
<td>显示观察点</td>
<td>i watch</td>
</tr>
<tr>
<td><strong>catchpoint</strong></td>
<td>当程序异常终止或加载链接库时停止运行，这里不展开</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）设置<span class="attr">catchpoints:</span></span><br><span class="line">a. <span class="keyword">catch</span> <span class="attr">event:</span> 当事件event发生的时候，程序停止运行，这里event的取值有：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）<span class="attr">throw:</span> C++抛出异常</span><br><span class="line"><span class="number">2</span>）<span class="attr">catch:</span> C++捕捉到异常</span><br><span class="line"><span class="number">3</span>）<span class="attr">exec:</span> exec被调用</span><br><span class="line"><span class="number">4</span>）<span class="attr">fork:</span> fork被调用</span><br><span class="line"><span class="number">5</span>）<span class="attr">vfork:</span> vfork被调用</span><br><span class="line"><span class="number">6</span>）<span class="attr">load:</span> 加载动态库</span><br><span class="line"><span class="number">7</span>）load <span class="attr">libname:</span> 加载名为libname的动态库</span><br><span class="line"><span class="number">8</span>）<span class="attr">unload:</span> 卸载动态库</span><br><span class="line"><span class="number">9</span>）unload <span class="attr">libname:</span> 卸载名为libname的动态库</span><br><span class="line"><span class="number">10</span>）syscall [args]: 调用系统调用，args可以指定系统调用号，或者系统名称</span><br><span class="line">b. tcatch <span class="attr">event:</span> 设置只停一次的catchpoint，第一次生效后，该catchpoint被自动删除</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/kevinx_xu/article/details/36261571">这一段从网上扒的</a></p>
<h3 id="反汇编"><a class="markdownIt-Anchor" href="#反汇编"></a> 反汇编</h3>
<p>disassemble 如果不带参数，会自动显示后面若干条汇编指令。简写disas</p>
<p>如果带一个参数，可以带函数名也可以带某一个地址，都是显示那个地址处的函数的汇编代码。</p>
<p>如果带两个参数，也就是起始地址和终止地址，那么就会显示两个之间的代码</p>
<h3 id="回退"><a class="markdownIt-Anchor" href="#回退"></a> 回退</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
<th>简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>reverse-continue</td>
<td>反向运行程序知道遇到一个能使程序中断的事件（比如断点，观察点，异常）</td>
<td>无</td>
</tr>
<tr>
<td>reverse-step</td>
<td>返回到上一次执行的源代码行</td>
<td>无</td>
</tr>
<tr>
<td>reverse-stepi</td>
<td>返回上一条机器指令</td>
<td>无</td>
</tr>
<tr>
<td>reverse-next</td>
<td>返回上一次执行的源代码行，但不执行函数</td>
<td>无</td>
</tr>
<tr>
<td>reverse-nexti</td>
<td>反向运行到上一条机器指令，除非这条指令用来返回一个函数调用、整个函数将会被反向执行。</td>
<td>无</td>
</tr>
<tr>
<td>reverse-finish</td>
<td>反向运行程序回到调用当前函数的地方</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>注意，想使用回退功能先要用record命令对指令进行录制</p>
<h3 id="调试带参数的程序"><a class="markdownIt-Anchor" href="#调试带参数的程序"></a> 调试带参数的程序</h3>
<p>方法1： gdb启动时候加参数</p>
<p>gdb --args ./main aaaa bb</p>
<p>方法2：</p>
<p>gdb main    //先启动起来</p>
<p>(gdb)run aaaa bb</p>
<p>方法3</p>
<p>gdb main    //先启动起来</p>
<p>(gdb)set args aaaa bb</p>
<p>(gdb)run  //或者start</p>
<p>(gdb)show args</p>
<p><a href="https://blog.csdn.net/mw_nice/java/article/details/100991341">这部分照搬的</a></p>
<h3 id="打印"><a class="markdownIt-Anchor" href="#打印"></a> 打印</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
<th>简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>** 函数栈帧打印**</td>
<td></td>
<td></td>
</tr>
<tr>
<td>i frame</td>
<td>输出了当前函数堆栈帧的地址，指令寄存器的值，局部变量地址及值等信息</td>
<td>无</td>
</tr>
<tr>
<td>frame n</td>
<td>打印第n层的函数栈帧</td>
<td>无</td>
</tr>
<tr>
<td>up/down n</td>
<td>向上/向下切换栈帧</td>
<td>无</td>
</tr>
<tr>
<td>print + 数组名</td>
<td>打印数组内容</td>
<td>p</td>
</tr>
<tr>
<td>set print array-indexes on</td>
<td>打印数组时打印下标</td>
<td>无</td>
</tr>
<tr>
<td>info locals</td>
<td>打印局部变量值</td>
<td>i locals</td>
</tr>
<tr>
<td>backtrace full n</td>
<td>由内向外显示n个栈帧的值</td>
<td>bt</td>
</tr>
<tr>
<td>set print pretty on</td>
<td>打印结构体</td>
<td>无</td>
</tr>
<tr>
<td>p *array@len</td>
<td>array数组名 len 数据长度</td>
<td>无</td>
</tr>
<tr>
<td>p $寄存器名</td>
<td>查看某个寄存器的值</td>
<td>无</td>
</tr>
<tr>
<td>info register</td>
<td>查看所有寄存器</td>
<td>i reg</td>
</tr>
</tbody>
</table>
<h4 id="x-显示内存中内容命令"><a class="markdownIt-Anchor" href="#x-显示内存中内容命令"></a> x 显示内存中内容命令</h4>
<p>格式: x /nfu <addr></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">n</span>表示要显示的内存单元的个数</span><br><span class="line"></span><br><span class="line">f表示显示方式, 可取如下值</span><br><span class="line">x 按十六进制格式显示变量。</span><br><span class="line">d 按十进制格式显示变量。</span><br><span class="line">u 按十进制格式显示无符号整型。</span><br><span class="line">o 按八进制格式显示变量。</span><br><span class="line"><span class="built_in">t</span> 按二进制格式显示变量。</span><br><span class="line">a 按十六进制格式显示变量。</span><br><span class="line">i 指令地址格式</span><br><span class="line">c 按字符格式显示变量。</span><br><span class="line">f 按浮点数格式显示变量。</span><br><span class="line"></span><br><span class="line">u表示一个地址单元的长度</span><br><span class="line">b表示单字节，</span><br><span class="line">h表示双字节，</span><br><span class="line">w表示四字节，</span><br><span class="line">g表示八字节</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/16107.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java switch foreach</title>
    <url>/post/4c720881.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="switch"><a class="markdownIt-Anchor" href="#switch"></a> switch</h3>
<p>switch的条件（switch括号中的内容）可以有一下几种。</p>
<ul>
<li>可以自动转换成int的类型（byte,short,int,char)</li>
<li>字符串类型</li>
</ul>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> color = <span class="string">&quot;red&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">switch</span>(color)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">   System.out.println(<span class="string">&quot;红色&quot;</span>)<span class="comment">;</span></span><br><span class="line">   <span class="built_in">break</span><span class="comment">;</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;blue:</span></span><br><span class="line"><span class="string">   System.out.println(&quot;</span>蓝色<span class="string">&quot;);</span></span><br><span class="line"><span class="string">   break;</span></span><br><span class="line"><span class="string"> default:</span></span><br><span class="line"><span class="string">   System.out.println(&quot;</span>其他颜色<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>枚举类型</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Colour</span>(<span class="title">red</span>,<span class="title">blue</span>);</span></span><br><span class="line">Colour c = Colour.red;</span><br><span class="line">Switch(c)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="foreach语句"><a class="markdownIt-Anchor" href="#foreach语句"></a> foreach语句</h3>
<p>foreach是for的特殊简化版本。用来遍历数组或集合</p>
<p>语法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(变量类型 变量名 : 待输出的集合或数组)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这也只能说是稍稍简化，直接写for就可以了。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>int指令</title>
    <url>/post/57453.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>格式： int n，n为中断类型码</p>
<p>在程序中可以采用int指令调用任何一个中断处理程序</p>
<p>例如： int 0 ，就会调用除法溢出的处理程序</p>
<p>所以说，int指令最终的功能与call指令类似，都是调用一段程序</p>
<p>例 用中断程序实现循环</p>
<p>要想实现循环，需要知道两个量，第一个是循环次数，第二个是跳转位移。循环次数用cx来保存，跳转位移用bx来保存</p>
<p>而为了实现loop指令，中断例程需要实现两个功能</p>
<ol>
<li>dec cx</li>
<li>cx=0，则顺序执行，否则，跳转</li>
</ol>
<p>代码</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ...安装</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bx</span>,offset s-offset se</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span></span><br><span class="line"><span class="symbol"> s:</span> <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="string">&#x27;!&#x27;</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">7ch</span>；这时<span class="built_in">ip</span>指向下一条指令即se标号</span><br><span class="line"><span class="symbol">se:</span> <span class="keyword">nop</span></span><br><span class="line"><span class="symbol">lp:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">dec</span> <span class="built_in">cx</span> <span class="comment">;cx--</span></span><br><span class="line">   <span class="keyword">jcxz</span> lpret</span><br><span class="line">   <span class="keyword">add</span> [<span class="built_in">bp</span>+<span class="number">2</span>],<span class="built_in">bx</span>//因为入栈顺序为标志寄存器，<span class="built_in">cs</span>，<span class="built_in">ip</span>，而<span class="keyword">add</span>是与后两个字节<span class="keyword">add</span></span><br><span class="line"><span class="symbol">ipret:</span> <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">     <span class="keyword">iret</span> //没到<span class="built_in">cx</span>=<span class="number">0</span>时也会终止，但这时<span class="built_in">ip</span>就不会回到s标号处</span><br></pre></td></tr></table></figure>
<h3 id="blos-和-dos中断例程安装过程"><a class="markdownIt-Anchor" href="#blos-和-dos中断例程安装过程"></a> blos 和 dos中断例程安装过程</h3>
<ol>
<li>开机后，cs：ip初始化为0ffff：0 ，这里有一条跳转指令，自动跳转到blos中的硬件系统检测和安装程序</li>
<li>初始化程序将建立blos所支持的中断向量，即把blos提供的中断例程载入中断向量表中</li>
<li>硬件检测完之后，调用int 19h进行操作系统的引导，从此把计算机给操作系统控制</li>
</ol>
<h3 id="blos中断例程的应用"><a class="markdownIt-Anchor" href="#blos中断例程的应用"></a> blos中断例程的应用</h3>
<p>int 10h 中断例程是blos提供的，包含多个与屏幕输出有关的子程序</p>
 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span></span><br></pre></td></tr></table></figure>
<p>ah=2表示调用10h中的2号子程序，功能为设置光标的位置，</p>
<p>bh=0，dh=5，dl=12 设置光标到第0页，第5行，第12列</p>
<p>mov ah ，9 表示调用第9号子程序，功能为在光标位置显示字符，可以提供显示字符的各种属性</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">9</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">11001010b</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span>//字符重复次数</span><br><span class="line">    <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="dos中断例程的应用"><a class="markdownIt-Anchor" href="#dos中断例程的应用"></a> dos中断例程的应用</h3>
<p>int 21h就是dos的中断例程，</p>
<p>我们一直使用的是int 21h中的4ch功能，即程序返回功能</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">4ch</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure>
<p>ah=4ch表示调用21h中的4ch号子程序</p>
<p>21h 中的光标位置显示字符功能</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ds:</span><span class="built_in">dx</span> 指向字符串</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>，<span class="number">9</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure>
<p>调用第九号子程序</p>
<p>dh中放行号，dl中放列号</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>java 内部类</title>
    <url>/post/348d4e04.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>内部类就是在类的内部又定义一个类。</p>
<h3 id="实例内部类"><a class="markdownIt-Anchor" href="#实例内部类"></a> 实例内部类</h3>
<p>实例内部类就是没有static修饰的内部类。他有以下几点需要注意</p>
<ul>
<li>在创建内部类的实例时，外部类必须已经创立。例如：</li>
</ul>
<p><code>Outer.InnerTool tool = new Outer().newInnerTool();</code>这个语句相当于</p>
<p><code>Outer outer = new Outer(); Outer.InnerTool Tool = outer.new InnerTool();</code></p>
<ul>
<li>
<p>内部类也是在外部类的内部，可以访问外部类的任何级别的成员方法和成员变量。这是因为想要创建内部类，首先要创建外部类，这个时候可以看成内部类有外部类的引用。</p>
</li>
<li>
<p>一个外部类可以对应多个内部类，一个内部类对应一个外部类。外部类不能直接访问内部类的成员，必须要通过实例去访问。例如</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> b1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> b2 = <span class="number">2</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">C</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v1 = b1;<span class="comment">//不能直接访问内部类成员，错误</span></span><br><span class="line">        B.C c1 = <span class="keyword">new</span> C();<span class="comment">//错误</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();<span class="comment">//正确，因为在类内部相当于已经有实例</span></span><br><span class="line">        <span class="keyword">int</span> v2 = b.b1;<span class="comment">//正确，可以通过内部类实例直接访问</span></span><br><span class="line">        B.c c2 = b.<span class="function">new <span class="title">C</span><span class="params">()</span></span>;<span class="comment">//正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在内部类中不能定义静态成员。</li>
<li>如果内部类和外部类A有同名的成员。那么this代表外部，A.this代表内部</li>
<li>如果有两个内部类且一个定义成private，那么另一个类不能访问。因为两个是同级的，可以把两个内部类看成继承于同一个父类的类。并且如果想在一个内部类中使用另一个内部类，则必须用完整类名</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        A.B b = <span class="keyword">new</span> <span class="type">A</span>().<span class="keyword">new</span> <span class="type">B</span>();<span class="comment">//使用A.B而不能像前面一样直接使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h3>
<p>静态内部类也是一种静态变量。但是这种类比较神奇，本来static是不能修饰类的，但是内部类的static和普通的静态变量有所不同。它可以创建实例，也就是说不局限于方法区，只是为了有特殊的权限而把static安上去而已。</p>
<p>静态变量可以直接创建，不必先创建外部类。例如<code>A.B b = new A.B();</code>。</p>
<p>正因为如此，所以静态内部类想访问外部类实例变量需要先创建实例。但是静态变量可以直接访问。</p>
<p>静态类的特点就是可以定义静态成员。</p>
<h3 id="局部内部类"><a class="markdownIt-Anchor" href="#局部内部类"></a> 局部内部类</h3>
<p>局部内部类是在一个方法中定义的类，它的可见范围是这个方法。局部内部类不能使用访问权限修饰符（public等），其实本来就没有必要，只能在这个方法内了还要访问权限干什么。</p>
<p>局部类也不能包含静态成员。依我看这就是java中的struct（不知道java中有不）。</p>
<h3 id="匿名类"><a class="markdownIt-Anchor" href="#匿名类"></a> 匿名类</h3>
<p>这种类的特殊之处就是没有名字，这种类实际上是内部类的简写形式（虽然也简单不到哪去），如果只需要创建一个内部类实例，就可以考虑匿名类。例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">void</span> method()</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;from&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        a.method;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名类本身没有构造方法，但是他会调用父类的构造方法。匿名类和内部类的访问权限相同，也可以访问外部所有变量。</p>
<p>传递参数时要注意，如果传递的是外部类的参数，必须要加final。因为内部类和外部类编译时生成的是两个文件，也就是说可能是值传递。但是内部类和外部类按道理应该是同一个类，内部类改变了参数，外部类也要跟着改变。为了避免这种矛盾，干脆直接定义成final不可改变了。</p>
<p>语法： <code>new 类名/接口名(构造方法参数)&#123;内容&#125;</code></p>
<p>匿名内部类实现接口（注意是实现），其实就是创造了一个类</p>
<h3 id="内部类的继承"><a class="markdownIt-Anchor" href="#内部类的继承"></a> 内部类的继承</h3>
<p>如果一个外部类继承了另一个外部类的内部类的实例，那么这个外部类会自动引用另一个外部类。例如</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    pubilc <span class="keyword">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> print()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;a=&quot;+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Sample extends <span class="keyword">Outer</span>.<span class="keyword">Inner</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">public</span> Sample(<span class="keyword">Outer</span> o)</span><br><span class="line">   &#123;</span><br><span class="line">       o.super();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">public</span> static <span class="type">void</span> main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">Outer</span> outer1 = <span class="built_in">new</span> <span class="keyword">Outer</span>();</span><br><span class="line">       <span class="keyword">Outer</span>.<span class="keyword">Inner</span> <span class="keyword">inner</span> = outer1.<span class="built_in">new</span> <span class="keyword">Inner</span>();</span><br><span class="line">       Sample s1 = <span class="built_in">new</span> Sample(outer1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sample必须要提供如上所述的构造函数。因为如果不提供，那么就不知道引用的是哪一个Outer。此外，Java虚拟机会自动使内部类的实例引用外部类的实例。例如上面inner实例会自动引用outer1实例。</p>
<h3 id="内部类用途"><a class="markdownIt-Anchor" href="#内部类用途"></a> 内部类用途</h3>
<p>第一个作用就是封装。例如顶层类只有public和默认级别，而内部类四种级别都可以有。</p>
<p>第二个作用是访问外部类的属性。这个访问不代表创建一个内部类的实例就可以直接访问外部类的属性了，那反而是对封装的破坏，这里指的是在定义的时候可以随意使用外部类的属性。</p>
<p>第三个作用是<strong>回调</strong>。这个的含义是可以实现类和接口中同名的方法。例如两个接口或一个类一个接口中定义了重名的方法，那么可以让内部类实现接口然后外部覆盖方法。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span>//<span class="title">Base</span>调节速度，<span class="title">Adjustable</span>调节温度</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> speed)</span><span class="comment">//覆盖</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustTemperature</span><span class="params">(<span class="keyword">int</span> temperature)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Adjustable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> temperature)</span><span class="comment">//实现</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            adjustTemperature(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Adjustable <span class="title">getCallBackReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里内部类是通过调用外部类的方法来实现的，虽然应该也可以直接在内部类中实现，频繁的跳转反而会带来性能的降低。但是某些时候想使用外部类的private类型时可以使用这种方法。</p>
<h3 id="文件名"><a class="markdownIt-Anchor" href="#文件名"></a> 文件名</h3>
<p>对于每个内部类，java都会生成.class文件。</p>
<ul>
<li>成员内部类 外部类名字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">内</mi><mi mathvariant="normal">部</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">：</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">内部类名字. 例： A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">类</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">字</span><span class="mord">.</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault">A</span></span></span></span>B.class</li>
<li>局部内部类 外部类名字$数字加内部类名字</li>
<li>匿名类 外部类名字$数字</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 图片操作</title>
    <url>/post/3319ed9a.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="读取图片"><a class="markdownIt-Anchor" href="#读取图片"></a> 读取图片</h1>
<p><strong>通过Toolkit</strong></p>
<p>可以通过Toolkit工具从本地，网络或内存获取图片</p>
<ul>
<li>Image Toolkit.getDefaultToolkit().getImage(String filename)</li>
<li>Image Toolkit.getDefaultToolkit().getImage(URL url)</li>
<li>Image Toolkit.getDefaultToolkit().createImage(byte[] imageData)</li>
</ul>
<p><strong>通过ImageIO</strong></p>
<p>方法：</p>
<ul>
<li>BufferedImage ImageIO.read(File input)</li>
<li>ImageIO.read(URL input)</li>
<li>ImageIO.read(InputStream input)</li>
</ul>
<p>一般用这种方法</p>
<p><strong>ImageIO常用方法</strong></p>
<ul>
<li>int getWidth()： 获取图片宽度</li>
<li>int getHeight()</li>
<li>int getWidth(ImageObserver observer)</li>
<li>int getHeight(ImageObserver observer)</li>
<li>setRGB(int x, int y, int rgb)： 设置图片在(x, y)处像素</li>
<li>getRGB(int x, int y)： 获取像素</li>
<li>setRGB(int startX, int startY, int w, int h, int[] rgbArray, int offset, int scansize)：startx,starty是左上角，w和h是宽和高，offset是rgbarray偏移量。scansize是每一行在数组内长度，一般取w。</li>
<li>int[] getRGB(int startX, int startY, int w, int h, int[] rgbArray, int offset, int scansize)</li>
<li>BufferedImage getSubimage (int x, int y, int w, int h)： 剪裁图片</li>
<li>Image getScaledInstance(int width, int height, int hints)：图片缩放，生成的是Image，如果想变成BufferedImage，可以创建一个同样大小的BufferedImage，然后绘制进去。hints是缩放算法，取值如下：
<ul>
<li>
<pre><code>SCALE_AREA_AVERAGING: 使用 Area Averaging 图像缩放算法;
</code></pre>
</li>
<li>
<pre><code>SCALE_DEFAULT: 使用默认的图像缩放算法;
</code></pre>
</li>
<li>
<pre><code>SCALE_FAST: 选择一种图像缩放算法，在这种缩放算法中，缩放速度比缩放平滑度具有更高的优先级;
</code></pre>
</li>
<li>
<pre><code>SCALE_REPLICATE: 使用 ReplicateScaleFilter 类中包含的图像缩放 算法;
</code></pre>
</li>
<li>
<pre><code>SCALE_SMOOTH: 选择图像平滑度比缩放速度具有更高优先级的图像缩放算法。
</code></pre>
</li>
</ul>
</li>
</ul>
<p>在图片上绘制文字等</p>
<ul>
<li>Graphics2D createGraphics()： 创建绘制图片的画布</li>
<li>Graphics getGraphics()： 获得画布</li>
</ul>
<h1 id="保存图片"><a class="markdownIt-Anchor" href="#保存图片"></a> 保存图片</h1>
<ul>
<li>ImageIO.write(RenderedImage im, String formatName, File output)：RenderedImage可以是BufferedImage，format是图片格式，例如&quot;jpg&quot;等。output是输出文件</li>
<li>ImageIO.write(RenderedImage im, String formatName, OutputStream output)：这里的output是输出位置，可以输出到内存或文件中。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span><br><span class="line">        <span class="comment">// 获取屏幕尺寸</span></span><br><span class="line">        Dimension screenSize = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.get<span class="constructor">ScreenSize()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建需要截取的矩形区域</span></span><br><span class="line">        Rectangle rect = <span class="keyword">new</span> <span class="constructor">Rectangle(0, 0, <span class="params">screenSize</span>.<span class="params">width</span>, <span class="params">screenSize</span>.<span class="params">height</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截屏操作</span></span><br><span class="line">        BufferedImage bufImage = <span class="keyword">new</span> <span class="constructor">Robot()</span>.create<span class="constructor">ScreenCapture(<span class="params">rect</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存截取的图片</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>write(bufImage, <span class="string">&quot;PNG&quot;</span>, <span class="keyword">new</span> <span class="constructor">File(<span class="string">&quot;capture.png&quot;</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 常用类</title>
    <url>/post/85b4e13b.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="object"><a class="markdownIt-Anchor" href="#object"></a> Object</h1>
<p>Object是所有java类共同的祖先。如果没有用extends，那么这个类将直接继承Object类。</p>
<p>Object类有一个默认构造方法，构造子类实例时，都会优先使用这个构造方法。</p>
<p><code>public Object()&#123;&#125;</code></p>
<p>方法：</p>
<ul>
<li>equals(Object obj): 比较两个对象是否相等，只有当两个变量引用一个实例时才会为真。</li>
<li>notify()</li>
<li>notifyAll()</li>
<li>wait()</li>
<li>hashCode(): 返回对象哈希码。</li>
<li>toString(): 返回当前对象字符串表示。如果println方法参数时Object，那么先会调用toString()</li>
<li>finalize(): 垃圾回收时先调用这个方法</li>
<li>getClass(): 返回运行时类。java引用变量有两种类型，编译时类型和运行时类型。运行时类型就是引用的实例。</li>
</ul>
<h1 id="string-和-stringbuffer"><a class="markdownIt-Anchor" href="#string-和-stringbuffer"></a> String 和 StringBuffer</h1>
<p>String是不可变类，里面字符串永远不会改变(也就是平常用双引号括起来的那些),StringBuffer是可变类</p>
<h2 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h2>
<p>构造方法：</p>
<ul>
<li>String()</li>
<li>String(String value):</li>
<li>String(char[] value): 会把字符数组转换成字符串</li>
<li>String(byte[] bytes): 会用本地默认编码把字节数组变成字符串</li>
<li>String(byte[] bytes, String charsetName): 根据charsetName指定的编码，构造字符串。</li>
</ul>
<p>方法：</p>
<ul>
<li>length()</li>
<li>char charAt(int index): 返回index上的字符</li>
<li>getChars(int srcBegin, int srcEnd, char[] dst, int dstbegin): 从当前字符串复制字符到dst中，srcBegin开始取字符，到srcEnd-1结束</li>
<li>equals(object str): 判断两个字符串是否相等</li>
<li>equalsIgnoreCase()： 忽略大小写</li>
<li>int compareTo(String str): 比较字符串大小</li>
<li>indexOf()和lastIndexOf(): 在字符串中检索特定字符或字符串，indexOf()从开始位置查找，另一个从后面开始查找</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str.index<span class="constructor">Of(&#x27;<span class="params">e</span>&#x27;)</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str.index<span class="constructor">Of(<span class="string">&quot;ea&quot;</span>, 2)</span>); <span class="comment">//从2开始</span></span><br></pre></td></tr></table></figure>
<ul>
<li>concat(String str): 把str加载末尾</li>
<li>substring(): 返回子串，参数中可以有开始和结束位置</li>
<li>String[] split(String regex): 根据参数把字符串分成几个子串，例如根据空格分隔</li>
<li>replaceAll(String regex, String replacement): 把原来字符串中regrex换成replacement。replaceFirst()只替换第一个</li>
<li>trim(): 把字符串首尾空格删除</li>
<li>String valueOf(): 把基本类型转换成String类型。</li>
<li>toUpperCast()/toLowerCast(): 把字符串变成大小写</li>
</ul>
<h3 id="hello-和-new-stringhello区别"><a class="markdownIt-Anchor" href="#hello-和-new-stringhello区别"></a> “hello” 和 new String(“hello”)区别</h3>
<p>第一种： String s1 = “hello”</p>
<p>第二种： String s2 = new String(“hello”)</p>
<p>第一种方式hello是立即数，Java虚拟机只会分配一次内存（在data节中）。第二种方式是建立一个对象，每次新建一个对象都会重新分配一次内存。所以用第一种方式赋相同值给两个变量用equal()比较时true，而而第二种不是。</p>
<h2 id="stringbuffer"><a class="markdownIt-Anchor" href="#stringbuffer"></a> StringBuffer</h2>
<p>构造方法：</p>
<ul>
<li>StringBuffer()</li>
<li>StringBuffer(int length)</li>
<li>StringBuffer(String str)：缓冲区初始字符串是str，并且提供16字节的额外缓冲区</li>
</ul>
<p>方法：</p>
<ul>
<li>length()</li>
<li>append(): 向缓冲区内添加字符串</li>
<li>toString(): 返回缓冲区内字符串</li>
<li>charAt(int index)</li>
<li>setCharAt(int index, char c): 在index处放c</li>
<li>getChars(int Begin, int end, char[] dst, int dstBegin):</li>
<li>subString()</li>
<li>insert(int offset, String str): 在offset位置插入字符串（字符串首位置在offset处）</li>
</ul>
<h2 id="string和stringbuffer区别"><a class="markdownIt-Anchor" href="#string和stringbuffer区别"></a> String和StringBuffer区别</h2>
<p>String是不可变类。即使看上去提供了replaceAll()的修改方法实际上它是创建了一个新的字符串。而StringBuffer是在自身基础上进行修改。</p>
<p>String覆盖了equals()方法。</p>
<p>String对象可以用+号进行拼接，而StringBuffer不可以</p>
<h1 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h1>
<p>就是用一些特殊字符来代替多个字符进行匹配</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任意字符</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配中括号中所有数据，例如[abc]可以匹配a或b或c</td>
</tr>
<tr>
<td>[^…]</td>
<td>匹配除括号数据外的任意数据</td>
</tr>
<tr>
<td>\s</td>
<td>空白符（空格，tab，换行，换页，回车）</td>
</tr>
<tr>
<td>\S</td>
<td>非空白符</td>
</tr>
<tr>
<td>\d</td>
<td>任意数字</td>
</tr>
<tr>
<td>\D</td>
<td>任意非数字</td>
</tr>
<tr>
<td>\w</td>
<td>大小写字母和数字</td>
</tr>
<tr>
<td>\W</td>
<td>除了大小写和数字外的字符</td>
</tr>
</tbody>
</table>
<p><a href="https://xinhecuican.github.io/post/26477.html">更多可以看这里</a></p>
<h1 id="格式化字符串"><a class="markdownIt-Anchor" href="#格式化字符串"></a> 格式化字符串</h1>
<p>String类的静态方法format()用于创建格式化字符串</p>
<ul>
<li>String format(String format, Object… args)</li>
<li>String format(Locale locale, String format, Object… args): locale指定语言</li>
</ul>
<p>例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(String.format(Locale.CHINESE, &quot;%tc&quot;, <span class="type">date</span>));</span><br></pre></td></tr></table></figure>
<h2 id="日期时间格式化"><a class="markdownIt-Anchor" href="#日期时间格式化"></a> 日期，时间格式化</h2>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%tb</td>
<td>月份简称，8月</td>
</tr>
<tr>
<td>%dB</td>
<td>全称</td>
</tr>
<tr>
<td>%ta</td>
<td>星期几</td>
</tr>
<tr>
<td>%tA</td>
<td>星期几全称</td>
</tr>
<tr>
<td>%ty</td>
<td>2位年份，如20</td>
</tr>
<tr>
<td>%tY</td>
<td>4位年份，如2020</td>
</tr>
<tr>
<td>%tm</td>
<td>月份，08</td>
</tr>
<tr>
<td>%te</td>
<td>一月中第几天</td>
</tr>
<tr>
<td>%tj</td>
<td>一年中第几天</td>
</tr>
<tr>
<td>%tc</td>
<td>具体时间和日期</td>
</tr>
<tr>
<td>%tF</td>
<td>年-月-日，四位年</td>
</tr>
<tr>
<td>%tD</td>
<td>年/月/日，两位年</td>
</tr>
<tr>
<td><strong>时间</strong></td>
<td></td>
</tr>
<tr>
<td>%tH</td>
<td>24时制（00-23）</td>
</tr>
<tr>
<td>%tI</td>
<td>十二小时（01-12）</td>
</tr>
<tr>
<td>%tk</td>
<td>24时（0-23）</td>
</tr>
<tr>
<td>%tl</td>
<td>12时（0-12）</td>
</tr>
<tr>
<td>%tM</td>
<td>分钟</td>
</tr>
<tr>
<td>%tS</td>
<td>秒</td>
</tr>
<tr>
<td>%tL</td>
<td>毫秒</td>
</tr>
<tr>
<td>%tN</td>
<td>微秒</td>
</tr>
<tr>
<td>%tp</td>
<td>上午下午标记</td>
</tr>
<tr>
<td>%tz</td>
<td>时区偏移量</td>
</tr>
<tr>
<td>%tZ</td>
<td>时区缩写</td>
</tr>
</tbody>
</table>
<h2 id="常规类型"><a class="markdownIt-Anchor" href="#常规类型"></a> 常规类型</h2>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%b</td>
<td>布尔类型</td>
</tr>
<tr>
<td>%B</td>
<td>大写</td>
</tr>
<tr>
<td>%h,%H</td>
<td>哈希码</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%S</td>
<td>大写字符串</td>
</tr>
<tr>
<td>%c</td>
<td>字符</td>
</tr>
<tr>
<td>%C</td>
<td>大写</td>
</tr>
<tr>
<td>%d</td>
<td>十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>八进制</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%e</td>
<td>科学记数法表示的十进制</td>
</tr>
<tr>
<td>%n</td>
<td>换行</td>
</tr>
</tbody>
</table>
<p>例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Stirng</span>.</span></span>format(<span class="string">&quot;hi%s&quot;</span>, <span class="string">&quot;小红&quot;</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">&quot;%c%n&quot;</span>, <span class="character">&#x27;A&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>使用大致和c语言类似。</p>
<table>
<thead>
<tr>
<th>转换符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>转换符号</td>
<td>它是在%后面字符前面的,例如&quot;%+d&quot;</td>
</tr>
<tr>
<td>+</td>
<td>为数字添加正负号</td>
</tr>
<tr>
<td>-</td>
<td>左对齐</td>
</tr>
<tr>
<td>0</td>
<td>数字前补零，例如 “%04d” 表示如果数字不满四位前面要补零</td>
</tr>
<tr>
<td>(</td>
<td>添加括号，例如(&quot;%(d&quot;, 99) ,输出 (99)</td>
</tr>
<tr>
<td>#</td>
<td>如果是十六或十进制前面添加0x或0,如果是浮点数添加小数点</td>
</tr>
</tbody>
</table>
<h2 id="包装类"><a class="markdownIt-Anchor" href="#包装类"></a> 包装类</h2>
<p>每个基本类型都有一个包装类。包装类就是对应基本类型然后首字母大写（int,char除外）。例如int Integer float Float.char是Character</p>
<p>构造方法：</p>
<p>都可以用字符串作为参数来构造。Boolean类型可以用&quot;true&quot;或&quot;false&quot;。</p>
<p>除了Character和Boolean外其他类都是继承于Number类。</p>
<p>Number类方法如下：</p>
<ul>
<li>
<p>byteValue(): 返回Number对象的byte类型</p>
</li>
<li>
<p>intValue():</p>
</li>
<li>
<p>longValue()</p>
</li>
<li>
<p>shortValue()</p>
</li>
<li>
<p>doubleValue()</p>
</li>
<li>
<p>floatValue()</p>
</li>
<li>
<p>包装类都覆盖了toString()方法</p>
</li>
<li>
<p>都有parsexxx(String str)静态方法，可以把字符串转化成相应数据。例如parseint(“123”)</p>
</li>
</ul>
<h3 id="包装类自动装箱和拆箱"><a class="markdownIt-Anchor" href="#包装类自动装箱和拆箱"></a> 包装类自动装箱和拆箱</h3>
<p>就是在基本类型和包装类之间进行转换。可以直接用基本类型赋值给包装类，也可以直接用包装类赋值给基本类型。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Integer a</span> = 3;</span><br><span class="line"><span class="attribute">int b</span> = new Integer(4);</span><br></pre></td></tr></table></figure>
<h2 id="math类"><a class="markdownIt-Anchor" href="#math类"></a> Math类</h2>
<p>Math类里面基本上都是静态方法，并且他的构造方法时private，不能有实例。而且是final类型，不能有子类。</p>
<p>方法：</p>
<ul>
<li>abs()</li>
<li>ceil(): 向上取整</li>
<li>floor(): 向下取整</li>
<li>max()</li>
<li>min()</li>
<li>random(): 返回0到1间double类型的随机数。包括0，不包括1</li>
<li>round(): 四舍五入整数</li>
<li>sin()</li>
<li>cos()</li>
<li>tan()</li>
<li>exp(): 根号x</li>
<li>sqrt():  x的平方</li>
<li>pow(): 幂运算</li>
</ul>
<h2 id="random类"><a class="markdownIt-Anchor" href="#random类"></a> Random类</h2>
<p>和Math类似</p>
<p>方法：</p>
<ul>
<li>nextInt(): 返回一个int型随机数，随机数大于等于0</li>
<li>nextInt(int n): n是随机数最大值</li>
<li>nextLong()</li>
<li>nextFloat()</li>
<li>nextDouble()</li>
<li>nextBoolean()</li>
</ul>
<h2 id="处理时间类"><a class="markdownIt-Anchor" href="#处理时间类"></a> 处理时间类</h2>
<p><strong>Date</strong></p>
<p>Date类以毫秒方法日期。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.prtinln(<span class="type">date</span>);</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Sun Aug21 <span class="number">17</span>:<span class="number">32</span>:<span class="number">05</span> CST <span class="number">2016</span></span><br></pre></td></tr></table></figure>
<p><strong>DateFormat</strong></p>
<p>它可以定制日期格式</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>();</span><br><span class="line">SimpleDateFormat f = <span class="literal">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MMMM-dd-EEEE&quot;</span>);</span><br><span class="line">这些都是表示显示几位的年月日的.E是星期</span><br></pre></td></tr></table></figure>
<h2 id="biginteger-bigdecimal"><a class="markdownIt-Anchor" href="#biginteger-bigdecimal"></a> BigInteger BigDecimal</h2>
<p>BigInteger可以接受任意位的整数运算。他有add(BigInteger b),subtract(BigInteger b) multiply(BigInteger b) divide(BigInteger b)等方法来进行四则运算</p>
<p>BigDecimal可以进行精确的浮点数运算。对于加减乘都是准确的，对于除法可以指定小数位和舍入模式。</p>
<p>divide(BigDeciaml b, int scale, RoundingMode more)more是舍入模式。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 对象的生命周期</title>
    <url>/post/53677394.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="创建对象的方式"><a class="markdownIt-Anchor" href="#创建对象的方式"></a> 创建对象的方式</h3>
<p>有四种显式创建的方式：</p>
<ul>
<li>new创建</li>
<li>运用反射，调用java.lang.Class或java.lang.reflect.Constructor类的newInstance()方法</li>
<li>调用对象的clone()方法</li>
<li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射创建</span></span><br><span class="line">Class objClass = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;Customer&quot;</span>)</span>;</span><br><span class="line">Customer cl = (Customer)objClass.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line"><span class="comment">//通过克隆创建</span></span><br><span class="line">Customer c3 = (Customer)c2.clone<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<p>通过new或反射的方法创建的时候，都会调用构造方法。但是通过克隆创建不会执行构造方法。在Object类中就定义了clone()方法</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object clone()<span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Cloneable))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportException();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式下如果对应类没有实现cloneable接口，那么clone（）方法会抛出异常。<strong>如果想用clone，那么必须要实现Cloneable接口</strong>。</p>
<p>clone会创建一个对象，对象的属性值相同，但是内存地址不同。</p>
<p><strong>隐式创建对象</strong></p>
<ul>
<li>输入main的参数都会转化成String对象</li>
<li>+号对String类型创建新对象</li>
<li>加载一个类时，会创建Class实例</li>
</ul>
<p><strong>创建对象步骤</strong></p>
<ol>
<li>给对象分配内存</li>
<li>将实例变量自动初始化成默认值</li>
<li>初始化对象。例如private int a = 1;在第二步赋值成0，在第三步中才会变成1.</li>
</ol>
<p>对于第三步，如果是通过clone的方法创建，那么将原来成员变量的值赋给新的成员变量。如果是用第四种方法，那么是通过输入流读入序列化数据。</p>
<h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3>
<p>构造方法时负责初始化的，可以提供参数，也可以不提供，一般设置一个默认构造函数有好处。</p>
<ul>
<li>方法名要与类名相同</li>
<li>不声明返回类型</li>
<li>不能被static,final,synchronized,abstract,native修饰</li>
</ul>
<p><strong>重载构造方法</strong></p>
<p>这是为了满足多样化的需求。需要注意一点在一个构造方法中可以用this调用另一个构造方法。但是如果在一个构造方法中使用了this语句，那么它必须在第一行。</p>
<h4 id="默认构造方法"><a class="markdownIt-Anchor" href="#默认构造方法"></a> 默认构造方法</h4>
<p>其实和c++一样，在没有构造方法的时候会提供一个默认构造方法，如果写了一个构造方法那么系统就不会提供构造方法。但是最好要有一个不带参数的构造方法。</p>
<h4 id="子类调用父类构造方法"><a class="markdownIt-Anchor" href="#子类调用父类构造方法"></a> 子类调用父类构造方法</h4>
<p>父类构造方法不能被子类继承。在构造子类时，先执行祖先的构造方法，然后一次向下。这样可以确保子类从父类继承的东西可以被使用。可以用super(…)调用父类构造方法。如果没有用super显示构造，那么子类会用父类的默认构造方法。如果子类没有构造方法，将会出现编译错误</p>
<h4 id="构造方法的访问级别"><a class="markdownIt-Anchor" href="#构造方法的访问级别"></a> 构造方法的访问级别</h4>
<p>这里主要将private的访问级别的意义。</p>
<p>当构造函数是private时，只有当前类可以访问它。这也代表不能有子类。所以只有一些特殊的场合才会使用它。</p>
<ol>
<li>只有静态方法，没有实例方法</li>
<li>禁止被继承。这个与final的区别就是private不允许其他类创建它的实例，而final可以。</li>
<li>这个类要把自己封装起来。</li>
</ol>
<h3 id="静态工厂办法"><a class="markdownIt-Anchor" href="#静态工厂办法"></a> 静态工厂办法</h3>
<p>创建实例最常见的方法是用new调用类的构造方法。在这种情况下，可以创建任意多的实例。如果类想要进一步封装创建实例的细节，并控制实例数目，可以用静态工厂的方法。</p>
<p>静态工厂方法指的是在类中提供一个公有的静态方法，返回类的一个实例。</p>
<p>静态工厂实际上是一种普通的方法，但是它有平常创建实例时所不具有的灵活性。</p>
<p><strong>特点一</strong>： 可以有不同于类的名字，这样在重构构造方法时可以更清晰的说明其中的不同，使可读性增大。</p>
<p>例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static Person get<span class="constructor">ManInstance(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">       return <span class="keyword">new</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>, SEX.<span class="params">man</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public static Person get<span class="constructor">WomanInstance(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">       return <span class="keyword">new</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>, SEX.<span class="params">woman</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>一般都喜欢把静态工厂取名为valueof或getInstance。</p>
<p><strong>特点二</strong>： 可以不创建新对象。重复利用原有对象</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> A <span class="keyword">init</span> = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">getinit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">init</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点三</strong>： 可以创建子类的实例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public static <span class="type">A</span> getson()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Sub</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为静态工厂每次不一定创建新的实例，所以在一些特殊的场合有应用。</p>
<h4 id="单例类"><a class="markdownIt-Anchor" href="#单例类"></a> 单例类</h4>
<p>单例类就是只有一个实例的类，这种类只有一个实例。一般是系统中具有唯一性的组件才会使用。这种类一般要消耗很多内存，为了防止随便开然后爆内存，所以设置成单例类。</p>
<p>一种办法是提供public static final的静态常量，然后该常量引用唯一实例。在把构造方法定义成private类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Globalconfig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> GlobalConfig INSTANCE = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GlobalConfig</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种办法就是把构造方法定义成private类型，然后提供构造工厂。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Globalconfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final GlobalConfig INSTANCE = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">GlobalConfig</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GlobalConfig getInstatnces()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举类"><a class="markdownIt-Anchor" href="#枚举类"></a> 枚举类</h4>
<p>枚举类是实例数目有限的类。比如，表示性别的Gender类，他只会有两个类。</p>
<p>设计时，同样把构造方法定义成private，然后创建若干个public static final的静态变量。还可以提供静态工厂。另外如果想使用这些实例，直接用类名即可。</p>
<h4 id="不可变类和实例缓存"><a class="markdownIt-Anchor" href="#不可变类和实例缓存"></a> 不可变类和实例缓存</h4>
<p>不可变类指的是创建之后就不可以更改属性值，和final类似。例如Long类，String类。</p>
<p>创建不可变类时，要考虑一下内容：</p>
<ul>
<li>把属性定义成final类型</li>
<li>不对外公开的（private）set方法</li>
<li>public的get方法</li>
<li>在构造方法中初始化所有属性</li>
<li>覆盖Object类的equals()和hashCode()方法。</li>
</ul>
<p>对于不可变类，因为数据成员不会改变，所以在创建实例时，如果二者数据成员相同，那么可以共有一份空间，这样就减小了内存消耗。这叫做实例缓存。</p>
<p>例如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(10)</span>;</span><br><span class="line">Integer b = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(10)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(a<span class="operator"> == </span>b);<span class="comment">//会打印true</span></span><br></pre></td></tr></table></figure>
<p>关于两个对象的等于，在<a href="https://xinhecuican.github.io/post/4b1879e3.html">前面一篇博客</a>中已有说明。</p>
<p>这就说明了两者共用了内存空间。那么我们应该如何实现实例缓存呢？</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> <span class="type">Name</span></span><br><span class="line">&#123;</span><br><span class="line">    private static final <span class="keyword">Set</span>&lt;SoftReference&lt;<span class="type">Name</span>&gt;&gt; names = <span class="built_in">new</span> HashSet&lt;SoftReference&lt;<span class="type">Name</span>&gt;&gt;();//实例缓存，存放<span class="type">Name</span>的软引用</span><br><span class="line">    <span class="built_in">public</span> sattic <span class="type">Name</span> valueOf(String firstname, Stirng lastname)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(SoftReference&lt;<span class="type">Name</span>&gt; <span class="keyword">ref</span>:names)//循环查看是否已经存在</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Name</span> <span class="type">name</span> = <span class="keyword">ref</span>.<span class="keyword">get</span>();//获得软引用的<span class="type">Name</span>对象</span><br><span class="line">            <span class="keyword">if</span>(<span class="type">name</span> != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; <span class="type">name</span>.firstname.equals(firstname)</span><br><span class="line">            &amp;&amp; <span class="type">name</span>.lastname.equals(lastname))</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果缓存中不存在<span class="type">Name</span>对象，就创建新对象，并加入到实例缓存</span><br><span class="line">            <span class="type">Name</span> <span class="type">name</span> = <span class="built_in">new</span> <span class="type">Name</span>(firstname, lastname);</span><br><span class="line">            names.<span class="keyword">add</span>(<span class="built_in">new</span> SoftReference&lt;<span class="type">Name</span>&gt;(<span class="type">name</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，实例缓存也需要消耗内存空间，如果对所有不可变类都使用，可能有的反而会减少内存。当有如下情况时，才会使用实例缓存。</p>
<ul>
<li>不可变类实例种类有限</li>
<li>需要频繁访问某些特定的实例。</li>
</ul>
<h3 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h3>
<p>在c++中，内存回收是程序员自己负责，因为人难免犯错嘛，可能会导致一系列奇奇怪怪的错误。所以在java中，内存回收是java虚拟机做的。</p>
<p>只有对象不被任何变量引用时，它的内存才会被回收。当垃圾回收器回收内存时，会先调用该对象的finalize()方法，该方法可能使对象复活，导致垃圾回收器取消回收内存。</p>
<p>对垃圾回收器来说，程序由三种状态：</p>
<ol>
<li>可触及状态：只要还有引用变量引用对象，那么这个对象就处于可触及状态。</li>
<li>可复活状态： 当程序中没有引用2变量引用时，就进入了可复活状态，复活的关键是finalize方法，这个方法有可能使他复活</li>
<li>不可触及状态： 也就是调用了finalize状态并且没有复活之后。这种状态下虚拟机才会真正回收内存。</li>
</ol>
<h4 id="finalize方法"><a class="markdownIt-Anchor" href="#finalize方法"></a> finalize方法</h4>
<p>finalize()方法就是要销毁时执行的方法，如果finalize方法如果出现异常系统也不会报错而是直接清除。下面讲一下如何把它变成可触及状态。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ghost</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Ghost&gt; ghosts = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>,Ghost&gt;();</span><br><span class="line">    <span class="built_in">String</span> name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Ghost getInstance(<span class="built_in">String</span> name)</span><br><span class="line">    &#123;</span><br><span class="line">        Ghost ghost = ghost(name);</span><br><span class="line">        <span class="keyword">if</span>(ghost == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ghost = <span class="keyword">new</span> Ghost(name);</span><br><span class="line">            ghosts.put(name, ghost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ghost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">void</span> finalize()</span><br><span class="line">    &#123;</span><br><span class="line">        ghosts.put(name, <span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;execute finalize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序在将要被销毁时会调用finalize，之后就把这个对象有放回了Map中，又把这个对象复活了。</p>
<p>但是实际最好不要用finalize，因为这会扰乱正常的回收机制，导致永远无法回收。</p>
<p><strong>清除过期引用</strong></p>
<p>正常情况下，虚拟机都会很好的执行垃圾回收，但是在对象数组等线性结构中，如果只让指针减一，是无法进行垃圾回收的，因为这个数组仍保留对它的引用，但是这个被清除的数据已经无意义了，下面举个例子</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">Object</span>[] elements = <span class="keyword">new</span> <span class="built_in">Object</span>[capacity];</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">Object</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements[--size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的确没什么问题，也可以得到正确的执行，但是实际上size位置的引用并没有被清除，所以当你不断的增加然后开始不断的删除时，这个栈一直在占用大量的空间。所以要想办法除法java的回收机制</p>
<p>方法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">Object</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span> <span class="built_in">object</span> = elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="强引用弱引用软引用虚引用"><a class="markdownIt-Anchor" href="#强引用弱引用软引用虚引用"></a> 强引用，弱引用，软引用，虚引用</h3>
<p>在早期的java中，并没有各种引用。这些引用代表的是清除的级别，如果空间不够了，那么先清除级别低的，这样对程序造成的影响就小。</p>
<p>在java.lang.ref包中，有Reference的抽象父类，下面有SoftReference,WeakReference,PhantomRefence，分别代表软引用，弱引用，虚引用。<br />
ReferenceQueue表示引用队列，它可以和上面三种引用联合使用，以便跟踪虚拟机回收所引起的对象的活动(具体的现在不清楚）。</p>
<h4 id="强引用"><a class="markdownIt-Anchor" href="#强引用"></a> 强引用</h4>
<p>强引用就是普通的引用。如果一个类是强引用，那么除非没有变量引用它，虚拟机绝对不会回收它，甚至空间不足的时候虚拟机抛出OutOfMemoryError也不会回收。</p>
<h4 id="软引用"><a class="markdownIt-Anchor" href="#软引用"></a> 软引用</h4>
<p>如果一个对象只有软引用，那么空间足够就会留着它，空间不足就会回收它。前面就有一个软引用的例子。</p>
<p>软引用可以和引用队列（ReferenceQueue）配合使用，如果软引用所引用的对象被回收，那么虚拟机就会把这个软引用加入到与之关联的引用队列中</p>
<h4 id="弱引用"><a class="markdownIt-Anchor" href="#弱引用"></a> 弱引用</h4>
<p>弱引用比软引用更没人权。一旦垃圾回收器发现了弱引用，不管有没有内存，都会回收它。只是因为垃圾回收是一个优先级比较低的线程，所以不一定会很快发现弱引用。</p>
<h4 id="虚引用"><a class="markdownIt-Anchor" href="#虚引用"></a> 虚引用</h4>
<p>弱引用都如此了，虚引用肯定更倒霉。同样也是一旦被发现分分钟清除的货。而且优先级比弱引用还要低。虚引用并不会决定对象生命周期。对象持有虚引用和没有引用一样，如果只有虚引用，还是会被清除。</p>
<p>弱引用<strong>必须</strong>要和引用队列一起使用。当回收一个对象时，如果发现它有虚引用，那么就会在回收对象之前，把这个虚引用对象加入引用队列中。</p>
<p>那么它的作用是什么？因为虚引用会被放到引用队列中，所以可以设一个虚引用，然后通过虚引用是否在引用队列中来判断这个对象时候要被回收。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> str = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">//创建强引用</span></span><br><span class="line">ReferenceQueue&lt;<span class="keyword">String</span>&gt; rq = <span class="keyword">new</span> <span class="type">ReferenceQueue</span>&lt;<span class="keyword">String</span>&gt;();<span class="comment">//创建引用队列</span></span><br><span class="line">WeakReference&lt;<span class="keyword">String</span>&gt; wf = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;<span class="keyword">String</span>&gt;(str,rq);<span class="comment">//创建弱引用</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 异常处理</title>
    <url>/post/e058ffd8.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="异常处理流程"><a class="markdownIt-Anchor" href="#异常处理流程"></a> 异常处理流程</h3>
<p>有两种办法抛出异常：</p>
<ul>
<li>通过try-catch抛出，例如</li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span> <span class="title">A</span><span class="params">(int money)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    try</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        if(--money&lt;=0)</span></span></span><br><span class="line"><span class="function"><span class="comment">        &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">            throw new SpecialException(&quot;Outof money&quot;);</span></span></span><br><span class="line"><span class="function"><span class="comment">        &#125;</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="title">catch</span><span class="params">(SpecialException e)</span></span></span><br><span class="line"><span class="function">    <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        处理异常</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在方法声明处声明抛出</li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span> <span class="title">A</span><span class="params">(int money)</span><span class="title">throws</span> <span class="title">SpecialException</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    if(--money&lt;=0)</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        throw new SpecialException(&quot;Out of money&quot;);</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>每次抛出异常之后，都要找到catch块，如果在当前方法中没有找到，那么它将会弹出栈帧，到了上一级继续寻找知道找到。找到之后就执行catch块内容然后退出。</p>
<p>如果到最底部也没有找到catch块，那么就调用异常对象的printStackTrace()方法，打印异常信息。</p>
<p>如果该线程不是主线程，那么就会退出这一个线程，如果是主线程（main），那么就会退出程序。</p>
<p>抛出异常和处理异常最好在同一方法，不然对性能影响较大。</p>
<h4 id="finally-在任何情况下都要执行的代码"><a class="markdownIt-Anchor" href="#finally-在任何情况下都要执行的代码"></a> finally 在任何情况下都要执行的代码</h4>
<p>因为异常处理会打断正常进程，所以可能会导致一些占用的资源不会被释放。在c++中就是动态内存分配的问题，在java中额例如关闭数据库链接，关闭输入流。</p>
<p>finally跟在catch后面，并且一定不能在前面。</p>
<h4 id="throws-抛出可能的异常"><a class="markdownIt-Anchor" href="#throws-抛出可能的异常"></a> throws 抛出可能的异常</h4>
<p>如果一个方法需要抛出异常，但没有能力解决异常，可以在方法头声明throws语句，在前面已经举过例子了。</p>
<h4 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h4>
<ul>
<li>try后面可以有多个catch块，只能有至多一个finally块，也可以只跟finally块。</li>
<li>在try块中定义的变量，在catch和finally中不能访问。</li>
<li>每当try后面有多个catch时，会依次对catch块进行匹配，只需要匹配同一继承分支上的父类就会执行。例如， IOException是Exception的子类，如果抛出IOExpception且Exception的catch块在前那么就只会执行Exception。例：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code1;<span class="comment">//抛出FileNotfoundException</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLExceptio e)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">&quot;SOLException&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">&quot;IOException&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个只会输出Exception，因为Exception和FileNotFoundException在还有IOException在同一继承分支上，每一次直接走Exception了，而不会走IOException。<strong>所以让子类的catch在前面，防止错误的catch</strong>。</p>
<ul>
<li>为了简化，可以用 | 分隔两个异常在一个catch块中进行处理。例如 catch( FileNotFoundException | InterruptedIOException e){…}</li>
<li>如果一个地方出现受检查异常，要么用throws，要么用try，不然会出现编译错误（这样也就方便些try了，不然写代码的时候还真不好说哪里有异常）。</li>
</ul>
<h4 id="退出"><a class="markdownIt-Anchor" href="#退出"></a> 退出</h4>
<p>正常流程是捕捉异常，执行catch，执行finally，退出。有两种退出方式</p>
<p>第一种使用System.exit(number);这种方法会直接退出程序，</p>
<p>第二种是return，退出本方法，这个时候如果有返回值还可以弄个返回值以便其他部分正常运行。finally执行于return之前。一般return是在catch中的，但是也可以在finally中，但是这样可能会导致问题。</p>
<ul>
<li>返回值覆盖，因为catch执行于return之前，所以如果要执行catch中的return，会先执行finally中的return，这个时候catch中的return就不会执行了。</li>
<li>丢失异常，如果在catch中抛出异常且finally中有return就可能发生异常丢失。这个时候catch中的异常就不会被抛出。此外，如果catch和finally中都抛出异常，那么catch中的异常将会丢失。</li>
</ul>
<p>为了解决丢失异常的问题，Throwable接口中有两个默认实现的方法</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> addSuppressed(<span class="built_in">Throwable</span> <span class="built_in">exception</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">Throwable</span>[] getSuppressed()</span><br></pre></td></tr></table></figure>
<p>其中addSuppressed()方法就是把丢失的异常保存下来，getSuppressed就是返回所有保存下来的异常。当然，并不是系统自动添加，还要手动用这些方法去添加。</p>
<h3 id="异常类"><a class="markdownIt-Anchor" href="#异常类"></a> 异常类</h3>
<p>java中用类来描述异常。所有异常的祖先是java.lang.Throwable类。它的实例就是具体的异常，可以通过throw抛出。它提供了一些常用方法，包括</p>
<ul>
<li>getMessage() 返回String类型的异常信息</li>
<li>printStackTrace() 打印跟踪方法调用栈获得的详细异常信息</li>
</ul>
<p>例如catch到这个异常后，可以<code>System.out.println(e.getMessage())</code>来输出异常信息。例如e里面的信息时Out of money（就是前面的），那么就会输出这个异常信息。</p>
<p>而如果用后面那个方法，将会说明哪个类，哪一行出现了异常。</p>
<p><img src="/images/20160603151809323" alt="异常类图" /></p>
<ul>
<li>Error类，表示单靠程序本身无法恢复的严重错误，例如内存不足，或者栈溢出。</li>
<li>Exception类，表示程序可以处理的异常。出现这些异常时，可以进行处理而不退出程序。</li>
<li>IOException 输入输出时产生的异常。</li>
<li>ArithmeticException 数学异常。例如除以0</li>
<li>NullpointerException，空指针异常。当引用变量时null是，试图使用这个变量将会出现。</li>
<li>IndexOutOfBoundsException 下标越界异常</li>
<li>ClassCastException 类型转换异常，例如父类转子类</li>
<li>IllegalArgumentException 非法参数，例如 if(name==null)throw new IllegalArgumentException(“姓名不能为空”)。</li>
</ul>
<h4 id="运行时异常"><a class="markdownIt-Anchor" href="#运行时异常"></a> 运行时异常</h4>
<p>RuntimeException一个子树都可以叫运行时异常。这种异常特点是编译器不会检查他。例如上面说的数学异常。当这种异常出现的时候程序将异常终止。其他的都是受检查异常。</p>
<h4 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h4>
<p>可以通过继承来实现自定义异常。一般挂在Exception或RuntimeException上。</p>
<p>自定义异常要一般要写以下部分。</p>
<p>异常数据，异常原因（String类型），然后是一个带参数的构造函数。之后提供方法说明这个异常。</p>
<h4 id="异常转义异常链"><a class="markdownIt-Anchor" href="#异常转义异常链"></a> 异常转义异常链</h4>
<p>原始的异常对于用户来说看不懂，这个时候我们就要抛出一些更人性化的异常。但是与此同时我们也要把原始异常保存易于我们排错。这个时候我们就可以在原始异常上进行扩展。扩展类的数据域中可以来一个Throwable的引用变量，然后在构造函数中把原始异常导入。这样就保存了原始异常。</p>
<p>例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Throwable</span> cause = <span class="literal">null</span>;</span><br><span class="line">    public <span class="type">BaseException</span>();</span><br><span class="line">    public <span class="type">BaseException</span>(<span class="type">Throwable</span> cause)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">BaseException</span>(<span class="type">String</span> msg, <span class="type">Throwable</span> cause)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h4 id="处理多样化异常"><a class="markdownIt-Anchor" href="#处理多样化异常"></a> 处理多样化异常</h4>
<p>就是一次性抛出多个异常，这就需要先自定义一个异常类，收集多种异常然后一次性输出。</p>
<p>例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> int size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">List</span>&lt;<span class="type">Throwable</span>&gt;exceptions = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="type">Throwable</span>&gt;();</span><br><span class="line">    public void addExcpetion(<span class="type">BaseException</span> ex)</span><br><span class="line">    &#123;</span><br><span class="line">        exceptions.add(ex);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="记录日志"><a class="markdownIt-Anchor" href="#记录日志"></a> 记录日志</h3>
<p>记录日志的作用：监视代码中变量情况，周期性的记录到文件中供其他应用统计分析。承担继承开发环境中调试器作用。</p>
<p>要在程序中输出日志，最普通的办法是用println输出。比较好的做法是用一个日志操作类。</p>
<p>现在可以直接使用java.util.logging日志操作包。这个包中主要有四个类</p>
<ul>
<li>Logger类：生成日志，并对日志信息分级筛选，确定什么等级被输出，什么不输出。</li>
<li>Handler： 负责输出日志信息。它有两个子类：ConcoleHandler（输出到Dos控制台），FileHandler（输出到文件中）</li>
<li>Level类： 表示日志各个界别。</li>
</ul>
<h4 id="创建及设置级别"><a class="markdownIt-Anchor" href="#创建及设置级别"></a> 创建及设置级别</h4>
<p>创建 <code>Logger mylogger = Logger.getLogger(&quot;mylogger&quot;);</code></p>
<p>getlogger就是用来创建对象的。如果mylogger存在，那么直接返回引用。</p>
<p>级别： SEVERE(严重）， WARNING(警告），INFO , CONFIG(确认），FINE（好），CONFIG,FINE,FINER,FINEST</p>
<p>默认情况下，只会输出最高三个级别的。可以使用Logger类的setLevel()来设置级别。例：<code>mylogger.setLevel(&quot;Level.FINE&quot;)//把日志设置成FINE级别</code>。这样设置FINE及以上级别都会被设置。还有Level.on开启所有级别和Level.off关闭所有级别。</p>
<p><code>mylogger.info(&quot;这是一条普通提示消息&quot;)</code>用级别的名字设置提示消息</p>
<h4 id="输出日志到文件"><a class="markdownIt-Anchor" href="#输出日志到文件"></a> 输出日志到文件</h4>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">FileHandler fileHandler = <span class="keyword">new</span> <span class="constructor">FileHandler(<span class="string">&quot;C:\\test.log&quot;</span>)</span>;</span><br><span class="line">fileHandler.set<span class="constructor">Level(Level.INFO)</span>;<span class="comment">//设定向文件中写日志的级别</span></span><br><span class="line">mylogger.add<span class="constructor">Handler(<span class="params">fileHandler</span>)</span>;<span class="comment">//将FileHandler与Logger关联</span></span><br></pre></td></tr></table></figure>
<h3 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h3>
<p>语法： assert 条件表达式 或 assert 条件表达式 : 包含错误信息的表达式。</p>
<p>作用： 当条件表达式为false时，会抛出AssertError，这是一个错误。如果后面有包含错误信息的表达式，那么将会输出后面的内容</p>
<p>例如： assert b!=0 : ”b不能为0“；</p>
<p>启用断言需要-ea参数，而IDEA中默认是关闭的。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 数据类型和变量</title>
    <url>/post/f201f9fd.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h3>
<p>因为是记笔记，这里只说一下和c++不同的地方。</p>
<p>定义及使用的方式和c++基本一致，就是有些名字改了而已。</p>
<p>类变量自动初始化，boolean初始化为false，其他初始化为0。但是普通的变量还有自己初始化。这里和c++不同的是如果没有初始化会报错。当然，如果一直没有使用的话不初始化也不会报错。</p>
<p>boolean 就是c++中的bool型。但是有一点不同，这里只能赋true or false，赋一个整数变成bool型是不可以的。但是无语的是底层实现其实还是非零是true，零是false。也就是说，在java中,int i = 1; if(i)的行为是不被允许的，因为整型不可以变成boolean型。</p>
<p>byte 一个字节，和char不同，这个是整型的。当然，java中也有char</p>
<p>在java中，如果数学表达式都是整数，则返回值只能是int或long型。如果把返回值赋给byte型，要进行强制类型转换。<strong>强制类型转换例：byte a = (byte)(1+1);</strong></p>
<p>可以用下划线分隔，例如：int a = 10_000_000;实际上就是1000万，这样可以增加可读性。</p>
<p>此外，可以在后面加尾标表示类型。例如 l是long型，f是float，D是double。S是short，C表示char。例如： 100L。</p>
<p>小数没有后缀默认是double型</p>
<h4 id="变量的赋值"><a class="markdownIt-Anchor" href="#变量的赋值"></a> 变量的赋值</h4>
<ul>
<li>如果int型直接赋给byte，short或char型的时候，如果在数据范围内，可以直接赋值，如果超出数据范围，必须要进行强制类型转换，而且是显式的，不然会报错。超出部分直接截断，没超出的再按对应编码方式解释。</li>
</ul>
<p>byte b = 129;//错</p>
<p>byte b = (byte)129;//对</p>
<ul>
<li>浮点型赋给整型必须要进行强制类型转换，而整型给浮点型不要</li>
<li>double给float要强制类型转换，而float给double不要</li>
</ul>
<p><strong>java语言编码</strong></p>
<p>java采用UCS-2编码，字符占两个字节，把字符看成无符号整数对待。一般来说不用记字符的编码，但是像一些特殊的例如<code>'</code>如果直接char c = ‘’‘就会出错。所以可以加反斜线进行转义。char c = ‘’’</p>
<h3 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型"></a> 引用类型</h3>
<p>引用可分为类引用，接口引用，数组引用。</p>
<p>类引用引用类的实例，接口引用引用接口的实例，数组引用引用数组的实例（数组页看成对象）。无论是哪种，都是引用一个对象</p>
<p>如果没有引用一个实例，可以赋值成null，例如：</p>
<p>Doll a = null;</p>
<p>Doll a = new Doll(“beibei”);</p>
<p>用new关键字可以创建一个对象，它做了下面的事：</p>
<ul>
<li>为对象分配空间，并将变量初始化</li>
<li>调用构造方法</li>
<li>返回对象引用</li>
</ul>
<h4 id="实例变量和静态变量和静态函数"><a class="markdownIt-Anchor" href="#实例变量和静态变量和静态函数"></a> 实例变量和静态变量和静态函数</h4>
<p>类的成员变量有两种，一种是static修饰的变量，叫做类变量，或静态变量。一种是普通的实例变量。</p>
<p>静态变量就是归所有实例所共享的。而普通变量就是每一个实例所独有的。</p>
<p>静态变量储存在方法区，而普通变量存放在堆区。想到java类方法的访问过程就可以知道方法区是存放一些共有的东西，例如方法的二进制代码。每个类使用方法时直接调用就可以了。</p>
<p>静态函数有几个特点：</p>
<p>如果不是类中的静态函数，那么只能在当前文件中使用，相当于权限是private。</p>
<p>如果是类中的静态函数，只能使用静态变量，也不能调用类中的非静态成员函数。</p>
<p><strong>this</strong></p>
<p>java中也有this指针，也是指向当前对象，但是使用的是点操作符而不是箭头。使用上与c++大致相同，</p>
<p>例： owner.setdog(this)//this代表当前dog的对象</p>
<h3 id="参数传递"><a class="markdownIt-Anchor" href="#参数传递"></a> 参数传递</h3>
<p>如果传递的是基本数据类型，那么就传递参数的值（值传递？）。如果是对象或者数组，那么就是引用传递。注意数组不是指针传递了，因为java中好像没有指针的概念。所以这里数组应该也可以作为返回值（纯推测，还没看到）。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 数组</title>
    <url>/post/325cdbf2.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1>
<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2>
<p>可以这样声明：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int[] scores<span class="comment">;</span></span><br><span class="line">String[] names<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>也可以这样声明</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int scores[]<span class="comment">;</span></span><br><span class="line">String names[]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>二维更为古怪</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-attr">[]</span><span class="selector-tag">x</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-tag">x</span><span class="selector-attr">[]</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">x</span><span class="selector-attr">[]</span><span class="selector-attr">[]</span>;</span><br></pre></td></tr></table></figure>
<p>这里注意一点，声明时不能往括号中加东西，会报错。例如：<code>int x[1];//报错</code></p>
<p>java中推荐吧括号放到前面，可能int[]也成了一个对象？</p>
<h2 id="创建数组对象"><a class="markdownIt-Anchor" href="#创建数组对象"></a> 创建数组对象</h2>
<p>创建数组对象语法和c++中创建动态数组类似。</p>
<p><code>int[] scores = new int[100];</code></p>
<p>上面这个代码首先要在堆中分配空间，然后把里面的数据初始化。</p>
<p>括号中的数字可以使常量，也可以是变量，甚至可以是0(表示里面没有数据).</p>
<h2 id="访问数组的元素和长度"><a class="markdownIt-Anchor" href="#访问数组的元素和长度"></a> 访问数组的元素和长度</h2>
<p>和c++一样，下标索引。如果越界，会抛出ArrayIndexOutOfBoundsException异常</p>
<p>所有数组都有length属性，表示数组的长度: <code>public final length</code>.</p>
<p>所以我们可以直接输出这一属性，例如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x<span class="literal">[]</span> = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="number">40</span>]</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.length); <span class="comment">//输出length</span></span><br></pre></td></tr></table></figure>
<p>如果是对象数组，那么数组中的元素时对象的引用，因此当我们不使用数组的时候最好把值赋null触发垃圾回收机制。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> sb = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="built_in">String</span> sbs[] = <span class="keyword">new</span> <span class="built_in">String</span>[](sb,<span class="keyword">null</span>);</span><br><span class="line">...</span><br><span class="line">sbs[<span class="number">0</span>] = <span class="keyword">null</span>;<span class="comment">//清除数组对象的引用</span></span><br><span class="line">sbs = <span class="keyword">null</span>;<span class="comment">//清除数组引用</span></span><br></pre></td></tr></table></figure>
<h2 id="多维数组和不规则数组"><a class="markdownIt-Anchor" href="#多维数组和不规则数组"></a> 多维数组和不规则数组</h2>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">String</span>[][] rooms = new <span class="symbol">String</span>[<span class="number">2</span>][];</span><br><span class="line">rooms[<span class="number">0</span>] = new <span class="symbol">String</span>[](<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">rooms[<span class="number">1</span>] = new <span class="symbol">String</span>[](<span class="string">&quot;Mary&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可以用不等长数组是因为每一行都是一个数组元素，都有自己的length变量</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rooms.<span class="built_in">length</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;rooms[i].<span class="built_in">length</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(rooms[i][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个循环的length是rooms引用多少个数组，rooms[]指的是每个数组的长度。</p>
<p>要注意只有最后一个括号可以不加数字，我的理解是只有最后一层才是真正的数组对象，才有length，同时，前面不确定就不知道要开多少个数组对象。</p>
<h2 id="数组作为返回值"><a class="markdownIt-Anchor" href="#数组作为返回值"></a> 数组作为返回值</h2>
<p>在c<ins>中数组是不能作为返回值的，因为c</ins>中数组是一个指针，而又不能像其他指针一样确定它的大小。而在java中数组是一个对象，可以返回它的引用。</p>
<h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h1>
<p>平常我们想找某一个值都是通过遍历数组得到的，我们也可以用值通过某种映射关系得到在数组中的位置。这就是哈希表</p>
<p>例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value%<span class="number">10</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子中value就是值，返回的是下标。但是这时如果超过十就会出现重复，这叫做哈希冲突。我们可以设计更复杂的映射来处理哈希冲突。</p>
<p>判断重复的条件是 object1.equals(boject2)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Object</span> value;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Node(<span class="built_in">Object</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">Object</span> getValue()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Node getNext()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> setNext(Node next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyhashSet</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node[] array;</span><br><span class="line">    <span class="keyword">private</span> int size = <span class="number">0</span>;<span class="comment">//数组元素数目</span></span><br><span class="line">    <span class="keyword">public</span> MyHashSet(int length)</span><br><span class="line">    &#123;</span><br><span class="line">        array = <span class="keyword">new</span> Node[length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> int size()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> int hash(<span class="built_in">Object</span> o)<span class="comment">//哈希算法</span></span><br><span class="line">    &#123;</span><br><span class="line">        int h = o.hashCode();<span class="comment">//Object类中有这个方法</span></span><br><span class="line">        h += ~(h &lt;&lt; <span class="number">9</span>);</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">14</span>);</span><br><span class="line">        h += (h &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> int indexFor(int hashCode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hashCode &amp; (array.length-<span class="number">1</span>);<span class="comment">//返回索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> add(<span class="built_in">Object</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        Node node = array(index);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            array(index) = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//处理哈希冲突</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node nextNode;</span><br><span class="line">            <span class="keyword">while</span>(!node.getValue().equals(value) &amp;&amp;</span><br><span class="line">            (nextnode = node.getNext()) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node = nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不允许加入重复元素</span></span><br><span class="line">            <span class="keyword">if</span>(!node.getValue().equals(value))</span><br><span class="line">            &#123;</span><br><span class="line">                node.setNext(newNode);</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试是否有这个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> contains(<span class="built_in">Object</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        Node node = array[index];</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; !node.getValue().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            node = node.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="literal">null</span> &amp;&amp; node.getValue().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> remove(<span class="built_in">Object</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        Node node = array[index];</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="literal">null</span> &amp;&amp; node.getValue().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            array[index] = node.getNext();</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node lastNode = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; !node.getValue().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            lastNode.setNext(node.getNext());</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">Object</span>[] getAll()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Object</span>[] values = <span class="keyword">new</span> <span class="built_in">Object</span>[size];</span><br><span class="line">        int index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node node: array)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                values[index++] = node.getValue();</span><br><span class="line">                node = node.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="arrays类"><a class="markdownIt-Anchor" href="#arrays类"></a> Arrays类</h1>
<p>java.util.Arrays类，有一系列操作数组的方法。这是一个私有类</p>
<p>静态方法：</p>
<ul>
<li>equals(): 比较两个数组是否相同</li>
<li>fill(): 向数组中填充数据</li>
<li>sort(): 把数组升序排列</li>
<li>parallelSort(): 开启多个线程，以并发的方式对数组中元素进行排序，提高效率</li>
<li>asList()把一个数组变成List</li>
</ul>
<p>例： Arrays.sort(a);</p>
<h1 id="用-声明数目可变参数"><a class="markdownIt-Anchor" href="#用-声明数目可变参数"></a> 用 … 声明数目可变参数</h1>
<p>可以用int… a代替 int[] a;这种模式下如果输入立即数可以转化成数组类型：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>... datas)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//可以直接输入数据</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure>
<p>但是必须要放在参数列表的最后一位</p>
<pre class="highlight"><code class="">pubilc void max(int... data, String p)//错误，int... 必须放在最后
&#123;
    ...
&#125;</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 操作符</title>
    <url>/post/4b1879e3.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h3>
<p>c<ins>中没有 &gt;&gt;&gt;(逻辑右移）操作符，这是在java中才有的。c</ins>想要实现逻辑右移的功能要么进行更复杂的运算要么用unsigned。<a href="https://xinhecuican.github.io/post/61738.html">这篇博客中详细讲了算术右移和逻辑右移</a></p>
<p>浮点数不支持移位运算。并且如果其中一个浮点数是double型，结果就是double型。</p>
<table>
<thead>
<tr>
<th>逻辑运算符（部分）</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>短路与</td>
</tr>
<tr>
<td>&amp;</td>
<td>非短路与</td>
</tr>
<tr>
<td>两竖线</td>
<td>短路或</td>
</tr>
<tr>
<td>一竖线</td>
<td>非短路或</td>
</tr>
</tbody>
</table>
<p>短路与非短路的区别是对于短路运算符如果左边可以判断，那么就不会去判断右边。非短路运算符无论条件如何都会执行两边。</p>
<p>非短路运算符的作用是有时我们先要进行一些运算再判断，非短路运算符可以确保运算的执行。例如 if(b == true &amp; (output+=10) == 20 ).其中output+=10就是运算，</p>
<h3 id="操作符在对象中"><a class="markdownIt-Anchor" href="#操作符在对象中"></a> ==操作符在对象中</h3>
<p>当==操作符在对象中时，两个引用变量必须是引用同一个对象，结果才为true。</p>
<p>例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Integer <span class="built_in">int</span>1 = new Integer(<span class="number">1</span>);</span><br><span class="line">Integer <span class="built_in">int</span>2 = new Integer(<span class="number">1</span>);</span><br><span class="line">Integer <span class="built_in">int</span>3 = <span class="built_in">int</span>1;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="built_in">int</span>1 == <span class="built_in">int</span>2);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="built_in">int</span>1 == <span class="built_in">int</span>3);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>可见哪怕赋了一样的值两个对象还是不同的。</p>
<h4 id="与多态"><a class="markdownIt-Anchor" href="#与多态"></a> == 与多态</h4>
<p>想要使用必须要两个类是相同的或者处于同一分支。例如 cat和dog都继承与animal类，cat可以和animal进行比较，但是cat不能和dog进行比较。</p>
<p>数组也是引用类型，可以用==进行比较，但是前提是两边变量类型必须相同，例如一个int型和一个long型进行比较就会报错。</p>
<h4 id="对象的equal方法"><a class="markdownIt-Anchor" href="#对象的equal方法"></a> 对象的equal（）方法</h4>
<p>有些jdk中的一些类覆盖了object类的equal（）。这种情况下比较就是如果类型一致且内容一致（数据域），那么就返回true，否则返回false。例如String类。</p>
<p>所以如果要进行字符串比较的话，必须使用equal方法。不然除非是复制的两个字符串，不然即使内容相同也会出错。</p>
<h3 id="instanceof操作符"><a class="markdownIt-Anchor" href="#instanceof操作符"></a> instanceof操作符</h3>
<p>instanceof操作符用于判断引用类型所引用的对象是否是一个类或其祖先的实例。如果是返回true。</p>
<p>格式： 实例名 instanceof 类名或接口名</p>
<p>例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Dog dog = <span class="keyword">new</span> <span class="constructor">Dog()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(dog instanceof Dog);</span><br><span class="line"></span><br><span class="line">output: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">同时如果Dog替换成dog的父类或祖先类，或Dog类或其祖先实现的接口时，都会返回<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h3>
<p><strong>自动类型转换</strong></p>
<p>总的规则就是小的和大的相乘结果是大的。浮点数和整数相乘结果是浮点数。</p>
<p><strong>强制类型转换</strong></p>
<p>把高位类型赋值给低位类型，结果一定要进行强制类型转换（显式转换）。由小到大进行自动类型转换。</p>
<p>例 ：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">long</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = (<span class="keyword">int</span>)j;</span><br><span class="line"></span><br><span class="line">其中只有第一个是不合法的，因为浮点数默认是<span class="keyword">double</span>型。</span><br></pre></td></tr></table></figure>
<p>此外，如果超过了数据范围也必须强制类型转换。</p>
<p>char c = -1;//错误，因为超过了数据范围</p>
<p>char c = 97;//正确</p>
<p><strong>引用类型的强制转换</strong></p>
<p>子类复制给祖先类，会自动进行类型转换。而父类给子类则必须进行强制类型转换。</p>
<p>如果不在统一继承分支上则不可以进行转换。</p>
<p>例如：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Animal cat</span> = new Cat();</span><br><span class="line"><span class="attribute">Dog dog</span> = (Dog)cat;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以通过编译，但是在运行时会跑出ClassCastException异常</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 泛型</title>
    <url>/post/70263071.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="发展过程"><a class="markdownIt-Anchor" href="#发展过程"></a> 发展过程</h1>
<p>由父类转给子类时允许的，但是会抛出ClassCastException。这种异常是运行时异常，编译期不会检查，这就加大了检查的难度。为了解决这个问题，从jdk5开始引入了泛型。泛型可以把ClassCastException转换成编译时类型不兼容错误。</p>
<p>泛型符号是&lt;&gt;,里面可以使任意一种类（不能是int等基础类型，可以是Integer).</p>
<p>例如： <code>Set&lt;Object&gt; set = new HashSet&lt;Object&gt;();//实例中的类型必须要和前面相同</code></p>
<h1 id="泛型类数组接口方法"><a class="markdownIt-Anchor" href="#泛型类数组接口方法"></a> 泛型类，数组，接口，方法</h1>
<p><strong>泛型类</strong></p>
<p>例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line">    <span class="keyword">public</span> Bag(T content)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T get()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> set(T content)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Bag&lt;<span class="built_in">String</span>&gt; bag = <span class="keyword">new</span> Bag&lt;<span class="built_in">String</span>&gt;(<span class="string">&quot;mybook&quot;</span>);</span><br><span class="line">        Integer content1 = bag.get();<span class="comment">//出错</span></span><br><span class="line">        <span class="built_in">String</span> content2 = bag.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和c++中的模板十分类似。同样泛型参数可以有许多个，例如：<code>public class A&lt;str,inte,dou&gt;&#123;...&#125;</code></p>
<p><strong>注意</strong> 如果没有传入泛型实参的话，泛型变量可以使任何类型。例如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> <span class="constructor">Generic(<span class="string">&quot;111111&quot;</span>)</span>;</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> <span class="constructor">Generic(4444)</span>;</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> <span class="constructor">Generic(55.55)</span>;</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> <span class="constructor">Generic(<span class="params">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key is &quot;</span> + generic.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key is &quot;</span> + generic1.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key is &quot;</span> + generic2.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key is &quot;</span> + generic3.get<span class="constructor">Key()</span>);</span><br></pre></td></tr></table></figure>
<p><strong>泛型接口</strong></p>
<p>泛型接口和泛型类类似，但是它的实现类如果实现的是泛型接口，那么它的实现类也要是泛型。例如：</p>
<p><code>public class A&lt;T&gt; implements B&lt;T&gt;</code></p>
<p>如果<code>public class A implements B&lt;T&gt;</code>会报错</p>
<p>但是如果实现的是一个确定类型的接口，那么前面就不是必须加</p>
<p><code>public class A implements B&lt;Integer&gt;</code>可以</p>
<p><strong>数组</strong></p>
<p>以前我们都是 int[], double[],现在我们把前面的类型变成泛型。例如<code>T[]</code>。</p>
<p>这里要注意一点，不能使用泛型创建实例。例如<code>T[] content = new T[10];</code>是错误的。</p>
<p><strong>方法</strong></p>
<p>在普通类和泛型类中都可以定义泛型方法。泛型方法只需要在方法头部定义泛型符号就可以了，例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="built_in">void</span> printArray(E[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    Integer[] b = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    a.printArray(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉泛型方法很方便，直接传入参数就可以了，不用管类型。但是这样势必会增大时间开销。</p>
<h1 id="extends限定类型参数"><a class="markdownIt-Anchor" href="#extends限定类型参数"></a> extends限定类型参数</h1>
<p>例如：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> 类名&gt; 必须要是这个类或者子类</span><br><span class="line">&lt;T <span class="keyword">extends</span> 接口名&gt;</span><br></pre></td></tr></table></figure>
<h1 id="使用通配符"><a class="markdownIt-Anchor" href="#使用通配符"></a> 使用？通配符</h1>
<p>前面已经说过，实例中泛型类型必须要和定义时泛型类型相同。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; s1 =  <span class="keyword">new</span> HashSet&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; s2 = <span class="keyword">new</span> HashSet&lt;<span class="built_in">Integer</span>&gt;();//报错</span><br></pre></td></tr></table></figure>
<p>为了防止上述错误，可以使用通配符？，例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Integer&gt; listInteger = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        listInteger.add(<span class="number">11</span>);</span><br><span class="line">        print(listInteger);</span><br><span class="line">        printNew(listInteger);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> print(Collection&lt;<span class="built_in">Object</span>&gt; collection)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">Object</span> obj: collection)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> printNew(Collection&lt;?&gt; collection)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">Object</span> obj: collection)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>print会出现问题，因为只能接受Object的泛型类型，后面一个就可以。</p>
<p>还可以和extends结合。例如：</p>
<p><code>TreeSet&lt;? extends Number&gt; x = new TreeSet&lt;Integer&gt;();//可以，Integer是Number的子类</code></p>
<p>这个和前面说的区别是前面是在定义时决定的，这个是在具体写代码时决定的，个人认为这种更为灵活。</p>
<p>还有super，后面类型只能是前面类型的父类或者他自己。例如：<code>TreeSet&lt;? super Integer&gt; x = new TreeSet&lt;Number&gt;();</code></p>
<h1 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h1>
<ul>
<li>看上去不同的泛型类型导致了不同的类。例如<code>A&lt;Integer&gt;</code>和<code>A&lt;String&gt;</code>是不同的类，但是实际上泛型的类型在编译时期已经赋给内部的变量了，这个时候泛型被擦除了，所以实际上创建实例时还是调用了方法区中的A。</li>
<li>因为上一条，所以不允许出现名字相同只有泛型类型不同的重载，例如：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;Integer&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">&quot;Integer&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">会报错</span><br></pre></td></tr></table></figure>
<ul>
<li>不能对确切的泛型使用instanceof符号，例如：<code>Collection cs = new ArrayList&lt;String&gt;(); cs instanceof Collection&lt;String&gt;; 报错</code></li>
</ul>
<p>但是如果后面使用通配符就可以，<code>cs instanceof Collection&lt;?&gt;通过</code></p>
<ul>
<li>不能使用泛型类型进行强制类型转换，例如：</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Collection cs = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">String</span>&gt; list = (ArrayList&lt;<span class="keyword">String</span>&gt;)cs;<span class="comment">//会警告并且运行时容易出现异常</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 类的生命周期</title>
    <url>/post/61eaf19a.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="类的加载连接和初始化"><a class="markdownIt-Anchor" href="#类的加载连接和初始化"></a> 类的加载连接和初始化</h3>
<ol>
<li>
<p>加载： 查找并加载类的二进制数据</p>
</li>
<li>
<p>链接： 包括验证，准备和解析类的二进制数据</p>
<ul>
<li>验证： 确保加载类的正确性。</li>
<li>准备： 为类的静态变量分配内存，将其初始化为默认值（也就是0）</li>
<li>解析： 将类的符号引用<sup id="fnref:1"><a href="#fn:1" rel="footnote">&lt;span class=“hint–top hint–error hint–medium hint–rounded hint–bounce” aria-label=&quot;符号引用就是在编译阶段，虚拟机并不知道所有引用类的地址（因为还没有加到内存中），就用一个符号表示地址。而直接引用就是真实的地址。</li>
</ul>
</li>
</ol>
<h4 id="类的加载1spanasup变成直接引用"><a class="markdownIt-Anchor" href="#类的加载1spanasup变成直接引用"></a> 类的加载&quot;&gt;[1]</span></a></sup>变成直接引用</h4>
<ol start="3">
<li>初始化： 把类的静态变量赋予正确的初始值。</li>
</ol>
<p>类的加载是指把类的.class文件中的二进制数据读入到内存中，把它存放在方法区中。然后再兑取川家一个java.lang.Class对象，用来封装类在方法区的数据结构。<strong>通俗的来讲就是把代码加载到内存中</strong>。</p>
<p>类的加载是由虚拟机自带的加载器来完成的，但是我们也可以自己去定义。用java.lang.ClassLoader类的子类的实例。</p>
<p>类加载器允许某个类将要被使用时预先加载它。如果预先加载过程中遇到了.class的错误。那么类加载器在首次主动使用这个类的时候报错（LinkageError)</p>
<h4 id="类的链接"><a class="markdownIt-Anchor" href="#类的链接"></a> 类的链接</h4>
<p><strong>类的验证</strong></p>
<p>类的验证主要验证一下内容：</p>
<ul>
<li>类文件格式， 看看后缀是否符合</li>
<li>语义检查 看看是否符合java语义（例如把一个String给int或final是否有子类）</li>
<li>字节码验证，字节码代表java方法。</li>
<li>二进制兼容验证。查看这个类引用的另一个类的方法的=在另一个类中是否存在。</li>
</ul>
<p><strong>类的准备</strong></p>
<p>为类的静态变量分配内存，并设置成0（boolean是false，char是’\u0000’)</p>
<p><strong>类的解析</strong></p>
<p>符号引用上面已经解释过了，其实也就是这个类引用的其他类或其他类的成员变量和方法等。因为这些类在编译阶段并没有加载，所以虚拟机也不知道要到哪里去找这些方法，所以先弄一个符号代表这个方法。</p>
<h4 id="类的初始化"><a class="markdownIt-Anchor" href="#类的初始化"></a> 类的初始化</h4>
<p>静态变量的初始化有两种途径。（1） 声明时直接赋值 （2） 在静态代码块中初始化。</p>
<p>初始化并不是直接初始化。如果没有加载和链接，那么先加载和链接。如果父类没有初始化，那么先初始化父类。</p>
<p>虚拟机只有首次启用一个类的时候才会初始化它。也就是说，创建对象实例，或者访问使用静态变量，还有是某个正在初始化类的父类时都会初始化它。</p>
<p>此外，当final类型的静态变量，如果能直接计算出值，那么会当成常量，不会导致初始化。反之，会导致初始化。</p>
<h3 id="类的加载器"><a class="markdownIt-Anchor" href="#类的加载器"></a> 类的加载器</h3>
<p>类加载和Linux进程生成类似，都是先有一个根加载器，然后其他类加载器只有一个父加载器。父加载器不是加载自己，而是加载子类，但是是子类请求父类加载自己。</p>
<p>有三类自带的加载器：</p>
<ul>
<li>根加载器，负责加载一些核心库，例如java.lang.*</li>
<li>扩展加载器，它的父加载器是根加载器。他从java.ext.dirs系统属性指定的目录中加载扩展。或者从JDK的jre\lib\ext中加载扩展</li>
<li>系统加载器：也叫应用类加载器。它的父加载器是扩展加载器。他从classpath环境变量或者子系统属性java.class.path中加载类，它是用户自定义加载器的默认父加载器。</li>
</ul>
<p><strong>类加载的过程</strong></p>
<p>例如要加载一个类，首先请求父类加载器代为加载，父类再向它的父类代为加载…。一直到根加载器，如果根加载器不能加载，那么就让扩展加载器加载，如果不能加载…。直到找到一个可以加载的。如果所有加载器都不能加载，那么返回ClassNotFoundException。</p>
<p>成功加载那个类的加载器叫定义类加载器。</p>
<p>这种机制是为了安全考虑，因为在这种严密的机制下，用户自定义的加载器不可能取代由父加载器完成的任务。</p>
<p>这里加载器并不一定是和类一样的父子关系。一对父子加载器可能是同一个类的两个实例。</p>
<h4 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h4>
<p>每个类加载器都有自己的命名空间，命名空间由该加载器和所有父加载器所加载的类组成。在同一个命名空间中，不可能出现名字（包括包名）完全相同的两个类。不同的命名空间中就有可能出现。</p>
<h4 id="运行时包"><a class="markdownIt-Anchor" href="#运行时包"></a> 运行时包</h4>
<p>同一加载器加载的属于相同包的类组成了运行时包。包名相同不一定默认访问级别可以访问，必须要组成运行时包才可以访问默认访问级别。</p>
<h3 id="创建用户自定义加载器"><a class="markdownIt-Anchor" href="#创建用户自定义加载器"></a> 创建用户自定义加载器</h3>
<p>首先介绍自定义类的应用场景：</p>
<p>（1）加密：Java代码可以轻易的被反编译，如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用Java的ClassLoader去加载类了，这时就需要自定义ClassLoader在加载类的时候先解密类，然后再加载。</p>
<p>（2）从非标准的来源加载代码：如果你的字节码是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。</p>
<p>（3）以上两种情况在实际中的综合运用：比如你的应用需要通过网络来传输 Java 类的字节码，为了安全性，这些字节码经过了加密处理。这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出在Java虚拟机中运行的类。</p>
<p>要扩展自己的类加载器，只需扩展java.lang.Classloader类，瑞啊后覆盖findClass(String name)方法。该方法根据参数指定类的名字，返回对应Class对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    	File file = <span class="keyword">new</span> File(<span class="string">&quot;D:/People.class&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(file);</span><br><span class="line">            <span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</span></span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(File file) <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里要读入.class的字节，因此要使用字节流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.read(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.write(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/SEU_Calvin/article/details/52315125">这段代码是扒下来的</a></p>
<h4 id="urlclassloader加载类"><a class="markdownIt-Anchor" href="#urlclassloader加载类"></a> URLClassLoader加载类</h4>
<p>在java.net包中，提供了URLClassLoader类，它可以从网上下载类。可以直接使用这个类作为自定义加载器。</p>
<p>构造方法: <code>URLClassLoader(URL[] urls)//父加载器是系统加载器</code></p>
<p><code>URLClassLoader(URL[] urls, ClassLoader parent)//指定父加载器</code></p>
<h3 id="类的卸载"><a class="markdownIt-Anchor" href="#类的卸载"></a> 类的卸载</h3>
<p>java自带类加载器所加载的类是永远不会被卸载的。而用户自定义的类加载器可以被卸载。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">符号引用就是在编译阶段，虚拟机并不知道所有引用类的地址（因为还没有加到内存中），就用一个符号表示地址。而直接引用就是真实的地址。</p>
<h4 id="类的加载a-hreffnref1-revfootnote-aspanlioldivdiv"><a class="markdownIt-Anchor" href="#类的加载a-hreffnref1-revfootnote-aspanlioldivdiv"></a> 类的加载<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div></h4>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 继承和多态</title>
    <url>/post/17862176.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h3>
<p>利用extends来进行继承，例如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上表明Sub类继承Base类，具体继承还要分两种情况。</p>
<ul>
<li>如果在同一个包中，那么Sub继承了Base中的public，protected和默认访问级别的成员变量和方法</li>
<li>如果在不同的包中，不继承默认访问级别的成员变量和成员方法，其他和上一个相同。</li>
</ul>
<p>默认访问级别就是前面没有加任何关键字。</p>
<p>java不支持多继承，一个类只能继承于一个类，但是父类可以有多个子类，就像一棵树。下级继承会继承同一分支上所有的成员和方法。</p>
<p>java中有一个所有类的祖先叫object类，如果没有使用extends关键字那么会自动继承这个类。</p>
<h3 id="方法覆盖"><a class="markdownIt-Anchor" href="#方法覆盖"></a> 方法覆盖</h3>
<p>覆盖指的是父类中的函数在子类中重新写。要满足下列条件：</p>
<ul>
<li>子类方法名称，函数签名（包括参数位置）和返回类型都要和父类方法一致</li>
<li>在子类中，必须要先覆盖函数，才可以重写函数</li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Base类中：</span><br><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Sub</span>类中：</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">int</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">这样会报错</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果<span class="title">Sub</span>类这样</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">int</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function">这样可以编译通过</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子类方法不可以缩小父类的访问权限，如果父类的方法时private那么子类就不能写public</li>
<li>子类不能抛出比父类更多的异常</li>
<li>子类无法覆盖父类的静态方法，只能够隐藏。这两者的区别是覆盖的话父类可以使用子类的，子类也可以使用父类的。隐藏的话父类只能使用父类的，子类只能使用子类的。这是由于static定义的区域所决定的。<br />
例：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">package newpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">void</span> method()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">void</span> method2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------</span><br><span class="line">package newpackage;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newsec</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">void</span> method()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">void</span> method2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Base a = <span class="keyword">new</span> newsec();</span><br><span class="line">        a.method();</span><br><span class="line">        a.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出时Base和Sub</span><br></pre></td></tr></table></figure>
<ul>
<li>可以扩大访问权限。并且如果是抽象类，子类可以只扩大访问范围而不做任何事.但是必须要实现它，不然只能让子类也定义成抽象类。</li>
</ul>
<p>例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">父类定义类A()的抽象方法，子类可以这样</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> A()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">这也算实现</span><br></pre></td></tr></table></figure>
<h3 id="super"><a class="markdownIt-Anchor" href="#super"></a> super</h3>
<p>super和this一样都是指向一个对象，不同的是super指向父类，this指向自己。</p>
<p>使用场合：</p>
<ul>
<li>局部变量和类变量重名</li>
<li>子类覆盖了父类的方法或成员变量时，可以用这种方法使用父类的方法</li>
</ul>
<p>需要注意，如果父类成员变量和方法被定义成private，那么子类无论如何都无法访问他们。不能再静态方法区使用super关键字。</p>
<p>此外如果在父类第一行使用super()是调用父类构造函数</p>
<h3 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h3>
<p>多态就是父类可以使用子类，子类也可以使用父类（自我理解）。下面讲具体使用规范。<br />
儿子可以用爸爸一切公有的，而爸爸如果引用了自己的实例就不能用儿子的，只有引用了儿子的实例才可以使用儿子继承于爸爸的。</p>
<ul>
<li>对于一个引用类型变量，编译器按声明变量进行处理。例如</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Base </span>who = new <span class="keyword">Sub();</span></span><br><span class="line"><span class="keyword">who.subVar </span>= <span class="string">&quot;123&quot;</span>;</span><br><span class="line">这里编译会出错，无论后面引用了谁，who都是<span class="keyword">Base类，而父类不能直接使用子类的变量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>编译器允许继承分支关系的类进行类型转换。对于向上转型（子类使用父类的），编译器会自动类型转换。对于向下转型则需要强制类型转换。在运行时，子类可以转换成父类，但是父类实际上无法转换成子类。因为父类有的子类一定有，子类有的父类却不一定有。</p>
</li>
<li>
<p>对于引用对象绑定，遵循如下规则</p>
<ol>
<li>对于实例方法和引用变量是由实际使用的对象进行绑定。这个是动态的，也就是说方法的实际输出是由实际类型所决定。例如 Base a = new Sub();输出时Sub的。如果这个时候Sub的子类b = a;那么输出还是Sub的。但是如果使用了子类中独有的方法会报错</li>
<li>静态方法和成员变量由前面定义的类型所决定，这属于静态绑定，在编译时期已经决定。无论引用了谁都不会改变。</li>
</ol>
</li>
</ul>
<h3 id="继承的使用"><a class="markdownIt-Anchor" href="#继承的使用"></a> 继承的使用</h3>
<p>继承树的最上层一般是抽象层。并且继承树上有接口类型，那么尽可能的把应用变量声明成继承树上层的接口类型。因为实例可以是子类，向上转型不会出现问题，这样便于使用多个子类，如果想用子类独有的东西就把引用变量定义成子类。</p>
<p>继承关系会打破封装，因为上层类改变会使下层类也跟着改变。所以对上层类定义要谨慎。</p>
<h3 id="修饰符"><a class="markdownIt-Anchor" href="#修饰符"></a> 修饰符</h3>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类</th>
<th>成员方法</th>
<th>构造方法</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract（抽象的）</td>
<td>有</td>
<td>有</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>static（静态的）</td>
<td>无</td>
<td>有</td>
<td>无</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>public</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>protected</td>
<td>无</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>private</td>
<td>无</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>synchronized（同步的）</td>
<td>无</td>
<td>有</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>native（本地的）</td>
<td>无</td>
<td>有</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>transient（暂时的）</td>
<td>无</td>
<td>无</td>
<td>无</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>volatile（易失的）</td>
<td>无</td>
<td>无</td>
<td>无</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>final（不可改变的）</td>
<td>有</td>
<td>有</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
</tbody>
</table>
<p>表中的类指的是顶层类，与内部类相对应（内部类是定义在类或方法中的类）。</p>
<h4 id="访问控制修饰符"><a class="markdownIt-Anchor" href="#访问控制修饰符"></a> 访问控制修饰符</h4>
<p>访问控制指的是其他类或对象可以查看的东西。一共有四种访问级别</p>
<ul>
<li>public 所有都是可以给外部看的</li>
<li>protected 只对子类和一个包中的类公开</li>
<li>默认级别 没有修饰符 只对同一个包中的类公开，不对子类公开</li>
<li>private 不对外公开</li>
</ul>
<p>public&gt;protected&gt;默认&gt;private。public与其他不同是其他包也可以查看</p>
<p>顶层类只能是public或protected，不然会出现编译错误。</p>
<p>访问级别是对成员变量和类来说的，对局部变量没有意义，局部变量的访问范围就是方法内部。</p>
<h4 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> abstract</h4>
<p>用abstract修饰的类表示抽象类，抽象类不允许实例化，也就是抽象类不允许创建实例</p>
<p>用abstract修饰的方法表示抽象方法，抽象方法内部没有内容，只有一个函数头。</p>
<p>注意，如果有抽象方法，这个类必须定义成抽象类。此外，没有抽象静态方法，abstract和static是互相矛盾的。</p>
<p>抽象类本身不可以实例化，但是可以创建一个抽象类的引用变量然后引用具体类。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Base a = <span class="keyword">new</span> <span class="type">Base</span>();<span class="comment">//不可以，因为Base是抽象类</span></span><br><span class="line">Base b = <span class="keyword">new</span> <span class="type">Sub</span>(); <span class="comment">//Sub是具体类</span></span><br></pre></td></tr></table></figure>
<p>抽象方法不可以用private修饰，因为抽象出来本来就是要让子类去实现的，private一下子类就无法使用了。</p>
<p>子类必须实现抽象类的所有抽象方法。</p>
<h4 id="final"><a class="markdownIt-Anchor" href="#final"></a> final</h4>
<p>final有不可改变的含义。</p>
<p>用final修饰的类不能被继承，没有子类</p>
<p>用final修饰的方法不能被覆盖</p>
<p>final修饰的变量表示常量，只能赋一次值</p>
<p>final不能用来修饰构造方法。</p>
<p>final修饰引用变量，这个变量不能只能引用一个实例，但是可以对这个实例进行修改。</p>
<p>不允许覆盖就是不能用相同的函数签名去重写这个函数</p>
<h4 id="static"><a class="markdownIt-Anchor" href="#static"></a> static</h4>
<ul>
<li>static修饰的成员变量时静态变量，可以直接通过类名进行访问，并且所有实例共用一个静态变量</li>
<li>修饰成员方法表示静态方法，可以直接通过类名访问</li>
<li>修饰的程序代码块叫做静态代码块，加载类时会执行这些代码块</li>
</ul>
<p>静态变量只有一份备份，处于方法区，在加载类的时候随之加载。</p>
<p>注意，在静态方法中没办法用this，因为静态方法时所有类共有的，this表示的是某个特定的类。所以在main方法中不能用this和super，因为main是static的，如果想访问这个类的内容，可以先定义一个该类的引用变量。</p>
<p>如果直接访问了，编译器会报<strong>在静态方法内不允许访问非静态变量</strong>。</p>
<p>main函数必须是static的原因是只要加载了main所在的类main就被加载了，可以直接去执行，不然还要先创建一个类然后使用main方法。</p>
<p>类中可以包含一些静态代码块，这些代码块不存在与任何方法中，加载类时一次执行这些代码块。例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;First Static code i=&quot;</span> + i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static代码块和静态方法一样，不可以直接调用实例变量和实例方法，只用通过先引用之后才可以进行调用。</p>
<h5 id="static进行静态导入"><a class="markdownIt-Anchor" href="#static进行静态导入"></a> static进行静态导入</h5>
<p>静态导入类似于c++中的using namespace std;可以简写代码。例如</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">import</span>.<span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out.<span class="built_in">println</span>(MIN_VALUE);<span class="comment">//原来是Integer.MIN_VALUE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果静态导入过多，可能会导致冲突，因此尽量导入的时候具体一点。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java初探</title>
    <url>/post/912b2566.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="源文件结构"><a class="markdownIt-Anchor" href="#源文件结构"></a> 源文件结构</h3>
<p>java源文件可能包含以下内容：</p>
<ul>
<li>包声明语句</li>
<li>包引入语句</li>
<li>类声明</li>
<li>接口声明</li>
</ul>
<p>这些内容都不是必须的。此外要注意只能有一个类或接口是public的（一般也是private）。</p>
<h4 id="包声明语句"><a class="markdownIt-Anchor" href="#包声明语句"></a> 包声明语句</h4>
<p>包声明语句把类放到特定的包中。例如</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">package com.abc.dollapp;</span><br><span class="line">public calss appmain<span class="meta">&#123;...&#125;</span>;</span><br><span class="line">class doll<span class="meta">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中appmain和doll都在com.abc.dollapp包中。</p>
<p>在一个java文件中，只能有一个package语句。如果没有提供package，那么就表明在系统默认的包中。</p>
<h5 id="包的作用"><a class="markdownIt-Anchor" href="#包的作用"></a> 包的作用</h5>
<ol>
<li>用于区分名字相同的类。例如定义了两中车类名都叫car，一种实际上是奔驰，一种是宝马。把他们丢在不同的包中就可以区分他们，相当于使用了不同的命名空间<sup id="fnref:1"><a href="#fn:1" rel="footnote">&lt;span class=“hint–top hint–error hint–medium hint–rounded hint–bounce” aria-label=&quot;命名空间实际上就是在函数前的一些附加消息。因为可能同时引入了多个库，库文件中可能某些函数名字相同，这个时候只有通过前面添加一些信息来辨别。典型例子就是using namespace std;这个含义就是使用标准命名空间。不然就要写std::cout来进行辨别。</li>
<li>有助于访问权限的控制。但不同包之间进行访问时，就会受到访问权限的控制。</li>
<li>有助于组织划分各个类。&quot;&gt;[1]</span></a></sup>。</li>
</ol>
<h5 id="包的命名规范"><a class="markdownIt-Anchor" href="#包的命名规范"></a> 包的命名规范</h5>
<p>包的名字通常用小写，一般包含以下信息：</p>
<ol>
<li>类的创建者信息</li>
<li>类所属软件信息</li>
<li>类在具体项目中所处的位置</li>
</ol>
<p>jdk提供了一些基本包</p>
<ul>
<li>java.lang包，包含线程类（Thread)，异常类（Exception），系统类（System），整数类（Integer），字符串类（String）等。这个包系统会自动引入。</li>
<li>java.awt。抽象窗口工具包。用于构建GUI界面和绘图类</li>
<li><a href="http://java.io">java.io</a> 输入输出包。例如文件输入类（FileInputStream类）</li>
<li>java.util 实用类，例如日期类（Date）集合类（Collection）</li>
<li><a href="http://java.net">java.net</a> 支持TCP/IP网络协议。</li>
</ul>
<h5 id="包引入"><a class="markdownIt-Anchor" href="#包引入"></a> 包引入</h5>
<p>如果一个类访问了另一个包的类，那么一定要引入这个类（就像c++中的库引入一样）。</p>
<p>语法： import 包名.类名</p>
<p>如果想引入一个包中所有类， 可以 import 包名.*</p>
<p>要注意最好使用第一种语法，因为第二种不仅耗时大并且还可能带来类名重复的问题，这个时候每写一个类都要写它的包名。</p>
<p>并且如果包中还有包的话，第二种语法是不会把内层包的类引入的。之所以可以包中有包是为了保证层次结构。例如前面提到的com.abc其实就是包中有包，com是外层，abc是内层。</p>
<p>package语句必须在import前</p>
<h4 id="方法函数声明"><a class="markdownIt-Anchor" href="#方法函数声明"></a> 方法（函数）声明</h4>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">返回值 函数名（参数）</span></span><br><span class="line"><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    主体</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里的函数和c++大致相同</p>
<h4 id="main方法"><a class="markdownIt-Anchor" href="#main方法"></a> main方法</h4>
<p>main方法和c++不一样了，要包含几个要素</p>
<ul>
<li>访问限制 public</li>
<li>静态方法 static</li>
<li>参数 main(String args[])</li>
<li>返回类型 void</li>
</ul>
<p>所以合起来就是 static public void main（String args[])</p>
<h5 id="给main传递参数"><a class="markdownIt-Anchor" href="#给main传递参数"></a> 给main传递参数</h5>
<p>格式： java classname [args…]</p>
<p>classname指的是类名</p>
<p>例如： java com.abc.dollapp.main.MainApp parameter0 parameter1</p>
<p>也就是c++中的argc，argv</p>
<h4 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h4>
<p>第一种 //</p>
<p>第二种 <code>/*...*/</code></p>
<p>第三种 <code>/**...*/</code>，当这种注释出现在类的声明时，会作为javadoc的内容</p>
<h4 id="标识符和关键字"><a class="markdownIt-Anchor" href="#标识符和关键字"></a> 标识符和关键字</h4>
<p>关键字之后慢慢就会知道</p>
<p>标识符命名规则：</p>
<ul>
<li>首字母必须是字母，下划线（_)，符号￥或符号$。</li>
<li>除开首字母其他字符可以用数字</li>
<li>没有长度限制</li>
</ul>
<h3 id="用jdk管理java应用"><a class="markdownIt-Anchor" href="#用jdk管理java应用"></a> 用jdk管理java应用</h3>
<p>java常用目录（防止以后看到这些目录都不知道是干什么的）</p>
<table>
<thead>
<tr>
<th>src</th>
<th>存放源文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>classes</td>
<td>存放编译生成的java文件</td>
</tr>
<tr>
<td>lib</td>
<td>存放第三方java软件的JAR文件（不要问我这是什么）</td>
</tr>
<tr>
<td>doc</td>
<td>存放帮助文档</td>
</tr>
<tr>
<td>doc\api</td>
<td>存放javadoc文档</td>
</tr>
<tr>
<td>deploy</td>
<td>存放打包文件，jar文件</td>
</tr>
</tbody>
</table>
<h3 id="使用javadoc文档"><a class="markdownIt-Anchor" href="#使用javadoc文档"></a> 使用javadoc文档</h3>
<p>java中有一个程序，可以识别类中的注释并将其转化成html文件。只有满足规范的文件才可以转化。</p>
<p>首先的规范就是注释要<code>/**...*/</code>才可以。里面可以有普通文件，html标记和javadoc标记。</p>
<p>范围：javadoc命令只处理类声明，接口声明，成员方法声明，成员变量声明，以及构造方法<strong>之前</strong>声明的注释。也就是说要在函数或类等的外面去声明。</p>
<h4 id="javadoc标记"><a class="markdownIt-Anchor" href="#javadoc标记"></a> javadoc标记</h4>
<table>
<thead>
<tr>
<th>标记</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@version</td>
<td>版本</td>
</tr>
<tr>
<td>@since</td>
<td>指定最早出现在哪个版本</td>
</tr>
<tr>
<td>@author</td>
<td>作者</td>
</tr>
<tr>
<td>@see</td>
<td>生成参考其他javadoc的链接</td>
</tr>
<tr>
<td>@link</td>
<td>生成链接，但是还可以添加其他的话</td>
</tr>
<tr>
<td>@deprecated</td>
<td>表示某些类或方法不提倡使用，之后可能会被废弃</td>
</tr>
<tr>
<td>@param</td>
<td>描述方法参数</td>
</tr>
<tr>
<td>@return</td>
<td>返回值</td>
</tr>
<tr>
<td>@throws</td>
<td>描述方法抛出的异常，指出抛出异常的条件</td>
</tr>
</tbody>
</table>
<p>@see用于生成到其他文档的链接。例如<code>@see #setWord</code>生成到setWord的链接。一共有三种格式</p>
<ul>
<li>set com.abc.dollapp.doll 生成到其他类的javadoc文档</li>
<li>set #setWord 生成当前类不同方法的javadoc文档</li>
<li>set com.abc.dollapp.doll#speak 生成到其他类的某一个方法的javadoc文档</li>
</ul>
<p>至于link在语法上与set大致相同，但是他可以用大括号插入到某一句话中，例如</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 如果&#123;<span class="variable">@link</span> <span class="comment">#word word成员变量&#125;不为NULL；</span></span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure>
<p>输出： 如果word<u>成员变量</u>不为NULL；</p>
<p>javadoc命令用法：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">-<span class="keyword">public</span> 仅为<span class="keyword">public</span>级别的类建立文档</span><br><span class="line">-<span class="keyword">protected</span> 进位<span class="keyword">public</span>和<span class="keyword">protected</span>建立文档 默认选项</span><br><span class="line">-<span class="keyword">package</span></span><br><span class="line">-<span class="keyword">private</span></span><br><span class="line">-<span class="keyword">version</span> 解析<span class="keyword">version</span>标记，默认情况会忽略</span><br><span class="line">-author </span><br><span class="line">-sourcepath&lt;path&gt; 指定源文件路径</span><br><span class="line">-classpath</span><br><span class="line">-d &lt;directory&gt; 指定javadoc的输出目录</span><br></pre></td></tr></table></figure>
<p>语法： javadoc [options] [packagenames] [sourcefiles]</p>
<h3 id="java虚拟机运行java的基本原理"><a class="markdownIt-Anchor" href="#java虚拟机运行java的基本原理"></a> java虚拟机运行java的基本原理</h3>
<p>过程：先进行编译，之后进入虚拟机中变成机器指令。具体过程就不解释了，但是这里有一步就是根据操作系统进行运行。而java程序使运行在虚拟机上的。所以编译出来的文件可以在任何平台上运行。</p>
<p>系统会先给虚拟机分配一个空间。虚拟机又会把这个空间分成若干个部分。主要包括堆区，栈区，方法区等等。堆中存放对象，方法区中存放类的类型信息，方法信息和静态变量等等。</p>
<p>运行程序时，先要把程序的二进制加载到内存，然后对程序进行验证（包括初始化），之后再执行。</p>
<p>当生成一个实例时，虚拟机会先搜索方法区，如果方法区没有，那么就会先加载这个类。之后在堆区分配一片内存用来存放实例，实例有一个指向方法区的指针。这个实例用一个局部指针指向它（也就是实例名，和数组很像，不是说java不提供指针吗）。</p>
<p>所以运行一个java方法的过程是：先由类名到堆区，然后堆指向方法区的指针把对应的方法取出来（机器指令）。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">命名空间实际上就是在函数前的一些附加消息。因为可能同时引入了多个库，库文件中可能某些函数名字相同，这个时候只有通过前面添加一些信息来辨别。典型例子就是using namespace std;这个含义就是使用标准命名空间。不然就要写std::cout来进行辨别。
2. 有助于访问权限的控制。但不同包之间进行访问时，就会受到访问权限的控制。
3. 有助于组织划分各个类。<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
  </entry>
  <entry>
    <title>java 集合，列表，队列，映射</title>
    <url>/post/d5381517.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1>
<ul>
<li>Set（集），集合中对象不以特定方式排序（有的实现类可以），没有重复元素</li>
<li>List(列表），按照索引排序，可以有重复对象。List和数组类似。</li>
<li>Queue（队列），先进先出</li>
<li>Map（映射）： 有键值对。没有重复键对象，可以有重复值对象</li>
</ul>
<p>定义：</p>
<p><code>Set&lt;String&gt; set = new HashSet&lt;String&gt;();</code></p>
<h2 id="collection-和-interator接口"><a class="markdownIt-Anchor" href="#collection-和-interator接口"></a> Collection 和 Interator接口</h2>
<p>Collection声明了上面这些数据结构（不包含map）通用的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(Object o)</td>
<td>加入对象</td>
</tr>
<tr>
<td>void clear()</td>
<td>删除所有对象</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断集合中是否有特定对象</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td></td>
</tr>
<tr>
<td>Iterator iterator()</td>
<td>返回一个Iterator对象（<a href="https://xinhecuican.github.io/post/37318.html">迭代器</a>）</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td></td>
</tr>
<tr>
<td>int size()</td>
<td>返回数目</td>
</tr>
<tr>
<td>Object[] toArray()<T>T[]toArray(T[] a)</td>
<td>返回一个数组，包含集合中所有元素</td>
</tr>
</tbody>
</table>
<p>Set接口，List接口，Queue接口都继承了Collection接口。</p>
<p>Inerator接口定义了如下方法：</p>
<ul>
<li>hasNext()：判断集合中的元素是否遍历完毕，如果没有返回true</li>
<li>next(): 返回下一个元素。例如iter.next()是让iter这个迭代器进一位</li>
<li>remove(): 删除由next()返回的元素</li>
</ul>
<p>如果先用iterator()得到一个Iterator对象后，又用Collection的其他方法，再用next()可能会抛出ConcurrentModifcationException异常。</p>
<p>例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Set</span>&lt;<span class="type">Integer</span>&gt; a = <span class="built_in">new</span> HashSet&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    a.<span class="keyword">add</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;<span class="type">Integer</span>&gt; iter = a.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(iter.next());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加基本类型数据"><a class="markdownIt-Anchor" href="#添加基本类型数据"></a> 添加基本类型数据</h2>
<p>实际上集合中只能存放对象。但是经常可以看到list.add(2)之类的操作。实际上在添加的时候已经隐式转换成Integer对象了。</p>
<h1 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h1>
<p>set本身是不排序的。但是它的实现类TreeSet具有排序功能。</p>
<h2 id="一般用法"><a class="markdownIt-Anchor" href="#一般用法"></a> 一般用法</h2>
<p>当添加一个新的元素时，首先要检查这个对象是否已经存在于集合中。如果存在就不添加。例如：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> Set&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">String</span> s1 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">String</span> s2 = s1;</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(s1);</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(s2);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">set</span>.<span class="built_in">size</span>());</span><br><span class="line">结果放回<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="hashset-类"><a class="markdownIt-Anchor" href="#hashset-类"></a> HashSet 类</h2>
<p>HashSet使用哈希算法存放集合中对象。具有良好的查找和存取性能。</p>
<p>前面说过在Object类中有hashCode()方法返回哈希值，而这个有使用hash算法存储的，所以判断两个对象是否相等还可以<code>customer1.hashCode() == customer2.hashCode();</code></p>
<p>如果一个类覆盖了equals()方法，那么就应该实现hashCode()方法，保证党两个对象相等时，hashcode相同。</p>
<h2 id="treeset类"><a class="markdownIt-Anchor" href="#treeset类"></a> TreeSet类</h2>
<p>TreeSet类实现了SortedSet接口，可以对集合中对象排序。TreeSet支持两种排序方法：自然排序和客户化排序。默认使用自然排序。</p>
<p><strong>自然排序</strong></p>
<p>TreeSet实现了Comparable接口的compareTo(Object o)方法比较集合中对象大小。如果返回值大于0，代表这个值大于o。<strong>只有实现了Comparable接口的对象才可以使用TreeSet进行排序</strong>。compareTo方法最好要从小到大进行排序，以便和其他的进行匹配。</p>
<p>下面列举了一些实现了Comparable接口的类</p>
<table>
<thead>
<tr>
<th>类</th>
<th>排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>BigDecimal BigInteger Byte Double Float Integer Long Short</td>
<td>按数字大小</td>
</tr>
<tr>
<td>Character</td>
<td>按字符 Unicode值</td>
</tr>
<tr>
<td>String</td>
<td>按字符串中Unicode值</td>
</tr>
</tbody>
</table>
<p>如果是自己定义的类，首先要实现Comparable接口。并且最好也是通过返回值大于零小于零来判断谁大谁小的。</p>
<p>注意，如果把一个对象加入TreeSet并且修改它的属性TreeSet是不会重新排序的。所以适合排序的是不可变类。</p>
<p><strong>客户化排序</strong></p>
<p>客户化排序可以降序排序。首先实现java.util.Comparator<T>接口。Comparator有个compare(T x, T y)方法用于比较两个对象的大小，如果返回值大于0，表示x&gt;y。</p>
<p>如果想实现降序排序，例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerComparator</span> <span class="title">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Customer</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> int compare(Customer c1, Customer c2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c1,getName().compareTo(c2.getName())&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c1.getName().compareTo(c2.getName())&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span> args[])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Set</span>&lt;Customer&gt; set = <span class="keyword">new</span> TreeSet&lt;Customer&gt;(<span class="keyword">new</span> CustomerComparator());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Set有个构造方法 Set(Comparator comparaotr)可以使用Comparator来确定升序还是降序。</p>
<h1 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h1>
<p>list的实现类有：</p>
<ul>
<li>ArrayList： ArrayList代表长度可变数组。ArrayList实现了RandomAccess接口，这个接口不包含任何方法，仅仅表示有良好的随机访问性能。</li>
<li>LinkedList： 链式结构。LinkedList不仅仅可以做数组，还可以做堆栈，队列，双向队列。</li>
</ul>
<h2 id="访问元素和排序"><a class="markdownIt-Anchor" href="#访问元素和排序"></a> 访问元素和排序</h2>
<p>list中get(int index)方法可以返回集合中索引位置的数。List中的iterator()和Set中的iterator()一样，也可以用来遍历。</p>
<p>此外，还可以用foreach来遍历</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">for</span>(Integer <span class="attribute">i</span>: list)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.print</span>(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于排序，只能对集合中的对象按索引进行排序，如果想用其他方式，可以实现collections类和Comparator接口。Collections类中的sort方法可以用来排序</p>
<ul>
<li>sort(List list) 对List对象进行自然排序</li>
<li>sort(List list, Comparator comparator)进行客户化排序</li>
</ul>
<h2 id="listiterator-接口"><a class="markdownIt-Anchor" href="#listiterator-接口"></a> ListIterator 接口</h2>
<p>List中listIterator()返回一个ListIterator对象，这个对象继承了Iterator接口，此外还有一些独有的方法</p>
<ul>
<li>add() 向列表中插入一个元素</li>
<li>hasNext() 判断列表中是否还有下一个元素</li>
<li>hasPrevious(): 判断列表中是否还有上一个元素</li>
<li>next(): 返回下一个元素</li>
<li>previous(): 返回上一个元素</li>
</ul>
<p>![](/images/java 集合，列表，队列，映射.jpg)</p>
<h1 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h1>
<p>Queue提供了add()和offer()两种方法来从队尾加元素，如果是add队满就会抛出IllegalStateException，如果是offer()会返回false。</p>
<p>删除也有两种，一种是remove()，一种是poll()。如果是remove，队空后会跑出NoSuchElementException，如果是poll，空了会返回null</p>
<p>获取元素，一种是element(),一种是peek().如果不成功（队空），那么会出现和删除队空同样的情况。</p>
<h2 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> Deque</h2>
<p>Deque是一个接口</p>
<p>从头或尾添加元素</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">addFirst</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="function"><span class="title">addLast</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">offerFirst</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">offerLast</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果队满，都会抛出IlllegalStateException.后两种方法返回false</p>
<p>删除</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">E</span> <span class="function"><span class="title">removeFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">removeLast</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">pollFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">pollLast</span>()</span></span><br></pre></td></tr></table></figure>
<p>和前面队空判断一样</p>
<p>获取</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">E</span> <span class="function"><span class="title">getFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">getLast</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">peekFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">peekLast</span>()</span></span><br></pre></td></tr></table></figure>
<p>就是把上面的queue加了个first和last</p>
<p>LinkedList和ArrayList都实现了Deque接口，</p>
<h2 id="priorityqueue-优先队列"><a class="markdownIt-Anchor" href="#priorityqueue-优先队列"></a> PriorityQueue 优先队列</h2>
<p>优先队列使用堆进行排序。并且因为要排序，所以想用优先队列要首先实现Comparable接口。</p>
<p>这里的remove总会首先删除最小的元素。</p>
<h1 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h1>
<p>定义： Map&lt;type1, type2&gt; map = new HashMap&lt;type1, type2&gt;();</p>
<p>其中type1是键类型，type2是值类型。</p>
<p>Map叫映射，就是给出键返回值。可以使用get(Object key)得到值。通过put(Object key, Object value)插入键值对。</p>
<p>Map的键不允许有重复，但是值可以有重复。</p>
<p>Map有两种常用实现，HashMap和TreeMap，HashMap用哈希算法来存取键对象，有良好的取性能。为了保证能正常工作，也要确保通过equals()比较为true时，两个对象返回哈希码相同。</p>
<p>TreeMap实现了SortedMap接口，可以对键进行排序。如果想进行客户化排序，可以调用TreeMap(Comparator comparator)构造函数。</p>
<p>Map的keySet()返回所有键对象的集合。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">Integer</span>, <span class="built_in">Integer</span>&gt; <span class="built_in">map</span> = <span class="literal">new</span> HashMap&lt;<span class="built_in">Integer</span>, <span class="built_in">Integer</span>&gt;();</span><br><span class="line">        for(int i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">Integer</span>, <span class="built_in">Integer</span>&gt;&gt; <span class="built_in">set</span> = <span class="built_in">map</span>.entrySet();<span class="comment">//注意</span></span><br><span class="line">        Iterator&lt;<span class="built_in">Map</span>.Entry&lt;<span class="built_in">Integer</span>, <span class="built_in">Integer</span>&gt;&gt; iter = <span class="built_in">set</span>.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>=<span class="number">0</span></span><br><span class="line"><span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>=<span class="number">2</span></span><br><span class="line"><span class="number">3</span>=<span class="number">3</span></span><br><span class="line"><span class="number">4</span>=<span class="number">4</span></span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">6</span>=<span class="number">6</span></span><br><span class="line"><span class="number">7</span>=<span class="number">7</span></span><br><span class="line"><span class="number">8</span>=<span class="number">8</span></span><br><span class="line"><span class="number">9</span>=<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>set内的类型是Map.Entry,可以使用getKey()返回键，使用getValue()返回值。</p>
<h1 id="collections"><a class="markdownIt-Anchor" href="#collections"></a> Collections</h1>
<p>适用于List的方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">copy</span><span class="params">(List dest, List src)</span></span>: 把一个list复制到另一个list中</span><br><span class="line"><span class="function"><span class="title">fill</span><span class="params">(List list,Object o)</span></span> 想列表中填充元素</span><br><span class="line"><span class="function"><span class="title">sort</span><span class="params">(List list)</span></span> 排序</span><br><span class="line"><span class="function"><span class="title">binarySearch</span><span class="params">(List list, Object key)</span></span> 如果有序就可以用这个</span><br><span class="line"><span class="function"><span class="title">shuffle</span><span class="params">(List list)</span></span>: 对List中元素随机排列</span><br></pre></td></tr></table></figure>
<p>适用于Map或Collection的：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> max(Collection coll):返回集合中最大的元素</span><br><span class="line"><span class="built_in">Object</span> max(Collection coll, Comparator comp):采用指定规则进行比较，返回最大元素</span><br><span class="line"><span class="built_in">Object</span> min(Collection coll)</span><br><span class="line"><span class="built_in">Object</span> min(Collection coll, Comparator comp)</span><br><span class="line"><span class="built_in">Set</span> singleton(<span class="built_in">Object</span> o): 返回一个不可变的<span class="built_in">Set</span></span><br><span class="line">List singletonList(<span class="built_in">Object</span> o) 返回不可改变的List</span><br><span class="line"><span class="built_in">Map</span> singletonMap（<span class="built_in">Object</span> key, <span class="built_in">Object</span> value):</span><br><span class="line">Collection synchronizedCollection(Collection c): 在原来的基础上，返回支持同步的集合</span><br><span class="line"><span class="built_in">Map</span> synchronizedMap(<span class="built_in">Map</span> m)</span><br><span class="line"><span class="built_in">Set</span> ...</span><br><span class="line">List ...</span><br><span class="line">Collection unmodifiableCollection(Collection c): 在原来结合的基础上，返回不可改变的集合视图</span><br><span class="line">其他三个相同</span><br></pre></td></tr></table></figure>
<p>前面的singleton是指这个集合中只有一个元素，并且不允许修改</p>
<p>而后面的unmodifiable是返回这个集合，但是如果原集合修改，这个集合也会跟着修改。不允许修改指的是不允许修改这个集合视图</p>
<p><strong>线程安全的集合</strong></p>
<p>在平常情况下集合的实现类都没有同步锁机制，这样可以加快速度。但是当有多个线程同时操作一个锁的时候就需要同步机制了。一种方式就是在可能导致问题的代码块用synchronized，另一种就是上面讲的方法。</p>
<h1 id="集合批量操作"><a class="markdownIt-Anchor" href="#集合批量操作"></a> 集合批量操作</h1>
<p>前面说的都是一次处理一个元素，如果要处理多个元素，可以采用Collection中的方法：</p>
<ul>
<li>boolean retainAll(Collection&lt;?&gt; c)修改集合，保留在c中的元素并删去其他元素</li>
<li>boolean removeAll(Collection&lt;?&gt; c)删去集合中c的元素。</li>
<li>boolean addAll(Collection&lt;? extends E&gt; c): 把c中元素加入到当前集合中</li>
<li>boolean containsAll(Collection&lt;?&gt; c): 判断当前集合是否全部包含c</li>
</ul>
<h1 id="其他集合类"><a class="markdownIt-Anchor" href="#其他集合类"></a> 其他集合类</h1>
<p>Properties是一种特殊的Map类。他可以用load()从输入流中读取键和值。例如；</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Properties ps = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span><br><span class="line">InputStream <span class="keyword">in</span> = <span class="module-access"><span class="module"><span class="identifier">PropertiesTester</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ResourceAsStream(<span class="string">&quot;myapp.properties&quot;</span>)</span>;</span><br><span class="line">ps.load(<span class="keyword">in</span>);</span><br><span class="line"><span class="keyword">in</span>.close<span class="literal">()</span>;</span><br><span class="line">print(ps);</span><br><span class="line">ps=<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Properties()</span>;</span><br><span class="line">print(ps);</span><br></pre></td></tr></table></figure>
<p>可以使用System.getProperties()返回一个Propertiese对象。这个对象中包含一系列系统属性。</p>
<p>BitSet表示一组boolean数据集合。类似于boolean[]数组。最小初始容量是64位，可以通过BitSet(int bits)设置初始容量。如果达到了初始容量会自动增加。</p>
<p>BitSet中有以下方法：</p>
<ul>
<li>set(int index) 把index位置的元素设置成true</li>
<li>clear(int index) 把index位置的元素设false</li>
<li>get(int index): 获得index位置的元素值</li>
<li>and(BitSet bs): 与bs进行与运算，结果保存在当前BitSet中</li>
<li>or(Bitset bs)</li>
<li>xor(BitSet bs)</li>
</ul>
<p>BitSet在c++中是返回二进制信息，在这里也可以有这个作用。可以自己建立byteToBitSet()计算出byte类型的二进制位，其他类型类似。printBitSet()打印BitSet二进制信息。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte </span>a = <span class="number">125</span>;</span><br><span class="line"><span class="keyword">short </span><span class="keyword">b </span>= -<span class="number">125</span>;</span><br><span class="line">int c = -<span class="number">125</span>;</span><br><span class="line">long d = <span class="number">125</span>;</span><br><span class="line">printBitSet(<span class="keyword">byteToBitSet(a), </span><span class="keyword">BYTE_SIZE);</span></span><br><span class="line"><span class="keyword">printBitSet(shortToBitSet(b), </span><span class="keyword">SHORT_SIZE);</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure>
<h1 id="枚举类型"><a class="markdownIt-Anchor" href="#枚举类型"></a> 枚举类型</h1>
<p>位置： java.lang.Enum。这个类是抽象类</p>
<p>此外，还提供了关键字enum。例如 public enum Gender{FEMALE, MALE}</p>
<p>Enum类有如下非抽象方法（一般直接使用enum就可以了，也有这些)：</p>
<ul>
<li>intcompareTo(E o) 比较当前常量与指定对象的顺序</li>
<li>Class<E> getDeclaringClass()返回当前类型的class对象</li>
<li>String name() 返回当前枚举常量的名称。例如调用Gender.FEMALE的name()方法，会返回FEMALE</li>
<li>intordinal() 返回当前枚举常量在声明时的位置</li>
<li>toString() 返回枚举常量的名称</li>
<li><code>static&lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)</code>返回制定枚举类型和名称返回的枚举常量</li>
<li>static Enum[] values() 以数组的方式返回所有的枚举常量</li>
<li>range(from， to)用来迭代</li>
</ul>
<p>range用法例如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(WeekDayEnum day : <span class="module-access"><span class="module"><span class="identifier">EnumSet</span>.</span></span>range(WeekDayEnum.Mon, WeekDayEnum.Fri)) &#123; </span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(day); </span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line">Mon </span><br><span class="line">Tue </span><br><span class="line">Wed </span><br><span class="line">Thu </span><br><span class="line">Fri</span><br></pre></td></tr></table></figure>
<p>枚举类型最大的作用就是可以用于switch，相当于扩充了switch的范围。</p>
<h2 id="枚举类型构造方法"><a class="markdownIt-Anchor" href="#枚举类型构造方法"></a> 枚举类型构造方法</h2>
<p>这个构造方法时private，或friendly类型的，例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Gender</span><br><span class="line">&#123;</span><br><span class="line">    MALE(<span class="string">&quot;男性&quot;</span>),</span><br><span class="line">    FEMALE(<span class="string">&quot;女性&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> description;</span><br><span class="line">    <span class="keyword">private</span> Gender(<span class="built_in">String</span> description)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> getDescription()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Gender g = Gender.valueOf(<span class="string">&quot;FEMALE&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (g)<span class="comment">//必须要是实例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.println(g.getDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.println(g.getDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意前面定义时的符号，如果是基础类型，那么最后一个不用跟任何符号，如果不是，那么最后一个必须要封号。并且前面只能是逗号</p>
<p>enum是构造对象时产生的，因此看起来相同的两个类型实际上比较时也可能不相同。</p>
<h2 id="enumset和enummap"><a class="markdownIt-Anchor" href="#enumset和enummap"></a> EnumSet和EnumMap</h2>
<p>前面一个把枚举转化成集合，它的静态allOf()方法把枚举类所有常量实例存放到一个EnumSet类型的集合中，然后放回这个集合。</p>
<p>EnumMap转换成映射，它的EnumMap(Class<K> keyType)来指定具体的枚举类型。枚举常量以key的方式存到Map中。例如：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">EnumSet&lt;WeekDayEnum&gt; <span class="built_in">subset</span> = EnumSet.of(WeekDayEnum.Mon, WeekDayEnum.Wed); </span><br><span class="line">     <span class="keyword">for</span> (WeekDayEnum <span class="built_in">day</span> : <span class="built_in">subset</span>) &#123; </span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="built_in">day</span>);  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>jmp进行跳转</title>
    <url>/post/2647.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="根据位移进行的转移"><a class="markdownIt-Anchor" href="#根据位移进行的转移"></a> 根据位移进行的转移</h3>
<p>用jmp进行跳转时，会发现一个奇怪的问题，无论它要跳转到哪里，它的机器码始终不变，为EB03，那么它到底是怎么告诉cpu修改ip地址的呢？</p>
<p>先回忆一下cpu读取指令的过程</p>
<ol>
<li>cs=076a ip=0006，cs：ip指向eb03</li>
<li>读取指令码eb03到指令缓冲器</li>
<li>ip=ip+指令长度=0008h，cs：ip指向下一条指令</li>
<li>cpu执行指令缓冲器中的指令eb03</li>
<li>执行完缓冲器中的指令后，ip被修改+</li>
</ol>
<p>jmp指令并不需要转移的目的地址，但是它是凭借什么转移的呢？这里有个03，正好跳过三个字节之后就是要转移的地址。原来jmp指令只需知道当前指令的下一个指令（因为执行完这条指令后ip会增加）与要跳转的指令的位移就可以了</p>
<p>jmp short 标号 功能是 ip=ip+8位位移（一字节）</p>
<p>jmp near ptr 标号 是16位</p>
<p>jmp far ptr 标号 是段间转移，可以修改cs</p>
<p>还可以直接 jmp 寄存器1：寄存器2</p>
<h3 id="根据内存进行的转移"><a class="markdownIt-Anchor" href="#根据内存进行的转移"></a> 根据内存进行的转移</h3>
<p>转移地址再内存中的转移有两种格式</p>
<ol>
<li>jmp word  ptr（段内转移）</li>
</ol>
<p>例 jmp word ptr ds：[0]</p>
<p>jmp word ptr [bx]</p>
<p>2.jmp dword ptr (段间转移）后面接两个字，第一个是偏移地址，第二个是段地址</p>
<p>例 jmp dword ptr ds：[0],0 完成后段地址为0</p>
<p>注意</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">nop</span></span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,offset s</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,offset s2</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cs</span>:[<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="symbol">   s0:</span> <span class="keyword">jmp</span> short s</span><br><span class="line"><span class="symbol">   s1:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">       <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">   s2:</span> <span class="keyword">jmp</span> short s1</span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>这个程序奇怪之处在于运行到mov cs：[di],ax后 s处会变为jmp 0000，这里就要记住jmp传递的是偏移地址，也就是说，jmp short s1这个指令并不是真的跳到s1处，而是往前跳8个字节</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>memset</title>
    <url>/post/46466.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>memset(标识符，填充数据,大小)</p>
<p>memset是一个字节一个字节填充的，所以一般只能填充0或-1因为这个一个字节和四个字节相同</p>
]]></content>
  </entry>
  <entry>
    <title>linux指令学习</title>
    <url>/post/26477.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h5 id="命令语法"><a class="markdownIt-Anchor" href="#命令语法"></a> 命令语法</h5>
<p>一次输入多条命令，可以在命令之间用 <code>;</code>分割开来</p>
<p>语法： 命令名称 选项 参数</p>
<p><strong>选项</strong>有时被称为开关（switches）或标志（flags），选项通常是由一个连字符后面接着一些字母，或者两个连字符后接着一个单词构成。例如 --help，–version（显示版本信息）</p>
<p>使用多个单字符选项时，可以把他们连接在一起，用一个连字符来表示。例如 ls -lF<br />
。注意，unix的选项区分大小写</p>
<p>实际上许多长参数有着对应的短参数，但是长参数是一个完整的单词，为了便于记忆，有时也是用长参数，这时就要用两个连字符</p>
<p>输入命令时，必须要把每个选项和参数用空格分隔开</p>
<p>有些命令有默认值，有些命令没有默认值，例如 ls 如果只输入ls的话他会返回当前工作目录下所有文件</p>
<p>手册中提示的语法</p>
<ol>
<li>方括号中的项是可选的</li>
<li>不再方括号中的项是必选项</li>
<li>黑体字必须原样输入</li>
<li>斜体字可以用适当的值代替</li>
<li>有省略号代表可以重复多次</li>
<li>如果一个单独的选项和参数组合在一起，这二者必须同时出现</li>
<li>由竖线（|）字符分开的两个或者多个项，宝石可以从这个列表中选择任意一项</li>
</ol>
<h5 id="用户提醒命令"><a class="markdownIt-Anchor" href="#用户提醒命令"></a> 用户提醒命令</h5>
<ul>
<li>who 用来显示用这个计算机的用户</li>
<li>whoami 用来显示当前用户标识</li>
<li>quota 用来看自己拥有多少空间</li>
<li>lock 临时上锁 lock -5 锁5分钟</li>
<li>leave leave +15 十五分钟后离开 leave 1344 13点44分离开，到了时间它会不停的提醒你，相当于一个闹钟</li>
<li>id 用来显示你的基本信息</li>
<li>date 时间 date -u 协调世界时间（UTC时间）</li>
<li>cal 显示日历 cal+某一年份可以显示某一年份的日历 cal 7 2019 显示2019年7月的日历 cal -j +… 会显示第几天，所以想要知道这一年是不是闰年只需 cal -j 12 + 年份，看看12月最后一天是不是366天就可以了</li>
<li>su（substitute user） 这个指令是用来切换用户的，如果你知道一个用户的口令，那么就可以采用su+用户名的方式切换，这个时候用户标识改变了，但是你仍位于旧的环境之中。就像你让别人来你家做事，如果你想让别人在自己家做事，就要用su+’-’+用户名</li>
</ul>
<p>特别的，如果你想拥有root权限，你需要 su - root ，这时你输入的是你自己的口令而不是root口令，因为在计算机中有特殊的配置文件，这个文件只有管理员能操作，他可以修改那些人可以通过su口令获得root权限</p>
<ul>
<li>man 联机文档帮助 当你查看联机文档时，可以用/符加上你想搜索的内容进行搜索，用n来显示下一个，用N来显示上一个。？符是向下搜索。<br />
如果想在查看man文档时执行指令，只需输入！在输入命令，之后按enter键又能回到man文档中</li>
<li>foo bar 可以指代任意标识<br />
man文档显示的内容</li>
</ul>
<ol>
<li>命令</li>
<li>系统调用</li>
<li>库函数</li>
<li>特殊文件</li>
<li>文件格式</li>
<li>游戏</li>
<li>杂项</li>
<li>系统管理</li>
</ol>
<ul>
<li>whatis 显示说明书页的第一行（名字和用途）例如 whatis time date，这样同时显示两条指令的信息。这种指令可以用 man -f 替换</li>
<li>apropos 搜索命令 他将显示所有带有该字符的命令。这种命令可以用man -k代替</li>
<li>info 另一种搜索命令，这种命令的特点是它有到其他命令的连接，就好像网页一样。这时一种树形结构，n跳转到下一个节点，p跳转到上一个节点，t跳转到当前文件的顶节点</li>
</ul>
<h5 id="登入登出命令"><a class="markdownIt-Anchor" href="#登入登出命令"></a> 登入登出命令</h5>
<ul>
<li>exit 退出当前用户，例如想从root模式退出用exit</li>
<li>sudo 以超级用户模式运行一条指令。如果你经常使用超级用户，可能在无意间删去一些重要文件导致系统出现故障，因此超级用户需慎用。因此要用可以用sudo命令。</li>
<li>less 浏览配置文件。例如我想浏览passwd文件，只需 less /etc/passwd</li>
</ul>
<p>配置文件就像windows系统下的注册表和ini文件</p>
<ul>
<li>dmesg 显示启动信息，但是这种显示太快，看不清</li>
<li>dmesg | less 显示启动信息</li>
<li>init 设置运行级别，1为单用户，2为多用户，等等，0是关机，6是重启</li>
</ul>
<p>如果想重启，可以用 sudo init 6</p>
<ul>
<li>reboot 重启 sudo reboot</li>
<li>shutdown 关机，这个要说关机时间，经常用的是sudo shutdown now</li>
</ul>
<h5 id="快捷键和便捷输入命令"><a class="markdownIt-Anchor" href="#快捷键和便捷输入命令"></a> 快捷键和便捷输入命令</h5>
<ul>
<li>erase 删除最好一个键入的字符，Ctrl+H</li>
<li>werase 删除最后一个单词 Ctrl+W</li>
<li>kill 删除一行 Ctrl+U</li>
<li>intr 停止程序 有些系统是Ctrl+C，有些是delete</li>
<li>quit 停止程序 Ctrl+\ 它不仅会停止程序，还会生成一个副本保存在core的文件中</li>
<li>stop 停止屏幕显示，Ctrl+S</li>
<li>start 开始屏幕显示 Ctrl+Q</li>
<li>eof 文件终止信号 Ctrl+D<br />
可以通过Ctrl+D终止shell，但是有时候会不小心按到。为了让shell忽略eof，需要使用一个叫IGNOREEOF的环境变量，这个变量表示注销前BASH会忽略多少次eof，设置这个变量时，要 IGNOREEOF = 数字</li>
<li>stty -a 显示键盘映射，这个命令是表示各个快捷方式如erase的快捷键。stty是set terminal(设置终端）-a表示显示所有设置</li>
<li>stty 修改键映射。例如想修改kill命令 ，可以 stty kill Ctrl a</li>
<li>返回字符 ^M，指的是返回到这一行的开头</li>
<li>换行字符 ^J<br />
文件每一行最后一定是一个返回加换行</li>
<li>stty sane，reset 候终端的设置被弄乱，可以采用这个命令是终端恢复到初始值</li>
<li>up 向上键，会转到上一条指令</li>
<li>down 转到下一条指令</li>
<li>fc 查看历史命令列表，用fc -l来查看，前面都有一个编号。如果想转到某一条指令，可以 fc -s(substitute) 编号。如果后面不接编号，则默认为上一条指令。但是用fc -s会立刻执行这条指令</li>
</ul>
<p>可以对这条命令进行小范围修改，格式为 fc -s pattern=replacement number<br />
。pattern和replacement 都是字符串，而number是要修改时间的编号</p>
<ul>
<li>tab 自动补全命令，按一下如果有歧义，会发出提示声</li>
</ul>
<h5 id="立即使用的程序"><a class="markdownIt-Anchor" href="#立即使用的程序"></a> 立即使用的程序</h5>
<ul>
<li>gedit 文本编辑器，相当于windows下的记事本</li>
<li>which 看某个命令会使用那些程序，如果显示地址，则说明有这些程序，如果没有输出，或者输出错误信息，则说明这个命令无法使用</li>
<li>quit 终止程序命令，但是也可以输入eof使程序终止</li>
<li>bc 计算器 如果想用bc内部的函数，要用bc -l命令（library)。如果是多个算式，中间要用&quot;;&quot;号隔开</li>
</ul>
<p>常用函数</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">s</span><span class="params">(x)</span></span> sinx  弧度制</span><br><span class="line"><span class="function"><span class="title">c</span><span class="params">(x)</span></span> cosx</span><br><span class="line"><span class="function"><span class="title">a</span><span class="params">(x)</span></span> arctanx</span><br><span class="line"><span class="function"><span class="title">ln</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">j</span><span class="params">(n,x)</span></span>  x的n次整阶贝塞尔函数</span><br></pre></td></tr></table></figure>
<p>如果想用小数运算，先要设置标度因子 scale 来确定精确到小数点后多少位。如果输入scale 则会返回scale的当前值 scale=3，则设置小数点后三位</p>
<p>有一点需要注意，当你用来 bc -l时，scale会自动设置为20</p>
<p>bc实际上是一套功能完整的数学编程语言，可以使用的变量有26个字母<br />
例如 x=100 就是将x变量设为100</p>
<h5 id="变量显示命令"><a class="markdownIt-Anchor" href="#变量显示命令"></a> 变量显示命令</h5>
<p>环境变量实际上就是全局变量，用env显示环境变量，如果想让输出按字母表排序，可以用 env | sort | less</p>
<ul>
<li>
<p>set 显示shell变量</p>
</li>
<li>
<p>echo 显示赋予它对象的值，例如 echo I 将会输出I</p>
</li>
</ul>
<p>如果要显示一个变量的值，可以用$(美元符号），后面的变量最好加花括号（{}）</p>
<p>例如 echo ${TERM}</p>
<p>实际上，很多标点符号都有特殊的用途，为了能正确显示他们，要在最外面用双引号</p>
<ul>
<li>
<p>变量创建只需要一边写变量名，另一边写值即可。例如，HARLEY=cool，如果希望变量中有空格，则需使用双引号</p>
</li>
<li>
<p>export 将变量导出环境中（即变成全局变量）。还可以在创建同时导出。用 export 变量名=值即可</p>
</li>
<li>
<p>unset 删除变量。实际上没有办法简单的从环境中移除变量，因此最简单的办法是直接删除它。</p>
</li>
<li>
<p>set 显示shell所有选项的当前值，如果用 -o 则会简要的显示 +o是详细的显示。例如，set -o ignoreeof 这样在按 Ctrl+D的时候就不会突出shell了，如果想复位，只要+o</p>
</li>
<li>
<p>alias 建立别名，语法为alias name=command 例如 <code>alias It='-l temp*'</code>。这种时候，单引号就比双引号要好，因为这样可以防止一些特殊字符被转义。此外，可以通过alias name 知道这个别名的当前值。可以只输入alias得知所有别名，通过unalias删去别名。如果想暂时不用别名，可以在命令之前输入&quot; \ &quot;</p>
</li>
</ul>
<h5 id="文件显示指令"><a class="markdownIt-Anchor" href="#文件显示指令"></a> 文件显示指令</h5>
<ul>
<li>less，这条指令是让大量的数据分成一页一页进行查看，如果不使用这个程序。那么输出时会直接到这些数据的末尾。less在正常情况下是区分大小写的，如果想不区分，可以使用I选项。此外，less命令内部还有许多搜索，翻页等指令，这些指令可以通过help去查看。</li>
</ul>
<p>less还有一个特殊的功能，就是直接跳转到某一页。less +5g …代表跳转到第5页，less +/buffer …是从第一个buffer处开始。</p>
<h6 id="显示十六进制文件"><a class="markdownIt-Anchor" href="#显示十六进制文件"></a> 显示十六进制文件</h6>
<p>显示二进制文件的命令是 hexdump（显示十六进制文件），od（显示八进制文件），</p>
<p>hexdump -C file。将自动选取适合的选项组合进行输出。</p>
<p>-s 偏移一定字节数开始输出。</p>
<p>-n 显示多少字节输出</p>
<p>strings: 显示二进制文件中的字符串</p>
<h5 id="条件执行指令"><a class="markdownIt-Anchor" href="#条件执行指令"></a> 条件执行指令</h5>
<p>command1 &amp;&amp; command2</p>
<p>在条件1满足的情况下执行command2</p>
<p>command1|| command2</p>
<p>在条件1不满足的情况下也执行command2</p>
<h5 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h5>
<p>regular expression 通常简写成regex或re，是一种指定字符串模式的输出方式。</p>
<p>例如： harley1 harley2 harley3 ，作为正则表达式，可以用harley[123]表达这组模式。</p>
<p>从这里我们可以了解到，正则表达式就像把许多字符串化为一个表达式。</p>
<p>下面介绍一些常用的正则表达式</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>除新行字符外，匹配任意的单个字符</td>
</tr>
<tr>
<td>^</td>
<td>锚，匹配行的开头</td>
</tr>
<tr>
<td>$</td>
<td>锚，匹配行的末尾</td>
</tr>
<tr>
<td>\ &lt;</td>
<td>锚，匹配单词的开头</td>
</tr>
<tr>
<td>\ &gt;</td>
<td>锚，匹配单词的末尾</td>
</tr>
<tr>
<td>[list]</td>
<td>字符类，匹配list中的任意字符</td>
</tr>
<tr>
<td><code>[ ^ list]</code></td>
<td>子父类，匹配不再list中的任意字符</td>
</tr>
<tr>
<td>()</td>
<td>组，视为一个单独的单元</td>
</tr>
<tr>
<td>竖线</td>
<td>匹配选择之一</td>
</tr>
<tr>
<td>\</td>
<td>引用： 从字面上解释元字符</td>
</tr>
<tr>
<td><strong>注意</strong></td>
<td><strong>下面是判定匹配次数的字符</strong></td>
</tr>
<tr>
<td>*</td>
<td>匹配0次或者多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配一次或者多次</td>
</tr>
<tr>
<td>？</td>
<td>匹配0次或1次，如果是多个字符，则代表最小匹配。例如 &lt;.*?&gt;,这是用来匹配html标签的，如果同时匹配到多个，则选取匹配数目最少的</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配n次</td>
</tr>
<tr>
<td>{0，m}</td>
<td>最多匹配m次</td>
</tr>
<tr>
<td>{n,}</td>
<td>最少匹配n次</td>
</tr>
<tr>
<td>{，m}</td>
<td>最多匹配m次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>最少n次，最多m次</td>
</tr>
<tr>
<td><strong>注意</strong></td>
<td><strong>预定义字符类</strong></td>
</tr>
<tr>
<td>[:lower:]</td>
<td>小写字母</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>大写字母</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>大小写字母</td>
</tr>
<tr>
<td>[:alnum:]</td>
<td>大小写字母，数字</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>数字</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点符号</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>制表符或者空格</td>
</tr>
</tbody>
</table>
<h6 id="基本和扩展正则表达式"><a class="markdownIt-Anchor" href="#基本和扩展正则表达式"></a> 基本和扩展正则表达式</h6>
<h6 id="匹配行和单词"><a class="markdownIt-Anchor" href="#匹配行和单词"></a> 匹配行和单词</h6>
<p>有些元字符具有定位的作用，这些字符叫做<strong>锚</strong>。例如，harley$仍是匹配字符串harley，但是这个时候只匹配行末尾的字符了。</p>
<p>如果我们要找以harley开头的行，可以</p>
<p>grep ‘^harley’ data</p>
<p>注意，当我们使用含有元字符的表达式时，为了不干扰，最好加上单引号</p>
<p>通过使用 ^$ ，我们可以很方便的查找空行。这个的意思就是既找行首又找行尾，只有空行才满足这个条件。</p>
<p>例如： grep ‘^$’ data | wc -l</p>
<p>如果我们要找 某个字符位于开头的，可以用 &lt;</p>
<p>例如： grep ‘&lt;kn’ data，这个就是找kn为于单词开头的单词。或者grep ‘kn&gt;’ data</p>
<p>在linux系统中，可以采用\b代替&lt;和&gt;，\b相当于边界标记。此外，要尊重客观规律，不能把开头标记和结尾标记都写在开头。</p>
<p>如果想匹配所有包含字母 H ，后面加a或者A的，可以用 grep ‘H[aA]’ data</p>
<p>如果想表示一个范围，可以用 [a-b]，例如 [3-6] 或 [a-z]，这应该是按ascii码来的</p>
<p>grep ‘[^A-Z,a-z]’ data可以用来搜索所有不包含字母的行</p>
<h6 id="重复使用运算符"><a class="markdownIt-Anchor" href="#重复使用运算符"></a> 重复使用运算符</h6>
<p>例如，如果我想找首字母是大写H，后面接了0个或者多个字母的行，可以使用</p>
<p>grep ‘H[[:alpha:]]*’ data</p>
<p>如果想搜索一个或者多个，可以用+号，</p>
<p>例如： grep ‘variable[0-9]+’ data</p>
<p>到现在，我们一直使用单个字符作为查找对象，如果想用多个字符作为查找对象，就需要用到组（小括号）</p>
<p>例如： (xyz){5},这条命令就是查找重复出现xyz五次的字符串</p>
<p>如果我们想搜索多个单词，可以用 | 分隔开来。</p>
<p>例如： grep '(cat | dog | bird) ’ data</p>
<p>如果我们想搜索有特殊含义的元字符，可以用(转义字符）把这些字符的含义变成常规字符，如果我们想搜索 \ 本身，那么可以用两个 \</p>
<p>例如： grep ‘$’ data</p>
<h6 id="字典文件"><a class="markdownIt-Anchor" href="#字典文件"></a> 字典文件</h6>
<p>字典顾名思义，就是许多经常用的单词放到一起，每个单词一行，并且按照字母表顺序排列。一般储存在 /usr/share/dict/words中。</p>
<p>利用这个文件，我们就可以很方便的查找单词。例如，那些单词以qu开头并且以y结尾呢？</p>
<p>grep ‘^qu[a-z]+y$’ /usr/share/dict/words</p>
<h5 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h5>
<table>
<thead>
<tr>
<th>变量名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>PATH</td>
<td>设置shell搜索路径</td>
</tr>
<tr>
<td>PS1</td>
<td>设置标识符</td>
</tr>
<tr>
<td>SHELL</td>
<td>shell路径</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>fc中最大保存的指令数</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux目录操作</title>
    <url>/post/61312.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="目录名和工作目录"><a class="markdownIt-Anchor" href="#目录名和工作目录"></a> 目录名和工作目录</h3>
<p>斜杠表示根目录，如果最后一个名称代表的是文件名。当然，这个文件名也可以是一个目录。</p>
<p>工作目录又叫当前目录，也是进行操作的根目录（但不是系统的根目录），如果命令后面直接输入一个文件名，那么就是代表这个目录在工作目录中，系统也只会在当前目录中搜寻。</p>
<h3 id="绝对目录和相对目录"><a class="markdownIt-Anchor" href="#绝对目录和相对目录"></a> 绝对目录和相对目录</h3>
<p>绝对目录就是从根目录开始。在Linux系统中，根目录是home（这个根目录是当前用户的根目录）目录。</p>
<p>相对目录就是从工作目录（当前目录）开始。大多数时候我们输入一个文件名其实都是输入相对目录，我们也可以输入绝对目录，但那样过于麻烦。</p>
<h3 id="路径名缩写"><a class="markdownIt-Anchor" href="#路径名缩写"></a> 路径名缩写</h3>
<p><strong>第一个</strong>： …（两个点号）。这个符号的含义是父目录，也就是上级目录。用…可以回到上级目录然后在进入子目录</p>
<p>例：现在绝对目录是 /home/abcd/ceshi，如果我想进入abcd的gongzuoqu目录，那么输入cd …/gongzuoqu即可。这是从左向右读的， …代表进入父目录，然后再进入父目录中的工作区目录。</p>
<p><strong>第二个</strong>： .(一个点号）。代表的是当前目录，注意<strong>任何不以/开头的路径名都被认为相对于工作目录</strong>。所以大部分情况下直接输入文件名即可，但是在某些情况下必须输入完整的目录，因此这个时候就需要.代表当前目录便于输入。</p>
<p>unix只能运行它能找到的程序，也就是在path环境变量中的路径。但是如果我们输入绝对路径的话，程序也能运行，因此这里我们就可以简单的用 . 来代替长长的绝对路径名。</p>
<p>如果我们想运行new程序，而这个程序不在搜索路径中，那么可以用 ./new来运行它</p>
<p>一个点号和两个点号都是缩写，所以其实我们运用点号时都是输入<strong>绝对路径名</strong></p>
<p><strong>第三个</strong> ~(波浪号）。 用这个符号代表home目录（这里的home是系统的根，也就是没有目录包含它）。</p>
<p><strong>第四个</strong> -. 到上一次操作的目录。</p>
<h3 id="cd-pwd-在目录树中移动"><a class="markdownIt-Anchor" href="#cd-pwd-在目录树中移动"></a> cd pwd 在目录树中移动</h3>
<p>pwd命令是显示当前的绝对目录</p>
<p>cd 命令</p>
<p>语法： cd [-LP] [directory | - ]</p>
<p>其中dircetory是你想切换到的目录的名称。</p>
<p>如果只输入cd，那么会进入home目录下。如果输入cd -， 那么将会进入前一个目录，与cd …命令效果相同。</p>
<p>如果使用绝对路径名，那么第一个符号是/。</p>
<p>例如 cd /home/abcd/gongzuoqu</p>
<p>如果使用相对路径名，那么第一个就没有/</p>
<p>例如 cd gongzuoqu/temp</p>
<h3 id="mkdir-rmdir新建目录和移除目录"><a class="markdownIt-Anchor" href="#mkdir-rmdir新建目录和移除目录"></a> mkdir rmdir新建目录和移除目录</h3>
<p>语法： mkdir [-P] dictory…</p>
<p>首先，可以使用字母，数字和没有特殊含义的标点符号作为文件名。</p>
<p>创建目录要遵循两条规则。第一条，不能在一个目录下创建两个同名的目录。第二条，默认情况下，如果父目录不存在，那么就无法创建目录。可以使用-p选项忽略第二条规则。</p>
<p>语法： redir [-p] directory …</p>
<p>这里要注意只能移除空的目录。如果想要移除非空的目录，可以使用rm程序</p>
<p>如果想一次性移除一串目录，那么可以使用-p选项。但是有一个不是空的就不行（除了在这条链上的目录外）</p>
<p>其次，不能移除根目录和工作目录之间的任何程序。也就是说就算是使用了绝对地址，如果它在工作目录外部，那么也无法移除它。</p>
<h3 id="mv-移动或重命名目录"><a class="markdownIt-Anchor" href="#mv-移动或重命名目录"></a> mv 移动或重命名目录</h3>
<p>语法： mv directory target</p>
<p>target如果是一个路径，那么一定是移动目录，如果是名字，那么要看情况。</p>
<p>例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/home/</span>harley/data</span><br><span class="line"><span class="regexp">/home/</span>harley/storge</span><br><span class="line"></span><br><span class="line">mv data storage</span><br><span class="line"></span><br><span class="line">现在的位置： <span class="regexp">/home/</span>harley<span class="regexp">/storge/</span>data</span><br></pre></td></tr></table></figure>
<p>也就是说，如果该路径下没有这个名字的目录，那么就会重命名，但是如果有这个名字的目录，那么就会移动到这个目录下。</p>
<h3 id="pushdpopddirs-使用目录栈"><a class="markdownIt-Anchor" href="#pushdpopddirs-使用目录栈"></a> pushd,popd,dirs 使用目录栈</h3>
<p>语法： pushd [directory | +n]</p>
<p>pop [+n]</p>
<p>dirs [-c] [-l] [-v]</p>
<p>push是将目录的名称压入栈中，pop是弹出栈中，dirs是显示栈的内容，n是标识符</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>dirs</td>
<td>显示名称，home显示为~</td>
</tr>
<tr>
<td>dirs -l</td>
<td>home显示为完整路径</td>
</tr>
<tr>
<td>dirs -v</td>
<td>每行一个显示名称，并有标识符</td>
</tr>
<tr>
<td>pushd directory</td>
<td>将其压入栈中</td>
</tr>
<tr>
<td>push +n</td>
<td>把n移到栈顶</td>
</tr>
<tr>
<td>popd +n</td>
<td>把n移除</td>
</tr>
<tr>
<td>dirs -c</td>
<td>除当前目录外，移除所有目录</td>
</tr>
</tbody>
</table>
<p>在任何时候，栈顶都是存放当前工作目录的名称。每当改变工作目录时，栈顶元素也会随之改变。</p>
<p>如果我们使用了pushd命令，这时我们也会进入这个目录，同时只能进入自己的下级目录。</p>
<h3 id="ls"><a class="markdownIt-Anchor" href="#ls"></a> ls</h3>
<p>语法： ls [aCdFglrRs1] [name…]</p>
<p>作用，列举该目录下的文件名称。</p>
<p>参数：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-C 横的列举文件</span></span><br><span class="line"><span class="deletion">-1 竖的列举文件 可以与wc -l组成管道</span></span><br><span class="line"><span class="deletion">-r 按字母表相反顺序进行排序。</span></span><br><span class="line"><span class="deletion">-R 递归。也就是列举完这一层继续列举下一层。如果这个很长的话，可以用less程序</span></span><br><span class="line"><span class="deletion">-F 检查文件类型，会增加几种标识，如下表所示</span></span><br><span class="line"><span class="deletion">--color 使用不同颜色来显示不同类型文件</span></span><br><span class="line"><span class="deletion">-l 显示长列表</span></span><br><span class="line"><span class="deletion">-u 显示访问时间</span></span><br><span class="line"><span class="deletion">-r reverse 从旧的到新的</span></span><br><span class="line"><span class="deletion">-h 自动显示大小</span></span><br><span class="line"><span class="deletion">-d 显示目录本身的信息。</span></span><br><span class="line"><span class="deletion">-a 显示隐藏文件</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>空</td>
<td>非可执行文件</td>
</tr>
<tr>
<td>*</td>
<td>可执行文件</td>
</tr>
<tr>
<td>/</td>
<td>目录</td>
</tr>
<tr>
<td>@</td>
<td>符号链接</td>
</tr>
<tr>
<td>竖线</td>
<td>命名管道 /FIFO</td>
</tr>
</tbody>
</table>
<h4 id="-hs-du-df-quota-掌握磁盘空间使用情况"><a class="markdownIt-Anchor" href="#-hs-du-df-quota-掌握磁盘空间使用情况"></a> -hs du -df -quota 掌握磁盘空间使用情况</h4>
<p>-s 前面以字节为单位输出文件的大小</p>
<p>-sh 自动选择合适的单位</p>
<p>du（disk usage) 显示文件的大小，这是一个程序</p>
<p>语法： du [-achs] [name…]</p>
<p>-h 显示单位</p>
<p>如果不指定名称，du会递归搜索整个目录树</p>
<p>-s 显示总和</p>
<p>-c 是先输出每个文件的大小，最后输出总量</p>
<p>df 显示磁盘可用空间</p>
<p>quota 显示配额</p>
<h3 id="file-检查文件类型"><a class="markdownIt-Anchor" href="#file-检查文件类型"></a> file 检查文件类型</h3>
<p>file的使用相当直接，只需要file + 路径就可以检查那个路径下的文件类型，但是比ls显示的更为详细。</p>
<p>可能显示下列几种类型：</p>
<ul>
<li>ELF:可执行和链接模式</li>
<li>32-bit： 字长</li>
<li>LSB： 采用最低有效字节编译（小端序）</li>
<li>executable： 可执行文件</li>
<li>Intel 80386： 内部文件格式版本</li>
<li>GNU/linux2.6.9 操作系统和内核版本</li>
<li>dynamically linked 使用共享库</li>
<li>stripped 将符号表移除的可执行文件</li>
</ul>
<h3 id="块和分配单元"><a class="markdownIt-Anchor" href="#块和分配单元"></a> 块和分配单元</h3>
<p>在文件系统中，空间以固定大小进行分配，我们把固定大小的组块叫做块。块的大小在不同系统中不同。块的大小有512,1,2,4kb等。典型的linux系统是1kb。</p>
<p>此时我们只是说在文件系统中的分配方式。但是写入到磁盘中时出于效率的考虑，磁盘中也有特定的单元叫做分配单元或者簇。例如，分配单元为8kb代表即使只有1btye的数据系统也会自动分配8kb</p>
<h3 id="使用通配符进行通配"><a class="markdownIt-Anchor" href="#使用通配符进行通配"></a> 使用通配符进行通配</h3>
<p>使用通配符可以指定特定的文件名，类似于正则表达式。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任何0个或多个字符组成的序列</td>
</tr>
<tr>
<td>？</td>
<td>匹配任何单个字符</td>
</tr>
<tr>
<td>[list]</td>
<td>匹配list中任意字符</td>
</tr>
<tr>
<td>[^list]</td>
<td>匹配不再list中任意字符</td>
</tr>
<tr>
<td>{string1竖线string2}</td>
<td>匹配任意一个字符串</td>
</tr>
</tbody>
</table>
<p>其实就是一个简化版的正则表达式。例如： ls h*表示显示所有以h为开头的文件或目录</p>
<p>此外，还可以使用一些预定义字符类，例如[[:lower:]]等</p>
<h3 id="显示目录树"><a class="markdownIt-Anchor" href="#显示目录树"></a> 显示目录树</h3>
<p>语法： tree [-adfFilrst] [-L level] [directory…]</p>
<p>level是树的深度</p>
<p>作用：绘制文件系统中任意部分的图形（真的就是一个目录图表，可以自己试一下）。</p>
<p>选项：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-a 显示所有文件，包括点文件</span></span><br><span class="line"><span class="deletion">-s 显示文件大小</span></span><br><span class="line"><span class="deletion">-F 显示标识文件的标志</span></span><br><span class="line"><span class="deletion">-r 以相反顺序输出</span></span><br><span class="line"><span class="deletion">-t 按修改时间顺序输出</span></span><br><span class="line"><span class="deletion">-d 只显示目录</span></span><br><span class="line"><span class="deletion">-i 省略缩进，这种模式只会输出一条条路径，但是不会生成一个图标</span></span><br><span class="line"><span class="deletion">-L 限制树的深度。后面的数字就是树的深度</span></span><br></pre></td></tr></table></figure>
<p>个人意见可以重定向到一个文件中然后再文件中查找。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>next主题出现404的一个解决方法</title>
    <url>/post/7119.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在<code>主题配置文件中</code></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">home:</span> /|| home</span><br><span class="line"></span><br><span class="line"><span class="symbol">about:</span> <span class="meta-keyword">/about/</span>|| user</span><br><span class="line"></span><br><span class="line"><span class="symbol">tags:</span> <span class="meta-keyword">/tags/</span>|| tags</span><br><span class="line"></span><br><span class="line"><span class="symbol">categories:</span> <span class="meta-keyword">/categories/</span>|| th</span><br><span class="line"></span><br><span class="line"><span class="symbol">archives:</span> <span class="meta-keyword">/archives/</span>|| archive</span><br><span class="line"></span><br><span class="line"><span class="meta">#schedule: /schedule/|| calendar</span></span><br><span class="line"><span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">#commonweal: /404/|| heartbeat</span></span><br></pre></td></tr></table></figure>
  <p>注意/||，原来是/ ||，不要中间那个空格，亲测有效]]></content>
      <categories>
        <category>next</category>
      </categories>
  </entry>
  <entry>
    <title>mul指令</title>
    <url>/post/40583.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>两个相乘的数：</p>
<p>如果是8位，那么一个默认在al中，另一个在8位寄存器或内存字节单元中，如果是16位，一个在ax中，另一个在16位寄存器或内存字单元中</p>
<p>结果： 如果是8位，结果默认在ax中，如果是16位，高位默认在dx中，低位在ax中</p>
]]></content>
  </entry>
  <entry>
    <title>numpy</title>
    <url>/post/fa288682.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>numpy用于矩阵计算，内置了大量矩阵计算的函数，并且速度也比列表快</p>
<p><strong>创建</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy as np</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"><span class="string">    [2, 3]</span>,</span><br><span class="line"><span class="string">    [5, 8]</span>]</span><br><span class="line">c = np.<span class="built_in">array</span>(a)</span><br><span class="line">d = np.<span class="built_in">array</span>(b, <span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<p>通过array就把列表转化成了numpy的矩阵</p>
<ul>
<li>ones(shape, dtype): 这个是创建值全为1的矩阵，shape是矩阵的行和列数，dtype是矩阵数据类型。</li>
<li>zeros(shape, dtype): 创建全是零的矩阵</li>
<li>full(shape, constant_value, dtype): 创建指定数值的矩阵。其中constant_value是用来填充矩阵的值</li>
<li>eye(N): 创建单位矩阵，N是矩阵的维度</li>
<li>diag(v, k): 创建对角矩阵。v如果是一维则是创建对角矩阵，如果是二维是获取对角线上的元素。k=0表示获取主对角线上元素，k&gt;0则获取主对角线上方第k条对角线元素</li>
</ul>
<p><strong>创建随机数组</strong></p>
<ul>
<li>np.random.rand(shape): 创建一个值在0到1的随机数组。例如np.random.rand(10, 10, 3)是创建一个三维数组</li>
<li>uniform(low, high, shape): 创建一个值在low到high的随机数组</li>
<li>randint(low, high, shape): 创建一个值在low到high并且值是整数的随机数组</li>
<li>normal(loc, scale, shape): 给定均值，方差，维度的正态分布。</li>
</ul>
<p><strong>查看矩阵属性</strong></p>
<ul>
<li>size(): 获得矩阵元素个数</li>
<li>shape(): 获得矩阵的行和列，shape[0]是行，shape[1]是列.但是如果是一维数组那么shape[0]表示列数，没有shape[1]</li>
<li>ndim:  维数</li>
<li>dtype： 元素类型</li>
<li>T: 返回这个矩阵的转置</li>
</ul>
<p><strong>操作</strong></p>
<ul>
<li>np.copy(array): 复制矩阵</li>
<li>sort(a, axis): axis = 0是每行进行排序，1是每列进行排序，默认是对整个数组进行排序。a是用来排序的矩阵。如果是np.sort()那么原矩阵不改变。如果是array.sort()，原矩阵改变。</li>
<li>unique(a, return_index, retrun_inverse, return_counts, axis): 查找array中唯一元素。return_index是返回新列表中元素在旧列表出现第一个位置。return_counts是每个元素在原来矩阵中数量。return_inverse是返回一个索引数组，索引的是新列表元素位置。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="selector-tag">b</span> = np.diag(a)</span><br><span class="line">alpha, beta = np.unique(<span class="selector-tag">b</span>, return_counts=True)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(alpha)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(beta)</span></span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">20</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">a = [1, 2, 3, 4, 5]</span><br><span class="line">b = np.diag(a)</span><br><span class="line">alpha, beta = np.unique(b, return_inverse=True)</span><br><span class="line">print(alpha)</span><br><span class="line">print(beta)</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">[0<span class="number"> 1 </span>2<span class="number"> 3 </span>4 5]</span><br><span class="line">[1<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>2<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>3<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>4<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>5]</span><br></pre></td></tr></table></figure>
<ul>
<li>array.reshape(shape): 改变形状，但是元素个数不变，如果改变形状后元素数目和原来不同会报错。原数组改变</li>
<li>array.resize(shape): 改变形状,元素个数可变，不足补零。如果小于原来数目会输出None，采取逐个填充的方法。</li>
</ul>
<p><strong>计算</strong></p>
<ul>
<li><code>+</code>： 矩阵加法，让矩阵中每个元素都相加。例如a+5是矩阵中每个元素都加五。a+b是矩阵中对应元素相加</li>
<li><code>*</code>： 注意矩阵乘法是dot函数，这个是对应元素相乘</li>
<li>==: 矩阵中逐个元素进行比对，然后返回一个bool型矩阵，如果两个矩阵对应位置相同那么bool型矩阵对应位置就是True。</li>
<li>dot(): 矩阵相乘</li>
<li>delete(a, elements, axis): 矩阵删除行或列。elements是删除的行或列的序号</li>
<li>append()</li>
<li>insert()</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>pair</title>
    <url>/post/27621.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>pair实际上是一个结构体，它可以把两种类型结合起来使用,定义在<code>&lt;utility&gt;</code>中</p>
<p>定义：pair&lt;类型A,类型B&gt; 标识符</p>
<p>操作 pa.first 表示类型A pa.second 表示类型B</p>
<p>注意不能用-> 操作符，虽然我也不知道为什么
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>ret 和 retf</title>
    <url>/post/29378.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="ret"><a class="markdownIt-Anchor" href="#ret"></a> ret</h3>
<p>ret指令用栈中的数据，修改ip中的内容，从而实现近转移</p>
<p>过程：</p>
<ol>
<li>
<p>ip=ss*16+sp</p>
</li>
<li>
<p>sp+=2</p>
</li>
</ol>
<p>相当于 pop ip</p>
<h3 id="retf"><a class="markdownIt-Anchor" href="#retf"></a> retf</h3>
<p>修改cs和ip 的内容，实现远转移<br />
过程</p>
<ol>
<li>ip=ss*16+sp</li>
<li>sp+=2</li>
<li>cs=ss*16+sp</li>
<li>sp+=2</li>
</ol>
<p>相当于 pop ip ，pop cs</p>
<p>例</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ss</span>:stack</span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>这条指令相当于把ip变为0，指向第一条指令</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>prioity_queue</title>
    <url>/post/54612.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="prioity_queue"><a class="markdownIt-Anchor" href="#prioity_queue"></a> prioity_queue</h3>
<p>实际上是一个大顶堆，定义在<code>&lt;queue&gt;</code>中</p>
<p><code>prioity_queue&lt;int&gt; qu</code>为大顶堆</p>
<p><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qu;</code>为小顶堆</p>
<p>.push()</p>
<p>.pop()取出元素，但不返回值</p>
<p>.top()不取出元素，返回值</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>scanf printf</title>
    <url>/post/46925.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="scanf"><a class="markdownIt-Anchor" href="#scanf"></a> scanf</h3>
<p>格式：scanf(const char *format, …)</p>
<p>format – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。</p>
<p>format 说明符形式为:</p>
<p>[=%[*][width][modifiers]type=]</p>
<p><code>*</code>这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。</p>
<p>width	这指定了在当前读取操作中读取的最大字符数。</p>
<p>modifiers	为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）</p>
<p>type	一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%a、%A</td>
<td>读入一个浮点值(仅 C99 有效)</td>
<td>float*</td>
</tr>
<tr>
<td>%c</td>
<td>单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td>
<td>char *</td>
</tr>
<tr>
<td>%d</td>
<td>十进制整数：数字前面的 + 或 - 号是可选的。</td>
<td>int *</td>
</tr>
<tr>
<td>%e、%E、%f、%F、%g、%G</td>
<td>浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4</td>
<td>float *</td>
</tr>
<tr>
<td>%i</td>
<td>读入十进制，八进制，十六进制整数 。</td>
<td>int *</td>
</tr>
<tr>
<td>%o</td>
<td>八进制整数。</td>
<td>int *</td>
</tr>
<tr>
<td>%s</td>
<td>字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td>
<td>char *</td>
</tr>
<tr>
<td>%u</td>
<td>无符号的十进制整数。</td>
<td>unsigned int *</td>
</tr>
</tbody>
</table>
<h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4>
<p>scanf读入数据时碰到空白符（空白符：指空格符、制表符、回车符）就会停止函数，例如 你输入 1\n ，这个时候scanf只会读入1，\n留在了缓冲区，但是这样会导致十分严重的问题，所以scanf还有一个特性，<strong>忽略在数据之前的空白符</strong>，而这样当你读取完之后，缓冲区中一般还有一个空白符，如果这个时候你用了&quot;%c&quot;，那么%c会毫不犹豫的把这个空白字符读入，%c是读入一个字符，无论这个字符是什么。%s就会忽略前面的空白符</p>
<p>这里有一个相对有用的方法 scanf（”%d\n&quot;,…)这样就会在读入一个整数的同时把后面的\n也读入，但是如果不是换行符而是空格那就熟手无策了。</p>
<p>另外还有一种函数gets()，这个函数除了换行符其它一概不管，并且他会把换行符吃掉（变成NULL）</p>
<h3 id="printf"><a class="markdownIt-Anchor" href="#printf"></a> printf</h3>
<p>格式 printf(&quot;&lt;格式化字符串&gt;&quot;, &lt;参量表&gt;);</p>
<p>声明 printf(const char *format, …)</p>
<p>format中有这几种：%[标志][最小宽度][.精度][类型长度]类型</p>
<h5 id=""><a class="markdownIt-Anchor" href="#"></a> %</h5>
<table>
<thead>
<tr>
<th>格式字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>以十进制形式输出带符号整数(正数不输出符号)</td>
</tr>
<tr>
<td>o</td>
<td>以八进制形式输出无符号整数(不输出前缀0)</td>
</tr>
<tr>
<td>x,X</td>
<td>以十六进制形式输出无符号整数(不输出前缀Ox)</td>
</tr>
<tr>
<td>u</td>
<td>以十进制形式输出无符号整数</td>
</tr>
<tr>
<td>f</td>
<td>以小数形式输出单、双精度实数</td>
</tr>
<tr>
<td>e,E</td>
<td>以指数形式输出单、双精度实数</td>
</tr>
<tr>
<td>g,G</td>
<td>以%f或%e中较短的输出宽度输出单、双精度实数</td>
</tr>
<tr>
<td>c</td>
<td>输出单个字符</td>
</tr>
<tr>
<td>s</td>
<td>输出字符串</td>
</tr>
<tr>
<td>p</td>
<td>输出指针地址</td>
</tr>
<tr>
<td>lu</td>
<td>32位无符号整数</td>
</tr>
<tr>
<td>llu</td>
<td>64位无符号整数</td>
</tr>
</tbody>
</table>
<h5 id="标志"><a class="markdownIt-Anchor" href="#标志"></a> 标志</h5>
<table>
<thead>
<tr>
<th>字符</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>减号</td>
<td>结果左对齐，右边填空格。默认是右对齐，左边填空格。</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
<td>输出符号(正号或负号)</td>
</tr>
<tr>
<td>space</td>
<td>空格</td>
<td>输出值为正时加上空格，为负时加上负号</td>
</tr>
<tr>
<td>#</td>
<td>井号</td>
<td>type是o、x、X时，增加前缀0、0x、0X。type是a、A、e、E、f、g、G时，一定使用小数点。默认的，如果使用.0控制不输出小数部分，则不输出小数点。type是g、G时，尾部的0保留。</td>
</tr>
<tr>
<td>0</td>
<td>数字零</td>
<td>将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用“-”）</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">printf</span>(<span class="string">&quot;%5d\n&quot;</span>,<span class="number">1000</span>); 				//默认右对齐,左边补空格</span><br><span class="line"><span class="attribute">printf</span>(<span class="string">&quot;%-5d\n&quot;</span>,<span class="number">1000</span>); 				//左对齐,右边补空格</span><br><span class="line"></span><br><span class="line"><span class="attribute">printf</span>(<span class="string">&quot;%+d %+d\n&quot;</span>,<span class="number">1000</span>,-<span class="number">1000</span>);		//输出正负号</span><br><span class="line"></span><br><span class="line"><span class="attribute">printf</span>(<span class="string">&quot;% d % d\n&quot;</span>,<span class="number">1000</span>,-<span class="number">1000</span>);		//正号用空格替代，负号输出</span><br><span class="line"></span><br><span class="line"><span class="attribute">printf</span>(<span class="string">&quot;%x %#x\n&quot;</span>,<span class="number">1000</span>,<span class="number">1000</span>);		//输出<span class="number">0</span>x</span><br><span class="line"></span><br><span class="line"><span class="attribute">printf</span>(<span class="string">&quot;%.0f %#.0f\n&quot;</span>,<span class="number">1000</span>.<span class="number">0</span>,<span class="number">1000</span>.<span class="number">0</span>)//当小数点后不输出值时依然输出小数点</span><br><span class="line"></span><br><span class="line"><span class="attribute">printf</span>(<span class="string">&quot;%g %#g\n&quot;</span>,<span class="number">1000</span>.<span class="number">0</span>,<span class="number">1000</span>.<span class="number">0</span>);	//保留小数点后后的<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">printf</span>(<span class="string">&quot;%05d\n&quot;</span>,<span class="number">1000</span>);				//前面补<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="输出最小宽度"><a class="markdownIt-Anchor" href="#输出最小宽度"></a> 输出最小宽度</h3>
<p>这是指的小数点前的宽度，如果小于最小宽度，前面补空格，如果大于，那么直接输出。另外如果用了flag中的0，那么前面将会补零</p>
<table>
<thead>
<tr>
<th>width</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>数值</td>
<td>十进制整数</td>
<td>printf(&quot;%06d&quot;,1000);输出:001000</td>
</tr>
<tr>
<td>*</td>
<td>星号。不显示指明输出最小宽度，而是以星号代替，在printf的输出参数列表中给出</td>
<td>printf(&quot;%0*d&quot;,6,1000);输出:001000</td>
</tr>
</tbody>
</table>
<h3 id="精度"><a class="markdownIt-Anchor" href="#精度"></a> 精度</h3>
<p>精度以点<code>.</code>开头，后面再接</p>
<table>
<thead>
<tr>
<th>.precision</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.数值</td>
<td>十进制整数。(1)对于整型（d,i,o,u,x,X）,precision表示输出的最小的数字个数，不足补前导零，超过不截断。(2)对于浮点型（a, A, e, E, f ），precision表示小数点后数值位数，默认为六位，不足补后置0，超过则截断。(3)对于类型说明符g或G，表示可输出的最大有效数字。(4)对于字符串（s），precision表示最大可输出字符数，不足正常输出，超过则截断。precision不显示指定，则默认为0</td>
</tr>
<tr>
<td>.*</td>
<td>以星号代替数值，类似于width中的*，在输出参数列表中指定精度。</td>
</tr>
</tbody>
</table>
<p>对于整数型，这个作用与最小宽度作用类似，例如，&quot;%08d&quot; 与 &quot;%.8d&quot;作用是一样的</p>
<h3 id="类型长度"><a class="markdownIt-Anchor" href="#类型长度"></a> 类型长度</h3>
<p>printf(&quot;%hhd\n&quot;,‘A’);				//输出有符号char</p>
<p>printf(&quot;%hhu\n&quot;,‘A’+128);			//输出无符号char</p>
<p>printf(&quot;%hd\n&quot;,32767);				//输出有符号短整型short int</p>
<p>printf(&quot;%hu\n&quot;,65535);				//输出无符号短整型unsigned short int</p>
<p>printf(&quot;%ld\n&quot;,0x7fffffffffffffff);	//输出有符号长整型long int</p>
<p>printf(&quot;%lu\n&quot;,0xffffffffffffffff);	//输出有符号长整型unsigned long int</p>
<h3 id="缓冲"><a class="markdownIt-Anchor" href="#缓冲"></a> 缓冲</h3>
<p>用户在输入字符时，其实并不是直接显示到屏幕上，而是放在缓冲区中，在一些条件之下才会输出</p>
<p>printf在glibc中默认为行缓冲，在下列情况中会刷新缓冲区</p>
<ol>
<li>缓冲区填满</li>
<li>写入字符中有换行符（’\n’)或回车符（’\r’)</li>
<li>调用fflush手动刷新缓冲区</li>
<li>调用scanf读取数据时</li>
</ol>
<p>可使用setbuf(stdout,NULL)关闭行缓冲，或者setbuf(stdout,uBuff)设置新的缓冲区，uBuff为自己指定的缓冲区。也可以使用setvbuf(stdout,NULL,_IOFBF,0);来改变标准输出为全缓冲。全缓冲与行缓冲的区别在于遇到换行符不刷新缓冲区。</p>
<h3 id="注意-2"><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h3>
<p>在运用printf和scanf中，前面的format是一个字符串，所以可以作为参数传入</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putout</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(s,...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以用一个函数实现重复输出不同类型的进制数</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>qsort</title>
    <url>/post/5490.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>自带的快排函数</p>
<p>qsortvoid qsort(void *base, size_t nitems, size_t size, int (*compar)(const void <em>, const void</em>))</p>
<p>参数</p>
<p>base-- 指向要排序的数组的第一个元素的指针。<br />
nitems-- 由 base 指向的数组中元素的个数。<br />
size-- 数组中每个元素的大小，以字节为单位。<br />
compar-- 用来比较两个元素的函数，即函数指针（回调函数）</p>
<p>回调函数：</p>
<p>回调函数就是一个通过函数指针调用的函数。如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。 [2]<br />
compar参数<br />
compar参数指向一个比较两个元素的函数。比较函数的原型应该像下面这样。注意两个形参必须是const void *型，同时在调用compar 函数（compar实质为函数指针，这里称它所指向的函数也为compar）时，传入的实参也必须转换成const void *型。在compar函数内部会将const void *型转换成实际类型。<br />
int compar(const void *p1, const void *p2);</p>
<p>如果compar返回值小于0（&lt; 0），那么p1所指向元素会被排在p2所指向元素的左面；<br />
　　如果compar返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定；<br />
　　如果compar返回值大于0（&gt; 0），那么p1所指向元素会被排在p2所指向元素的右面。</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>set</title>
    <url>/post/44250.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="set之iterator"><a class="markdownIt-Anchor" href="#set之iterator"></a> set之iterator</h3>
<p>定义：set::iterator iter</p>
<p>运用：*iter</p>
<p>遍历 for(iter=set.begin();iter!=set.end();iter++)</p>
<p>还可以直接用auto it=set.begin() (auto是自动匹配类型)</p>
<p><strong>注意</strong><br />
iterator只能用++，–运算符。不能*（iter-1），另外还要注意iter++后自身会改变</p>
<p>例：set中有0,2,4，iter指向2，现在cout&lt;&lt;<em>iter&lt;&lt;&quot; &quot;&lt;&lt;</em>(iter–)&lt;&lt;endl;</p>
<p>输出0,2，先执行iter–，我也不知道为什么</p>
<h3 id="set之lower_bound"><a class="markdownIt-Anchor" href="#set之lower_bound"></a> set之lower_bound()</h3>
<p>lower_bound()返回从first开始的第一个大于或等于val的元素的地址。如果所有元素都小于val，则返回last的地址，所以必须要</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">int</span>&gt;::iterator <span class="built_in">iter</span>;</span><br><span class="line"><span class="built_in">iter</span>=st.lower_bound(一个数字)</span><br></pre></td></tr></table></figure>
<p>upper_bound()返回最后一个大于等于val的元素的地址</p>
<h3 id="set基础"><a class="markdownIt-Anchor" href="#set基础"></a> set基础</h3>
<p>定义：set&lt;数据类型&gt; 标识符 ，set中元素都唯一</p>
<p>set实际上运用了红黑树。另外，set中元素会自动排序</p>
<h4 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h4>
<p>begin()，返回的是开头元素迭代器</p>
<p>end()</p>
<p>clear()</p>
<p>empty()</p>
<p>size()</p>
<h4 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h4>
<p>count(数据)判断某个值是否在set中</p>
<ul>
<li>
<p>erase(iterator) 删去迭代器所指向的值</p>
</li>
<li>
<p>erase(iteratora,iteratorb)删去a，b之间的值</p>
</li>
<li>
<p>erase(数据)删去该数据</p>
</li>
<li>
<p>set删除是不会检查任何错误的，使用时小心</p>
</li>
</ul>
<p>find(数据)返回指定元素的迭代器，没有则返回最后一个元素的迭代器</p>
<p>当set中没有元素的时候，*s.end()=0</p>
<p>insert(某一个值),将一个值插入set中，<strong>注意</strong>这是唯一的将元素弄到set中的方法，并且重复插入无效</p>
<h6 id="判断insert插入是否成功的方法具体可看"><a class="markdownIt-Anchor" href="#判断insert插入是否成功的方法具体可看"></a> 判断insert插入是否成功的方法（<a href="https://blog.csdn.net/liyuqian199695/article/details/49100543">具体可看</a>)</h6>
<pre class="highlight"><code class="">//typedef pair&lt;iterator, bool&gt; _Pairib;
	pair&lt;set&lt;Student,FuncStudent&gt;::iterator,bool&gt; pair1=set1.insert(s1);
	if(pair1.second==true)
	&#123;
		cout&lt;&lt;&quot;插入s1成功&quot;&lt;&lt;endl;
	&#125;
	else
	&#123;
		cout&lt;&lt;&quot;插入s1失败&quot;&lt;&lt;endl;
	&#125;```</code></pre>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>shell内部命令与外部命令与搜索路径</title>
    <url>/post/18431.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>有些命令是shell外部的，shell会解析参数然后调用外部的程序去处理它，另外还有一些是对shell起作用的，叫shell内置命令</p>
<p>如果先查看内部命令，需要 man + shell名称 ，例如，man bash</p>
<h3 id="外部命令和搜索路径"><a class="markdownIt-Anchor" href="#外部命令和搜索路径"></a> 外部命令和搜索路径</h3>
<p>shell是如何知道那些程序都在哪呢？ 实际上shell是检查PATH环境变量，PATH包含一串字符，这串字符就是一系列目录名称，称作搜索路径。如果输入一个命令，shell会依次按这些目录去搜索命令</p>
<p>先要看PATH 直接 echo $PATH即可</p>
<h3 id="修改搜索路径"><a class="markdownIt-Anchor" href="#修改搜索路径"></a> 修改搜索路径</h3>
<p>可以用export命令，export命令可以使PATH变量变成环境变量，这就意味着shell和随后所有进程都可以使用它，例如<code>export PATH=&quot;/bin:/usr/bin:/usr/ucb:/usr/local/bin&quot;</code></p>
<p>如果希望在搜索路径的末尾加上一条路径，可以 <code>export PATH=&quot;$PATH:$HOME/bin&quot;</code><br />
如果想在最后加上一条指令，可以<code>export PATH=&quot;$HOME/bin:$PATH&quot;</code></p>
<p>如果把自己写的date命令放在开头，系统将会执行自己写的date命令，而不会执行系统本身的命令</p>
<p>实际上用export设置的环境变量在下次启动时就会失效，如果想一直保存需要修改一些特定的文件</p>
<h3 id="修改命令行提示"><a class="markdownIt-Anchor" href="#修改命令行提示"></a> 修改命令行提示</h3>
<p>命令行提示的路径在PS1的环境变量当中,因此要修改的话只需要export PS1=”$ &quot;就可以了</p>
<h3 id="命令替换"><a class="markdownIt-Anchor" href="#命令替换"></a> 命令替换</h3>
<p>用反引号`,用了这种符号会先执行反引号你饿不的命令然后再执行外部命令，</p>
<p>例如 echo &quot;Date is `date` &quot;</p>
<p>这个命令会显示Date is + 具体时间，注意要用双引号，单引号会把反引号引用掉</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>si和di</title>
    <url>/post/38145.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>si和di在8086cpu中的功能与bx类似，si与di不能分为两个8位寄存器来使用</p>
<p>也就是说  ds：[si]是可以的</p>
<p>如果不用这些寄存器直接写的话就会出现之前所说的编译器和exe对程序的不同处理</p>
<p>例   mov ax,[si]在exe中就是 ds：[si]，但是如果是 mov，ax,[1]在exe中就是把ax中的数据放入1中</p>
<p>甚至可以直接用[bx+si]的方式或[bx+si+idata]的方式来指明内存地址</p>
<h3 id="不同寻址方式的比较"><a class="markdownIt-Anchor" href="#不同寻址方式的比较"></a> 不同寻址方式的比较</h3>
<p>[idata]用于一个常量的寻址，直接定位一个内存单元</p>
<p>[bx]用于一个变量来表示内存地址，间接定位内存单元</p>
<p>只有bx,bp,di,si具有寻址能力，例如ds:[dx]等都是错误的</p>
<p>并且这几个寄存器间组合还有要求，只有bx+si,bx+di,bp+si,bp+di这四种情况是正确的</p>
<p>只要使用bp，它的段寄存器默认为ss</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>swing 表格</title>
    <url>/post/ade8c6d6.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://blog.csdn.net/xietansheng/article/details/78079806">学习自</a></p>
<h1 id="基础表格"><a class="markdownIt-Anchor" href="#基础表格"></a> 基础表格</h1>
<p>JTable用来编辑二维表格。注意添加到容器时表头和内容要分开添加。表头获取是table.getTableHeader()。</p>
<p>构造方法：</p>
<ul>
<li>JTable(int numRows, int numColumns)</li>
<li>JTable(Object[][] rowData, Object[] columnNames)：columnnames是表头名称</li>
<li>JTable(TableModel dm)： 用表格模型创建表格</li>
</ul>
<p>方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setFont</span><span class="params">(Font f)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//被选中字体颜色</span></span><br><span class="line"><span class="function"><span class="title">setSelectionForeground</span><span class="params">(Color selectionForeground)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setForeground</span><span class="params">(Color fg)</span></span><span class="comment">//字体颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setSelectionBackground</span><span class="params">(Color selectionBackground)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//网格颜色</span></span><br><span class="line"><span class="function"><span class="title">setGridColor</span><span class="params">(Color gridColor)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否显示网格</span></span><br><span class="line"><span class="function"><span class="title">setShowGrid</span><span class="params">(boolean showGrid)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//水平网格是否显示</span></span><br><span class="line"><span class="function"><span class="title">setShowHorizontalLines</span><span class="params">(boolean showHorizontalLines)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setShowVerticalLines</span><span class="params">(boolean showVerticalLines)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>JTableHeader getTableHeader(): 获取表头</li>
<li>jTableHeader.setFont(Font font);： 设置表头颜色</li>
<li>jTableHeader.setForeground(Color fg)</li>
<li>jTableHeader.setResizingAllowed(boolean resizingAllowed)：时候可以拖动调整列大小</li>
<li>jTableHeader.setReorderingAllowed(boolean reorderingAllowed)： 是否可以拖动进行重新排序</li>
<li>setRowHeight(int rowHeight)： 行高</li>
<li>setRowHeight(int row, int rowHeight)： 指定行行高</li>
<li>setAutoResizeMode(int mode)改变列宽的操作
<ul>
<li>JTable.AUTO_RESIZE_ALL_COLUMNS 在所有的调整大小操作中，按比例调整所有的列。</li>
<li>JTable.AUTO_RESIZE_LAST_COLUMN 在所有的调整大小操作中，只对最后一列进行调整。</li>
<li>JTable.AUTO_RESIZE_NEXT_COLUMN 在 UI 中调整了一个列时，对其下一列进行相反方向的调整。</li>
<li>JTable.AUTO_RESIZE_OFF 不自动调整列的宽度；使用滚动条</li>
<li>JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS 在 UI 调整中，更改后续列以保持总宽度不变；此为默认行为。</li>
</ul>
</li>
<li>TableColumn jTable.getColumnModel().getColumn(int columnIndex)：获取某列进行操作</li>
<li>tableColumn.setWidth(int width);</li>
<li>tableColumn.setPreferredWidth(int preferredWidth);</li>
<li>tableColumn.setMinWidth(int minWidth);</li>
<li>tableColumn.setMaxWidth(int maxWidth);</li>
<li>tableColumn.sizeWidthToFit()： 设置列宽使其符合单元格宽度</li>
<li>tableColumn.setResizable(boolean isResizable)： 是否允许手动改变列宽</li>
<li>tableColumn.setHeaderValue(Object headerValue)： 设置该列表头名称</li>
<li>jTable.getModel().setValueAt(Object aValue, int rowIndex, int columnIndex)： 设置某个位置数据</li>
<li>Object jTable.getModel().getValueAt(int rowIndex, int columnIndex)：得到某个位置数据</li>
</ul>
<h1 id="表格模型"><a class="markdownIt-Anchor" href="#表格模型"></a> 表格模型</h1>
<p>TableModel中储存了表格的一系列信息，实际上导入JTable中的数据自动变成TableModel。</p>
<p>TableModel中的方法：</p>
<ul>
<li>getRowCount()： 获取行数</li>
<li>getColumnCount()： 获取列数</li>
<li>String getColumnName(int columnIndex)：获取指定列的表头名称</li>
<li>Class&lt;?&gt; getColumnClass(int columnIndex)： 获取列中所有数据</li>
<li>isCellEditable(int rowIndex, int columnIndex)：单元格是否可编辑</li>
<li>Object getValueAt(int rowIndex, int columnIndex)： 获取单元格</li>
<li>setValueAt(Object aValue, int rowIndex, int columnIndex)： 获取单元格值</li>
</ul>
<p>监听器：</p>
<ul>
<li>tableModel.addTableModelListener(TableModelListener l)： 添加表格模型监听，表格的数据维护，对数据的监听。</li>
<li>tableModel.removeTableModelListener(TableModelListener l)：去除表格模型监听</li>
</ul>
<h1 id="listselectionmodel-表格选择器"><a class="markdownIt-Anchor" href="#listselectionmodel-表格选择器"></a> ListSelectionModel 表格选择器</h1>
<p>它可以让用户以不同模式选中表格。</p>
<ul>
<li>table.setCellSelectionEnabled(boolean cellSelectionEnabled)：设置表格可以被选择</li>
<li>table.getSelectionModel()： 获得选择器</li>
<li>selectionModel.setSelectionMode(int selectionMode)：设置选择模式
<ul>
<li>ListSelectionModel.MULTIPLE_INTERVAL_SELECTION   一次选择一个或多个连续的索引范围（默认）</li>
<li>ListSelectionModel.SINGLE_INTERVAL_SELECTION     一次选择一个连续的索引范围</li>
<li>ListSelectionModel.SINGLE_SELECTION              一次只能选择一个列表索引</li>
</ul>
</li>
</ul>
<p>监听器：</p>
<p>addListSelectionListener： 在选中状态改变时调用</p>
<h1 id="tablecellrenderer-单元格的渲染器"><a class="markdownIt-Anchor" href="#tablecellrenderer-单元格的渲染器"></a> TableCellRenderer 单元格的渲染器</h1>
<p>可以自己创建一个表格渲染器。然后TableColumn有setCellRenderer(renderer)。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static <span class="keyword">class</span> MyTableCellRenderer extends DefaultTableCellRenderer &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回默认的表单元格渲染器，此方法在父类中已实现，直接调用父类方法返回，在返回前做相关参数的设置即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        @Override</span><br><span class="line">        public Component get<span class="constructor">TableCellRendererComponent(JTable <span class="params">table</span>, Object <span class="params">value</span>, <span class="params">boolean</span> <span class="params">isSelected</span>, <span class="params">boolean</span> <span class="params">hasFocus</span>, <span class="params">int</span> <span class="params">row</span>, <span class="params">int</span> <span class="params">column</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数行背景设置为白色，奇数行背景设置为灰色</span></span><br><span class="line">            <span class="keyword">if</span> (row % <span class="number">2</span><span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                set<span class="constructor">Background(Color.WHITE)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set<span class="constructor">Background(Color.LIGHT_GRAY)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一列的内容水平居中对齐，最后一列的内容水平右对齐，其他列的内容水平左对齐</span></span><br><span class="line">            <span class="keyword">if</span> (column<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                set<span class="constructor">HorizontalAlignment(SwingConstants.CENTER)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (column<span class="operator"> == </span>(table.get<span class="constructor">ColumnCount()</span> - <span class="number">1</span>)) &#123;</span><br><span class="line">                set<span class="constructor">HorizontalAlignment(SwingConstants.RIGHT)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set<span class="constructor">HorizontalAlignment(SwingConstants.LEFT)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置提示文本，当鼠标移动到当前(row, column)所在单元格时显示的提示文本</span></span><br><span class="line">            set<span class="constructor">ToolTipText(<span class="string">&quot;提示的内容: &quot;</span> + <span class="params">row</span> + <span class="string">&quot;, &quot;</span> + <span class="params">column</span>)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PS: 多个单元格使用同一渲染器时，需要自定义的属性，必须每次都设置，否则将自动沿用上一次的设置。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 单元格渲染器为表格单元格提供具体的显示，实现了单元格渲染器的 DefaultTableCellRenderer 继承自</span></span><br><span class="line"><span class="comment">             * 一个标准的组件类 JLabel，因此 JLabel 中相应的 API 在该渲染器实现类中都可以使用。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * super.getTableCellRendererComponent(...) 返回的实际上是当前对象（this），即 JLabel 实例，</span></span><br><span class="line"><span class="comment">             * 也就是以 JLabel 的形式显示单元格。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果需要自定义单元格的显示形式（比如显示成按钮、复选框、内嵌表格等），可以在此自己创建一个标准组件</span></span><br><span class="line"><span class="comment">             * 实例返回。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用父类的该方法完成渲染器的其他设置</span></span><br><span class="line">            return super.get<span class="constructor">TableCellRendererComponent(<span class="params">table</span>, <span class="params">value</span>, <span class="params">isSelected</span>, <span class="params">hasFocus</span>, <span class="params">row</span>, <span class="params">column</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="tablecelleditor-数据编辑器"><a class="markdownIt-Anchor" href="#tablecelleditor-数据编辑器"></a> TableCellEditor 数据编辑器</h1>
<p>数据编辑器可以在表格中加入textfield，JComboBox等组件。实际一般使用默认的实现类DefaultCellEditor</p>
<p>tableColumn.setCellEditor(cellEditor)设置表格编辑器</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCellEditor</span> <span class="keyword">extends</span> <span class="title">DefaultCellEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="title">MyCellEditor</span>(<span class="params">JTextField textField</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(textField);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="title">MyCellEditor</span>(<span class="params">JCheckBox checkBox</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(checkBox);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="title">MyCellEditor</span>(<span class="params">JComboBox comboBox</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(comboBox);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="function"><span class="title">stopCellEditing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前单元格的编辑器组件</span></span><br><span class="line">            Component comp = getComponent();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前单元格编辑器输入的值</span></span><br><span class="line">            <span class="built_in">Object</span> obj = getCellEditorValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前单元格编辑器输入的值不是数字，则返回 false（表示数据非法，不允许设置，无法保存）</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span> || !obj.toString().matches(<span class="string">&quot;[0-9]*&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 数据非法时，设置编辑器组件内的内容颜色为红色</span></span><br><span class="line">                comp.setForeground(Color.RED);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据合法时，设置编辑器组件内的内容颜色为黑色</span></span><br><span class="line">            comp.setForeground(Color.BLACK);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合法数据交给父类处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.stopCellEditing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="rowsorter-排序器"><a class="markdownIt-Anchor" href="#rowsorter-排序器"></a> RowSorter 排序器</h1>
<p>创建： <code>RowSorter&lt;TableModel&gt; rowSorter = new TableRowSorter&lt;TableModel&gt;(tableModel)</code></p>
<p>TableRowSroter是RowSorter的实现类。</p>
<p>使用 <code>table.setRowSorter(rowSorter)</code></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>swing JTree</title>
    <url>/post/455a4c92.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1>
<p>树图形就像文件目录。由TreeNode表示节点，用TreePath表示这个节点的路径。</p>
<p>创建时，先创建根节点，然后创建子节点连接，类似于树的链式表示。</p>
<p>TreeNode 是一个接口，创建节点对象时，通常使用已实现该接口的的 DefaultMutableTreeNode 类。</p>
<h1 id="defaultmutabletreenode"><a class="markdownIt-Anchor" href="#defaultmutabletreenode"></a> DefaultMutableTreeNode</h1>
<p>表示一个节点，可以进行增查改删等操作。</p>
<p>构造方法：</p>
<ul>
<li>DefaultMutableTreeNode(Object userObject, boolean allowsChildren)：userObject是用户对象（节点名称），allowsChildren是是否允许拥有子节点</li>
</ul>
<p>方法：</p>
<ul>
<li>add()： 添加子节点</li>
<li>insert(MutableTreeNode newChild, int childIndex) ： 在指定位置插入子节点</li>
<li>getPreviousSibling()： 获得这个节点的前一个兄弟节点</li>
<li>getNextSibling()</li>
<li>getFirstChild()</li>
<li></li>
<li>remove(int childIndex)： 移除子节点</li>
<li>remove(MutableTreeNode aChild);</li>
<li>removeAll()</li>
<li>getChildCount()：获得子节点数量</li>
<li>getLeafCount()： 获得叶子结点数量</li>
<li>TreeNode getChildAt(int index)： 获取指定位置子节点</li>
<li>TreeNode getChildAfter(TreeNode aChild)： 获取子节点之后子节点</li>
<li>TreeNode getChildBefore(TreeNode aChild)</li>
<li>boolean isNodeChild(TreeNode aNode)： 判断是否是aNode是否是这个节点子节点</li>
<li>TreeNode getParent()： 获得父节点，没有返回null</li>
<li>boolean isRoot()： 是否是根节点</li>
<li>boolean isLeaf()</li>
<li>int getLevel()： 返回这个节点的层数，如果是根节点就是0</li>
<li>TreeNode[] getPath()： 返回从根结点到这个节点的路径，第一个节点是根节点</li>
<li>Enumeration children()： 遍历子节点（不包括孙子节点）</li>
<li>Enumeration breadthFirstEnumeration()： 遍历树（广度遍历）</li>
<li>Enumeration depthFirstEnumeration()： 深度遍历</li>
<li>setUserObject(Object userObject)</li>
<li>Object getUserObject(): 获得节点名称</li>
</ul>
<h1 id="treepath"><a class="markdownIt-Anchor" href="#treepath"></a> TreePath</h1>
<p>一般使用方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">TreeNode<span class="literal">[]</span> pathNodes = node.get<span class="constructor">Path()</span>;</span><br><span class="line">TreePath treePath = <span class="keyword">new</span> <span class="constructor">TreePath(<span class="params">pathNodes</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>treePath.getPathCount(): 获得节点数量</li>
<li>treePath.getPath()： 获得路径上的节点</li>
<li>treePath.getParentPath()： 获得这个节点上一个节点路径</li>
<li>treePath.isDescendant(TreePath aTreePath)： 判断aTreePath是否包含这个路径（判断aTreePath节点是否是子孙辈节点）</li>
</ul>
<h1 id="jtree"><a class="markdownIt-Anchor" href="#jtree"></a> JTree</h1>
<p>JTree负责把构造好的树显示出来。</p>
<p>构造方法：</p>
<ul>
<li>JTree(TreeNode root)： 由根节点就可以显示整个树</li>
<li>TreeModel treeModel = new DefaultTreeModel(TreeNode root)：构建一个树模型. 然后JTree(treeModel)</li>
</ul>
<p>方法：</p>
<ul>
<li>TreePath getPathForRow(int row)： 获得行索引。但是这个行索引实惠变化的，它不包括没有展开的。</li>
<li>int getRowForPath(TreePath path)： 根据路径获得行索引</li>
<li>int getRowForLocation(int x, int y)： 获得这个位置处的节点，可以和鼠标监听器一起使用。</li>
<li>TreePath getPathForLocation(int x, int y)</li>
<li>expandRow(int row)： 展开节点</li>
<li>expandPath(TreePath path)</li>
<li>collapseRow(int row)： 折叠节点</li>
<li>collapsePath(TreePath path)</li>
<li>isExpanded(int row)： 节点是否处于展开状态</li>
<li>isExpanded(TreePath path)</li>
<li>setSelectionRow(int row)： 设置当前选中的节点</li>
<li>setSelectionRow(int[] row)</li>
<li>setSelectionPath(TreePath path)</li>
<li>setSelectionPath(TreePath[] path): 多选</li>
<li>int[] getSelectionRows()： 获取当前选中的节点</li>
<li>TreePath getSelectionPath()</li>
<li>TreePath[] getSelectionPaths()</li>
<li>setRootVisible(boolean rootVisible)： 是否显示根节点（默认显示）</li>
<li>setShowsRootHandles(boolean newValue)： 是否显示根节点句柄（默认不显示）</li>
<li>setEditable(boolean flag)</li>
</ul>
<p>设置节点样式：</p>
<p>首先创建节点渲染器<code>DefaultTreeCellRenderer render = new DefaultTreeCellRenderer()</code></p>
<ul>
<li>render.setOpenIcon(Icon newIcon)： 设置节点展开时图标</li>
<li>render.setClosedIcon(Icon newIcon)：</li>
<li>render.setLeafIcon(Icon newIcon)： 叶子节点显示图标</li>
<li>render.setFont(Font font)</li>
<li>ender.setTextSelectionColor(Color newColor)：选中时颜色</li>
<li>render.setTextNonSelectionColor(Color newColor)</li>
<li>render.setBackgroundSelectionColor(Color newColor)： 选中时背景颜色</li>
<li>render.setBackgroundNonSelectionColor(Color newColor)</li>
</ul>
<p>之后设置节点渲染器<code>jTree.setCellRenderer(render)</code></p>
<p>监听器：</p>
<ul>
<li>addTreeExpansionListener： 节点展开/折叠监听器</li>
<li>addTreeWillExpandListener： 功能和上面相同，但是先执行</li>
<li>addTreeSelectionListener： 节点被选中监听器</li>
<li>tree.getModel().addTreeModelListener： 节点增删改监听器</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> Tree</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="constructor">Tree(String <span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> <span class="constructor">JFrame(<span class="params">name</span>)</span>;</span><br><span class="line">        frame.pack<span class="literal">()</span>;</span><br><span class="line">        frame.set<span class="constructor">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class="line">        frame.set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        DefaultMutableTreeNode treeroot = <span class="keyword">new</span> <span class="constructor">DefaultMutableTreeNode()</span>;</span><br><span class="line">        Object<span class="literal">[]</span> treename = <span class="keyword">new</span> Object<span class="literal">[]</span>&#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;H&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;treename.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            treeroot.add(<span class="keyword">new</span> <span class="constructor">DefaultMutableTreeNode(<span class="params">treename</span>[<span class="params">i</span>])</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        Object<span class="literal">[]</span> C_treename = <span class="keyword">new</span> Object<span class="literal">[]</span>&#123;<span class="string">&quot;user&quot;</span>, <span class="string">&quot;program&quot;</span>, <span class="string">&quot;data&quot;</span>&#125;;</span><br><span class="line">        DefaultMutableTreeNode C_treenode = (DefaultMutableTreeNode) treeroot.get<span class="constructor">ChildAt(0)</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="module-access"><span class="module"><span class="identifier">C_treename</span>.</span></span>length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">C_treenode</span>.</span></span>add(<span class="keyword">new</span> <span class="constructor">DefaultMutableTreeNode(C_treename[<span class="params">i</span>])</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        JTree tree = <span class="keyword">new</span> <span class="constructor">JTree(<span class="params">treeroot</span>)</span>;</span><br><span class="line">        tree.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line">        tree.set<span class="constructor">RootVisible(<span class="params">false</span>)</span>;</span><br><span class="line">        tree.set<span class="constructor">ShowsRootHandles(<span class="params">true</span>)</span>;</span><br><span class="line">        frame.add(tree);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swing%E7%BB%84%E4%BB%B69.PNG" alt="" /></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>union</title>
    <url>/post/9197.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先看一下结构体，c语言中的结构体占用字节数是所有类型字节数的总和。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用sizeof测试一下结果是8，但是如果用union呢？会发现结果是4</p>
<p>union中的参数共用同一块内存空间，它们在内存中起始地址都相同，也就是说同一时间内联合体中其实只会有一个参数存在，当另一个参数被赋值时，此时内存中存的就是另一个参数的值，而前面的参数会被覆盖</p>
<p>但是size并不一定是根据最长的那个长度来决定的（实测不是，但是不懂），还要考虑内存对齐的问题</p>
<p>如果此时已经给某一变量赋上了值，再用另外一个变量输出，那么内存中的编码并不会改变，只是会按找相应类型的编码方式进行编码然后输出。</p>
<ul>
<li>在c++中的使用</li>
</ul>
<p>大致相同，但是union中不能有类，如果我们在再类CA中添加了构造函数，或者添加析构函数，我们就会发现程序就会出现错误。由于union里面的东西共享内存，所以不能定义静态、引用类型的变量。由于在union里也不允许存放带有构造函数、析构函数和复制构造函数等的类的对象，但是可以存放对应的类对象指针</p>
<ul>
<li>应用 类型转换</li>
</ul>
<p>因为union共用一片地址，所以我可以通过不同的定义去访问这片地址。例如一个double类型的数据，我可以用int型访问低四字节和高四字节，并且不改变位级别的数据，这就相当于类型转换</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>unix文件系统</title>
    <url>/post/35532.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>文件就是任意源，有一个名称，可以从中写入读出数据。</p>
<h3 id="文件类型"><a class="markdownIt-Anchor" href="#文件类型"></a> 文件类型</h3>
<p>unix中有三种文件类型，普通文件，目录和伪文件。</p>
<p>普通文件是大多数时候所使用的文件，包括文本文件和二进制文件。例如，纯文本，shell脚本，源程序，配置文件，html文件等。</p>
<p>目录不同之处在于他们用来组织，访问其他文件。从概念上讲，目录包含其他文件。这个文件其实类似于windows下的文件夹。</p>
<p>伪文件有时候也称为设备文件。这种文件是物理设备的内部表示。例如键盘，显示器，打印机等，这些设备都可以当成一个文件进行访问。</p>
<p>有一种特殊的伪文件时proc文件，这种文件可以访问linux内核中的信息，设置可以修改Linux内核中的数据。</p>
<h3 id="特殊文件"><a class="markdownIt-Anchor" href="#特殊文件"></a> 特殊文件</h3>
<p>特殊文件就是表示物理设备的伪文件。这些文件都被存放于/dev下</p>
<p>一些常见的设备如下</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>硬件</th>
</tr>
</thead>
<tbody>
<tr>
<td>/dev/sda</td>
<td>SCSI硬盘</td>
</tr>
<tr>
<td>/dev/sda</td>
<td>第一分区</td>
</tr>
<tr>
<td>/dev/hda</td>
<td>硬盘</td>
</tr>
<tr>
<td>/dev/Ip0</td>
<td>打印机</td>
</tr>
<tr>
<td>/dev/tty</td>
<td>当前终端</td>
</tr>
<tr>
<td>/dev/random</td>
<td>随机数生成器</td>
</tr>
<tr>
<td>/dev/null</td>
<td>放弃输入 输入不返回内容</td>
</tr>
<tr>
<td>/dev/zero</td>
<td>放弃送站，输入返回0</td>
</tr>
</tbody>
</table>
<p>写入到/dev/null 或/dev/zero 中的任何文件都会被抛弃，因此这些文件又叫做位桶。</p>
<p>如果想读取随即数，只需要读取/dev/random。</p>
<h3 id="mkfifo-命名管道"><a class="markdownIt-Anchor" href="#mkfifo-命名管道"></a> mkfifo 命名管道</h3>
<p>在前面我们已经介绍过了管道，那种管道是匿名管道，就是只有当程序运行的时候它才被创建。</p>
<p>命名管道与匿名管道的显著区别就是必须显式的创建管道，其次，当命令结束之后，管道并不会消失，而是会继续存在，除非使用命令删除他们。</p>
<p>通常将命名管道称为FIFO，实际上就是队列。</p>
<p>语法： mkfifo [-m mode] pipe</p>
<p>其中，mode是chmod程序使用的一种文件类型，pipe是希望创建的管道名称。</p>
<p>用途：经常被用来两个进程中的通信。</p>
<p>例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkfifo fifotest</span><br><span class="line">grep bash <span class="regexp">/etc/</span>passwd &gt; fifotest <span class="regexp">//</span>第一个窗口上的命令</span><br><span class="line">wc -l &lt; fifotest <span class="regexp">//</span>这是第二个窗口上的命令</span><br></pre></td></tr></table></figure>
<p>如果想要去除管道，只需要rm + 管道名即可。</p>
<h3 id="proc文件"><a class="markdownIt-Anchor" href="#proc文件"></a> proc文件</h3>
<p>proc文件时那些提供一些简单途径来检查多种类型的系统信息的伪文件。proc文件可以直接从内核中提取数据。</p>
<p>所有的proc文件都存放在/proc目录下，在这个目录中，可以发现每一个进程对应一个子目录。</p>
<p>如果想提取这些进程的信息，可以使用cat命令去找到当前有那些进程正在执行，如果进入这些目录，还可以知道这些进程的详细状态。</p>
<p>有一个特殊的proc文件，/proc/kcore，这个文件表示计算机的实际物理内存。可以使用ls -l选项查看这个文件的大小。</p>
<h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3>
<h4 id="根目录-子目录"><a class="markdownIt-Anchor" href="#根目录-子目录"></a> 根目录 子目录</h4>
<p>目录是一个树形结构，对于每一层一定会有一个根，而用root过于麻烦，所以一般用/表示根目录。</p>
<p>例如 ls / 表示列举根目录下的所有文件。这样 ls /bin代表列bin目录下的所有文件。但是实际上如果列举根目录下的文件是不需要加/的，直接加上名字就好了，如果想访问根目录下子目录中的文件，就需要在子目录和子目录文件之间加一个/</p>
<p>例如： ls homework/bomb</p>
<h4 id="mount-umount挂载文件系统"><a class="markdownIt-Anchor" href="#mount-umount挂载文件系统"></a> mount umount挂载文件系统</h4>
<p>在系统中，有许多设备，也就有许多个文件系统。但是如果都是完全分隔的话，没办法在不同文件系统之间进行访问，所以一定有一颗主树，然后其他树挂载在主树上，这一个个文件系统其实类似于windows下的磁盘分区。</p>
<p>当小的文件系统连接上主树时，我们称为挂载。小文件系统附加到主树上的目录叫做挂载点</p>
<p>一般来说，系统已经自动挂载好了子树，但是有时候需要我们手动挂载子树（例如插入u盘时，当然现在也是自动挂载了）。这时需要mount程序。这里不再展开</p>
<h4 id="漫游根目录"><a class="markdownIt-Anchor" href="#漫游根目录"></a> 漫游根目录</h4>
<table>
<thead>
<tr>
<th>目录</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>/</td>
<td>根目录</td>
</tr>
<tr>
<td>/bin</td>
<td>基本程序</td>
</tr>
<tr>
<td>/boot</td>
<td>启动系统时所需要的文件</td>
</tr>
<tr>
<td>/etc</td>
<td>配置文件</td>
</tr>
<tr>
<td>/dev</td>
<td>设备文件</td>
</tr>
<tr>
<td>/home</td>
<td>用户home目录</td>
</tr>
<tr>
<td>/lib</td>
<td>基本共享库，内核模块</td>
</tr>
<tr>
<td>/lost+found</td>
<td>由fsck恢复的受损文件</td>
</tr>
<tr>
<td>/media</td>
<td>可移动介质的挂载点</td>
</tr>
<tr>
<td>/mnt</td>
<td>不能挂载在其他位置的挂载点</td>
</tr>
<tr>
<td>/opt</td>
<td>第三方应用程序</td>
</tr>
<tr>
<td>/proc</td>
<td></td>
</tr>
<tr>
<td>/root</td>
<td>超级用户home目录</td>
</tr>
<tr>
<td>/srv</td>
<td>本地系统提供服务的数据</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时文件</td>
</tr>
<tr>
<td>/usr</td>
<td>静态数据使用的文件系统</td>
</tr>
<tr>
<td>/var</td>
<td>可变数据使用的文件系统</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>unix基础</title>
    <url>/post/10919.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ol>
<li>操作系统有初始化功能，初始化过程只是引导过程的一部分</li>
</ol>
<p>引导过程是计算机启动时会运行一个小程序，然后再运行另一个程序，逐层运行，最后运行一个十分复杂的程序，这个程序名字是内核。</p>
<p>内核是操作系统的核心，因此只要计算机开启，内核边一直运行。</p>
<p>内核可以分为微内核和单内核两种。单内核较大，运行速度较快，但是由于没有采用模块化设计，维护修改比较困难。而微内核自己只能运行最基本的功能，其他功能要交给服务器去运行（微内核调用的其他程序），微内核速度慢，但适用于定制化的任务，如移动电话。</p>
<h3 id="unix内核使用工具"><a class="markdownIt-Anchor" href="#unix内核使用工具"></a> unix=内核+使用工具</h3>
<p>只有内核并不能带来很好的用户体验，因此还有许多其他的程序。最重要的是为用户提供计算机界面的程序，shell 和 GUI。</p>
<p>shell 是一种提供基于文本的界面的程序，也就是平时所说的命令提示符。</p>
<p>而 GUI（graphical user interface）是使用窗口，鼠标指针，图标等提供图形界面.</p>
<p>这些工具称为Unix实用工具，有几百个。</p>
<h3 id="服务器和客户端"><a class="markdownIt-Anchor" href="#服务器和客户端"></a> 服务器和客户端</h3>
<p>早期由于主机昂贵而终端便宜，所以经常是多个主机连接一个终端。因此服务器和客户端的概念也因此产生。</p>
<p>提供某种类型的服务的程序叫做服务器，使用服务的程序叫做客户端。例如，但你用键盘键入字符时，是主机而不是终端把字符显示出来，终端只是向主机发出了一个输出字符的请求，然后主机进行解析然后把字符输出</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>vector</title>
    <url>/post/54708.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="vector的定义"><a class="markdownIt-Anchor" href="#vector的定义"></a> vector的定义</h3>
<p>vector&lt;数据类型&gt; 标识符</p>
<h3 id="vector的函数"><a class="markdownIt-Anchor" href="#vector的函数"></a> vector的函数</h3>
<p>begin()返回开头元素的迭代器</p>
<p>end()同理</p>
<p>front() 返回开头元素的引用</p>
<p>back() 返回末尾元素的引用</p>
<p>size()返回vector内元素的数量</p>
<p>erase(迭代器) 删除一个元素</p>
<p>clear() 清空</p>
<p>insert(迭代器，a) 把a插入迭代器后</p>
<p><strong>例</strong>vector中现在有1 2 3 三个元素，vec.insert(vec.begin()+2,4)得到1 2 4 3</p>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3>
<p>reverse(vec.begin(),vec.end()) <strong>(头文件<code>&lt;algorithm&gt;</code>)</strong></p>
<p>实际上不一定是begin到end，也可以begin()+1到、、、，只需要用迭代器就行了
<p>sort排序，也要用<code>&lt;algorithm&gt;</code>默认升序</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> <span class="constructor">Comp(<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">a</span>,<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序。</p>
<h3 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组"></a> 二维数组</h3>
<pre><code>vector&lt;vector&lt;数据类型&gt; &gt; vec[3];//3行
vector&lt;数据类型&gt; veci;
for(int i=0;i&lt;3;i++)
&#123;
   for(int k=0;k&lt;4;k++)
   &#123;
      veci.push_back();
   &#125;
   vec.push_back(veci);
&#125;//四列
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>“凸包”</title>
    <url>/post/6589.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>凸包就是把平面中所有点都包进去的凸多边形，当然多边形上的点也是题目中给出的点</p>
<p>分治法<br />
1 首先，横坐标最小p1和最大pn的点一定是凸包上的点<br />
2上包，即离p1pn最远的点，记pmax<br />
3再把pmax与p1连接，求左侧的上包，重复上述过程即可求解<img src="/images/20150530094927274" alt="" /></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>python time random turtle jieba</title>
    <url>/post/a3a786d6.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="time"><a class="markdownIt-Anchor" href="#time"></a> time</h1>
<ul>
<li>
<p>time(): 输出从1970年1月1日到现在时间时间差（以秒为单位）。可以用来获取程序运行时间。</p>
</li>
<li>
<p>gmtime(): 获取utc时间。返回一个struct_time对象</p>
</li>
<li>
<p>localtime(): 获取本地时间,也是返回struct_time对象</p>
</li>
<li>
<p>ctime(): 获取本地时间的字符串</p>
</li>
<li>
<p>mktime(t): 把struct_time类型的t转化成时间差（从1970到现在）</p>
</li>
<li>
<p>strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, t): 格式化t.例如2020-02-02 01:02:03</p>
</li>
<li>
<p>strptime(timestring, “…”): 将格式为…的timestring转化成struct_time</p>
</li>
<li>
<p>sleep(): 进程睡眠</p>
</li>
<li>
<p>perf_counter(): 用来计时。和time类似，但精度更高</p>
</li>
</ul>
<h1 id="random"><a class="markdownIt-Anchor" href="#random"></a> random</h1>
<ul>
<li>seed(): 初始化随机数种子</li>
<li>random(): 生成一个0到1的小数</li>
<li>randint(a, b): 生成a到b的随机整数</li>
<li>getrandbits(k): 生成一个kbit长的随机整数</li>
<li>randrange(start, stop, step): 生成一个start到stop步长为step的随机整数</li>
<li>uniform(a, b): 生成a到b随机小数</li>
<li>choice(seq): 从列表中随机返回一个元素</li>
<li>shuffle(seq): 随机排列</li>
<li>sample(pop, k): 从pop中选出k个数，以列表形式返回</li>
</ul>
<h1 id="turtle"><a class="markdownIt-Anchor" href="#turtle"></a> turtle</h1>
<ul>
<li>
<p>setup(width, height, startx, starty)如果width是小数，那么是窗口相对屏幕比例。如果startx是null，则在水平中央</p>
</li>
<li>
<p>forword(x):</p>
</li>
<li>
<p>backword(x)</p>
</li>
<li>
<p>right(x): 向右旋转</p>
</li>
<li>
<p>left(x):</p>
</li>
<li>
<p>setheading(x): 设置角度</p>
</li>
<li>
<p>goto(x, y): 移动到坐标处，原点是0,0。</p>
</li>
<li>
<p>circle(radius, e): 绘制半径是r，角度是e的圆</p>
</li>
<li>
<p>undo(): 取消最后一步动作。</p>
</li>
<li>
<p>speed(x): 设置速度，范围1到10</p>
</li>
<li>
<p>penup(): 提起画笔</p>
</li>
<li>
<p>pendown():</p>
</li>
<li>
<p>pensize():</p>
</li>
<li>
<p>color(): 设置颜色</p>
</li>
<li>
<p>begin_fill(): 开始填充</p>
</li>
<li>
<p>end_fill():</p>
</li>
<li>
<p>filling(): 是否填充。必须要在end_fill前写，如果在fill范围外写一定是false</p>
</li>
<li>
<p>clean(): 清空画的东西，但不改变画笔的位置</p>
</li>
<li>
<p>reset(): 重置</p>
</li>
<li>
<p>screensize(x, y): 设置屏幕长宽，超出屏幕大小的size时会有滚动条。</p>
</li>
<li>
<p>hideturtle(): 去除小箭头</p>
</li>
<li>
<p>showturtle(): 显示箭头</p>
</li>
</ul>
<h1 id="jieba"><a class="markdownIt-Anchor" href="#jieba"></a> jieba</h1>
<ul>
<li>lcut(x): 精确模式</li>
<li>lcut(x, cut_all=True): 全模式，速度快但是划分不精确</li>
<li>lcut_for_search(x):  饭后适合搜索引擎搜索的词。</li>
<li>add_word(x): 添加词</li>
</ul>
<h1 id="wordcloud"><a class="markdownIt-Anchor" href="#wordcloud"></a> wordcloud</h1>
<p>根据频率来确定大小。默认以空格和,为分隔符。</p>
<p>函数：</p>
<ul>
<li>a = wordcloud.WordCloud(font_path=, width=, height=).generate(text): 其中第二个WordCloud是wordcloud库中的类。</li>
<li>a.to_file(filename): 把词云输出成文件，filename是文件名。文件类型可以是png，jpg等。</li>
</ul>
<p><img src="/images/python_wordcloud.PNG" alt="" /><br />
这些是WordCloud的参数</p>
<p>如果是中文，先要用jieba进行分词。</p>
<h1 id="pyinstaller"><a class="markdownIt-Anchor" href="#pyinstaller"></a> pyinstaller</h1>
<p>把源文件转化成exe文件。</p>
<p>使用： pyinstaller -F 源文件名</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>vi</title>
    <url>/post/20198.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="启动vi"><a class="markdownIt-Anchor" href="#启动vi"></a> 启动vi</h3>
<p>语法： vi [-rR] [file…]</p>
<p>如果用vi启动了一个不存在的文件，那么他将新建这个文件。如果只输入vi，那么他将在当前文件夹下创建一个空文件</p>
<p>-R 以只读模式启动</p>
<p>vim是vi的进阶版本</p>
<p>语法： vi -C [-rR] [file…]</p>
<p>-C是兼容模式，它将尽可能的和vi保持一样</p>
<h3 id="命令模式和编辑模式"><a class="markdownIt-Anchor" href="#命令模式和编辑模式"></a> 命令模式和编辑模式</h3>
<p>当使用vi时，存放数据的区域叫做编辑缓冲区（editing buffer),如果想编辑文件，那么vi就将文件的内容复制到缓冲区中，然后再缓冲区中编辑。因此处理的其实是文件的副本。</p>
<p>在命令模式中，输入的一切字符都是命令。例如，在命令模式中，单个字母x就是删除一个字符。dd就是删除整行的命令。</p>
<p>第二种模式就是输入模式。这种模式下，任何内容都会输入到缓冲区中。</p>
<p>在启动过程中，vi完成三件事情。将文件中的内容复制到编辑缓冲区，将光标定位到缓冲区第一行的开头。最后vi进入命令模式。</p>
<h3 id="数据的恢复和关闭vi"><a class="markdownIt-Anchor" href="#数据的恢复和关闭vi"></a> 数据的恢复和关闭vi</h3>
<p>当使用vi时，数据会保存在编辑缓冲区内，因此当程序非正常终止时，临时文件依然存在。使用-r(recovery)就可以重新打开缓冲区</p>
<p>如果需要先保存再退出，使用的命令时ZZ,即先按下shift键，然后按z两次。这个命令不需要按enter键</p>
<p>如果不保存直接退出，可以 :q!，然后按return键</p>
<h3 id="vi屏幕的格式即vi和ex命令"><a class="markdownIt-Anchor" href="#vi屏幕的格式即vi和ex命令"></a> vi屏幕的格式即vi和ex命令</h3>
<p>屏幕底部的一行叫做命令行。这一行有两种功能：显示消息和显示键入时的命令。</p>
<p>大多数时候vi编辑的数据都是纯文本（字母，数字，标点符号等）。如果想输入控制字符，需要使用^v。 例如，如果想输入<sup>c,那么需要输入</sup>v^c.</p>
<p>vi和ex命令其实都是vi编辑器中的命令。大多数vi命令都是单字母或双字母形式。大多数vi命令无需按下return键。例如，一但输入dd，那么立刻会删除一行。</p>
<p>ex命令一般都比较长，并且在键入过程中会显示在屏幕下方。如果键入有错误，可以backspace删除单个字符或者<sup>x/</sup>u删除所有字符。</p>
<h3 id="移动光标"><a class="markdownIt-Anchor" href="#移动光标"></a> 移动光标</h3>
<p>h 向左移动一个字符</p>
<p>j 向下移动一个字符</p>
<p>k 向上移动一个字符</p>
<p>l 向右移动一个字符</p>
<p>另外一种方式是上下左右键。</p>
<p>此外，backspace 向左移动一个位置，space向右移动一个位置。-号移动到上一行，+号移动到下一行。</p>
<p>0移动到当前行的开头，$移动到当前行的结尾。^移动到第一个非制表符/空格字符上</p>
<p>w移动到下一个单词的开头，e移动到下一个单词的结尾。b移动到上一个单词的开头</p>
<p>W，E，B的作用和w，e，b的作用相同，但是忽略标点符号</p>
<p>( 移动到上一个句子</p>
<p>) 移动到下一个句子</p>
<p>{ 移动到上一个段落</p>
<p>} 移动到下一个段落</p>
<p>句子的定义时一个字符串，以句号，逗号，问号和感叹号结尾，并且后面要接一个新行字符或者两个空格</p>
<p>H 移动到屏幕的顶部（是当前屏幕，不是整个文章）</p>
<p>M 移动到屏幕的中间</p>
<p>L 移动到屏幕的底部</p>
<p>为了增强命令的功能，可以在命令之前输入数字确定重复次数。例如：10w代表跳过十个单词。不需要输enter。</p>
<h4 id="整屏移动"><a class="markdownIt-Anchor" href="#整屏移动"></a> 整屏移动</h4>
<p>^f(ctrl+f,forward) 移动到下一屏</p>
<p>^B(backward) 移动到上一屏</p>
<p>^d 下移半屏，^u 上移半屏</p>
<p>这里<sup>d和</sup>u前面加数字与前面略有不同。前面只对该次有效，而这里是一直有效</p>
<h4 id="跳转到前一位置"><a class="markdownIt-Anchor" href="#跳转到前一位置"></a> 跳转到前一位置</h4>
<p>可以使用两个反引号跳转到前一位置。这个前一位置并不简单指的是上一条指令的位置。如果你一直使用行跳转的话那么这条指令将会带你去没进行行跳转时的位置。其实相当于保存了两个地址，你可以在两个地址之间跳转进行修改，第一个地址就是每跳转之前的地址。第二个地址就是跳转之后的地址。如果你现在位于第二个地址上，那么进行跳转只会改变第二个地址。用了反引号后直接回到第一个地址，然后如果再在第一个地址上跳转，那么只会修改第一个地址。</p>
<p>第二个跳转地址是在你第一次使用移动命令后产生的，也可以看为开始第一个地址和第二个地址再同一位置。之后一直都是在对第二地址进行修改。</p>
<p>如果使用两个单引号，那么将会回到对应地址的开头。</p>
<p>此外，我们还可以通过设置标识来新增跳转地址。先键入m，再输入标识符，之后就可以直接跳转到有标识符的位置。标识符是不可见字符，所以最好自己先记好。</p>
<p>例如： ma设置a标识符。 `a回到a的位置</p>
<h3 id="搜索模式"><a class="markdownIt-Anchor" href="#搜索模式"></a> 搜索模式</h3>
<p>符号： / ?</p>
<p>/ 向下面搜索，/+字符表示要搜索哪个字符。如果还想继续搜索该字符只需要输入/然后回车就会搜索下一个</p>
<p>？ 用法相同，向上搜索</p>
<p>或者按n继续向下搜索，N继续向上搜索</p>
<p>此外，还可以使用正则表达式中的锚</p>
<h3 id="使用行号和切换模式"><a class="markdownIt-Anchor" href="#使用行号和切换模式"></a> 使用行号和切换模式</h3>
<p>可以通过 :set number 设置显示行号</p>
<p>如果行号关闭，可以通过 ^G键查看现在在文本中的哪个位置</p>
<p>可以通过 数字+G（大写）跳转到任意一行</p>
<p>此外，还可以通过 :+数字跳转到任意一行，其中 😒 跳转到文本末尾</p>
<p>前文已经说了vi有两种模式，一种是编辑模式，一种是命令模式，从编辑模式切换成命令模式只有一种方法，按esc键。但是从命令模式转换到编辑模式有十二种之多</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">i</span> 在当前光标之前插入字符</span><br><span class="line"><span class="variable">a</span> 在光标之后插入字符</span><br><span class="line"><span class="built_in">I</span> 在当前行的开头插入字符</span><br><span class="line"><span class="variable">A</span> 在当前行的末尾插入字符</span><br><span class="line"><span class="variable">o</span> 在当前行下面插入一行</span><br><span class="line"><span class="built_in">O</span> 在当前行上面插入一行</span><br></pre></td></tr></table></figure>
<h3 id="修改文本"><a class="markdownIt-Anchor" href="#修改文本"></a> 修改文本</h3>
<p>如果只需要修改一个字符的话，那么可以在命令模式下输入r+字符就可以修改光标后面的字符（注意不是增加而是直接把光标后面的字符变成输入的字符）</p>
<p>如果想要修改很多字符，可以输入R，这时会切换到输入模式。随后键入的每个字符都会替换当前字符。</p>
<p>如果想要修改的字符数与原来并不相同，那么可以使用s（substitute)命令把一个字符变成许多个字符。如果输入了s，那么将回到输入模式，且此时光标后面的后面的字符将会变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">，</mi><mi mathvariant="normal">然</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">再</mi><mi mathvariant="normal">输</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">，然后再输入字符，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">再</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">，</span></span></span></span>就会变成对应的字符</p>
<p>例如 m|a,输入s后变成 m|$，然后输入other，就会变成 mother</p>
<p>此外C命令是将光标后面的字符都替换，如果输入了这个命令，那么在该行的最后将会出现$</p>
<p>cc命令可以替换一整行，无论光标在哪里</p>
<p>c+移动光标命令，这将替换从光标处到移动后的光标处所有的字符，可以有重复次数</p>
<h3 id="替换文本"><a class="markdownIt-Anchor" href="#替换文本"></a> 替换文本</h3>
<p>这里我们主要谈论的是ex命令。这些命令都以 ： 为开始。</p>
<p>替换语法： 😒/pattern/replace/</p>
<p>这条命令的含义是替换第一个pattern，如果后面加上g（global），那么将替换所有pattern。</p>
<p>如果希望改变之前先请求同意，可以在后面加上 c（confirm）。也可以同时使用gc</p>
<p>如果想要删除某些pattern，只需要 😒/pattern//g即可</p>
<p>在s前面加上数字表示替换某些行。例如： :57s/unix/linux 表示把第57行第一次出现的unix变成linux。</p>
<p>如果想从当前行到末尾，那么可以使用 : . , $s/pattern/replace/</p>
<p>其中 .(点）表示当前行，$表示最后一行，中间用逗号分割开来。</p>
<h3 id="删除字符"><a class="markdownIt-Anchor" href="#删除字符"></a> 删除字符</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">x</span> 删除右边的字符</span><br><span class="line"><span class="selector-tag">X</span> 删除左边的字符</span><br><span class="line"><span class="selector-tag">D</span> 删除当前光标到本行末尾的字符</span><br><span class="line"><span class="selector-tag">d</span>+移动指令 删除从当前光标到移动指令后的字符</span><br><span class="line"><span class="selector-tag">dd</span> 删除当前行</span><br><span class="line"><span class="selector-tag">ex</span> 命令</span><br><span class="line"><span class="selector-pseudo">:lined</span> 删除指定行</span><br><span class="line"><span class="selector-pseudo">:line</span>,<span class="selector-tag">lined</span> 删除多个行</span><br></pre></td></tr></table></figure>
<p>如果要删除所有行，一种是 :1,$d，另一种是:%d，%指的是所有行</p>
<h3 id="撤销或重复改变"><a class="markdownIt-Anchor" href="#撤销或重复改变"></a> 撤销或重复改变</h3>
<p>撤销就是如果命令输入错误，可以使用命令撤销</p>
<p>u 撤销上一命令对缓冲区进行的修改</p>
<p>U 恢复当前行</p>
<p>. 重复上一命令对编辑缓冲区进行的修改</p>
<p>其中 U 指的是将撤销至移动到当前行的那一刻起，对当前行所进行的所有改变</p>
<p>.命令可以用来重复，但是如果使用了撤销，那么它将会使用撤销所恢复的命令</p>
<h4 id="恢复删除"><a class="markdownIt-Anchor" href="#恢复删除"></a> 恢复删除</h4>
<p>每当删除<strong>一行或者多行</strong>文本时，vi都将文本储存在一个缓冲区中，这个缓冲区称为编号缓冲区。vi有9个缓冲区。在任何时候，都可以将一个编号缓冲区中的内容插入到编辑缓冲区中。这样做时，需要键入一个双引号（“），后面跟着缓冲区的编号，再后面跟着一个p（put)命令，p是在当前行下面插入，P是在当前行上面插入。</p>
<p>如果你忘记是哪个编号缓冲区的话，可以先撤销一次，然后使用.号重复插入，这时vi将自动把缓冲区编号加1</p>
<h3 id="移动文本"><a class="markdownIt-Anchor" href="#移动文本"></a> 移动文本</h3>
<p>vi总是在一个称为无名缓冲区的地方为上一次删除保存一个副本。与编号缓冲区不同，编号缓冲区只会保存删除的多行，删除少数字符是不会被保存的。</p>
<p>p 命令用来把无名缓冲区的内容插入到当前位置之后</p>
<p>考虑组合命令xp，x是删除当前光标处的字符。p是把字符插入光标的右边。这样相当于把两个自住房换了一下顺序。</p>
<p>另一个重要的组合命令是deep，这个命令是将两个单词换序</p>
<p>ddp 调换两行，因为dd是删除一行，删除这行后光标在原本该行的下一行，然后p是插入到这一行的后一行，相当于两行换了位置。</p>
<h3 id="复制文本"><a class="markdownIt-Anchor" href="#复制文本"></a> 复制文本</h3>
<p>复制文本分为三步：</p>
<ol>
<li>使用y，yy或Y命令将文本有编辑缓冲区复制到无名缓冲区中，但不删除原始文本。</li>
<li>将光标移动到希望插入文本的位置。</li>
<li>使用p或P命令命令执行插入</li>
</ol>
<p>在不删除文本的情况下将文本复制到无名缓冲区，叫做接出（yank)，因此将命令命名为y，yy，Y。y，yy命令和d命令执行情况相同，</p>
<h3 id="改变字母大小写"><a class="markdownIt-Anchor" href="#改变字母大小写"></a> 改变字母大小写</h3>
<p>符号： ~</p>
<p>该命令会改变vi当前字母的大小写，然后将光标向前移动一个字符。改变大小写的意思是把大写变成小写，小写变成大写。</p>
<p>有些版本的vi使用这个命令不会超过一行，just like me。</p>
<h3 id="设置选项"><a class="markdownIt-Anchor" href="#设置选项"></a> 设置选项</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> showmode 输入模式提醒</span><br><span class="line">:<span class="builtin-name">set</span> number 显示行号</span><br><span class="line">:<span class="builtin-name">set</span> nonumber 不显示行号</span><br><span class="line">:<span class="builtin-name">set</span> tabstop = number 设置制表符间距</span><br><span class="line">:<span class="builtin-name">set</span> autoindent 缩进以匹配上一行/下一行</span><br><span class="line">:<span class="builtin-name">set</span> autowrite 如果文本已修改，则在切换文件前保存</span><br><span class="line">:<span class="builtin-name">set</span> errorbells 显示错误信息时发出声音</span><br><span class="line">:<span class="builtin-name">set</span> list 将制表符显示成^I,将行的结束显示成$</span><br><span class="line">:<span class="builtin-name">set</span> showmatch 显示匹配的 () &#123;&#125; []</span><br><span class="line">:<span class="builtin-name">set</span> wrapscan 环绕文本进行搜索</span><br><span class="line">:<span class="builtin-name">set</span> lines 设置文本行数</span><br><span class="line">:<span class="builtin-name">set</span> wrapmargin = n 在键入过程中自动换行，n是离右边缘的位置，例如<span class="attribute">n</span>=6意味着在例右边缘6个字符的地方换行，为0关闭自动换行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果想查看当前选项是在什么状态，可以使用:set 选项？</p>
<p>如果显示所有选项的值，可以使用 :set all</p>
<h3 id="复制移动行"><a class="markdownIt-Anchor" href="#复制移动行"></a> 复制移动行</h3>
<p>如果想指定行号进行移动，可以使用ex命令中的 :co(copy) :m(move)</p>
<p>:5co10,复制第5行，并将其放在第10行的下面</p>
<p>:4,8co20 复制4到8行，并将其放在20行的下面</p>
<h3 id="输入shell命令"><a class="markdownIt-Anchor" href="#输入shell命令"></a> 输入shell命令</h3>
<p>可以通过 :!+命令的方式，在不退出vi的情况下进行shell命令</p>
<p>:!! 重复上一条shell命令</p>
<p>如果现在缓冲区中直接插入shell命令的输出，可以使用 :r !</p>
<p>例如 :1r !date，就是将date输出插入第一行的后面</p>
<p>如果直接用感叹号，那么就会将文件中的数据交给shell命令进行操作，然后再将操作后的文件复制到原位置</p>
<p>例如： 5!!sort ，这个命令将会从当前开始把接下来5行排序。</p>
<p>!}sort 这个命令是将接下来一段排序。</p>
<h3 id="将文件中的数据插入编辑缓冲区中"><a class="markdownIt-Anchor" href="#将文件中的数据插入编辑缓冲区中"></a> 将文件中的数据插入编辑缓冲区中</h3>
<p>语法： :[line]r file</p>
<p>line 是行号 file是文件名</p>
<p>:r命令读取文件中的内容，然后将其插入指定行的后面</p>
<h3 id="不退出vi的情况下进行保存"><a class="markdownIt-Anchor" href="#不退出vi的情况下进行保存"></a> 不退出vi的情况下进行保存</h3>
<p>:w 将数据写入原有文件<br />
:w file 将数据写入一个新文件中<br />
:w! file 覆盖原有文件<br />
:w&gt;&gt; file 将数据追加到一个新文件中<br />
:10w! save 将特定行保存到文件中<br />
:wq 保存退出vi 和 ZZ有同样的效果</p>
<h3 id="切换到一个新文件"><a class="markdownIt-Anchor" href="#切换到一个新文件"></a> 切换到一个新文件</h3>
<p>:e + 文件名</p>
<p>当编辑一个新文件时，原有缓冲区内容会消失，所以首先要使用 :w保存.当使用:e时，系统会自动检查是否保存，如果没有保存，不允许切换到新文件。如果希望忽略这种保护，可以使用:e!命令</p>
<h3 id="使用缩写"><a class="markdownIt-Anchor" href="#使用缩写"></a> 使用缩写</h3>
<p>:ab [short long]</p>
<p>short是缩写，long是缩写的原文。如果确定了缩写，那么在编辑模式下，如果拼写了缩写，系统会自动变成全称。当然，只有在这个缩写是一个单词（两边有空格）的情况下才会变全称。</p>
<h3 id="宏"><a class="markdownIt-Anchor" href="#宏"></a> 宏</h3>
<p>:map命令可以创建命令模式下的缩写，实际上，这就可以自己创建命令。这些命令叫做宏</p>
<p>语法： :map [x commands]</p>
<p>x是一个字符，commands是vi或ex命令序列</p>
<p>例如 :map K deep就是将两个单词换位的命令设置成一个宏</p>
<h3 id="初始化文件"><a class="markdownIt-Anchor" href="#初始化文件"></a> 初始化文件</h3>
<p>对于vim来说，初始化文件是.vimrc,</p>
<p>如果想删除一个缩写，可以使用 :una short</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>&amp;&amp;与||小提示</title>
    <url>/post/25699.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id=""><a class="markdownIt-Anchor" href="#"></a> &amp;&amp;</h4>
<p>&amp;&amp;运算符从左自由依次判断 ，如果判断有一个为假则停止判断</p>
<h4 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> ||</h4>
<p>同理如果判断有一个为真则停止判断</p>
<h4 id="例"><a class="markdownIt-Anchor" href="#例"></a> 例</h4>
<pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
&#123;
    int a=0,b=1,c;
    c = (a != b) || (++a == b++);
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
<p>输出为0 1因为前面一个为真，直接退出判断</p>
]]></content>
  </entry>
  <entry>
    <title>string大小写字母转换</title>
    <url>/post/14511.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在algorithm库中有transform函数<br />
transform(str.begin(),str.end(),str.begin(),::toupper)<br />
注意transform有四个输入参数<br />
1：str.begin()字符串的起始地址；<br />
2：str.end()字符串的终止地址；<br />
3：str.begin()是转换之后，输出到原str字符串的起始地址；<br />
4：转换操作，可以选择toupper，tolower。</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>二分搜索</title>
    <url>/post/41829.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="主要是怕自己忘记了"><a class="markdownIt-Anchor" href="#主要是怕自己忘记了"></a> （主要是怕自己忘记了）</h1>
<p>一个要点，用二分时要先排序</p>
 <figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> erfen(<span class="built_in">int</span> arr[],<span class="built_in">int</span> key,<span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> low=<span class="number">0</span>,high=<span class="built_in">n</span>-<span class="number">1</span>;</span><br><span class="line">        while(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span>=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">if</span>(arr[<span class="built_in">mid</span>]&lt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                low=<span class="built_in">mid</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span>(arr[<span class="built_in">mid</span>]==key)</span><br><span class="line">            &#123;</span><br><span class="line">                return <span class="built_in">mid</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span>(arr[<span class="built_in">mid</span>]&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                high=<span class="built_in">mid</span>-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -<span class="built_in">mid</span>-<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>从asm到exe</title>
    <url>/post/28954.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>先要有masm.exe和link.exe，然后输入masm+程序名和link+程序名</p>
<p>或者masm+盘符+程序名，可以省略中间过程，节省时间<br />
例：masm c:\1.asm</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树链表构建和应用</title>
    <url>/post/11799.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="递归遍历"><a class="markdownIt-Anchor" href="#递归遍历"></a> 递归遍历</h3>
<p>中序</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">void inorder(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> != NULL)</span><br><span class="line">    &#123; </span><br><span class="line">        inorder(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">T</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">        inorder(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前序</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">void preorder(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">T</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">        preorder(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        preorder(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历同理。</p>
<p>这个算法是以当前节点为基点，先输出当前节点数值，然后再去输出左子树数值，然后再递归输出左子树数值知道NULL，才又递归输出右子树数值。</p>
<h3 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h3>
<h4 id="二叉树构建"><a class="markdownIt-Anchor" href="#二叉树构建"></a> 二叉树构建</h4>
<p>如果我们只给出数值和构建顺序，是无法构建二叉树的。例如，给出三个数，然后给出构建顺序是123这样总共有5中构建方法。因此还要把空节点加上才可以构建。空节点的值为-1或@</p>
<p>前序遍历构建</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">create</span>(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="built_in">new</span> binarynode;</span><br><span class="line">        <span class="keyword">if</span>(T == <span class="keyword">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        T-&gt;data = c;</span><br><span class="line">        <span class="keyword">create</span>(T-&gt;left);</span><br><span class="line">        <span class="keyword">create</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是先构造当前节点，如果当前节点不是空节点，那么构造左节点和右节点。如果是，直接空节点返回。</p>
<h4 id="计算叶结点个数"><a class="markdownIt-Anchor" href="#计算叶结点个数"></a> 计算叶结点个数</h4>
<p>叶节点的特点就是左右子树都是空。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">int calculate(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)//空树</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;<span class="built_in">left</span> == NULL &amp;&amp; T-&gt;<span class="built_in">right</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(T-&gt;<span class="built_in">left</span>) + calculate(T-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算节点个数"><a class="markdownIt-Anchor" href="#计算节点个数"></a> 计算节点个数</h4>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">int calulate(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + calculate(T-&gt;<span class="built_in">left</span>) + calculate(T-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算二叉树高度"><a class="markdownIt-Anchor" href="#计算二叉树高度"></a> 计算二叉树高度</h4>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> counthigh(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = counthigh(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">n</span> = counthigh(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">        return m &gt; <span class="built_in">n</span> ? m+<span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的思想是比较左子树和右子树高度，然后再加上根的高度。</p>
<h4 id="复制二叉树"><a class="markdownIt-Anchor" href="#复制二叉树"></a> 复制二叉树</h4>
<p>按前序遍历的方法最好复制</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">binode* <span class="keyword">copy</span>(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    binode *<span class="keyword">temp</span> = <span class="built_in">new</span> node;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">temp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">exit</span>(overflow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">temp</span>-&gt;data = T-&gt;data;</span><br><span class="line">    <span class="keyword">temp</span>-&gt;left = <span class="keyword">copy</span>(T-&gt;left);</span><br><span class="line">    <span class="keyword">temp</span>-&gt;right = <span class="keyword">copy</span>(T-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归搜索二叉树"><a class="markdownIt-Anchor" href="#非递归搜索二叉树"></a> 非递归搜索二叉树</h3>
<p>非递归构造二叉树主要用到了栈来模拟递归过程。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> inorder(binode *T)</span><br><span class="line">&#123;</span><br><span class="line">    binode *p;</span><br><span class="line">    stack&lt;binode*&gt; s;<span class="comment">//如果不行就自己构建一个栈</span></span><br><span class="line">    s.<span class="keyword">push</span>(T);<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( p == s.gettop() &amp;&amp; p != <span class="keyword">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">push</span>(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="comment">/*因为是push左子树，所以最后先push进一个空然后才会退出循环</span></span><br><span class="line"><span class="comment">        所以要先把这个NULL去掉*/</span></span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p = s.gettop();</span><br><span class="line">            cout &lt;&lt; p-&gt;data;</span><br><span class="line">            s.<span class="keyword">pop</span>();<span class="comment">//去掉p节点</span></span><br><span class="line">            s.<span class="keyword">push</span>(p-&gt;right);</span><br><span class="line">            <span class="comment">/*如果p是叶结点，那么push右边也是NULL,内层循环不会执行，然后</span></span><br><span class="line"><span class="comment">            执行pop取点NULL，之后if中又会取出上一层节点继续找右子树*/</span></span><br><span class="line">            <span class="comment">//如果右子树中还有分支，那么会继续这个过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序的含义是先找左节点，然后把中间节点退出去，找右节点，在右节点中重复找左节点。</p>
<p><strong>前序遍历</strong>又稍有不同，因为前序遍历是先直接输出根节点，所以根节点就不需要存入栈中，实际栈中存入的是右节点。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> preorder(binode *T)</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;binode*&gt; s;</span><br><span class="line">    binode *p = T;</span><br><span class="line">    s.push(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="keyword">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;left;<span class="comment">//进入左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s.gettop();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是先输出根，然后把右子树拖入栈中，进入左子树，如果左子树遍历完了，p-&gt;left == NULL,之后就到右子树那边去遍历。</p>
<p><strong>后序遍历</strong>更为麻烦，stack要用自己的，设置一个标志位确定现在是左子树还是右子树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stacknode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    binode *ptr;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">tag</span>&#123;</span>L,R&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(binode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> s;</span><br><span class="line">    stacknode w;</span><br><span class="line">    binode *p = T;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            w.ptr = p;</span><br><span class="line">            w.tag = L;</span><br><span class="line">            push(s,w);</span><br><span class="line">            p = p-&gt;leftchild;</span><br><span class="line">        &#125;<span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">continue</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">continue</span> != <span class="number">0</span> &amp;&amp; !stackempty(s))</span><br><span class="line">        &#123;</span><br><span class="line">             pop(s,w);</span><br><span class="line">             p = w.ptr;</span><br><span class="line">             <span class="keyword">switch</span>(w.tag)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">case</span> L: w.tag = R;<span class="comment">//这时算作根节点，根节点为R那么下次就会输出</span></span><br><span class="line">                      push(s,w);</span><br><span class="line">                      <span class="keyword">continue</span> = <span class="number">0</span>;<span class="comment">//退出循环</span></span><br><span class="line">                      p = p-&gt;right;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> R: <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(p != <span class="literal">NULL</span> || !stackempty(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>元字符的使用</title>
    <url>/post/38072.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="元字符"><a class="markdownIt-Anchor" href="#元字符"></a> 元字符</h3>
<p>元字符指的是Linux中有特殊含义的字符，例如 ； 换行符等。</p>
<h3 id="字符引用和转义"><a class="markdownIt-Anchor" href="#字符引用和转义"></a> 字符引用和转义</h3>
<p>如果不想用元字符内在含义，只想打出这个字符，那么就需要用到引用字符。</p>
<p>字符引用的方法有三种，使用反斜线，使用一对单引号或者使用一对双引号</p>
<p>例如 echo a ; b 这样就会把他们当成不同的指令，但是如果 <code>echo a\; b</code>这样就会当成同一个指令，实际上\是转义字符，转义字符指的是把一个字符从一中状态转移到另一种状态</p>
<p>单引号会将一切字符引用，这样有时例如我需要引用其中一个变量的值的时候就会出现问题</p>
<p>这时我们就可以用到双引号，双引号不会引用 $ , \ , `(反引号），</p>
<p>引用能力强弱 <code>\&gt;''&gt;&quot;&quot;</code></p>
<p>如果输入换行字符，单引号并不会转义它，但是\会转义它。</p>
<p>反引号作用是输出程序结果。例如</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot; There are `ps aux | wc -l` processes &quot;</span></span><br><span class="line">输出 there are <span class="number">268</span> processes</span><br></pre></td></tr></table></figure>
<p>反引号可以用 $(…)替代</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>位运算和移位运算</title>
    <url>/post/61738.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="与运算"><a class="markdownIt-Anchor" href="#与运算"></a> 与运算</h3>
<p>这里的与运算并不是平常的bool运算，而是按位与。这种运算比加减法快</p>
<p>符号： &amp;</p>
<p>例： 1010&amp;1000=1000 1001&amp;0110=0000</p>
<p>含义： 1&amp;1=1,1&amp;0=0,0&amp;1=0,0&amp;0=0，只要不是两个都是,1，那么结果就是0</p>
<p>应用：</p>
<ul>
<li>替换指定位的值</li>
</ul>
<p>一个典型应用就是大小写转换，如果平常转换我们可能要写一大堆，但是经过仔细观察后发现大写字母和小写字母之间差距只有第5位，如果第五位为0，就是大写字母，为1就是小写字母，所以只要<code>a&amp;0b11011111</code>这一段代码就可以完成小写到大写的转换</p>
<ul>
<li>清零</li>
</ul>
<p>通过 a&amp;0b00000000 ,可以快速的把某个数变成零</p>
<ul>
<li>消去最后一位 1</li>
</ul>
<p>x &amp; (x-1) 例如 x 1010 x-1 1001 ，计算之后1000。减1就是让最小的那个1变成0然后后面全是1</p>
<ul>
<li>找到最小一位1</li>
</ul>
<p>x &amp; (-x) 在lowbit函数中用到， -x=~（x-1），大于最小一位1的都由于取反变成0，然后最小一位1及其后面本来是0111…,取反变成1000…，而原来是100…，所以最终是00…0100…</p>
<h3 id="或运算"><a class="markdownIt-Anchor" href="#或运算"></a> 或运算</h3>
<p>符号： |</p>
<p>例： 1010|1000=1010 1001|0110=1111</p>
<p>含义： 1|1=1,1|0=1，0|1=1，0|0=0</p>
<p>应用：</p>
<ul>
<li>设定某一个数据位为1，例如想把第五位设为1，只要 a|0b00100000</li>
</ul>
<h3 id="异或"><a class="markdownIt-Anchor" href="#异或"></a> 异或</h3>
<p>符号： ^</p>
<p>例： 1010^1000=0010, 1001^0110=1111</p>
<p>含义： 1<sup>1=0,1</sup>0=1,0<sup>1=1,0</sup>0=0，同为假，异为真</p>
<p>应用：</p>
<ul>
<li>
<p>x^11111…=~x;</p>
</li>
<li>
<p>异或满足交换率，结合率</p>
</li>
<li>
<p>x<sup>x=0,x</sup>0=x,自己是自己的逆元，0是幺元</p>
</li>
<li>
<p>a<sup>b</sup>a=b,因此可以用这种性质做许多应用，一个应用就是交换两个变量的值</p>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*&amp; a,<span class="keyword">int</span>*&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a=*a ^ *b;  <span class="comment">//a=a^b</span></span><br><span class="line">    *b=*a ^ *b; <span class="comment">//b=a^b^b=a</span></span><br><span class="line">    *a=*a ^ *b; <span class="comment">//a=a^b^a=b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还可以用来检查重复数或者在其余都是偶数个重复数字中找到一个奇数</p>
<p>例：1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现<br />
一次。每个数组元素只能访问一次</p>
<p>将所有的数全部异或，得到的结果与1<sup>2</sup>3<sup>…</sup>1000的结果进行异或，得到的结果就是重复数。</p>
<h3 id="按位非"><a class="markdownIt-Anchor" href="#按位非"></a> 按位非</h3>
<p>符号： ~</p>
<p>例： ~ 1001=0110， ~1010=0101</p>
<p>含义： <sub>1=0，</sub>0=1 ,取反</p>
<p>应用：</p>
<ul>
<li>
<p>对于有符号数 <code>~a=-(a+1)</code>,因为一般采用补码，而补码的负数就是正数-1再取反得到，所以<sub>(a-1)=-a，可得</sub>a=-(a+1)</p>
</li>
<li>
<p>把最低位变成0，a&amp;~1</p>
</li>
</ul>
<h3 id="左移"><a class="markdownIt-Anchor" href="#左移"></a> 左移</h3>
<p>符号： &lt;&lt;</p>
<p>例 00001010&lt;&lt;1 =&gt; 00010100</p>
<p>含义： 把所有的位向左移位，高位删去，低位补零，相当于乘上2的n次方</p>
<p>注意：如果移动次数超过了最高位，那么这是一个未定义行为。所以不同编译器，不同cpu对其有不同解释。gcc会将其自动变成0，而微软的编译器会先将移动位数模上最大位数然后再左移相应位数。cpu中也是取模的方式。</p>
<p>例如</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int a=<span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attribute">b</span>=a&lt;&lt;<span class="number">40</span><span class="comment">;//此时b=0，因为这个命令是在编译器中完成的</span></span><br><span class="line">a&lt;&lt;=<span class="number">40</span><span class="comment">;//此时a！=0，因为这个命令是在cpu中完成的</span></span><br></pre></td></tr></table></figure>
<h3 id="右移"><a class="markdownIt-Anchor" href="#右移"></a> 右移</h3>
<p>符号： &gt;&gt;</p>
<p>含义 将所有位向右移位，高位视情况而定，低位舍弃</p>
<p>视情况而定是因为实际上有两种右移，第一种是逻辑右移，第二种是算术右移</p>
<ul>
<li>逻辑右移，高位直接取0</li>
<li>算术右移，高位要看情况，如果原来最高位是0，则取0。如果最高位是1，则后面加的都是1.</li>
</ul>
<p><strong>逻辑右移的符号： &gt;&gt;&gt;</strong>(java)</p>
<p>那什么时候用逻辑右移还是算术右移呢？一般来说，有符号数算术右移，无符号数逻辑右移。因为有符号数用的是补码，如果是负数右移最高位补1才能让这个数还是负数</p>
<p>应用：</p>
<ul>
<li>不用-号把1变成-1</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="attribute">a</span>&gt;&gt;=<span class="number">31</span>;//最高位为<span class="number">1</span>，其余都为<span class="number">0</span></span><br><span class="line"><span class="attribute">a</span>&lt;&lt;=<span class="number">31</span>;//都为<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="右移运算对整数的影响"><a class="markdownIt-Anchor" href="#右移运算对整数的影响"></a> 右移运算对整数的影响</h4>
<p>右移运算相当于除2，之后低位相当于小数点后面的数字。这时我们把它截断相当于取整，对于无符号数和有符号数中的非负数，这个取整是没什么影响的，但对于有符号数中的负数，取整却与除法取整有所偏差。</p>
<p>除法取整是趋向于零。也就是说，非负数向下取整，负数向上取整。而右移确是把小数后面的数全部舍弃，就相当于让这个数更小了。</p>
<p>例如： 假如右移后是 -1234.32423，结果是-1235.因为把小数点舍弃会使这个数更小。</p>
<p>有一种情况除外。就是右移产生的小数点位中全是0，这时舍弃它并不会产生影响，所以不会发生向下取整。</p>
<p>为了解决这个问题，一种办法就是 <code>(x+2^k-1)&gt;&gt;k</code>，为了加快速度，可以写成<code>(x+1&lt;&lt;k-1)&gt;&gt;k</code></p>
<p>现在来看这个式子的正确性，当最后几位全为0时，例如1000000右移三位，那么2^3-1=0b111,因为本来这个结果就是正确答案，现在加上111并没有改变它的值，0b1111000.111后面三位舍弃与原来相同，因此这个时候结论正确</p>
<p>如果后面不是全为0，那么这时必定产生进位，例如1101右移三位那么加上之后必定会使第四位进一位，这时我们再右移三位，便相当于让原来的答案加一，达到了向上取整的效果</p>
<p>最后，只有在有符号数中的负数中才要采用这种算法，在非负数中直接右移即可</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>内中断</title>
    <url>/post/44914.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一般cpu都有一种能力，就是接受cpu内部或外部发来的信号，停止当前程序而取执行其他的程序。这种信息叫做中断信息，中断信息指的是cpu接受到这种信息后立刻处理这个信息。接受到这个信息后cpu会交给专门的程序去处理，叫做中断处理程序</p>
<h3 id="内中断"><a class="markdownIt-Anchor" href="#内中断"></a> 内中断</h3>
<p>内中断指的是中断信息来自cpu内部。当cpu接受到相应几种情况时，会产生相应的中断信息</p>
<ol>
<li>除法错误 例如 ，div除法溢出</li>
<li>单步执行</li>
<li>执行into指令</li>
<li>执行int 指令</li>
</ol>
<p>我们先不需要了解具体含义。为了更方便的知道到底属于那种中断信息，8086cpu用了一个字节的中断类型码来确定。</p>
<ol>
<li>除法错误 0</li>
<li>单步执行 1</li>
<li>执行into指令 4</li>
<li>int： int n ，n就是中断类型码</li>
</ol>
<p>cpu根据cs:ip知道程序的入口，所以中断类型码中必定有cs:ip的信息，可cpu如何根据8位的类型吗知道程序的入口呢？</p>
<h3 id="中断向量表"><a class="markdownIt-Anchor" href="#中断向量表"></a> 中断向量表</h3>
<p>cpu通过中断类型码找到中断向量表，而中断向量表中就保存着程序的入口。中断向量表在内存中保存。中断内存表位于0000:0000 到 0000:03ff 1024个字节中</p>
<h3 id="中断过程"><a class="markdownIt-Anchor" href="#中断过程"></a> 中断过程</h3>
<p>找到cs：ip的过程叫做中断过程。</p>
<p>cpu收到中断信息后，要对中断信息进行处理。但是完成中断程序之后还要返回，就像call和ret一样。所以总过程如下</p>
<ol>
<li>获得中断类型码</li>
<li>标志寄存器的值入栈（因为中断过程会改变标志寄存器的值）</li>
<li>设置标志寄存器第8位和第九位的值为0</li>
<li>cs入栈</li>
<li>ip入栈</li>
<li>设置cs：ip</li>
</ol>
<p>更简洁的说明</p>
<ol>
<li>获得 中断类型码 n</li>
<li>pushf</li>
<li>tf=0 if=0</li>
<li>push cs</li>
<li>push ip</li>
<li>ip=n<em>4，cs=n</em>4+2</li>
</ol>
<h3 id="iret指令"><a class="markdownIt-Anchor" href="#iret指令"></a> iret指令</h3>
<p>中断处理程序用iret进行返回</p>
<p>内容</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pop</span> <span class="built_in">ip</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">cs</span></span><br><span class="line"><span class="keyword">popf</span></span><br></pre></td></tr></table></figure>
<p>这个正好与进栈顺序相反</p>
<h3 id="除法错误中断的处理"><a class="markdownIt-Anchor" href="#除法错误中断的处理"></a> 除法错误中断的处理</h3>
<p>cpu如果产生除法溢出错误，将会产生中断类型码为0的中断信息。引发中断过程。然后中断处理程序会返回 divide overflow 再返回到主程序中</p>
<h3 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h3>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span> do0安装程序</span><br><span class="line">     设置中断向量表</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00h</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol"> do0:</span> 显示字符串“overflow！”</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>注意：do0也要返回</p>
<h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3>
<p>用movsb指令，将do0的代码送入0:200处</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> 设置<span class="built_in">es</span>:<span class="built_in">di</span>指向目的地址</span><br><span class="line">     设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向源地址</span><br><span class="line">     设置传输长度</span><br><span class="line">     设置传输方向为正</span><br><span class="line">     <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line">     </span><br><span class="line">     设置中断表</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>
<p>我们如何知道do0代码长度？</p>
<p>可以用编译器来知道do0的长度</p>
<p><code>mov cx,offset do0end-offset do0</code></p>
<p>“-”是编译器识别的符号，编译器可以用它来做两个常数的减法</p>
<p>例如 mov ax,(5+3)*5/10 被编译器识别为 mov ax，4</p>
<h3 id="do0"><a class="markdownIt-Anchor" href="#do0"></a> do0</h3>
<p>do0的主要任务是显示字符串</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">do0:</span> 设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向字符串</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">9</span></span><br><span class="line"><span class="symbol">  s:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">do0end:</span><span class="keyword">nop</span></span><br></pre></td></tr></table></figure>
<p>这个程序看起来对，实际上有问题，因为程序执行完后内存立刻被释放，其中保存的内容也可能被其他的程序覆盖。正确的程序如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="symbol">do0:</span> <span class="keyword">jmp</span> short do0start</span><br><span class="line">   <span class="built_in">db</span> <span class="string">&quot;overflow!&quot;</span></span><br><span class="line"><span class="symbol">do0start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">202h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">9</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span>//用<span class="keyword">iret</span>也可以，用的话表示还会返回主程序中</span><br><span class="line"><span class="symbol">do0end:</span> <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="设置中断向量"><a class="markdownIt-Anchor" href="#设置中断向量"></a> 设置中断向量</h3>
<p>现在do0的入口为 0:200 ,写入中断向量表的0号表项中。使do0成为0号中断处理程序<br />
0号表项地址为0:0 ，其中0:0存放偏移地址，0:2存放段地址。程序如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="单步中断"><a class="markdownIt-Anchor" href="#单步中断"></a> 单步中断</h3>
<p>cpu执行完一条指令后，如果检测到tf=1，则产生单步中断，单步中断类型码为1，过程如下</p>
<ol>
<li>获得中断类型码</li>
<li>标志寄存器入栈，tf if设置为0</li>
<li>cs，ip入栈</li>
<li>ip=1<em>4 cs=1</em>4+2</li>
</ol>
<p>cpu为什么要提供单步中断呢？在debug的t命令中，为什么执行完一条 指令后，能够实时的反映寄存器的状态？这便是cpu单步中断导致可以一条条指令执行</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>储存设备与缓存</title>
    <url>/post/7d1c86da.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="机械硬盘"><a class="markdownIt-Anchor" href="#机械硬盘"></a> 机械硬盘</h1>
<p><img src="/images/%E7%A1%AC%E7%9B%98.jpg" alt="" /></p>
<p>结构： 由若干个盘片组成，每个盘片有2两面，每一面上有若干个磁道（柱面就是指和中心轴平行的圆柱面，有多个每个盘上都有两个磁道在上面） ，每个磁道上又划分成若干个扇区，扇区是数据访问的最小单位。中间的轴在不停转动。每个扇区都有一个编号。</p>
<p>显然如果扇区划分时是从中心发出多根射线的话是不好的。因为内圈的扇区划分小，外面的扇区划分大，因此每个扇区读写数据数目可能会有较大的差距。但是很可能只需要利用其中很小一部分，这样就造成了浪费。所以磁道与磁道之间扇区数目是不同的，尽量使数据分布均匀。</p>
<p>图中左边的架子是读写头，可以前后滑动。数据就是通过读写头进行读写的。</p>
<p><strong>大致过程</strong>：先移动到对应扇区（寻道），然后等待读写头划过我们要读取的扇区。之后在读取这个扇区。要注意即使只需要读取一个字节也要把这个扇区全部读取完。如果是写的话，先把扇区中数据读取出来，然后再在这些数据中进行更改，最后再把这些数据写入到扇区中。</p>
<p>一般寻道在2-9ms，旋转也是10ms左右，而读取只需要0.02ms，所以说大头都在寻找过程中。并且要比dram慢2500倍，比sram慢40000倍。</p>
<blockquote>
<p>旋转时间如果没有特殊规定一般都是算旋转半圈的时间，而读取时间一般使用旋转一圈时间/扇区数得到</p>
</blockquote>
<p>机械硬盘扇区的读取次数是由限制的，大概是十万到100万次左右。如果某一扇区坏了是不是会导致整个硬盘都异常呢？当然这是不可能的，那样也太不经用了。</p>
<p>为了解决这个问题，可以用逻辑编号代替物理编号，然后用一定的映射规则转换到物理编号，如果某一个扇区损坏，硬盘中有一些备用的扇区可以替补上，这样就可以解决某一个扇区损坏的问题。可能某些逻辑扇区会被频繁的使用，如果对应规则是确定的那么可能很快那个扇区就会损坏，所以对应规则也要不断变化使每个扇区利用大致平均。</p>
<h2 id="寻道算法"><a class="markdownIt-Anchor" href="#寻道算法"></a> 寻道算法</h2>
<ul>
<li>FCFS（先来先服务）： 这种算法就是先来的请求先服务。但是固态采用的是这种算法（因为不需要考虑寻道时间）</li>
<li>SSTF（最短位置优先）： 这种算法是在所有请求中找到距离他最近的</li>
<li>SCAN（电梯算法）： 先一直朝着某个方向走，这个方向没有之后再往反方向走，这种在实际中有应用</li>
<li>CSCAN(循环电梯算法）： 这种方法时一直朝一个方向走，到了顶部又直接放回底部重新扫描</li>
</ul>
<p>例：现在在15磁道。请求有81， 47， 90， 18， 5.并且现在向上走</p>
<p>FCFS： 15-&gt;81, 81-&gt;47, 47-&gt;90, 90-&gt;18, 18-&gt;5</p>
<p>SSTF: 15-&gt;18, 18-&gt;5, 5-&gt;47, 47-&gt;81, 81-&gt;90</p>
<p>SCAN: 15-&gt;47, 47-&gt;81, 81-&gt;90, 80-&gt;18, 18-&gt;5</p>
<h2 id="磁盘raid"><a class="markdownIt-Anchor" href="#磁盘raid"></a> 磁盘RAID</h2>
<p>磁盘RAID是在逻辑卷出来之前为了多个磁盘同时使用而想出来的算法。首先要求这些磁盘大小相同</p>
<h3 id="raid0"><a class="markdownIt-Anchor" href="#raid0"></a> RAID0</h3>
<p>RAID0就是将一个文件拆分成多个部分，然后同时写和读。但是有一个相当大的问题是如果一个磁盘坏了那么所有文件都坏了。</p>
<h3 id="raid1"><a class="markdownIt-Anchor" href="#raid1"></a> RAID1</h3>
<p>RAID1是从一个极端到了另一个极端。例如有两份磁盘，那么他将把一份数据写到两份磁盘中。这样写的效率毫无疑问是低的，但是读的效率还行（因为可以两个磁盘同时读），并且浪费一半的空间</p>
<h3 id="raid10"><a class="markdownIt-Anchor" href="#raid10"></a> RAID10</h3>
<p>RAID10并不是10而是RAID1和RAID0的组合<br />
<img src="/images/%E5%82%A8%E5%AD%98%E8%AE%BE%E5%A4%87%E5%92%8C%E7%BC%93%E5%AD%981.PNG" alt="" /><br />
这种兼顾读写效率和可靠性，但是同样要浪费一半的空间</p>
<h3 id="raid5"><a class="markdownIt-Anchor" href="#raid5"></a> RAID5</h3>
<p>RAID5是现在一般使用的技术。RAID5同样是把一个文件拆分成多个文件写（一般是以块为单位拆分）。但是现在每个磁盘都储存着其他磁盘文件的恢复信息。例如2磁盘存着1磁盘的信息，3磁盘存着2磁盘的信息。这样如果一个磁盘损坏另外的磁盘还可以恢复信息。</p>
<p>会浪费一块磁盘的空间</p>
<h3 id="raid4"><a class="markdownIt-Anchor" href="#raid4"></a> RAID4</h3>
<p>RAID4是单独拿一块盘出来保存一些恢复信息，但是这样如果校验盘坏了就非常危险。</p>
<h3 id="raid67等"><a class="markdownIt-Anchor" href="#raid67等"></a> RAID6，7等</h3>
<p>市面上说的RAID6就是多出一块盘来做备用，如果一块盘坏了这块盘立刻读取恢复信息并工作。这实际上是RAID5。实际上是有RAID6的技术的，但是一般不采用</p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p><img src="/images/%E5%82%A8%E5%AD%98%E8%AE%BE%E5%A4%87%E5%92%8C%E7%BC%93%E5%AD%982.PNG" alt="" /></p>
<h1 id="固态硬盘ssd"><a class="markdownIt-Anchor" href="#固态硬盘ssd"></a> 固态硬盘（ssd）</h1>
<p>结构： 固态硬盘最小的结构是页，每一页有若干个字节。之后若干个页组成了块。它是由闪存构成的（就是usb所使用的）</p>
<p>读写过程：读的过程是以<strong>页</strong>作为单位，也需要通过一定的映射使之利用均衡。但是写的过程却是以<strong>块</strong>作为单位，就算只改一个字节也需要读取整个块，并且写的过程中需要先把原来的内容全部擦除，所以写过程比读过程慢的多。</p>
<p>ssd好处是读写较快，但是价格贵，并且读写次数少，只有1万到10万次。</p>
<h1 id="局部性和高速缓存"><a class="markdownIt-Anchor" href="#局部性和高速缓存"></a> 局部性和高速缓存</h1>
<p>局部性分为时间局部性和空间局部性。</p>
<p>时间局部性指的是在短时间内多次重复使用某个内存。</p>
<p>空间局部性指的是一个内存被使用，很可能接下来会使用这段内存附近的数据。</p>
<p>现代计算机cpu运算速度已经很快了，但是内存的访问速度却跟不上cpu的运算速度。因此现在更重要的是解决内存读取速度的问题。</p>
<p>根据上面所说的局部性原理（这是人们通过大量观察总结得出的规律），人们想到可以把常用的数据放在一个更快的储存器里，这样就可以提高运算速度。</p>
<p>于是就有了高速缓存。高速缓存（cahce）是用sram制成的，它的速度很快但是容量很小，直接集成到了cpu内部，每次cpu访问内存的时候都会先从高速缓存中读取。如果高速缓存中没有才会去内存中查找。从内存中取出数据并不是只取那几个字节，而是把附近的指令都放到高速缓存中（因为局部性原理），这样就可以提高速度。</p>
<h1 id="高速缓存运行原理"><a class="markdownIt-Anchor" href="#高速缓存运行原理"></a> 高速缓存运行原理</h1>
<h2 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构"></a> 基本结构</h2>
<p><img src="/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png" alt="" /></p>
<p>一共有S个组，每个组有E行，每行有B个字节。S，E，B都是2的n次方，记S是2的s次方，E是2的e次方，B是2的b次方。</p>
<p>每一行的B字节都是由三部分组成。最高位叫做有效位，用来判定这一行中是否储存了数据。之后又t字节标记位，用来进行判别，后面的位才是实际从内存中取出来的内容。</p>
<p>每次cpu访问一个地址时，可以把地址分成3个部分。最低b位是块偏移，中间s位是组索引，高t位是标记。</p>
<p>进行查询时，先用中间s位找出组索引。例如中间s位是010，那么组索引是2.找到组索引后就用高t位的标记进行比对，如果对应行中最高位为1且标记位正好符合那么就通过最后的b字节找到块偏移。然后取出数据。</p>
<p>注意，我们只需要找到对应的组就行了，cpu可以自动对该组所有行同时进行比对而不用一一比对。</p>
<p>例  cpu发出一个指令，要从0111位置取出两字节数据。首先高速缓存中有四组，每组一行。每行四字节。所以这里块偏移是1组索引是11，标记是0.那么我们先通过中间的11确定是第三组，之后再和第三组最高位为1的进行比对，如果有一行标记位正好是0，那么就算出偏移量是1，所以从后面开始的第一位（有第零位）取出两个字节。</p>
<h2 id="直接映射高速缓存"><a class="markdownIt-Anchor" href="#直接映射高速缓存"></a> 直接映射高速缓存</h2>
<p>直接映射高速缓存的特点是每一组只有一行。所以找到组后直接进行比对即可。但是这里有一个问题，例如组索引是1，标记位有两位。那么可能频繁的取出组索引相同但是标记位不同的数据，那么我们就要频繁的从内存中取出数据（miss），这样就降低了速度。</p>
<h2 id="组相联高速缓存"><a class="markdownIt-Anchor" href="#组相联高速缓存"></a> 组相联高速缓存</h2>
<p>组相联高速缓存和直接告诉缓存的不同是组相联高速缓存中每一组有多个行，这样就更可以存放更多的标记位，miss的可能性也就越低。但是这个的问题是因为要同时访问多行，所以硬件设计比较困难。</p>
<h2 id="全相连高速缓存"><a class="markdownIt-Anchor" href="#全相连高速缓存"></a> 全相连高速缓存</h2>
<p>全相连高速缓存中只有一个组，因此没有组索引（想要有组索引最少要有两个组）。</p>
<p>因此把cpu发送的内存地址分成两个部分，块偏移和标记。因为没有组索引，所以这两部分一般比较大。它可以同时匹配所有的行，也就少了寻找组索引的计算，但是如果行太多设计极为困难，所以只适合做小的高速缓存。</p>
<h2 id="直写与回写"><a class="markdownIt-Anchor" href="#直写与回写"></a> 直写与回写</h2>
<p>直写就是每次都要写到内存或者硬盘中，回写就是每次先在缓存中写，等到这个缓存被替换的时候再写回。毫无疑问回写要快，但是直写也有用武之地。</p>
<h2 id="块替换策略"><a class="markdownIt-Anchor" href="#块替换策略"></a> 块替换策略</h2>
<p>每次未命中时并且缓存中已经全部使用的时候就要进行块替换。块替换有两种策略，第一种是把最近没有使用的块替换出去，第二种是把最不经常使用的块替换出去。</p>
]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>决策树算法</title>
    <url>/post/ef296a07.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构"></a> 基本结构</h1>
<p>决策树是一个类似流程图的树形结构：其中，每个节点表示在一个属性上的测试。每个分支表示一个输出，每个树叶节点代表类或类的分布。</p>
<p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%91.PNG" alt="" /></p>
<p>上面这个例子中play和don’t play是结果，表示玩还是不玩。然后不是叶结点的节点都有一个问号，例如第一个outlook询问的是天气，后面还有湿度和是否刮风。通过这些条件得到了叶节点，叶结点都是只包含一种情况，要么是play要么是don’t play</p>
<p>熵： 不确定性的多少，越不确定的信息信息熵越大。</p>
<p>我们可以用比特(bit)来衡量信息的多少。公式为每种事情的概率* 以二为底该事情概率的对数。</p>
<p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%912.PNG" alt="" />.变量不确定性越大，熵也就越大。</p>
<p>例如，我们想要知道世界杯谁会夺冠，我们可以从往届比赛中得知每个球队夺冠的大致概率，然后从而推测出bit的大小。</p>
<h1 id="决策树归纳算法id3"><a class="markdownIt-Anchor" href="#决策树归纳算法id3"></a> 决策树归纳算法（ID3）</h1>
<p>决策树适合小规模，类别比较少的数据集。</p>
<p>我们通过什么确定该节点应该是什么问题呢?</p>
<p>信息获取量 Gain(A) = info(D) - info_A(D)</p>
<p>info(D)表示只考虑结果时信息量（bit值）。 info_A(D)表示考虑A后的信息量</p>
<p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%913.PNG" alt="" /></p>
<p>上面这个例子中，后面age的计算是该种类的概率（如5/14或4/14等）* 在这个种类里的信息获取量。上面青年有五种，然后求得五种里买电脑或者不买电脑的信息获取量。</p>
<p>最后可以求得gain，然后选取gain最大的作为该节点。 通过划分后如果只有一种目标，那么划分结束，如果有多种目标，那么重新用这种方法选取gain最大的。</p>
<p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%914.PNG" alt="" /></p>
<p>如果所有属性都用完了，那么采用多数表决，即哪个结果多就把它划分成哪个类。例如最后所有属性都使用了一遍，最后三人买电脑，两人不买电脑，那么最后就把它划分成买电脑类。</p>
<p>如果分的太细也可能出现问题。所以有时候达到一定纯度就不再往下分。还可以先全部分完然后再剪。</p>
<h1 id="运用"><a class="markdownIt-Anchor" href="#运用"></a> 运用</h1>
<p>python中有一个scikit-learn库包含了决策树。</p>
<p>首先sklearn要求输入的属性值必须是数值型的值而不能是young，old之类模糊的数据。</p>
<p>具体可以变成由0和1组成的集合。例如假如是young，那么按照young Middle old排列的话取值是100，如果是middle那么就是010.</p>
<p>所有特征值形成了一串0和1,以这个作为输入。</p>
<p>python中提供了一个函数可以直接把属性转化成01， 他叫DictVectorizer(),使用它的条件是我们把属性转化成了一个列表（所有样例构成一个列表，但是单个样例可以用字典进行描述)</p>
<p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%915.PNG" alt="" />这是上例所形成的列表</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">vec</span> = DictVectorizer()</span><br><span class="line"><span class="attr">dummyx</span> = vec.fit_transform(featurelist).toarray()</span><br></pre></td></tr></table></figure>
<p>输出<br />
<img src="/images/%E5%86%B3%E7%AD%96%E6%A0%916.PNG" alt="" /></p>
<p>这是对于特征值的，对于目标标记也有专门的方法</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">lb</span> = processing.LabelBinarizer()</span><br><span class="line"><span class="attr">dummyY</span> = lb.fit_transform(labellist)</span><br></pre></td></tr></table></figure>
<p><strong>创建分类器</strong></p>
<p>前面都是对数据进行预处理，预处理完毕之后我们就要把它转换成决策树模型了。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">clf</span> = tree.DecesionTreeClassifier(criterion = <span class="string">&#x27;entropy&#x27;</span>) <span class="comment">#criterion是使用的决策树算法，具体可以看文档</span></span><br><span class="line"><span class="attr">ans</span> = clf.fit(dummyX, dummyY)</span><br></pre></td></tr></table></figure>
<p><strong>可视化</strong></p>
<p>虽然我们产生了结果，但是结果非常不直观，我们可以用graphviz将结果变成上面看到的图。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">&quot;allElectronicInformationGainOri.dot&quot;</span>, <span class="character">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f = tree.export<span class="constructor">_graphviz(<span class="params">clf</span>, <span class="params">feature_names</span>=<span class="params">vec</span>.<span class="params">get_feature_names</span>()</span>, out_file=f) # feature_names是属性的名字，因为在形成决策树过程中全变成<span class="number">0</span>和<span class="number">1</span>了</span><br></pre></td></tr></table></figure>
<p>通过这两行代码可以把结果输出到文件中<img src="/images/%E5%86%B3%E7%AD%96%E6%A0%917.PNG" alt="" />可以看到结果非常不直观，因此我们还需用graphviz进一步转化。</p>
<p>在cmd中输入<code>dot -Tpdf iris.dot -o output.pdf</code> iris.dot是原始文件的路径，-o是输出文件名</p>
<p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%918.PNG" alt="" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.externals.six <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in the csv file and put features into list of dict and list of class label</span></span><br><span class="line">allElectronicsData = <span class="built_in">open</span>(<span class="string">r&#x27;/home/zhoumiao/MachineLearning/01decisiontree/AllElectronics.csv&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">reader = csv.reader(allElectronicsData)</span><br><span class="line">headers = reader.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">print(headers)</span><br><span class="line"></span><br><span class="line">featureList = []</span><br><span class="line">labelList = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">    labelList.append(row[<span class="built_in">len</span>(row)-<span class="number">1</span>])</span><br><span class="line">    rowDict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(row)-<span class="number">1</span>):</span><br><span class="line">        rowDict[headers[i]] = row[i]</span><br><span class="line">    featureList.append(rowDict)</span><br><span class="line"></span><br><span class="line">print(featureList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Vetorize features</span></span><br><span class="line">vec = DictVectorizer()</span><br><span class="line">dummyX = vec.fit_transform(featureList) .toarray()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;dummyX: &quot;</span> + <span class="built_in">str</span>(dummyX))</span><br><span class="line">print(vec.get_feature_names())</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;labelList: &quot;</span> + <span class="built_in">str</span>(labelList))</span><br><span class="line"></span><br><span class="line"><span class="comment"># vectorize class labels</span></span><br><span class="line">lb = preprocessing.LabelBinarizer()</span><br><span class="line">dummyY = lb.fit_transform(labelList)</span><br><span class="line">print(<span class="string">&quot;dummyY: &quot;</span> + <span class="built_in">str</span>(dummyY))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using decision tree for classification</span></span><br><span class="line"><span class="comment"># clf = tree.DecisionTreeClassifier()</span></span><br><span class="line">clf = tree.DecisionTreeClassifier(criterion=<span class="string">&#x27;entropy&#x27;</span>)</span><br><span class="line">clf = clf.fit(dummyX, dummyY)</span><br><span class="line">print(<span class="string">&quot;clf: &quot;</span> + <span class="built_in">str</span>(clf))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize model</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;allElectronicInformationGainOri.dot&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f = tree.export_graphviz(clf, feature_names=vec.get_feature_names(), out_file=f)</span><br><span class="line"></span><br><span class="line">oneRowX = dummyX[<span class="number">0</span>, :]</span><br><span class="line">print(<span class="string">&quot;oneRowX: &quot;</span> + <span class="built_in">str</span>(oneRowX))</span><br><span class="line"></span><br><span class="line">newRowX = oneRowX</span><br><span class="line">newRowX[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">newRowX[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">print(<span class="string">&quot;newRowX: &quot;</span> + <span class="built_in">str</span>(newRowX))</span><br><span class="line"></span><br><span class="line">predictedY = clf.predict(newRowX) <span class="comment"># 创建一个新的节点然后预测</span></span><br><span class="line">print(<span class="string">&quot;predictedY: &quot;</span> + <span class="built_in">str</span>(predictedY))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>内联汇编</title>
    <url>/post/51e63dcf.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>内联汇编是在c语言代码中插入一段汇编语言，这在一些特殊的场合如操作系统中经常使用。有些时候我们想加快速度或者进行某些特殊的操作就可以使用内联汇编。</p>
<h1 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h1>
<blockquote>
<p><strong>关键字</strong>： asm</p>
</blockquote>
<p>例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;movl %eax, %ebx&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<strong>volatile</strong>的含义是告诉编译器这段代码不需要优化，原封不动的让他执行。</p>
<p>语法：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">asm(</span><br><span class="line">   汇编语言模板</span><br><span class="line">   : output operands <span class="regexp">/*可选*/</span></span><br><span class="line">   : input operands <span class="regexp">/*可选*/</span></span><br><span class="line">   : options     <span class="regexp">/*可选*/</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可以只有output operands或只有input operands。但是如果有options，那么前面两个冒号都要打.</p>
<p>options表示我们最多使用哪些寄存器。</p>
<h2 id="汇编模板"><a class="markdownIt-Anchor" href="#汇编模板"></a> 汇编模板</h2>
<p>可以使用<a href="https://xinhecuican.github.io/post/1326.html">AT&amp;T语法</a>，也可以使用intel语法（没有测试过）。下面以AT&amp;T模板作为例子。</p>
<p>它的语法和和汇编语言完全类似，同样是寄存器用%，立即数用$, 内存访问用<code>()</code>。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>如果有多行汇编语句，那么语句与语句之间要用\n\t分隔开</li>
<li>如果使用了%0,%1等标识，那么寄存器就需要用两个%%标识</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;movl %0, %%eax\n\t&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;pushl %%eax\n\t&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    :<span class="string">&quot;a&quot;</span>(a)</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="输出和输入部分"><a class="markdownIt-Anchor" href="#输出和输入部分"></a> 输出和输入部分</h2>
<p>他们的格式都是 <code>&quot;restriction&quot;(value)</code>，其中restriction表示这个变量要使用哪个寄存器或者表示内存或者是立即数。而value就是外带的变量。</p>
<p>如果是输出部分，在restricttion前还要加个等号。如 “=a”(output)</p>
<p>在定义了输入和输出部分之后，就可以把这些变量用于汇编语句中了。我们可以用%0,%1…%9表示变量。也就是说最多有是个输入输出部分。例如</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">input</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">output</span> = <span class="number">1</span>;</span><br><span class="line">asm volatile(</span><br><span class="line">    <span class="string">&quot;addl %1, %0&quot;</span></span><br><span class="line">    :<span class="string">&quot;=r&quot;</span>(<span class="keyword">output</span>)</span><br><span class="line">    :<span class="string">&quot;r&quot;</span>(<span class="keyword">input</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面就是一个简单的1+1并且把值赋到output中。output是第0个，input第第一个，所以%0表示output,%1表示input.</p>
<h2 id="限制"><a class="markdownIt-Anchor" href="#限制"></a> 限制</h2>
<p>输入输出部分前面的限制有很多，这里列举一些常用的</p>
<table>
<thead>
<tr>
<th>限制</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>表示 eax,ax,ah,al</td>
</tr>
<tr>
<td>b</td>
<td>表示 ebx, …</td>
</tr>
<tr>
<td>c</td>
<td>表示 ecx, …</td>
</tr>
<tr>
<td>d</td>
<td>表示 edx, …</td>
</tr>
<tr>
<td>S</td>
<td>表示 esi</td>
</tr>
<tr>
<td>D</td>
<td>表示 edi</td>
</tr>
<tr>
<td>r</td>
<td>指定任意一个寄存器</td>
</tr>
<tr>
<td>m</td>
<td>表示内存</td>
</tr>
<tr>
<td>p</td>
<td>表示操作数是一个指针</td>
</tr>
<tr>
<td>X</td>
<td>可以是任意类型</td>
</tr>
<tr>
<td>i</td>
<td>立即数</td>
</tr>
<tr>
<td>数字0,1,2,…</td>
<td>表示这个操作数和前面的某个操作数相同，一般在输入和输出在同一个变量时使用</td>
</tr>
<tr>
<td>f</td>
<td>浮点数</td>
</tr>
<tr>
<td>&amp;</td>
<td>避免使用同一个寄存器</td>
</tr>
</tbody>
</table>
<p>访问内存方式：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> input = <span class="number">0x7fffffc</span>;</span><br><span class="line">asm <span class="keyword">volatile</span>(</span><br><span class="line">    &quot;movl %%eax, (%0)&quot;</span><br><span class="line">    : &quot;r&quot;(<span class="keyword">input</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">input = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">asm <span class="keyword">volatile</span> (&quot;addl %1,%0&quot;:&quot;+r&quot;(result):&quot;m&quot;(<span class="keyword">input</span>));</span><br></pre></td></tr></table></figure>
<p>一个具体应用</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void (*handler)();</span><br><span class="line"><span class="function"><span class="title">handler</span> = myproc()-&gt;</span><span class="function"><span class="title">tf</span>-&gt;</span>handler;</span><br><span class="line">uint addr = (uint)*handler;</span><br><span class="line"><span class="function"><span class="title">myproc</span>()-&gt;</span><span class="function"><span class="title">tf</span>-&gt;</span>esp -= <span class="number">4</span>;</span><br><span class="line">asm volatile(</span><br><span class="line">    <span class="string">&quot;movl %0, (%1)\n\t&quot;</span></span><br><span class="line">    : <span class="string">&quot;r&quot;</span>(<span class="function"><span class="title">myproc</span>()-&gt;</span><span class="function"><span class="title">tf</span>-&gt;</span><span class="function"><span class="title">eip</span>), &quot;r&quot;(myproc()-&gt;</span><span class="function"><span class="title">tf</span>-&gt;</span>esp)</span><br><span class="line">);</span><br><span class="line"><span class="function"><span class="title">myproc</span>()-&gt;</span><span class="function"><span class="title">tf</span>-&gt;</span>eip = addr;</span><br><span class="line"></span><br><span class="line">这段代码的作用是位于内核态时跳转到某一个函数，并且结束之后返回，asm中就是将返回地址存入栈中。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>分治法</title>
    <url>/post/7f3bcd7f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1>
<p>分治法是将大问题分解成若干个小问题，通过解决小问题解决大问题的方法。它和递归关系密切。</p>
<p>大致流程</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if(<span class="name">|P|</span> &lt;= n0) adhoc(<span class="name">p</span>)<span class="comment">;</span></span><br><span class="line">divide p into small k part<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">for(<span class="name">int</span> i=0<span class="comment">; i&lt;k; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">	yi = divide-and-conquer(<span class="name">pi</span>)<span class="comment">;</span></span><br><span class="line">    //递归解决各个子问题</span><br><span class="line">&#125;</span><br><span class="line">return merge(<span class="name">y1</span>,y2,...yk)<span class="comment">; 合并子问题的解</span></span><br></pre></td></tr></table></figure>
<h1 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h1>
<h2 id="找伪币"><a class="markdownIt-Anchor" href="#找伪币"></a> 找伪币</h2>
<p>假如有十六个硬币，有一个是伪币，伪币比较轻，试用一个天平找出伪币</p>
<p>假如两两比较，最坏情况需要8次</p>
<p>如果使用分治法，需要四次。首先8个8个比较，然后在轻的一堆中比较。</p>
<h2 id="计算an"><a class="markdownIt-Anchor" href="#计算an"></a> 计算a^n</h2>
<p>如果使用 a * a * a…。那么复杂度是O(n).使用分治法，</p>
<p>a^n = a^(n/2) * a^(n/2) n%2 == 0</p>
<p>a^n = a^(n/2) * a^(n/2) * a n%2 == 1</p>
<blockquote>
<p>所以 T(n) = T(n/2) + 0(1)</p>
</blockquote>
<p>其中T(n/2)是计算a^(n/2)所需要的时间， O(1)是两个数相乘需要的时间。由<a href="https://xinhecuican.github.io/post/71038564.html#more">主定理</a>可得，复杂度是 O(logn)。</p>
<p>可以看到，通过分治法，有时我们可以减少一些重复运算。</p>
<h2 id="大整数乘法"><a class="markdownIt-Anchor" href="#大整数乘法"></a> 大整数乘法</h2>
<p>两个大整数乘法直接相乘复杂度是O(n^2)（注意这里指的是每个bit相乘）<img src="/images/%E5%88%86%E6%B2%BB%E6%B3%951.PNG" alt="" /></p>
<p>如果把它分成两个部分,如图所示，那么乘法就可以变成</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">(a* <span class="number">2</span>^(<span class="built_in">n</span>/<span class="number">2</span>) + b)(c * <span class="number">2</span>^(<span class="built_in">n</span>/<span class="number">2</span>) + d)</span><br><span class="line">= ac * <span class="number">2</span>^<span class="built_in">n</span> + (ad+bc) *<span class="number">2</span>^(<span class="built_in">n</span>/<span class="number">2</span>) + bd</span><br></pre></td></tr></table></figure>
<p>递推公式为 <code>T(n) = 4*T(n/2) + 0(n)</code>其中O(n)是ad和bc等两个分式相加的复杂度而不是计算2<sup>n的复杂度。得到的复杂度为O(n</sup>2)，没有改进。</p>
<p>但是如果写成 <code>ac * 2^n +((a+b)(c+d)-ac-bd) * 2^(n/2) + bd</code>则复杂度就变成了O(n^1.59)。</p>
<h2 id="中间的中间问题"><a class="markdownIt-Anchor" href="#中间的中间问题"></a> 中间的中间问题</h2>
<p><img src="/images/%E5%88%86%E6%B2%BB%E6%B3%952.PNG" alt="" /><br />
如图，对这些数进行排序。我们可以把这些数分成5组，然后每组找中位数。然后在所有的中位数中寻找中位数（中位数的中位数）。再用找到的中位数的中位数进行排序。</p>
<p>提出这个方法是因为快速排序在最坏情况下复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，之所以可能是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是因为可能我们每次选的支点都可能是最小值。而这个算法就是为了避免这种情况。</p>
<p>我们已经找到中位数的中位数了（图中是10，多余的两个数可以不管）。也就是说在10这组前面有两组。因为前面每组都有三个数一定比10小。那么一定有3n/10个数比10小。</p>
<p>假设有n个数，找到n/5个中位数，又找中位数的中位数，那么一定有n/10个数比中位数小（n/5个中位数中有一半比他小）。因为中位数前面两个数字也一定比他小，所以总共是3n/10。</p>
<p>可以证明找中位数的中位数时间复杂度是O(n)</p>
<h2 id="最接近点对问题"><a class="markdownIt-Anchor" href="#最接近点对问题"></a> 最接近点对问题</h2>
<p>问题： 在二维平面上的n个点中，找出最接近的一对点</p>
<p>我们可以利用分治法进行求解。先用一个一条垂线将左右两边分隔开（一般选取中点），然后分别求左边最短距离和右边最短距离，然后比较这两个最短距离和中线两侧最短距离，找到最小值就是最接近的一组点。</p>
<p><img src="/images/%E5%88%86%E6%B2%BB%E6%B3%951.webp" alt="" /></p>
<p>问题的关键在于怎么找中线两侧的最短距离。</p>
<p>\delta = min{\deltaL, \deltaR},\deltaL是左边最短距离，\deltaR是右边最短距离。两侧最短距离一定要比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>小的范围内考虑。</p>
<ul>
<li>选取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>−</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">L-\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>+</mo><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">L+delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>范围内的点， 并且按照y值大小进行排序</li>
<li>选取左边的一个点(x, y), 对右边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>−</mo><mi>δ</mi><mo>∼</mo><mi>y</mi><mo>+</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">y-\delta \sim y+\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>矩形范围内的点考虑。因为右边任意两个点的范围都大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>,因此可以推断这个矩形中最多不超过六个点。也就是说只需要检查<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mo>∗</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">6*\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个候选者。</li>
</ul>
<p>它的复杂度是 T(n) = 2T(n/2) + O(n).用<a href="https://xinhecuican.github.io/post/71038564.html">主定理</a>解得复杂度为O(nlogn)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/post/55046.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="引例"><a class="markdownIt-Anchor" href="#引例"></a> 引例</h1>
<p><strong>钢条切割问题</strong></p>
<p>有一根长为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的钢条，切若干米获得的收益不同（例如切1米1元，切2米3元），请问怎样切割使得收益最大？</p>
<p>朴素的方法是我们可以把所有情况列举出来求最优解，但是总共有2^(n-1)种方案，复杂度显然过高，因此需要更简便的方法。</p>
<p>我们虽然是把它分成若干段，但是其实我们不是一瞬间把所有段都切好的，我们也是一条一条进行切割，所以问题可以转化为切一段和剩下所有段的最优解。即</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub><mo>=</mo><munder><mo><mi>max</mi><mo>⁡</mo></mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>P</mi><mi>i</mi></msub><mo>+</mo><msub><mi>R</mi><mi>n</mi></msub><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_n = \max_{1\le i \le n}( P_i+R_n-i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.572843em;vertical-align:-0.822843em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.072336em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.822843em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是长为n时的最优解。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是切长度为i可以获得的收益。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">rod(<span class="built_in">int</span>* p, <span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">n</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> q = -<span class="number">2147483648</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=<span class="built_in">n</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q = <span class="built_in">max</span>(q, p[i]+rod(p, <span class="built_in">n</span>-i));</span><br><span class="line">    &#125;</span><br><span class="line">    return q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是上面说明的递归算法。事实上，这种方法复杂度仍然很高，还是指数级复杂度。我们可以输入4模拟一下过程。</p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921.jpg" alt="" /></p>
<p>从图中我们可以看出，求解n=0求了7次，求解n=1求了4次。速度慢的原因可能就是我们重复求解相同的问题。</p>
<p><strong>用动态规划的方法求解问题</strong></p>
<p>因为我们总是求解相同的问题，那么是否可以在第一次求解这个问题的时候把结果记录下来呢？那么之后再需要这个结果的时候就可以直接去取了。</p>
<p>用这种思路求解问题有两种方法：</p>
<ul>
<li>带备忘的自顶向下法。这种方法仍然是按普通的方法求解。但是用了一个数组或散列表记录了每个子问题的解，这样每次求解时先从表中查询，没有再求解。</li>
<li>自底向上法。这种方法要求我们正确的划分问题，使得每个子问题都是由更小的子问题得来的，这样我们只需要从最小的子问题求起就可以解决。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">自顶向下</span><br><span class="line">rod(<span class="built_in">int</span>* p, <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> r<span class="literal">[<span class="identifier">n</span>+<span class="number">1</span>]</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r<span class="literal">[<span class="identifier">i</span>]</span> = -<span class="number">2147483648</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return memo<span class="constructor">_aux(<span class="params">p</span>, <span class="params">n</span>, <span class="params">r</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memo<span class="constructor">_aux(<span class="params">int</span><span class="operator">*</span> <span class="params">p</span>, <span class="params">int</span> <span class="params">n</span>, <span class="params">int</span><span class="operator">*</span> <span class="params">r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> q;</span><br><span class="line">    <span class="keyword">if</span>(r<span class="literal">[<span class="identifier">n</span>]</span> &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return r<span class="literal">[<span class="identifier">n</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n<span class="operator"> == </span><span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = -<span class="number">2147483648</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q = max(q, p<span class="literal">[<span class="identifier">i</span>]</span>+memo<span class="constructor">_aux(<span class="params">p</span>,, <span class="params">n</span>-<span class="params">i</span>, <span class="params">r</span>)</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r<span class="literal">[<span class="identifier">n</span>]</span> = q;<span class="comment">//把算出来的值存进去</span></span><br><span class="line">    return q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自底向上</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">rod(<span class="built_in">int</span>* p, <span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> r[<span class="built_in">n</span>+<span class="number">1</span>];</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=<span class="built_in">n</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> q = -<span class="number">2147483648</span>;</span><br><span class="line">        for(<span class="built_in">int</span> k=<span class="number">1</span>; k&lt;=i; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            q = <span class="built_in">max</span>(q, p[k] + r[j-k]);</span><br><span class="line">        &#125;</span><br><span class="line">        r[i] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    return r[<span class="built_in">n</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种方法的复杂度都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.实际上自顶向下到了底层求解的时候还是从最简单的情况一步步向上求。</p>
<p>上面求解的都是最大收益，但是没有说明到底如何切割。从自底向上的方法中我们可以看出，对于每次最大都是p[k]+r[j-k]和q<br />
进行比较。也就是对于每个问题我们最多只会切一刀，所以我们只需要记录切的那一刀</p>
<p><strong>子问题图</strong></p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922.jpg" alt="" /></p>
<p>上图是这个问题的子问题图。图中的线表示某个子问题求解需要用到那些子问题。从图中我们很容易看出我们可以先求解问题0，然后求解问题1，直到求解所有子问题。</p>
<p><strong>背包问题</strong></p>
<p><a href="https://xinhecuican.github.io/post/21624.html">背包问题</a></p>
<h1 id="动态规划原理"><a class="markdownIt-Anchor" href="#动态规划原理"></a> 动态规划原理</h1>
<p><strong>最优子结构</strong></p>
<p>如果一个问题最优解包含子问题的最优解，那么就称这个问题有最优子结构性质。因此想要知道一个问题能否用动态规划，这个问题是否有最优子结构是一个线索。</p>
<p>此外，两个子问题应该具有无关性，即一个子问题的解不影响另外一个问题。</p>
<p>例如，找无权最长路径时（该路径必须是简单路径，没有环），我们可以把问题分解成从a到b最长路径再从b到c最长路径。但是conga到b最长路径对后面一个求解是有影响的，因为不能形成环所以有些路就不能走。</p>
<p>说明最优子结构性质一般采用反证法，即假设一个子结构不是最优的，那么一定还有比他更优的，那么把这条更优的替换上去才是最优。</p>
<p>例如找最短路径问题，如果某一子路径的两个端点之间有更短的路径，那么把这条更短的路径替换上去才是最优。</p>
<p><strong>重叠子问题</strong></p>
<p>重叠子问题就是我们应该反复求解规模不同但求解方式相同的子问题。</p>
<p><strong>重构最优解</strong></p>
<p>通常把每个子问题所做的选择存在一个表中，这样就不必根据收益重构这些信息。</p>
<p>例如上面求解如何切割就是重构最优解，这样可以减少我们求特定问题的时间。</p>
<p><strong>备忘</strong></p>
<p>备忘是自顶向下时使用的策略。它的思路就是将求解过的存到一个表中，要的时候再用。</p>
<h2 id="最长公共子序列"><a class="markdownIt-Anchor" href="#最长公共子序列"></a> 最长公共子序列</h2>
<p>如果一个子序列即是X的子序列，又是Y的子序列，那么可以把这个序列称作公共子序列。现在任务是查找最长公共子序列。子序列只需要下标单调递增就可以，不一定要连续。</p>
<p>如果x的长度是m，y的长度是n。那么Xm = Yn就说明最长子序列中一定包括Xm，之后只需要在Xm-1和Yn-1中寻找。</p>
<p>如果Xm != Yn，那么最长子序列要么在Xm-1和Y中找要么在X和Yn-1中找。</p>
<p>根据上面的陈述，我们可以得到一个递推式。<br />
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923.jpg" alt="" /></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">int* length(int* x, int* y)</span><br><span class="line">&#123;</span><br><span class="line">    int m = x.len;</span><br><span class="line">    int n = y.len;</span><br><span class="line">    int c<span class="comment">[m+1]</span><span class="comment">[n+1]</span>;</span><br><span class="line">    for(int i=1; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c<span class="comment">[i]</span><span class="comment">[0]</span> = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c<span class="comment">[0]</span><span class="comment">[i]</span> = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int k=1; k&lt;=n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(x<span class="comment">[i]</span> == y<span class="comment">[k]</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c<span class="comment">[i]</span><span class="comment">[k]</span> = c<span class="comment">[i-1]</span><span class="comment">[k-1]</span> + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(c<span class="comment">[i-1]</span><span class="comment">[j]</span> &gt;= c<span class="comment">[i]</span><span class="comment">[j-1]</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c<span class="comment">[i]</span><span class="comment">[k]</span> = c<span class="comment">[i-1]</span><span class="comment">[k]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                c<span class="comment">[i]</span><span class="comment">[k]</span> = c<span class="comment">[i]</span><span class="comment">[k-1]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="旅行商问题"><a class="markdownIt-Anchor" href="#旅行商问题"></a> 旅行商问题</h2>
<p>旅行商问题是给定一系列城市和每对城市之间的距离, 求访问每一座城市一次并回到起始城市的最短回路。</p>
<ul>
<li>设 s, s1, ⋯, sp, s 是从 s 出发的一条路径长度最短的简单回路。</li>
<li>假设从 s 到下一个城市 s1的最短路径已经求出，则问题转化为求从 s1到 s 的最短路径。</li>
<li>显然s1到s的最短路径就是s1, …, sp, s.因为前面说了s, s1, …, sp, s是最短路径</li>
</ul>
<p>由此我们可以得到递推公式</p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.PNG" alt="" /><br />
其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta(i, S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>表示从i出发回到原点的最短路程。</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    for (<span class="name">i=1;</span> i&lt;n; i++) d[i][<span class="number">0</span>]=w[i][<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">    for (<span class="name">j=1;</span> j&lt;2n-1-1; j++)</span><br><span class="line">    for (<span class="name">i=1;</span> i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (<span class="name">I</span> ∉ Si)</span><br><span class="line">        &#123;</span><br><span class="line">            for each k∈S</span><br><span class="line">            i, d[i][Si]=min&#123;c[i][k]+d[k][&#123;Si-k&#125;]|k∈Si&#125;<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for each k∈V[<span class="number">2</span>n-1-1], d[<span class="number">0</span>][<span class="number">2</span>n-1-1]= min&#123;c[<span class="number">0</span>][k]+d[k][<span class="number">2</span>n-1-2]&#125;<span class="comment">;</span></span><br><span class="line">    return: d[<span class="number">0</span>][<span class="number">2</span>n-1-1]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>初始化文件</title>
    <url>/post/8274.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>有两个初始化文件，第一个文件是在启动时执行的，叫做登录文件（login file).第二个文件是在启动shell时执行的，叫做环境文件(environment file)。<br />
有的shell还有注销文件，注销文件指的是在shell关闭时执行的文件</p>
<p>bash shell中登录文件文件名（.Bash_profile .bash_login)，环境文件（.bashrc),注销文件（.bash_logout)</p>
<p>这些文件名都是以点开头，点文件的别名是隐藏文件，意义是除非你用ls指令去查看，通常状况你无法看到这个文件</p>
<p>登录shell指的是登录时默认启动的shell，非登录shel则需要在登录shell中执行命令才可以启动</p>
<p>登录shell执行登录文件和环境文件，非登录shell只执行环境文件</p>
<h4 id="初始化文件中放什么内容"><a class="markdownIt-Anchor" href="#初始化文件中放什么内容"></a> 初始化文件中放什么内容</h4>
<p>登录文件有两项任务，设置环境和初始化工作对话（不知道什么意思）</p>
<p>所以登录文件有两项任务</p>
<ol>
<li>创建或修改环境变量的命令（PATH,PAGER等）</li>
<li>执行所有一次性操作的命令</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>加法溢出和乘法溢出</title>
    <url>/post/41763.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>无符号数加法便是两个数相加，如果超过最大值那么就截断超过的位数。截断超过的位数也就相当于mod2^n,因为这样做超过的位都会被模去变成0.</p>
<p>有符号数加法相对复杂。先是变成无符号数加法，加完 之后再按有符号数编码去理解，这样就会产生两种溢出，正溢出和负溢出。</p>
<p>首先，如果两个数一正一负，则不可能产生进位。</p>
<p>正溢出很好理解，最高一位为符号位，假如两个正数一加，超过了最大值，那么第2^w-1位就会变成1，这一位是符号位，因此这个数字便会变成负数。</p>
<p>如果是负溢出，因为两个数最高位一定为1，如果2^w-2位没有发生进位的话，那么就产生了溢出，此时最高位为0，变成正数</p>
<p>例如：10111111+10111111（-65）=01111110（126）</p>
<p>所以说如果是正数溢出，则需要-2<sup>m,如果是负溢出，则需要加上2</sup>m</p>
<p>判定是否发生溢出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s=a+b;</span><br><span class="line"><span class="keyword">if</span>((a&gt;<span class="number">0</span>==b&gt;<span class="number">0</span>)&amp;&amp;(a&lt;<span class="number">0</span>!=s&lt;<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;发生溢出&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;没有发生溢出&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a&gt;0==b&gt;0的意义是判断a和b的符号是否相同,相同为真.a&lt;0!=s&lt;0的含义是判断a和s的符号是否<br />
乘法溢出相对简单粗暴，直接把高位全部截断，也就是对2^w取模，有符号数乘法是先不管符号位直接把后面的位相乘，然后再把符号位补上。</p>
]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/post/26737.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前缀和概念"><a class="markdownIt-Anchor" href="#前缀和概念"></a> 前缀和概念</h3>
<p>前缀和指的是用另一个数组b[n]来保存a[n]中前n项的和</p>
<p>例如，b[0]=a[0],b[1]=a[0]+a[1],…</p>
<h3 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h3>
<h4 id="求数组某一区间长度数字的和"><a class="markdownIt-Anchor" href="#求数组某一区间长度数字的和"></a> 求数组某一区间长度数字的和</h4>
<p>如果我给你一串长度为n的数列a1,a2,a3…an,再给出m个询问，每次询问给出L，R两个数，要求给出区间[L,R]里的数的和，一般可能是从L到R遍历一次，但这样很花时间，有了前缀和之后可以直接b[R]-b[L]就得到L到R的和</p>
<h3 id="差分"><a class="markdownIt-Anchor" href="#差分"></a> 差分</h3>
<p>差分就是将数列中的每一项分别与前一项数做差</p>
<p>一个序列1 2 5 4 7 3，差分后得到1 1 3 -1 3 -4 -3</p>
<p>这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0）<br />
差分序列最后比原序列多一个数（相当于0减最后一个数）</p>
<p>例 给你一串长度为n的数列a1,a2,a3…an，要求对a[L]~a[R]进行m次操作：</p>
<p>操作一：将a[L]~a[R]内的元素都加上P</p>
<p>操作二：将a[L]~a[R]内的元素都减去P</p>
<p>最后再给出一个询问求a[L]-a[R]内的元素之和？</p>
<p>如果用一般做法就是遍历加减，时间复杂度高，现在可以直接让b[L] 加上P，再让b[R+1]减去P，这样因为b[L+1]=b[L]+a[L+1]，所以L到R上每一项都会加P，而b[R+1]减去P是为了对后面的数不产生影响</p>
<p>如果有多次修改操作，可以先将每次修改保存到一个数组中，然后求前缀和时再加上<br />
#include&lt;bits/stdc++.h&gt;<br />
using namespace std;<br />
const int maxn=1e5+9;<br />
int a[maxn],b[maxn];<br />
int main(){<br />
int i,j,k,n,m,p;<br />
cin&gt;&gt;n&gt;&gt;m;<br />
for(i=1;i&lt;=n;i++){<br />
cin&gt;&gt;a[i];<br />
}<br />
for(i=1;i&lt;=m;i++){<br />
int L,R,t;<br />
cin&gt;&gt;t&gt;&gt;L&gt;&gt;R&gt;&gt;p;<br />
if(t==1){<br />
b[L]+=p;b[R+1]-=p; //仔细想想为什么b[R+1]要减去p<br />
}<br />
else{<br />
b[L]-=p;b[R+1]+=p;//这是减去p<br />
}<br />
}<br />
int add=0;<br />
for(i=1;i&lt;=n;i++){<br />
add+=b[i];<br />
a[i]+=a[i-1]+add;//这是求前缀和数组，并且add是把需要加p的地方加上<br />
}<br />
int x,y;<br />
cin&gt;&gt;x&gt;&gt;y;<br />
cout&lt;&lt;a[y]-a[x-1]&lt;&lt;endl;<br />
}</p>
<h4 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质：</h4>
<p>1、差分序列求前缀和可得原序列</p>
<p>2、将原序列区间[L,R]中的元素全部+1，可以转化操作为差分序列L处+1，R+1处-1</p>
<p>3、按照性质2得到，每次修改原序列一个区间+1，那么每次差分序列修改处增加的和减少的相同</p>
<h3 id="二维前缀和"><a class="markdownIt-Anchor" href="#二维前缀和"></a> 二维前缀和</h3>
<p>二维前缀和对应的是二维数组</p>
<p><img src="/images/20180817161822690.png" alt="" /></p>
<p>b[2][4]表示的是b[1][1]+b[1][2]+b[1][3]+b[1][4]+b[2][1]+b[2][2]+b[2][3]</p>
<p>因此可以先加上b[1][4]+b[2][3]，这时重复了b[1][3]，再减去</p>
<p>因此公式<br />
a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1]，因为这样，二维前缀和最好从一开始，0处全赋值为0</p>
<p>这时想知道从(x1,y1)到(x2,y2)的和要a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]</p>
<p>例如，求(3,3)到(4,4)的值，实际上是a[3][3]+a[3][4]+a[4][3]+a[4][4]</p>
<h3 id="二维差分不是很清楚"><a class="markdownIt-Anchor" href="#二维差分不是很清楚"></a> 二维差分（不是很清楚）</h3>
<p>和一维差分的第四个问题类似，让（x1,y1)和（x2,y2）矩形内的数都加上x</p>
<p>b[x1][y1]+=x; b[x2+1][y2+1]+=x;</p>
<p>b[x1][y2+1]-=x; b[x2+1][y1]-=x;</p>
<p>参考博客https://blog.csdn.net/k_r_forever/article/details/81775899</p>
<p><a href="https://blog.csdn.net/Healer66/article/details/87201014">https://blog.csdn.net/Healer66/article/details/87201014</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>压缩矩阵</title>
    <url>/post/56929.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>对于特殊的矩阵，例如上下三角矩阵，对称矩阵，三对角矩阵，可以转化成1维矩阵，减小空间的消耗。</p>
<h3 id="特殊矩阵"><a class="markdownIt-Anchor" href="#特殊矩阵"></a> 特殊矩阵</h3>
<h4 id="对称矩阵"><a class="markdownIt-Anchor" href="#对称矩阵"></a> 对称矩阵</h4>
<p>对称矩阵有 aij=aji的特性，因此可以只保存一边，也就是压缩成 <code>n(n+1)/2</code>个</p>
<p>如果我们用一个一维数组s[n(n+1)/2]来保存，那么它域原矩阵的对应关系</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">k</span>= i(i-<span class="number">1</span>)/<span class="number">2</span>+j-<span class="number">1</span> i&gt;=j</span><br><span class="line">    <span class="attribute">j</span>(j-<span class="number">1</span>)/<span class="number">2</span>+i-<span class="number">1</span>  i&lt;j</span><br></pre></td></tr></table></figure>
<p>这个式子先只考虑一边，先看i&gt;=j的情况。此时第一行中压缩矩阵只保存一个值，第二行两个值，依此类推。所以对于第i行先把前i-1行中对应压缩矩阵的值的数量加起来，也就死i(i-1)/2，之后再加上第j行的第j-1个（这里因为数组下标是从0开始）。</p>
<p>这个例子中的行数是从第一行开始，实际上应该从第0行开始，所以</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">k</span>= i(i+<span class="number">1</span>)/<span class="number">2</span>+j i&gt;=j</span><br><span class="line">  <span class="attribute">j</span>(j+<span class="number">1</span>)/<span class="number">2</span>+i i&lt;j</span><br></pre></td></tr></table></figure>
<p>举个例子，第0行第0个在k中对应位置就是0</p>
<h4 id="上下三角矩阵"><a class="markdownIt-Anchor" href="#上下三角矩阵"></a> 上下三角矩阵</h4>
<p>对称矩阵行数和列数相同</p>
<p>上三角矩阵其实就是对称矩阵中 i&gt;=j的那一段</p>
<p>下三角矩阵中第一行的压缩矩阵元素数量是n,第二行是n-1,以此类推，我们也可以得到相应的关系式</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">k=（2<span class="emphasis">*n-i-1)*</span>i/2+j i&lt;=j</span><br><span class="line">  (2<span class="emphasis">*n-j-1)*</span>j/2+i i&gt;j</span><br></pre></td></tr></table></figure>
<h4 id="三对角矩阵"><a class="markdownIt-Anchor" href="#三对角矩阵"></a> 三对角矩阵</h4>
<p>除了第一行和最后一行有两个元素之外，其他行都有三个元素</p>
<p>对于<code>a[i][j]</code>来说，前面有 3*i-1个元素，本行它前面有j-i+1个位置。所以k=2 * i+j</p>
<p>反之，如果在压缩矩阵中是第k个位置，那么在原矩阵中 i=(k+1)/3 j=k-2*i</p>
<h4 id="稀疏矩阵"><a class="markdownIt-Anchor" href="#稀疏矩阵"></a> 稀疏矩阵</h4>
<p>对于非零元素较少的矩阵，可以直接用一个结构体保存 i,j ,sum，然后再用一个结构体数组来保存所有的值。这个数组是从左至右扫描遍历的。一般稀疏矩阵中元素只占5%</p>
<h5 id="稀疏矩阵转置的算法"><a class="markdownIt-Anchor" href="#稀疏矩阵转置的算法"></a> 稀疏矩阵转置的算法</h5>
<p>首先，如果用朴素的算法，就是从第零行开始遍历每一列，然后把列变成行。</p>
<p>如果我们用两个数组分别保存 每一列中元素的数量以及每一列在新的稀疏矩阵中的位置，就有办法可以加快速度</p>
<p>例如：<img src="/images/%E6%8D%95%E8%8E%B71.PNG" alt="" /></p>
<p><img src="/images/%E6%8D%95%E8%8E%B7.PNG" alt="" /></p>
<p>cpot 第一个位置是一是因为数组下标从1开始</p>
<p>for循环中注意q=cpot[col]，代表现在这个位置已经有东西了，所以再最后++cpot[col]代表现在这一列在新稀疏矩阵的首位置要后移一位。</p>
<p>其次，因为转置前行号已经是从小到大排了，所以行号小的一定在前面。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划背包问题</title>
    <url>/post/21624.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="无后效性"><a class="markdownIt-Anchor" href="#无后效性"></a> 无后效性</h3>
<p>无后效性是一个问题可以用动态规划求解的标志之一，理解无后效性对求解动态规划类题目非常重要</p>
<p>概念：某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响（某度上找的定义）</p>
<p>理解：无后效性指的是之前做过的事现在还可以继续去做，这便是前一阶段做的事对后一阶段无影响。如果前面做过了后面便不能去做或者做的事受限这便是有后效性</p>
<p>例：<a href="https://blog.csdn.net/qq_30137611/article/details/77655707">这篇博客讲的很清楚</a></p>
<h3 id="01背包问题"><a class="markdownIt-Anchor" href="#01背包问题"></a> 01背包问题</h3>
<p><a href="https://xinhecuican.github.io/post/55046.html">动态规划更多可看</a></p>
<p><strong>问题描述</strong>：</p>
<p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p>
<p>我们可以用一个数组dp[i][c]来表示考虑前i个物品并且剩余容量为c时的最大价值。</p>
<p>首先要说明它满足最优子结构性质:</p>
<ol>
<li>假设最优解为(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1, x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, …).<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可以选取0或1.</li>
<li>现在随机选取最优解中的部分(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_1, x_2,...x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。假设它不是子问题的最优解，那么一定存在一个比他更优的解(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_1, y_2,...y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。使得value(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_1, x_2,...x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)&lt;value(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_1, y_2,...y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</li>
<li>则value(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">y_1, y_2, ...y_i, x_{i+1}...x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)&gt;value(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1, x_2,...x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。与假设矛盾</li>
<li>因此(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_1, x_2, ... x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)一定是子问题的最优解</li>
</ol>
<p>我们只考虑第i件和第i-1件，如果第i件没有装，那么dp[i][j] = dp[i-1][j].如果第i件装了，那么剩余容量就会减小并且加上第i件物品的价值为<code>dp[i][j] = dp[i-1][j-goods[i].w] + goods[i].v;</code></p>
<p>递推关系式为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>g</mi><mi>o</mi><mi>o</mi><mi>d</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>w</mi><mo stretchy="false">]</mo><mo>+</mo><mi>g</mi><mi>o</mi><mi>o</mi><mi>d</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>v</mi><mo stretchy="false">}</mo><mspace width="1em"/><mi>j</mi><mo>≥</mo><msub><mi>w</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mspace width="1em"/><mi>j</mi><mo>&lt;</mo><msub><mi>w</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j] = 
\left
\{\begin{matrix}
  max\{dp[i-1][j], dp[i-1][j-goods[i].w]+goods[i].v\} \quad j \ge w_i\\
  dp[i-1][j] \quad j&lt;w_i
\end{matrix}
\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">}</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">struct Good&#123;</span><br><span class="line">    int w;</span><br><span class="line">    int v;</span><br><span class="line">&#125;goods<span class="comment">[101]</span>;</span><br><span class="line">int dp<span class="comment">[101]</span><span class="comment">[1001]</span>;</span><br><span class="line">int n,S;//n表示有n个物品，S表示背包的最大容积</span><br><span class="line">for (i = 1; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (j = S; j &gt;= goods<span class="comment">[i]</span>.w; j--)</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[j]</span> = max(dp<span class="comment">[i-1]</span><span class="comment">[j]</span>, dp<span class="comment">[i-1]</span><span class="comment">[j - goods<span class="comment">[i]</span>.w]</span> + goods<span class="comment">[i]</span>.v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，之所将j初始化为S，逆序循环更新状态是为了保证在更新dp[j]时，dp[j-goods[i].w]的状态尚未因为本次更新而发生改变，即等价于由dp[i-1][j-goods[i].w]转移得到dp[i][j]。保证了更新dp[j]时，dp[j-goods[i].w]是没有放入物品i时的数据dp[i-1][j-goods[i].w]。</p>
<p>实际上01背包问题同一种思路代码写法有两种，如果s从0开始遍历就不需要逆序，但是从大于w[i]开始就需要逆序</p>
<p>实际上这里的二维数组可以优化变为一维数组</p>
<p>dp[i][j] = max{dp[i-1][j-w[i]]+v[i]，dp[i-1][j]，这里的i与i-1实际上是第i个物体与第i-1个物体，而这个可以用数组下标直接代替，这样便可以用一维数组解决背包问题，但是一维数组与二维数组的区别是二维数组保存了前i个物品所可以获得的最大价值，而一维数组只能保存题目要求的s个物品的最大价值，因此用一维还是用二维因题目而异</p>
<p>dp[j] = max{dp[j]，dp[j-w[i]]+v[i]}。从这个方程中我们可以发现，有两个dp[j]，但是要区分开。等号左边的dp[j]是当前i的状态，右边中括号内的dp[j]是第i-1状态下的值。</p>
<p>所以为了保证状态的正确转移，我们需要先更新等号左边中的dp[j]（当前状态的dp[j]）。</p>
<p>代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,maxv;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;maxv;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">1001</span>],v[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxv;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=maxv;k&gt;=w[i];k--)<span class="comment">/*这里是因为当背包体积小于物品体积时不可能成立，相当于if(k&lt;w[i])&#123;dp[i][k]=dp[i-1][k];&#125;*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[k]=<span class="built_in">max</span>(dp[k],dp[k-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[maxv]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓展问题</p>
<p>继续0-1背包问题，如果在上面的问题加上一个限制条件，所选择的物品必须恰好装满背包，否则输出-1。这时数组初始化为负无穷</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">int w<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int v<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int maxv;</span><br><span class="line">int n;</span><br><span class="line">int dp<span class="comment">[MAXSIZE]</span><span class="comment">[MAXSIZE]</span>;</span><br><span class="line"></span><br><span class="line">int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &gt; b)</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxv;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w<span class="comment">[i]</span> &gt;&gt; v<span class="comment">[i]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化，当容积为0时，即不能装入，最大价值即为0</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[0]</span> = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化为-1，表示没有装满</span><br><span class="line">    for (int i = 0; i &lt;= n; i++)</span><br><span class="line">    for (int j = 1; j &lt;= maxv; j++)</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[j]</span> = -1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = maxv; j &gt;= w<span class="comment">[i]</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1表示容积为j - w<span class="comment">[i]</span>时没有装满，所以当容积为j，装w<span class="comment">[i]</span>时一定不能装满</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt; dp<span class="comment">[i-1]</span><span class="comment">[j]</span>表示装入物品i时签好装满并且总价值比前i-1个物品的总价值要大</span><br><span class="line">            if (dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1 &amp;&amp; dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt;= dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>)</span><br><span class="line">                dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = w<span class="comment">[i]</span> - 1; j &gt;= 1; j--)</span><br><span class="line">            dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp<span class="comment">[n]</span><span class="comment">[maxv]</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它大致相同，现在dp[i][j]表示的是恰好装j空间时价值的最大值</p>
<p><strong>元组法</strong>：</p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.PNG" alt="" /></p>
<p>这是动态规划数组，可以看到里面存了大量重复的值，我们可以只记录变化的值（图中红色部分）从而减小空间消耗。</p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E4%BC%9A%E8%AF%9D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9811.PNG" alt="" /><br />
首先i=4时是在i=5基础上变化的。i=4时w=5,v=4,所以跳点可能是(0, 0) (5,4) (4, 6) (9, 10). 因为(5, 4)比(4, 6)重量大价值低所以无论后面怎么增加一定没有(4, 6)好，因此可以把(5, 4)省略</p>
<h3 id="完全背包"><a class="markdownIt-Anchor" href="#完全背包"></a> 完全背包</h3>
<p>题目：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for (i = 1; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (j = goods<span class="comment">[i]</span>.w; j &lt;= S; j++)</span><br><span class="line">        dp<span class="comment">[j]</span> = max(dp<span class="comment">[j]</span>, dp<span class="comment">[j - goods<span class="comment">[i]</span>.w]</span> + goods<span class="comment">[i]</span>.v);</span><br><span class="line">&#125;//不是很理解，但是先把模板记下吧</span><br></pre></td></tr></table></figure>
<p>这个代码和01背包代码十分相似，只有循环方向不同，为什么可以这样做呢？因为01背包要求每个物品只能选一次，因此根据这个式子，有可能会导致多选的就是dp[j - goods[i].w],如果从前往后循环，j-goods[i].w可能是已经选择了当前物品的情况</p>
<p><a href="https://pangyuworld.github.io/2019/04/03/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/#%E9%A2%98%E7%9B%AE%E7%B1%BB%E5%9E%8B-1">可以去看</a></p>
<h3 id="多重背包"><a class="markdownIt-Anchor" href="#多重背包"></a> 多重背包</h3>
<p>有N种物品和一个容量为V的背包。第 i 种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p>实际上可以转化为01背包，把每一种物品中多件拆开</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">int k = n + 1;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">		while (number<span class="comment">[i]</span>&gt;1) &#123;</span><br><span class="line">			w<span class="comment">[k]</span> = w<span class="comment">[i]</span>;</span><br><span class="line">			value<span class="comment">[k]</span> =value<span class="comment">[i]</span>;</span><br><span class="line">			k++;</span><br><span class="line">			number<span class="comment">[i]</span>--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">		for (int j = v; j &gt;= w<span class="comment">[i]</span>; j--) &#123;</span><br><span class="line">			f<span class="comment">[j]</span> = max(f<span class="comment">[j]</span>, f<span class="comment">[j - w<span class="comment">[i]</span>]</span> + value<span class="comment">[i]</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样可能导致时间复杂度过高，可以考虑采用二进制思想，每一个数例如7可以用二进制来表示，而这样我们就可以把它拆为3个数，7二进制为111，所以可以拆为100,010,001，这样我们就只需要储存3个数，降低了时间复杂度。但是假如不是正好的话<br />
例如13 ，二进制为1101，则可以分解为0110,0001,0010,0100（如果最好不足2<sup>i，则取x-2</sup>i-1)</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">int num<span class="comment">[maxn]</span><span class="comment">[2]</span>, dp<span class="comment">[maxn]</span>;</span><br><span class="line">int N, V, c, w, n, tot;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">cin &gt;&gt; V &gt;&gt; N; tot = 1;</span><br><span class="line">for(int i = 1; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; c &gt;&gt; w &gt;&gt; n;</span><br><span class="line">	for(int k = 1; k &lt; n; k&lt;&lt;=1)//左移求下一个所需二进制数 </span><br><span class="line">	&#123;</span><br><span class="line">		num<span class="comment">[tot]</span><span class="comment">[0]</span> = k*c;</span><br><span class="line">		num<span class="comment">[tot++]</span><span class="comment">[1]</span> = k*w;//注意这时我们把若干物体看为1个物体，它的总重量也要变</span><br><span class="line">		n -= k;</span><br><span class="line">	&#125;</span><br><span class="line">	num<span class="comment">[tot]</span><span class="comment">[0]</span> = n*c;</span><br><span class="line">	num<span class="comment">[tot++]</span><span class="comment">[1]</span> = n*w;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt; tot; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	for(int j = V; j &gt;= num<span class="comment">[i]</span><span class="comment">[0]</span>; --j)</span><br><span class="line">		dp<span class="comment">[j]</span> = max(dp<span class="comment">[j]</span>, dp<span class="comment">[j-num<span class="comment">[i]</span><span class="comment">[0]</span>]</span>+num<span class="comment">[i]</span><span class="comment">[1]</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列</title>
    <url>/post/8498.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>也就是有一个数列a，要求你求数列b和c，b[i]是a[i]…a[i+w-1]中的最小值，c[i]是最大值。如果a是1,3,-1,-3,5,3,6,7，则b为-1,-3,-3,-3,3,3，c为3,3,5,5,6,7。</p>
<p>这个问题相当于一个数据流（数列a）在不断地到来，而数据是不断过期的，相当于我们只能保存有限的数据（sliding window中的数据，此题中就是窗口的宽度w），对于到来的查询（此题中查询是每时刻都有的），我们要返回当前滑动窗口中的最大值\最小值。注意，元素是不断过期的。</p>
<p>解决这个问题可以使用一种叫做单调队列的数据结构，它维护这样一种队列：</p>
<p>a)从队头到队尾，元素在我们所关注的指标下是递减的（严格递减，而不是非递增），比如查询如果每次问的是窗口内的最小值，那么队列中元素从左至右就应该递增，如果每次问的是窗口内的最大值，则应该递减，依此类推。这是为了保证每次查询只需要取队头元素。</p>
<p>b)从队头到队尾，元素对应的时刻（此题中是该元素在数列a中的下标）是递增的，但不要求连续，这是为了保证最左面的元素总是最先过期，且每当有新元素来临的时候一定是插入队尾。</p>
<p>满足以上两点的队列就是单调队列，首先，只有第一个元素的序列一定是单调队列。</p>
<p>那么怎么维护这个单调队列呢？无非是处理插入和查询两个操作。</p>
<p>对于插入，由于性质b，因此来的新元素插入到队列的最后就能维持b)继续成立。但是为了维护a)的成立，即元素在我们关注的指标下递减，从队尾插入新元素的时候可能要删除队尾的一些元素，具体说来就是，找到第一个大于（在所关注指标下）新元素的元素，删除其后所有元素，并将新元素插于其后。因为所有被删除的元素都比新元素要小，而且比新元素要旧，因此在以后的任何查询中都不可能成为答案，所以可以放心删除。</p>
<p>对于查询，由于性质b，因此所有该时刻过期的元素一定都集中在队头，因此利用查询的时机删除队头所有过期的元素，在不含过期元素后，队头得元素就是查询的答案（性质a），将其返回即可。</p>
<p>由于每个元素都进队出队一次，因此摊销复杂度为O(n)。</p>
<p>这个讲的十分清楚，我只是<a href="https://blog.csdn.net/Baoli1008/article/details/47001513">搬运</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>双端队列deque</title>
    <url>/post/35848.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>普通的队列有许多限制，例如从一边删除插入，不能使用迭代器（因为空间不连续）等等。<br />
双端队列就允许从两边插入</p>
<p>deque的特点：</p>
<p>1、支持随机访问，即支持[]以及at()，但是性能没有vector好。</p>
<p>2、可以在内部进行插入和删除操作，但性能不及list。</p>
<p>deque和vector的不同之处：</p>
<p>1、两端都能够快速插入和删除元素。vector只能在尾端进行。</p>
<p>2、deque的元素存取和迭代器操作会稍微慢一些。因为deque的内部结构会多一个间接过程。</p>
<p>3、迭代器是特殊的智能指针，而不是一般指针。它需要在不同的区块之间跳转。</p>
<p>4、deque可以包含更多的元素，其max_size可能更大。因为不止使用一块内存。</p>
<p>5、不支持对容量和内存分配时机的控制。</p>
<p>注意：在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector。因为其内部结构显示不需要复制所有元素。</p>
<p>迭代器属于随机存取迭代器。</p>
<p>以上都是复制粘贴的，从以上我们可以看出它与vector相似，不同在于它可以从两头插入，这样插入效率高，如果从中间插入，要把很多元素都移动一遍，效率低</p>
<p>格式： deque&lt;类型&gt; 标识符</p>
<p>当生成一个 deque 容器时，也可以用由两个迭代器标识的一段元素来初始化它：</p>
<p>std::deque<a href="std::string">std::string</a> words_part { std::begin(words),std::begin(words) + 5 };</p>
<p>deque的成员函数：</p>
<p>deq[ ]：用来访问双向队列中单个的元素。</p>
<p>deq.front()：返回第一个元素的引用。</p>
<p>deq.back()：返回最后一个元素的引用。</p>
<p>deq.push_front(x)：把元素x插入到双向队列的头部。</p>
<p>deq.pop_front()：弹出双向队列的第一个元素。</p>
<p>deq.push_back(x)：把元素x插入到双向队列的尾部。</p>
<p>deq.pop_back()：弹出双向队列的最后一个元素。</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>合法的字符常量</title>
    <url>/post/3526.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>用英文单引号括起来的一个字符，例如’a’,’ '等等。空格也是一个字符常量</p>
<p>注意<p>
  1.转义字符也属于字符常量，例如'\t','\n'等，但是'\97'不算]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>字符常量</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法和分支限界法</title>
    <url>/post/a50b8908.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="回溯法"><a class="markdownIt-Anchor" href="#回溯法"></a> 回溯法</h1>
<h2 id="回溯法概念"><a class="markdownIt-Anchor" href="#回溯法概念"></a> 回溯法概念</h2>
<p>回溯法是一种能避免不必要搜索的穷举式算法，适用于一些解空间相当大的问题。</p>
<p>它经常呈现一种树形结构，先进入左节点，当到了底部或者条件不满足时返回父节点并进入右节点。一个典型的例子就是<a href="https://xinhecuican.github.io/post/37663.html">深度优先搜索</a></p>
<p>如果不加限制条件直接搜索的话复杂度将是2^n。因此我们需要添加一些限界函数来减小搜索量。</p>
<p>限界函数一般有两个，一个是用来限制左支的，叫显式约数条件。另一种是限制是否搜索右支的，叫隐式约束条件。</p>
<h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2>
<h3 id="01背包问题"><a class="markdownIt-Anchor" href="#01背包问题"></a> 01背包问题</h3>
<p><a href="https://xinhecuican.github.io/post/21624.html">01背包问题</a>最常见的办法是动态规划算法.这里介绍回溯法求解</p>
<ol>
<li>将物品按密度进行排序</li>
<li>设bestp是当前最好收益并初始化为负无穷</li>
<li>设bound = cp+r是效益值的上界。其中cp是这个节点的收益值，r是剩下所有物品的连续背包问题收益值（也就是说不满一件也可以装进去）</li>
<li>展开左子节点：
<ul>
<li>如果$$cw+Wk &lt;= c$$, 则装入k,且cw += Wk, cp += pk Xk = 1(说明这个节点使用了）</li>
</ul>
</li>
<li>否则展开右节点：
<ul>
<li>如果bound &lt;= bestp。则停止展开右子树（就算把剩余物品都放进去也抵不上它的收益）。否则就 xk = 0,然后继续搜索</li>
</ul>
</li>
</ol>
<p><img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%951.PNG" alt="" /></p>
<h3 id="货箱装船问题"><a class="markdownIt-Anchor" href="#货箱装船问题"></a> 货箱装船问题</h3>
<p><strong>问题</strong>：给定载重量为 c 的货船，找一种装船的方法，使得装载的货箱数目最多。</p>
<p><strong>分析</strong></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">设<span class="keyword">cw</span>是已装载货物重量</span><br><span class="line"></span><br><span class="line">显式限界条件： 如果<span class="keyword">cw</span>+w(i) &gt; maxw 则杀死该左节点。</span><br><span class="line">隐式限界条件： 如果<span class="keyword">cw</span>+r &lt;= bestw，则停止展开右节点。r是剩余货物的重量。</span><br></pre></td></tr></table></figure>
<h1 id="分支限界法"><a class="markdownIt-Anchor" href="#分支限界法"></a> 分支限界法</h1>
<p>分支限界法也是一种穷举搜索算法。但是同样可以通过限界函数进行限界。一个典型例子就是广度优先搜索。</p>
<h2 id="旅行商问题"><a class="markdownIt-Anchor" href="#旅行商问题"></a> 旅行商问题</h2>
<p>首先说一下归约矩阵。</p>
<ul>
<li>行规约矩阵：找到每一行最小的数，然后让这一行都减去最小的数。</li>
<li>行规约数： 每一行最小的数求和</li>
<li>归约矩阵： 每一行做归约后每一列再做归约。归约数就是行规约数加上列归约数</li>
</ul>
<p>归约矩阵的性质：</p>
<ul>
<li>每一行每一列都必须有一个0</li>
<li>对于旅行商问题， 它的结果就是在归约矩阵中得到的结果加上归约数 W(f) = w’(f)+h</li>
</ul>
<p>例：<img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%92%8C%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%951.PNG" alt="" /><br />
<img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%92%8C%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%952.PNG" alt="" /></p>
<p>其中q12表示A’矩阵中第一行第二列的点，表示我们要先从1到2.</p>
<p>之后的h’表示去掉这一行这一列和qji为无穷后的矩阵的归约值。因为我们到过这个节点之后这一行这一列都不会再有点了，所以可以去掉。另外如果不是导数第二个节点的话也不可能回到起点。</p>
<p>找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>的最小值后以这个点作为起始点除去这一行这一列进行下一步搜索。</p>
<p>现在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span>最小，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta(4)(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>inf</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">+\inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">in<span style="margin-right:0.07778em;">f</span></span></span></span></span>并且将第四行提到第一行，之后重复上述过程。<br />
<img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%92%8C%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%953.PNG" alt="" /></p>
<p>之后一直重复上述步骤直到搜索完成。</p>
<p>使用行规约矩阵的目的在于提前知道一些信息来进行分支限界。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>在代码段中使用栈</title>
    <url>/post/44487.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>实际上栈是我们人为定义的一段内存空间，所以先要用dw来申请</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>  //申请<span class="number">6</span>个字的内存空间，栈是由高内存地址到低内存地址，所以栈顶为<span class="built_in">cs</span>：<span class="number">Ch</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">Ch</span></span><br></pre></td></tr></table></figure>
<p>ss，sp就是前面所说的栈的指针</p>
]]></content>
  </entry>
  <entry>
    <title>图论基础</title>
    <url>/post/15201.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h1>
<p>如果图中有权值，称为网，仅在无向图中考虑这些问题，生成树指删去一些边变为树</p>
<h2 id="kruskal算法"><a class="markdownIt-Anchor" href="#kruskal算法"></a> kruskal算法</h2>
<p>这个也被称为加边法，</p>
<ol>
<li>把图中所有边按权值从小到大排序</li>
<li>把图中n个点看为n个独立的连通块</li>
<li>选择端点分属两个联通块且权值最小的边，若可选择的边有多条，任选其中一条即可</li>
<li>重复三，直至只剩一个连通块</li>
</ol>
<p>如何存边？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;x,<span class="keyword">const</span> node&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxm];</span><br></pre></td></tr></table></figure>
<p>其中u代表起点v代表终点，而w代表权值</p>
<p>采用了并查集的思想</p>
<p>怎么看加边后是否会变成环？只需要查找u，v的根节点，如果根节点相同则说明加边后 会变成环</p>
<p>模板，n个点m条边，找最小生成树</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,e,w;</span><br><span class="line">    <span class="keyword">friend</span> opoerator &lt; (<span class="keyword">const</span> node&amp; x,<span class="keyword">const</span> node&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=a;</span><br><span class="line">    <span class="keyword">while</span>(father[r]!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        r=father[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=a;</span><br><span class="line">    <span class="keyword">while</span>(father[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=father[x];</span><br><span class="line">        father[x]=x;</span><br><span class="line">        x=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">int</span> fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        father[fx]=fy;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; nod[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;nod[i].s&gt;&gt;nod[i].e&gt;&gt;nod[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nod.<span class="built_in">begin</span>(),nod.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(join(nod[i].s,nod[i].e))</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">                ans+=nod[i].val;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prim-算法"><a class="markdownIt-Anchor" href="#prim-算法"></a> prim 算法</h2>
<p>先把点分为两个集合，在最开始的时候第一个集合中只有任意一点，其他点在另外一个集合中，之后选择属于集合一点在集合B中一点在集合A中且与A权值最小的边</p>
<p>选择时注意只要把最近选的那个点的权值与原来 权值相比就可以了</p>
<p>我们如何保存边？用邻接矩阵</p>
<p>在这里我们不用考虑形成环的问题，因为我们是从两个集合中拿边，而想要形成环必定是在一个集合内拿边</p>
<p>模板</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[maxn][maxn],dis[maxn];<span class="comment">//dis用来记录以i为起点的最小权值</span></span><br><span class="line"><span class="keyword">bool</span> mark[maxn];<span class="comment">//用来判断某点是否加入</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,ox3f,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="keyword">sizeof</span>(mark));</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">1</span>,mi;</span><br><span class="line">    mark[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[v]=<span class="built_in">min</span>(dis[v],g[u][v]);<span class="comment">//将从前的最小值与第u个点的最小值相比</span></span><br><span class="line">        &#125;</span><br><span class="line">        mi=ox3f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mark[v]&amp;&amp;dis[v]&lt;mi)<span class="comment">//找到与A集合中权值最小的</span></span><br><span class="line">            &#123;</span><br><span class="line">                u=v;</span><br><span class="line">                mi=dis[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=mi;</span><br><span class="line">        mark[u]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，g数组开始要初始化为正无穷</p>
<h1 id="最短路"><a class="markdownIt-Anchor" href="#最短路"></a> 最短路</h1>
<p>在有向网中，求结点之间边权和最小的路被称为最短路问题</p>
<h2 id="多源最短路"><a class="markdownIt-Anchor" href="#多源最短路"></a> 多源最短路</h2>
<p>多源最短路指的是任意两点之间的最短路径</p>
<p>一般采用floyd-warshall算法，并且要求图中没有负权环（不然一直绕着环走就可以一直减小）</p>
<h4 id="flord算法"><a class="markdownIt-Anchor" href="#flord算法"></a> flord算法</h4>
<p>用一个二维数组f[i][j]表示从i到j最小路长度，初始化时输入i，j点的路的长度并且f[i][i]=0.</p>
<p>我们怎么找到最短的路程呢？ 通过观察可以发现，如果我们把一些点作为中转点的话，有可能会让路程变小。例如，我们只用1作为中转，可以得到</p>
<p>f[i][j]=min(f[i][j],f[i][1]+f[1][j]);</p>
<p>如果我们拿1和2作为中转点，可以得到</p>
<p>f[i][j]=min(f[i][j],f[i][1]+f[1][j]);</p>
<p>f[i][j]=min(f[i][j],f[i][2]+f[2][j]);</p>
<p>这段代码的意思是我先拿1作为中转，找到1做中转的最小路径之后我再拿2做为中转</p>
<p>模板<br />
<img src="/images/%E5%9B%BE%E7%89%8715.png" alt="" /><br />
第一层是k，表示以1,2。。。n为中转</p>
<p>离散上的传递闭包<br />
<img src="/images/%E5%9B%BE%E7%89%8716.png" alt="" /></p>
<h2 id="单源最短路"><a class="markdownIt-Anchor" href="#单源最短路"></a> 单源最短路</h2>
<h3 id="dijkstra"><a class="markdownIt-Anchor" href="#dijkstra"></a> dijkstra</h3>
<p>dijkstra只适用于无负权的图。</p>
<p>默认s可达全部点，用dis[i]表示从s到i的最短路径。</p>
<p>它的基本思想是贪心，将从单源单点最短路径化为单源多点最短路径。也就是计算从起始点出发到所有点的最短路径。</p>
<p>松弛操作</p>
<p>每次给目标集合加入一个点时，都要用该点重新判断最小的路径。</p>
<p>每次选择完一个点之后，这个点就由估计值变成确定值，也就是确定这个值就是从起点到这个点的最短路径（因为现在推到从起点到这个点是最短了，就算后面其他节点连接到这个节点也只会比这个路径更长）<br />
<img src="/images/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%805.PNG" alt="" /><br />
例如上面这个图，第一选择B，之后更新一遍之后选择D。虽然A-&gt;B-&gt;C-&gt;D这条路径，但是A-&gt;B-&gt;C就比A-&gt;B-&gt;D长了，之后就更不用说了。</p>
<p>每次进行松弛操作就是考虑加入这个点之后最短的点，这样每次都可以固定一次最短路径，进行n-1次就可以固定所有的最短路径。</p>
<p><img src="/images/%E5%9B%BE%E7%89%8717.png" alt="" /></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dijkstra(int x)</span><br><span class="line">&#123;</span><br><span class="line">	int visit<span class="comment">[maxn]</span>,i,j,min,next=x;</span><br><span class="line">	memset(visit,0,sizeof(visit));</span><br><span class="line">	for(i=1;i&lt;=n;++i)</span><br><span class="line">		dis<span class="comment">[i]</span>=map<span class="comment">[x]</span><span class="comment">[i]</span>;</span><br><span class="line">	visit<span class="comment">[x]</span>=1;</span><br><span class="line">	for(i=2;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		min=INF;</span><br><span class="line">		for(j=1;j&lt;=n;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			if(!visit<span class="comment">[j]</span>&amp;&amp;dis<span class="comment">[j]</span>&lt;min)</span><br><span class="line">			&#123;</span><br><span class="line">				min=dis<span class="comment">[j]</span>;</span><br><span class="line">				next=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		visit<span class="comment">[next]</span>=1;</span><br><span class="line">		for(j=1;j&lt;=n;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			if(!visit<span class="comment">[j]</span>&amp;&amp;dis<span class="comment">[j]</span>&gt;dis<span class="comment">[next]</span>+map<span class="comment">[next]</span><span class="comment">[j]</span>)</span><br><span class="line">				dis<span class="comment">[j]</span>=dis<span class="comment">[next]</span>+map<span class="comment">[next]</span><span class="comment">[j]</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="bellman-ford"><a class="markdownIt-Anchor" href="#bellman-ford"></a> Bellman-Ford</h3>
<p>该算法是通过每一条边进行降距操作（前面是通过点）。它的优点是可以有负权，并且可以检查出负权环。</p>
<p>过程：</p>
<ul>
<li>进行初始化，将distance变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">+\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span></li>
<li>用每一条边进行松弛操作</li>
<li>重复上述过程n-1次</li>
</ul>
<p><strong>为什么dijkstra不可以有负权图而下面可以？</strong></p>
<ol>
<li>dijkstra是贪心选择，选中了就认为是最短路径，但是有可能发生到了之后原本路径长的通过一条负权结果路径比原来选择的那条还短的问题。</li>
<li>Ford每次并没有进行选择，第一次松弛操作之后，因为访问了所有边，所以可以确定从起点找第一个点的最短路径。之后第二次又可以找到一个，依次进行。就算有负权因为每一次都是访问所有的边且并没有选择，所以负权也只会起到更新作用。</li>
</ol>
<p>开始有一点疑惑时假设有负权那么每次经过负权的话长度不会变吗？其实如果dis[from]确定的话dis[from]+edge.weight也确定了下来，导致dis[to]经过一次松弛之后也确定了下来</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;<span class="comment">//对m条边进行循环</span></span><br><span class="line">      <span class="keyword">var</span> <span class="keyword">edge</span> = edges[j];</span><br><span class="line">      <span class="comment">// 松弛操作</span></span><br><span class="line">      <span class="keyword">if</span> (distance[<span class="keyword">edge</span><span class="variable">.to</span>] &gt; distance[<span class="keyword">edge</span><span class="variable">.from</span>] + <span class="keyword">edge</span><span class="variable">.weight</span> )&#123; </span><br><span class="line">        distance[<span class="keyword">edge</span><span class="variable">.to</span>] = distance[<span class="keyword">edge</span><span class="variable">.from</span>] + <span class="keyword">edge</span><span class="variable">.weight</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查是否有负权环的方法：</p>
<ul>
<li>再进行一次松弛操作，如果dis变化就有负权环（因为n-1次操作之后正常情况所有点的最短路径都是确定的）</li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>在不更改注册表的情况下把程序移出c盘</title>
    <url>/post/44336.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这里用的类似于快捷方式。用mklink命令，这个命令可以将两个文件夹连接，一个是真实存放内容的文件夹，另一个只有名称，实际内容并不放在哪里。所以我们可以创建一个这样的文件夹来骗过程序。例如 office</p>
<p>首先要用cmd而不能用powershell，这是系统自带命令.然后在其他盘建一个同名的文件夹。注意c盘的文件夹不要创建，执行命令后系统自动创建。</p>
<p><code>mklink /J &quot;C:\Program Files (x86)\Microsoft Files&quot; &quot;D:\Program Files (x86)\Microsoft Files&quot;</code></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>埃氏筛</title>
    <url>/post/29949.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在筛质数时，我们会发现，筛去2后，2的倍数4、6、8等一定不是素数;筛去3后，3的倍数6、9、12等一定不是倍数。简单模拟这个过程如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> int MAXN = <span class="number">1000000</span>；  </span><br><span class="line"><span class="keyword">void</span> Prime()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span> (int i=<span class="number">0</span>; i&lt;MAXN; i++) prime[i]=<span class="number">1</span>;  <span class="comment">//先把每个数都定义为质数</span></span><br><span class="line">    prime[<span class="number">0</span>]=prime[<span class="number">1</span>]=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (int i=<span class="number">2</span>; i&lt;MAXN; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!prime[i]) <span class="keyword">continue</span>;  </span><br><span class="line">        <span class="keyword">for</span> (int j=i*<span class="number">2</span>; j&lt;MAXN; j+=i) prime[j] = <span class="number">0</span>;  <span class="comment">//将i的倍数标记为合数</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>复杂度</title>
    <url>/post/71038564.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="下界math-xmlnshttpwwww3org1998mathmathmlmiωmimath-上界o-紧界math-xmlnshttpwwww3org1998mathmathmlmiθmimath"><a class="markdownIt-Anchor" href="#下界math-xmlnshttpwwww3org1998mathmathmlmiωmimath-上界o-紧界math-xmlnshttpwwww3org1998mathmathmlmiθmimath"></a> 下界<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Ω</mi></math> 上界O 紧界<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Θ</mi></math></h1>
<p>这几个界都是由极限得来的。</p>
<p>上界： 对于 任意正常量c&gt;0,都存在No&gt;=n,使得 0&lt;=f(n)&lt;= cg(n).则可用 f(n) = O(g(n))表示。</p>
<p>g(n)一般使用简单的式子如 n nlogn, n^2,…</p>
<p>这个式子其实就是极限的表达形式，所以我们也可以用极限的形式表达：<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>i</mi><msubsup><mi>m</mi><mn>0</mn><mi>∞</mi></msubsup><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>/</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mo> </mo><mn>0</mn></math></p>
<p>下界： f(n)&gt;=cg(n) <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>i</mi><msubsup><mi>m</mi><mn>0</mn><mi>∞</mi></msubsup><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>/</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mo> </mo><mi>∞</mi></math></p>
<p>紧界： f(n)= cg(n)</p>
<h1 id="分析递归式的复杂度"><a class="markdownIt-Anchor" href="#分析递归式的复杂度"></a> 分析递归式的复杂度</h1>
<p>之所以递归式要单独拿出来分析是因为递归式很难从直观上去判断。例如 f(n) = f(n-1)+f(n-2).这个递归式如果要分析的话可以写成 f(n) = f(n-1) + f(n-2) + 1，最后一个1表示每一层需要进行的运算，因为这里只有一个加法运算，所以是加1.</p>
<h2 id="代入法求递归式"><a class="markdownIt-Anchor" href="#代入法求递归式"></a> 代入法求递归式</h2>
<p>代入法就是首先猜测复杂度，然后用归纳法证明。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">例如： <span class="built_in">T</span>(<span class="built_in">n</span>) = <span class="number">4</span><span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">2</span>) + <span class="built_in">n</span></span><br><span class="line"></span><br><span class="line">假设 <span class="built_in">T</span>(<span class="built_in">n</span>) &lt;= cn^<span class="number">3</span></span><br><span class="line"></span><br><span class="line">当<span class="built_in">n</span> = <span class="number">1</span>时，可以找出一个足够大的c使，<span class="built_in">T</span>(<span class="number">1</span>) &lt;= c， 成立</span><br><span class="line">当<span class="built_in">n</span>= k 时， <span class="built_in">T</span>(k) &lt;= ck^<span class="number">3</span></span><br><span class="line">当<span class="built_in">n</span> = <span class="built_in">n</span>时， <span class="built_in">T</span>(<span class="built_in">n</span>) = <span class="number">4</span><span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">2</span>) + <span class="built_in">n</span> &lt;= <span class="number">1</span>/<span class="number">2</span> * c * <span class="built_in">n</span>^<span class="number">3</span> + <span class="built_in">n</span> &gt;= cn^<span class="number">3</span>，所以成立。</span><br><span class="line"></span><br><span class="line">如果 <span class="built_in">T</span>(<span class="built_in">n</span>) &lt;= cn^<span class="number">2</span></span><br><span class="line"></span><br><span class="line">当<span class="built_in">n</span>=<span class="built_in">n</span>时， <span class="built_in">T</span>(<span class="built_in">n</span>) &lt;= c * <span class="built_in">n</span>^<span class="number">2</span> +<span class="built_in">n</span> &gt;= cn^<span class="number">2</span>。 不成立</span><br><span class="line"></span><br><span class="line">遇到这种与结果十分接近的式子时可以减去一个低阶项。</span><br><span class="line"></span><br><span class="line">假设 <span class="built_in">T</span>(<span class="built_in">n</span>) &lt;= c （<span class="built_in">n</span>^<span class="number">2</span> - <span class="built_in">n</span>)</span><br><span class="line"></span><br><span class="line">当 <span class="built_in">n</span> = <span class="built_in">n</span> 时， <span class="built_in">T</span>(<span class="built_in">n</span>) &lt;= cn^<span class="number">2</span> - c/<span class="number">2</span>*<span class="built_in">n</span> +<span class="built_in">n</span> &lt;= cn^<span class="number">2</span>，成立</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="递归树法"><a class="markdownIt-Anchor" href="#递归树法"></a> 递归树法</h2>
<p>递归树法是通过作图分析<img src="/images/%E5%A4%8D%E6%9D%82%E5%BA%A61.jpg" alt="" /></p>
<p>例如 f(n) = 2 * f(n/2) + n. 那么第二层是由两个f(n/2)组合而成 每个f(n/2)都会加上n/2,所以第一层和第二层都加上n。</p>
<p>总共有多少层呢？ 可以看到最后要减小到f(1)，而每次乘1/2,也就是 n/(2^h) = 1,h=logn.所以复杂度是 O(nlogn)（层数乘上每层数目）</p>
<p>拿一个跟复杂的例子。 f(n) = f(n/3) + f(2n/3) + n.对于这种我们通常使用夹紧准则获得一个近似值。例如一直从左边高度是log3 n ,右边是 log3/2 n.而右边到最后每一层不是n。这些差异我们可以忽略大致得到复杂度是nlogn。然后在用归纳法证明</p>
<h2 id="主方法"><a class="markdownIt-Anchor" href="#主方法"></a> 主方法</h2>
<p>对于 T(n) = aT(n/b) + f(n)</p>
<ol>
<li>
<p>如果 f(n) = O(n^logb a-e).也就是n^logb a 比 f(n)大，那么T(n) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Θ</mi></math>（n^logb a)<br />
这里e最好写出来</p>
</li>
<li>
<p>如果f(n) = n^logb a, 那么 T(n) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Θ</mi></math>(n^logb a lgn)</p>
</li>
<li>
<p>f(n) = O(n^logb a+e),还要满足存在c&lt;1和足够大的n af(n/b) &lt;= cf(n),则 T(n) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Θ</mi></math>(f(n))</p>
</li>
</ol>
<p>要注意，case1 和 case2之间有空隙，case2和case3之间有空隙。一个例子是</p>
<p><code>T(n) = 2T(n/2) + O(nlogn)</code></p>
<p>这个 n^(logb(a))的确比nlogn小，但是 nlogn/n = logn都渐进小于 n<sup>e（也就是n</sup>e/logn 取极限为0）,所以这是渐进大于而不是多项式大于，不能用case3.</p>
<p>主定理更为适用于多项式级别的比较，如果有logn和2^n有时候就会力不从心了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>字符串之KMP算法</title>
    <url>/post/57671.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="由扯来蛋"><a class="markdownIt-Anchor" href="#由扯来蛋"></a> 由（扯）来（蛋）</h3>
<p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这三人的姓氏命名此算法。</p>
<h3 id="最长前缀和与后缀和"><a class="markdownIt-Anchor" href="#最长前缀和与后缀和"></a> 最长前缀和与后缀和</h3>
<p>例如给出一个字符串ABCDABD<br />
<img src="/images/331.jpg" alt="" /><br />
前缀和就是从前往后数i个，后缀和是从第n-i个数到最后一个，首先我们便要找到每一个字母的最长相同前缀后缀和，然后求next数组，注意，只有一个元素时是不计算前缀后缀的，直接看为0</p>
<h4 id="next数组"><a class="markdownIt-Anchor" href="#next数组"></a> next数组</h4>
<p>next数组考虑的是除当前字符外的最长相同前缀后缀，实际上就是前一个前缀后缀和，因为把最后一个字母上去之后必定会使后缀和少一个，因此前缀后缀和也会-1，注意next数组中会出现-1，<strong>实际上这个数组就是将原数组整体右移一位，然后在第0位补上-1</strong></p>
<p><img src="/images/3331.jpg" alt="" /></p>
<p><img src="/images/3332.jpg" alt="" /></p>
<h3 id="用next数组进行匹配"><a class="markdownIt-Anchor" href="#用next数组进行匹配"></a> 用next数组进行匹配</h3>
<p>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀 pj-k pj-k+1, …, pj-1 跟文本串 si-k si-k+1, …, si-1 匹配成功，但 pj 跟 si 匹配失败时，因为 next[j] = k，相当于在不包含 pj 的模式串中有最大长度为 k 的相同前缀后缀，即 p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令 j = next[j]，从而让模式串右移 j - next[j] 位，使得模式串的前缀 p0 p1, …, pk-1 对应着文本串 si-k si-k+1, …, si-1，而后让 pk 跟 si 继续匹配。如下图所示：<br />
<img src="/images/323.jpg" alt="" /></p>
<p><strong>解释</strong>：因为前缀和后缀和相等，当最后一个匹配失误的时候就可以直接跳到后缀和开始的地方，这样就一下子匹配到了几位数，加快速度，至于合理性 ，K M P 这三个人已经证明过，而具体要跳几位呢？</p>
<p>比如说你有7个数，前面6个数已经匹配好了，结果第七位出了问题，这时一找next数组，发现第6位前缀和为2，那我们就要跳到第五位上去，找找规律，就是j-next[j]呀，没错，就是要跳这么多位，忘了自己推一下就好了，挺好推的</p>
<p><em><strong>失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</strong></em></p>
<h3 id="next数组求法"><a class="markdownIt-Anchor" href="#next数组求法"></a> next数组求法</h3>
<p>这里运用了递归的思想，首先对于前一两个可以直接写出来，然后对于后面的，假如第j个next值我们已经求出来了，那么对于第j+1个，</p>
<ol>
<li>如果p[k]=p[j]，则next[j+1]=k+1</li>
</ol>
<p>例如<img src="/images/3343.jpg" alt="" /><br />
C为p[j]，E为p[j+1]，next[j]=2,则第一，第二个与第五，第六个相同，如果第三个和3七个相同，则最大相同长度就为3，即p[k]=p[j]</p>
<p>2.如果p[k]!=p[j],则递归找p[next[k]]是否等于p[j]，p[next[next[k]]]是否等于p[j],直到找到或到了开头</p>
<p>对于第二种情况，也可以通过图来展示<br />
<img src="/images/3344.jpg" alt="" /><br />
现在p[j]!=p[k]，那么肯定要缩小范围，我么已经知道第一个与第二个是匹配的了，那么第五个第六个对应与第一个第二个匹配，但如果那里面没有前后缀的话，你减去一个就相当于破坏了结构（前缀从前往后，后缀也是从前往后，减去一个便要求这这个前缀串里面前几个要和后缀串里面后面几个匹配，因此要求next[k]就是为了里面要匹配，这样只需比较p[next[k]]和p[j]即可），假如中间就碰到了，那么next[j+1]=next[next[k]]+1,如果没碰到，那么next[j+1]=0（一朝回到解放前）</p>
<p>代码实现：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> GetNext(<span class="built_in">char</span>* p,<span class="built_in">int</span> <span class="keyword">next</span>[])  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">int</span> pLen = strlen(p);  </span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k;  </span><br><span class="line">            ++j;  </span><br><span class="line">            <span class="keyword">next</span>[j] = k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="nextval"><a class="markdownIt-Anchor" href="#nextval"></a> nextval</h3>
<p>nextval是next的进阶版。例如某一位是next[5]，但是next[5]和5的字符相同，这样肯定还是不行，所以多比了一次。</p>
<p>nextval判断方法：在next的基础上,s是用来匹配的串</p>
<p>s[next[i]] = s[i], 继续比较。如果next[i]和next[next[i]]还是相同，那么要继续比，直到不相同或者过了第一个为止</p>
<p>s[next[i]] != s[i] , nextval[flag] = next[i]</p>
<h3 id="匹配最终代码"><a class="markdownIt-Anchor" href="#匹配最终代码"></a> 匹配（最终代码）</h3>
<p>匹配过程：</p>
<p>“假设现在文本串S匹配到 i 位置，模式串 P 匹配到 j 位置</p>
<p>如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符；</p>
<p>如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j] 位。</p>
<p>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。”</p>
<p>例 <img src="/images/3353.png" alt="" /></p>
<p>例如此时i=10,j=6,此时文本串该位为空格，而匹配串为D，这时不匹配，就要让匹配串移动6-next[6]=4位，我令i=10,j=2,即匹配串为C,这就相当于让匹配位左移4位，而文本对应位不变，于是相当于匹配串右移4位（有种物理相对运动的既视感）</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      </span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      </span></span><br><span class="line">            <span class="comment">//next[j]即为j所对应的next值        </span></span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>感到了代码的优美感有没有！</p>
<p>但是这样还可以优化</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>优化过后的<span class="keyword">next</span> 数组求法  </span><br><span class="line">void GetNextval(char* p, int <span class="keyword">next</span>[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int pLen = strlen(p);  </span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;  </span><br><span class="line">    int k = -<span class="number">1</span>;  </span><br><span class="line">    int j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">//</span>p[k]表示前缀，p[j]表示后缀    </span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k])  </span><br><span class="line">        &#123;  </span><br><span class="line">            ++j;  </span><br><span class="line">            ++k;  </span><br><span class="line">            <span class="regexp">//</span>较之前<span class="keyword">next</span>数组求法，改动在下面<span class="number">4</span>行  </span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])  </span><br><span class="line">                <span class="keyword">next</span>[j] = k;   <span class="regexp">//</span>之前只有这一行  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="regexp">//</span>因为不能出现p[j] = p[ <span class="keyword">next</span>[j ]]，所以当出现时需要继续递归，k = <span class="keyword">next</span>[k] = <span class="keyword">next</span>[<span class="keyword">next</span>[k]]  </span><br><span class="line">                <span class="keyword">next</span>[j] = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            k = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这里有点蒙，就先这样吧</p>
<p><a href="https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html">参考文章（这篇文章真的太好了，生怕你不会）</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串之hash算法</title>
    <url>/post/11491.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="hash基础概念"><a class="markdownIt-Anchor" href="#hash基础概念"></a> hash基础概念</h3>
<p>但在工程实践中，要查找的关键字往往都不是自然数，即使是自然数也有可能是很大的值。因此，只要我们提前把关键字转换为在固定较小范围内的自然数，就可以实现常数时间的查找。那么问题来了，如何实现该转换关系呢？这就是哈希函数所要完成的工作。</p>
<p>哈希函数：又称散列函数，是把一段有限二进制串（字符串，整数等）转换为自然数的一种函数。</p>
<p>哈希值：哈希函数输出的最终结果。</p>
<p>字符串哈希函数：输入是字符串的哈希函数。</p>
<p>注：实际上就是用一个函数将字符串转化为整数，然后尽可能使一个整数对应一个字符串</p>
<p>现在的哈希函数基本上都是满射，多个字符串会对应一个数字，这种情况佳作冲突，为了减小冲突，列举几种方法</p>
<p><img src="/images/%E5%9B%BE%E7%89%876.png" alt="" /><br />
这种方法就是用进制转换的观念，一般用128,但这样十分容易超int型的范围，因此要想办法减小范围，可以用一个较大的数去摸，这时又出现了冲突的问题，那可以用两个数同时去摸，这样用两个数表示一个字符串冲突的几率便大大降低</p>
<p>BKDRHash算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BKDR Hash Function</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);<span class="comment">//ox7FFFFFFF代表int型最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;是与运算符，<a href="https://blog.csdn.net/ssdjdk/article/details/90199634">详细看这</a></p>
<p>关于 <a href="https://blog.csdn.net/MyLinChi/article/details/79509455">BKDRHash算法可以看</a></p>
<p>最好用unsigned int 类型，<a href="https://www.cnblogs.com/lailailai/p/4030151.html">这样相当于每次hash操作都取了一次模</a></p>
<p>APhash算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// AP Hash Function</span><br><span class="line">unsigned <span class="built_in">int</span> APHash(char *<span class="built_in">str</span>)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned <span class="built_in">int</span> <span class="built_in">hash</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; *<span class="built_in">str</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">hash</span> ^= ((<span class="built_in">hash</span> &lt;&lt; <span class="number">7</span>) ^ (*<span class="built_in">str</span>++) ^ (<span class="built_in">hash</span> &gt;&gt; <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">hash</span> ^= (~((<span class="built_in">hash</span> &lt;&lt; <span class="number">11</span>) ^ (*<span class="built_in">str</span>++) ^ (<span class="built_in">hash</span> &gt;&gt; <span class="number">5</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">hash</span> &amp; <span class="number">0x7FFFFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/MyLinChi/article/details/79508112">这篇博客讲的很详细</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符形式 的数据</title>
    <url>/post/30072.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先要知道asc11码</p>
<p>形式： db ‘…’</p>
<p>无论多少个单词都只需要单引号</p>
<p>例 db‘unix’</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>字符数组</title>
    <url>/post/22493.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前方高能"><a class="markdownIt-Anchor" href="#前方高能"></a> 前方高能</h3>
<pre><code>char a[4]=&#123;'a','b','c','d'&#125;;
cout&lt;&lt;a&lt;&lt;endl;
</code></pre>
<p>这将输出什么呢，是<code>abcd</code>，实际上是<code>abcdPpB</code></p>
<p>这就有点神奇</p>
<h4 id="字符数组"><a class="markdownIt-Anchor" href="#字符数组"></a> 字符数组</h4>
<p>char +标识符+[]，注意字符数组的最后一定会有’\0’，</p>
<p>例如<code>char[]=&quot;abcd&quot;,这就是一个合法的赋值，但是char[4]=&quot;abcd&quot;是不合法的因为带双引号的为字符串，赋值给字符数组时编译器会自动加上'\0'这时需要5个空间</code></p>
<h3 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h3>
<p>因为本来是要加上’\0’的，但是这时位子不够了，编译器只好帮它扩扩容，也就是说这是字符数组（其实现在已经不是字符数组了）长度已经不是4了，编译器会为后面几个位子附上值（不是随机的，我也有点不清楚，这样解释先），因此后面会多输出一些。但是如果开始就把长度设为5，这时’\0’就有位子放了，也就不会多出后面那些奇奇怪怪的字符</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>宏定义</title>
    <url>/post/39968.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>宏定义就是在开始用井号（#）定义一个函数或者是常量，这种定义在编译器中被处理，运算速度快，但使用宏定义时可能会出现一些隐蔽的问题</p>
<p>例如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">#define <span class="keyword">DATA</span> sizeof(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">for(<span class="built_in">int</span> i=cnt;i-<span class="keyword">DATA</span>&gt;=<span class="number">0</span>;i-=<span class="keyword">DATA</span>)</span><br></pre></td></tr></table></figure>
<p>乍一看这样做似乎没什么问题，要注意sizeof返回的是一个无符号数，有符号数和无符号数做比较的时候会先把有符号数变成无符号数。而负数的有符号数最高位一定为1，这样就可能会导致数据异常。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>将不同代码放入不同段中</title>
    <url>/post/41840.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>举个栗子</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code <span class="built_in">ds</span>:data <span class="built_in">ss</span>:stack</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0345h</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">20h</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span> //<span class="built_in">ds</span>:<span class="built_in">bx</span>指向data中第一个内存单元</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s0:</span><span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s0</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"> code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>看了这个就差不多了，前面定义的时候要注意不同段对应不同的寄存器，而后面要注意各个段有独自的segment与ends，而且从start开始要把各个段寄存器赋值，以备后面使用（mov ax，data）<strong>注意</strong> mov ds，data是错误的，8086cpu不允许直接把一个数值送入段寄存器中</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>层次聚类</title>
    <url>/post/2ba82a45.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1>
<p>层次聚类（hierarchical clustering)就是不断把最近的类合并知道达到要求为止。这是一种树形结构</p>
<p>大致过程：</p>
<ol>
<li>初始化，每个实例看做一类</li>
<li>合并， 算出每两个类之间的距离，然后把距离最近的两个类合并成一个类</li>
<li>终止条件可以是最近两个类之间的距离</li>
</ol>
<p>计算两个类之间距离的方法</p>
<ol>
<li>SingleLinkage: 这种方法是以两个类中最短距离代表两个类之间的距离。但是这种方法可能出现链式反应，即抓到了一个离其他点十分近的点就抓到了一群点，但实际上分属两团</li>
<li>CompleteLinkage： 这种方法是找两个类中最长点距离</li>
<li>AverageLinkage： 这种方法是把两个类中所有点的距离求出来再求平均值，或者也可以取中值</li>
</ol>
<h1 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Code for hierarchical clustering, modified from </span></span><br><span class="line"><span class="string">Programming Collective Intelligence by Toby Segaran </span></span><br><span class="line"><span class="string">(O&#x27;Reilly Media 2007, page 33). </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cluster_node</span>:</span> <span class="comment"># 树节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,vec,left=<span class="literal">None</span>,right=<span class="literal">None</span>,distance=<span class="number">0.0</span>,<span class="built_in">id</span>=<span class="literal">None</span>,count=<span class="number">1</span></span>):</span></span><br><span class="line">        self.left=left</span><br><span class="line">        self.right=right</span><br><span class="line">        self.vec=vec</span><br><span class="line">        self.<span class="built_in">id</span>=<span class="built_in">id</span></span><br><span class="line">        self.distance=distance</span><br><span class="line">        self.count=count <span class="comment">#only used for weighted average </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L2dist</span>(<span class="params">v1,v2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(<span class="built_in">sum</span>((v1-v2)**<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L1dist</span>(<span class="params">v1,v2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">abs</span>(v1-v2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># def Chi2dist(v1,v2):</span></span><br><span class="line"><span class="comment">#     return sqrt(sum((v1-v2)**2))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hcluster</span>(<span class="params">features,distance=L2dist</span>):</span></span><br><span class="line">    <span class="comment">#cluster the rows of the &quot;features&quot; matrix</span></span><br><span class="line">    distances=&#123;&#125;</span><br><span class="line">    currentclustid=-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># clusters are initially just the individual rows</span></span><br><span class="line">    clust=[cluster_node(array(features[i]),<span class="built_in">id</span>=i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(clust)&gt;<span class="number">1</span>:</span><br><span class="line">        lowestpair=(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        closest=distance(clust[<span class="number">0</span>].vec,clust[<span class="number">1</span>].vec)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># loop through every pair looking for the smallest distance</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(clust)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(clust)):</span><br><span class="line">                <span class="comment"># distances is the cache of distance calculations</span></span><br><span class="line">                <span class="keyword">if</span> (clust[i].<span class="built_in">id</span>,clust[j].<span class="built_in">id</span>) <span class="keyword">not</span> <span class="keyword">in</span> distances: </span><br><span class="line">                    distances[(clust[i].<span class="built_in">id</span>,clust[j].<span class="built_in">id</span>)]=distance(clust[i].vec,clust[j].vec)</span><br><span class="line">        </span><br><span class="line">                d=distances[(clust[i].<span class="built_in">id</span>,clust[j].<span class="built_in">id</span>)]</span><br><span class="line">        </span><br><span class="line">                <span class="keyword">if</span> d&lt;closest:</span><br><span class="line">                    closest=d</span><br><span class="line">                    lowestpair=(i,j) <span class="comment"># 这里是使用第一种方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># calculate the average of the two clusters</span></span><br><span class="line">        mergevec=[(clust[lowestpair[<span class="number">0</span>]].vec[i]+clust[lowestpair[<span class="number">1</span>]].vec[i])/<span class="number">2.0</span> \</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(clust[<span class="number">0</span>].vec))]</span><br><span class="line">        <span class="comment"># 平均距离</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># create the new cluster</span></span><br><span class="line">        newcluster=cluster_node(array(mergevec),left=clust[lowestpair[<span class="number">0</span>]],</span><br><span class="line">                             right=clust[lowestpair[<span class="number">1</span>]],</span><br><span class="line">                             distance=closest,<span class="built_in">id</span>=currentclustid)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># cluster ids that weren&#x27;t in the original set are negative</span></span><br><span class="line">        currentclustid-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">del</span> clust[lowestpair[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">del</span> clust[lowestpair[<span class="number">0</span>]]</span><br><span class="line">        clust.append(newcluster)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clust[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_clusters</span>(<span class="params">clust,dist</span>):</span></span><br><span class="line">    <span class="comment"># extract list of sub-tree clusters from hcluster tree with distance&lt;dist</span></span><br><span class="line">    clusters = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> clust.distance&lt;dist:</span><br><span class="line">        <span class="comment"># we have found a cluster subtree</span></span><br><span class="line">        <span class="keyword">return</span> [clust] </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># check the right and left branches</span></span><br><span class="line">        cl = []</span><br><span class="line">        cr = []</span><br><span class="line">        <span class="keyword">if</span> clust.left!=<span class="literal">None</span>: </span><br><span class="line">            cl = extract_clusters(clust.left,dist=dist)</span><br><span class="line">        <span class="keyword">if</span> clust.right!=<span class="literal">None</span>: </span><br><span class="line">            cr = extract_clusters(clust.right,dist=dist)</span><br><span class="line">        <span class="keyword">return</span> cl+cr </span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cluster_elements</span>(<span class="params">clust</span>):</span></span><br><span class="line">    <span class="comment"># return ids for elements in a cluster sub-tree</span></span><br><span class="line">    <span class="keyword">if</span> clust.<span class="built_in">id</span>&gt;=<span class="number">0</span>:</span><br><span class="line">        <span class="comment"># positive id means that this is a leaf</span></span><br><span class="line">        <span class="keyword">return</span> [clust.<span class="built_in">id</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># check the right and left branches</span></span><br><span class="line">        cl = []</span><br><span class="line">        cr = []</span><br><span class="line">        <span class="keyword">if</span> clust.left!=<span class="literal">None</span>: </span><br><span class="line">            cl = get_cluster_elements(clust.left)</span><br><span class="line">        <span class="keyword">if</span> clust.right!=<span class="literal">None</span>: </span><br><span class="line">            cr = get_cluster_elements(clust.right)</span><br><span class="line">        <span class="keyword">return</span> cl+cr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printclust</span>(<span class="params">clust,labels=<span class="literal">None</span>,n=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="comment"># indent to make a hierarchy layout</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="built_in">print</span> <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">    <span class="keyword">if</span> clust.<span class="built_in">id</span>&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="comment"># negative id means that this is branch</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># positive id means that this is an endpoint</span></span><br><span class="line">        <span class="keyword">if</span> labels==<span class="literal">None</span>: <span class="built_in">print</span> clust.<span class="built_in">id</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="built_in">print</span> labels[clust.<span class="built_in">id</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># now print the right and left branches</span></span><br><span class="line">    <span class="keyword">if</span> clust.left!=<span class="literal">None</span>: printclust(clust.left,labels=labels,n=n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> clust.right!=<span class="literal">None</span>: printclust(clust.right,labels=labels,n=n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getheight</span>(<span class="params">clust</span>):</span></span><br><span class="line">    <span class="comment"># Is this an endpoint? Then the height is just 1</span></span><br><span class="line">    <span class="keyword">if</span> clust.left==<span class="literal">None</span> <span class="keyword">and</span> clust.right==<span class="literal">None</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Otherwise the height is the same of the heights of</span></span><br><span class="line">    <span class="comment"># each branch</span></span><br><span class="line">    <span class="keyword">return</span> getheight(clust.left)+getheight(clust.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getdepth</span>(<span class="params">clust</span>):</span></span><br><span class="line">    <span class="comment"># The distance of an endpoint is 0.0</span></span><br><span class="line">    <span class="keyword">if</span> clust.left==<span class="literal">None</span> <span class="keyword">and</span> clust.right==<span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># The distance of a branch is the greater of its two sides</span></span><br><span class="line">    <span class="comment"># plus its own distance</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(getdepth(clust.left),getdepth(clust.right))+clust.distance</span><br><span class="line">      </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/post/61809.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>并查集指的是一个图中的若干个连通分支，任意两个连通分支间没有关系，而每个连通分支内部可以以任意一个点作为根节点，根节点指向它自己，而其他点指向他们的上级节点（因为是连通图，两点之间必定可达），因此只要在同一连通分支，必定可以到同一根节点，从而判断两者可达</p>
<p>例如：pre[2]=3表示2的上级节点为3，pre[3]=3表示这是一个根节点</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                    <span class="comment">//查找我（x）的掌门</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=x;                      <span class="comment">//委托 r 去找掌门</span></span><br><span class="line">    <span class="keyword">while</span> (pre[r ]!=r)           <span class="comment">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）</span></span><br><span class="line">    r=pre[r ] ;                 <span class="comment">// r 就接着找他的上级，直到找到掌门为止。</span></span><br><span class="line">    <span class="keyword">return</span>  r ;                <span class="comment">//掌门驾到~~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外如何将两个连通分支合并为一个连通分支呢？</p>
<p>我们可以把任意一个根节点指向另外一个根节点（因为我们不考虑内部的关系，指向知道是否可达），这样就变为一个连通分支了</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>          <span class="comment">//我想让虚竹和周芷若做朋友</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);         <span class="comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span></span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)                         <span class="comment">//玄慈和灭绝显然不是同一个人</span></span><br><span class="line">    pre[fx ]=fy;                       <span class="comment">//方丈只好委委屈屈地当了师太的手下啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路径压缩"><a class="markdownIt-Anchor" href="#路径压缩"></a> 路径压缩</h3>
<p>如果我们要经转很多个上级才能找到根节点，这样显然效率较低，假如我们可以直接让自己的上级是根节点，那就再好不过了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span> ];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                                       <span class="comment">//查找根节点</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )                           <span class="comment">//返回根节点 r</span></span><br><span class="line">          r=pre[r];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> i=x , j ;</span><br><span class="line">    <span class="keyword">while</span>( i != r )                                   <span class="comment">//路径压缩</span></span><br><span class="line">    &#123;</span><br><span class="line">         j = pre[ i ]; 				<span class="comment">// 在改变上级之前用临时变量  j 记录下他的值 </span></span><br><span class="line">         pre[ i ]= r ; 				<span class="comment">//把上级改为根节点</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带权并查集"><a class="markdownIt-Anchor" href="#带权并查集"></a> 带权并查集</h3>
<p>带权值的并查集只不过是在并查集中加入了一个value[ ]数组<br />
value[ ]可以记录很多种东西，不一定是类似距离这种东西，也可以是相对于根节点的状态</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">int findfat(int <span class="symbol">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(fat[<span class="symbol">x</span>] == <span class="symbol">x</span>) <span class="keyword">return</span> <span class="symbol">x</span>;</span><br><span class="line">	int tmp=fat[<span class="symbol">x</span>];</span><br><span class="line">	fat[<span class="symbol">x</span>]=findfat(fat[<span class="symbol">x</span>]);</span><br><span class="line">	<span class="comment">//在此处修改val比如：</span></span><br><span class="line">	value[<span class="symbol">x</span>]=value[tmp]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> fat[<span class="symbol">x</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/liujian20150808/article/details/50848646">参考文章</a></p>
]]></content>
  </entry>
  <entry>
    <title>广义表</title>
    <url>/post/14379.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>广义表一般记作：LS=（a1,a2,…)</p>
<p>其中ai在线性表中只可以是单个元素，而在广义表中即可以是单个元素，也可以是广义表。如果是单个元素，叫做原子，如果是广义表，叫做子表。当广义表非空时，第一个元素叫做广义表的表头，其余所有元素组成的表叫做广义表的表尾。</p>
<p>例如： A（），空表</p>
<p>B（e) 只有一个原子元素e,长度为1</p>
<p>c（a,(b,c,d)) 长度是2</p>
<p>d( a ( d)) 递归表</p>
<ul>
<li>广义表的储存结构</li>
</ul>
<p>通常用链式存储结构</p>
<p>每个节点有tag域（标志域），hp，tp三个域，但是原子节点（就是表头节点）只有两个域，标志域和值域</p>
<p>定义：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">glnnode</span></span></span><br><span class="line">&#123;</span><br><span class="line">    int tag;<span class="regexp">//</span>表示是原子节点还是表结点</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        int atom;<span class="regexp">//</span>原子节点值域</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ptr</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            glnnode *hp,*tp;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了空表表头指针为空外，其他表表头指针必定指向一个表节点</p>
<p>同一层次的表可以从第一个节点通过尾节点依次往后数，而头结点则指向一个原子节点或者是一个子表。</p>
<p>例如，画出c表的表示</p>
<p>| | | 代表tag， 头结点，尾结点</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">c-&gt; 1|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> -&gt; 1</span>|<span class="string"> </span>|<span class="string"> NULL</span></span><br><span class="line"><span class="string">    </span>|<span class="string">      </span>|<span class="string">  </span></span><br><span class="line"><span class="string">    -&gt;0</span>|<span class="string">a</span>|<span class="string">   -&gt;1</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt;1</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt;1</span>|<span class="string"> </span>|NULL</span><br><span class="line">             |<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">             -&gt;0|<span class="string">b</span>|<span class="string">-&gt;0</span>|<span class="string">c</span>|<span class="string">-&gt;0</span>|<span class="string">c</span>|</span><br></pre></td></tr></table></figure>
<p>这个代表的是 c=（a,(b,c,d))，可以看到，第一层节点的数目就是表的长度，第一层如果头结点接一个原子节点，那么在表中代表一个数，如果接一个表节点，代表一个子表，同理，第二层头节点如果是一个数，那么就代表第二层增加一个元素，如果头结点接一个表节点，那么说明还有一个子表</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>开始使用unix</title>
    <url>/post/9187.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>当你使用Unix系统的时候，第一件要你做的事便是输入用户标识和口令（账号密码），注意，在Unix中，密码是完全不可见的，甚至连*号都不会出现。</p>
<p>登陆之后出现的欢迎界面，这一部分源于一个特殊的初始化文档，这就意味着你可以对文档内容进行修改从而定制化你的初始化界面。</p>
<p>一旦初始化命令结束执行，Unix将启动shell，并将控制权交给他。这时shell会出现一个提示-称为shell提示，并等待命令。接下来就可以输入各种命令了。</p>
<p>最终，没有命令时，你可以通过注销结束工作会话，此时shell将停止运行。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/post/11306.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>步骤：<br />
1.先从数列中取出一个数作为基准数。</p>
<p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p>
<p>3．再对左右区间重复第二步，直到各区间只有一个数。</p>
<p>例 6 1 2 7 9 3 4 5 10 8 进行排序<p><br />
1 以6为基准数，先从右边找比6小的数，我们用一个变量j一步步向左移动，好在移动三次后我<br />
们找到了5，j为7。现在再让另一个变量i向右移动去找比6大的数，当i为3时找到了7.现在再让5<br />
和7互换，得到了6 1 2 5 9 3 4 7 10 8,。在让j向左移动，找到了4，i向右找到了9，再让两个数<br />
互换，j再向左到3，此时i向左也到3，两者相遇，便让3和6互换，第一次结束<br />
（想想原因）<p><br />
2 现在分为两部分，左边全比6小，右边全比6大，为3 1 2 5 4 6 9 7 10 8<br />
再在3 1 2 5 4 中用同样的方法搜索一次得到2 1 3 5 4,再在2 1 中搜索得到1 2<br />
然后在5 4 中搜索得到4 5，左边排序完成，右边用同样的方法排序就可得到答案</p>
<p>不说了，上代码</p>
 <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">void</span> <span class="keyword">sort</span>(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span>(l&lt;r)<span class="comment">//l大于等于r时这一段排序结束</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i=l,j=r,x=a[l];</span><br><span class="line"> <span class="keyword">while</span>(i&lt;j)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;j&amp;&amp;a[j]&gt;=x)</span><br><span class="line">  &#123;</span><br><span class="line">      j--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;j&amp;&amp;a[i]&lt;=x)</span><br><span class="line">  &#123;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(a[i],a[j]);</span><br><span class="line"> &#125;</span><br><span class="line"> swap(a[l],a[i]);</span><br><span class="line"> <span class="keyword">sort</span>(a,l,i-<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">sort</span>(a,i+<span class="number">1</span>,r);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>引用 转载请标明出处，原文地址：<a href="http://blog.csdn.net/morewindows/article/details/6684558">http://blog.csdn.net/morewindows/article/details/6684558</a><br />
csdn 我见过最通俗易懂的快速排序过程讲解，转自《坐在马桶上看算法：快速排序》</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/post/28877bf.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="产生过程"><a class="markdownIt-Anchor" href="#产生过程"></a> 产生过程</h3>
<p>当程序运行时，可能会产生异常，当cpu检测到这些时间发生时，就会通过异常表跳转到异常处理程序，然后进行处理。</p>
<p>异常表示常驻于内存中的，每个异常都有一个异常号，事件发送的是异常号，之后根据异常号找到异常表中的对应项再跳转过去。异常表的首地址存放在一个特殊的寄存器中。</p>
<p>当一场处理结束之后，可能会跳转到下一条语句，可能跳转到当前语句，也可能终止程序。</p>
<p>要注意，这里讲的异常是系统提供的异常，要把用户程序中设定的异常区分开。</p>
<h3 id="类别"><a class="markdownIt-Anchor" href="#类别"></a> 类别</h3>
<h4 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h4>
<p>中断是用来和外部设备进行交互的，例如网卡，usb和磁盘。</p>
<p>每当这些设备有操作完成时，都会发给cpu一个信号叫cpu去取数据（cpu上有一个特殊的引脚专门去接受这些数据）。之后cpu就会执行中断程序然后去取数据。</p>
<p>一个显著的例子就是scanf，cpu不可能一到scanf就停止运行，肯定还要继续做各种各样的事。他只是调用了scanf函数给标准输入发出信号，有数据来了就告诉我。之后标准输入输入完成之后并不是直接存到内存中，而是先存到一个缓存中（例如键盘有usb缓存），然后告诉cpu要读数据，cpu才会执行中断去读数据。</p>
<p>执行中断程序之前，首先要把所有寄存器的值都保护好，之后才去执行。</p>
<h4 id="陷阱和系统调用"><a class="markdownIt-Anchor" href="#陷阱和系统调用"></a> 陷阱和系统调用</h4>
<p>陷阱又叫系统调用。它是一种故意的中断，是执行一条指令的结果。执行完后回到下一条指令。</p>
<p>这是用户向系统请求服务，例如读文件，打开文件，创建文件，终止进程等。</p>
<p>系统提供了syscall n 指令专门用来调用这些功能。当这条指令执行时，会中断当前线程然后跳到内核中执行相应的代码，执行完成之后又会返回。</p>
<h4 id="故障"><a class="markdownIt-Anchor" href="#故障"></a> 故障</h4>
<p>故障是有可能修复的异常，这种异常执行完成之后会跳转到当前语句再执行一次。</p>
<p>一种典型的故障是缺页异常，缺页异常是虚拟内存的东西（现在还没学，就不瞎比比了）。</p>
<h4 id="终止"><a class="markdownIt-Anchor" href="#终止"></a> 终止</h4>
<p>终止是不可恢复的错误，通常是硬件错误，例如突然缺少什么信息等等。一般这种异常都会直接调用abort终止程序。</p>
<p><img src="/images/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>快速输入</title>
    <url>/post/54778.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="attribute">x</span>=0,f=1;</span><br><span class="line">    char <span class="attribute">ch</span>=getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span> (<span class="attribute">ch</span>==&#x27;-&#x27;) <span class="attribute">f</span>=-1;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;<span class="attribute">x</span>=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;</span><br><span class="line">    return x<span class="number">*f</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个快速输入只适合int类型，另外如果参加比赛，最好不要用cin，cout，速度较慢<br />
用scanf，printf更好</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/post/63711.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h4>
<p>归并排序运用了分治的思想，先将数组二分成一个元素（一个元素时看为有序），然后将这些元素不断合并，每合并一次排一次序，最后就可以得到有序的数组。</p>
<p>比如说一个序列:12 ,23,1,44,233,10,9,8。我们先分成两段：12 ,23,1,44 和 233,10,9,8，<br />
发现还能再分成4段：12 ,23 和 1,44------233,10 和 9,8。<br />
再分成8段：12–23–1--44 和233–10–9--8。<br />
这时候开始把子序列进行排序合并，一个元素就是有序的。所以不用排序。<br />
合并成2个一组排序得到：12，23----1，44—10，233—8，9。<br />
再合并成4个一组排序得到：1，12，23，44—8，9，10，233。<br />
最后合并得到最终结果：1，8，9，10，12，23，44，233。</p>
<p>合并过程看代码</p>
<p>链接：<a href="https://www.jianshu.com/p/b50a6034eb90">https://www.jianshu.com/p/b50a6034eb90</a></p>
<h4 id="图解"><a class="markdownIt-Anchor" href="#图解"></a> 图解</h4>
<p><img src="/images/1024555-20161218163120151-452283750.png" alt="" /></p>
<p>这个图片蓝色部分就是拆的过程，而绿的部分为并的过程</p>
<h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paixu</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> mid,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span><span class="comment">//这是合并过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1=first,l2=mid+<span class="number">1</span>,r1=mid,r2=last;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1&amp;&amp;l2&lt;=r2)<span class="comment">//两部分都存在时看哪个小就加上哪个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l1]&lt;=a[l2])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1)<span class="comment">//第一部分有剩余就把第一部分剩下的全加上</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2&lt;=r2)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i+first]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xunhuan</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(first+last)/<span class="number">2</span>;</span><br><span class="line">        xunhuan(first,mid,a,temp);<span class="comment">//拆左边</span></span><br><span class="line">        xunhuan(mid+<span class="number">1</span>,last,a,temp);<span class="comment">//拆右边</span></span><br><span class="line">        paixu(first,mid,last,a,temp);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[last-first];<span class="comment">//建一个临时数组，合并时用</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="comment">//判断是否传入空数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xunhuan(first,last,a,p);</span><br><span class="line">    <span class="keyword">delete</span> [] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>动态顺序统计</title>
    <url>/post/20ff5ccb.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先要了解<a href="https://xinhecuican.github.io/post/f89cb603.html#more">红黑树</a>.</p>
<p>顺序统计树指示在普通的红黑树上附加了一个参量，x-&gt;size。这个参量表示的是该节点的子树含有元素个数。</p>
<p>为了找出第i小的关键字，可以用：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">select</span>(node<span class="comment">* x, int i)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int r = x-&gt;left-&gt;size + 1;</span></span><br><span class="line">    </span><br><span class="line">    //<span class="meta">x</span>的序号，因为红黑树也是一个排序树，所以<span class="meta">x</span>一定比左边元素都大</span><br><span class="line">    <span class="meta">if</span>(i == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">return</span> <span class="meta">x</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">else</span> <span class="meta">if</span>(i &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">return</span> <span class="meta">select</span>(<span class="meta">x</span>-&gt;left, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">return</span> <span class="meta">select</span>(<span class="meta">x</span>-&gt;right, i-r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>确定一个元素的秩</strong></p>
<p>秩指的是排第几号元素。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">rank(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">int</span> r = x-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span>size + <span class="number">1</span>;</span><br><span class="line">    node* y = x;</span><br><span class="line">    <span class="function"><span class="title">while</span>(y != t-&gt;</span>root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(y == y-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right)<span class="comment">//如果是右子树，那么还要加上左子树的数目</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">r</span> = r+y-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">y</span> = y-&gt;</span>p;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，使用中序遍历可以得到排序树的排序。中间循环的过程就是找到x在父亲节点子树中位置然后再到祖宗节点中所处位置最后到根节点所处位置。</p>
<p><strong>维护</strong></p>
<p>对于插入，红黑树插入分为两个阶段，第一阶段是找位置，只需要沿途让size+1就好了，第二阶段是旋转。对于左子树， x是原来最上面的节点，现在size是<code>x-&gt;left-&gt;size + x-&gt;right-&gt;size + 1</code>， 对于右儿子y来说，y的size就是最开始x的size（因为现在它使根节点）</p>
<h1 id="区间树"><a class="markdownIt-Anchor" href="#区间树"></a> 区间树</h1>
<p>区间树是另一种红黑树的扩展。它和普通红黑树的区别是多了一个区间x-&gt;int(interval)表示，区间最大值是int.high(区间的右端点),最小值是int.low.</p>
<p>此外，还附加了max（以x为根的子树中所有区间端点的最大值）</p>
<p><code>x-&gt;max = max(x-&gt;int-&gt;high, x-&gt;left-&gt;max, x-&gt;right-&gt;max)</code></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">search(node* t, int(interval) i)<span class="comment">//查找与i重叠的区间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">node</span>* x = t-&gt;</span>root;</span><br><span class="line">    <span class="function"><span class="title">while</span>(x != NULL &amp;&amp; (x-&gt;</span><span class="function"><span class="title">int</span>-&gt;</span><span class="function"><span class="title">low</span>&gt;i-&gt;</span><span class="function"><span class="title">high</span> || x-&gt;</span><span class="function"><span class="title">int</span>-&gt;</span><span class="function"><span class="title">high</span>&lt;i-&gt;</span>low))<span class="comment">//x!=NULL &amp;&amp; i不在x的区间范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">if</span>(x-&gt;</span><span class="function"><span class="title">left</span> != NULL &amp;&amp; x-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="function"><span class="title">max</span> &gt;= i-&gt;</span>low)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">x</span> = x-&gt;</span>left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">x</span> = x-&gt;</span>right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最优二叉搜索树"><a class="markdownIt-Anchor" href="#最优二叉搜索树"></a> 最优二叉搜索树</h1>
<p>给一个n个不同关键字的已排序序列，用这些关键字构建一个二叉搜索树。对于每个关键字ki，都有一个概率pi表示搜索概率。因为还有可能没有搜索到，所以还有n+1个伪关键字。</p>
<p>可以证明，最优二叉搜索树的子树也是最优二叉树。</p>
<p>所以我们求解的子问题为： 求解ki到kj的最优二叉搜索树。并且 j&gt;=i-1.当j=i-1时，不包含关键字。</p>
<p>当j=i-1时，子树中只包含伪关键字di-1， 所以搜索代价是qi-1</p>
<p>当j&gt;=i时，我们要选取一个根节点kr, ki到kr-1为左子树，kr+1到j为右子树。当一棵树成为另一棵树的子树时，因为每个节点的深度都加1，所以搜索代价的增加值应该是所有概率之和，记这个概率为w(i, j)</p>
<p>注意w(i, j) = w(i, r-1) + pr + w(r+1, j)</p>
<p>所以现在概率应该是原来左子树代价+原来右子树代价+增加代价</p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%925.jpg" alt="" /></p>
<p>这就是最优搜索代价的递归公式。e[i, j]表示从i到j构成的二叉树的最优搜索代价。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">bst(int* p, int* q, int n)</span><br><span class="line">&#123;</span><br><span class="line">    //q是伪关键字搜索频率</span><br><span class="line">    int max = 2147483647;</span><br><span class="line">    int e<span class="comment">[n+2]</span><span class="comment">[n+1]</span>, w<span class="comment">[n+2]</span><span class="comment">[n+1]</span>, root<span class="comment">[n+1]</span><span class="comment">[n+1]</span>;</span><br><span class="line">    for(int i=1; i&lt;=n+1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e<span class="comment">[i]</span><span class="comment">[i-1]</span> = q<span class="comment">[i-1]</span>;</span><br><span class="line">        w<span class="comment">[i]</span><span class="comment">[i-1]</span> = q<span class="comment">[i-1]</span>;</span><br><span class="line">        for(int l=1; l&lt;=n; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i + l - 1;</span><br><span class="line">            e<span class="comment">[i]</span><span class="comment">[j]</span> = max;</span><br><span class="line">            w<span class="comment">[i]</span><span class="comment">[j]</span> = e<span class="comment">[i]</span><span class="comment">[j-1]</span> + p<span class="comment">[j]</span> + q<span class="comment">[j]</span>;</span><br><span class="line">            for(int r=i; r&lt;=j; r++)</span><br><span class="line">            &#123;</span><br><span class="line">                t = e<span class="comment">[i]</span><span class="comment">[r-1]</span> + e<span class="comment">[r+1]</span><span class="comment">[j]</span> + w<span class="comment">[<span class="comment">[i]</span><span class="comment">[j]</span>;</span></span><br><span class="line"><span class="comment">                if(t &lt; e<span class="comment">[i]</span><span class="comment">[j]</span>)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    e<span class="comment">[i]</span><span class="comment">[j]</span> = t;</span></span><br><span class="line"><span class="comment">                    root<span class="comment">[i]</span><span class="comment">[j]</span> = r;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return e;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>抽样分布定理证明</title>
    <url>/post/74e7fdff.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>定理 ：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mi>S</mi><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{(n-1)S^{2}}{\sigma^{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4539199999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10892em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><strong>证明</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mi>S</mi><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo>+</mo><mi>μ</mi><mo>−</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mfrac><mn>1</mn><msup><mi>σ</mi><mn>2</mn></msup></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mfrac><mn>1</mn><msup><mi>σ</mi><mn>2</mn></msup></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mfrac><mn>1</mn><msup><mi>σ</mi><mn>2</mn></msup></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mi>n</mi><mo stretchy="false">(</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mfrac><mn>1</mn><msup><mi>σ</mi><mn>2</mn></msup></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mi>n</mi><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac><mo>−</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac><mo>−</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><msup><mi>σ</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><msqrt><mi>n</mi></msqrt></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\frac{(n-1)S^2}{\sigma^2} =&amp; \sum_{k=1}^n\frac{(x_i-\overline{x})^2}{\sigma^2}\\
    =&amp; \sum_{k=1}^n\frac{(x_i - \mu +\mu - \overline{x})^2}{\sigma^2}\\
    =&amp;\frac{1}{\sigma^2} \sum_{i=1}^{n}(( x_i-\mu)^2 - 2(x_i-\mu )(\bar{x} - \mu) + (\bar{x}-\mu)^2)\\
=&amp; \frac{1}{\sigma^2} \sum_{i=1}^{n}( x_i-\mu)^2 - 2(\bar{x} - \mu)\sum_{i=1}^{n}(x_i-\mu ) + \sum_{i=1}^{n}(\bar{x}-\mu)^2\\
=&amp; \frac{1}{\sigma^2} \sum_{i=1}^{n}( x_i-\mu)^2 - 2(\bar{x} - \mu)n(\frac{1}{n}\sum_{i=1}^{n}x_i -\mu\times n)+ \sum_{i=1}^{n}(\bar{x}-\mu)^2\\
=&amp; \frac{1}{\sigma^2} \sum_{i=1}^{n}( x_i-\mu)^2 - 2n(\bar{x} - \mu)^2+ \sum_{i=1}^{n}(\bar{x}-\mu)^2\\
    =&amp; \sum_{k=1}^n\frac{(x_i - \mu)^2}{\sigma^2} -\sum_{k=1}^n\frac{(\overline{x}-\mu)^2}{\sigma^2}\\
    =&amp; \sum_{k=1}^n\frac{(x_i - \mu)^2}{\sigma^2} - \frac{n(\overline{x}-\mu)^2 }{\sigma^2}\\
    =&amp; \sum_{k=1}^n\frac{(x_i - \mu)^2}{\sigma^2} - \frac{(\overline{x}-\mu)^2}{\sigma^2 / \sqrt{n}}\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:29.18381399999999em;vertical-align:-14.341906999999996em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:14.841906999999997em;"><span style="top:-16.841906999999996em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span><span style="top:-13.588396999999997em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-10.334886999999998em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-7.105820999999999em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-3.8767549999999993em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-0.6476889999999995em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:2.581377em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:5.834886999999998em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:9.088396999999997em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:14.341906999999996em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:14.841906999999997em;"><span style="top:-16.841906999999996em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-13.588396999999997em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-10.334886999999998em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-7.105820999999999em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.8767549999999993em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-0.6476889999999995em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:2.581377em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:5.834886999999998em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:9.088396999999997em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.30972em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9402800000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:14.341906999999996em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac><mo>∼</mo><msubsup><mi>X</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sum_{k=1}^n\frac{(x_i - \mu)^2}{\sigma^2} \sim X_{n}^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9535100000000005em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><msup><mi>σ</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><msqrt><mi>n</mi></msqrt></mrow></mfrac><mo>∼</mo><msubsup><mi>X</mi><mn>1</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\frac{(\overline{x}-\mu)^2}{\sigma^2 / \sqrt{n}} \sim X_1^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.431388em;vertical-align:-0.9402800000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.30972em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9402800000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mi mathvariant="normal">与</mi><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">(x_i - \mu)^2 与 \overline{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">与</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>相互独立，所以根据卡方分布可加性可得服从于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">X_{n-1}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1205469999999997em;vertical-align:-0.30643899999999996em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-2.451892em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30643899999999996em;"><span></span></span></span></span></span></span></span></span></span></p>
]]></content>
      <categories>
        <category>数学</category>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/post/a444b428.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h1>
<p>稳定？不稳定： 稳定指的是两个相同的元素排序完成之后在表中相对位置不变。</p>
<h2 id="直接插入"><a class="markdownIt-Anchor" href="#直接插入"></a> 直接插入</h2>
<p>当插入第i个时，前i-1个已经排好了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        tag = a[i];</span><br><span class="line">        <span class="type">int</span> <span class="keyword">temp</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i<span class="number">-1</span>; k&gt;=<span class="number">0</span>; k<span class="comment">--)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k]&gt;tag)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">                <span class="keyword">temp</span> = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[k+<span class="number">1</span>] = tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认第一个已经排好，从第二个开始从后往前排，如果第k个数比要比较的数大就把这个数往后排。</p>
<p>复杂度： n^2</p>
<h2 id="折半插入"><a class="markdownIt-Anchor" href="#折半插入"></a> 折半插入</h2>
<p>折半排序基于前面的直接插入，不同的是它通过二分找插入位置。然后再移动</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line">for(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">n</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    tag = a[i];</span><br><span class="line">    <span class="built_in">int</span> low=<span class="number">0</span>, high=i-<span class="number">1</span>;</span><br><span class="line">    while(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">mid</span> = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">if</span>(a[<span class="built_in">mid</span>]&gt;tag)</span><br><span class="line">        &#123;</span><br><span class="line">            high = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            low = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//high+<span class="number">1</span>是插入位置</span><br><span class="line">    for(<span class="built_in">int</span> k=i-<span class="number">1</span>; k&gt;=high+<span class="number">1</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    a[high+<span class="number">1</span>] = tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度 n^2</p>
<h2 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h2>
<p>思想： 把序列按gap划分成若干个子序列。例如有6个元素，gap是3，那么第0个和第3个是一个序列，第1个和第4个是一个序列。之后在每个子序列中直接插入。然后折半缩小gap。</p>
<p>第一个gap一般取n/2。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> gap = n/<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(gap != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=gap; i&lt;n; i++)//从gap开始是因为直接插入排序中默认第一个已经排序</span><br><span class="line">    &#123;</span><br><span class="line">        tag = a[i];</span><br><span class="line">        <span class="type">int</span> <span class="keyword">temp</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i-gap; k&gt;=<span class="number">0</span>; k-=gap)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k]&gt;tag)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k+tag] = a[k];</span><br><span class="line">                <span class="keyword">temp</span> = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="keyword">temp</span>+tag] = tag;</span><br><span class="line">    &#125;</span><br><span class="line">    gap /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：n(longn)^2。但这是一种不稳定的排序</p>
<h2 id="起泡排序"><a class="markdownIt-Anchor" href="#起泡排序"></a> 起泡排序</h2>
<p>起泡排序是过程是逐个比较，比较出最小的放到第一个，然后放到第二个。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">int flag=<span class="number">0</span>,exchange=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag&lt;n-<span class="number">1</span> &amp;&amp; exchange==<span class="number">0</span>)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    exchange = 0;</span></span><br><span class="line"><span class="comment">    for(int i=n-1; i&gt;flag; i--)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(a[i-1]&gt;a[i])</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            a[i-1] = a[i] ^ a[i-1];</span></span><br><span class="line"><span class="comment">            a[i] = a[i] ^ a[i-1];</span></span><br><span class="line"><span class="comment">            a[i-1] = a[i] ^ a[i-1];</span></span><br><span class="line"><span class="comment">            exchange = 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line">        <span class="comment">//这一步后小的在前面，然后下一次又是把i-1和i-2比，如果i-1小，又跑到前面</span></span><br><span class="line">        <span class="comment">//这样第i-1个一直是最小的（相对于它后面的元素）</span></span><br><span class="line">    &#125;</span><br><span class="line">    flag++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度 n^2</p>
<h1 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h1>
<p><a href="https://xinhecuican.github.io/post/11306.html">以前的一篇</a></p>
<h1 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h1>
<h2 id="直接选择排序"><a class="markdownIt-Anchor" href="#直接选择排序"></a> 直接选择排序</h2>
<p>这个就不多说了。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">min</span> = <span class="number">2147483647</span>;</span><br><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line">for(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">n</span>-<span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for(<span class="built_in">int</span> k=i+<span class="number">1</span>; k&lt;<span class="built_in">n</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">if</span>(a[k]&lt;<span class="built_in">min</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">min</span> = a[k];</span><br><span class="line">            tag = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap（a[i], a[tag]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h2>
<p>堆排序是完全二叉树产生的数组。然后建立一个父节点比子节点大/小的数组。父节点比子节点大的叫大顶堆，父节点比子节点小的叫小顶堆。</p>
<p>假设父节点是i，那么两个子节点分别是i<em>2和i</em>2+1。下标要从1开始</p>
<p>过程，以小顶堆为例</p>
<ul>
<li>初始化，首先构造一个大顶堆，过程是用这个节点和它的父节点进行比较，如果小就交换位置，然后再和新位置的父节点进行比较。先拿第一个数和第二个数进行比较，如果第一个数比第二个数小那个交换位置。然后第三个数和第一个数比较。此外，还可以从小到大直接建</li>
</ul>
<p>之后第4个数是插入到第二个数上的，就拿第四个数和第二个数比较，如果第四个数比第二个数小就把第二个数往上提，之后再和第一个数进行比较。然后依此类推。</p>
<p><img src="/images/%E6%8E%92%E5%BA%8F.png" alt="" /></p>
<ul>
<li>把第一个元素和最后一个元素进行交换，然后对前n-1个元素进行处理。开始我们建立的是大顶堆，现在我们把最大的放到后面就变成小顶堆了。并且这时不仅满足小顶堆，还满足左儿子一定比右儿子小。</li>
</ul>
<p><img src="/images/%E6%8E%92%E5%BA%8F2.png" alt="" /></p>
<ul>
<li>之后就是用根节点左右儿子中比较大的节点和根节点进行比较。然后如果比根节点大就进行换位。然后再在新位置和新的子节点进行比较。完成之后又把根节点放到最后。之后就重复第二步和第三步。（不画图了，难死我了）</li>
</ul>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">//根据上面自己写的，拿过几个数据代过，如果想看更标准的可以看下面模板(饶命)</span><br><span class="line">void Heap(<span class="built_in">int</span> *a, <span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="built_in">n</span>/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">now</span> = i;</span><br><span class="line">        while((<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>) &lt;= <span class="built_in">n</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> largest ;</span><br><span class="line">            <span class="built_in">int</span> l = <span class="built_in">now</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> r = (<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">if</span>((<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>)+<span class="number">1</span> == <span class="built_in">n</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">if</span>(a[l] &gt; a[<span class="built_in">now</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">int</span> temp = a[l];</span><br><span class="line">                    a[l] = a[<span class="built_in">now</span>];</span><br><span class="line">                    a[<span class="built_in">now</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span>(a[l] &gt; a[r])</span><br><span class="line">            &#123;</span><br><span class="line">                largest = l;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                largest = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span>(a[largest] &gt; a[<span class="built_in">now</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = a[largest];</span><br><span class="line">                a[largest] = a[<span class="built_in">now</span>];</span><br><span class="line">                a[<span class="built_in">now</span>] = temp;</span><br><span class="line">                <span class="built_in">now</span> = largest;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//初始化</span><br><span class="line">            </span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="built_in">n</span>; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">1</span>] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        a[i] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">now</span> = <span class="number">1</span>;</span><br><span class="line">        while((<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>) &lt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> big;</span><br><span class="line">            <span class="built_in">if</span>((<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>)+<span class="number">1</span> == i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = <span class="built_in">now</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">if</span>(a[<span class="built_in">now</span>] &lt; a[temp])</span><br><span class="line">                &#123;</span><br><span class="line">                    a[<span class="built_in">now</span>] = a[temp] ^ a[<span class="built_in">now</span>];</span><br><span class="line">                    a[temp] = a[temp] ^ a[<span class="built_in">now</span>];</span><br><span class="line">                    a[<span class="built_in">now</span>] = a[temp] ^ a[<span class="built_in">now</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;//只有左节点</span><br><span class="line">            <span class="built_in">if</span>(a[<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>] &lt; a[(<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                big = (<span class="built_in">now</span>&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                big = <span class="built_in">now</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span>(a[big] &gt; a[<span class="built_in">now</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                a[big] = a[big] ^ a[<span class="built_in">now</span>];</span><br><span class="line">                a[<span class="built_in">now</span>] = a[big] ^ a[<span class="built_in">now</span>];</span><br><span class="line">                a[big] = a[big] ^ a[<span class="built_in">now</span>];</span><br><span class="line">                <span class="built_in">now</span> = big;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆长度</span></span><br><span class="line"><span class="keyword">int</span> heapsize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//大顶堆化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MAX_HEAPIFY</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">2</span> * i;		<span class="comment">//把 i 的左儿子 下标 赋给l</span></span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">2</span> * i + <span class="number">1</span>;		<span class="comment">//把 i 的左儿子 下标 赋给r</span></span><br><span class="line">	<span class="keyword">int</span> largest;	<span class="comment">//3个里面最大的下标</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (l &lt;= heapsize &amp;&amp; A[l]&gt;A[i])</span><br><span class="line">		largest = l;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		largest = i;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (r &lt;= heapsize &amp;&amp; A[r]&gt;A[largest])</span><br><span class="line">		largest = r;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (largest != i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//交换 A[largest] 和 A[i]</span></span><br><span class="line">		<span class="keyword">int</span> tmp = A[largest];</span><br><span class="line">		A[largest] = A[i];</span><br><span class="line">		A[i] = tmp;</span><br><span class="line"> </span><br><span class="line">		MAX_HEAPIFY(A, largest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BUILD_MAX_HEAP</span><span class="params">(<span class="keyword">int</span> A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = (<span class="keyword">int</span>)(heapsize / <span class="number">2</span>); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		MAX_HEAPIFY(A, i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, A[j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HEAPSORT</span><span class="params">(<span class="keyword">int</span> A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BUILD_MAX_HEAP(A);		<span class="comment">//ok</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="keyword">for</span> (i = heapsize; i &gt;= <span class="number">2</span>; i--)		<span class="comment">//A[1] 必定是最大的</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//交换 A[1] 和 A[i]</span></span><br><span class="line">		tmp = A[<span class="number">1</span>];</span><br><span class="line">		A[<span class="number">1</span>] = A[i];</span><br><span class="line">		A[i] = tmp;</span><br><span class="line"> </span><br><span class="line">		heapsize--;</span><br><span class="line">		MAX_HEAPIFY(A, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">11</span>] = &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line">	<span class="comment">//ok</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) - <span class="number">1</span>;</span><br><span class="line">	heapsize = n;</span><br><span class="line"> </span><br><span class="line">	HEAPSORT(A);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, A[i]);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度： nlogn.但是不稳定</p>
<h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2>
<p><a href="https://xinhecuican.github.io/post/63711.html">以前博客</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>接口</title>
    <url>/post/5951da65.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="接口的基本特征"><a class="markdownIt-Anchor" href="#接口的基本特征"></a> 接口的基本特征</h3>
<p>在java中接口有两种意思</p>
<ul>
<li>第一种是概念性的接口，指的是封装的内容对外界提供的服务（一开始一听接口一定以为就是这个吧）</li>
<li>第二种是一种接口类型</li>
</ul>
<p>定义接口使用interface关键字，实现接口使用implement关键字。这个类似于父类和子类。</p>
<p>注意点：</p>
<ul>
<li>接口成员变量默认是public或static或final类型的，必须显示初始化。例如</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> b;</span><br><span class="line">    <span class="built_in">int</span> c = <span class="number">3</span>;<span class="comment">//正确，显式初始化表示定义同时要赋值，并且默认是上面三种类型</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure>
<ul>
<li>方法默认是public abstract类型。JDK8开始才可以有默认方法和静态方法之前只能有抽象方法。默认方法用<strong>default关键字</strong>声明，可以有自己的实现，接口实现类可以直接访问默认方法，也可以覆盖它。静态方法可以在接口内部访问或者实现接口的类通过使用接口名字来访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;<span class="comment">//默认是public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;<span class="comment">//编译器默认是public的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;<span class="comment">//不可以，必须要有abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口没有构造方法，不能够被实例化</li>
<li>接口可以继承于多个接口，但是不能实现接口。例如：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">A</span></span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">B</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">C</span> <span class="symbol">extends</span> <span class="symbol">A</span>,<span class="symbol">B</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>与子类继承抽象父类相似，当类实现某个接口时，<strong>必须要重写接口中的所有抽象方法，否则这个类必须定义成抽象类</strong>。</li>
<li>不允许创建接口的实例，但允许创建接口类型的引用变量，该变量引用实现了接口的类的实例（也可以看成是子类的实例）</li>
<li>一个类只能够继承一个父类，但可以实现多个接口。例如：<br />
<code>public class A extends Base implement intera, interb&#123;...&#125;</code>。并且一个接口也可以由多个类来实现。</li>
</ul>
<p>接口可以在一定程度上弥补一个类只能有一个直接父类的遗憾，有利于扩展。</p>
<h3 id="接口模式"><a class="markdownIt-Anchor" href="#接口模式"></a> 接口模式</h3>
<h4 id="定制服务模式"><a class="markdownIt-Anchor" href="#定制服务模式"></a> 定制服务模式</h4>
<p>这种模式就是利用接口可以继承多个接口，把多个子功能整合到一起变成一个大的服务。例如一个套餐里面有流量服务，电话服务，语音服务等等。这些都是一个接口。之后整合成整个的套餐包含上述服务</p>
<h4 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h4>
<p>适配器就是用来做两个系统之间转换的。有两种方式实现转换。</p>
<p>第一种就是通过继承，继承源类的实例和目标类的接口。</p>
<p>第二种是通过组合，组合两种类的接口，然后实现。</p>
<p>例如，一个接口有add（a,b)函数，另一个有addone(a)函数，第二个函数不能作用是让a+1，但是它没有加法（假设）。这时我们设计一个接口，继承上面两个接口，这样我们就有办法用原接口的实现类从而实现加法完成第二个方法。</p>
<h4 id="默认适配器模式"><a class="markdownIt-Anchor" href="#默认适配器模式"></a> 默认适配器模式</h4>
<p>这种适配器其实是一个类，因为接口中都是抽象函数，所以当你使用适配器的时候不得不实现所有功能-即使你只想实现一个。所以干脆实现了一种类，这个类实现了所有抽象方法，但是内容全是空。这样再用其他类继承这个类就可以一次实现一种了。</p>
<h4 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h4>
<p>代理人其实就是中间人，代理类和代理人类似，这个类负责预处理一些消息，例如钱少于多少就直接拒绝。也负责向委托类传递信息。</p>
<h4 id="标识类型模式"><a class="markdownIt-Anchor" href="#标识类型模式"></a> 标识类型模式</h4>
<p>标识类型一般是标识某一类事物。例如事物，树，人物等等。使用这种接口而不是直接使用一个类的好处是便于同一管理。</p>
<h4 id="常量接口"><a class="markdownIt-Anchor" href="#常量接口"></a> 常量接口</h4>
<p>常量接口就是把一些常量放到一起。要使用的时候直接implements就可以了。</p>
<p>但是这种接口有一个弊端，就是破坏了封装性。为了解决这个问题，可以使用import static语句。import static允许直接访问另一个类的静态常量</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>操作符offset</title>
    <url>/post/59431.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>offset是由编译器处理的符号，它的功能是获得标号的偏移地址</p>
<p>例</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset start//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">0</span></span><br><span class="line"><span class="symbol">   s:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset s//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">3</span></span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>
<p>上面的程序中offset获得了start和s的偏移地址0和3</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>支持向量机</title>
    <url>/post/280b588e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="引入"><a class="markdownIt-Anchor" href="#引入"></a> 引入</h1>
<p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA1.png" alt="" /></p>
<p>上图中黑色和白色的点分别代表一类事物，我们想用一条直线把这两类事物区分开，显而易见红线区分最好，那么为什么红线区分最好呢？</p>
<p>这里引入了一个概念，边际。边际指的是做一个超平面，使得两侧离的最近的点的距离。</p>
<p>如何选取使边际(margin)最大的超平面 (Max Margin Hyperplane)？</p>
<p>超平面到一侧最近点的距离等于到另一侧最近点的距离，两侧的两个超平面平行。</p>
<h1 id="选取最大超平面"><a class="markdownIt-Anchor" href="#选取最大超平面"></a> 选取最大超平面</h1>
<p>超平面可以定义为： W * X + b = 0</p>
<p>W是一个类似于权重的向量， X是我们给出的实例的特征向量， b是偏好</p>
<p>超平面方程也可以写成<img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA2.png" alt="" />这是二维的，b也就是w0.</p>
<p>上方的点满足大于零，下方的点小于零</p>
<p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA4.png" alt="" /></p>
<p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA3.png" alt="" /></p>
<p>H1就是上边界，也就是两个图中上面的这条线，至于为什么后面是1？这只是用来区分上边界还是下边界，可以通过w0进行调节。我们输入其实就是(x1,x2,…, yi)，yi就是类别标记</p>
<p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA5.png" alt="" />两个公式可以合并</p>
<p>在边界上的点叫做<strong>支持向量</strong></p>
<p>我们可以得出一个结论：<strong>分界的超平面和H1/H2之间的距离是1/||W||</strong>。</p>
<p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA6.png" alt="" />也就是先平方再开方</p>
<p>所以最大边界距离是2/||W||</p>
<p>所以我们要找2/||W||最大值，也就是找w的最小值。所以我们需要找的是：</p>
<p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA9.PNG" alt="" /></p>
<p>用1/2平方是因为好算</p>
<p>之后运用拉格朗日函数，KKT算法等得到了最大超平面方程</p>
<p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA10.PNG" alt="" />.其中a和b是通过计算过程得出，暂时不清楚具体情况</p>
<h1 id="python使用"><a class="markdownIt-Anchor" href="#python使用"></a> python使用</h1>
 <figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [[<span class="number">2</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]] <span class="comment"># 特征向量</span></span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>] <span class="comment"># yi</span></span><br><span class="line">clf = svm.SVC(kernel = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">clf.fit(x, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> clf</span><br><span class="line"></span><br><span class="line"><span class="comment"># get support vectors</span></span><br><span class="line"><span class="built_in">print</span> clf.support_vectors_</span><br><span class="line"></span><br><span class="line"><span class="comment"># get indices of support vectors</span></span><br><span class="line"><span class="built_in">print</span> clf.support_ <span class="comment"># 支持向量点的索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get number of support vectors for each class </span></span><br><span class="line"><span class="built_in">print</span> clf.n_support_ <span class="comment"># 每个类中有几个支持向量，yi所代表的类</span></span><br></pre></td></tr></table></figure>
<p>把结果画出来</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pylab as pl</span><br><span class="line"><span class="keyword">from</span> sklearn import svm</span><br><span class="line"></span><br><span class="line"><span class="comment"># we create 40 separable points</span></span><br><span class="line">X = np.r_[np.random.randn(20, 2) - [2, 2], np.random.randn(20, 2) + [2, 2]]</span><br><span class="line">Y = [0]<span class="number">*20</span> +[1]<span class="number">*20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fit the model</span></span><br><span class="line">clf = svm.SVC(<span class="attribute">kernel</span>=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">clf.fit(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get the separating hyperplane</span></span><br><span class="line">w = clf.coef_[0] # 获得w</span><br><span class="line">a = -w[0]/w[1] # 斜率</span><br><span class="line">xx = np.linspace(-5, 5)</span><br><span class="line">yy = a*xx - (clf.intercept_[0])/w[1] # 截距</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the parallels to the separating hyperplane that pass through the support vectors</span></span><br><span class="line">b = clf.support_vectors_[0]</span><br><span class="line">yy_down = a*xx + (b[1] - a<span class="number">*b</span>[0])</span><br><span class="line">b = clf.support_vectors_[-1]</span><br><span class="line">yy_up = a*xx + (b[1] - a<span class="number">*b</span>[0]) </span><br><span class="line"></span><br><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;w: &quot;</span>, w</span><br><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;a: &quot;</span>, a</span><br><span class="line"></span><br><span class="line"><span class="comment"># print &quot;xx: &quot;, xx</span></span><br><span class="line"><span class="comment"># print &quot;yy: &quot;, yy</span></span><br><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;support_vectors_: &quot;</span>, clf.support_vectors_</span><br><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;clf.coef_: &quot;</span>, clf.coef_</span><br><span class="line"></span><br><span class="line"><span class="comment"># switching to the generic n-dimensional parameterization of the hyperplan to the 2D-specific equation</span></span><br><span class="line"><span class="comment"># of a line y=a.x +b: the generic w_0x + w_1y +w_3=0 can be rewritten y = -(w_0/w_1) x + (w_3/w_1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the line, the points, and the nearest vectors to the plane</span></span><br><span class="line">pl.plot(xx, yy, <span class="string">&#x27;k-&#x27;</span>)</span><br><span class="line">pl.plot(xx, yy_down, <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line">pl.plot(xx, yy_up, <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pl.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1],</span><br><span class="line">          <span class="attribute">s</span>=80, <span class="attribute">facecolors</span>=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">pl.scatter(X[:, 0], X[:, 1], <span class="attribute">c</span>=Y, <span class="attribute">cmap</span>=pl.cm.Paired)</span><br><span class="line"></span><br><span class="line">pl.axis(<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">pl.show()</span><br></pre></td></tr></table></figure>
<h1 id="线性不可分的情况"><a class="markdownIt-Anchor" href="#线性不可分的情况"></a> 线性不可分的情况</h1>
<p>要解决线性不可分的情况首先要看一个例子。</p>
<p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA8.jpg" alt="" /></p>
<p>如图，左边明显不可分，但是投影到右边就可分了。因此解决线性不可分的基本思想就是投影到更高的维度。所以现在问题关键成了建立一个映射函数正确的映射到高维，然后找到超平面后再还原回原空间就可以找到超平面（其实现在超平面在原空间中是一个曲面）</p>
<p>核函数是为了把数据从低维到高维和减小运算量而使用的。</p>
<p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA11.PNG" alt="" /></p>
<p>如果我们先解决多个类的问题，我们可以每次分成这个类和其他类，然后不断求解</p>
<h1 id="人脸识别例子"><a class="markdownIt-Anchor" href="#人脸识别例子"></a> 人脸识别例子</h1>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> RandomizedPCA</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(__doc__)</span><br><span class="line"></span><br><span class="line"># Display progress logs on stdout</span><br><span class="line">logging.basicConfig(level=logging.INFO, format=<span class="string">&#x27;%(asctime)s %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Download the data, <span class="keyword">if</span> not already on disk and load it <span class="keyword">as</span> numpy arrays</span><br><span class="line"></span><br><span class="line">lfw_people = fetch_lfw_people(min_faces_per_person=<span class="number">70</span>, resize=<span class="number">0.4</span>) #下载人脸</span><br><span class="line"></span><br><span class="line"># introspect the images arrays to find the shapes (for plotting)</span><br><span class="line">n_samples, h, w = lfw_people.images.shape</span><br><span class="line"></span><br><span class="line"># for machine learning we use the <span class="number">2</span> data directly (<span class="keyword">as</span> relative pixel</span><br><span class="line"># positions info is ignored by this model)</span><br><span class="line">X = lfw_people.data # 特征向量</span><br><span class="line">n_features = X.shape[<span class="number">1</span>] #有多少列</span><br><span class="line"></span><br><span class="line"># the label to predict is the id <span class="keyword">of</span> the person</span><br><span class="line">y = lfw_people.target # 类</span><br><span class="line">target_names = lfw_people.target_names # 所挑选的图片的人名</span><br><span class="line">n_classes = target_names.shape[<span class="number">0</span>] # 有多少行</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Total dataset size:&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;n_samples: %d&quot;</span> % n_samples)</span><br><span class="line">print(<span class="string">&quot;n_features: %d&quot;</span> % n_features)</span><br><span class="line">print(<span class="string">&quot;n_classes: %d&quot;</span> % n_classes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Split into a training set and a test set using a stratified k fold</span><br><span class="line"></span><br><span class="line"># split into a training and testing set</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X, y, test_size=<span class="number">0.25</span>)</span><br><span class="line"># train_test_split把实例分成训练集和测试集</span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Compute a PCA (eigenfaces) on the face dataset (treated <span class="keyword">as</span> unlabeled</span><br><span class="line"># dataset): unsupervised feature extraction / dimensionality reduction</span><br><span class="line">n_components = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Extracting the top %d eigenfaces from %d faces&quot;</span></span><br><span class="line">      % (n_components, X_train.shape[<span class="number">0</span>]))</span><br><span class="line">t0 = time()</span><br><span class="line">pca = RandomizedPCA(n_components=n_components, whiten=<span class="literal">True</span>).fit(X_train)</span><br><span class="line">print(<span class="string">&quot;done in %0.3fs&quot;</span> % (time() - t0)) # RandomizedPCA使用来降维的，因为这个维度抬高难以计算</span><br><span class="line"></span><br><span class="line">eigenfaces = pca.components_.reshape((n_components, h, w))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Projecting the input data on the eigenfaces orthonormal basis&quot;</span>)</span><br><span class="line">t0 = time()</span><br><span class="line">X_train_pca = pca.transform(X_train)</span><br><span class="line">X_test_pca = pca.transform(X_test)</span><br><span class="line">print(<span class="string">&quot;done in %0.3fs&quot;</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Train a SVM classification model</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Fitting the classifier to the training set&quot;</span>)</span><br><span class="line">t0 = time()</span><br><span class="line">param_grid = &#123;<span class="string">&#x27;C&#x27;</span>: [<span class="number">1e3</span>, <span class="number">5e3</span>, <span class="number">1e4</span>, <span class="number">5e4</span>, <span class="number">1e5</span>],</span><br><span class="line">              <span class="string">&#x27;gamma&#x27;</span>: [<span class="number">0.0001</span>, <span class="number">0.0005</span>, <span class="number">0.001</span>, <span class="number">0.005</span>, <span class="number">0.01</span>, <span class="number">0.1</span>], &#125;</span><br><span class="line">clf = GridSearchCV(SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, class_weight=<span class="string">&#x27;auto&#x27;</span>), param_grid)#核函数kernel， GridSearchCV是用来寻找最好的参数比例</span><br><span class="line">clf = clf.fit(X_train_pca, y_train)</span><br><span class="line">print(<span class="string">&quot;done in %0.3fs&quot;</span> % (time() - t0))</span><br><span class="line">print(<span class="string">&quot;Best estimator found by grid search:&quot;</span>)</span><br><span class="line">print(clf.best_estimator_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Quantitative evaluation <span class="keyword">of</span> the model quality on the test set</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Predicting people&#x27;s names on the test set&quot;</span>)</span><br><span class="line">t0 = time()</span><br><span class="line">y_pred = clf.predict(X_test_pca)</span><br><span class="line">print(<span class="string">&quot;done in %0.3fs&quot;</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line">print(classification_report(y_test, y_pred, target_names=target_names))</span><br><span class="line">print(confusion_matrix(y_test, y_pred, labels=range(n_classes)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Qualitative evaluation <span class="keyword">of</span> the predictions using matplotlib</span><br><span class="line"></span><br><span class="line">def plot_gallery(images, titles, h, w, n_row=<span class="number">3</span>, n_col=<span class="number">4</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Helper function to plot a gallery of portraits&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">1.8</span> * n_col, <span class="number">2.4</span> * n_row))</span><br><span class="line">    plt.subplots_adjust(bottom=<span class="number">0</span>, left=<span class="number">.01</span>, right=<span class="number">.99</span>, top=<span class="number">.90</span>, hspace=<span class="number">.35</span>)</span><br><span class="line">    for i <span class="keyword">in</span> range(n_row * n_col):</span><br><span class="line">        plt.subplot(n_row, n_col, i + <span class="number">1</span>)</span><br><span class="line">        plt.imshow(images[i].reshape((h, w)), cmap=plt.cm.gray)</span><br><span class="line">        plt.title(titles[i], size=<span class="number">12</span>)</span><br><span class="line">        plt.xticks(())</span><br><span class="line">        plt.yticks(())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># plot the result <span class="keyword">of</span> the prediction on a portion <span class="keyword">of</span> the test set</span><br><span class="line"></span><br><span class="line">def title(y_pred, y_test, target_names, i):</span><br><span class="line">    pred_name = target_names[y_pred[i]].rsplit(<span class="string">&#x27; &#x27;</span>, <span class="number">1</span>)[<span class="number">-1</span>]</span><br><span class="line">    true_name = target_names[y_test[i]].rsplit(<span class="string">&#x27; &#x27;</span>, <span class="number">1</span>)[<span class="number">-1</span>]</span><br><span class="line">    return <span class="string">&#x27;predicted: %s\ntrue:      %s&#x27;</span> % (pred_name, true_name)</span><br><span class="line"></span><br><span class="line">prediction_titles = [title(y_pred, y_test, target_names, i)</span><br><span class="line">                     for i <span class="keyword">in</span> range(y_pred.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">plot_gallery(X_test, prediction_titles, h, w)</span><br><span class="line"></span><br><span class="line"># plot the gallery <span class="keyword">of</span> the most significative eigenfaces</span><br><span class="line"></span><br><span class="line">eigenface_titles = [<span class="string">&quot;eigenface %d&quot;</span> % i for i <span class="keyword">in</span> range(eigenfaces.shape[<span class="number">0</span>])]</span><br><span class="line">plot_gallery(eigenfaces, eigenface_titles, h, w)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/post/1b9c8662.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="文件"><a class="markdownIt-Anchor" href="#文件"></a> 文件</h1>
<h2 id="文件的结构和类型"><a class="markdownIt-Anchor" href="#文件的结构和类型"></a> 文件的结构和类型</h2>
<p>文件在系统中其实就是一串二进制数，结尾有特殊的符号标识，而他的入口处由操作系统管理。</p>
<p>在linux系统中，文件的类型有目录文件，一般文件和特殊文件（如设备文件）等，这些文件在内容组织上各不相同，但是他们的基础构成还是上面说的。</p>
<h2 id="查找文件"><a class="markdownIt-Anchor" href="#查找文件"></a> 查找文件</h2>
<p>首先在linux中文件通过树形结构进行组织，在找到对应目录下的文件后就要打开文件了。linux目录中存放的i节点表，i节点中存放着一些文件的信息和文件的入口地址。</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F1.PNG" alt="" />如图就是一些文件的属性，操作系统会根据自身需要选取某些属性。</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2.PNG" alt="" />这个图中就是i节点的结构，注意Point to Block data就是在磁盘中的位置</p>
<h2 id="文件在磁盘中的储存"><a class="markdownIt-Anchor" href="#文件在磁盘中的储存"></a> 文件在磁盘中的储存</h2>
<ul>
<li>第一种方法时每个文件在磁盘中有固定的位置，当然这种方法是不可行的，因为这样必须事先分配好大小，如果达到了事先分配的最大值后就无法继续增大。</li>
<li>第二种方法是通过一个链表组织。这种方法中链表在磁盘的前几个字节，然后i节点指向入口地址。它的缺点是如果想访问后面的节点必须把前面节点都扫一遍，并且因为他在磁盘中占有了位置，所以现在磁盘中所能容纳的文件字节数减少了，需要重新考虑对齐的问题。</li>
<li>第三种方法是在i节点中增加15*4个字节。它是12+1+1+1的结构。低12字节保存第0到11块的入口地址（如果一块大小矢1k的话，那么0-12k地址内容可以通过低12字节访问）。而第12个字节保存到下一个链表的指针，这个链表大小就是一页大小，也就是说保存着从12k开始到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><mo>+</mo><mn>1024</mn><mo>∗</mo><mo stretchy="false">(</mo><mfrac><mn>1024</mn><mn>4</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">12+ 1024*(\frac{1024}{4})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>位置的数据。同样第13字节有两个页表，那么它保存着 1024 * 1024/4 * 1024/4大小的数据。以此类推,第二个图展示了它的结构</li>
</ul>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F3.PNG" alt="" /><br />
<img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F4.PNG" alt="" /></p>
<h1 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h1>
<p>不同的操作系统中有不同的文件系统。</p>
<ul>
<li>linux： minix, ext2, ext3, ext4, reiserFS, IBMJFS, xfxs</li>
<li>windows: FAT-16, FAT-32, FAT-12, exFat， NTFS</li>
</ul>
<p>不同的文件系统不一定兼容，下面以ext2作为例子来说明文件系统的结构。</p>
<p><strong>磁盘</strong>被分为若干块，它的大小可以是1024， 2048， 4096等等。磁盘块的大小是由操作系统决定的。</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F5.PNG" alt="" /></p>
<ul>
<li>超级块（superblock）是文件系统中的第一个块，其中存放着文件系统的一些信息如文件系统的根目录，挂载点，空闲块指针，空闲i节点指针。超级块坏了文件系统就坏了。</li>
</ul>
<blockquote>
<p>为了保证超级块坏的时候文件系统不至于崩溃，超级块一般由多个备份。</p>
</blockquote>
<ul>
<li>i节点和间接i节点表。这两个作用在上面说了</li>
<li>数据块（data Block)真正存储数据的块</li>
</ul>
<h2 id="空数据块位置"><a class="markdownIt-Anchor" href="#空数据块位置"></a> 空数据块位置</h2>
<p>每次操作系统想分配空间给一个文件时，首先要知道空的数据块在哪。</p>
<ul>
<li>一种办法是使用一个链表来维护空数据块，这种办法的问题是消耗太大</li>
<li>另一种办法是使用位图法，因为块是有编号的，如果对应位置是1表示不是空的。<img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F6.PNG" alt="" /></li>
</ul>
<h2 id="文件系统的创建和挂载"><a class="markdownIt-Anchor" href="#文件系统的创建和挂载"></a> 文件系统的创建和挂载</h2>
<p>可以使用<strong>mkfs</strong>命令进行文件系统的创建</p>
<blockquote>
<p><code>mkfs [-t type] [fs-options] &lt;device&gt; size</code></p>
</blockquote>
<p>例： mkfs -t ext4 /dev/sda6</p>
<p><strong>mount</strong>命令进行文件系统的挂载</p>
<p><a href="https://xinhecuican.github.io/post/35532.html">此命令可以看这篇文章中目录部分</a></p>
<p>例： mount /dev/lv100 /home/patsie</p>
<p><strong>注意</strong>：不同文件系统中i节点是不一样的，挂载时经历了一些转换过程，这时可以看到挂载进来的内容，但是该目录下原有内容被隐藏了，只有使用卸载命令<strong>umount</strong>才可以重新看到原有内容。</p>
<h1 id="磁盘及卷组管理"><a class="markdownIt-Anchor" href="#磁盘及卷组管理"></a> 磁盘及卷组管理</h1>
<p><a href="https://xinhecuican.github.io/post/7d1c86da.html">有关磁盘基础结构请看</a></p>
<p>首先磁盘分区有两种，分别是MBR和GPT（也就是C盘D盘之类的）</p>
<ul>
<li>MBR（Master Boot Record):
<ul>
<li>位于第一个扇面</li>
<li>支持4个主分区，加上扩展分区最多也就支持32个分区</li>
<li>一个分区最大2T</li>
</ul>
</li>
<li>GPT（GUID Partition table):
<ul>
<li>理论支持无限多个分区（实际上操作系统会限制）</li>
<li>最大支持18EB</li>
<li>需要操作系统支持和主板支持EFI/UEFI</li>
</ul>
</li>
</ul>
<p>直接磁盘分区有很多问题</p>
<ol>
<li>磁盘分区大小是固定的，很难改变（除非格式化）</li>
<li>受文件系统大小的限制（因为文件系统无法跨越设备，所以分区也不可以）</li>
<li>需要提前考虑大小</li>
</ol>
<p>LVM（逻辑卷管理）就是为了克服这些问题而产生的。他将物理设备分为若干物理卷，然后使用逻辑卷进行管理和分区。</p>
<blockquote>
<p>物理储存介质： 如磁盘等，在linux上是/dev/sda等设备文件<br />
物理卷(PV): 相当于一个个磁盘分区，但是分区大小固定并且还有一些与LVM相关参数<br />
卷组（VG）： 多个物理卷组成的储存池，也就是说可以让文件系统跨设备<br />
逻辑卷（LV）： 从卷组中分出一些卷进行管理，可以在上面划分分区</p>
</blockquote>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F7.PNG" alt="" /></p>
<p><strong>一些linux命令</strong></p>
<ul>
<li>fdisk： 创建分区 例如 fdisk /dev/sda</li>
<li>pvcreate:创建物理卷</li>
<li>vgcreate: 创建卷组 例如： vgcreate vg0 /dev/sda6(sda6是一个物理卷）</li>
<li>vgextend: 扩展卷组 例如： vgextend vg0 /dev/sdb1</li>
<li>lvcreate: 创建逻辑卷 例如： lvcreate -L 10G -n lv0 /dev/vg0（名字是lv0，大小是10G）</li>
<li>mkfs： 创建文件系统，现在是在逻辑卷中创造</li>
<li>lvextend: 扩大逻辑卷</li>
<li>resize2fs： 扩大文件系统</li>
<li>umount： 卸载文件系统，为减小大小做准备。</li>
<li>lvreduce： 减小逻辑卷大小。<strong>首先要减小文件系统大小，使用resize2fs命令</strong></li>
</ul>
<p>这些命令基本按照顺序把文件系统创建和增删过程说了出来。</p>
<p>基本过程： 创建硬盘分区-&gt;创建逻辑卷-&gt;创建卷组-&gt;创建逻辑卷-&gt;创建文件系统</p>
<p>扩大物理卷-&gt;扩散卷组-&gt;扩大逻辑卷-&gt;扩大文件系统</p>
<p>减小文件系统-&gt;减小逻辑卷…</p>
]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>数论</title>
    <url>/post/15425.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="整除"><a class="markdownIt-Anchor" href="#整除"></a> 整除</h3>
<p>如果a能被b整除，a=b*q，q为一整数记作b|a,a是被除的那个</p>
<h3 id="同余"><a class="markdownIt-Anchor" href="#同余"></a> 同余</h3>
<p>如果a和bmod m 是同一个值，则称a和b同余，记作a (三横线） b(mod m)</p>
<p>例如： 3 和 8 关于5 同余  因为 3%5=3,8%5=3</p>
<p>重要性质：</p>
<pre><code>     （a+b)%c=a%c+b%c
     (a*b)%c=(a%c*b%c)%c
     (a^b)%c=(a%c^b)%c
</code></pre>
<h3 id="唯一分解定理"><a class="markdownIt-Anchor" href="#唯一分解定理"></a> 唯一分解定理</h3>
<p>任何大于1的正整数n都可以被分解为若干质数的乘积</p>
<p>约数个数 例如 72=2<sup>3*3</sup>2  ，而72有 1 2 3 4 6 8 9 12 18 24 36 72 12个约数<br />
，而我可以从2^3 中提取出0个2,1个2，两个2，三个2把其他的数放到另一边，这样我们就可以得到4个约数，3也同理，用一下分配率，就可以得到约数个数为3*4=12</p>
<p>约数和  因为约数是从2和3中随机挑出若干个数进行分配，所以用分配率可得约数和为</p>
<p>(1+2+2<sup>2+2</sup>3)(1+3+3^2)</p>
<h3 id="费马小定理"><a class="markdownIt-Anchor" href="#费马小定理"></a> 费马小定理</h3>
<p>如果p是质数且a与p互质，则</p>
<p>a^(p-1)%p=1(a的p-1次方和1关于p同余）</p>
<p>互质指的是 二者除了1以外没有相同的约数</p>
<h3 id="求质数的方法"><a class="markdownIt-Anchor" href="#求质数的方法"></a> 求质数的方法</h3>
<p><a href="http://localhost:4000/2020/01/04/%E5%9F%83%E6%B0%8F%E7%AD%9B/">埃氏筛</a></p>
<p><a href="http://localhost:4000/2020/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B/">线性筛</a></p>
<h3 id="欧拉函数"><a class="markdownIt-Anchor" href="#欧拉函数"></a> 欧拉函数</h3>
<p>概念：表示0到n-1中与n互素的数的个数</p>
<p>积性函数：如果 m和n互质 ，则f(m*n)=f(m)*f(n)</p>
<p>欧拉函数的性质：</p>
<ol>
<li>对于质数p  f§=p-1</li>
<li>如果n=p<sup>k,则f(n)=p</sup>k-p^k-1</li>
<li>欧拉函数是积性函数，但不是完全积性函数，当n为质数时成立，当m=2,n为奇数时，f(2*n)=n</li>
<li>n&gt;2时 f(n)是偶数</li>
<li>与n互质的数的和为 f(n)*n/2</li>
<li>n的因数的欧拉函数的和为n</li>
</ol>
<h3 id="模意义下的乘法逆元"><a class="markdownIt-Anchor" href="#模意义下的乘法逆元"></a> 模意义下的乘法逆元</h3>
<p>例 1/5%7=?</p>
<p>3*5%7=1,所以1/5的逆元是3，所以1/5%7=3</p>
<p>逆元的求法</p>
<p>1 费马小定理</p>
<p>a*a<sup>-1%p=1,a</sup>p-1%p=1</p>
<p>可得 a<sup>-1%p=a</sup>p-2%p，然后用快速幂。但是费马小定理要求必须要是素数</p>
<p>2 线性求逆元（不理解）</p>
<p>公式：inv(a)=-p/a*inv(p%a)%p;</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>]<span class="operator">=</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line">for(int i<span class="operator">=</span><span class="number">2</span><span class="comment">;i&lt;=n;++i)&#123;</span></span><br><span class="line">inv[i]<span class="operator">=</span>((<span class="number">1</span>ll*(-p/i)*inv[p<span class="variable">%i</span>]<span class="variable">%p</span>)+p)<span class="variable">%p</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 扩展欧几里得法</p>
<p>exgcd</p>
<p>exgcd用来求解ax+by=c，其中a，b，c都为整数</p>
<p>裴蜀定理</p>
<p>不定方程 ax+by=c存在整数解当且仅当gcd(a,b)|c ，当存在一组整数解时，必存在无限组解<br />
ax+by=gcd(a,b)=&gt;bx1+a%by1=gcd(b,a%b)=&gt;x=x1,y=x1-(a/b)y1</p>
<p>x=x1+k<em>b/gcd(a,b) , y= y1-k</em>a/gcd(a,b)</p>
<p>之后一直求解直到x=1,y=0,这时b=0,所以gcd(a,b)=a,方程一定成立</p>
<p>在这里我们可以用递归反推，把x=1,y=0带入方程，一步步向上推</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">void exgcd(int a,int b,int &amp;x,int &amp;y)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="attribute">b</span>==0)&#123;</span><br><span class="line"><span class="attribute">x</span>=1;</span><br><span class="line"><span class="attribute">y</span>=0;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">int x1,y1;</span><br><span class="line">exgcd(b,a%b,x1,y1);</span><br><span class="line"><span class="attribute">x</span>=y1;</span><br><span class="line"><span class="attribute">y</span>=x1-(a/b)*y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们就可以得到第三种方法</p>
<p>求逆元可以转化为：求关于x的同余方程ax（三横）1 mod b的最小正整数解</p>
<p>ax%b=1  ax=kb+1</p>
<p>即 ax-by=1</p>
<p>最后 x1%b+b即是答案</p>
<p><a href="https://big-news.cn/2019/05/19/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/">可以看这篇博客</a></p>
<h3 id="排列组合"><a class="markdownIt-Anchor" href="#排列组合"></a> 排列组合</h3>
<p>求C(m,n)%p的值</p>
<p>可变成  (n!/m!(n-m)!)%p</p>
<p>之后就用费马小定理求逆元</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ksm(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=<span class="number">1</span>ll*ret*a%p;</span><br><span class="line">a=<span class="number">1</span>ll*a*a%p;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fac[maxn];</span><br><span class="line"><span class="keyword">int</span> inv(<span class="keyword">int</span> <span class="keyword">x</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ksm(<span class="keyword">x</span>,p-<span class="number">2</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> C(<span class="keyword">int</span> n,<span class="keyword">int</span> <span class="keyword">m</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> qwq=<span class="number">1</span>ll*fac[n]*inv(fac[n-<span class="keyword">m</span>])%p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>ll*qwq*inv(fac[<span class="keyword">m</span>])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,<span class="keyword">m</span>;</span><br><span class="line">scanf(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;<span class="keyword">m</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">fac[i]=<span class="number">1</span>ll*fac[i-<span class="number">1</span>]*i%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">&quot;%d&quot;</span>,C(n,<span class="keyword">m</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>文件输入输出</title>
    <url>/post/7502.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="文件输入in"><a class="markdownIt-Anchor" href="#文件输入in"></a> 文件输入in</h4>
<p>文件输入指的是从文件_输入_给程序，对应的有in，get，read，seekg等
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">seekg和seekp中有三个定位基址，分别是cur（当前）beg（开始），<span class="built_in">end</span>（末尾）&lt;p&gt;</span><br><span class="line">例如 seekg（<span class="number">100</span>，ios：：beg）；seekg（<span class="number">2</span>*<span class="keyword">sizeof</span>(Student)) student是一个类</span><br></pre></td></tr></table></figure>
<h4 id="文件输出out"><a class="markdownIt-Anchor" href="#文件输出out"></a> 文件输出out</h4>
<p>文件输出指的是从程序<code>输出</code>给文件，对应的有out，put，write，seekp等</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>查找</title>
    <url>/post/33cb1151.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="静态查找"><a class="markdownIt-Anchor" href="#静态查找"></a> 静态查找</h3>
<h4 id="顺序查找"><a class="markdownIt-Anchor" href="#顺序查找"></a> 顺序查找</h4>
<p>就是一个个找，过程不必多少。</p>
<p>如果查找每个元素概率相等，那么查找第n个元素只需要一次，第n-1需要两次…。所以平均查找次数是 1+2+…+n / n = （n+1)/2</p>
<h4 id="折半查找"><a class="markdownIt-Anchor" href="#折半查找"></a> 折半查找</h4>
<p>其实就是二分查找,<a href="https://xinhecuican.github.io/post/41829.html">代码</a></p>
<h4 id="分块查找"><a class="markdownIt-Anchor" href="#分块查找"></a> 分块查找</h4>
<p>分块查找就是每个找出每个块中最大的元素然后单独建一个表，之后就可以先查找这个表然后根据表来查找。大致意思就是这样，<a href="https://blog.csdn.net/To_Be_IT_1/article/details/25333253">具体代码</a></p>
<h3 id="动态查找"><a class="markdownIt-Anchor" href="#动态查找"></a> 动态查找</h3>
<h4 id="二叉排序树查找树"><a class="markdownIt-Anchor" href="#二叉排序树查找树"></a> 二叉排序树（查找树）</h4>
<p>二叉查找树特点是左儿子都比父亲小，右儿子都比父亲大。</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE.PNG" alt="" /></p>
<p>上面就不是二叉排序树，因为66比50还要大。</p>
<p>用链表进行存储。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    node</span> *lchild;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*rchild</span>;</span><br><span class="line">    int val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树的查找算法：</p>
<ol>
<li>如果二叉树是空，那么直接返回</li>
<li>如果该节点的val正好是要查找的数，则查找成功</li>
<li>如果大，那么去右边找</li>
<li>如果小，去坐标找</li>
</ol>
<p><strong>插入</strong></p>
<p>先要进行查找，如果查找不成功才会插入。</p>
<p>插入过程最好单独写一个函数，因为使用递归。如果要插入的点比当前点大，那么就去右边，反之就去左边。知道这个点是空为止，把要插入的点插入到这个空的点中。</p>
<p><strong>删除</strong></p>
<p>如果要删除的点是叶结点，那么直接把这个点变成空（因为父亲节点的儿子指针就指向这个节点，现在把这个节点变成空，那么儿子指针就指向空）</p>
<p>如果要删除的节点只有左子树或者右子树，那么让父亲对应指针指向那个子树就可以了。所以最好把父亲节点也用一个变量存储。</p>
<p>如果要删除的节点左右子树都有，就用它的前驱替代，然后删除前驱。</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE2.PNG" alt="" /></p>
<p>左边是删除前，右边是删除后。</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE3.PNG" alt="" /></p>
<p>前面一段代码是找前驱，前驱是s，而q是s的父亲，如果p==q说明p的左孩子就是s并且没有没有其他分支</p>
<p>效率 2logn</p>
<h4 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树"></a> 平衡二叉树</h4>
<p>平衡二叉树的特点是左右子树深度之差小于等于1.</p>
<p><strong>构造方法</strong></p>
<p>加入一个代表深度差的标记bf，如果左边比右边深为正，右边比左边深为负。例如：</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE4.PNG" alt="" /></p>
<p>上面的数字就是bf值。这个例子中是失去平衡的右子树的右子树导致的，也就是右右，可以向左旋转。让5做8的左节点，8连接根节点，19连接右节点。</p>
<p>如果是左左，那么向右旋转。</p>
<p>如果是左右，那么先左旋再右旋。</p>
<p>如果是右左，那么先右旋再左旋。</p>
<p>那么现在就知道如果不平衡应该怎么做了。但是插入时怎么判断平不平衡呢？</p>
<p>如果是空树，那么把这个点做根节点。</p>
<p>否则就按照二叉排序树的方法进行插入，插入完成之后又从底部递归。如果最终插入到右边就让父亲-1，如果插入到左边就让父亲加一。如果父亲&gt;=2就找左儿子，如果左儿子是1那么就是左左的情况，那么右旋，反之先左旋再右旋。如果&lt;=-2也是同样的方法。</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE5.PNG" alt="" /></p>
<p><img src="/images/%E6%9F%A5%E6%89%BE6.PNG" alt="" /></p>
<p>注意，左旋和右旋是以根节点为基准的。在左左或右右的情况中，根节点是最上面那个点p，右旋就是把p和lc互换。但是在左右和右左的情况中不是这样。</p>
<p>如果是左右的情况，先以第二层的点作为根，右旋就是第二层的点和第三层的点换一下位置，顺便把原来第三层的左儿子挂到原来第二层的右儿子上（因为原来第三层的点变成第二层，右儿子没有了）。</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE7.PNG" alt="" /></p>
<p>最后除此之外还要注意左右或右左的情况中旋转之后的bf值会不同。</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE8.PNG" alt="" /><br />
<img src="/images/%E6%9F%A5%E6%89%BE9.PNG" alt="" /><br />
<img src="/images/%E6%9F%A5%E6%89%BE10.PNG" alt="" /></p>
<p>可以通过c点来区分</p>
<h4 id="b-树"><a class="markdownIt-Anchor" href="#b-树"></a> B-树</h4>
<p>一种多路平衡查找树</p>
<p>每个节点至多m个儿子，如果根节点不是叶子节点，那么<strong>最少2棵</strong>子树。根节点之外的非叶子节点都<strong>至少有 m/2</strong>个子树。</p>
<p>非终端节点包含n, A0, k1, A1, k1, A2…其中k是关键字，且k&lt;k+1.n是关键字的数目</p>
<p>所有叶子节点都在同一层次且是空指针。</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE11.PNG" alt="" /></p>
<p>从上图中可以看出，对于每一个节点还是符合左边小右边大的规律的。</p>
<p>结构：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> keynum;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*parent</span>;</span><br><span class="line">    int key[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*p</span>[m+<span class="number">1</span>];</span><br><span class="line">    int *record[m+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">struct result</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*pt</span>;</span><br><span class="line">    int i;//节点中关键字序号</span><br><span class="line">    int success;//是否找到</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">result search(node *head, int key)</span><br><span class="line">&#123;</span><br><span class="line">    node *<span class="attr">p</span> = head;</span><br><span class="line">    mode *q;</span><br><span class="line">    int <span class="attr">found</span> = <span class="number">0</span>;</span><br><span class="line">    while(p &amp;&amp; !found)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">n</span> = p-&gt;keynum;</span><br><span class="line">        int <span class="attr">i</span> = search(p, key);//这个函数是找第一个大于等于key的</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; p-&gt;key[i] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">found</span> = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">q</span> = p;</span><br><span class="line">            <span class="attr">p</span> = p-&gt;p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(found != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result a.<span class="attr">pt</span> = p;</span><br><span class="line">        a.<span class="attr">i</span> = i;</span><br><span class="line">        a.<span class="attr">success</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result a.<span class="attr">pt</span> = q;//因为没找到最后一定会到<span class="literal">null</span>，所以返回它父亲</span><br><span class="line">        a.<span class="attr">i</span> = i;</span><br><span class="line">        a.<span class="attr">success</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插入</strong></p>
<p>节点插入首先是查找，前面查找的时候已经返回了他应该在的位置。但是如果插入后超过了上限那么还要把中间节点提到上面去（主要讲三叉）。同时让左右两边的做往上提节点的左右两边。</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE12.PNG" alt="" /><br />
上面是插入85</p>
<p>算法：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void insert(node *head, int key, node *<span class="built_in">in</span>, int position)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//in是要插入的节点，例如上面就是g节点</span></span><br><span class="line">    <span class="comment">//position是插入位置，也可以先用一次查找</span></span><br><span class="line">    int x = key；</span><br><span class="line">    node *ap = NULL;</span><br><span class="line">    int finish = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &amp;&amp; !finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(int k=position; k&lt;<span class="built_in">in</span>-&gt;</span>keynum-<span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">in</span>-&gt;</span><span class="function"><span class="title">key</span>[k+1] = <span class="built_in">in</span>-&gt;</span>key[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">for</span>(int i=position+1; i&lt;<span class="built_in">in</span>-&gt;</span>keynum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">in</span>-&gt;</span><span class="function"><span class="title">p</span>[i+1] = <span class="built_in">in</span>-&gt;</span>p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">in</span>-&gt;</span>key[position] = x;</span><br><span class="line">        <span class="function"><span class="title">in</span>-&gt;</span>keynum++;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="built_in">in</span>-&gt;</span>keynum &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            finish = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要把数往上提</span></span><br><span class="line">            int temp = (m%<span class="number">2</span>==<span class="number">0</span>) ? m/<span class="number">2</span> : m/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="title">x</span> = <span class="built_in">in</span>-&gt;</span>key[temp];</span><br><span class="line">            <span class="comment">//分裂</span></span><br><span class="line">            <span class="function"><span class="title">ap</span> = <span class="built_in">in</span>-&gt;</span>parent;</span><br><span class="line">            <span class="function"><span class="title">for</span>(int i=0; i&lt;ap-&gt;</span>keynum-<span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span>(ap-&gt;</span>key[i] &lt; x)</span><br><span class="line">                &#123;</span><br><span class="line">                    position = x;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//search</span></span><br><span class="line">            <span class="function"><span class="title">for</span>(int i=position+1; i&lt;ap-&gt;</span>keynum; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">ap</span>-&gt;</span><span class="function"><span class="title">p</span>[i+1] = ap-&gt;</span>p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            node *left = new node;<span class="comment">//拆分后左边节点</span></span><br><span class="line">            node *right = new node;<span class="comment">//拆封后右边节点</span></span><br><span class="line">            <span class="comment">//拆分具体过程就不写了，一系列的赋值</span></span><br><span class="line">            <span class="function"><span class="title">ap</span>-&gt;</span>p[position] = left;</span><br><span class="line">            <span class="function"><span class="title">ap</span>-&gt;</span>p[position+<span class="number">1</span>] = right;</span><br><span class="line">            <span class="built_in">in</span> = ap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">head</span>-&gt;</span>keynum++;</span><br><span class="line">        <span class="function"><span class="title">head</span>-&gt;</span>key[<span class="number">0</span>] = key;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这是自己写的并且没有验证，只有借鉴作用</span><br></pre></td></tr></table></figure>
<p><strong>删除</strong></p>
<ul>
<li>如果删除这个值后节点的key数大于 m/2-1（此时分支数是m/2)。那么只需要删除对应部分，其他不变。</li>
<li>如果删除节点后key=m/2-1
<ol>
<li>如果它父亲左边或者右边Key数大于m/2-1，那么先把左边最大（右边最小）提到上面，再把那个值放下来<img src="/images/%E6%9F%A5%E6%89%BE13.PNG" alt="" /></li>
<li>如果左右两边正好都等于m/2-1，那么把左边右边合并并且把这个值也放下来<img src="/images/%E6%9F%A5%E6%89%BE14.PNG" alt="" /></li>
<li>不会有小于m/2-1的了，不符合定义</li>
</ol>
</li>
<li>如果删除后<strong>双亲</strong>key值小于m/2-1,层层向上合并（不清楚具体过程）</li>
</ul>
<p><strong>B+树</strong></p>
<p>b+树key和q一样多，并且子节点中包含父节点中的信息。</p>
<h4 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h4>
<p>基本思想：建立要存的数和存的位置之间的映射关系（最理想的情况是一一映射），此后在查找元素时，只需要用hash函数就可以找到再表中的位置。</p>
<p>哈希函数就是将值转化成存的位置的函数。</p>
<p>举个例子： 比如哈希函数是 x%10-1,那么可以输入x就可以得到元素在表中的位置。</p>
<p>但是这里有个问题，例如11的哈希值和1的哈希值相同，那么存的位置也相同，这显然是不允许的，这叫做哈希冲突。判断哈希函数优劣就是哈希冲突越少越好。</p>
<p><a href="https://xinhecuican.github.io/post/11491.html">字符串哈希</a></p>
<h5 id="直接定值法"><a class="markdownIt-Anchor" href="#直接定值法"></a> 直接定值法</h5>
<p>hash(key) = key 或 hash(key) = a * key + b</p>
<p>这种方法仅适合哈希表和取值范围一样大的情况（如果取值到十亿我就呵呵）</p>
<h5 id="数字分析法"><a class="markdownIt-Anchor" href="#数字分析法"></a> 数字分析法</h5>
<p>这是利用所选数字中的一些规律来的。例如某一串数字最高若干位都相同，只有一两位不同，那么我们就可以只取一两位</p>
<h5 id="平方取中法"><a class="markdownIt-Anchor" href="#平方取中法"></a> 平方取中法</h5>
<p>就是先把数字平方然后再取中间几位，它的目的是扩大差别从而缩小冲突几率。适用于每一位都有高概率的重复数字。</p>
<h5 id="折叠法"><a class="markdownIt-Anchor" href="#折叠法"></a> 折叠法</h5>
<p>将关键字分成若干块然后叠加。可以直接分成若干块叠加。也可以正的加一块然后把数倒过来加一块，这种方法使用于位数多的情况。</p>
<h5 id="除留余数法"><a class="markdownIt-Anchor" href="#除留余数法"></a> 除留余数法</h5>
<p>hash(key) = key % p;//p是不大于表长且不大于最大值的素数</p>
<h5 id="随机数法"><a class="markdownIt-Anchor" href="#随机数法"></a> 随机数法</h5>
<p>hash(key) = random(key);//这是伪随机数</p>
<h5 id="处理冲突的方法"><a class="markdownIt-Anchor" href="#处理冲突的方法"></a> 处理冲突的方法</h5>
<p><strong>开放地址法</strong></p>
<p>把冲突的地址求一个地址序列：h0,h1…</p>
<p>h(i) = (h(key) + d(i) ) mod m // m是表长</p>
<p>d(i) = c + i c可以随便取</p>
<p>或d(i) = (-1)^(i-1) * (i/2)^2 //这里的i/2是向上取整也就是1/2=1</p>
<p>或d(i)=random(i)//伪随机数</p>
<p>或d(i) = i*h2(key)</p>
<p>注意，这里的d(i)要保证完备性，也就是要保证s(m-1)个h(i)均不相同并且要覆盖到所有地址。那么就要求</p>
<ol>
<li>表长要是 4*k+3</li>
<li>m与d(i)没有公因子</li>
</ol>
<p><strong>链地址法</strong></p>
<p>把哈希值相同的记录在一个链表里。其实就是构建一个链表，如果不冲突就只有一个值，冲突就往后面加。</p>
<p><strong>再哈希法</strong></p>
<p>发生冲突时，选用另外一个哈希函数，直到不冲突。</p>
<p><strong>建立公共溢出区</strong></p>
<p>一旦发生冲突，就把有冲突的数据都填充到溢出表。</p>
<h5 id="哈希表查找"><a class="markdownIt-Anchor" href="#哈希表查找"></a> 哈希表查找</h5>
<p>就是先计算处hash(key)，如果找到直接填充，如果发现冲突就在通过冲突处理方法进行查找</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>检测比较结果的条件转移指令</title>
    <url>/post/57449.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>转移是指它可以修改ip，条件指在某种特定情况下才会修改</p>
<p>例如 jcxz就是一个条件转移指令，只有在cx=0的情况下才会跳转</p>
<p>下列转移指令都是根据cmp指令进行的转移</p>
<h3 id="无符号数情况下的转移"><a class="markdownIt-Anchor" href="#无符号数情况下的转移"></a> 无符号数情况下的转移</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>je</td>
<td>等于则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>小于则转移</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>大于等于则转移</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>cf=1或zf=1</td>
</tr>
</tbody>
</table>
<p>记忆方法：第一个字母都是j，代表jump</p>
<p>e：equal</p>
<p>ne：not equal</p>
<p>b：below</p>
<p>a：above</p>
<p>不一定要在前面是cmp指令，例如</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">je</span> s</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="symbol">s:</span> <span class="keyword">inc</span> <span class="built_in">ax</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>标志寄存器</title>
    <url>/post/57339.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>标志寄存器16位中只有9位有特殊作用</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody>
<tr>
<td>CF</td>
<td>0</td>
<td>PF</td>
<td>0</td>
<td>AF</td>
<td>0</td>
<td>ZF</td>
<td>SF</td>
<td>TF</td>
<td>IF</td>
<td>DF</td>
<td>OF</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<h4 id="zf"><a class="markdownIt-Anchor" href="#zf"></a> ZF</h4>
<p>ZF含义是执行完指令后结果是否为0，为0,ZF=1，不为0,ZF=0</p>
<p>例如</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">mov ax,<span class="number">1</span> ;ZF=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">ax</span>,1 </span>;ZF=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="pf"><a class="markdownIt-Anchor" href="#pf"></a> PF</h4>
<p>奇偶标志位，它记录相关指令执行后，其结果的所有bit为中1的个数是否为偶数，如果1的个数为偶数，pf=1,反之则为0</p>
<h4 id="sf"><a class="markdownIt-Anchor" href="#sf"></a> SF</h4>
<p>符号标志位，看结果是否为负，如果为负，则SF=1</p>
<h4 id="cf"><a class="markdownIt-Anchor" href="#cf"></a> CF</h4>
<p>进位标志位，一般情况下，对无符号数运算时，它记录了超过最高位的值</p>
<p>例如 ，add 255,255 这时已经超过最高位了，我们已经知道，超过最高位的数据都会被丢失，实际上它被保存在CF中，但只会保存一位</p>
<p>做减法时，还有可能发生错位，例如，两个8位数据，-4+5，将产生错位。错位后，相当于计算 252+5，超过255，因此会记录，因为无符号数中负数就是255-该值。<strong>小的减大的时会产生借位</strong></p>
<h4 id="of"><a class="markdownIt-Anchor" href="#of"></a> OF</h4>
<p>溢出标志位，在有符号数运算时，可能会产生溢出，即小于最小值或大于最大值，如果超出，就会让OF=1</p>
<h4 id="adc指令"><a class="markdownIt-Anchor" href="#adc指令"></a> adc指令</h4>
<p>adc是带进位加法指令，它利用了CF位上记录的进位值</p>
<p>格式 adc 对象1，对象2</p>
<p>功能 对象1=对象1+对象2+CF</p>
<p>例</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>执行后ax=4，adc执行时，相当于计算 ax+1+CF=2+1+1=4</p>
<p>这个指令有什么意义呢？实际上加法都可以分为两步操作，第一步是低位相加，第二步是高位相加再加上低位的进位，用汇编语言可以表示为</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="keyword">adc</span> <span class="number">ah</span>,<span class="number">bh</span></span><br></pre></td></tr></table></figure>
<p>这样我们就可以对更大的数据进行运算</p>
<p>例：计算1EF0001000H+2010001EF0H,结果放在ax（最高16位），bx，cx中<br />
计算分三步</p>
<ol>
<li>先将低16位相加，完成后，CF记录本次进位值</li>
<li>再将中16位与CF相加，完成后，CF记录本次相加进位值</li>
<li>最后将高16位与CF相加</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">001eh</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0f000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">cx</span>,<span class="number">1ef0h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">0020h</span></span><br></pre></td></tr></table></figure>
<h4 id="sbb指令"><a class="markdownIt-Anchor" href="#sbb指令"></a> sbb指令</h4>
<p>带借位减法指令</p>
<p>格式 sbb 对象1，对象2</p>
<p>功能： 对象1=对象1-对象2-CF</p>
<h4 id="cmp指令"><a class="markdownIt-Anchor" href="#cmp指令"></a> cmp指令</h4>
<p>比较指令，相当于减法指令，但是不保存结果，只对标志寄存器产生影响</p>
<p>格式： cmp 对象1，对象2</p>
<p>功能： 对象1-对象2，但并不保存结果，对寄存器产生影响</p>
<p>例：</p>
<p>cmp ax，bx</p>
<ol>
<li>
<p>ax=bx，则ax-bx=0，zf=1</p>
</li>
<li>
<p>ax！=bx，则zf=0</p>
</li>
<li>
<p>ax&lt;bx, 将产生借位，cf=1</p>
</li>
<li>
<p>ax&gt;=bx, cf=0</p>
</li>
<li>
<p>ax&gt;bx  ,不产生借位结果又不为0，所以zf=0，cf=0</p>
</li>
<li>
<p>ax&lt;=bx,可能产生借位结果也可能为0，所以zf=1或cf=1</p>
</li>
</ol>
<p>这是无符号位的，还有有符号位的</p>
<p>同理</p>
<ol>
<li>ax=bx，则zf=1</li>
<li>ax！=bx，zf=0</li>
</ol>
<p>但是这时就不能简单的用sf来判断了，因为sf只是符号标志位，它记录了计算结果的正负，但它并不能判断溢出。所以我们同时还要运用寄存器of来判断溢出</p>
<p>例： sf=1，of=0. of=0，说明没有溢出，直接用sf判断即可，sf=1说明ax&lt;bx</p>
<p>sf=1,of=1.这样就说明有溢出，<strong>因此说明是由于溢出导致结果为负，所以真正的结果必然为正</strong>，所以ax&gt;bx</p>
<p>sf=0,of=1. 有溢出，ah&lt;bh</p>
<h4 id="标志寄存器在debug中的表示"><a class="markdownIt-Anchor" href="#标志寄存器在debug中的表示"></a> 标志寄存器在debug中的表示</h4>
<table>
<thead>
<tr>
<th>标志</th>
<th>值为1的标记</th>
<th>值为0的标记</th>
</tr>
</thead>
<tbody>
<tr>
<td>of</td>
<td>ov</td>
<td>nv</td>
</tr>
<tr>
<td>sf</td>
<td>ng</td>
<td>pl</td>
</tr>
<tr>
<td>zf</td>
<td>zr</td>
<td>nz</td>
</tr>
<tr>
<td>pf</td>
<td>pe</td>
<td>po</td>
</tr>
<tr>
<td>cf</td>
<td>cy</td>
<td>nc</td>
</tr>
<tr>
<td>df</td>
<td>dn</td>
<td>up</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编 函数</title>
    <url>/post/30479.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>进入函数在汇编中其实就是callq，出函数就是retq。</p>
<p>而callq和retq的功能之前已经提到过</p>
<h3 id="参数的传递"><a class="markdownIt-Anchor" href="#参数的传递"></a> 参数的传递</h3>
<p>在x86-64位系统中，有六个寄存器负责传入参数，分别是rdi，rsi，rdx，rcx,r8,r9，同时程序返回时返回值放在rax中。如果大于6个，多的部分就要放在栈上。如果我们想操作在栈上的参数，就要通过 x(%rsp)来操作了。</p>
<p>例如有7个参数，此时第7个参数就放在栈上那么 8(%rsp)就可以访问这个参数了，pushq操作分为两部分，首先是rsp-8，然后把数据放进去。这个时候其实数据就是在rsp-rsp+8的区域中，也就是说我们直接movq (%rsp)…就可以访问到我们刚才放进去的元素了</p>
<p>我们这里不采用(%rsp)的原因是因为调用函数是callq，在最后应该是把rip放到栈中，所以要加8到下一个元素。</p>
<p>如果有8个参数，那么栈中要先存第8个，然后再存第7个。</p>
<h3 id="栈上的局部储存"><a class="markdownIt-Anchor" href="#栈上的局部储存"></a> 栈上的局部储存</h3>
<p>由于现代编译器的不断优化和寄存器的增多，我们一般不把局部变量放到栈中，但是有的时候我们不得不把他们放到栈中。</p>
<ol>
<li>寄存器不足时</li>
<li>某一变量用了&amp;（取地址），因此这个时候不得不把它放到栈中，这样才有一个地址</li>
<li>当局部变量是数组或结构体时</li>
</ol>
<p>例如：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">long <span class="keyword">caller</span>()</span><br><span class="line">&#123;</span><br><span class="line">    long <span class="keyword">x</span> = <span class="number">534</span>;</span><br><span class="line">    long <span class="keyword">y</span> = <span class="number">1057</span>;</span><br><span class="line">    long sum = swap_add(&amp;<span class="keyword">x</span>, &amp;<span class="keyword">y</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">汇编代码为：</span><br><span class="line"><span class="keyword">caller</span>:</span><br><span class="line">  subq $16, %rsp</span><br><span class="line">  movq $534, (%rsp)</span><br><span class="line">  movq $1057, <span class="number">8</span>(%rsp)</span><br><span class="line">  leaq <span class="number">8</span>(%rsp), %rsi</span><br><span class="line">  movq %rsp, %rdi</span><br><span class="line">  callq swap_add</span><br><span class="line">  ...</span><br><span class="line">  addq $16,%rsp</span><br></pre></td></tr></table></figure>
<p>汇编中第一行代码为rsp-16，这是为局部变量分配内存空间。534存在最近的一个，1057存在较远的一个，这与前面多个参数存储符合。</p>
<p>注意在这个函数结束时，分配的栈空间也要清除，也就是最后的addq</p>
<p>例2：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">long call_proc()</span><br><span class="line">&#123;</span><br><span class="line">    long <span class="keyword">x</span><span class="number">1</span> <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    int <span class="keyword">x</span><span class="number">2</span> <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    short <span class="keyword">x</span><span class="number">3</span> <span class="operator">=</span> <span class="number">3</span><span class="comment">;</span></span><br><span class="line">    char <span class="keyword">x</span><span class="number">4</span> <span class="operator">=</span> <span class="number">4</span><span class="comment">;</span></span><br><span class="line">    proc(<span class="keyword">x</span><span class="number">1</span><span class="punctuation">,</span>&amp;<span class="keyword">x</span><span class="number">1</span><span class="punctuation">,</span><span class="keyword">x</span><span class="number">2</span><span class="punctuation">,</span>&amp;<span class="keyword">x</span><span class="number">2</span><span class="punctuation">,</span><span class="keyword">x</span><span class="number">3</span><span class="punctuation">,</span>&amp;<span class="keyword">x</span><span class="number">3</span><span class="punctuation">,</span><span class="keyword">x</span><span class="number">4</span><span class="punctuation">,</span>&amp;<span class="keyword">x</span><span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">    return <span class="keyword">x</span><span class="number">1</span>-<span class="keyword">x</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">汇编：</span><br><span class="line">call_proc:</span><br><span class="line">  subq $<span class="number">32</span><span class="punctuation">,</span><span class="variable">%rsp</span></span><br><span class="line">  movq $<span class="number">1</span><span class="punctuation">,</span> <span class="number">24</span>(<span class="variable">%rsp</span>)</span><br><span class="line">  movq $<span class="number">2</span><span class="punctuation">,</span> <span class="number">20</span>(<span class="variable">%rsp</span>)</span><br><span class="line">  movq $<span class="number">3</span><span class="punctuation">,</span> <span class="number">18</span>(<span class="variable">%rsp</span>)</span><br><span class="line">  movq $<span class="number">4</span><span class="punctuation">,</span> <span class="number">17</span>(<span class="variable">%rsp</span>)</span><br><span class="line">  leaq <span class="number">17</span>(<span class="variable">%rsp</span>)<span class="punctuation">,</span> <span class="variable">%rax</span></span><br><span class="line">  </span><br><span class="line">  movq <span class="variable">%rax</span><span class="punctuation">,</span> <span class="number">8</span>(<span class="variable">%rsp</span>)</span><br><span class="line">  movl $<span class="number">4</span><span class="punctuation">,</span> (<span class="variable">%rsp</span>)</span><br><span class="line">  leaq <span class="number">18</span>(<span class="variable">%rsp</span>)<span class="punctuation">,</span> <span class="variable">%r9</span></span><br><span class="line">  movl $<span class="number">3</span><span class="punctuation">,</span> <span class="variable">%r8d</span></span><br><span class="line">  leaq <span class="number">20</span>(<span class="variable">%rsp</span>)<span class="punctuation">,</span> <span class="variable">%rcx</span></span><br><span class="line">  movl $<span class="number">2</span><span class="punctuation">,</span><span class="variable">%edx</span></span><br><span class="line">  leaq <span class="number">24</span>(<span class="variable">%rsp</span>)<span class="punctuation">,</span> <span class="variable">%rsi</span></span><br><span class="line">  movl $<span class="number">1</span><span class="punctuation">,</span> <span class="variable">%edi</span></span><br><span class="line">  <span class="keyword">call</span> proc</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">add</span> $<span class="number">32</span><span class="punctuation">,</span><span class="variable">%rsp</span></span><br></pre></td></tr></table></figure>
<p>注意空行前面是存储地址，因为后面函数的参数中有使用。空行后面就是把8个参数赋值。可能这里会有疑问就是这里把参数都赋了值，那么函数返回到原函数时那些参数值不都变了吗？</p>
<p>按照惯例，寄存器 %rbx，%rbp 和 %r12到%15被划分成被调用者保存寄存器，也就是说，这些寄存器在被调用的函数中都会保存好，因此我们可以把参数存在这些寄存器中，然后需要的时候又从这些寄存器中取出来，这样就保证了参数值不会被改变。其他寄存器[1]<br />
。叫做调用者保存寄存器，这些寄存器由调用者自己去保护，例如rdi，rsi等，被调用者并不会保护这些寄存器，也就是说传入参数时，要先把这些寄存器压入栈中，以防止被改变<br />
[1]:rsp除外</p>
<p>例：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">long p(long <span class="keyword">x</span>, long <span class="keyword">y</span>)</span><br><span class="line">&#123;</span><br><span class="line">    long u = <span class="string">q(y)</span>;</span><br><span class="line">    long v = <span class="string">q(x)</span>;</span><br><span class="line">    <span class="keyword">return</span> u+v;</span><br><span class="line">&#125;</span><br><span class="line">汇编：</span><br><span class="line">p:</span><br><span class="line">  pushq %rbp</span><br><span class="line">  pushq %rbx</span><br><span class="line">  subq $8,%rsp</span><br><span class="line">  movq %rdi, %rbp</span><br><span class="line">  movq %rsi, %rdi</span><br><span class="line">  call <span class="keyword">q</span></span><br><span class="line">  movq %rax, %rbx//保存得到的函数值</span><br><span class="line">  movq %rbp, %rdi</span><br><span class="line">  calll <span class="keyword">q</span></span><br><span class="line">  addq %rbx, %rax</span><br><span class="line">  addq $8, %rsp</span><br><span class="line">  popq %rbx</span><br><span class="line">  popq %rbp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>这段代码开始把rbp和rbx拉进栈，是因为后面要改变rbx和rbp，而p本身也是一个函数，要保证被调用者保存寄存器不会被改变，之后在q函数传递参数前先把p的参数保存到rbp和rbx中，这样就保证了参数在函数中不会被破坏。之后传递参数时也可以直接从rbp中传入，</p>
<h3 id="栈中的内容"><a class="markdownIt-Anchor" href="#栈中的内容"></a> 栈中的内容</h3>
<p>从上面我们可以看到，栈中的内容可能会有寄存器，局部变量，下一个函数所需要的参数等。</p>
<p>有三类函数，一种是只有调用者的身份，一种是既有调用者又有被调用者的身份，第三种是只有被调用者的身份。</p>
<p>对于第一种。首先保存参数，之后保存调用者保存寄存器和局部变量，然后保存返回地址。</p>
<p>对于第二种，同样首先保存参数，之后保存局部变量，但是这里还可能要保存被调用者保存寄存器。同样保存返回地址</p>
<p>对于第三种，其他大致相同，但是不需要保存被调用者保存寄存器了。</p>
<p>对于函数的大致过程，首先传入参数，然后运用call进入函数。然后里面可能有一些局部变量需要保存或者寄存器需要保存，这时我们需要分配一个栈帧。之后如果进入函数，首先我们要传递参数（如果进入多个函数且这些函数运动了调用者函数的参数那此时先要把调用者参数放到被调用者保存寄存器中，防止调用者的参数被破坏）。然后call进入函数，被调用者函数返回前先要把被调用者保存寄存器中的内容弹出，和把栈帧释放。之后在调用者函数返回之前要先把调用者保存寄存器弹出，最后返回。</p>
]]></content>
      <categories>
        <category>汇编</category>
        <category>AT&amp;T</category>
      </categories>
  </entry>
  <entry>
    <title>栈.                                      </title>
    <url>/post/51491.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>栈是一段连续的内存空间，这个空间的特殊性在于，最后进入这个空间的数据，最先出去</p>
<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3>
<p>通过ss sp 两个寄存器确定了一个栈顶指针，然后随着一些操作，这个指针会向上向下移动<br />
例如 push ax，这条指令会将ax中的内容运到栈中，然后sp-2。<strong>注意</strong>，栈顶地址为低地址，栈底地址为高地址，因此增加元素会使sp值减小</p>
<p>在栈为空的时候，偏移地址为栈底地址加2，例如栈底为000F，则此时偏移地址为10，在拉一个元素进栈后，偏移地址为000E，恰好是数据最高位（一个数据一个字，两个字节，栈底为000F，用了两个空间，因此此时元素到了000E，恰好sp也是000E</p>
<h3 id="超界问题"><a class="markdownIt-Anchor" href="#超界问题"></a> 超界问题</h3>
<p>8086cpu并没有特定的机制来检查我们是否超界，只能够靠自己小心，超界是一个十分严重的问题，因为既然这一段被分配为栈了，说明其他的内存有其他的用途，如果超界，可能会干扰其他程序的运行。要注意，栈的范围最大是0到ffff即2的16次方字节</p>
<h3 id="push-pop-命令"><a class="markdownIt-Anchor" href="#push-pop-命令"></a> push pop 命令</h3>
<p>push 寄存器 pop 寄存器<br />
也可以是push内存地址，pop内存地址</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编中的多层循环</title>
    <url>/post/6587.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>因为唯一的用于统计循环次数的寄存器就是cx，所以有多层循环的时候就会碰到循环次数难以记录的问题，以下是一种解决办法</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span>//用另一个寄存器来存<span class="built_in">cx</span>的次数</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol"> s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>+<span class="built_in">bx</span>]</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">si</span>+<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">   <span class="keyword">loop</span> s</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>//这里把<span class="built_in">cx</span>次数取出来减一次</span><br><span class="line">   <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure>
<p>但是寄存器的数量是有限的，如果多次循环可能会导致寄存器不够用，因此可以先在数据段定义一个字型数据，然后直接把循环次数放到里面</p>
 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> </span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol">  s0:</span> <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">cx</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2</span></span><br><span class="line"><span class="symbol">  s:</span>  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">loop</span> s</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">     <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure>
<p>此外，还可以定义一个栈，直接用push，pop命令把cx值取出存入</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编指令学习（待补充）</title>
    <url>/post/47075.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>mov 内存地址1：内存地址2。把地址上的数据从2赋值到1</li>
<li>sub 。。。            数据1-数据2</li>
<li>add  。。。                  +</li>
<li>inc  寄存器    让寄存器上的数据+1</li>
<li>dw  “define word” 定义字型数据</li>
<li>and 逻辑与命令，按位进行与运算 可以通过该命令将相应为变为0，其他位不变</li>
</ul>
<p>例如：</p>
<pre><code>mov al,01100011b
and al,00111011b
</code></pre>
<p>执行后al=00100011b</p>
<ul>
<li>or 按位进行或运算 前面一个例子，如果是or的话为01111011b，可以通过该命令将相应位变为1，其他为不变</li>
<li>db，字符型数据</li>
<li>ptr word ptr,byte ptr ,确定是什么数据</li>
<li>div 除法指令，被除数要比除数多8位，如果除数为8位，被除数为16位，除数为16位，被除数为32位，被除数可以用dx和ax存放</li>
</ul>
<p>如果除数为8位，则用al储存商，ah储存余数，如果除数为16位，则用ax储存商，dx储存余数</p>
<p>例： div bl 这个就是除数为8位，默认被除数是ax</p>
<p>div bx 这个除数是16位，则要用dx和ax两个寄存器来储存被除数，先转为16进制，dx储存高位，ax储存低位</p>
<p>例 计算 100001/100<br />
被除数大于65536，因此要用32位 寄存器，100001的16进制是186A1h</p>
  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>，<span class="number">1h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">86A1h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">100</span></span><br><span class="line"><span class="keyword">div</span> <span class="built_in">bx</span></span><br></pre></td></tr></table></figure>
<ul>
<li>diwdw（这不是关键字，这是一个子程序） 进行不会产生除法溢出的运算，被除数为dword型，除数为word型，结果为dword型</li>
</ul>
<p>参数： ax=dword 型数据低十六位</p>
<pre><code> dx=高十六位
 
 cx=除数
</code></pre>
<p>返回：dx=结果高十六位，ax=结果低十六位   cx=余数</p>
<p>原理（公式）：x/n=int(h/n)*65536+[rem(h/n)*65536+l]/n</p>
<p>x：被除数 ， n：除数 h :x高十六位 ，l :x低十六位，int（）:取商，例 int（38/10)=3,rem()：取余数</p>
<ul>
<li>dd 双字型</li>
<li>dup 用于数据的重复</li>
<li>jmp 用于跳转</li>
<li>jcxz 格式 jcxz 标号（如果cx=0，则跳转到标号处运行） 这是短指令</li>
<li>ret 用栈数据修改ip</li>
<li>retf 用栈数据修改cs和ip</li>
<li>call 先把ip存入栈，再跳转</li>
<li>call far ptr 先存 ip，再存cs，再跳转</li>
<li>call word ptr 根据内存</li>
<li>mul 乘法指令</li>
<li>offset 获取标号的偏移地址</li>
<li>adc 带进位加法指令</li>
<li>sbb 带借位减法指令</li>
<li>cmp 比较指令</li>
<li>j… 例 je ja jb 带条件跳转指令</li>
<li>movsb， movsw ，串传送指令</li>
<li>rep 根据cx的值，重复执行串传送指令</li>
<li>cld df=0</li>
<li>std df=1</li>
<li>pushf，将标志寄存器的值压入栈</li>
<li>popf，将标志寄存器的值弹出栈</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编的第一个程序</title>
    <url>/post/48220.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="伪指令"><a class="markdownIt-Anchor" href="#伪指令"></a> 伪指令</h3>
<p>编译器中，包含两种指令，一种是汇编指令，一种是伪指令。伪指令是给编译器看的，最终不会被cpu执行。先了解三个最为基础的伪指令</p>
<ul>
<li>XXX segment，XXX ends，这两个是配套使用的。功能是定义一个代码段，一个段必须要有一个名称标识（XXX是也）</li>
</ul>
<p>例如codesg segment ，codesg ends</p>
<ul>
<li>assume</li>
</ul>
<p>这条指令作用是假设某一寄存器和程序中的某一个用segment和ends定义的段相关联，写在最开头。</p>
<ul>
<li>end</li>
</ul>
<p>没什么特别的，程序的结束标识，不写程序不知道在哪里结束</p>
<h3 id="一个程序"><a class="markdownIt-Anchor" href="#一个程序"></a> 一个程序</h3>
<pre><code>assume cs: codesg
codesg segment
    mov ax,0123
    mov bx,0456
    add ax,bx
    mov ax,4c00
    int 21
codesg ends
end
</code></pre>
<h4 id="程序返回"><a class="markdownIt-Anchor" href="#程序返回"></a> 程序返回</h4>
<p>在单任务操作系统上，一次只可以执行一个程序，那么当我们写的这个程序执行完之后，还要把cpu控制权交给dos，而mov ax，4c00 和 int 21 就是做这个工作的</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编指令 AT&amp;T版 64位</title>
    <url>/post/1326.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>用g++ -Og -S -masm=intel name.c 可以生成intel格式的汇编代码，-S是生成汇编代码，-Og是省去不重要的部分，如果不加这个，可能5条指令要变成十多条指令</p>
<p>-fno-if-conversion 分支语句不要采用条件传输的方式，条件跳转的方式</p>
<p>-g debug</p>
<p>objdump -d 反汇编</p>
<p>gdb 调试 b+ 标号 设置断点 info register 查看寄存器 r 执行到断点出</p>
<p>n（next） 执行下一条命令</p>
<p><a href="https://xinhecuican.github.io/post/63002.html">gdb调试更多可看</a></p>
<h4 id="mov-移动指令"><a class="markdownIt-Anchor" href="#mov-移动指令"></a> mov 移动指令</h4>
<p>格式： movq a,b</p>
<p>a是原操作数，b是目标操作数</p>
<p>这个指令中的q代表的是64位</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>类型</th>
<th>别名</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>char</td>
<td>byte</td>
<td>b</td>
</tr>
<tr>
<td>2</td>
<td>short</td>
<td>word</td>
<td>w</td>
</tr>
<tr>
<td>4</td>
<td>int</td>
<td>double word（long word）</td>
<td>l</td>
</tr>
<tr>
<td>8</td>
<td>long</td>
<td>quad word</td>
<td>q</td>
</tr>
<tr>
<td>8</td>
<td>char*</td>
<td>quad word</td>
<td>q</td>
</tr>
<tr>
<td>4</td>
<td>float</td>
<td>…</td>
<td>s</td>
</tr>
<tr>
<td>8</td>
<td>double</td>
<td>…</td>
<td>l</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>源操作数</th>
<th>目标操作数</th>
</tr>
</thead>
<tbody>
<tr>
<td>立即数（idata)</td>
<td>寄存器 ，地址</td>
</tr>
<tr>
<td>寄存器</td>
<td>寄存器，地址</td>
</tr>
<tr>
<td>地址</td>
<td>寄存器</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>操作数</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>立即数</td>
<td>$</td>
</tr>
<tr>
<td>寄存器</td>
<td>%</td>
</tr>
<tr>
<td>地址</td>
<td>（）</td>
</tr>
<tr>
<td>地址中数据</td>
<td>不加任何符号</td>
</tr>
</tbody>
</table>
<p>例：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">movq $2,%rax</span><br><span class="line">movq %rax,%rbx</span><br><span class="line">mov<span class="string">q (%rax)</span>,%rbx</span><br></pre></td></tr></table></figure>
<p>注意；</p>
<ul>
<li>当源操作数为地址的时候，目标操作数不能也是地址，因为一定要通过cpu进行调控，从地址到地址代表没有经过cpu（解释是这样，但我觉得不太合理）</li>
<li>立即数不能为8字节，使用 movabsq 可以让立即数为8字节</li>
<li>地址都是8字节，也就是上面的char*</li>
<li>如果把一个32位数给64位寄存器，那么高三十二位自动变成0.但是如果是16位或者8位的话高位不会改变</li>
</ul>
<p>例如：</p>
<p>movabsq $0x0011223344556677,%rax</p>
<p>movq $-1,%rax</p>
<p>%rax= 00000000ffffffff</p>
<h5 id="地址的写法"><a class="markdownIt-Anchor" href="#地址的写法"></a> 地址的写法</h5>
<p>地址可以写为一个四元组 A（寄存器1，寄存器2，B）</p>
<p>这个四元组其实是  寄存器1+B*寄存器2+A</p>
<p>其中B可以是1,2,4,8。从数组的角度来看，寄存器1相当于起始地址，寄存器2相当于偏移地址，B是一个数据的字节数</p>
<p>同时 64位寄存器前缀是r，三十二位前缀是e，16位没有前缀，8位后面是l和h</p>
<p>例：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rax</span></span><br><span class="line"><span class="built_in">eax</span></span><br><span class="line"><span class="built_in">ax</span></span><br><span class="line"><span class="built_in">al</span></span><br><span class="line"><span class="number">ah</span></span><br></pre></td></tr></table></figure>
<h5 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h5>
<p>格式 movzab</p>
<p>a代表原格式，b代表现格式，一般是从小的转换成大的。而z代表多的位补0</p>
<p>例： movzlq</p>
<p>特殊形式： cltq 把32位寄存器扩展到64位并且赋值给自己，</p>
<p>movsab 有符号扩展，最高位为1那么扩展出来的位全是1。</p>
<h4 id="leaq-地址转移"><a class="markdownIt-Anchor" href="#leaq-地址转移"></a> leaq 地址转移</h4>
<p>格式 leaq 地址，寄存器</p>
<p>看起来与mov没什么区别，但是mov中的地址是要取地址中的数，而这里的地址只是把对应地址给寄存器</p>
<p>例如： leaq (%rax,%rbx,4),%rdx 这条指令类似于把数组中某一元素的地址给了rdx</p>
<p>它还可用来求值</p>
<p>例如 要求x* 12</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mul(<span class="keyword">int</span> <span class="keyword">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">   lea<span class="string">q (%rdi,%rdi,2)</span>,%rax</span><br><span class="line">   salq %rax,<span class="number">2</span>//左移指令</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">x</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码只要看中间两条指令就可以了，leaq 中的数运算之后是3rdi，然后左移两位就是12了。</p>
<p>但是这条指令不会判断溢出，且不会改变标志寄存器</p>
<h4 id="比较指令"><a class="markdownIt-Anchor" href="#比较指令"></a> 比较指令</h4>
<p>这里涉及到标志寄存器，<a href="https://xinhecuican.github.io/post/57339.html">在前面一篇博客中已经提到</a></p>
<p>cmpq 比较指令</p>
<p>textq 与比较</p>
<p>textq b a 把a与b相与，不改变a和b的值，只会改变标志寄存器中的zf和sf。</p>
<p>这个指令通常用来判断某一位是否是1，例如 textq a,0x1 ，如果最低位为1，那么zf就是0，说明最低位是1</p>
<h5 id="标志寄存器的访问"><a class="markdownIt-Anchor" href="#标志寄存器的访问"></a> 标志寄存器的访问</h5>
<table>
<thead>
<tr>
<th>操作名</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sete</td>
<td>ZF</td>
<td>Equal</td>
</tr>
<tr>
<td>setne</td>
<td>~ZF</td>
<td>not equal</td>
</tr>
<tr>
<td>sets</td>
<td>SF</td>
<td>sign</td>
</tr>
<tr>
<td>setns</td>
<td>~SF</td>
<td></td>
</tr>
<tr>
<td>setg</td>
<td><sub>(SF^OF)&amp;</sub>ZF</td>
<td>greater 有符号数</td>
</tr>
<tr>
<td>setge</td>
<td>~(SF^OF)</td>
<td>大于等于</td>
</tr>
<tr>
<td>setl</td>
<td>(SF^OF)</td>
<td>less</td>
</tr>
<tr>
<td>setle</td>
<td>…</td>
<td>小于等于</td>
</tr>
<tr>
<td>seta</td>
<td><sub>CF&amp;</sub>ZF</td>
<td>above 无符号数</td>
</tr>
<tr>
<td>setb</td>
<td>CF</td>
<td>below 小于</td>
</tr>
</tbody>
</table>
<p>这些指令都是返回到8位寄存器上，将高七位置0，最低位依据含义所进行的运算来判断是0还是1</p>
<p>之后可以 movzbl %al,%eax，这时高三十二位也会被清零</p>
<h4 id="跳转指令"><a class="markdownIt-Anchor" href="#跳转指令"></a> 跳转指令</h4>
<p><a href="https://xinhecuican.github.io/post/2647.html">前面博客中也已谈到过</a></p>
<p>这里再补充jg和gb等，其实就是上面同样的模式</p>
<p>此外，由于是64位系统，没有cs寄存器，且intel使用cisc指令集，所以会自动根据指令长度进行判断用多少位长来储存位移</p>
<p>此外 x86 64位系统中 还提供了一种 jmp *(%rax) 也就是把rax作为地址，取内存中的内容</p>
<h4 id="条件跳转指令"><a class="markdownIt-Anchor" href="#条件跳转指令"></a> 条件跳转指令</h4>
<p>格式： cmov +后缀 a b，后缀格式就是前面set的格式</p>
<p>作用: 如果满足条件，则把a赋值给b，如果不满足，则不做处理</p>
<p>现代编译器在遇到分支语句时会尽量用条件跳转的格式执行，因为cpu采用了流水线作业的模式（就是一次提前搬运多条指令） 但是条件跳转指令会使流水线停止运行，而流水线可以明显增加cpu速度。</p>
<p>条件跳转的格式就是先把 if 和else的内容都计算出来，然后在最后用条件跳转指令进行比较。</p>
<p>例如</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">int a;</span><br><span class="line"><span class="meta">if</span>(<span class="meta">x</span>&gt;y)</span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="meta">x</span>-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">else</span></span><br><span class="line">&#123;</span><br><span class="line">    a=y-<span class="meta">x</span>;</span><br><span class="line">&#125;</span><br><span class="line">汇编模式</span><br><span class="line">movq <span class="name">%rdi</span>,<span class="name">%rax</span></span><br><span class="line">subq <span class="name">%rsi</span>,<span class="name">%rax</span></span><br><span class="line">movq <span class="name">%rsi</span>,<span class="name">%rdx</span></span><br><span class="line">subq <span class="name">%rdi</span>,<span class="name">%rdx</span></span><br><span class="line">cmovle <span class="name">%rdx</span>,<span class="name">%rax</span></span><br></pre></td></tr></table></figure>
<p>可以看出，用条件跳转模式会多计算一些指令，不会破坏流水线，如果在流水线上减少的时间大于多进行指令所消耗的时间，那么用条件跳转指令比较合适。反之，直接用条件指令。</p>
<p>下列几种情况不适合用条件跳转指令</p>
<ol>
<li>分支语句计算量大（执行时间过多，划不来）</li>
<li>在要判断是否可以运算的情况，例如 var=p ？*p ： 0，这条语句意思是如果p不为空指针那么将p的内容赋给var，否则赋0.但是如果用条件跳转会出错，因为空指针不能取值</li>
<li>计算可能产生副作用（即前后两个分支之间会产生影响）。例如 var=x&gt;0 ? x*=3 : x+=6,这个分支前面对后面会产生影响，因此不能简单粗暴的直接条件跳转</li>
</ol>
<h4 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h4>
<ul>
<li>do-while循环</li>
</ul>
<p>do-while循环用goto语句表达成</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码便是先执行，后比较。很容易就可以转化成汇编。goto可以用条件转移指令代替。</p>
<ul>
<li>while循环</li>
</ul>
<p>while循环有两种形式，第一种是在最开始进行一次跳转，如果符合则进入循环，不符合则退出</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!x) <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>第二种是先跳过第一次循环直接进行判断。</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">goto test;</span><br><span class="line">loop:</span><br><span class="line">statement;</span><br><span class="line">test:</span><br><span class="line">if(x) goto loop;</span><br></pre></td></tr></table></figure>
<p>由于cpu流水线的限制，两条连续的跳转指令会减慢cpu运行的速度，因此最好采用第一种办法（虽然代码多）</p>
<ul>
<li>for循环</li>
</ul>
<p>for(init; test; update)</p>
<p>可以转化成</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">init<span class="comment">;</span></span><br><span class="line">while(test)</span><br><span class="line">&#123;</span><br><span class="line">  statement<span class="comment">;</span></span><br><span class="line">  update<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再然后就可以变成汇编代码</p>
<h4 id="switch-汇编实现"><a class="markdownIt-Anchor" href="#switch-汇编实现"></a> switch 汇编实现</h4>
<p>首先要了解条件语句和switch的区别，if语句要从上倒下一条一条判断，如果数量多的话时间开销大。而switch是根据标号直接跳转，无论要跳转到哪一个时间开销都一定。</p>
<p>内存中实际上在编译时已经设定了一个跳转表，这个跳转表的标号是一个固定的地址，不能被改变，这个标号内的数据就是每一条指令的跳转地址，而且是8字节。</p>
<p>因此跳转语句可以这样写: jmp .L4(,%rdi,8)</p>
<p>其中.L4代表的是跳转表的标号（不一定是这个名字，举个例子）而rdi就是switch中的x，</p>
<p>如果标号很大，例如10000甚至1000000开始的时候，如果把前面的查找表一个个全部设置出来，空间开销会很大，所以编译器会先自动的减去一个数使他处于较小的范围，但是这种情况只适用于数据密集的情况。</p>
<p>如果数据稀疏例如一个是1一个是10000，这个时候偏移也不行了，只有通过先排序再二分搜索来查找标号，这个复杂度是logn</p>
<h4 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项</h4>
<ul>
<li>inc 自增</li>
<li>dec 自减</li>
<li>neg 取负 -x</li>
<li>not 取非 ~x</li>
<li>imul 乘</li>
<li>xor 异或</li>
<li>or 或</li>
<li>and 与</li>
<li>sal shl 左移</li>
<li>sar 算数右移</li>
<li>shr 逻辑右移</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>AT&amp;T</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言写函数</title>
    <url>/post/54613.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>例,计算data段第一行的三次方，并储存到第二行上</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">    <span class="built_in">dd</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span></span><br><span class="line"><span class="symbol">  s:</span> <span class="keyword">mov</span> <span class="built_in">bx</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">call</span> cube</span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">di</span>].<span class="number">2</span>,<span class="built_in">dx</span> ；这个的含义是[<span class="built_in">di</span>]的第二个字节</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">4</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">cube:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"> code ends</span><br><span class="line"> end start</span><br></pre></td></tr></table></figure>
<p>这个程序函数是cube，注意想要跳转就用call，想要返回就用ret。这时返回值存在ax和dx中，参数在bx中，可如果有多个参数，寄存器不够时，可以用栈来传递参数</p>
<h3 id="用栈传递参数"><a class="markdownIt-Anchor" href="#用栈传递参数"></a> 用栈传递参数</h3>
<p>例：计算（a-b）^3，a，b为字型数据<br />
参数 进入子程序时，栈顶存放ip，后面依次存放a，b<br />
结果：（dx：ax）=(a-b)^3</p>
 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">difcube:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">4</span>] <span class="comment">;将a的值送入栈中</span></span><br><span class="line">      <span class="keyword">sub</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">6</span>] ；减去b的值</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">ret</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>ret n的含义为，pop ip add sp，n</p>
<p>而ret 4 的原因是此时栈中有2个数据，要想把栈清空，要移动四个单位（字型）。而push bp ，pop bp 是为了保证bp中的数据没有改变</p>
<h3 id="寄存器冲突问题"><a class="markdownIt-Anchor" href="#寄存器冲突问题"></a> 寄存器冲突问题</h3>
<p>例 将data段中的字母变为大写，以0结尾</p>
 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">   <span class="built_in">db</span> <span class="string">&#x27;fafdsfs&#x27;</span>,<span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">call</span> capital</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">5</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">capital:</span> <span class="keyword">mov</span> <span class="built_in">cl</span>,,[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">jcxz</span> ok</span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">jmp</span> short capital</span><br><span class="line"><span class="symbol">    ok:</span><span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>这个程序实际上是有问题的，因为进行一次capital后，cx的值一定为0，直接退出主程序的循环</p>
<p>要解决这个问题，有两种方案</p>
<ol>
<li>找另一个没有使用的寄存器</li>
<li>不要使用会发生冲突的寄存器</li>
</ol>
<p>这样实际上是不可能的，例如cx，循环便一定会冲突</p>
<p>解决方案就是，在进入函数前把所用到寄存器的内容保存起来，结束函数在进行使用</p>
<p>由此我们可以得到子程序设计的标准</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">子程序开始： 子程序中使用的寄存器入栈</span><br><span class="line">         子程序内容</span><br><span class="line">         子程序所使用寄存器出栈</span><br><span class="line">         返回 （<span class="keyword">ret</span> ，<span class="keyword">retf</span>）</span><br></pre></td></tr></table></figure>
<p>这里要注意一个问题，当把寄存器内容入栈后，sp会发生改变，如果子程序中也要使用栈要注意地址的变化</p>
<p>同时还要注意入账和出栈的顺序<br />
例</p>
 <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">capital:</span> <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">      <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">cx</span></span><br></pre></td></tr></table></figure>
<p>后进先出</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编语言数据位置的表达</title>
    <url>/post/12334.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="立即数"><a class="markdownIt-Anchor" href="#立即数"></a> 立即数</h3>
<p>其实就是idata，这种数据执行前在cpu的指令缓冲器中，在汇编指令中直接给出</p>
<h3 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h3>
<p>指令要处理的数据在寄存器中，在汇编指令中给出相应寄存器名</p>
<h3 id="段地址sa和偏移地址ea"><a class="markdownIt-Anchor" href="#段地址sa和偏移地址ea"></a> 段地址（SA）和偏移地址（EA)</h3>
<p>这些数据在内存中，在汇编指令中可以用[x]的方式给出</p>
<h2 id="指令要处理数据有多长"><a class="markdownIt-Anchor" href="#指令要处理数据有多长"></a> 指令要处理数据有多长</h2>
<p>用寄存器的ax或al可以很方便的说明数据长度，但是如果是内存之间的传递可以用<br />
x ptr 的方式确定是字型传递还是字节性传递</p>
<p>例： mov word ptr ds:[0],1</p>
<p>mov byte ptr ds:[0],1</p>
<p>另外，push操作无需指明，因为push只对字进行操作</p>
<h2 id="结构体的汇编表达"><a class="markdownIt-Anchor" href="#结构体的汇编表达"></a> 结构体的汇编表达</h2>
<p>一般来说，我们可以用[bx+idata+si]的方式来表达结构体中的数据，用bx定位整个结构体，用idata定义某一个数据项，用si确定数据项中的一个元素</p>
<p>可以简写为 [bx].idata,[bx].idata[si]</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>流水线</title>
    <url>/post/b4c1d206.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>cpu运算可以简化成两大块，运算单元和寄存器。大致过程是先从寄存器中取值然后放入运算单元中运算完成之后又放入寄存器中。大致过程可分为六个部分</p>
<ol>
<li>fetch(取指），读入指令</li>
<li>decode(译码),解码然后把寄存器中的值放到运算单元中</li>
<li>execute(执行), 进行计算</li>
<li>memory(访存),把结果放到内存中</li>
<li>write back（写回），把结果放到寄存器中</li>
<li>PC（更新PC）</li>
</ol>
<p>这六个部分和把数据放到寄存器所用的总时间就是执行一条指令所需要的时间。cpu中有一个时钟，时钟以特定的周期进行高电压和低电压的变换。每一个周期内cpu执行一条指令，这个周期就是时钟周期。</p>
<p>但是这样速度不够快，因为cpu同一时间内只有一部分在工作，其他的都处于待机状态，所以可以用一种办法把其他部分利用起来。</p>
<p>之前我们之所以不能连续送入多条指令的原因是如果牵一条指令还未执行完成后一条指令便开始执行很可能导致电路出现问题（先这样理解吧）。如果我们在中间插入寄存器的话便不存在这个问题了。</p>
<p>例如：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> 算术单元 </span>|<span class="string"> 寄存器 </span>|</span><br><span class="line">|<span class="string"> 300ps   </span>|<span class="string">  20ps  </span>|</span><br><span class="line">|<span class="string"> 算术单元1 </span>|<span class="string"> 寄存器1 </span>|<span class="string"> 算术单元2 </span>|<span class="string"> 寄存器2 </span>|<span class="string"> 算术单元3 </span>|<span class="string"> 寄存器</span></span><br><span class="line">|<span class="string"> 100ps    </span>|<span class="string"> 20ps   </span>|<span class="string"> 100ps    </span>|<span class="string"> 20ps   </span>|<span class="string"> 100ps    </span>|<span class="string"> 20ps</span></span><br></pre></td></tr></table></figure>
<p>乍一看加了寄存器之后时钟周期反而变长了，便成360ps。但实际上现在可以每120ps送入一条指令，先前的运算结果可以先储存在寄存器中，新一个时钟周期时把寄存器中的值送入下一个运算单元，这样就节省了时间</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">如果把时间分成<span class="number">3</span>部分来运算</span><br><span class="line">abcabcabc  不用流水线</span><br><span class="line"><span class="keyword">abc</span></span><br><span class="line"> <span class="keyword">abc</span>      用流水线</span><br><span class="line">  <span class="keyword">abc</span></span><br></pre></td></tr></table></figure>
<p>可以看出使用流水线后时间明显缩短</p>
<p>但是流水线也有一些问题。</p>
<ol>
<li>不能无限划分，随着划分的增多价格问题也越来越严重，性能提升却不大。甚至无限划分的时候，时间反而会变成无穷大（因为寄存器上时间过多，永远也执行不了指令）。</li>
<li>不一致的划分，因为流水线的时钟频率是根据耗时最长的那一阶段来确定的，所以如果划分不一致，就会导致最长的那段时间增大。正因如此，cpu一般把取指和PC这两个阶段当做一个阶段在最开始执行。</li>
<li>数据相关。 程序中上一条指令和下一条指令很可能有关联[例]<br />
[例]: movq rax rbx movq rbx rcx</li>
<li>控制相关。 主要是条件跳转指令，因为一次输入了多条指令，所以很可能前面的判断没有完成的时候条件判断语句后面的指令已经开始计算了，这时候如果条件跳转指令跳转到了另一个地方，那前面开始计算的部分全部要清空，然后重新载入流水线。这样就会极大的影响效率。</li>
</ol>
<p>解决办法：</p>
<p>对于数据相关可以中间插入一个空命令例如</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">a阶段只有命令的传入，并没有涉及到数据的传入,假设第一条和第二条有冲突</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br><span class="line">  空</span><br><span class="line">    <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br><span class="line">      <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br></pre></td></tr></table></figure>
<p>但是这样还是会导致效率的降低。</p>
<p>一个更好的办法是在cpu内部对命令进行重排，但是又不影响运行逻辑。</p>
<p>对于控制相关可以使用数据传输指令，但是数据传输指令也具有局限性。</p>
<p>还可以通过分支预测的方法。如果是第一次进入分支，直接顺序传入指令，如果不是第一次，可以传入上一次分支运行时的指令。这样对循环具有优化作用。</p>
<p>此外在编译器层面，可以提前预测那种可能性比较大。然后把可能性大的部分放在分支语句的后面。</p>
]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>深度优先搜索和广度优先搜索</title>
    <url>/post/37663.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="深度优先搜索"><a class="markdownIt-Anchor" href="#深度优先搜索"></a> 深度优先搜索</h3>
<p>基本思想：它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念</p>
<p>例<img src="/images/%E5%9B%BE%E7%89%871.png" alt="" /></p>
<p>V0-&gt;V1-&gt;V4-&gt;V3-&gt;V5-&gt;V6,先从v0到V1，再从V1到V4，发现到了终点，就退回到V1继续寻找</p>
<p>代码</p>
<p>注意恢复初始状态十分重要，在一种情况走不了的情况下它可以使其恢复初始状态试下一条路</p>
<p><img src="/images/%E5%9B%BE%E7%89%872.png" alt="" /></p>
<p>例题：<img src="/images/%E5%9B%BE%E7%89%873.png" alt="" /></p>
<p>遍历连通图，能否从v0到v6</p>
<p>答案<img src="/images/%E5%9B%BE%E7%89%874.png" alt="" /></p>
<p>说明，重要的便是模板，先判断当前情况是否满足，如果满足则退出，不满足则遍历所有情况，如果某一位置到了头便会返回false，然后返回到分叉点，搜索下一步（遍历作用在这），而最后一定要回到初始状态，因为别的搜索也可能用</p>
<h3 id="广度优先搜索"><a class="markdownIt-Anchor" href="#广度优先搜索"></a> 广度优先搜索</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">广度优先搜索是最简便的图的搜索算法之一，别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中</span><br></pre></td></tr></table></figure>
<p>模板<br />
<img src="/images/%E5%9B%BE%E7%89%875.png" alt="" /></p>
<p>说明：从某一个起始节点开始，看是否满足，如果不满足， 遍历所有可能的情况，这里便是tt，如果tt存在，那么就把它送入队列中，之后继续遍历可能情况，这里需要两个数组，一个数组是用来确定这点是否已经走过，另外一个数组是用来记录步数的。<a href="https://blog.csdn.net/freezhanacmore/article/details/8168265">另外，有些题可能会导致数组超过范围，这时就要写一个判断条件排除掉越界的</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>神奇的逗号运算符</title>
    <url>/post/27980.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>cout&lt;&lt;(a,c),此时只会输出c的内容，但是a中的内容也会被计算，例如a=5,b=6,c=7  cout&lt;&lt;(（d=a+b),c) 输出为7，d=11</p>
]]></content>
  </entry>
  <entry>
    <title>算法设计与分析代码</title>
    <url>/post/fb98053e.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="子集和数问题"><a class="markdownIt-Anchor" href="#子集和数问题"></a> 子集和数问题</h1>
<p>由于本实验是为了验证数据集影响，因此没有采用一次增加两个的限界函数。此代码左支限界是 w+wi&gt; target,右支限界是w+rest&gt;=target. 并且由于实验网站要求在没有正确解的情况下输出近似解，因此每次触底或者左支终止之后还进行了记录。最后因为进行了排序，而数据集给出的答案中并没有进行排序，因此使用了一个结构体对开始的位置进行记录。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> *data;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;scale; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] = rand() % <span class="number">1000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=l, j=r, key=a[l];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; a[j]&gt;=key)</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; a[i]&lt;=key)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a[i], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[l], a[i]);</span><br><span class="line">        quick(a, l, i<span class="number">-1</span>);</span><br><span class="line">        quick(a, i+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paixu</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> mid, <span class="keyword">int</span> last, <span class="keyword">int</span> a[], <span class="keyword">int</span> temp[])</span><span class="comment">//这是合并过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1=first,l2=mid+<span class="number">1</span>,r1=mid,r2=last;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1&amp;&amp;l2&lt;=r2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l1]&lt;=a[l2])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2&lt;=r2)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i+first]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xunhuan</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> last, <span class="keyword">int</span> a[], <span class="keyword">int</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(first+last)/<span class="number">2</span>;</span><br><span class="line">        xunhuan(first, mid, a, temp);<span class="comment">//拆左边</span></span><br><span class="line">        xunhuan(mid+<span class="number">1</span>, last, a, temp);<span class="comment">//拆右边</span></span><br><span class="line">        paixu(first, mid, last, a, temp);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[scale];</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] temp;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    xunhuan(<span class="number">0</span>, scale<span class="number">-1</span>, a, temp);</span><br><span class="line">    <span class="keyword">delete</span> [] temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> scale;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;scale;</span><br><span class="line">    data =<span class="keyword">new</span> <span class="keyword">int</span>[scale+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    LARGE_INTEGER start_time, end_time, tc;</span><br><span class="line">    QueryPerformanceFrequency(&amp;tc);</span><br><span class="line">    <span class="keyword">double</span> duration_time;</span><br><span class="line">    <span class="keyword">double</span> ans1=<span class="number">0</span>, ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        shuffle(scale);</span><br><span class="line">        <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[scale];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;scale; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        QueryPerformanceCounter(&amp;start_time);</span><br><span class="line">        quick(temp, <span class="number">0</span>, scale<span class="number">-1</span>);</span><br><span class="line">        QueryPerformanceCounter(&amp;end_time);</span><br><span class="line">        duration_time = (<span class="keyword">double</span>)(end_time.QuadPart-start_time.QuadPart) / tc.QuadPart;</span><br><span class="line">        ans1+=duration_time;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;scale; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        QueryPerformanceCounter(&amp;start_time);</span><br><span class="line">        merge_sort(temp, scale);</span><br><span class="line">        QueryPerformanceCounter(&amp;end_time);</span><br><span class="line">        duration_time = (<span class="keyword">double</span>)(end_time.QuadPart-start_time.QuadPart) / tc.QuadPart;</span><br><span class="line">        <span class="keyword">delete</span> [] temp;</span><br><span class="line">        ans2+=duration_time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans1/<span class="number">10</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2/<span class="number">10</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="01背包问题"><a class="markdownIt-Anchor" href="#01背包问题"></a> 01背包问题</h1>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> w[<span class="number">16</span>] = &#123;<span class="number">0</span>,<span class="number">70</span>,<span class="number">73</span>,<span class="number">77</span>,<span class="number">80</span>,<span class="number">82</span>,<span class="number">87</span>,<span class="number">90</span>,<span class="number">94</span>,<span class="number">98</span>,<span class="number">106</span>,<span class="number">1110</span>,<span class="number">113</span>,<span class="number">115</span>,<span class="number">118</span>,<span class="number">120</span>&#125;;			<span class="comment">//商品的重量 </span></span><br><span class="line"><span class="keyword">int</span> v[<span class="number">16</span>] = &#123;<span class="number">0</span>,<span class="number">135</span>,<span class="number">139</span>,<span class="number">149</span>,<span class="number">150</span>,<span class="number">156</span>,<span class="number">163</span>,<span class="number">173</span>,<span class="number">184</span>,<span class="number">192</span>,<span class="number">201</span>,<span class="number">210</span>,<span class="number">214</span>,<span class="number">221</span>,<span class="number">229</span>,<span class="number">240</span>&#125;;			<span class="comment">//商品的价值</span></span><br><span class="line"><span class="keyword">int</span> bagV = <span class="number">750</span>;					        <span class="comment">//背包大小</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">16</span>][<span class="number">751</span>] = &#123; &#123; <span class="number">0</span> &#125; &#125;;			        <span class="comment">//动态规划表</span></span><br><span class="line"><span class="keyword">int</span> item[<span class="number">7</span>];					        <span class="comment">//最优解情况</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findMax</span><span class="params">()</span> </span>&#123;					<span class="comment">//动态规划</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagV; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findWhat</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;				<span class="comment">//最优解情况</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[i][j] == dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">			item[i] = <span class="number">0</span>;</span><br><span class="line">			findWhat(i - <span class="number">1</span>, j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (j - w[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][j] == dp[i - <span class="number">1</span>][j - w[i]] + v[i]) &#123;</span><br><span class="line">			item[i] = <span class="number">1</span>;</span><br><span class="line">			findWhat(i - <span class="number">1</span>, j - w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)			<span class="comment">//最优解输出</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; item[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LARGE_INTEGER start_time, end_time, tc;</span><br><span class="line">    QueryPerformanceFrequency(&amp;tc);</span><br><span class="line">    QueryPerformanceCounter(&amp;start_time);</span><br><span class="line">	findMax();</span><br><span class="line">	findWhat(<span class="number">15</span>, <span class="number">750</span>);</span><br><span class="line">	QueryPerformanceCounter(&amp;end_time);</span><br><span class="line">    <span class="keyword">double</span> duration_time = (<span class="keyword">double</span>)(end_time.QuadPart-start_time.QuadPart) / tc.QuadPart;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;duration_time&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多源最短路问题"><a class="markdownIt-Anchor" href="#多源最短路问题"></a> 多源最短路问题</h1>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SUM 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 0x3f3f3f3f </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m[MAX_SUM][MAX_SUM];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;N; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                m[i][j] = <span class="built_in">min</span>(m[i][j], m[i][k]+m[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX_SUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;MAX_SUM; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			m[i][k] = MAX;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    fstream input_stream;</span><br><span class="line">    input_stream.<span class="built_in">open</span>(<span class="string">&quot;p0.txt&quot;</span>, ios::in);</span><br><span class="line">    <span class="keyword">while</span>(!input_stream.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to;</span><br><span class="line">        <span class="keyword">double</span> sum;</span><br><span class="line">        input_stream&gt;&gt;from;</span><br><span class="line">        input_stream&gt;&gt;to;</span><br><span class="line">        input_stream&gt;&gt;sum;</span><br><span class="line">        m[from][to] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    input_stream.<span class="built_in">close</span>();</span><br><span class="line">    LARGE_INTEGER start_time, end_time, tc;</span><br><span class="line">    QueryPerformanceFrequency(&amp;tc);</span><br><span class="line">    QueryPerformanceCounter(&amp;start_time);</span><br><span class="line">    solve();</span><br><span class="line">    QueryPerformanceCounter(&amp;end_time);</span><br><span class="line">    <span class="keyword">double</span> duration_time = (<span class="keyword">double</span>)(end_time.QuadPart-start_time.QuadPart) / tc.QuadPart;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;duration_time&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="https://xinhecuican.github.io/pdf/算法设计与分析实验.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>程序执行过程的跟踪</title>
    <url>/post/7564.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>运用debug +程序名进入debug过程</p>
<p>例如 debug 1.exe</p>
<p>程序开始都是从0000的偏移地址开始的，设段地址为A，而程序开始有一段不做该程序内容，而有其他用途。这段程序占256个字节，叫psp，之后段地址偏移10h，所以真正的程序是从A+10:0 开始的（256个字节在16进制中是10，而A也是用16进制表示的）</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>程序的进入与退出</title>
    <url>/post/27890.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="程序进入"><a class="markdownIt-Anchor" href="#程序进入"></a> 程序进入</h3>
<p>在c++中，程序的入口是main函数，并且main函数有两个参数</p>
<p>int main(int argc,char* argv[])</p>
<p>argc是用来记录输入的参数的数量，而argv是用来记录输入的参数。</p>
<p>例如： ls -la，这个输入中有两个参数，第一个参数是ls，第二个参数是-la</p>
<h3 id="程序退出"><a class="markdownIt-Anchor" href="#程序退出"></a> 程序退出</h3>
<p>return 是退出当前函数，例如退出主函数或者退出任意函数</p>
<p>而 exit 是退出当前进程，也就是说就算是在调用的函数中，这个程序也会直接结束</p>
<p>exit(0)表示正常退出，exit(1)表示异常退出，更深入的内容涉及到进程。</p>
<p>exit函数在stdlib.h头文件中</p>
]]></content>
      <categories>
        <category>基础</category>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/post/f89cb603.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质</h1>
<p>红黑树是一颗二叉搜索树，并且在每个节点上增加一个变量来储存颜色，可以是红或者是黑。红黑树保证了没有一条路径会比其他路径长两倍。</p>
<p>每个节点有五个属性：color、key、left、right、p(parent)。</p>
<p>红黑树满足以下性质：</p>
<ul>
<li>根节点是黑色</li>
<li>每个叶结点是黑色的。</li>
<li>如果一个节点是红色，则两个子节点是黑色</li>
<li>对于每个节点，从这个节点到所有后代节点的简单路径上，均包含相同数目的黑色节点。</li>
</ul>
<p>在叶结点中不存在值，可以用一个哨兵节点来代指叶结点。哨兵节点颜色为黑，其他值任意，之后一旦到叶结点就连接到哨兵，这样可以减少空间占用。</p>
<p>从某一节点出发（不包含这个节点）的任意一条简单路径上黑色节点的个数叫这个点的黑高。定义红黑树的黑高是根节点的黑高。</p>
<p>可以证明，节点数为n的红黑树高度至多为2lg(n+1).</p>
<h1 id="旋转"><a class="markdownIt-Anchor" href="#旋转"></a> 旋转</h1>
<p>插入和删除可能会改变红黑树的性质，这个时候就需要通过旋转来恢复红黑树的性质。</p>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%911.jpg" alt="" /></p>
<p>左旋的过程是把y的左边给x，然后x变为y的左儿子。右旋可以类比</p>
<p>左旋函数：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void left_rotate(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//t是根节点</span></span><br><span class="line">    <span class="function"><span class="title">node</span>* y = x-&gt;</span>right;</span><br><span class="line">    <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">right</span> = y-&gt;</span>left;</span><br><span class="line">    <span class="function"><span class="title">if</span>(y-&gt;</span><span class="function"><span class="title">left</span> != NULL)//设置y-&gt;</span>left的父辈节点</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span>p = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">p</span> = x-&gt;</span>p;<span class="comment">//设置y的父辈节点</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(x-&gt;</span><span class="function"><span class="title">p</span> == NULL)//如果x-&gt;</span>p为NULL，说明它是根节点</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">t</span>-&gt;</span>root = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(x == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)<span class="comment">//这是设置原来x的父辈的连接</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right == y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">y</span>-&gt;</span>left = x;</span><br><span class="line">    <span class="function"><span class="title">x</span>-&gt;</span>p = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h1>
<p>我们可以先找到插入位置（用二叉搜索树的方法），然后将这个点着色为红。为了保证性质，我们还要用一个函数对节点重新着色并旋转。</p>
<p>调整函数：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void fixup(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">while</span>(x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> == red)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(x-&gt;</span><span class="function"><span class="title">p</span> == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">node</span>* y = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">if</span>(y-&gt;</span><span class="built_in">color</span> == red)<span class="comment">//情况1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">y</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">                <span class="function"><span class="title">x</span> = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">else</span> <span class="keyword">if</span>(x == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right)<span class="comment">//情况2</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">x</span> = x-&gt;</span>p;</span><br><span class="line">                left_rotate(t, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = black;<span class="comment">//情况3</span></span><br><span class="line">            <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">            <span class="function"><span class="title">right_rotate</span>(t, x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>p);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//和上面一样，就是把左右换一下</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">root</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为插入的是红色的节点，所以所有路径黑色节点数目相同这个性质不可能破坏。</p>
<p>这里可能被破坏的是根节点必须是黑色和红节点儿子必须是黑色两个性质。所以要从这两个性质着手去解决。</p>
<p>上面这个函数每次while都要保持下面性质：</p>
<ul>
<li>x是红节点</li>
<li>如果x-&gt;p是根节点，那么x-&gt;p是黑节点</li>
<li>如果性质被破坏，只可能是上面两条。如果是第一条，那么x是根节点并且是红节点，如果是第二条，那么它是红并且它的父亲是红。</li>
</ul>
<p>上面三种情况区别是叔节点颜色不同。在所有情况中，相同的地方是x-&gt;p-&gt;p一定是黑色，因为x-&gt;p一定是红色。</p>
<p><strong>情况1：叔节点是红色</strong></p>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%912.jpg" alt="" /></p>
<p>如图，左边是最开始的情况，白色代表红色。我们就可以把A和D图成黑色，然后C变成红色，这样每条路径黑色节点数目仍没变，但是此时C变成了红节点，可能和C的父亲有冲突，所以我们要把指针移动到C点</p>
<p><strong>情况2，情况3： 叔节点是黑色并且x是左孩子/右孩子</strong></p>
<p>情况2是x为右孩子。</p>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%913.png" alt="" /></p>
<p>情况2可以通过一个左旋变成情况3，此时x是左孩子。</p>
<p>此时把D和A都是红色。再让C一个右旋就让D到了上面（开始进行了一次左旋D到了A上面）然后让D为黑色，A和C为红色就可以了。并且这个时候循环也会结束，因为</p>
<h1 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h1>
<p>首先要基于基础的搜索二叉树删除操作，即如果删除节点是叶结点，直接删除，如果删除节点只有一个子节点，那么删除这个节点后还要让它的父节点连接这个节点的子节点，如果有两个子节点，那么要让它的前驱（或后继）来替代他。并且它的前驱的右子节点连接它的父节点。</p>
<p>总的函数过程为：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">transplant(node* t, node* u, node* v)<span class="comment">//删u节点操作，用v替代</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(u-&gt;</span>p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">t</span>-&gt;</span>root = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(u == u-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">u</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">u</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">v</span>-&gt;</span><span class="function"><span class="title">p</span> = u-&gt;</span>p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixup(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">while</span>(x != t-&gt;</span><span class="function"><span class="title">root</span> &amp;&amp; x-&gt;</span><span class="built_in">color</span> == black)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(x == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">node</span>* w = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">if</span>(w-&gt;</span><span class="built_in">color</span> == red)<span class="comment">//情况1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">                <span class="function"><span class="title">left_rotate</span>(t, x-&gt;</span>p);</span><br><span class="line">                <span class="function"><span class="title">w</span> = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span>(w-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="function"><span class="title">color</span> == black &amp;&amp; w-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="built_in">color</span> == black)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="built_in">color</span> = red;<span class="comment">//情况2</span></span><br><span class="line">                <span class="function"><span class="title">x</span> = x-&gt;</span>p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">else</span> <span class="keyword">if</span>(w-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="built_in">color</span> == black)<span class="comment">//情况3</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">                right_rotate(t, w);</span><br><span class="line">                <span class="function"><span class="title">w</span> = w-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">color</span> = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span>;<span class="comment">//情况4</span></span><br><span class="line">            <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">            <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">            <span class="function"><span class="title">left_rotate</span>(t, x-&gt;</span>p);</span><br><span class="line">            <span class="function"><span class="title">x</span> = t-&gt;</span>root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//就是左右交换一下</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="title">x</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">delete(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//y-&gt;original-&gt;color保存的是y发生改变之前的颜色</span></span><br><span class="line">    node* z;</span><br><span class="line">    node *y = x;</span><br><span class="line">    <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">original</span>-&gt;</span><span class="function"><span class="title">color</span> = y-&gt;</span><span class="built_in">color</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span>(x-&gt;</span>left == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">z</span> = x-&gt;</span>left;</span><br><span class="line">        <span class="function"><span class="title">transplant</span>(t, x, x-&gt;</span>right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(x-&gt;</span>right == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">z</span> = x-&gt;</span>right;</span><br><span class="line">        <span class="function"><span class="title">transplant</span>(t, x, x-&gt;</span>left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果两个子树都不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">y</span> = minimum(x-&gt;</span>right);<span class="comment">//找到x的后继</span></span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">original</span>-&gt;</span><span class="function"><span class="title">color</span> = y-&gt;</span><span class="built_in">color</span>;</span><br><span class="line">        <span class="function"><span class="title">z</span> = y-&gt;</span>right;</span><br><span class="line">        <span class="function"><span class="title">if</span>(y-&gt;</span>p == x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">z</span>-&gt;</span>p = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">transplant</span>(t, y, y-&gt;</span>right);</span><br><span class="line">            <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">right</span> = x-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span>p = y;</span><br><span class="line">        &#125;</span><br><span class="line">        transplant(t, x, y);</span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">left</span> = x-&gt;</span>left;</span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">color</span> = x-&gt;</span><span class="built_in">color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span>(y-&gt;</span><span class="function"><span class="title">original</span>-&gt;</span><span class="built_in">color</span> == black)</span><br><span class="line">    &#123;</span><br><span class="line">        fixup(t, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保持y是要被删除的元素,因此如果y最初的颜色是黑色就可能改变性质。而z保存的是y的原始位置。</p>
<p>在fixup中，while循环总目标是把额外的黑色沿着树往上提。</p>
<p>while节点退出条件：</p>
<ul>
<li>x指向红黑节点（两种颜色）。然后再最后再将颜色变成单独的颜色。</li>
<li>x指向根节点</li>
<li>执行适当的旋转和重新着色，退出循环。</li>
</ul>
<p>在循环中，x总是指向双重黑色节点（双重黑色就是假设z位置处额外有一个黑色，之后y删除会移走一个黑色然后性质就符合了，但是多了一个黑色会导致开开始路径黑色数目就不同，所以要把这个双重黑色的节点放到根节点处，这样就不会有影响了，红黑色就是z处原来是红色。另外这是为了理解说的，和书上的不同）。</p>
<p>如果x是双重黑色，那么w（x的兄弟）不可能是NULL，因为这会导致两边黑色不相等。</p>
<p><strong>情况1： x的兄弟w是红色的</strong><br />
<img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%915.jpg" alt="" /></p>
<p>它的目的是把兄弟节点变成黑色。先把父亲节点和兄弟节点的颜色设置好，然后进行旋转。会把情况变成情况2或3</p>
<p><strong>情况2： w黑色，并且w的两个子节点是黑色</strong></p>
<p>这个时候可以从w上去除一层黑色，也就是x变成单黑然后w变成红色，然后x到父亲节点（一定是红色），也就是说这个时候去掉了黑色但是性质不满足了（有两个红色），所以跳出循环后还要加一个把x变成黑色</p>
<p><strong>情况3： w黑色，w左孩子红色，右孩子黑色</strong></p>
<p>通过这种变换，会把情况变成情况4.</p>
<p><strong>情况4： w黑色，w右孩子红色</strong></p>
<p>这种情况也是可以去掉黑色的。然后把x设置成根是为了退出循环。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>神经网络（NN）</title>
    <url>/post/7ca31f7.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="多层向前神经网络"><a class="markdownIt-Anchor" href="#多层向前神经网络"></a> 多层向前神经网络</h1>
<p>该神经网络的层数大的有三层：输入层， 隐藏层（隐藏层可以有多层）， 输出层。</p>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C1.png" alt="" />该图是两层神经网络（输入层不算）</p>
<p>每层由单元组成（例如决策树算法中的一和零）	。输入层就是传入一些特征向量。</p>
<p><strong>理解</strong>：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">下一层的神经元可以看成y，然后每个w可以看成k，那么其实就是一条直线。有些层次用来做 <span class="meta">&amp;&amp; 或 || 的操作，这样就可以用多条直线对区域进行划分.</span></span><br></pre></td></tr></table></figure>
<p>权重： 每两层有线进行连接，线上的数值就是权重，我们是通过特征向量和权重相乘求和再用非线性方程转化得到下一层的</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>. 设计神经网络结构</span><br><span class="line">     <span class="number">3</span>.<span class="number">1</span> 使用神经网络训练数据之前，必须确定神经网络的层数，以及每层单元的个数</span><br><span class="line">     <span class="number">3</span>.<span class="number">2</span> 特征向量在被传入输入层时通常被先标准化(<span class="keyword">normalize）到0和1之间 </span>（为了加速学习过程）</span><br><span class="line">     <span class="number">3</span>.<span class="number">3</span> 离散型变量可以被编码成每一个输入单元对应一个特征值可能赋的值</span><br><span class="line">          比如：特征值A可能取三个值（<span class="built_in">a0</span>, <span class="built_in">a1</span>, <span class="built_in">a2</span>), 可以使用<span class="number">3</span>个输入单元来代表A。</span><br><span class="line">                    如果A=<span class="built_in">a0</span>, 那么代表<span class="built_in">a0</span>的单元值就取<span class="number">1</span>, 其他取<span class="number">0</span>；</span><br><span class="line">                    如果A=<span class="built_in">a1</span>, 那么代表a1de单元值就取<span class="number">1</span>，其他取<span class="number">0</span>，以此类推</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>.<span class="number">4</span> 神经网络即可以用来做分类(classification）问题，也可以解决回归(regression)问题</span><br><span class="line">          <span class="number">3</span>.<span class="number">4</span>.<span class="number">1</span> 对于分类问题，如果是<span class="number">2</span>类，可以用一个输出单元表示（<span class="number">0</span>和<span class="number">1</span>分别代表<span class="number">2</span>类,例如黑和白，不是黑就是白，所以只需要输出一类）</span><br><span class="line">                   如果多于<span class="number">2</span>类，每一个类别用一个输出单元表示</span><br><span class="line">                   所以输入层的单元数量通常等于类别的数量</span><br><span class="line"></span><br><span class="line">          <span class="number">3</span>.<span class="number">4</span>.<span class="number">2</span> 没有明确的规则来设计最好有多少个隐藏层</span><br><span class="line">                    <span class="number">3</span>.<span class="number">4</span>.<span class="number">2</span>.<span class="number">1</span> 根据实验测试和误差，以及准确度来实验并改进</span><br></pre></td></tr></table></figure>
<p><strong>交叉验证方法</strong></p>
<p>这是一种验证正确率的方法。例如我们把样例集分成10份，第一次用第一份做测试集，其他做训练集，第二次用第二个做测试集，其他做训练集。这样做十次得到的正确率再求平均值。当然划分不一定是十份。</p>
<p><strong>神经网络训练大致过程</strong>： 先根据输入确定结果，通过预测结果和真实结果之间的误差反推更新权重。</p>
<p>开始的时候可以随机的在1到-1之间给权重</p>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C2.png" alt="" /></p>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C3.png" alt="" /></p>
<p>下面这个式子就是从下一层的计算公式，单元值乘以权重求和然后再加上偏向(oj)</p>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C4.png" alt="" /></p>
<p>前面到Bias的部分已经提到了，就是上面那个方程，最后还需要经过一个非线性函数（激活函数）。</p>
<p>激活函数：</p>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C5.png" alt="" /></p>
<p>其中Ij就是前面提到的函数。</p>
<p>之后反向更新权重：</p>
<p>对于输出层：<br />
<img src="/images/pasted-10.png" alt="" />Tj是输出层标签真实值</p>
<p>对于隐藏层：<br />
<img src="/images/pasted-11.png" alt="" />其中Errk是前面一层的误差</p>
<p>权重更新：</p>
<p><img src="/images/pasted-12.png" alt="" /></p>
<p>l是学习率（learning weight），这是我们手工设置的值，在零到一之间</p>
<p>偏向更新：<br />
<img src="/images/pasted-13.png" alt="upload successful" /></p>
<p>终止条件：</p>
<ul>
<li>权重的更新低于某个阈值</li>
<li>
<pre><code>         预测的错误率低于某个阈值
</code></pre>
</li>
<li>
<pre><code>         达到预设一定的循环次数
</code></pre>
</li>
</ul>
<h2 id="梯度下降算法"><a class="markdownIt-Anchor" href="#梯度下降算法"></a> 梯度下降算法</h2>
<p>数学中梯度指的是函数关于各个偏导的一个向量，它的意义是指向上升最快的方向。因此负梯度就是下降最快的方向。</p>
<p>梯度下降算法的基本思想就是沿着梯度每次走一定距离，然后再次计算梯度，重复步骤直到走到最低点。这里的最低点是极值而不是最值</p>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C14.jpg" alt="" />以二维为例。如果让x在最低点左边。x-梯度（导数），那么x增大，朝着最低点靠近。如果在右边x-梯度，x减小，同样朝着最低点靠近。</p>
<p>我们是根据loss function来对神经网络进行调整的。而lossfunction的参数就是w和bias，因此可以对w和bias求偏导然后w- 偏导对w进行修正。</p>
<p><strong>随机梯度下降算法</strong>： 多次随机选取一些样本（mini-batch)，直到所有样例都被选取。</p>
<h2 id="反向更新"><a class="markdownIt-Anchor" href="#反向更新"></a> 反向更新</h2>
<p>反向更新利用了梯度下降算法。也就是使用 w = wi - (delta)w的方式进行更新。</p>
<p>(delta)w = L * 偏Cost / 偏w ， 所以我们的目标就是要求出偏导。</p>
<p>反向更新主要用到了四个式子。<br />
<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C15.PNG" alt="" /></p>
<p>这几个式子都有证明，这里不详细描述。</p>
<ul>
<li>第三个和第四个式子就是偏导，我们看到其中的量可以通过第一个和第二个方程求出来。</li>
<li>第一个式子是对于输出层来说的。右边第一项指的是cost关于a（预测值）的偏导。这里cost的计算式为 (预测值-实际值)的平方求和再除以2n。因此偏导就是预测值减去实际值。后面一项是激活函数的导数。</li>
<li>第二个式子是对于其他层。</li>
</ul>
<p>这里还有另一种cost <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C16.PNG" alt="" /></p>
<p>它的偏导数为<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C17.PNG" alt="" /> <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C18.PNG" alt="" />.</p>
<p>这个偏导数好在偏导的大小由a-y决定。a-y其实就是error。 error大，下降就要快。</p>
<p><strong>推导过程</strong></p>
<p>其实反向更新就是求偏导 <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C27.png" alt="" /><br />
这张图表示的是从输出反向推第一个权重，也就是上面的第一个式子。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">net</span> = w * x + b</span><br><span class="line"><span class="keyword">out</span> = 1 / 1 + <span class="keyword">e</span>^(-<span class="keyword">net</span>)</span><br><span class="line">∂<span class="keyword">E</span> / ∂<span class="keyword">out</span> = target - <span class="keyword">out</span></span><br><span class="line">∂<span class="keyword">out</span> / ∂<span class="keyword">net</span> = <span class="keyword">net</span> * (1 - <span class="keyword">net</span>)</span><br><span class="line">∂<span class="keyword">net</span> / ∂w = x</span><br><span class="line">∂<span class="keyword">E</span> / ∂w = (target - <span class="keyword">out</span>) * <span class="keyword">net</span> * (1 - <span class="keyword">net</span>) * x</span><br></pre></td></tr></table></figure>
<p>再看另一个例子<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C28.png" alt="" />这里就可以解释为什么有个求和的过程了，到w不只有一条路，而这里多了两个偏导∂outh1 / ∂neth1 和 ∂neth1 / ∂w1.这里的数值和前面是一样的。</p>
<p>有一点和前面不同，前面是∂E / ∂w，这里是∂E / ∂outh1。所以前面最后乘了一个x而这里乘了一个w。</p>
<h2 id="非线性转化函数"><a class="markdownIt-Anchor" href="#非线性转化函数"></a> 非线性转化函数</h2>
<p>激活函数一般使用S型曲线（sigmoid）。一般是双曲函数(tanh)或逻辑函数。</p>
<p>广义上的sigmoid函数需要在-1到1之间变化并且平滑。</p>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C7.PNG" alt="" /></p>
<p><strong>双曲函数</strong>：</p>
<p>tanhx = sinhx/coshx =</p>
<p>sinhx = (e^x - e^(-x))/2 、 coshx = (e^x + e^(-x)) / 2</p>
<p>导数： <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C10.PNG" alt="" /></p>
<p>图像为：<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C8.PNG" alt="" /></p>
<p><strong>逻辑函数</strong></p>
<p>p(t) = 1/(1 + e^(-t))</p>
<p>导数： <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C11.PNG" alt="" /></p>
<p>图像为： <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C9.PNG" alt="" /></p>
<h2 id="减小overfitting"><a class="markdownIt-Anchor" href="#减小overfitting"></a> 减小overfitting</h2>
<ol>
<li>
<p>增加训练数据集</p>
</li>
<li>
<p>减神经网络的规模</p>
</li>
<li>
<p>regularization <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C21.PNG" alt="" />.这是一个例子，后面一项也可以应用于其他cost函数中。加了这一项后神经网络会倾向于学习较小的权重,更少可能受到局部噪音影响<br />
<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C22.PNG" alt="" />w的更新也有变化<br />
<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C23.PNG" alt="" /> nameda随着n的变化而变化，目的是不让比值太小从而使作用失效</p>
<p>另一种regularization函数 <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C24.PNG" alt="" />它的偏导数为<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C25.PNG" alt="" />注意当w=0时，w不可导，所以直接使用没有regularization的。</p>
</li>
<li>
<ol start="3">
<li>DropOut： 防止过拟合。具体方法时让需要dropout的层的百分之p的神经元关闭（即让需要关闭的神经元值为0）。然后多次随机剔除，最后再把权重除以p</li>
</ol>
</li>
<li>
<p><strong>softmax</strong></p>
</li>
</ol>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C19.PNG" alt="" /></p>
<p>这个函数有一些独特的性质。例如zj增大，那么对应输出增大，其他输出减小。并且同一层所有输出值的和一定是1，可以用来模拟概率。所以经常用在输出层当做概率</p>
<p>对应我们可以定义一个新的cost函数 Cost(p,q)=−∑xp(x)logq(x)， 其中p是真实值，q是估计值. 它的偏导为<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C20.PNG" alt="" />这个偏导和上面的cross-entropy类似。</p>
<h1 id="卷积神经网络"><a class="markdownIt-Anchor" href="#卷积神经网络"></a> 卷积神经网络</h1>
<p>卷积神经网络对隐藏层进行了细分，常用于对图像处理。</p>
<ul>
<li>input layer： 还需要对输入数据进行一些处理，如减去均值（只需要使用训练集上均值，测试集也是使用训练集均值）</li>
<li>卷积计算层（CONV layer）： 通过一个窗口进行移动然后再和w矩阵进行点乘过滤一些信息。有三个主要参数，深度，步长和填充值。深度指的是下一层神经元数目，步长指的是窗口一次移动的长度，填充值是为了防止移动超出范围在周围补的一圈零。</li>
</ul>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C6.PNG" alt="" />这里深度是2，步长是2，填充值是1.其中最右边绿色就是输出。它是通过左边蓝色的窗口和红色的w进行点乘然后相加得到的。有三层是因为输入一个32 * 32 * 3（RGB）的矩阵，然后通过运算可以得到输出矩阵。</p>
<ul>
<li>激励层： 将卷积层结果进行非线性映射，典型的激励函数是ReLu，sigmoid函数其实很少用了，因为在数据比较大的时候导数趋近于0，难以训练。</li>
</ul>
<p>ReLu方程式 y = max(0, x).也就是小于0时y=0，大于0时y=x。但是这个函数问题是小于0时导数=0，也无法训练。因此改进是小于0时y=0.01x</p>
<ul>
<li>池化层（pooling layer): 池化层一般夹在连续的卷积层中间，它是用来压缩数据量，减少过拟合。方法是max pooling。也是通过一个窗口，每次去窗口中的最大值形成一个矩阵。</li>
</ul>
<p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C12.PNG" alt="" />由原来的4 * 4矩阵变成2 * 2矩阵</p>
<ul>
<li>全连接层： 该层和前一层之间一般所有神经元都有权重连接，一般是放在神经网络尾部，是用来防止信息丢失太多的。</li>
</ul>
<p><strong>注意点</strong></p>
<ol>
<li>
<p>权重初始化： 使用高斯函数（正态分布）去随机初始化可以让权重随机化。也就是numpy.random.randn(in, out) / np.sqrt(in/2). in是输入层个数，out是输出层个数</p>
</li>
<li>
<p>Batch Normalization: 它是用来减少初始值依赖的，通常在全连接层之后。具体算法<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C13.PNG" alt="" />其中y和b是神经网络自己学习的。</p>
</li>
</ol>
<h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1>
<p>通过前面逻辑函数的导数可以得知，前面权重更新其实就是运用激活函数的导数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanh</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.tanh(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanh_deriv</span>(<span class="params">x</span>):</span> <span class="comment"># 导数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - np.tanh(x)*np.tanh(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_derivative</span>(<span class="params">x</span>):</span> <span class="comment"># 导数</span></span><br><span class="line">    <span class="keyword">return</span> logistic(x)*(<span class="number">1</span>-logistic(x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NeuralNetwork</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, layers, activation=<span class="string">&#x27;tanh&#x27;</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param layers: A list containing the number of units in each layer.</span></span><br><span class="line"><span class="string">        Should be at least two values</span></span><br><span class="line"><span class="string">        :param activation: The activation function to be used. Can be</span></span><br><span class="line"><span class="string">        &quot;logistic&quot; or &quot;tanh&quot;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># layers是一个列表，代表输入层，隐藏层和输出层，列表中每个数字代表隐藏层中单元的数目，列表长度代表总共有多少层</span></span><br><span class="line">        <span class="keyword">if</span> activation == <span class="string">&#x27;logistic&#x27;</span>:</span><br><span class="line">            self.activation = logistic</span><br><span class="line">            self.activation_deriv = logistic_derivative</span><br><span class="line">        <span class="keyword">elif</span> activation == <span class="string">&#x27;tanh&#x27;</span>:</span><br><span class="line">            self.activation = tanh</span><br><span class="line">            self.activation_deriv = tanh_deriv</span><br><span class="line"></span><br><span class="line">        self.weights = [] <span class="comment"># 初始化一个列表来装所有的weight，这后来是一个三重矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(layers) - <span class="number">1</span>): <span class="comment"># 随机初始化weight</span></span><br><span class="line">            self.weights.append((<span class="number">2</span>*np.random.random((layers[i - <span class="number">1</span>] + <span class="number">1</span>, layers[i] + <span class="number">1</span>))-<span class="number">1</span>)*<span class="number">0.25</span>) <span class="comment"># 生成一个layers[i-1]+1行，layer[i]+1列的范围在-0.25到0.25的矩阵</span></span><br><span class="line">            self.weights.append((<span class="number">2</span>*np.random.random((layers[i] + <span class="number">1</span>, layers[i + <span class="number">1</span>]))-<span class="number">1</span>)*<span class="number">0.25</span>) <span class="comment"># 第i层到第i+1层之间</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y, learning_rate=<span class="number">0.2</span>, epochs=<span class="number">10000</span></span>):</span></span><br><span class="line">    <span class="comment"># epochs是训练次数（循环次数）</span></span><br><span class="line">        X = np.atleast_2d(X)</span><br><span class="line">        temp = np.ones([X.shape[<span class="number">0</span>], X.shape[<span class="number">1</span>]+<span class="number">1</span>])<span class="comment"># 初始化一个矩阵，值全是一，行数和列数由参数提供</span></span><br><span class="line">        temp[:, <span class="number">0</span>:-<span class="number">1</span>] = X  <span class="comment"># adding the bias unit to the input layer</span></span><br><span class="line">        X = temp</span><br><span class="line">        y = np.array(y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">            i = np.random.randint(X.shape[<span class="number">0</span>])</span><br><span class="line">            a = [X[i]]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.weights)):  <span class="comment">#going forward network, for each layer</span></span><br><span class="line">                a.append(self.activation(np.dot(a[l], self.weights[l])))  <span class="comment">#Computer the node value for each layer (O_i) using activation function</span></span><br><span class="line">              <span class="comment">#正向所有更新</span></span><br><span class="line">            error = y[i] - a[-<span class="number">1</span>]  <span class="comment">#Computer the error at the top layer</span></span><br><span class="line">            deltas = [error * self.activation_deriv(a[-<span class="number">1</span>])] <span class="comment">#For output layer, Err calculation (delta is updated error)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#Staring backprobagation</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a) - <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>): <span class="comment"># we need to begin at the second to last layer</span></span><br><span class="line">                <span class="comment">#Compute the updated error (i,e, deltas) for each node going from top layer to input layer</span></span><br><span class="line"></span><br><span class="line">                deltas.append(deltas[-<span class="number">1</span>].dot(self.weights[l].T)*self.activation_deriv(a[l]))</span><br><span class="line">            deltas.reverse()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.weights)):</span><br><span class="line">                layer = np.atleast_2d(a[i])</span><br><span class="line">                delta = np.atleast_2d(deltas[i])</span><br><span class="line">                self.weights[i] += learning_rate * layer.T.dot(delta)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = np.array(x)</span><br><span class="line">        temp = np.ones(x.shape[<span class="number">0</span>]+<span class="number">1</span>)</span><br><span class="line">        temp[<span class="number">0</span>:-<span class="number">1</span>] = x</span><br><span class="line">        a = temp</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(self.weights)):</span><br><span class="line">            a = self.activation(np.dot(a, self.weights[l]))</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/post/40997091.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1>
<p>简单线性回归指的是只有一个x和一个y</p>
<p>用来描述自变量和因变量及偏差之间关系的模型叫做回归模型</p>
<p>简单线性回归的模型是：<img src="/images/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%921.png" alt="" /></p>
<p>b0是截距，b1是斜率，e是偏差。</p>
<p><strong>关于偏差</strong></p>
<ul>
<li>他是一个随机变量，均值是0</li>
<li>它的方差对于所有自变量x是相同的</li>
<li>它的值是独立的</li>
<li>它满足正太分布</li>
</ul>
<p>线性回归方程就是少了偏差，其他和基本模型是相同的。</p>
<p>我们现在给若干x和y，要解决的问题是找出最好的截距和斜率。</p>
<h1 id="线性回归的求解"><a class="markdownIt-Anchor" href="#线性回归的求解"></a> 线性回归的求解</h1>
<p>我们要找最能代表趋势的直线，实际上就是要找距离所有点最近的直线。</p>
<p><img src="/images/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%922.PNG" alt="" />我们就是要找一条直线使得这个值最小，其中y^i是用这条直线求出来的估计值，yi是这个点的值。</p>
<p><img src="/images/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%923.PNG" alt="" />求解这个问题的数学公式</p>
<h1 id="多元线性回归"><a class="markdownIt-Anchor" href="#多元线性回归"></a> 多元线性回归</h1>
<p>它与一元线性回归的区别就是有多个自变量</p>
<p><img src="/images/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%925.PNG" alt="" /> 具体模型求解过程涉及线代高数等内容，这里不再详解。</p>
<p>使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> genfromtxt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line">dataPath = <span class="string">r&quot;Delivery.csv&quot;</span></span><br><span class="line">deliveryData = genfromtxt(dataPath,delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;data&quot;</span></span><br><span class="line"><span class="built_in">print</span> deliveryData</span><br><span class="line"></span><br><span class="line">x= deliveryData[:,:-<span class="number">1</span>]</span><br><span class="line">y = deliveryData[:,-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> x</span><br><span class="line"><span class="built_in">print</span> y</span><br><span class="line"></span><br><span class="line">lr = linear_model.LinearRegression() <span class="comment"># 模型</span></span><br><span class="line">lr.fit(x, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> lr</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;coefficients:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> lr.coef_ <span class="comment"># 估计参数 b1,...</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;intercept:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> lr.intercept_ <span class="comment"># b0</span></span><br><span class="line"></span><br><span class="line">xPredict = [<span class="number">102</span>,<span class="number">6</span>]</span><br><span class="line">yPredict = lr.predict(xPredict)</span><br><span class="line">print(<span class="string">&quot;predict:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> yPredict</span><br></pre></td></tr></table></figure>
<p>如果是分类型变量，我们需要转化成01再来运算。</p>
<p>例如男女就是分类型变量。假设一个人是男的，那么可以让它的自变量变成10。如果是女则是01，这样把一个自变量变成多个自变量从而当成数据型变量进行计算。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>线性筛</title>
    <url>/post/38035.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>埃氏筛中有重复，例如6,2与3都筛了一次，效率低<br />
线性筛定理，（口语不准确）一个数i乘以小于等于它的最小素因数的素数所得到的合数之间没有重复</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> N 10000</span></span><br><span class="line"><span class="keyword">int</span> flag[N+<span class="number">1</span>],prime[N+<span class="number">1</span>],pnum;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flag[n] 表示n是否是素数，1是素数，0不是</span></span><br><span class="line"><span class="comment">prime   中是所有的素数按从小到大排列、</span></span><br><span class="line"><span class="comment">pnum  表示素数的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	pnum=<span class="number">0</span>;<span class="comment">//初始化没有素数</span></span><br><span class="line">	<span class="comment">//先将所有数看做素数，然后开始筛选</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=N; i++)&#123;</span><br><span class="line">		flag[i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历筛去所有最大因数是i的合数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=N; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(flag[i]==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//把素数记录下来</span></span><br><span class="line">			p[pnum++]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历已知素数表中比i的最小素因数小的素数，并筛去合数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pnum &amp;&amp; p[j]*i&lt;=N; j++)&#123;</span><br><span class="line">		<span class="comment">//筛去合数</span></span><br><span class="line">			flag[p[j]*i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p[j]==<span class="number">0</span>)</span><br><span class="line">			<span class="comment">//找到i的最小素因数，找到了就终止</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>————————————————<br />
版权声明：本文为CSDN博主「太上绝情」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br />
原文链接：<a href="https://blog.csdn.net/bjrxyz/article/details/8125913">https://blog.csdn.net/bjrxyz/article/details/8125913</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>树状数组和线段树</title>
    <url>/post/58481.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="lowbit函数"><a class="markdownIt-Anchor" href="#lowbit函数"></a> lowbit函数</h3>
<p>lowbit函数指的是将元素与元素的补码按位与，即a&amp;-a，这个值返回的是从右数第一个1开始的值</p>
<p>例如 6&amp;-6， 6二进制位为110，所以6的lowbit函数值为10，即十进制下的二</p>
<pre><code>ll lowbit(ll num)
&#123;
    return num&amp;-num;
&#125;
</code></pre>
<h3 id="树状数组"><a class="markdownIt-Anchor" href="#树状数组"></a> 树状数组</h3>
<p>首先我们可以把一整个数组分为若干小部分，然后让这几个小部分叠加就可以得到数组总的和。例如，我想求a[91],我可以先求c[88],发现c[88]管理2个数，再找c[86]，这样一直进行下去就可以了。</p>
<p>c又是什么呢？例如c[6]，它的lowbit函数为2，因此它管理两位数，所以c[6]=a[5]+a[6]</p>
<p>奇数位的c[i]只有他自己，而偶数位c[i]为2的k次方</p>
<h4 id="单点修改"><a class="markdownIt-Anchor" href="#单点修改"></a> 单点修改</h4>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">add</span>(int <span class="keyword">x</span><span class="punctuation">,</span> int k) &#123;</span><br><span class="line">  while (<span class="keyword">x</span> &lt;<span class="operator">=</span> n) &#123;  //不能越界</span><br><span class="line">    <span class="keyword">c</span>[<span class="keyword">x</span>] <span class="operator">=</span> <span class="keyword">c</span>[<span class="keyword">x</span>] + k<span class="comment">;</span></span><br><span class="line">    <span class="keyword">x</span> <span class="operator">=</span> <span class="keyword">x</span> + lowbit(<span class="keyword">x</span>)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是把a[x]加上k，小于x的c不用修改</p>
<p>关键是x=x+lowbit(x)<br />
<img src="/images/1103198-20180725163149813-311841231.png" alt="" /><br />
从此图中我们可以看出，要想求偶数位节点大小，需要将所有子节点加起来，先要加自己和比自己小一位的奇数，再加上所有i+lowbit(i)=8的偶数</p>
<h4 id="求和"><a class="markdownIt-Anchor" href="#求和"></a> 求和</h4>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">int getsum(int <span class="symbol">x</span>) &#123;  <span class="comment">// a[1]……a[x]的和</span></span><br><span class="line">  int ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="symbol">x</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ans = ans + c[<span class="symbol">x</span>];</span><br><span class="line">    <span class="symbol">x</span> = <span class="symbol">x</span> - lowbit(<span class="symbol">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="建立"><a class="markdownIt-Anchor" href="#建立"></a> 建立</h4>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">  for (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">n</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">t</span>[i] += a[i];</span><br><span class="line">    <span class="built_in">int</span> j = i + lowbit(i);</span><br><span class="line">    <span class="built_in">if</span> (j &lt;= <span class="built_in">n</span>) <span class="built_in">t</span>[j] += <span class="built_in">t</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> kth(<span class="keyword">int</span> k) &#123;  //权值树状数组查询第k小</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>, <span class="keyword">ret</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">  for (<span class="keyword">int</span> i = log2(n)<span class="comment">; ~i; --i) &#123;</span></span><br><span class="line">    <span class="keyword">ret</span> += <span class="number">1</span> &lt;&lt; i<span class="comment">;</span></span><br><span class="line">    if (<span class="keyword">ret</span> &gt;= n || cnt + t[<span class="keyword">ret</span>] &gt;= k)</span><br><span class="line">      <span class="keyword">ret</span> -= <span class="number">1</span> &lt;&lt; i<span class="comment">;</span></span><br><span class="line">    else</span><br><span class="line">      cnt += t[<span class="keyword">ret</span>]<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="keyword">ret</span> + <span class="number">1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h3>
<p>含义：线段树指的是将一个区间不断二分所形成的一个二叉树，根结点代表arr[0:N]区间所对应的信息，接着根结点被分为两个子树，分别存储arr[0:(N-1)/2]及arr[(N-1)/2+1:N]两个子区间对应的信息</p>
<p>初始化：注意此处我们对于segmentTree]数组的索引从1开始算起。则对于数组中的任意结点i，其左子结点为<code>2*i</code>，右子结点为<code>2*i + 1</code>，其母结点为i/2。<br />
<img src="/images/%E5%9B%BE%E7%89%879.png" alt="" /><br />
<img src="/images/%E5%9B%BE%E7%89%8710.png" alt="" /><br />
<img src="/images/%E5%9B%BE%E7%89%878.png" alt="" /><br />
递归实际意义是先向底层递归，然后从底层向上回溯，p的意思是节点的编号</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">  <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = (s + t) / <span class="number">2</span>;</span><br><span class="line">  build(s, m, p * <span class="number">2</span>), build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间修改"><a class="markdownIt-Anchor" href="#区间修改"></a> 区间修改</h4>
<p>区间修改指的是把区间内连续多个数同时修改</p>
<p><img src="/images/%E5%9B%BE%E7%89%8711.png" alt="" />标记的作用是记录每次、每个节点要更新的值</p>
<p>另一种写法</p>
<p><img src="/images/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="" /></p>
<p>当使用lazy函数时，会让下一层的数加上相应的数并附上相应懒标记，同时根节点的懒标记将被清除，这样一层层往下就可以让每一个数都加上该值</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span>;</span><br><span class="line">    <span class="built_in">int</span> lz;</span><br><span class="line">&#125;sgm[<span class="built_in">MAX</span>*<span class="number">4</span>];</span><br><span class="line">#define <span class="built_in">mid</span> ((l+r)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">#define lc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">#define rc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">voide lazy(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> l,<span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">/*懒标记的作用是标记当前区间应该加上/减去的值，但是先不直接加，而是进行标记*/</span><br><span class="line">    sgm[lc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[lc].<span class="built_in">sum</span>+=(<span class="built_in">mid</span>-l+<span class="number">1</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].<span class="built_in">sum</span>+=(r-<span class="built_in">mid</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[<span class="built_in">n</span>].lz=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间查询"><a class="markdownIt-Anchor" href="#区间查询"></a> 区间查询</h4>
<p><img src="/images/%E5%9B%BE%E7%89%8712.png" alt="" /></p>
<p>这里的push_down就是另一种写法中的lazy</p>
<p>总代码</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define lc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">#define rc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">#define <span class="built_in">mid</span> ((l+r)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">#define <span class="built_in">MAX</span> <span class="number">100</span></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span>;</span><br><span class="line">    <span class="built_in">int</span> lz;</span><br><span class="line">&#125;sgm[<span class="built_in">MAX</span>*<span class="number">4</span>];</span><br><span class="line">void lazy(<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sgm[lc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[lc].<span class="built_in">sum</span>+=(<span class="built_in">mid</span>-l+<span class="number">1</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].<span class="built_in">sum</span>+=(r-<span class="built_in">mid</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[<span class="built_in">n</span>].lz=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">void build(<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> a[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=a[l];</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    build(l,<span class="built_in">mid</span>,lc,a);</span><br><span class="line">    build(<span class="built_in">mid</span>+<span class="number">1</span>,r,rc,a);</span><br><span class="line">    sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=sgm[lc].<span class="built_in">sum</span>+sgm[rc].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line">void update(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> L,<span class="built_in">int</span> R,<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>+=(r-l+<span class="number">1</span>)*num;</span><br><span class="line">        sgm[<span class="built_in">n</span>].lz+=num;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy(l,r,<span class="built_in">n</span>);</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(lc,L,R,l,<span class="built_in">mid</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(R&gt;<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(rc,L,R,<span class="built_in">mid</span>+<span class="number">1</span>,r,num);</span><br><span class="line">    &#125;</span><br><span class="line">    sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=sgm[lc].<span class="built_in">sum</span>+sgm[rc].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> ask(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> L,<span class="built_in">int</span> R,<span class="built_in">int</span> l,<span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        return sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy(l,r,<span class="built_in">n</span>);</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=ask(lc,L,R,l,<span class="built_in">mid</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(R&gt;<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=ask(rc,L,R,<span class="built_in">mid</span>+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a[<span class="number">10</span>];</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>,a);</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;sgm[i].<span class="built_in">sum</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    update(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ask(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>组合</title>
    <url>/post/44454.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本程序的思路是开一个数组，其下标表示1到n个数，数组元素的值为1表示其代表的数被选中，为0则没选中。</p>
<p>首先初始化，将数组前n个元素置1，表示第一个组合为前n个数。</p>
<p>然后从左到右扫描数组元素值的“10”组合，找到第一个“10”组合后将其变为“01”组合，同时将其左边的所有“1”全部移动到数组的最左端。</p>
<p>当第一个“1”移动到数组的n-m的位置，即n个“1”全部移动到最右端时，就得到了最后一个组合。</p>
<p>例如求5中选3的组合：</p>
<p>1 1 1 0 0 //1,2,3</p>
<p>1 1 0 1 0 //1,2,4</p>
<p>1 0 1 1 0 //1,3,4</p>
<p>0 1 1 1 0 //2,3,4</p>
<p>1 1 0 0 1 //1,2,5</p>
<p>1 0 1 0 1 //1,3,5</p>
<p>0 1 1 0 1 //2,3,5</p>
<p>1 0 0 1 1 //1,4,5</p>
<p>0 1 0 1 1 //2,4,5</p>
<p>0 0 1 1 1 //3,4,5</p>
<p>这里有一个关键是同时把所有的1移到左端，通过观察发现只有0在最左边的情况下才有可能要把1移动。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span>&lt;iostream&gt;</span><br><span class="line">#<span class="keyword">include</span>&lt;stdlib<span class="variable">.h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">output</span>(<span class="keyword">int</span> *a,<span class="keyword">int</span> *<span class="keyword">use</span>, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">use</span>[i]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = i;</span><br><span class="line">            cout&lt;&lt;a[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=flag+<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">use</span>[i]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> assemble(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">use</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">use</span>[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">use</span>[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tag &lt; n-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">output</span>(a, <span class="keyword">use</span>, n);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">use</span>[<span class="number">0</span>] == <span class="number">0</span>)<span class="comment">//第一位是0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">time</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(tag &lt; n-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">use</span>[tag]==<span class="number">1</span> &amp;&amp; <span class="keyword">use</span>[tag+<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">use</span>[tag] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">use</span>[tag+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">time</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">use</span>[i] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="keyword">time</span>; i&lt;tag; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">use</span>[i] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">use</span>[tag])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">time</span>++;</span><br><span class="line">                &#125;</span><br><span class="line">                tag++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tag &lt; n-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">use</span>[tag]==<span class="number">1</span> &amp;&amp; <span class="keyword">use</span>[tag+<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">use</span>[tag] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">use</span>[tag+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                tag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tag++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n,c;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="keyword">int</span> a[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    assemble(a, n, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————————————————<br />
版权声明：本文为CSDN博主「文如王勃三生慧」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br />
原文链接：<a href="https://blog.csdn.net/hf19931101/article/details/79452799">https://blog.csdn.net/hf19931101/article/details/79452799</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>线索二叉树</title>
    <url>/post/43817.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>普通的二叉树中空节点数量很多，例如一个有2n条分支的二叉树，其中节点数只有n-1个，空节点有n+1个，因此就要想办法把这些没用到的节点利用起来。</p>
<p>可以用原来的空节点去存放指针，指向其他节点，这中指针叫做线索。</p>
<p>记ptr指向二叉链表中的一个结点，以下是建立线索的规则：</p>
<p>（1）如果ptr-&gt;lchild为空，则存放指向中序遍历序列中该结点的前驱结点。这个结点称为ptr的中序前驱；</p>
<p>（2）如果ptr-&gt;rchild为空，则存放指向中序遍历序列中该结点的后继结点。这个结点称为ptr的中序后继；</p>
<p>显然，在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继，需要一个区分标志的。因此，我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是区分0或1数字的布尔型变量，其占用内存空间要小于像lchild和rchild的指针变量。结点结构如下所示。<br />
<img src="/images/26548237_13584034551s55.jpg" alt="" /></p>
<p>ltag = 0 表示指向左孩子，= 1 表示指向前驱</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉线索存储结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>Link, Thread&#125;PointerTag;    <span class="comment">//Link = 0表示指向左右孩子指针；Thread = 1表示指向前驱或后继的线索</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="keyword">char</span> data;                                      <span class="comment">//结点数据</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>                <span class="comment">//左右孩子指针</span></span><br><span class="line">       PointerTag  Ltag;                               <span class="comment">//左右标志</span></span><br><span class="line">       PointerTag  rtal;</span><br><span class="line">&#125;BitNode, *BiTree;</span><br></pre></td></tr></table></figure>
<p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以，线索化的过程就是在遍历的过程中修改空指针的过程。</p>
 <figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"> BiTree pre = NULL;                 <span class="comment">//全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"><span class="comment">//中序遍历进行中序线索化</span></span><br><span class="line">void InThreading(BiTree p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>lchild);          <span class="comment">//递归左子树线索化</span></span><br><span class="line">                <span class="comment">//===</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(!p-&gt;</span>lchild)           <span class="comment">//没有左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>ltag = Thread;    <span class="comment">//前驱线索</span></span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>lchild = pre; <span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(!pre-&gt;</span>rchild)     <span class="comment">//没有右孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rtag = Thread;  <span class="comment">//后继线索</span></span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rchild = p; <span class="comment">//前驱右孩子指针指向后继(当前结点p)</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">                <span class="comment">//===</span></span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>rchild);      <span class="comment">//递归右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码除了//===之间的代码以外，和二叉树中序遍历的递归代码机会完全一样。只不过将打印结点的功能改成了线索化的功能。</p>
<p>因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if(!pre-&gt;rchild)表示如果为空，则p就是pre的后继，于是pre-&gt;rchild = p，并且设置pre-&gt;rtag = Thread，完成后继结点的线索化。</p>
<p>前驱指的是某种遍历顺序中在你前面的节点，而后继就是在你后面的节点，这也是为什么pre = p 要写在InThreading(p-&gt;lchild)后面的原因，中序遍历是先做子树的，那么它只能是右子树的前驱而不能是左子树的前驱</p>
<p>遍历代码</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//t指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点。</span></span><br><span class="line"><span class="comment">//中序遍历二叉线索树表示二叉树t</span></span><br><span class="line">int InOrderThraverse_Thr(BiTree t)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="function"><span class="title">p</span> = t-&gt;</span>lchild;                               <span class="comment">//p指向根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != t)                               <span class="comment">//空树或遍历结束时p == t</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span>ltag == Link)                       <span class="comment">//当ltag = 0时循环到中序序列的第一个结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">printf</span>(&quot;%c &quot;, p-&gt;</span><span class="keyword">data</span>);                      <span class="comment">//显示结点数据，可以更改为其他对结点的操作</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">rtag</span> == Thread &amp;&amp; p-&gt;</span>rchild != t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;</span><br><span class="line">            <span class="function"><span class="title">printf</span>(&quot;%c &quot;, p-&gt;</span><span class="keyword">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;                         <span class="comment">//p进入其右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>结构体</title>
    <url>/post/6880.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="结构体的构成"><a class="markdownIt-Anchor" href="#结构体的构成"></a> 结构体的构成</h3>
<p>首先位于结构体中的元素在计算机也是对应存储的。而结构体的名字其实就可以看成是第一个变量的首地址。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内存中是这样的</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">| <span class="type">val</span> | <span class="type">c</span> | <span class="type">a</span>[<span class="number">0</span>] | <span class="type">a</span>[<span class="number">1</span>]</span><br><span class="line">p   p+<span class="number">4</span>   p+<span class="number">5</span>   p+<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>而变量在内存中的位置于定义时的位置是对应的</p>
<h3 id="字节对齐"><a class="markdownIt-Anchor" href="#字节对齐"></a> 字节对齐</h3>
<p>首先说明什么事字节对齐。它指的是变量在内存中的首地址是变量的长度的整数倍。</p>
<p>例如定义一个int型变量，那么这个变量首地址尽量要是4的整数倍。也就是地址最后两位一定为零，如果是long型，地址最后三位一定为零</p>
<p><strong>为什么要字节对齐？</strong></p>
<p>字节对齐可以加快访问数据的效率。原因是64位处理器数据总线是64位的，一次传过来8个字节的数据，所以如果我们是按8的整倍数进行存放，那么一定可以一次性取完，但是如果不是8的整倍数，例如int型首地址是6，那么就不可以一次性取完，要两次来取。而如果我们放在4这个位置，那么一定可以一次性取完。</p>
<p>此外例如首地址是2，这样也可以一次性取完，但是这样会造成空间浪费，因为现在不能再存int型了，可能会导致剩下4个字节都不能用。</p>
<p>对于x86系列，可以通过拼凑的方式把数据合起来。但是arm系列，如果没字节对齐，甚至会直接报错。</p>
<p>因此对于上面这个例子在c这个位置后面应该是p+8,为了让后面的整型保持对齐。而这多出的三个字节不会被使用（从此我们可以得出定义char型最好定义4个，不然多浪费）</p>
<p>此外，结构体的首地址的倍数由后面元素中占用空间最多的那个来决定。<strong>结尾的地址也要是占用空间最多的整倍数</strong>。结尾也要符合标准是为了便于用数组，因为数组的地址是连续的，所以每个的头和尾都要满足要求。</p>
<p>字节对齐还有利于结构体中元素的访问。我们之所以可以直接写a.data是因为每个元素在结构体中所占用的空间大小是一样的（考虑字节对齐），这样我们就可以像数组那样直接加上一个偏移量去访问。</p>
<p><strong>提示</strong>，为了节省空间，把相同类型的元素放到一块写，</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">|</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodeb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，第一种写法为保证字节对齐需要多消耗6字节的空间，而第二种写法只需要消耗两字节的空间。</p>
]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>网络</title>
    <url>/post/50daec4.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="aov网络"><a class="markdownIt-Anchor" href="#aov网络"></a> AOV网络</h3>
<p>aov网络指的是用顶点表示活动的网络。讲个例子吧</p>
<p>例如学习课程有个前后顺序，前面一门课没有学完后面一门课动不了手。这样就可以用顶点表示课程，然后用有向箭头表示学习的次序，这样就是一种AOV网络。并且显然每个点都要走，因为每门课都要学。</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C1.PNG" alt="后面这个数字代表先修课程" /><br />
<img src="/images/%E7%BD%91%E7%BB%9C2.PNG" alt="" /></p>
<p>检测有向环可以用对AOV网络构造拓扑序列。构造方法等会讲，如果有环，那么就会出现永远都有入度的情况，就说明有环。</p>
<p><strong>构造过程</strong></p>
<p>就拿上面一个图来说吧。必须先要学完c1，c2才可以学c3.学了c1又可以学c8，按照这样的顺序就可以得出学习顺序是C1C2C3C5C4C8C9C7C6。当然，还有许多其他的次序。</p>
<p>从中我们可以发现一个规律，假如每当我们学一门课就删去这些边，那么我们可以学习一个课程时入度一定为0.例如我们学完1和2后3入度就是0所以现在我们可以学了。如果入度不为0说明我们还有前置知识我们没有掌握，就不能学。</p>
<p>总结：找出入度为0的点，删去与之相邻的边，然后找新的入度为0的点，重复上述过程。</p>
<p>下面给出模板：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    int val;//边权</span><br><span class="line">    int <span class="built_in">last</span>;</span><br><span class="line">    edge* next;</span><br><span class="line">&#125;;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int insum;//入度</span><br><span class="line">    edge* <span class="built_in">first</span>;</span><br><span class="line">&#125;;</span><br><span class="line">node nod[<span class="number">100</span>];//随便设的数字，也可以<span class="built_in">new</span>来构建</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nod[i].<span class="built_in">first</span> = NULL;</span><br><span class="line">        nod[i].insum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void addedge(int <span class="built_in">sum</span>, int <span class="built_in">first</span>, int <span class="built_in">last</span>)</span><br><span class="line">&#123;</span><br><span class="line">    //用后插法</span><br><span class="line">    edge* temp = <span class="built_in">new</span> edge;//needfree</span><br><span class="line">    temp-&gt;val = <span class="built_in">sum</span>;</span><br><span class="line">    temp-&gt;<span class="built_in">last</span> = <span class="built_in">last</span>;</span><br><span class="line">    temp-&gt;next = nod[<span class="built_in">first</span>].<span class="built_in">first</span>;</span><br><span class="line">    nod[<span class="built_in">first</span>].<span class="built_in">first</span> = temp;</span><br><span class="line">    nod[<span class="built_in">last</span>].insum++;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">sum</span>, <span class="built_in">first</span>, <span class="built_in">last</span>;</span><br><span class="line">    node* tempnode;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;<span class="built_in">sum</span>&gt;&gt;<span class="built_in">first</span>&gt;&gt;<span class="built_in">last</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addedge(<span class="built_in">sum</span>, <span class="built_in">first</span>, <span class="built_in">last</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node* aovstack = <span class="built_in">new</span> node;//needfree,链栈，用来存放入度为<span class="number">0</span>的节点</span><br><span class="line">    int <span class="built_in">time</span> = <span class="number">0</span>;//记录栈中有多少元素</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nod[i].insum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tempnode = nod[i];</span><br><span class="line">            tempnode-&gt;<span class="built_in">first</span> = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">            aovstack-&gt;<span class="built_in">first</span> = tempnode;</span><br><span class="line">            <span class="built_in">time</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">time</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">time</span>--;</span><br><span class="line">        tempnode = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">        node* temp = aovstack;</span><br><span class="line">        aovstack = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">        <span class="built_in">delete</span> temp;</span><br><span class="line">        edge* tempedge = tempnode-&gt;<span class="built_in">first</span>;</span><br><span class="line">        <span class="keyword">while</span>(tempedge != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--nod[tempedge-&gt;<span class="built_in">last</span>].insum == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">time</span>++;</span><br><span class="line">                tempnode = nod[tempedge-&gt;<span class="built_in">last</span>];</span><br><span class="line">                tempnode-&gt;<span class="built_in">first</span> = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">                aovstack-&gt;<span class="built_in">first</span> = tempnode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/******************</span></span><br><span class="line"><span class="comment">            *output...</span></span><br><span class="line"><span class="comment">            ***************/</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***************</span></span><br><span class="line"><span class="comment">    * delete...</span></span><br><span class="line"><span class="comment">    *******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aoe网络"><a class="markdownIt-Anchor" href="#aoe网络"></a> AOE网络</h3>
<p>这个是用边表示活动，顶点表示事件。</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C3.PNG" alt="" /></p>
<p>这是一个AOE网络图，注意和上面类似这里每一条边都是要到的。我们要找的就是花费时间最长的那条路，因为那条路走完了所有活动才完成。那么这条路叫做关键路径，这条路径上的活动叫做关键活动。如果我们想缩短工期的时间，那么我们就要先缩短关键活动的时间。</p>
<p><strong>几个名词</strong></p>
<p>事件最早可能开始时间 ve(i)</p>
<p>事件最迟允许开始时间 vl(i)</p>
<p>活动最早可能开始时间 e[i]</p>
<p>活动最迟开始时间 l[i]</p>
<p><strong>所以关键活动就是 e[i] == l[i]</strong> ，因为最早时间和最晚时间相同说明耽误不得。</p>
<p><strong>求法</strong></p>
<p>代码比较简单，这里只讲一下思路。</p>
<p>同样使用邻接表。用四个数组分别表示上面四个名词。首先求前面两个。</p>
<p>事件最早时间这么多到那个点的路径中最晚的那个。例如上面的6点应该是40而不是30，因为只有最晚的那个完成了才能算真正到了那个点。</p>
<p>事件最晚开始时间要从后往前算。最后那个点的最晚开始时间我们一般是知道的，就是截至时间。然后往前面去减，如果有多条路径到那个点就选最小的。同样的道理因为所有边走完这件事才算做完了，如果你选大的相当于到最后那个点的所需时间少，结果这边走完了那个时间小的还没有走完。</p>
<p>举个例子：假设8点的截至时间是60，那么4点的截至时间应该是从8到7到5那一条。</p>
<p>活动最早开始时间是活动的起点的最早开始时间</p>
<p>活动的最晚开始时间是活动的终点的最晚开始时间减去这条边的权</p>
<p><img src="/images/aoe%E7%BD%91%E7%BB%9C.PNG" alt="" /></p>
<p>从这个代码中我们看出每个顶点遍历就可以了。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟内存</title>
    <url>/post/f79e4123.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1>
<p>我们在生成程序的时候，会发现每个程序的起始地址都是一样的，那么这种一样的地址怎么赋给实际的物理地址上的呢？这就要依靠虚拟内存机制了。</p>
<p>虚拟内存着力于解决进程间内存分配的问题，并且它还有一个作用是使进程之间相互隔绝。例如不小心产生了一个野指针指向了其他内存的位置，但是实际上却不会破坏其他程序而只会破坏自己的程序，这是因为虚拟内存限制了每个程序所使用的空间，如果超出限制就会报错。</p>
<p>程序中所使用的空间叫做虚拟空间，一共有2的n次方。而系统上有一个物理地址空间。虚拟内存做的其实是把虚拟空间上的内存地址映射到物理空间上。在cpu中，有一个叫MMU的部件专门做虚拟地址和物理地址转化。</p>
<h1 id="虚拟内存的组织形式"><a class="markdownIt-Anchor" href="#虚拟内存的组织形式"></a> 虚拟内存的组织形式</h1>
<p>虚拟内存中的内存其实是按页进行划分的。这类似与磁盘中的扇区概念，即使那个扇区中只有一个字节的数据，取数据时也是把一个扇区全取出来。</p>
<p>虚拟内存页的大小一般是4kb到2mb之间。而物理内存也是按页进行分块，并且块的大小和虚拟内存页的大小相同。</p>
<p>其实把程序加载到内存时也不是一股脑直接加载的，而是一块一块逐个加载，并且如果内存满了还有块替换策略，这实质上是把内存当做一级缓存使用。</p>
<p>虚拟页有三种情况：</p>
<ul>
<li>未分配的， 这部分内存就是虚拟内存预留出来的部分，例如malloc使用的空间，各个段之间预留出来的空间等。</li>
<li>缓存的， 就是加载到内存中的</li>
<li>未缓存的，是程序的组成部分但是还没有加载到内存中。</li>
</ul>
<p>由于磁盘访问速度过慢（比SRAM小100000倍），所以我们要尽可能的降低未命中率。第一个办法就是增大每一块的大小（所以才会有一块甚至到2mb，有的小程序都没这么大）。第二个办法是全相连。全相连可以极大降低冲突不命中概率。第三个是使用复杂的块替换策略，这和缓存不同，因为缓存和内存之间速度也就十倍差距，所以块替换策略越简单越好，但是内存与磁盘间不命中惩罚太大，大到情愿花一些时间来找那个最不可能被替换掉。最后是使用回写策略。 <a href="https://xinhecuican.github.io/post/7d1c86da.html">缓存</a></p>
<h2 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h2>
<p>页表是存放于物理内存中的，页表中中的内容代表虚拟内存中这片地址是否被使用，如果被使用，还要存放实际的物理地址。</p>
<p>页表的大小是由虚拟内存大小和页大小决定的。假设虚拟内存大小矢2的n次方，页大小矢2的p次方，那么页表就有2的n-p次方条。这实际上是一种以空间换时间的策略。每个进程都有一个页表。</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt="" /></p>
<p>上图中左边就是页表，右下角代表磁盘。页表中灰色代表未缓存，未缓存的地址就指向磁盘。而白色代表未分配，地址直接是NULL。如果我们访问0，因为0是未缓存并且内存已满，所以要替换一块下来，假设替换第四块，那么就要把页表中三的地址给改为内存中的物理地址并且把4的地址改为磁盘中的地址。</p>
<p>所以当我们访问内存时，如果访问到未加载的地址，那么会触发<a href="https://xinhecuican.github.io/post/28877bf.html#more">故障异常</a>,故障异常就会把磁盘中的内存加载进来并且重新执行这条指令。</p>
<p>如果我们加载到页表地址是NULL的地方，那么就会抛出segmentation fault。</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.PNG" alt="" /></p>
<p>通过页表，我们可以让物理内存彼此分离。并且还可以让两个进程数据共享，这也使动态库可能实现。</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.PNG" alt="" /></p>
<p>虚拟内存还提供了安全保护机制</p>
<p>这个是比较完整的页表，其中多了一些权限位。后面三个是读写和执行标志位，如果读的时候没有权限，那么就会抛出保护异常，这种异常一般都会终止程序。</p>
<p>第一个是模式标志位。有些操作系统专有的指令用户不能执行，有些专用寄存器用户不能访问。例如关机的指令即使用户特意编写也不会执行，因为它没有权限。</p>
<p>操作系统下的内存空间普通用户是没有办法去访问的。如果想调用操作系统的函数，可以使用陷阱异常，产生陷阱异常时，会转到特权模式。</p>
<h2 id="地址翻译"><a class="markdownIt-Anchor" href="#地址翻译"></a> 地址翻译</h2>
<p>首先虚拟地址的低p位是页内偏移，因为虚拟内存页的大小和实际内存页的大小相同，所以二者偏移量相同。虚拟地址高n-p位是页号。每一页的所包含的字节数是2<sup>p,而页表页号数目是2</sup>(n-p)</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%984.PNG" alt="" /></p>
<p>这张图表示了大致过程。cpu发出虚拟地址，mmu把地址解析成两部分（页号和页内偏移）。然后从内存中取出对应页号的地址（cpu中有页的基地址寄存器，页地址是根据页号* 每一个页表项的字节数+基地址得出）。然后mmu又根据取回来的页决定是否要去取内容。如果取，那么这个页中包含了物理页号，然后物理页号和偏移量直接合成得出实际地址。</p>
<p>如果标志位是0，那么还要到磁盘中去取出对应页放到内存中并且更新页表。</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%985.PNG" alt="" /></p>
<p>虚拟内存最大的问题就是显著增加了访问时间，本来只要访问一遍的现在要访问两遍。所以在mmu中又加了tlb寄存器专门用来存放页表。现在访问页表不用找内存了，直接找这个寄存器就可以了。如果没有找到再去内存中找并且更新tlb。</p>
<p>但是现代cpu都是多进程的。每个进程都有自己独立的页表，即使对应的内存相同可能标志位不同，也就是说每次更换进程都要把tlb清空一遍。一种解决办法是传给tlb页号的同时也传递一个进程信息，tlb也储存一个进程信息。</p>
<h2 id="多级页表"><a class="markdownIt-Anchor" href="#多级页表"></a> 多级页表</h2>
<p>假设虚拟内存大小是2的48次方，每页大小矢4kb，每个页表项8字节，那么页表大小矢2的39次方也就是512G。这在现实中显然是不可能实现的，所以要想办法把页表压缩。</p>
<p>我们很容易想到的一个办法是那些未分配的虚拟内存就不要建立页表项了，但是这样会带来一个问题。原来我们在查找页表的时候都是直接寻址，这是因为假设页表中每一项都存在，现在我们有一些项缺失了，直接根据页号查表的方法也就不行了，只有一个个比对，这样有增大了时间消耗。</p>
<p>我们可以建立一个多级页表，外层页表每一个页表项缓存的比较大，例如2mb甚至4Gb等，然后这一项中的内容不是物理页号，而是下一级页表的物理地址，之后下一级页表比上一级小，到最后一级就存储物理页号。</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.jpg" alt="" /></p>
<p>如上图，最外面一层就占着最高位，然后依次递减。这是因为一旦最外层选中了就说明最高几位是那几号，那么就不用管了。</p>
<p>这样看起来好像是用空间并没有减少，因为到最后一层还是要建立，并且中间几层还要额外消耗空间。实际上如果某个缓存块是未分配的，那么就不会建立下一级页表了。而外面几层页表锁包含的比较大，这样一下就可以排除几百个G的未分配空间。</p>
<h2 id="页替换策略"><a class="markdownIt-Anchor" href="#页替换策略"></a> 页替换策略</h2>
<ul>
<li>最优页替换策略(OPT)</li>
</ul>
<p>顾名思义，这种替换策略是最好的。它是将之后最少使用的页面替换出去，但是这种算法唯一的问题是他不可能被实现，可以作为一种理论判断依据<br />
<img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%9811.PNG" alt="" /><br />
当5进来时，因为1即将也要进来，那么即使替换了1那么很快他也要被替换进来，所以不选择1，同样也不选择3，所以替换2.</p>
<ul>
<li>先进先出策略</li>
</ul>
<p>这种策略就是维护一个队列，将最早使用的页面替换出去。但是这种算法性能很差，甚至比随机替换的效果还要差。因为最早使用的页面不一定不重要，他可能还是一直在被使用</p>
<ul>
<li>最近不使用（NRU）</li>
</ul>
<p>这种策略是设置一个标志位，如果最近一个时钟滴答（一般是10-30ms)中被使用，那么就把它置1。替换时替换那些标志位是0的。</p>
<ul>
<li>二次机会算法</li>
</ul>
<p>这是在先进先出算法上改进而来。它同样也有一个最近是否使用的标志位，如果这个标志位是1，那么就把它置0并且把它放到队尾，如果标志位是0那么就替换。</p>
<ul>
<li>时钟算法</li>
</ul>
<p>这其实就是二次机会算法,只是组织方式由队列变成了循环队列。这样如果这个位是1只需要让指针加1就可以了，相当于把它放到队尾。<br />
<img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%987.PNG" alt="" /></p>
<ul>
<li>最近最少使用（LRU）</li>
</ul>
<p>正如它的名字，就是将最近最少使用的页替换出来。它是除了最优页替换策略之外最好的算法，但是它几乎不可能实现。这里困难在于怎样定义最近和最少。为了定义它，产生了一系列近似策略</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%9812.PNG" alt="" />注意第二次出现1，他将1又放到了队首。</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%988.PNG" alt="" />.这种方法时如果访问该页面就将相应行置1，相应列置0.最后替换时选择0最多的行。</p>
<p>因为将这行置1就会让这一行的1变得最多，可以表明是最近访问。而置0会让其他行的0的数目增多，相当于离访问时间更长。</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%989.PNG" alt="" /></p>
<p>这种方法是将一个时钟滴答内访问过的页面最左边置1。到下次时钟滴答结束时全部右移一位，然后同样的方式置1.替换时只需选出值最小的替换即可。</p>
<p>要从左到右移位是为了保证最新一次更新的1产生的值是最大的，也就说明最近刚刚被访问。</p>
<ul>
<li>工作集替换算法</li>
</ul>
<p>工作集替换算法添加了一个该时钟滴答内是否访问的标志位和最近使用时间两个量。最近使用时间不是网络上的时间而是时钟时间（当然这影响不大）。这种算法开销大所以介绍它的时钟形式。</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%9810.PNG" alt="" /></p>
<blockquote>
<p>如果当前指针指向表项标志位是1，那么就将标志位置为0并且将时间更新为当前时间<br />
标志位是0并且时间差小于设定的最大时间就将它记录，如果没有比他更差的就替换它。<br />
时间差大于设定最大时间，那么就直接替换</p>
</blockquote>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>首先补充一下前面tlb结构。tlb也是一个缓存并且是组相联结构，这就代表着传递信息中必须要包含组号，然后剩余的是标志位。</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.jpg" alt="" /></p>
<p>上图中tlbi就是组号，前面的是标志位。mmu传给tlb的只有vpn。</p>
<p>先是cpu发出虚拟内存地址，然后mmu开始解析，解析处vpn传给tlb，如果tlb解析成功那么再传给mmu物理页号并与vpo合成成物理地址。之后在把物理地址发给缓存。按缓存的方式处理。</p>
<p>如果tlb未命中，那么会到内存系统（包括缓存）中用页表基地址寄存器（CR3）找到最外层的页表然后一层层解析找到物理页号，然后把页号发给mmu的同时缓存那一片区域给tlb。</p>
<p>如果内存系统中也没有命中（未缓存或者未分配），那么就出触发缺页异常，通过缺页异常判断是未分配还是未缓存还是其他情况。</p>
<p>缺页异常时判断与一个链表有关。我们知道虚拟内存时分为若干个段的，每个段都有起始地址和终止地址还有一些权限标志位，这个链表就是存放这些信息。当2发生缺页异常时，会判断这个地址是否是在这些段中，如果不在，那么直接抛出Segmentation Fault。如果在那么判断标志位，如果判断不成功会抛出保护异常，如果判断成功了然后再去磁盘中取数据。</p>
]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何基础</title>
    <url>/post/8050.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="判断两直线是否相交"><a class="markdownIt-Anchor" href="#判断两直线是否相交"></a> 判断两直线是否相交</h3>
<p>P(x1,y1) Q(x2,y2) 两向量的叉积为  x1<em>y2-x2</em>y1</p>
<p>如果 p*q&gt;0 p在q的顺时针方向</p>
<p>p*q&lt;0 p在q的逆时针方向</p>
<p>=0  ，共线或反向</p>
<p><img src="/images/20170428234108337.png" alt="" /></p>
<p>先做一次快速排斥实验，判断下一个线段中 x 较大的端点是否小于另一个线段中 x 较小的段点，若是，则说明两个线段必然没有交点，同理判断下 y</p>
<p>代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>x)&lt;min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>x)<span class="operator"> || </span>max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>y)&lt;min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>y) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">max(<span class="constructor">A</span>.x,<span class="constructor">B</span>.x)&lt;min(<span class="constructor">C</span>.x,<span class="constructor">D</span>.x) <span class="operator">||</span> max(<span class="constructor">A</span>.y,<span class="constructor">B</span>.y)&lt;min(<span class="constructor">C</span>.y,<span class="constructor">C</span>.y)</span></span><br></pre></td></tr></table></figure>
<p>如图所示，如果想判断两线段相交，只需要判断A 和 B在cd两侧即可</p>
<p>所以只需要 向量<code>AD*CD</code>与 BD*CD异号即可</p>
<p>如果端点正好在另一条线段上，两者乘积等于0</p>
<p>如果两者平行，叉积也为0但是可以在快速排斥实验中排除掉</p>
<p>总代码</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">struct Line &#123;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">x</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">double</span> y<span class="number">1</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">x</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">double</span> y<span class="number">2</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">bool intersection(const Line &amp;l<span class="number">1</span><span class="punctuation">,</span> const Line &amp;l<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    //快速排斥实验</span><br><span class="line">    if ((l<span class="number">1</span>.<span class="keyword">x</span><span class="number">1</span> &gt; l<span class="number">1</span>.<span class="keyword">x</span><span class="number">2</span> ? l<span class="number">1</span>.<span class="keyword">x</span><span class="number">1</span> : l<span class="number">1</span>.<span class="keyword">x</span><span class="number">2</span>) &lt; (l<span class="number">2</span>.<span class="keyword">x</span><span class="number">1</span> &lt; l<span class="number">2</span>.<span class="keyword">x</span><span class="number">2</span> ? l<span class="number">2</span>.<span class="keyword">x</span><span class="number">1</span> : l<span class="number">2</span>.<span class="keyword">x</span><span class="number">2</span>) ||</span><br><span class="line">        (l<span class="number">1</span>.y<span class="number">1</span> &gt; l<span class="number">1</span>.y<span class="number">2</span> ? l<span class="number">1</span>.y<span class="number">1</span> : l<span class="number">1</span>.y<span class="number">2</span>) &lt; (l<span class="number">2</span>.y<span class="number">1</span> &lt; l<span class="number">2</span>.y<span class="number">2</span> ? l<span class="number">2</span>.y<span class="number">1</span> : l<span class="number">2</span>.y<span class="number">2</span>) ||</span><br><span class="line">        (l<span class="number">2</span>.<span class="keyword">x</span><span class="number">1</span> &gt; l<span class="number">2</span>.<span class="keyword">x</span><span class="number">2</span> ? l<span class="number">2</span>.<span class="keyword">x</span><span class="number">1</span> : l<span class="number">2</span>.<span class="keyword">x</span><span class="number">2</span>) &lt; (l<span class="number">1</span>.<span class="keyword">x</span><span class="number">1</span> &lt; l<span class="number">1</span>.<span class="keyword">x</span><span class="number">2</span> ? l<span class="number">1</span>.<span class="keyword">x</span><span class="number">1</span> : l<span class="number">1</span>.<span class="keyword">x</span><span class="number">2</span>) ||</span><br><span class="line">        (l<span class="number">2</span>.y<span class="number">1</span> &gt; l<span class="number">2</span>.y<span class="number">2</span> ? l<span class="number">2</span>.y<span class="number">1</span> : l<span class="number">2</span>.y<span class="number">2</span>) &lt; (l<span class="number">1</span>.y<span class="number">1</span> &lt; l<span class="number">1</span>.y<span class="number">2</span> ? l<span class="number">1</span>.y<span class="number">1</span> : l<span class="number">1</span>.y<span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="keyword">false</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    //跨立实验</span><br><span class="line">    if ((((l<span class="number">1</span>.<span class="keyword">x</span><span class="number">1</span> - l<span class="number">2</span>.<span class="keyword">x</span><span class="number">1</span>)*(l<span class="number">2</span>.y<span class="number">2</span> - l<span class="number">2</span>.y<span class="number">1</span>) - (l<span class="number">1</span>.y<span class="number">1</span> - l<span class="number">2</span>.y<span class="number">1</span>)*(l<span class="number">2</span>.<span class="keyword">x</span><span class="number">2</span> - l<span class="number">2</span>.<span class="keyword">x</span><span class="number">1</span>))*</span><br><span class="line">        ((l<span class="number">1</span>.<span class="keyword">x</span><span class="number">2</span> - l<span class="number">2</span>.<span class="keyword">x</span><span class="number">1</span>)*(l<span class="number">2</span>.y<span class="number">2</span> - l<span class="number">2</span>.y<span class="number">1</span>) - (l<span class="number">1</span>.y<span class="number">2</span> - l<span class="number">2</span>.y<span class="number">1</span>)*(l<span class="number">2</span>.<span class="keyword">x</span><span class="number">2</span> - l<span class="number">2</span>.<span class="keyword">x</span><span class="number">1</span>))) &gt; <span class="number">0</span> ||</span><br><span class="line">        (((l<span class="number">2</span>.<span class="keyword">x</span><span class="number">1</span> - l<span class="number">1</span>.<span class="keyword">x</span><span class="number">1</span>)*(l<span class="number">1</span>.y<span class="number">2</span> - l<span class="number">1</span>.y<span class="number">1</span>) - (l<span class="number">2</span>.y<span class="number">1</span> - l<span class="number">1</span>.y<span class="number">1</span>)*(l<span class="number">1</span>.<span class="keyword">x</span><span class="number">2</span> - l<span class="number">1</span>.<span class="keyword">x</span><span class="number">1</span>))*</span><br><span class="line">        ((l<span class="number">2</span>.<span class="keyword">x</span><span class="number">2</span> - l<span class="number">1</span>.<span class="keyword">x</span><span class="number">1</span>)*(l<span class="number">1</span>.y<span class="number">2</span> - l<span class="number">1</span>.y<span class="number">1</span>) - (l<span class="number">2</span>.y<span class="number">2</span> - l<span class="number">1</span>.y<span class="number">1</span>)*(l<span class="number">1</span>.<span class="keyword">x</span><span class="number">2</span> - l<span class="number">1</span>.<span class="keyword">x</span><span class="number">1</span>))) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="keyword">false</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="keyword">true</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/HelloZEX/article/details/80880385">参考</a></p>
<h3 id="判断点是否在多边形内部"><a class="markdownIt-Anchor" href="#判断点是否在多边形内部"></a> 判断点是否在多边形内部</h3>
<p>我们先将横纵坐标存在一个数组内</p>
<p>第一步</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.<span class="symbol">x</span> &lt; minX || p.<span class="symbol">x</span> &gt; maxX || p.<span class="symbol">y</span> &lt; minY || p.<span class="symbol">y</span> &gt; maxY) &#123;</span><br><span class="line">     <span class="comment">// 这个测试都过不了。。。直接返回false；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个测试是画一个四边形</p>
<p>第二步， 这里我们就要讲一个定理了，以某一点为端点画一条射线，如果穿过图形次数为奇数次，则在图形内，如果是偶数次，在图形外</p>
<p>为了方便讨论，我们将以x轴正方向做一条射线</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pnpoly</span> <span class="params">(<span class="keyword">int</span> nvert, <span class="keyword">float</span> *vertx, <span class="keyword">float</span> *verty, <span class="keyword">float</span> testx, <span class="keyword">float</span> testy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = nvert<span class="number">-1</span>; i &lt; nvert; j = i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ( (verty[i]&gt;testy) != (verty[j]&gt;testy) ) &amp;&amp;</span><br><span class="line">(testx &lt; (vertx[j]-vertx[i]) * (testy-verty[i]) / (verty[j]-verty[i]) + vertx[i]) )</span><br><span class="line">            c = !c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nvert 是 顶点数量，testx和testy是顶点横纵坐标</p>
<p>第一段的意思是</p>
<p>verty[i] &lt;testy &lt; verty[j]</p>
<p>或者</p>
<p>verty[j] &lt;testy &lt; verty[i]</p>
<p>这段代码是用来粗略判断射线是否会经过该边的（没考虑反向和端点）</p>
<p>第二段是用来判断测试点是否在两点连线之下，这里用了斜率（移下项）</p>
<p>c=!c;是用来判断奇数次还是偶数次的</p>
<h3 id="多边形的面积"><a class="markdownIt-Anchor" href="#多边形的面积"></a> 多边形的面积</h3>
<p>s=pow(p*(p-a)<em>(p-b)</em>(p-c),0.5),p=(a+b+c)/2</p>
<p>凸多边形都可以通过划分变成三角形</p>
<h3 id="凸包"><a class="markdownIt-Anchor" href="#凸包"></a> 凸包</h3>
<p>用最少的点把给出的点全部包住</p>
<h4 id="andraw算法"><a class="markdownIt-Anchor" href="#andraw算法"></a> andraw算法</h4>
<p>把所有点按第一关键字x第二关键字y按从小到大排序，并且删除重复点，得到序列p1…pn</p>
<p>把p1 p2放入凸包中，凸包中的点用栈来保存</p>
<p>然后 p1p2和p2p3叉积，如果叉积大于0，则说明p1p2在p2p3右边，说明p3在内部，我们就不选，反之则把它拖入栈中并且要把p2拖出栈中</p>
<p>这样一直到pn算完成了一遍（下凸包），我们还要从pn反过来到p1（上凸包）,合起来就是完整的凸包</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y==b.y&amp;&amp;a.x&lt;b.x)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">xcross</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b,<span class="built_in">point</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);<span class="comment">//斜率</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">point</span> node[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node,node+n,cmp);</span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">0</span>; num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;xcross(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">        top--;</span><br><span class="line">        top++;</span><br><span class="line">        num[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> basic=top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;basic&amp;&amp;xcross(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">        top--;</span><br><span class="line">        top++;</span><br><span class="line">        num[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> s;</span><br><span class="line">    s=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=dis(node[num[i<span class="number">-1</span>]],node[num[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转卡壳"><a class="markdownIt-Anchor" href="#旋转卡壳"></a> 旋转卡壳</h3>
<p>旋转卡壳可以用来求凸包的直径，宽度，两个不相交凸包间最大距离和最小距离等</p>
<p>如果过凸包上的两个点可以画一对平行直线，使凸包上所有点都夹在两<br />
条平行线之间 || 落在平行线上，那么这两个点称为一对对踵点。</p>
<p><img src="/images/4429524-41118e7599b80fb5.webp" alt="" /><br />
其实简单来说就是用一对平行线“卡”住凸包进行旋转。<br />
被一对卡壳正好卡住的对应点对称为对踵点，对锺点的具体定义不好说，不过从图上还是比较好理解的。可以证明对鍾点的个数不超过3*n/2</p>
<p>卡壳有两种情况，第一种是一点对一点， 也就是上图中的</p>
<p><img src="/images/4429524-6d28ceac8cc2b711.webp" alt="" /></p>
<p>另一种是一边只有一点，另外一边有两个点</p>
<p>第二种情况中我们可以发现对鍾点到对应边的距离比其他的要大（不要问我为什么）</p>
<p>Step1：计算多边形 y 方向上的端点，称之为 ymin 和 ymax。</p>
<p>Step2：通过 ymin 和 ymax 构造两条水平切线，由于他们已经是一对对<br />
踵点，计算他们之间的距离并维护一个当前最大值。</p>
<p>Step3：同时旋转两条直线到其中一条与多边形的一条边重合。</p>
<p>Step4：一个新的对踵点对此时产生，计算新的距离，并和当前最大值进<br />
行比较，若大于当前最大值。则更新。</p>
<p>Step5：重复 Step3 和 Step4 的过程直到再次产生新的对踵点对。</p>
<p>Step6：输出最大直径的对踵点对。</p>
<p>听起来有点小麻烦，观察可以发现当平行线和多边形的一条边重合的时<br />
候最会产生一对新的对踵点<br />
这条边的两个端点和原来的点都可能更新最大值</p>
<p>不妨考虑找离每条边最远的点，显然，这条边的两个端点都和最远点是<br />
对踵点<br />
特殊情况，如果有两条边是平行的，必须考虑所有的对踵点。<br />
旋转卡壳的均摊复杂度 O(n)，但这个问题需要求凸包，复杂度是<br />
O(nlogn)</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">void solve2(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ymax=-1e5,ymin=1e5<span class="comment">;</span></span><br><span class="line">    <span class="keyword">int</span> ymaxidx,yminidx<span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">int</span> i=<span class="number">1</span><span class="comment">;i&lt;=num;i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if(<span class="number">ch</span>[i].y&gt;ymax)</span><br><span class="line">        &#123;</span><br><span class="line">            ymax=<span class="number">ch</span>[i].y<span class="comment">;</span></span><br><span class="line">            ymaxidx=i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="number">ch</span>[i].y&lt;ymin)</span><br><span class="line">        &#123;</span><br><span class="line">            ymin=<span class="number">ch</span>[i].y<span class="comment">;</span></span><br><span class="line">            yminidx=i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx])<span class="comment">;</span></span><br><span class="line">    <span class="number">ch</span>[num+<span class="number">1</span>]=<span class="number">ch</span>[<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">int</span> t=<span class="number">1</span><span class="comment">;t&lt;=num;t++,yminidx=yminidx%num+1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        while(xmult(<span class="number">ch</span>[yminidx+<span class="number">1</span>],<span class="number">ch</span>[ymaxidx+<span class="number">1</span>],<span class="number">ch</span>[yminidx])&gt;xmult(<span class="number">ch</span>[yminidx+<span class="number">1</span>],<span class="number">ch</span>[ymaxidx],<span class="number">ch</span>[yminidx]))ymaxidx=ymaxidx%num+<span class="number">1</span><span class="comment">;</span></span><br><span class="line">        ans=max(ans,dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx]))<span class="comment">;</span></span><br><span class="line">        ans=max(ans,dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx+<span class="number">1</span>]))<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>,ans)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>贪心与k-优化</title>
    <url>/post/34811d5f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="引例"><a class="markdownIt-Anchor" href="#引例"></a> 引例</h1>
<p><strong>活动选择问题</strong></p>
<p>假设n个活动集合S，这些活动使用同一个资源。这个资源在某一时刻只能供一个活动使用，每个活动都有一个开始时间和一个结束时间。 我们想选出时间不重叠的数量最多的活动集（假设活动按照结束时间单调递增排序）。</p>
<p>这个问题可以写出最优解的表达式但是求解的时候比较麻烦。</p>
<p>我们是否可以这样考虑，我们每次都挑选最早结束的活动，这样就算有活动比他早开始，但是因为比他晚结束，所以同样是一个活动还是早结束的活动更优。</p>
<p>代码比较简单，就不打了</p>
<h1 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h1>
<p>性质： 我们通过局部最优解构造全局最优解。也就是我们可以考虑当前问题最优的选择，而不比考虑子问题的解。</p>
<p>如果一个问题最优解包含子问题最优解，称此问题有最优子结构性质。</p>
<p>每个小问题的解可由贪心选择获得，则称这个问题具有贪心选择性质。</p>
<h1 id="k-优化算法"><a class="markdownIt-Anchor" href="#k-优化算法"></a> k-优化算法</h1>
<blockquote>
<p>这里的k-优化是拿背包问题进行说明的，其他某些问题也可以使用。</p>
</blockquote>
<p>大致过程：</p>
<ul>
<li>首先按密度进行排序</li>
</ul>
<ol>
<li>先拿取k件物品，如果重量大于背包重量c，则放弃这个选择（具体请看下面例子）</li>
<li>对其余物品使用贪心算法</li>
<li>进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>次上述过程找出贪心最优解</li>
</ol>
<p>k-优化算法的优点是它将贪心算法与最优算法的偏差限定在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（如果没有这个限制可能会导致最优算法结果是100，而贪心算法结果是6的情况）</p>
<p>它的复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">n^{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>。每次贪心选择要O(n)复杂度，一共进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>次</p>
<p>例：</p>
<p><img src="/images/%E8%B4%AA%E5%BF%831.PNG" alt="" /></p>
<p>c=50, 如果使用2优化，我们可以</p>
<ul>
<li>先取1、2，对其他物品再使用贪心，可以得到1、2、4，价值为190</li>
<li>先取1、3， 可以得到1、3、4，价值为210</li>
<li>先取1、4， 可以得到1、2、4</li>
<li>先取1、5， 可以得到1、2、5， 价值为200</li>
<li>先取2、3 …</li>
</ul>
<h1 id="多机调度问题"><a class="markdownIt-Anchor" href="#多机调度问题"></a> 多机调度问题</h1>
<p>设有n个独立的作业{1, 2, …, n}, 由m台相同的机器进行加工处理。<br />
作业i所需的处理时间为ti。现约定，每个作业均可在任何一台机<br />
器上加工处理，但未完工前不允许终端处理。作业不能拆分成更<br />
小的子作业。</p>
<p>求完成这些任务所需要的最短时间。</p>
<p>我们要想办法让分到m台机器上的时间尽可能平均，这样最后完成时间也会最短。因此我们可以按照时间排序，先把时间长的运行，之后再用时间短的进行填补<br />
<img src="/images/%E8%B4%AA%E5%BF%832.PNG" alt="" /></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> machine[NR_MACHINE];</span><br><span class="line"><span class="built_in">int</span> get_min_time(<span class="built_in">int</span> <span class="built_in">time</span>[], <span class="built_in">int</span> <span class="built_in">n</span>, <span class="built_in">int</span> machine_num)</span><br><span class="line">&#123;</span><br><span class="line">	quick_sort(<span class="built_in">time</span>, <span class="number">0</span>, <span class="built_in">n</span>-<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">if</span>(machine_num &gt;= <span class="built_in">n</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       return <span class="built_in">time</span>[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   priority_queue &lt;<span class="built_in">int</span>,vector&lt;<span class="built_in">int</span>&gt;,greater&lt;<span class="built_in">int</span>&gt; &gt; q;</span><br><span class="line">   for(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;machine_num; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       q.push(<span class="built_in">time</span>[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   for(<span class="built_in">int</span> i=machine_num; i&lt;<span class="built_in">n</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">int</span> temp = q.top();</span><br><span class="line">       q.pop();</span><br><span class="line">       q.push(temp+<span class="built_in">time</span>[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="primkruskal-dijkstra"><a class="markdownIt-Anchor" href="#primkruskal-dijkstra"></a> prim,kruskal, dijkstra</h1>
<p><a href="https://xinhecuican.github.io/post/15201.html">这三个算法可以看这</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>进程和作业控制</title>
    <url>/post/31a6b40.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>进程就是加载到内存中准备执行的程序。当进程创建的时候，内核赋予了唯一的标识号，这个标识号叫做进程ID或PID。</p>
<p>进程同一时间内可达数百个之多，为了管理这么多的进程。系统提供了一个调度器来维护。调度器维护一个所有进程的列表，每次选择一个进程（实际上可以一次选择多个进程），然后执行一个短暂的时间（时间片）。</p>
<p>典型的时间片是10毫秒。为了为了下一个时间片还可以顺利的执行，系统必须要保存下一条指令的位置，环境的副本等。</p>
<h3 id="进程分叉到死亡"><a class="markdownIt-Anchor" href="#进程分叉到死亡"></a> 进程分叉到死亡</h3>
<p>当进程需要使用内核的服务时，会使用<strong>系统调用</strong>发送请求。在编写程序时，系统调用的使用方法取决于语言。例如，c语言使用标准库中的函数进行调用。</p>
<p>下面列举一些常见的系统调用函数</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>进程控制</strong></td>
<td></td>
</tr>
<tr>
<td>fork</td>
<td>创建当前进程的一个副本</td>
</tr>
<tr>
<td>wait</td>
<td>等待另一个程序结束后执行（强制暂停当前进程）</td>
</tr>
<tr>
<td>exec</td>
<td>在当前进程中执行一个新进程</td>
</tr>
<tr>
<td>exit</td>
<td>中止当前进程</td>
</tr>
<tr>
<td>kill</td>
<td>杀死子进程</td>
</tr>
<tr>
<td><strong>文件I/O</strong></td>
<td></td>
</tr>
<tr>
<td>open</td>
<td>打开一个用于读取或写入的文件</td>
</tr>
<tr>
<td>read</td>
<td>从文件中读取数据</td>
</tr>
<tr>
<td>write</td>
<td>向文件中写入了数据</td>
</tr>
<tr>
<td>close</td>
<td>关闭文件</td>
</tr>
</tbody>
</table>
<p>fork打开的一个新进程叫做当前进程的子女，当前进程是新进程的双亲。</p>
<p>例如，shell打开内部命令时首先就要调用fork创建一个新进程，当子进程结束时会调用exit释放资源，被杀死的进程叫做僵进程。但是进程表中却仍然保存子进程的数据，因为父进程可能需要这些数据。。</p>
<p>当子进程创建时，父进程停止运行，等到子进程被杀死之后，父进程先看一眼进程表中子进程的数据，然后开始运行，与此同时，子进程从进程表中被销毁。</p>
<h3 id="孤儿进程父进程子进程"><a class="markdownIt-Anchor" href="#孤儿进程父进程子进程"></a> 孤儿进程，父进程，子进程</h3>
<p>孤儿进程指的是父进程意外死亡，这时只有子进程。所以当子进程结束时，因为没有人来接受它，会一直留在进程表中，直到系统结束才会死亡。</p>
<p>当然，现代系统没有这么傻。孤儿进程会自动被init进程收养，通过这种方式，每当产生孤儿进程时，都会迅速的被init进程销毁。</p>
<p>除了父进程意外死亡外子进程也可能一直不死，这种情况一般是程序出现bug无法正常退出时产生的，这个程序会一直消耗系统资源。kill可以解决这种问题。kill会杀死父进程然后让init进程托管，在适当的时候会杀死子进程（我估计是一定时间，猜测）。</p>
<p>关于父进程，fork创建一个和父进程一模一样的副本，那么这时如何知道谁是父进程，谁是子进程呢？其实fork创建子进程完成之后会返回给父进程和子进程一个值，子进程返回值是零，父进程返回值大于零。如果某个进程得到了零，那么他就会开始工作，得到大于零的就会停止工作（通过wait使自己暂停）</p>
<h3 id="init-第一个进程"><a class="markdownIt-Anchor" href="#init-第一个进程"></a> init 第一个进程</h3>
<p>假设进程是通过分叉创建的，那么除第一个进程外的进程一定会有父进程，也一定会有第一个进程。</p>
<p>实际上也是这样，Linux在启动时会创建一个特殊的进程，PID是0，这个进程叫做空闲进程。</p>
<p>在进行了一些操作之后，0号进程开始分叉创建1号进程。之后0号进程就会死亡，然后由1号进程进行剩余的初始化步骤，例如进行多次分叉创建其他进程。因为 他要执行初始化步骤，所以叫初始化进程，也就是init进程。</p>
<h3 id="前台和后台进程"><a class="markdownIt-Anchor" href="#前台和后台进程"></a> 前台和后台进程</h3>
<p>前台进程就是当前需要我们交互的进程，后台进程就是自己跑的进程。</p>
<p>例如： sort &lt; temp &gt; temp2 &amp;。后面的与符号就是让程序自己去后面跑，这时我们就可以直接使用shell了。</p>
<p>但是后台进程不能从标准输入中读取，可以输出到标准输出中，这就带来一个问题。如果这个程序需要输入但是你却把它划分成后台程序，那么他会一直等待输入。</p>
<h3 id="sleep-创建延迟"><a class="markdownIt-Anchor" href="#sleep-创建延迟"></a> sleep 创建延迟</h3>
<p>语法： sleep interval [s | m | h | d ]</p>
<p>interval是时间间隔，后面是单位，默认是秒。</p>
<p>例如 sleep 5 表示中断5秒。</p>
<h3 id="作业控制"><a class="markdownIt-Anchor" href="#作业控制"></a> 作业控制</h3>
<p>作业就是每一条输入的指令，该作业有一个唯一的作业号来标识。作业控制就是对输入的指令进行调控。常见的作业控制命令如下表。</p>
<table>
<thead>
<tr>
<th>作业控制命令</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>jobs</td>
<td>显示作业列表</td>
</tr>
<tr>
<td>ps</td>
<td>显示进程列表</td>
</tr>
<tr>
<td>fg</td>
<td>将作业移至前台</td>
</tr>
<tr>
<td>bg</td>
<td>将作业移至后台</td>
</tr>
<tr>
<td>suspend</td>
<td>挂起当前shell</td>
</tr>
<tr>
<td>^Z</td>
<td>挂起当前前台作业</td>
</tr>
<tr>
<td>kill</td>
<td>终止作业</td>
</tr>
<tr>
<td>suspend</td>
<td>挂起shell，例如超级用户暂时返回普通用户</td>
</tr>
</tbody>
</table>
<p>echo $$ 显示当前shell的PID</p>
<p>echo $! 显示上一条移至后台的PID</p>
<p>stty tostop 挂起试图向终端写数据的后台作业</p>
<p>set -o monitor 允许作业控制</p>
<p>set -o notify 当后台作业结束时立刻通报</p>
<h3 id="在后台运行作业"><a class="markdownIt-Anchor" href="#在后台运行作业"></a> 在后台运行作业</h3>
<p>为了在后台运行作业，需要在命令的最后加一个&amp;符号。</p>
<p>每次在后台运行作业时，系统都会自动分配一个作业号，从1开始，依次向后增加。</p>
<p>每次后台作业完成时，都会向终端发送一个信息表示已经完成。</p>
<h3 id="fg-将作业移至前台"><a class="markdownIt-Anchor" href="#fg-将作业移至前台"></a> fg 将作业移至前台</h3>
<p>挂起可能令人有些误解，其实就是暂停程序。可以用fg将挂起的作业恢复。</p>
<p>例如当你用vi编辑一个文件时，突然忘了某些东西想通过man查一下，可以先用ctrl+Z把vi挂起，然后查找，查找完了之后又用fg命令将vi唤醒。</p>
<p>如果有挂起的程序那么关机时系统会给你提示，你可以选择关机或者先把挂起的程序移至前台。</p>
<p>语法： fg %[job]</p>
<p>fg %%代表唤起当前进程。因为一般进程挂起后都是运行别的进程，运行完了才又唤醒进程，此时挂起的进程又成了最前面的进程。</p>
<p>后面的job是作业编号，可以通过jobs程序查看。</p>
<p>bg和fg大致相同。</p>
<h3 id="ps程序"><a class="markdownIt-Anchor" href="#ps程序"></a> ps程序</h3>
<p>ps程序是用来显示进程状态的</p>
<p>语法： ps [-aefFly] [-p pid] [-u userid]</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ps</span> 显示与当前用户标识和终端相关的进程</span><br><span class="line"><span class="built_in">ps</span> <span class="literal">-a</span> 所有与用户标识进程与终端相关的非守护进程</span><br><span class="line"><span class="built_in">ps</span> <span class="literal">-e</span> 所有进程</span><br><span class="line"><span class="built_in">ps</span> <span class="literal">-p</span> pid 显示指定pid的进程</span><br><span class="line"><span class="built_in">ps</span> <span class="literal">-u</span> userid 显示指定userid的进程</span><br><span class="line"><span class="built_in">ps</span> <span class="literal">-ef</span> 显示所有用户的进程，完整输出</span><br><span class="line"><span class="built_in">ps</span> <span class="literal">-t</span> 显示所有守护进程</span><br></pre></td></tr></table></figure>
<p>下面列举了ps输出时的标题和所代表的含义</p>
<table>
<thead>
<tr>
<th>标题</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADDR</td>
<td>进程表中虚拟地址</td>
</tr>
<tr>
<td>C</td>
<td>处理器利用率</td>
</tr>
<tr>
<td>CMD</td>
<td>命令名称</td>
</tr>
<tr>
<td>F</td>
<td>进程相关的标志</td>
</tr>
<tr>
<td>NI</td>
<td>nice值，用于设置优先级</td>
</tr>
<tr>
<td>PID</td>
<td>进程ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程ID</td>
</tr>
<tr>
<td>PRI</td>
<td>优先级（大数字 = 小优先级 ）</td>
</tr>
<tr>
<td>RSS</td>
<td>内存预留空间大小</td>
</tr>
<tr>
<td>S</td>
<td>状态代码（D,R,S,T,Z）</td>
</tr>
<tr>
<td>STIME</td>
<td>累计系统时间</td>
</tr>
<tr>
<td>SZ</td>
<td>物理页大小</td>
</tr>
<tr>
<td>TIME</td>
<td>累计cpu时间</td>
</tr>
<tr>
<td>TTY</td>
<td>控制终端完整名称</td>
</tr>
<tr>
<td>UID</td>
<td>用户标识</td>
</tr>
<tr>
<td>WCHAN</td>
<td>等待通道</td>
</tr>
</tbody>
</table>
<p>状态代码</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="built_in">D</span> 不可中断睡眠，等待事件结束</span><br><span class="line"><span class="built_in">I</span> 空闲，超过<span class="number">20</span><span class="variable">s</span>的睡眠</span><br><span class="line"><span class="variable">R</span> 正在运行或者可运行（可运行是在运行队列中等待）</span><br><span class="line"><span class="variable">S</span> 可中断睡眠，等待时间结束</span><br><span class="line"><span class="variable">T</span> 挂起</span><br><span class="line"><span class="variable">Z</span> 僵进程</span><br></pre></td></tr></table></figure>
<p>-ly 显示状态代码</p>
<h3 id="监视系统进程"><a class="markdownIt-Anchor" href="#监视系统进程"></a> 监视系统进程</h3>
<p>语法： top [-d delay] [-n count] [p pid[,pid]…]</p>
<p>top的作用是动态显示进程信息。</p>
<p>-d 每隔多少秒刷新一次</p>
<p>-n 只在特定的时间进行刷新</p>
<p>-p 对某几个进程进行监视</p>
<h3 id="显示进程树"><a class="markdownIt-Anchor" href="#显示进程树"></a> 显示进程树</h3>
<p>语法： pstree [-aAcGnpu] [pid | userid]</p>
<p>作用：因为进程几乎都是通过分叉产生的，所以这个作用是显示进程之间的关系（即谁是父进程谁是子进程）。</p>
<p>具体的可以去看联机手册</p>
<h3 id="kill-杀死进程向进程发送信号"><a class="markdownIt-Anchor" href="#kill-杀死进程向进程发送信号"></a> kill 杀死进程，向进程发送信号</h3>
<p>语法： kill [-signal] pid… | jobid…</p>
<table>
<thead>
<tr>
<th>signal</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>中止，注销或终端失去连接时发送给进程</td>
</tr>
<tr>
<td>2</td>
<td>中断，按下^C时发送</td>
</tr>
<tr>
<td>9</td>
<td>杀死，立刻杀死，进程不能捕获</td>
</tr>
<tr>
<td>15</td>
<td>终止，请求终止，进程不能捕获</td>
</tr>
<tr>
<td>18</td>
<td>继续，恢复挂起的进程，由fg或bg发送</td>
</tr>
<tr>
<td>19</td>
<td>停止（挂起），按^Z发送</td>
</tr>
</tbody>
</table>
<h3 id="设置进程优先级-nicerenice"><a class="markdownIt-Anchor" href="#设置进程优先级-nicerenice"></a> 设置进程优先级 nice，renice</h3>
<p>优先级决定了你能享有的系统资源。nice程序用于设定优先级。</p>
<p>语法： nice [-n adjustment] command</p>
<p>使用nice时要注意，只能对外部程序例如软件和自己写的程序设置优先级，系统内部命令不能设定优先级。其次，一般只对后台程序降低优先级，对前台程序降低优先级是自己找罪受。</p>
<p>不使用nice时优先级是0，使用nice默认的优先级是10，数字越大优先级越低，最大可以设到20，最小可以设到-20.当设负数的时候是提高优先级。</p>
<p><strong>renice</strong>重新设置优先级。</p>
<p>语法： renice niceness -p processid</p>
<p>niceness是nice值，processid是进程ID。</p>
<p>niec程序是在程序开始运行时确定的，使用nice程序后command程序便开始运行。而renice是对已运行的程序重新设置优先级。</p>
<h3 id="守护进程"><a class="markdownIt-Anchor" href="#守护进程"></a> 守护进程</h3>
<p>很多程序并不是由用户运行的，由系统运行的程序就是守护程序。相当于windows中的服务程序。这些程序不受终端控制</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>进程的储存和缓冲区溢出</title>
    <url>/post/27045.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="用户空间"><a class="markdownIt-Anchor" href="#用户空间"></a> 用户空间</h3>
<p>用户空间是用户可以使用的空间，与之对应的是内核空间，这是系统所使用的空间。用户空间的大小有2的48次方，远远超出了内存的大小。</p>
<p>用户空间主要分为四个区域：</p>
<ul>
<li>栈，栈位于用户空间的最高处，从高处向低处生长。linux系统中栈空间大小是8MB</li>
<li>堆， 用于存放一些动态分配的数据</li>
<li>数据， 用来存放全局变量，静态变量，字符串常量</li>
<li>代码， 存放指令和共享库</li>
</ul>
<p>在Linux中，对于大小小于某一阈值的数据，在堆中分配时是从低地址向高地址生长。反之，从高地址向低地址生长</p>
<h3 id="缓冲区溢出"><a class="markdownIt-Anchor" href="#缓冲区溢出"></a> 缓冲区溢出</h3>
<p>常见原因： 申请了一个数组但是访问时越界。</p>
<p>我们可以把数组叫做缓冲区，超出边界就是缓冲区溢出。</p>
<p>常见表现，对于输入的字符串没有进行长度检查直接赋值。如果缓冲区分配在栈中，就有可能造成栈中数据的破坏。如果造成了返回地址的破坏，可能直接导致程序的崩溃。这种错误叫做 segmentation fault</p>
<p>这里便可以被黑客利用，先故意把返回地址破坏了并且让返回地址到他自己写的程序上，这样retq时就可以调用自己写的程序。这种方法叫做注入。一般注入的数据有三部分，第一部分是恶意的指令。第二部分是占位数据，这部分数据没什么含义，只是和指令加起来正好到返回地址处，第三部分就是篡改的地址，篡改后的地址指向缓冲区底部即恶意指令所在的地方。</p>
<h3 id="防御代码注入攻击"><a class="markdownIt-Anchor" href="#防御代码注入攻击"></a> 防御代码注入攻击</h3>
<ul>
<li>程序员：不要使用不安全的函数</li>
<li>系统： 栈基地址随机化分配。设置可执行权限位（就是设置一些地方的bit只能当做数据而不能当做指令）</li>
<li>编译器： 添加栈破坏检测。通过添加金丝雀值（canary value），位于当前栈帧底部。如果金丝雀值被破坏，那么就终止程序。</li>
</ul>
]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器支持的运算</title>
    <url>/post/37318.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前写搜狗在线测试题目的时候，曾经想遍历一个set遍历。当时是这样写的。</p>
<p>set<int>::iterator b = a.begin()+1</p>
<p>后来发现程序报错。究其原因是，set迭代器不支持加减数操作。<br />
查看了一下维基百科，下面是有关说明。</p>
<p>1.所有迭代器都应该实现自增算符：iter++,++iter</p>
<p>2.Bidirectional迭代器：是在前向迭代器的基础上，多了单步向后遍历的能力。也就是–iter,iter–。</p>
<p>3.Random Access迭代器：在双向迭代器基础上，具有直接访问各数据元素的能力。随机迭代器增加了“迭代器算术运算”：</p>
<p>iter+=i 迭代器递增i位</p>
<p>iter-=i 迭代器递减i位</p>
<p>iter+i 加i位后的迭代器</p>
<p>iter-i 减i位后的迭代器</p>
<p>iter[i] 加i位后的迭代器的解引用</p>
<p>iter&lt;iter1 如果迭代器iter的位置在iter1前，返回true，否则返回false</p>
<p>iter&lt;=iter1 如果iter的位置在iter1的前面或同一位置时返回true，否则返回false</p>
<p>iter&gt;iter1 如果迭代器iter的位置在iter1后，返回true，否则返回false</p>
<p>iter&gt;=iter1 如果iter的位置在iter1的后面或同一位置时返回true，否则返回false</p>
<p>4.在STL定义的容器中，string，vector与deque提供了随机访问迭代器，list、set、multiset、map、multimap提供了双向迭代器。</p>
<p>————————————————</p>
<p>版权声明：本文为CSDN博主「ShenYounger」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br />
原文链接：<a href="https://blog.csdn.net/wusecaiyun/article/details/49563197">https://blog.csdn.net/wusecaiyun/article/details/49563197</a></p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>队列</title>
    <url>/post/26671.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="队列基础"><a class="markdownIt-Anchor" href="#队列基础"></a> 队列基础</h3>
<p>队列是一种线性结构，有队头（front）队尾（rear）两个指针，每次拉进来一个元素会让队尾加一，而每次删除一个元素会让队头加一，这是一种先进先出的结构。</p>
<p>队列特殊情况判断</p>
<p>空队列 front=rear</p>
<p>满队列 rear-front=N（N指的是开的数组的大小）</p>
<p>POP 从队头删元素</p>
<p>push 拉元素到队尾</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">duilie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> front ,rear;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        front=rear=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front)==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear-front==N<span class="number">-1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(full())<span class="comment">//如果满了就不能拖进去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[++rear]=key;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="循环队列"><a class="markdownIt-Anchor" href="#循环队列"></a> 循环队列</h3>
<p>上面一种队列并不是真的有n个空间，如果pop了元素那空间就要减小，这样便浪费了许多空间，而用模运算组成一个循环可以使空间充分利用</p>
<p>特殊情况判断</p>
<p>空 ： front=rear</p>
<p>满 ：（ rear+1）% N=front</p>
<p>代码实现</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const <span class="built_in">int</span> Queue_Size=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">typedef <span class="keyword">struct</span> circlQueue</span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> *elem;</span><br><span class="line">       <span class="built_in">int</span> rear;</span><br><span class="line">       <span class="built_in">int</span> front;</span><br><span class="line">       <span class="built_in">int</span> queueSize;</span><br><span class="line">&#125;circlQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">void init<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem=<span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[Q<span class="identifier">ueue_Size</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;<span class="comment">//首尾指针相等说明队列为空。</span></span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=Queue_Size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*销毁队列*/</span></span><br><span class="line">void destroy<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       delete <span class="literal">[]</span><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*求队列的长度*/</span></span><br><span class="line"><span class="built_in">int</span>  length<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">int</span> length;</span><br><span class="line">       length=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear-<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;<span class="comment">/*一般情况下，rear在front的上方，此种算法是用于</span></span><br><span class="line"><span class="comment">  rear已到front的下方，即已出现假溢出的情况。*/</span></span><br><span class="line">       return length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*入队列*/</span></span><br><span class="line">void enter<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q,<span class="params">char</span> <span class="params">x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span>(((<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)<span class="comment">//判断栈满的情况</span></span><br><span class="line">              cout&lt;&lt;<span class="string">&quot;Queue OverFlow!&quot;</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">rear</span>]</span>=x;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%Queue_Size;<span class="comment">//尾指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="built_in">char</span> output<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> e;</span><br><span class="line">       <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)</span><br><span class="line">              cout&lt;&lt;<span class="string">&quot;Queue Empty&quot;</span>;</span><br><span class="line">       e=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">front</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;;<span class="comment">//头指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">       return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「hackerain」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/hackerain/article/details/5934240</span></span><br></pre></td></tr></table></figure>
<h3 id="队列的函数"><a class="markdownIt-Anchor" href="#队列的函数"></a> 队列的函数</h3>
<p>push()：脱元素到队尾</p>
<p>pop()删队首元素</p>
<p>size()</p>
<p>front()返回队首元素</p>
<p>back()返回队尾元素</p>
<h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4>
<p>front无法使用迭代器，因为queue在物理地址上不连续，所以queue无法遍历，想要遍历只能不停top POP，这样会销毁队列</p>
<h3 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h3>
<ul>
<li>HDU 1387</li>
</ul>
<p>Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.<br />
In a team queue each element belongs to a team. If an element enters the queue, it first searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.</p>
<p>Your task is to write a program that simulates such a team queue.</p>
<p>Input</p>
<p>The input will contain one or more test cases. Each test case begins with the number of teams t (1&lt;=t&lt;=1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0 - 999999. A team may consist of up to 1000 elements.</p>
<p>Finally, a list of commands follows. There are three different kinds of commands:</p>
<p>ENQUEUE x - enter element x into the team queue<br />
DEQUEUE - process the first element and remove it from the queue<br />
STOP - end of test case<br />
The input will be terminated by a value of 0 for t.</p>
<p>Output</p>
<p>For each test case, first print a line saying “Scenario #k”, where k is the number of the test case. Then, for each DEQUEUE command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Sample</span> Input</span><br><span class="line"></span><br><span class="line"><span class="attribute">2</span></span><br><span class="line"><span class="attribute">3</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line"><span class="attribute">3</span> <span class="number">201</span> <span class="number">202</span> <span class="number">203</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">101</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">201</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">102</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">202</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">103</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">203</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">STOP</span></span><br><span class="line"><span class="attribute">2</span></span><br><span class="line"><span class="attribute">5</span> <span class="number">259001</span> <span class="number">259002</span> <span class="number">259003</span> <span class="number">259004</span> <span class="number">259005</span></span><br><span class="line"><span class="attribute">6</span> <span class="number">260001</span> <span class="number">260002</span> <span class="number">260003</span> <span class="number">260004</span> <span class="number">260005</span> <span class="number">260006</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">259001</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">260001</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">259002</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">259003</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">259004</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">259005</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">260002</span></span><br><span class="line"><span class="attribute">ENQUEUE</span> <span class="number">260003</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">DEQUEUE</span></span><br><span class="line"><span class="attribute">STOP</span></span><br><span class="line"><span class="attribute">0</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Sample</span> Output</span><br><span class="line"></span><br><span class="line"><span class="attribute">Scenario</span> #<span class="number">1</span></span><br><span class="line"><span class="attribute">101</span></span><br><span class="line"><span class="attribute">102</span></span><br><span class="line"><span class="attribute">103</span></span><br><span class="line"><span class="attribute">201</span></span><br><span class="line"><span class="attribute">202</span></span><br><span class="line"><span class="attribute">203</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Scenario</span> #<span class="number">2</span></span><br><span class="line"><span class="attribute">259001</span></span><br><span class="line"><span class="attribute">259002</span></span><br><span class="line"><span class="attribute">259003</span></span><br><span class="line"><span class="attribute">259004</span></span><br><span class="line"><span class="attribute">259005</span></span><br><span class="line"><span class="attribute">260001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title> 链式前向星</title>
    <url>/post/8072.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>静态链表（链式前向星）是表示图的另外一种方法</p>
<h3 id="前向星"><a class="markdownIt-Anchor" href="#前向星"></a> 前向星</h3>
<p>前向星也称为邻接数组</p>
<p>例 <img src="/images/static_linked_list_example.svg" alt="" /></p>
<p>总共有这几条边</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>现在将这些边按从小到大排序，变成</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>) --|<span class="type"></span></span><br><span class="line"><span class="type">(1</span>, <span class="number">3</span>) --| <span class="type">=&gt; len</span>[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>) --|<span class="type"></span></span><br><span class="line"><span class="type">(2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>) =&gt; head[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>然后再将数据填入三个数组中，分别是</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">es</span><span class="selector-attr">[]</span> 这个数组是用来记录每条边的终点的，而因为前面已经排好了序，起点很容易知道</span><br><span class="line"><span class="selector-tag">head</span><span class="selector-attr">[]</span> 记录以<span class="selector-tag">i</span>为起点的边在数组中的第一个位置</span><br><span class="line"><span class="selector-tag">len</span><span class="selector-attr">[]</span> 记录以<span class="selector-tag">i</span>为起点的边有多少</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Array</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>es</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>2</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>head</td>
<td>1</td>
<td>4</td>
<td>5</td>
<td>7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>len</td>
<td>3</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>head[2]=4表示2为起点的第一条边在es中的位置为4</p>
<p>通过这几个函数我们就能很清楚的知道点与边的关系</p>
<p>例如，我们想知道起点为1的所有边，我们只需要知道len[1]和head[1],这样我们知道起点为1的边有三个且从es[1]开始</p>
<p>但是前向星要排序，时间复杂度高，因此并不怎么使用</p>
<h3 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h3>
<p>邻接表通常用vector来实现</p>
<p>vector<int> g[max_v]，g[i]表示了以i为起点的所有边</p>
<h3 id="链式前向星"><a class="markdownIt-Anchor" href="#链式前向星"></a> 链式前向星</h3>
<p>其他部分与前向星相同，但是链式前向星多了一个next数组，取消了len数组（因为没有排序了）</p>
<p>next数组的含义是下一条以i为节点的边在es中的位置，如果这是最后一个节点，则令next[i]=0</p>
<p>例如</p>
<table>
<thead>
<tr>
<th>Array</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>es</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>head</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>next</td>
<td>4</td>
<td>0</td>
<td>6</td>
<td>7</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>举个例子，我们要求以1为起始边的所有节点</p>
<p>先从head中知道了第一个以1为起始点的边是1号，所以可以知道（1，2），然后next[1]=4,而4的es=3，所以（1,3）也知道，然后同理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,nEdge;      <span class="comment">//n为顶点数，m为边数，nEdge为存储的边的数量</span></span><br><span class="line">                    <span class="comment">//如果边是双向的，那么存储的边的数量就是2m</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>//这里是双向的</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">NODE edge[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedges</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span>       <span class="comment">//将边(u,v)添加进去</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nEdge++;</span><br><span class="line">    edge[nEdge].next=head[u];</span><br><span class="line">    edge[nEdge].to=v;</span><br><span class="line">    head[u]=nEdge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foreach</span><span class="params">()</span>       <span class="comment">//遍历边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=head[i];k!=<span class="number">-1</span>;k=edge[k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;edge[k].to&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nEdge=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0xff</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        addedges(u,v);</span><br><span class="line">        addedges(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>链接</title>
    <url>/post/4551c130.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h3>
<p>记得gcc编译器编译的步骤吗？预处理，编译，汇编，链接。首先前两步是为了生成.s的汇编文件，然后第三步就是生成机器码。但是如果第三步就已经完成了所有事为什么还要第四步呢？</p>
<p>首先我们要知道，编译时是各个文件独立编译的，也就是说这个时候如果分配了地址很可能发生这个函数的地址和另外一个文件中函数的地址相同的尴尬事情发生，为了避免这种事情，在编译到.o文件的时候一些其他文件要用的函数和变量使用一个符号来表示的，然后在链接阶段再来连连看把地址安上。</p>
<h3 id="目标文件"><a class="markdownIt-Anchor" href="#目标文件"></a> 目标文件</h3>
<p>目标文件有三种：</p>
<ul>
<li>可重定位目标文件，也就是汇编后形成的.o文件。可以和其他文件链接新城可执行文件</li>
<li>可执行目标文件，也就是可执行文件</li>
<li>共享目标文件，一种特殊的可重定向目标文件，可以在运行时重定向（动态链接）</li>
</ul>
<h4 id="可重定位目标文件"><a class="markdownIt-Anchor" href="#可重定位目标文件"></a> 可重定位目标文件</h4>
<p><img src="/images/elf.png" alt="" /></p>
<p>上面是一个elf文件结构图，这是现在linux中目标文件格式。各种目标文件中都有类似的格式。</p>
<ol>
<li>ELF头，存放了一些基础信息，例如大端序还是小端序，文件类型等等。</li>
<li>.text节，已编译的机器代码。</li>
<li>.rodata。只读数据，例如printf中的格式串和跳转表</li>
<li>.data；以初始化全局和静态变量</li>
<li>.bss； 未初始化全局和静态变量</li>
<li>.symtab。符号表</li>
<li>rel.text； .text节位置列表。可执行文件中不存在，一般会省略</li>
<li>.rel.data； 同上</li>
<li>.line； 源程序中行号和.text节机器指令间的映射，可以使用-g选项启用它</li>
<li>…</li>
<li>节头部表； 存放每一节相对于elf开始位置的偏移量。</li>
</ol>
<h3 id="符号和符号表"><a class="markdownIt-Anchor" href="#符号和符号表"></a> 符号和符号表</h3>
<p>每个.o文件中都有一个符号表。总共有三种符号</p>
<ul>
<li>全局符号：由该文件定义并且能被其他模块引用的全局符号。全局符号表示非静态函数和全局变量</li>
<li>外部符号：有其他模块定义并且被该模块引用的符号。这些符号叫外部符号。对应其他模块（文件）的非静态函数和全局变量</li>
<li>局部符号。这是带static的函数和全局变量。这些符号在函数内部都可见，但是不能呗其他函数引用。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">符号表的构成：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Symbol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;<span class="comment">//在符号表中的字节偏移</span></span><br><span class="line">    <span class="keyword">char</span> type:<span class="number">4</span>,<span class="comment">//符号类型，是数据还是函数还是文件还是未定义</span></span><br><span class="line">       binding:<span class="number">4</span>;<span class="comment">//符号是本地（static）还是全局的</span></span><br><span class="line">    <span class="keyword">char</span> reserved;</span><br><span class="line">    <span class="keyword">short</span> section;</span><br><span class="line">    <span class="keyword">long</span> value;<span class="comment">//符号地址</span></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">size</span>;<span class="comment">//符号大小，对于函数是函数指令字节总个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：<img src="/images/%E7%AC%A6%E5%8F%B7%E8%A1%A8.webp" alt="" /></p>
<p>其中ndx中的UND是undefine。</p>
<h3 id="静态链接完成的任务"><a class="markdownIt-Anchor" href="#静态链接完成的任务"></a> 静态链接完成的任务</h3>
<p>静态链接就是编译时完成的链接，与之对应的运行时的链接。静态链接主要完成了两个任务，符号解析和重定位</p>
<h4 id="符号解析"><a class="markdownIt-Anchor" href="#符号解析"></a> 符号解析</h4>
<p>符号解析就是将上面的符号表一一对应起来，例如上面第二种符号就匹配其他文件的第一种符号。</p>
<p>但是这里还有一些问题，因为开始编译是各做各的，所以难免出现名字相同的情况，甚至一个文件中也有函数重载导致重名的情况。这是符号解析中的难题。</p>
<p>对于一个文件中的重载，gcc链接器会对这些符号进行重整。例如同样是A函数，可能通过链接器的重整一个符号名就成了A1，另外一个成了A2。</p>
<p>如果是全局（其他模块可见）的变量之间导致重名。有以下方法。</p>
<p>在编译时，编译器想汇编器输出每个全局符号，分成强弱两类。函数和以初始化的全局变量时强符号，未初始化全局变量时弱符号。</p>
<p>链接规则：</p>
<ol>
<li>不能出现同名的强符号</li>
<li>如果一个强符号，其他都是弱符号，那么其他弱符号都使用强符号地址</li>
<li>如果都是弱符号，那么随机选取一个弱符号，其他弱符号使用这个弱符号地址</li>
</ol>
<p>注意第二点和第三点，系统都只分配了一片内存空间，其他符号都是共用这片内存空间，这就可能导致一些奇奇怪怪的错误，例如数据莫名被修改。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">sum.<span class="keyword">c</span></span><br><span class="line"></span><br><span class="line">int <span class="keyword">x</span><span class="comment">;</span></span><br><span class="line">int y<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">a.<span class="keyword">c</span></span><br><span class="line"></span><br><span class="line">int <span class="keyword">x</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">因为<span class="keyword">x</span>都是弱符号，所以随便选一个，然后让另一个共享内存空间，也就是在sum.<span class="keyword">c</span>中进行更改会导致a.<span class="keyword">c</span>中<span class="keyword">x</span>的更改。</span><br><span class="line"></span><br><span class="line">sum.<span class="keyword">c</span></span><br><span class="line">int <span class="keyword">x</span><span class="comment">;</span></span><br><span class="line">int y<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">a.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">double</span> <span class="keyword">x</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">这种问题更为严重，如果选到了a.<span class="keyword">c</span>中的<span class="keyword">x</span>，那么空间是<span class="number">8</span>字节，而这时在sum.<span class="keyword">c</span>中<span class="keyword">x</span>和y是连到一起的也是<span class="number">8</span>字节，这就意味着这次对a.<span class="keyword">c</span>中<span class="keyword">x</span>改变可能会导致y改变。</span><br></pre></td></tr></table></figure>
<p>上面这个问题在编译阶段很难发现，所以只有养成良好习惯，才可以减少这类问题。下面是几点建议。</p>
<ol>
<li>能不使用全局变量就不使用全局变量</li>
<li>使用全局变量记得初始化</li>
<li>确定要引用外部变量时用extern</li>
</ol>
<h4 id="重定位"><a class="markdownIt-Anchor" href="#重定位"></a> 重定位</h4>
<p>重定位有两步</p>
<ol>
<li>重定位节和符号定义：这一部分是把上面所说的每一个文件中的节。例如所有文件的.data节合成为一个节。之后就把内存地址赋给新的节，并且赋给每个符号。这时就有运行时的内存地址了。</li>
<li>重定位节的符号引用。</li>
</ol>
<h5 id="重定位条目"><a class="markdownIt-Anchor" href="#重定位条目"></a> 重定位条目</h5>
<p>在重定位之前，符号并没有赋值，这个时候就有重定位条目确定我们要怎么把地址赋给每一个符号。</p>
<p>代码重定位条目存放在.rel.text中，数据重定位条目在.rel.data中。</p>
<p>重定位条目内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Rela</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> offset;<span class="comment">//相对于函数首地址的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> type:<span class="number">32</span>,<span class="comment">//类型</span></span><br><span class="line">        symbol:<span class="number">32</span>;<span class="comment">//对应的符号</span></span><br><span class="line">    <span class="keyword">long</span> addend; <span class="comment">//附加信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只讲两种基本类型：R_X86_64_PC32(相对引用，32位），R_X86_64_32(绝对引用）。</p>
<p>这种重定位类型只支持小型代码模型，只能引用-2G到2G的范围。</p>
<p>下面讲怎么重定位。</p>
<p>如果是相对地址：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">refaddr = ADDR + <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>offset;<span class="comment">//ADDR是函数首地址，例如main函数首地址，offset是偏移量</span></span><br><span class="line"><span class="comment">//refaddr是需要修改内存的首地址，例如e8 00 00 00 00，后面四个零就是我们要填充的地址，那么refaddr是第一个00的地址</span></span><br><span class="line">*refptr(refaddr地址的内容) = <span class="constructor">ADDR(<span class="params">r</span>.<span class="params">symbol</span>)</span> + r.addend - refaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这一段就是计算相对跳转地址的，addr是对应符号的绝对地址，本来addr-refaddr就是相对跳转地址，但是注意这里的相对跳转地址是当前指令的，而我们要从下一条指令进行跳转，所以要加上一个addend，用下一个指令起始地址来减，所以这里的addend是-4，因为refaddr指向e8后面，加上4就是下一条指令，而因为是末地址减首地址所以addend是负数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绝对地址</span></span><br><span class="line"></span><br><span class="line">refaddr 同上;</span><br><span class="line">*refptr = <span class="constructor">ADDR(<span class="params">r</span>.<span class="params">symbol</span>)</span> + r.addend;</span><br><span class="line"><span class="comment">//这个相对简单，内容就是对应符号绝对地址嘛，但是这里也要加addend因为有可能是数组等因此还要加上数组的偏移量。</span></span><br></pre></td></tr></table></figure>
<h3 id="静态链接库"><a class="markdownIt-Anchor" href="#静态链接库"></a> 静态链接库</h3>
<p>过去我们有两种选择进行连接，第一种是把一堆常用函数放到一个可重定向文件中，另一种是把所有常有函数都分开，然后一个个链接。第一种占用空间太大，可能为了一两个函数加了一两千个函数，第二中编译时太难写，所以使用了静态链接库。</p>
<p>静态链接库集合了上面两种方法，首先它是一个可重定向目标文件。但是不同在于他有一个符号表需要哪个函数就把那个函数链接进去，这样就兼顾上面二者的优点。</p>
<p>可以使用<code>gcc -static -o prog2c main2.c -L. -lvector</code>其中L是链接库的路径，l是库名，一般库开头都是lib所以lib可以省略，后缀名可以省略。</p>
<p>可以使用<code>ar rcs libvector.a addvec.o multvec.o</code>来创建静态库，libvector.a是库名</p>
<p>为了效率考虑，链接时从左向右每个文件只会扫描一次，这样就可能导致问题。例如，最右边的模块有外部符号（引用其他文件的），这时因为扫描已完毕，所以就会报错。</p>
<p>此外，对于一些常用函数如cout等，如果每个程序都复制一次，那么还是太浪费空间。</p>
<p>而且如果库函数有错误或者考虑不周需要修改，那么对于绝大多数程序来说都是一个灾难，因为大型程序重新编译一下可能会导致冲突等不可预料的后果。</p>
<p>为了解决这些问题，提出了动态链接</p>
<h3 id="动态链接库"><a class="markdownIt-Anchor" href="#动态链接库"></a> 动态链接库</h3>
<p>动态链接库指的是在程序加载或运行阶段进行链接。在程序开始时（程序不是从main开始，前面还有一段代码负责初始化）会启用动态链接器。</p>
<h4 id="pic数据引用"><a class="markdownIt-Anchor" href="#pic数据引用"></a> pic数据引用</h4>
<p>GOT 全局偏移量表，这个表用来存全局变量的地址，在data段开始的地方，而静态链接的时候那些符号的跳转地址都是跳转到这个表中，然后在运行时这个跳转表才会真正赋予地址。</p>
<p>例：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">mov <span class="number">0x100010</span>(%rip), %rax</span><br><span class="line">addl $0x1, (%rax)</span><br><span class="line"></span><br><span class="line">第一行就是跳转到跳转表然后取出里面地址，然后第二段取出之歌地址中的值并加一</span><br></pre></td></tr></table></figure>
<p>PLT 过程链接表。举个例子</p>
<p><img src="/images/%E9%93%BE%E6%8E%A5.jpg" alt="" /></p>
<p>这个例子是从右上角开始的，先调用函数到了PLT表，之后跳转到GOT[4]所指位置，第一次GOT[4]指向4005c6也就是下一条指令，第一次后GOT[4]就会变成函数地址。</p>
<p>4005c6是把addvec的ID拖入栈中，然后跳转到GOT[2]的位置同时把GOT[1]放到栈中，GOT[1]是解析函数用到的信息，GOT[2]是动态链接器地址。跳到GOT[2]后就根据栈中的内容链接函数并把GOT[4]的值变成函数首地址。</p>
<h3 id="库打桩技术"><a class="markdownIt-Anchor" href="#库打桩技术"></a> 库打桩技术</h3>
<p>总体来说库打桩是指自己写一个库然后先于系统库加载这时程序运行的就是你自己写的库了。</p>
<h4 id="链接时库打桩"><a class="markdownIt-Anchor" href="#链接时库打桩"></a> 链接时库打桩</h4>
<p>例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(ptr) myfree(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d)=%p\n&quot;</span>, (<span class="keyword">int</span>)<span class="built_in">size</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过上面就可以实现不使用库函数而使用自己的函数了。这个函数便于跟踪内存请求和释放情况。但是每个文件都要写太过麻烦。</p>
<p>也可以把这个单独写成一个文件，然后通过编译器<code>gcc -Wl ,--wrap,malloc -Wl,--wrap,free -o int1 int.0 mymalloc.o</code>进行链接</p>
<h4 id="运行时库打桩"><a class="markdownIt-Anchor" href="#运行时库打桩"></a> 运行时库打桩</h4>
<p>运行时库打桩基于LD_PRELOAD环境变量。在这个变量路径下的库会先于系统库进行加载。</p>
<p><a href="https://blog.csdn.net/qq_18150497/article/details/78010331">更多内容请看</a></p>
]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/post/2ae43b86.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="逻辑回归logistic-regression"><a class="markdownIt-Anchor" href="#逻辑回归logistic-regression"></a> 逻辑回归（logistic regression)</h1>
<p>非线性回归例子：<img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%921.PNG" alt="" />.这个例子中的关系不能很好的用线性关系进行模拟，所以我们要另外做曲线模拟它。</p>
<p><img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%A8%A1%E6%8B%9F2.PNG" alt="" />为了更好的处理，还需要用sigmoid函数平滑化。</p>
<p>sigmoid函数图像为 <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C7.PNG" alt="" /></p>
<p>所以预测函数为： <img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BB3.PNG" alt="" /></p>
<p><img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%924.jpg" alt="" /></p>
<p>我们要求解的问题可以转化成，求解一组参数使得J()最小化。求解方法时求偏导让导数为零。</p>
<p>当然上面这个方法求解过于复杂，我们也可以使用梯度下降的方法。非线性方程其实就是一个超平面，我们可以求偏导找出梯度，沿着梯度下降的方向不断走就可以找到最低点。</p>
<p>求解函数为  <img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%925.PNG" alt="" /></p>
<p>其中a是更新率（learning weight）</p>
<p>所以求完偏导的结果为：<img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%926.PNG" alt="" /></p>
<p>h(x) = theta * x(i)</p>
<p>这就是更新函数，我们呢需要重复更新直到	收敛</p>
<h1 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genData</span>(<span class="params">numPoints,bias,variance</span>):</span></span><br><span class="line"><span class="comment"># 产生实验数据，其中numpoint是实验个数，bias是偏差，variance是方差</span></span><br><span class="line">    x = np.zeros(shape=(numPoints,<span class="number">2</span>))</span><br><span class="line">    y = np.zeros(shape=(numPoints))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,numPoints):</span><br><span class="line">        x[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        x[i][<span class="number">1</span>]=i</span><br><span class="line">        y[i]=(i+bias)+random.uniform(<span class="number">0</span>,<span class="number">1</span>)+variance</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span>(<span class="params">x,y,theta,alpha,m,numIterations</span>):</span></span><br><span class="line"><span class="comment"># alpha是学习率 \ theta是我们要求的，开始可以随意赋值 \ m是实例个数 \ numIterations是重复次数</span></span><br><span class="line">    xTran = np.transpose(x) <span class="comment"># 转置，为了好算</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numIterations):</span><br><span class="line">        hypothesis = np.dot(x,theta) <span class="comment"># dot是点积，算出h(x)。这个是一次全更新完</span></span><br><span class="line">        loss = hypothesis-y</span><br><span class="line">        cost = np.<span class="built_in">sum</span>(loss**<span class="number">2</span>)/(<span class="number">2</span>*m) <span class="comment"># 这个算法和上面讲的有所不同，相当于(h(x)-y(i)) * x(j)求和</span></span><br><span class="line">        gradient=np.dot(xTran,loss)/m</span><br><span class="line">        theta = theta-alpha*gradient</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;Iteration %d | cost :%f&quot;</span> %(i,cost))</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line">x,y = genData(<span class="number">100</span>, <span class="number">25</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;x:&quot;</span></span><br><span class="line"><span class="built_in">print</span> x</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;y:&quot;</span></span><br><span class="line"><span class="built_in">print</span> y</span><br><span class="line"></span><br><span class="line">m,n = np.shape(x)</span><br><span class="line">n_y = np.shape(y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;m:&quot;</span>+<span class="built_in">str</span>(m)+<span class="string">&quot; n:&quot;</span>+<span class="built_in">str</span>(n)+<span class="string">&quot; n_y:&quot;</span>+<span class="built_in">str</span>(n_y))</span><br><span class="line"></span><br><span class="line">numIterations = <span class="number">100000</span></span><br><span class="line">alpha = <span class="number">0.0005</span></span><br><span class="line">theta = np.ones(n)</span><br><span class="line">theta= gradientDescent(x, y, theta, alpha, m, numIterations)</span><br><span class="line">print(theta)</span><br></pre></td></tr></table></figure>
<h1 id="使用线性回归还是非线性回归"><a class="markdownIt-Anchor" href="#使用线性回归还是非线性回归"></a> 使用线性回归还是非线性回归</h1>
<p>在高中已经学过了，如果是一元线性回归的话会使用相关系数r来描述相关性，来决定是否使用线性回归。它的公式是<br />
<img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%9210.png" alt="" /></p>
<p>如果是多元线性回归就要用<img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%9211.jpg" alt="" /></p>
<p>这个公式中第一个yi是估计值，也就是说先要把回归方程求出来再估计相关性。</p>
<p>但是R^2会受样本量影响，随样本量增大而增大，所以要一个小小的改进。</p>
<p><img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%83%A1%E7%88%BD12.png" alt="" /></p>
<p>这个方程就是改进后的方程，先把开始的R^2算出来，然后带入，其中N是样本个数，P是维数（自变量个数）</p>
]]></content>
  </entry>
  <entry>
    <title>顺序表</title>
    <url>/post/52078.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>顺序表就是将元素放入一个连续的内存空间里，它的优点是可以快速访问，缺点是插入和删除操作时间复杂度高</p>
<h3 id="建立"><a class="markdownIt-Anchor" href="#建立"></a> 建立</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> datasize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>* p;<span class="comment">//存储空间的基址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//现在有的元素数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(node&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.p=<span class="keyword">new</span> <span class="keyword">int</span>[datasize];</span><br><span class="line">    <span class="keyword">if</span>(a.p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;储存分配失败&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> [] a.p;</span><br><span class="line">    &#125;</span><br><span class="line">    a.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化有两点要注意的地方，第一点是用了传引用，第二点是动态分配内存，这就表示如果使用完了要delete</p>
<h3 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h3>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(node&amp; a,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   		<span class="keyword">if</span>(a.p[i]==x)</span><br><span class="line">      &#123;</span><br><span class="line">      		<span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h3>
<p>插入操作是把一个数插入第i位，其他位顺序后移</p>
<p>如果插入某一位概率相同，那么在第0位插入需要移动n个数，第一位插入需要移动n-1个数…在第n位插入需要移动0个数，总共有n-1中可能，总共需要移动的次数为n(n+1)/2,所以平均需要移动次数为n/2</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> insert(node&amp; a,<span class="type">int</span> x,<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;a.<span class="built_in">length</span>||a.<span class="built_in">length</span>==datasize)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=a.<span class="built_in">length</span>;j&gt;i;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i]=x;</span><br><span class="line">    a.<span class="built_in">length</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3>
<p>与上面操作类似，这里需要前移，并且平均操作次数为(n-1)/2</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> Delete(node&amp; a,<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;a.<span class="built_in">length</span><span class="number">-1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.p[k]=a.p[k+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a.<span class="built_in">length</span>--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 过滤器</title>
    <url>/post/97246020.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中），但是在最前面的和在最后面的不一定是过滤器。</p>
<h3 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h3>
<h4 id="cat-复制"><a class="markdownIt-Anchor" href="#cat-复制"></a> cat 复制</h4>
<p>cat的用途就是把标准输入中的数据复制到标准输出中</p>
<p>应用：可以与重定向结合。cat &gt; data，这样从键盘中输入的数据将直接传到data文件中</p>
<p>此外还可以让文件内容显示在控制台上，有 cat &lt; data，标准输入变成了data文件，标准输出是屏幕。为了方便，直接cat 文件名也是可以的</p>
<p>此外，tail也有类似的功能，但是它只能显示最后的十行</p>
<p>另外一个应用就是把一个文件复制到另一个文件。例如，cat &lt; data &gt; newdata</p>
<h5 id="增强cat功能"><a class="markdownIt-Anchor" href="#增强cat功能"></a> 增强cat功能</h5>
<p>cat &lt; file…= cat file …</p>
<p>有三个点说明了可以同时输入多个文件，这样就为组合多个文件提供了途径</p>
<p>cat data1 data2 data3 &gt;file</p>
<p>后缀：</p>
<pre><code> -n 在每行后面加一个行号
 -b 与-n一起使用，不要对空白行加行号
 -s 将多个连续的空白行变成一个空白行
</code></pre>
<h4 id="split-分为不同文件"><a class="markdownIt-Anchor" href="#split-分为不同文件"></a> split 分为不同文件</h4>
<p>语法 split [-d] [-a num] [-l lines] [file [prefix]]</p>
<p>作用： 将一个大文件分解成几个小文件。默认情况下，split将创建1000行长的空间</p>
<p>参数：</p>
<pre><code>-l 创建一个5000行的空间
-d 将文件名改为从00开始编号
-a 后面加数字，例如3表示从000开始，总共1000个文件名
</code></pre>
<p>默认情况下，split创建的文件将以x开头，后面加aa，ab等</p>
<h4 id="tac-反转复制"><a class="markdownIt-Anchor" href="#tac-反转复制"></a> tac 反转复制</h4>
<p>相关过滤器： cat，rev</p>
<p>作用：和cat类似，但是在写入文件时把文件内容反转（tac是将cat反过来）。注意，这里的反过来并不是指从后往前倒着写，而是把行与行将顺序反过来。</p>
<h4 id="rev-反转字符顺序"><a class="markdownIt-Anchor" href="#rev-反转字符顺序"></a> rev 反转字符顺序</h4>
<p>相关过滤器： cat tac</p>
<p>作用： 将各行字符顺序反转</p>
<p>语法： rev [file…]</p>
<p>例如： 有一个文件data，里面有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">abcde</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure>
<p>之后用rev后会变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">54321</span><br><span class="line">edcba</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure>
<p>rev也是直接输出到标准输出上的，也就是说并不会对源文件造成改变，如果想输出到文件中，还要重定向一下</p>
<h4 id="headtail-从数据开头或者结尾读取"><a class="markdownIt-Anchor" href="#headtail-从数据开头或者结尾读取"></a> head，tail 从数据开头或者结尾读取</h4>
<p>语法： head/tail [-n lines]，lines是希望选择的数据行</p>
<p>默认情况下，head和tail都只会选择十行数据，用-n可以选择任意行数</p>
<p>例： calculate | tail -n 15</p>
<h4 id="colrm-删除数据列"><a class="markdownIt-Anchor" href="#colrm-删除数据列"></a> colrm 删除数据列</h4>
<p>相关过滤器： cut paste</p>
<p>colrm（“column remove&quot;)程序从标准输入中读取数据，删除指定数据列（也就是竖的删除），将剩余数据写入标准输出</p>
<p>语法： colrm [startcol [endcol]]，编号从1开始</p>
<p>例： colrm 14 30 &lt;students | less</p>
<h3 id="比较文件"><a class="markdownIt-Anchor" href="#比较文件"></a> 比较文件</h3>
<h4 id="cmp-比较两个任意文件"><a class="markdownIt-Anchor" href="#cmp-比较两个任意文件"></a> cmp 比较两个任意文件</h4>
<p>相关过滤器：comm diff sdiff</p>
<p>语法: cmp file1 file2</p>
<p>cmp程序逐字节的比较文件，查看两个文件是否相同。如果两个文件相同，那么不做任何处理，如果不同，将会返回第一个不同的行和列</p>
<h4 id="comm-比较有序文件"><a class="markdownIt-Anchor" href="#comm-比较有序文件"></a> comm 比较有序文件</h4>
<p>语法：comm [-123] file1 file2</p>
<p>comm程序一行一行的比较两个有序的文本间，程序输出三列，第一列输出只包含在第一个文件中的行，第二列输出只包含在第二个文件中的行，第三列输出两个文件中都有的行。</p>
<p>因为comm是逐行比较，所以在比较之前最好使用sort进行排序</p>
<p>参数： -1 -2 -3 取消第一二三列的输出</p>
<h4 id="diff-比较无序文件"><a class="markdownIt-Anchor" href="#diff-比较无序文件"></a> diff 比较无序文件</h4>
<p>语法： diff [-bBiqswy] [-c| -Clines | -u | -Ulines] file1 file2</p>
<p>lines是说明上下文关系的行号</p>
<p>输出： diff的输出有三个不同的单字符指示： c（change） d（delete） a（append）。这三个字符说明了要想让两个文件相同需要做哪些改变。</p>
<p>这三个字符左右两边都会有数字，代表着需要修改的行号。例如，3c3代表把左边文件中的第三行变成右边文件中的第三行。</p>
<p>diff要求改变时，就会给出每一个文件的实际行，第一个文件中的行用小于号标记，第二个文件中的行用大于号标记。两组行之间还会有横线分隔开</p>
<p>例如，第一个文件为</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">abcd</span><br><span class="line">asdf</span><br><span class="line"><span class="keyword">as</span> df</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure>
<p>第二个文件为</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">a</span>     </span><br><span class="line"><span class="attribute">abcd</span></span><br><span class="line"><span class="attribute">asdf</span></span><br><span class="line"><span class="attribute">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure>
<p>结果为</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">0a1</span><br><span class="line">&gt; a     </span><br><span class="line">3,4c4</span><br><span class="line">&lt; as df</span><br><span class="line">&lt; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">---</span><br><span class="line">&gt; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure>
<p>a左边的数代表在左边数后面追加一行，例如0a1代表在第0行后面加上右边的第一行</p>
<p>d一般只需要管左边的数字，它的意思是删去左边的那一行</p>
<p>c表示3,4行和第三行有不同，分隔符上面是第一个文件，下面是第二个文件</p>
<p>参数：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-i 忽略大小写区别</span></span><br><span class="line"><span class="deletion">-w（whitespace) 忽略所有空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别，就是把多个空白符看成一个</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行，</span></span><br><span class="line"><span class="deletion">-q 当两个文本不同时，忽略所有细节，只说两文本不同</span></span><br><span class="line"><span class="deletion">-s 会明确告诉两个文本相同</span></span><br><span class="line"><span class="deletion">-c 全文比较，+代表要增加，-代表要减少，！代表要替换</span></span><br><span class="line"><span class="deletion">-u 与-c类似，但是把两个文件混合在一起显示，两个重复行只输出一个</span></span><br><span class="line"><span class="deletion">-y 把两个文件并排输出</span></span><br></pre></td></tr></table></figure>
<h4 id="sdiff"><a class="markdownIt-Anchor" href="#sdiff"></a> sdiff</h4>
<p>语法： sdiff [-bBilsW] [-w columns] file1 file2</p>
<p>作用：与 diff -y 类似，并排比较<br />
参数：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-l 当两个文件有共同行时，只显示左边的列</span></span><br><span class="line"><span class="deletion">-s 不显示两个文件中任何相同的行</span></span><br><span class="line"><span class="deletion">-w+数字 改变列的宽度</span></span><br><span class="line"><span class="deletion">-i 忽略大写和小写的区别</span></span><br><span class="line"><span class="deletion">-W 忽略所有的空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行</span></span><br></pre></td></tr></table></figure>
<h4 id="差分"><a class="markdownIt-Anchor" href="#差分"></a> 差分</h4>
<p>例如： diff game1_ver1.0.c game2_ver2.0.c &gt; game2_ver2.1</p>
<p>这个命令会把第一个文件和第二个文佳之间的差保存下来，这样可以节省空间，此外在日后不慎丢失文件时也有办法快速找回</p>
<h4 id="cut-抽取数据列"><a class="markdownIt-Anchor" href="#cut-抽取数据列"></a> cut 抽取数据列</h4>
<p>相关过滤器： colrm join paste</p>
<p>语法： cut -c list [file…]</p>
<p>list就是要抽取的数据列，各个列之间用逗号隔开，不能有空格，或者14-19表示从14列到19列</p>
<p>作用：抽取指定的列</p>
<p>这种按列切分遇到长度不同的数据时就显得无能为力，因此还有另一种抽取方式，抽取字段，即按照一定的定界符进行分割（如逗号，空格等）</p>
<p>参数：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">-c  list [file...] list表明抽取第几个字段</span><br><span class="line">-f  list [-d delimiter] [-s] [file...]  -d后面是定界符种类 -s（suppress 抑制）抛弃没有定界符的行。例如 cut -f <span class="number">1</span> -d <span class="string">&#x27;:&#x27;</span> ./temp</span><br></pre></td></tr></table></figure>
<h4 id="paste"><a class="markdownIt-Anchor" href="#paste"></a> paste</h4>
<p>语法： paste [-d char…] [file…]</p>
<p>其中char是用来做分隔符的字符，默认情况为一个制表符或者是空格</p>
<p>作用： 把几个文件组合成一个表格（组合数据列）</p>
<p>如果指定了不止一个定界符，那么将会轮流使用定界符</p>
<p>例如： paste -d ‘|%’ name phone ，这个指令中就有两个定界符</p>
<h3 id="统计和格式化"><a class="markdownIt-Anchor" href="#统计和格式化"></a> 统计和格式化</h3>
<h4 id="nl-创建行号"><a class="markdownIt-Anchor" href="#nl-创建行号"></a> nl 创建行号</h4>
<p>语法： nl [-v start] [-i increment] [-b a] [-n ln|rn|rz] [file…]</p>
<p>start是起始行号 ，increment是增量</p>
<p>作用：希望在一些数据中永久的插入行号，在输出中临时插入行号。一般状况下，插入的行号都是临时的，原始数据并不会发生改变，除非重定向输出到文件中。</p>
<p>默认情况下，不会对空行编号</p>
<p>参数：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-v 改变起始编号，默认起始编号是1</span></span><br><span class="line"><span class="deletion">-i 改变增量，默认增量为1</span></span><br><span class="line"><span class="deletion">-b a 对所有行编号，包括空行</span></span><br><span class="line"><span class="deletion">-n ln 左对齐 rn 右对齐 rz 右对齐，有前导0</span></span><br></pre></td></tr></table></figure>
<h4 id="wcword-count统计行单词和字符的数量"><a class="markdownIt-Anchor" href="#wcword-count统计行单词和字符的数量"></a> wc（word count）统计行单词和字符的数量</h4>
<p>语法： wc [-clLw] [file…]</p>
<p>作用：统计行，单词，字符的数量。所统计的数据可以来自另一个程序或者是一个或多个文件</p>
<p>输出依次输出行，单词数，字符数 和文件名。如果不止一个文件，那么会为每一个文件显示一个输出，然后最后一行是一个总输出。</p>
<p>参数</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-l 统计行</span></span><br><span class="line"><span class="deletion">-w 统计单词</span></span><br><span class="line"><span class="deletion">-c 统计字符</span></span><br><span class="line"><span class="deletion">-L 该选项显示输入中最长行的长度</span></span><br></pre></td></tr></table></figure>
<p>此外，还可以用wc来统计某一目录中文件的数量，假设一个文件一行，用ls file | wc -l.</p>
<h4 id="制表符和空格"><a class="markdownIt-Anchor" href="#制表符和空格"></a> 制表符和空格</h4>
<p>在老式机器中，会在某些特定的为做一些机器标记，这些标记叫做制表位，如果按了制表位，那么机器会直接跳转到下一个制表位上，tab键与这个作用类似。一旦按了tab键，那么他将会自动跳转到下一个制表位。例如输入<code>A&lt;Tab&gt;BBBB&lt;Tab&gt;CCC</code>，实际上看起来中间有空格，实际上只有一个Tab</p>
<p>可视化制表符</p>
<p>第一种办法是在vi中，set list 那么制表符会转化成^I符号</p>
<h4 id="expand-将制表符转化成空格"><a class="markdownIt-Anchor" href="#expand-将制表符转化成空格"></a> expand 将制表符转化成空格</h4>
<p>语法： expand [-i] [-t size] [-t list] [file…]</p>
<p>其中size是固定宽度制表符的大小（默认为8)，list是制表位列表</p>
<p>作用：expand将输入文件中所有的制表符转化成空格，别切维持与原文本相同的对齐方式</p>
<p>-i 只转换开头的制表符，其他的制表符保持不变</p>
<h4 id="unexpand-将空格转化成制表符"><a class="markdownIt-Anchor" href="#unexpand-将空格转化成制表符"></a> unexpand 将空格转化成制表符</h4>
<p>语法： unexpand [-a] [-t size] [-t list] [file…]</p>
<p>其中size是制表符的大小（希望设置的），list是制表位列表</p>
<p>一般情况下，unexpand只转化第一行的空格，如果想要转换所有行的空格，那么需要-a选项</p>
<h4 id="fold-格式化行"><a class="markdownIt-Anchor" href="#fold-格式化行"></a> fold 格式化行</h4>
<p>相关过滤器： fmt ,pr</p>
<p>语法： fold [-s] [w witch] [file…]</p>
<p>其中witch是新行的宽度。</p>
<p>作用： 将长的行分割成短行。也就是把一行分成多行。其实就是在适当位置插入一个回车符</p>
<p>默认状态下，80个字符为一行。</p>
<p>-s选项是告诉程序不要分割单词，也就是说如果那个单词正好在要分割的位置，那么现在会先显示这个单词在转到下一行。</p>
<h4 id="fmt-格式化段落"><a class="markdownIt-Anchor" href="#fmt-格式化段落"></a> fmt 格式化段落</h4>
<p>语法： fmt [-su] [-w width] [file…]</p>
<p>作用：让各行连接在一起，并且不改变空白符。</p>
<p>当它读取文本时，假定段落由空行分隔。一个“段落”就是一个或多个连续的文本行，不包括空行。fmt根据下列规则读取一个段落</p>
<ul>
<li>行宽： 让每行尽可能的长，并且不超过指定的长度。默认情况下，每行最多75个字符</li>
<li>句子： 无论何时，尽可能在句子末尾分隔行。避免在句子的第一个单词之后或最后一个单词之前分隔行。</li>
<li>空白符： 保持单词及空行之间的所有缩进，空格。</li>
<li>制表符： 所有制表符转化成空格。并在最后输出时合适的位置插入制表符</li>
</ul>
<p>说起来复杂，其实就是让那些长短不一的段落尽量变得长。</p>
<p>例如</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">As we all know,</span><br><span class="line"><span class="keyword">success </span>cones slowly and</span><br><span class="line">is due to a number of different factors all coming</span><br><span class="line">together</span><br><span class="line">over a period of years</span><br></pre></td></tr></table></figure>
<p>使用命令后</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">As</span> we <span class="keyword">all</span> know, <span class="type">real</span> success comes slowly <span class="keyword">and</span> <span class="keyword">is</span></span><br><span class="line">due <span class="keyword">to</span> a number <span class="keyword">of</span> different factors <span class="keyword">all</span> coming</span><br><span class="line">together <span class="keyword">over</span> a period <span class="keyword">of</span> years.</span><br></pre></td></tr></table></figure>
<p>此外，它是一段的作用，如果两行之间有个空行就把他们当成两段单独处理，互不影响</p>
<p>参数</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-u(uniform spacing 统一间距) 减少空格，每个单词之间最多只有一个空格，句子末尾最多只有两个空格。</span></span><br><span class="line"><span class="deletion">-w 设定宽度</span></span><br></pre></td></tr></table></figure>
<h4 id="pr-按页格式化文本"><a class="markdownIt-Anchor" href="#pr-按页格式化文本"></a> pr 按页格式化文本</h4>
<p>语法： pr [-dt] [+beg[:end]] [-h text] [-l n] [-o margin] [-W width] [file…]</p>
<p>作用： 按页格式化文件，以便于打印。</p>
<p>其中 beg是需要格式化的第一页，end是最后一页，text是标题，n是每页的行数，margin是左边缘的大小，width是输出的宽度。</p>
<p>默认情况下，pr是通过顶端插入一个标题，左边插入一个边缘，底部插入一个页尾来格式化文件。标题包括修改时间，文件名称和页号。</p>
<p>如果想查看效果，最好在less程序中</p>
<p>参数：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-d 双倍行距文本（word中的）</span></span><br><span class="line"><span class="addition">+begin;end 从那页到哪页格式化</span></span><br><span class="line"><span class="deletion">-l 改变每页总行数</span></span><br><span class="line"><span class="deletion">-o 设置左边缘</span></span><br><span class="line"><span class="deletion">-W 改变每一行的字符数（默认是72）</span></span><br></pre></td></tr></table></figure>
<p>还可以按列格式化文本</p>
<p>语法： pr [-mt] [-columns] [-l lines] [-W width] [file…]</p>
<p>column是输出列的数量，lines是每页的行数，width是每行的字符数。这个选项不建议用，会截断字符。</p>
<h3 id="选取排序组合变换"><a class="markdownIt-Anchor" href="#选取排序组合变换"></a> 选取，排序，组合，变换</h3>
<h4 id="grep-选取特定模式的行"><a class="markdownIt-Anchor" href="#grep-选取特定模式的行"></a> grep 选取特定模式的行</h4>
<p>相关过滤器： look strings</p>
<p>语法： grep [-cilLnrsvwx] pattern [file…]</p>
<p>pattern是要搜索的格式</p>
<p>作用： 从标准输入或文件中读取数据，抽取所有包含特定模式的行，并写入标准输出。</p>
<p>这个模式可以是字符串标点符号等，但是如果是标号或者特殊字符时，最好用’'强引用，以防止歧义。</p>
<p>选项：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-c(count) 统计所抽取行的数量，但不显示行本身</span></span><br><span class="line"><span class="deletion">-i（ignore) 忽略大小写的区别</span></span><br><span class="line"><span class="deletion">-n 所选行在原文件中的位置</span></span><br><span class="line"><span class="deletion">-l（list），如果在不只一个文件中搜索，使用这个选项可以只把匹配的文件名列举出来，此时文件名也要输出多个</span></span><br><span class="line"><span class="deletion">-L 显示不包含该模式的文件名</span></span><br><span class="line"><span class="deletion">-v（reverse） 选取不包含模式的行</span></span><br><span class="line"><span class="deletion">-x 选取完全匹配的行</span></span><br><span class="line"><span class="deletion">-r（recursive递归） 搜索整个目录树</span></span><br></pre></td></tr></table></figure>
<h5 id="fgrepegrep-grep变体"><a class="markdownIt-Anchor" href="#fgrepegrep-grep变体"></a> fgrep，egrep grep变体</h5>
<p>fgrep，历史上使用，现在基本不用</p>
<p>egrep grep扩展版本，功能比grep强大，可以通过 grep -E的方式<br />
-w 只匹配完整的单词，并且最好配合-l使用。</p>
<h4 id="look-选取以特定模式开头的行"><a class="markdownIt-Anchor" href="#look-选取以特定模式开头的行"></a> look 选取以特定模式开头的行</h4>
<p>格式： look [-df] pattern file…</p>
<p>作用： 搜索以字母顺序排列的数据，并查找所有以特定模式开头的行。然后输出这些行</p>
<p>look其实并不是一个过滤器，它只能从文件中读入，因此只能写于管道线的开头</p>
<p>-d 忽略标点和其他字符，本来是指搜索第一个单词</p>
<p>-f（fold同等） 忽略大写和小写的区别</p>
<h4 id="sort-排序"><a class="markdownIt-Anchor" href="#sort-排序"></a> sort 排序</h4>
<p>格式 sort [-dfnru] [-o outfile] [infile…]</p>
<p>作用： 排序数据和查看数据是否已经有序。他可以比较整行，也可以从每行中选取一部分进行比较。</p>
<p>sort可以重定向输出到另一个文件，但是不能输出到输入文件</p>
<p>例如： sort temp &gt; temp 是不可以的</p>
<p>但是可以使用-o选项，此时该文件中原有数据将会被保存，排序后的数据也会被追加到这个文件中</p>
<h5 id="-dfnr-控制数据排序的顺序"><a class="markdownIt-Anchor" href="#-dfnr-控制数据排序的顺序"></a> -dfnr 控制数据排序的顺序</h5>
<p>-d(dictionary) 只查看字母，数字和空白符，当确定有阻碍排序的因素（如标点符号等），可以使用这个选项。</p>
<p>-f（fold 等同）不区分大小写</p>
<p>-n（numeric 数字） 识别开头或者字段开头的数字，并按照数字进行排序</p>
<p>-r 反向排序</p>
<p>-u（unique 唯一） 对于相同行，只保留一行</p>
<h5 id="检测数据是否有序-c"><a class="markdownIt-Anchor" href="#检测数据是否有序-c"></a> 检测数据是否有序 -c</h5>
<p>-c（check） 不会排列数据，只会告诉数据是否有序，如果有序，将不会显示任何内容</p>
<h4 id="uniq-查找重复的行"><a class="markdownIt-Anchor" href="#uniq-查找重复的行"></a> uniq 查找重复的行</h4>
<p>语法： uniq [-cdu] [infile [outfile]</p>
<p>作用： 消除重复行，选取重复行，选取唯一行，统计重复行的数量。不加选项输出非重复行和只输出一次重复行</p>
<p>注意uniq的输入必须是有序的</p>
<p>-d 只查看重复行</p>
<p>-u 只查看非重复行</p>
<p>-c 统计重复行出现的次数</p>
<h4 id="join-合并两个文件的有序数据"><a class="markdownIt-Anchor" href="#join-合并两个文件的有序数据"></a> join 合并两个文件的有序数据</h4>
<p>相关过滤器： colrm cut paste</p>
<p>语法： join [-i] [-al|-vl] [-a2|-v2] [-l field1] [-2 field2] file1 file2</p>
<p>其中field是引用特定数段的数字</p>
<p>作用： 把两个文件中对应行合并到一起。但是这又和sort不同，sort是直接把两个文件拼接在一起，而join则是重复数据合并为一个输出。不重复数据直接输出。读取输入时，会忽略前导空白符。</p>
<p>不使用其他标号情况下，只会显示有匹配的连接字段（也就是两个文件对应行有相同字段），如果使用-a(all)选项，将会显示整个文件，后面要加a1或a2。a1代表把第一个文件中不匹配的内容也加上去。如果是v1，显示V1中不匹配的行</p>
<p>-1+sum 将第一个文件中的第sum个字段和第二个文件中的第一个字段进行匹配</p>
<h4 id="tsort-由偏序创建全序"><a class="markdownIt-Anchor" href="#tsort-由偏序创建全序"></a> tsort 由偏序创建全序</h4>
<p>语法： tsort file</p>
<p>作用：将一系列的事一件一件从头到尾输出</p>
<p>例如：两个单词第二个单词代表在第一个单词后要做的事</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">eat clean-<span class="keyword">dishes</span></span><br><span class="line"><span class="keyword">clean-dishes </span>watch-TV</span><br><span class="line"><span class="keyword">shop </span>cook</span><br><span class="line">cook eat</span><br></pre></td></tr></table></figure>
<p>在使用了tsort后，输出为</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">shop</span></span><br><span class="line"><span class="keyword">cook</span></span><br><span class="line"><span class="keyword">eat</span></span><br><span class="line"><span class="keyword">clean-dishes</span></span><br><span class="line"><span class="keyword">watch-TV</span></span><br></pre></td></tr></table></figure>
<h4 id="strings-在二进制文件中搜索字符串"><a class="markdownIt-Anchor" href="#strings-在二进制文件中搜索字符串"></a> strings 在二进制文件中搜索字符串</h4>
<p>语法： strings [-length] file…</p>
<p>在现代软件中基本都有这种功能，不再展开</p>
<h4 id="转换字符-tr"><a class="markdownIt-Anchor" href="#转换字符-tr"></a> 转换字符 tr</h4>
<p>语法： tr [-cds] [set1 [set2]]</p>
<p>set1是字符组</p>
<p>作用：可以将一个字符转化成另一个字符，例如将小写转化成大写，将制表符转化成空格，或者将0转化成x等。此外，还可以将多个字符变成一个字符，例如将多个空格转化成一个空格。最后，还可以删除指定字符，例如删除制表符。</p>
<p>例如： tr a A &lt; old tr a-z A-Z &lt; old</p>
<p>当需要替换的字符中出现由特殊意义的字符时，需要引用他们</p>
<p>还有几种特殊的缩写 [:lower:] 代表小写字母，[:upper:]代表大写字母，[:digit:]代表数字</p>
<p>tr还可以转换不可见字符</p>
<p>例如： tr ‘\n’ ‘\t’ &lt; old</p>
<p>参数：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">s 多个字符变成一个字符 例如 tr -s <span class="string">&#x27; &#x27;</span> <span class="string">&#x27; &#x27;</span> &lt; old</span></span><br><span class="line"><span class="ruby">-d 删除指定字符</span></span><br><span class="line"><span class="ruby">-c 把没选上的字符变成另一个字符，例如 tr -c <span class="string">&#x27; \n&#x27;</span> x &lt; old，这个的意思就是除了空格和换行之外其他所有字符都变成x</span></span><br></pre></td></tr></table></figure>
<h4 id="sed-非交互式文本编辑"><a class="markdownIt-Anchor" href="#sed-非交互式文本编辑"></a> sed 非交互式文本编辑</h4>
<p>交互式文本编辑就是有一个窗口，例如gedit vi等。而非交互式则需要提前设计命令，然后将命令发给程序。</p>
<p>语法： sed [-i] command | -e command… [file…]</p>
<p>command是sed命令</p>
<p>作用： sed是一个标准的过滤器，可以对标准输入或者标准输出进行修改</p>
<p>sed从输入流中每次读取一行。然后执行下面三个步骤</p>
<ol>
<li>从输入流中读取一行</li>
<li>执行指定的命令，对该行进行必要的修改</li>
<li>将该行写入输出流中</li>
</ol>
<p>因为是修改标准输入或者标准输出，所以源文件不会被修改，如果要修改原文件，可以加上-i(in-place)选项，这个选项会将输出保存到一个临时文件，一但所有数据处理完，sed就会把临时文件复制到原文件中</p>
<h5 id="使用sed进行替换"><a class="markdownIt-Anchor" href="#使用sed进行替换"></a> 使用sed进行替换</h5>
<p>想要用sed对标准输入或输出的内容进行修改，可以采用 s命令</p>
<p>形式： /address|pattern/ s /search/replacement/[g]</p>
<p>address 是输入流中一个行或者多个行的地址，pattern是一个字符串，search是正则表达式，replacement是一个替换文本</p>
<p>例如 sed s/harley/Harley,这个例子意思就是把每一行的第一个harley改成Harley，如果想把所有都改了，那么在后面要加上一个g</p>
<p>如果只对一些行进行操作，可以用下列语法：</p>
<p>number[,number] /regex/</p>
<p>number是行号</p>
<p>例如： sed ‘5s/harley/Harley/g’ names</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Swing组件</title>
    <url>/post/604b49d0.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="border边框"><a class="markdownIt-Anchor" href="#border边框"></a> Border边框</h1>
<p>边框创建与设置</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Border border = <span class="module-access"><span class="module"><span class="identifier">BorderFactory</span>.</span></span>create<span class="constructor">XxxxBorder(<span class="operator">...</span>)</span>;</span><br><span class="line">jComponent.set<span class="constructor">Border(<span class="params">border</span>)</span>;<span class="comment">//设置边框</span></span><br></pre></td></tr></table></figure>
<p><strong>BorderFactory中的边框</strong></p>
<p>使用BorderFactory中的静态方法创建边框</p>
<ul>
<li>
<p>createEmptyBorder()： 空边框</p>
</li>
<li>
<p>createEmptyBorder(int top, int left, int bottom, int right)：</p>
</li>
<li>
<p>createLineBorder(Color color)： 线边框。color是线的颜色</p>
</li>
<li>
<p>createLineBorder(Color color, int thickness, boolean rounded)： thickness是线宽，rounded是是否有圆角</p>
</li>
<li>
<p>createTitledBorder(Border border, String title, int titleJustification, int titlePosition, Font titleFont, Color titleColor)：标题边框。border是要加标题的边框，title是标题内容。titleFont是标题字体，color是标题颜色。</p>
<ul>
<li>
<pre><code>    titleJustification有以下取值
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.LEFT
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.CENTER
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.RIGHT
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.LEADING
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.TRAILING
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.DEFAULT_JUSTIFICATION (leading)
</code></pre>
</li>
<li>titleposition是标题在边框位置。有以下取值</li>
<li>
<pre><code>     TitledBorder.ABOVE_TOP
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.TOP（位于顶线上）
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.BELOW_TOP
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.ABOVE_BOTTOM
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.BOTTOM（位于底线上）
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.BELOW_BOTTOM
</code></pre>
</li>
<li>
<pre><code>    TitledBorder.DEFAULT_POSITION（顶部）
</code></pre>
</li>
</ul>
</li>
</ul>
<p>还有许多其他边框</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 斜面边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createBevelBorder(...);</span><br><span class="line"><span class="comment">// 虚线边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createDashedBorder(...);</span><br><span class="line"><span class="comment">// “浮雕化”边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createEtchedBorder(...);</span><br><span class="line"><span class="comment">// 凹入斜面边缘的边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createLoweredBevelBorder(...);</span><br><span class="line"><span class="comment">// 具有凸出斜面边缘的边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createRaisedBevelBorder(...);</span><br><span class="line"><span class="comment">// 凸起软斜面</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createRaisedSoftBevelBorder(...);</span><br><span class="line"><span class="comment">// 合成边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> CompoundBorder createCompoundBorder(...);</span><br><span class="line"><span class="comment">// 类似衬边的边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> MatteBorder createMatteBorder(...);</span><br><span class="line"><span class="comment">// 共享斜面边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createSharedBevel(...)</span><br><span class="line"><span class="comment">// 软斜面边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createSoftBevelBorder(...);</span><br><span class="line"><span class="comment">// 画笔边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createStrokeBorder(...);</span><br></pre></td></tr></table></figure>
<p><img src="/images/swing%E7%BB%84%E4%BB%B610.PNG" alt="" /><br />
<a href="https://blog.csdn.net/xietansheng/article/details/78389211">学习自</a></p>
<h1 id="按钮"><a class="markdownIt-Anchor" href="#按钮"></a> 按钮</h1>
<p>所有的按钮都继承与AbstractButton。按钮有：普通按钮（JButton）、触发器按钮（JToggleButton）、复选框（JCheckBox）、单选按钮（JRadioButton）、箭头按钮（BasicArrowButton）和菜单项（JMenuItem）等。</p>
<p>方法：</p>
<ul>
<li>void setEnabled(boolean enable)： 设置这个按钮是否可用</li>
<li>setRolloverEnabled(boolean enable): 设置是否要产生翻转</li>
<li>setContentAreaFilled(): 是否要绘制父类内容。设置这个是让按钮周围不会有界限。</li>
<li>setFocusPainted(): 时候绘制焦点</li>
<li>setBorderPainted(): 是否绘制边框</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    JButton button;</span><br><span class="line">    JToggleButton togglebutton;</span><br><span class="line">    JCheckBox checkbox;</span><br><span class="line">    JRadioButton radiobutton;</span><br><span class="line">    BasicArrowButton arrowbutton;</span><br><span class="line">    JMenuItem menuitem;</span><br><span class="line">    <span class="keyword">public</span> Calculate(<span class="keyword">String</span> title)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">        setLayout(<span class="keyword">new</span> <span class="type">FlowLayout</span>());</span><br><span class="line">        button = <span class="keyword">new</span> <span class="type">JButton</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">        togglebutton = <span class="keyword">new</span> <span class="type">JToggleButton</span>(<span class="string">&quot;togglebutton&quot;</span>);</span><br><span class="line">        checkbox = <span class="keyword">new</span> <span class="type">JCheckBox</span>(<span class="string">&quot;checkbox&quot;</span>);</span><br><span class="line">        radiobutton = <span class="keyword">new</span> <span class="type">JRadioButton</span>(<span class="string">&quot;radiobutton&quot;</span>);</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="type">JPanel</span>();</span><br><span class="line">        panel.setBorder(<span class="keyword">new</span> <span class="type">TitledBorder</span>(<span class="string">&quot;arrow&quot;</span>));</span><br><span class="line">        arrowbutton = <span class="keyword">new</span> <span class="type">BasicArrowButton</span>(BasicArrowButton.NORTH);</span><br><span class="line">        panel.add(arrowbutton);</span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="type">BasicArrowButton</span>(BasicArrowButton.RIGHT));</span><br><span class="line">        menuitem = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;menuitem&quot;</span>);</span><br><span class="line">        add(button);</span><br><span class="line">        add(togglebutton);</span><br><span class="line">        add(checkbox);</span><br><span class="line">        add(radiobutton);</span><br><span class="line">        add(panel);</span><br><span class="line">        add(menuitem);</span><br><span class="line">        pack();</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Calculate</span>(<span class="string">&quot;Calculate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/swing.PNG" alt="" /></p>
<p>注意togglebutton有两种状态，按下和弹出，普通按钮按下就会立刻弹出，但是toggle按下就变成按下状态，需要再按一下才会变成弹出状态。</p>
<p>可以设置选中或者未选中<code>setSelected(boolean)</code>。也可以通过<code>isSelected()</code>查看是否被选中</p>
<p>在按钮中可以显示图标，ImageIcon类表示图标。有以下设置图标的方法：</p>
<ul>
<li>setIcon(Icon icon): 设置有效状态下的图标</li>
<li>setRolloverIcon(Icon icon): 设置鼠标移动到对应区域显示图标</li>
<li>setPressedIcon(Icon icon): 设置按下按钮时显示的图标</li>
<li>setDisabledIcon(Icon icon): 设置无效状态下的图标</li>
<li>setBorderPainted(boolean b)： 是否绘制边框</li>
</ul>
<p><strong>监听器</strong></p>
<p>JButton</p>
<ul>
<li>void addActionListener(ActionListener listener)</li>
<li>void removeActionListener(ActionListener listener)：移除监听器</li>
</ul>
<p>JRadioButton</p>
<ul>
<li>void addChangeListener(ChangeListener l)//状态改变监听器</li>
</ul>
<h2 id="jradiobuttonjcheckboxjtogglebutton"><a class="markdownIt-Anchor" href="#jradiobuttonjcheckboxjtogglebutton"></a> JRadioButton/JCheckBox/JtoggleButton</h2>
<p>从上面我们可以看出，这三者就是图形有所不同，大致功能还是相同的。</p>
<p>构造方法：</p>
<ul>
<li>JRadioButton(String text, boolean selected): selected确定开始的状态<br />
例：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JRadioButton button;</span><br><span class="line">    <span class="keyword">private</span> JRadioButton button2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Calculate(<span class="built_in">String</span> text)</span><br><span class="line">    &#123;</span><br><span class="line">        button = <span class="keyword">new</span> JRadioButton(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        button2 = <span class="keyword">new</span> JRadioButton(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">        ButtonGroup group = <span class="keyword">new</span> ButtonGroup();</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(button.isSelected())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;button has been selected&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Button hasn&#x27;t been selected&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button.setSelected(<span class="literal">true</span>);</span><br><span class="line">        group.add(button);</span><br><span class="line">        group.add(button2);</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line">        panel.add(button);</span><br><span class="line">        panel.add(button2);</span><br><span class="line">        add(panel);</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Calculate(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个问题，使用actionListener的话只会显示button has been selected.因为点击另外一个按钮时button按钮会自动关闭，而actionListener不检查，只有当按下button时才会输出。</p>
<p>如果用ChangeListener的话当鼠标移动到这两个按钮上面的时候就会输出，点击时又会输出，这样可能会使输出过于庞杂。</p>
<h2 id="按钮组"><a class="markdownIt-Anchor" href="#按钮组"></a> 按钮组</h2>
<p>当有多个单选按钮时，可以把他们加入到一个按钮组中。这个歌时候一次最多只能选择按钮组中一个按钮。</p>
<p>创建：</p>
<ul>
<li>ButtonGroup b = new ButtonGroup();</li>
</ul>
<p>把按钮添加到按钮组中用add。</p>
<h1 id="jtextfield文本框"><a class="markdownIt-Anchor" href="#jtextfield文本框"></a> JTextField文本框</h1>
<p>JTextField与PlainDocument关联，后者保存前者的文档。当用户向文本框中输入文本时，AWT线程会自动调用PlainDocument的insertString()方法，把用户输入的文本存到PlainDocument中。</p>
<p>文本框只能储存一行文本，不能多行。</p>
<p>构造方法：</p>
<ul>
<li>JTextField(String text): 显示默认文本</li>
<li>JTextField(int col): 设定首选列数，如果是零，就是默认列数。</li>
</ul>
<p>方法：</p>
<ul>
<li>String getText(): 获得文本</li>
<li>setCaretColor(Color c): 设置光标颜色</li>
<li>setSelectionColor(Color c): 设置选中背景颜色</li>
<li>setSelectedTextColor(Color c): 设置选中文本颜色</li>
<li>setDisabledTextColor(Color c): 设置不可用时文本颜色</li>
<li>setHorizontalAlignment(int alignment): 设置文本对齐方式</li>
<li>setEditable(boolean b): 设置文本框是否可以编辑</li>
<li>boolean isFocusOwner()： 查看当前组件是否拥有焦点</li>
<li>setSelectionStart(int selectionStart)：设置光标开始位置</li>
<li>setSelectionEnd(int selectionEnd)： 设置光标结束位置</li>
<li>copy(): 复制选中文本</li>
<li>cut(): 剪切选中文本</li>
<li>paste(): 将复制/剪切得到的文本复制到文本框</li>
</ul>
<p><strong>监听器</strong></p>
<p>void addFocusListener(FocusListener listener)： 焦点事件监听器</p>
<p>textField.getDocument().addDocumentListener(DocumentListener listener)：文本框内文本改变监听器</p>
<p>void addKeyListener(KeyListener listener)：按键监听器</p>
<p>例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JTextField field;</span><br><span class="line">    <span class="keyword">private</span> JTextField log;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Calculate(<span class="built_in">String</span> text)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(text);</span><br><span class="line">        log = <span class="keyword">new</span> JTextField();</span><br><span class="line">        field = <span class="keyword">new</span> JTextField(<span class="number">8</span>);</span><br><span class="line">        field.setFont(<span class="keyword">new</span> Font(<span class="literal">null</span>, Font.PLAIN, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        field.setCaretColor(Color.BLUE);</span><br><span class="line">        field.setSelectionColor(Color.BLACK);</span><br><span class="line">        field.setSelectedTextColor(Color.GREEN);</span><br><span class="line">        field.setDisabledTextColor(Color.RED);</span><br><span class="line"></span><br><span class="line">        field.setHorizontalAlignment(SwingConstants.RIGHT);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line">        JButton button_copy = <span class="keyword">new</span> JButton(<span class="string">&quot;copy&quot;</span>);</span><br><span class="line">        JButton button_paste = <span class="keyword">new</span> JButton(<span class="string">&quot;paste&quot;</span>);</span><br><span class="line">        JButton button_cut = <span class="keyword">new</span> JButton(<span class="string">&quot;cut&quot;</span>);</span><br><span class="line">        JToggleButton button_enabled = <span class="keyword">new</span> JToggleButton(<span class="string">&quot;edit disable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        button_copy.addActionListener(<span class="keyword">new</span> actioncopy());</span><br><span class="line">        button_cut.addActionListener(<span class="keyword">new</span> actioncut());</span><br><span class="line">        button_paste.addActionListener(<span class="keyword">new</span> actionpaste());</span><br><span class="line">        button_enabled.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(field.isEditable())</span><br><span class="line">                &#123;</span><br><span class="line">                    button_enabled.setText(<span class="string">&quot;edit enable&quot;</span>);</span><br><span class="line">                    field.setEditable(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    button_enabled.setText(<span class="string">&quot;edit disable&quot;</span>);</span><br><span class="line">                    field.setEditable(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        panel.add(button_copy);</span><br><span class="line">        panel.add(button_cut);</span><br><span class="line">        panel.add(button_paste);</span><br><span class="line">        panel.add(button_enabled);</span><br><span class="line"></span><br><span class="line">        field.addFocusListener(<span class="keyword">new</span> FocusAdapter()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> focusGained(FocusEvent e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">super</span>.focusGained(e);</span><br><span class="line">                log.setText(<span class="string">&quot;your focus is in the text field&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        field.addFocusListener(<span class="keyword">new</span> FocusAdapter()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> focusLost(FocusEvent e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">super</span>.focusLost(e);</span><br><span class="line">                log.setText(<span class="string">&quot;yout focus is out of the text field&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        add(panel, BorderLayout.NORTH);</span><br><span class="line">        add(log, BorderLayout.SOUTH);</span><br><span class="line">        add(field, BorderLayout.CENTER);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        pack();</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">actioncopy</span> <span class="title">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">        &#123;</span><br><span class="line">            field.copy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">actioncut</span> <span class="title">implements</span>  <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">        &#123;</span><br><span class="line">            field.cut();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">actionpaste</span> <span class="title">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">        &#123;</span><br><span class="line">            field.paste();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Calculate(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swing3.PNG" alt="" /></p>
<h1 id="jlabel标签"><a class="markdownIt-Anchor" href="#jlabel标签"></a> JLabel标签</h1>
<p>标签主要用于展示文本和图片。</p>
<p>构造方法：</p>
<ul>
<li>JLabel()</li>
<li>JLabel(String text, int horizontalAlignment): text是文本，horizontalAlignment是对齐方式</li>
<li>JLabel(Icon Image): 图片</li>
<li>上面三种可以组合，也就是说可以同时显示图片和文本</li>
</ul>
<p>方法：</p>
<ul>
<li>setText(String text)</li>
<li>setIcon(Icon icon)</li>
</ul>
<p>// 设置文本相对于图片的位置（文本默认在图片右边垂直居中）</p>
<ul>
<li>void setHorizontalTextPosition(int textPosition)</li>
<li>void setVerticalTextPosition(int textPosition)</li>
</ul>
<p>// 设置标签内容（在标签内）的对其方式（默认左对齐并垂直居中）</p>
<ul>
<li>void setHorizontalAlignment(int alignment)</li>
<li>void setVerticalAlignment(int alignment)</li>
<li>setIconTextGap(int gap): 设置文本和图片之间的间隙</li>
</ul>
<p>构造方法中的图片还可以直接填URL从网络中获取。此外，Icon一般用的是ImageIcon</p>
<p>image实例创建</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一: 通过 java.awt.Toolkit 工具类来读取本地、网络 或 内存中 的 图片（支持 GIF、JPEG 或 PNG）</span></span><br><span class="line">Image image = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.get<span class="constructor">Image(String <span class="params">filename</span>)</span>;</span><br><span class="line">Image image = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.get<span class="constructor">Image(URL <span class="params">url</span>)</span>;</span><br><span class="line">Image image = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.create<span class="constructor">Image(<span class="params">byte</span>[] <span class="params">imageData</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二: 通过 javax.imageio.ImageIO 工具类读取本地、网络 或 内存中 的 图片（BufferedImage 继承自 Image）</span></span><br><span class="line">BufferedImage bufImage = <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>read(File input);</span><br><span class="line">BufferedImage bufImage = <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>read(URL input);</span><br><span class="line">BufferedImage bufImage = <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>read(InputStream input);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PS_01: 图片宽高: BufferedImage 可以通过 bufImage.getWidth() 和 bufImage.getHeight() 方法直接获取图片的宽高;</span></span><br><span class="line"><span class="comment"> *                 Image 获取宽高需要另外传入一个 ImageObserver 参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PS_02: 图片裁剪: BufferedImage 通过 bufImage.getSubimage(int x, int y, int w, int h) 方法可以截取图片的</span></span><br><span class="line"><span class="comment"> *                 任意一部分，返回一个新的 BufferedImage 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PS_03: 图片缩放: Image 通过 image.getScaledInstance(int width, int height, int hints) 方法可以对图片进行</span></span><br><span class="line"><span class="comment"> *                 缩放，返回新的一个 Image 实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/xietansheng/article/details/74362076">几乎照搬</a></p>
<p>例：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JLabel label ;</span><br><span class="line">    <span class="keyword">public</span> Calculate(<span class="keyword">String</span> text, <span class="keyword">String</span> image)</span><br><span class="line">    &#123;</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="type">JPanel</span>();</span><br><span class="line">        label = <span class="keyword">new</span> <span class="type">JLabel</span>(image);</span><br><span class="line">        label.setFont(<span class="keyword">new</span> <span class="type">Font</span>(<span class="literal">null</span>, Font.PLAIN, <span class="number">25</span>));</span><br><span class="line">        JLabel label2 = <span class="keyword">new</span> <span class="type">JLabel</span>();</span><br><span class="line">        label2.setIcon(<span class="keyword">new</span> <span class="type">ImageIcon</span>(<span class="string">&quot;D:\\截图\\捕获.PNG&quot;</span>));</span><br><span class="line">        label2.setText(<span class="string">&quot;only an image&quot;</span>);</span><br><span class="line">        label2.setHorizontalTextPosition(SwingConstants.CENTER);</span><br><span class="line">        label2.setVerticalTextPosition(SwingConstants.BOTTOM);</span><br><span class="line">        panel.add(label);</span><br><span class="line">        panel.add(label2);</span><br><span class="line">        add(panel);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        pack();</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Calculate</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;This is an image&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swing2.PNG" alt="" /></p>
<h1 id="jpasswordfield-密码框"><a class="markdownIt-Anchor" href="#jpasswordfield-密码框"></a> JPasswordField 密码框</h1>
<p>JPasswordField的构造方法和JTextField相同。</p>
<p>方法：</p>
<ul>
<li>char[] getpassword(): 获取输入的密码</li>
<li>setEchoChar(char c)： 设置默认显示的字符</li>
<li>setEditable()</li>
<li>setEnabled()</li>
</ul>
<p>常用的监听器和JTextField相同。</p>
<p><img src="/images/swing5.PNG" alt="" /></p>
<p>密码框的特点就是输入字符不可见</p>
<h1 id="jtextarea-文本区域"><a class="markdownIt-Anchor" href="#jtextarea-文本区域"></a> JTextArea 文本区域</h1>
<p>文本区域可以编辑多行文本。</p>
<p>构造方法：</p>
<ul>
<li>JTextArea(String text, int rows, int cols): 默认显示多少行多少列</li>
</ul>
<p>方法：</p>
<ul>
<li>setLineWrap(boolean b): 设置是否自动换行， 默认是false</li>
<li>setWrapStyleWord(boolean word)： 设置换行方式，如果是true，就在单词边界换行。如果是false，就在字符边界换行（也就是说到了上限就一定换行）</li>
<li>append(String str): 追加字符串到文末</li>
<li>replaceRange（String str, int start, int end): 替换文本</li>
<li>getLineCount()： 获取行数</li>
<li>getLineEndOfOffset(int line): 获取某一行行尾在文中偏移量</li>
<li>getLineOfOffset(int line)</li>
<li>setCaretColor(Color c)</li>
<li>setSelectionColor(Color c)</li>
<li>void setMinimum(int min)</li>
<li>void setMaximum(int max)</li>
<li>void setValue(int n)</li>
<li>setSelectedTextColor(Color c)</li>
<li>setDisabledTextColor(Color c)</li>
</ul>
<p>大致方法和监听器和JTextField相同</p>
<h1 id="jcombobox-下拉列表"><a class="markdownIt-Anchor" href="#jcombobox-下拉列表"></a> JComboBox 下拉列表</h1>
<p>下拉列表中选项内容由ComboBoxModel 实例来维护。</p>
<p>构造方法：</p>
<ul>
<li>JComboBox(ComboBoxModel model)</li>
<li>JComboBox(Object[] items)</li>
<li>JComboBox(Vector&lt;?&gt; items)</li>
</ul>
<p>ComboBoxModel 实例可以直接创建，也可以通过把 数组 或 集合 传递到 JComboBox 中间接创建。</p>
<p>常用方法：</p>
<ul>
<li>setSelectedIndex(int index)： 设置选中索引</li>
<li>getSelectedIndex(): 获得当前选中的索引</li>
<li>Object getSelectedItem()： 获得当前选中的数据项</li>
<li>setModel(ComboBoxModel&lt;?&gt; model)： 设置当前模型</li>
<li>ComboBoxModel&lt;?&gt; getModel()： 获得模型。再通过 model.getElementAt(int index) 和 model.getSize() 获得索引和选项数量</li>
<li>setEditable(boolean flag)： 设置是否可以编辑，默认false。如果设置成true，那么用户自己可以自行输入值。</li>
</ul>
<p>监听器：</p>
<ul>
<li>addItemListener(ItemListener listener)：选项选中状态改变</li>
</ul>
<p><img src="/images/swing6.PNG" alt="" /></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">comboBox.add<span class="constructor">ItemListener(<span class="params">new</span> ItemListener()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void item<span class="constructor">StateChanged(ItemEvent <span class="params">e</span>)</span> &#123;</span><br><span class="line">                <span class="comment">// 只处理选中的状态</span></span><br><span class="line">                <span class="keyword">if</span> (e.get<span class="constructor">StateChange()</span><span class="operator"> == </span>ItemEvent.SELECTED) &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;选中: &quot;</span> + comboBox.get<span class="constructor">SelectedIndex()</span> + <span class="string">&quot; = &quot;</span> + comboBox.get<span class="constructor">SelectedItem()</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="jlist-列表框"><a class="markdownIt-Anchor" href="#jlist-列表框"></a> JList 列表框</h1>
<p>列表框和下拉列表不同之处在于列表框一次把所有选项都显示并且可以多选（按ctrl），而下拉列表一次只能选择一个。同样内容有ListModel维护。</p>
<p>构造方法大致和JComboBox相同</p>
<p>方法：</p>
<ul>
<li>setListData(Object[] listData)： 设置列表元素</li>
<li>setListData(Vector&lt;?&gt; listData)</li>
<li>setModel(ListModel&lt;?&gt; model)</li>
<li>setSelectionMode(int selectionMode)：设置选择模式，有三种模式，单选，可间断多选，可连续多选。ListSelectionModel.MULTIPLE_INTERVAL_SELECTION，等。</li>
<li>setSelectedIndex(int index)： 设置某个选项被选中</li>
<li>setSelectedIndices(int[] indices)</li>
<li>getSelectedIndex()： 获得第一个被选中的索引</li>
<li>int[] getSelectedIndices()： 获得所有被选中的索引</li>
<li>setForeground(Color fg)： 未选中时字体颜色</li>
<li>setSelectionForeground(Color selectionForeground)：选中选项字体颜色</li>
<li>setSelectionBackground(Color selectionBackground)：选中条颜色</li>
</ul>
<p>监听器： addListSelectionListener(ListSelectionListener listener)。选项选中状态改变监听器</p>
<h1 id="jprograssbar-进度条"><a class="markdownIt-Anchor" href="#jprograssbar-进度条"></a> JPrograssBar 进度条</h1>
<p>当进度未知的时候，可以设置成不确定模式，不确定模式下也会持续显示动画。当确定就可以转换成确定模式。</p>
<p>构造方法：</p>
<ul>
<li>
<p>JPrograssBar(int orient, int min, int max): 进度条当前值，最大值，最小值。这些参量可以减少</p>
</li>
<li>
<p>void setMinimum(int min)</p>
</li>
<li>
<p>void setMaximum(int max)</p>
</li>
<li>
<p>void setValue(int n)：设置当前进度值</p>
</li>
<li>
<p>getValue()</p>
</li>
<li>
<p>getPercentComplete()： 获得当前进度百分比</p>
</li>
<li>
<p>setStringPainted(boolean b)： 是否以百分比显示文本</p>
</li>
<li>
<p>setIndeterminate(boolean newValue)： 是否设置成不确定模式</p>
</li>
<li>
<p>setOrientation(int newOrientation)： SwingConstants.VERTICAL 或 SwingConstants.HORIZONTAL</p>
</li>
<li>
<p>setMajorTickSpacing(int n)： 设置主刻度线间隔</p>
</li>
<li>
<p>setMinorTickSpacing(int n)： 设置主标记线内次标记线间隔</p>
</li>
<li>
<p>setPaintTicks(boolean b)： 是否绘制刻度线</p>
</li>
<li>
<p>setInverted(boolean b)： 是否让刻度值从大到小</p>
</li>
<li>
<p>setSnapToTicks(boolean b)： 是否让滑块对齐刻度。true滑块只能取刻度值</p>
</li>
<li>
<p>setLabelTable(Dictionary&lt;Integer, JComponent&gt; labels)：绘制特定的标签代替刻度值</p>
</li>
<li>
<p>setPaintTrack(boolean b)： 是否绘制滑道</p>
</li>
</ul>
<p>监听器：<code>addChangeListener(ChangeListener l)</code>: 进度改变监听器</p>
<p>例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Calculate(<span class="built_in">String</span> text)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(text);</span><br><span class="line">        JProgressBar progressBar = <span class="keyword">new</span> JProgressBar(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        progressBar.setValue(<span class="number">0</span>);</span><br><span class="line">        progressBar.setStringPainted(<span class="literal">true</span>);</span><br><span class="line">        progressBar.setIndeterminate(<span class="literal">false</span>);</span><br><span class="line">        progressBar.setOrientation(SwingConstants.HORIZONTAL);</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(<span class="literal">true</span>);</span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">            &#123;</span><br><span class="line">                progressBar.setValue(progressBar.getValue() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        timer.schedule(task, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">        add(progressBar);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Calculate(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就可以解释为什么进度条为什么忽快忽慢的了。当某一部分任务完成的时候就会设置进度条向前进。</p>
<h1 id="jslider"><a class="markdownIt-Anchor" href="#jslider"></a> JSlider</h1>
<p>通过滑块来选择不同的值。当鼠标焦点移到滑块上时，也可以通过上下左右移动滑块。</p>
<p>构造方法 ：</p>
<ul>
<li>JSlider(int orientation): 滑块方向，有SwingConstants.HORIZONAL和SwingConstants.VERTICAL.</li>
<li>JSlider(int min, int max): 滑块初始值可以是min到max中间任意一个值。</li>
<li>JSlider(int orientation, int min, int max, int value)</li>
</ul>
<p>方法：</p>
<ul>
<li>void setMinimum(int min)</li>
<li>void setMaximum(int max)</li>
<li>void setValue(int n)</li>
<li>setMajorTickSpacing(int n)： 设置主刻度线间隔</li>
<li>setMinorTickSpacing(int n)： 设置主标记线内次标记线间隔</li>
<li>setPaintTicks(boolean b)： 是否绘制刻度线</li>
<li>setPaintLabels(boolean b): 是否绘制标签</li>
<li>setInverted(boolean b)： 是否让刻度值从大到小</li>
<li>setSnapToTicks(boolean b)： 是否让滑块对齐刻度。true滑块只能取刻度值</li>
<li>setLabelTable(Dictionary&lt;Integer, JComponent&gt; labels)：绘制特定的标签代替刻度值。Integer是刻度值，JComponent可以使JLabel等。</li>
<li>setPaintTrack(boolean b)： 是否绘制滑道</li>
<li>setOrientation(int orientation)： 方向</li>
</ul>
<p>监听器：<code>addChangeListener(ChangeListener l)</code>: 滑道值改变监听</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">text</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(text);</span><br><span class="line">        JTextField textField = <span class="keyword">new</span> <span class="constructor">JTextField()</span>;</span><br><span class="line">        JSlider slider = <span class="keyword">new</span> <span class="constructor">JSlider(0, 20)</span>;</span><br><span class="line"></span><br><span class="line">        slider.set<span class="constructor">MajorTickSpacing(5)</span>;</span><br><span class="line">        slider.set<span class="constructor">MajorTickSpacing(1)</span>;</span><br><span class="line">        slider.set<span class="constructor">Orientation(SwingConstants.HORIZONTAL)</span>;</span><br><span class="line">        slider.set<span class="constructor">PaintLabels(<span class="params">true</span>)</span>;</span><br><span class="line">        slider.set<span class="constructor">PaintTrack(<span class="params">true</span>)</span>;</span><br><span class="line">        slider.set<span class="constructor">PaintTicks(<span class="params">true</span>)</span>;</span><br><span class="line">        slider.set<span class="constructor">SnapToTicks(<span class="params">true</span>)</span>;</span><br><span class="line">        Hashtable&lt;Integer, JComponent&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;Integer, JComponent&gt;<span class="literal">()</span>;</span><br><span class="line">        hashtable.put(<span class="number">0</span>, <span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">&quot;Start&quot;</span>)</span>);      <span class="comment">//  0  刻度位置，显示 &quot;Start&quot;</span></span><br><span class="line">        hashtable.put(<span class="number">10</span>, <span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">&quot;Middle&quot;</span>)</span>);    <span class="comment">//  10 刻度位置，显示 &quot;Middle&quot;</span></span><br><span class="line">        hashtable.put(<span class="number">20</span>, <span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">&quot;End&quot;</span>)</span>);       <span class="comment">//  20 刻度位置，显示 &quot;End&quot;</span></span><br><span class="line">        slider.set<span class="constructor">LabelTable(<span class="params">hashtable</span>)</span>;</span><br><span class="line">        slider.add<span class="constructor">ChangeListener(<span class="params">new</span> ChangeListener()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void state<span class="constructor">Changed(ChangeEvent <span class="params">changeEvent</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                textField.set<span class="constructor">Text(<span class="string">&quot;now is &quot;</span> + <span class="params">slider</span>.<span class="params">getValue</span>()</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        add(slider);</span><br><span class="line">        add(textField, BorderLayout.SOUTH);</span><br><span class="line"></span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">        pack<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">&quot;Hello&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="robot-模拟鼠标键盘输入"><a class="markdownIt-Anchor" href="#robot-模拟鼠标键盘输入"></a> Robot 模拟鼠标，键盘输入</h1>
<p>这个类主要是为了方便自动测试</p>
<p>构造方法：</p>
<ul>
<li>Robot(GraphicsDevice screen)： 给指定屏幕创建一个对象</li>
<li>Robot(): 给默认屏幕创建一个对象</li>
</ul>
<p>方法：</p>
<ul>
<li>mouseMove(int x, int y)： 把鼠标移动到某个位置</li>
<li>mousePress(int buttons)： 按下某个键。有InputEvent.BUTTON1_MASK （鼠标左键）和InputEvent.BUTTON2_MASK （鼠标中键）和   InputEvent.BUTTON3_MASK （鼠标右键）</li>
<li>mouseRelease(int buttons)</li>
<li>mouseWheel(int wheelAmt)：旋转滚轮</li>
</ul>
<p>键盘输入：</p>
<ul>
<li>keyPress(int keycode)： keycode定义在KeyEvent.VK_xxx中</li>
<li>keyRelease(int keycode)</li>
</ul>
<p>屏幕相关：</p>
<ul>
<li>Color getPixelColor(int x, int y)： 获得像素颜色</li>
<li>BufferedImage createScreenCapture(Rectangle screenRect)： 截屏</li>
</ul>
<p>控制：</p>
<ul>
<li>delay(int ms)： 睡眠指定时间</li>
<li>waitForIdle()： 在当前队列中时间完成之前一直等待</li>
<li>setAutoWaitForIdle(boolean isOn)： 生成一个事件之后是否自动调用waitForIdle</li>
<li>boolean isAutoWaitForIdle()： 设置为true，按次序执行</li>
<li>setAutoDelay(int ms)： 每个事件完成后自动等待ms秒。</li>
<li>int getAutoDelay()</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">一般测试步骤</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws AWTException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Robot 实例</span></span><br><span class="line">        Robot robot = <span class="keyword">new</span> Robot();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行完一个事件后再执行下一个</span></span><br><span class="line">        robot.setAutoWaitForIdle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动鼠标到指定屏幕坐标</span></span><br><span class="line">        robot.mouseMove(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按下鼠标左键</span></span><br><span class="line">        robot.mousePress(InputEvent.BUTTON1_MASK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延时100毫秒</span></span><br><span class="line">        robot.<span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放鼠标左键（按下后必须要释放, 一次点击操作包含了按下和释放）</span></span><br><span class="line">        robot.mouseRelease(InputEvent.BUTTON1_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java I/O</title>
    <url>/post/5be7e977.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<p>java.io.InputStream代表字节输入流，java.io.OutputStream代表输出流。他们都是抽象类，InputStream中有以下方法：</p>
<ul>
<li>int read():读入一个字节，并且转化成unsigned int型整数</li>
<li>int read(byte[] b): 从输入流中读取若干字节，保存在b数组中。如果到了输入流的结尾，返回1</li>
<li>int read(byte[] b, int off, int len): 如上，这里只是多了在b数组中的开始位置和读取数目</li>
<li>void close()： 关闭输入流。如果不关闭的话其他需要这个文件的就无法读取这个文件信息。类似于打开了一个应用程序再打开就说有一个实例正在运行。</li>
<li>int available(): 放回从输入流中读取字节数目</li>
<li>skip(long n): 从输入流中跳过n个字节</li>
<li>boolean markSupported(),void mark(int readLimit), void reset(): 如果想要重复读入数据，就先用markSupported()判断这个流是否支持重复读入数据，如果支持，通过mark在当前位置开始设置readLimit字节的标记，然后用reset()可以使输入流定位到做标记的起始位置，然后通过read()就可以重复读数据了。</li>
</ul>
<p>OutputStream中方法：</p>
<ul>
<li>void write(): 输出一个字节</li>
<li>void write(byte[] b): 同上</li>
<li>void write(byte[] b, int off, int len): 同上</li>
<li>void close()</li>
<li>void flush(): OutputStream本身的flush()不执行操作。但是如果是一些有缓冲区机制的实现类就有用了。在有缓冲区的输出流中，一般都是先把输出存在缓冲区中，等到了一定大小才会输出，<strong>这个方法的作用是强制输出缓冲区中数据</strong>。</li>
</ul>
<p>设置缓冲区的原因是输出并不是直接输出到屏幕中间要经历一系列的过程，耗时比较长，如果先存到缓冲区然后一次性输出就可以减少时间。</p>
<h1 id="输入流"><a class="markdownIt-Anchor" href="#输入流"></a> 输入流</h1>
<h2 id="bytearrayinputstream字节数组输入流"><a class="markdownIt-Anchor" href="#bytearrayinputstream字节数组输入流"></a> ByteArrayInputStream,字节数组输入流</h2>
<p>这个类从字节数组读取数据，可能会想直接用字符数组不就行了吗，为什么还要弄一个输入流类。ByteArrayInputStream实际上是一个<a href="https://xinhecuican.github.io/post/5951da65.html">适配器</a></p>
<p>构造方法：</p>
<p>ByteArrayInputStream(byte[] buf)</p>
<p>ByteArrayInputStream(byte[] buf, int offset, int length)</p>
<p>使用就是用上面的方法</p>
<h2 id="fileinputstream文件输入流"><a class="markdownIt-Anchor" href="#fileinputstream文件输入流"></a> FileInputStream文件输入流</h2>
<p>构造方法：</p>
<p>FileInputStream(File file)</p>
<p>FileInputStream(String name):通过name指定路径</p>
<p>例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamTester</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span>((data=in.<span class="built_in">read</span>()) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(data+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果文件很大，为了提高读取效率，可以利用一个缓冲区。例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">1024</span>;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FIleOutputStream(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">        <span class="keyword">int</span> len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        <span class="keyword">while</span>(len != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out.<span class="built_in">write</span>(buff, <span class="number">0</span>, len);</span><br><span class="line">            len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">        out.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要打开的文件和这个类在同一文件夹下，可以用Class类的个体ResourceAsStream()方法,<strong>这时可以用相对路径</strong>。例如：</p>
<p><code>InputStream in = UseBuffer.getClass().getResourceAsStream(&quot;test.txt&quot;);</code></p>
<h2 id="pipedinputstream管道输入流"><a class="markdownIt-Anchor" href="#pipedinputstream管道输入流"></a> PipedInputStream管道输入流</h2>
<p>管道输入流是从管道输出流中读取数据的。一般是一个线程从管道中输出，然后另外一个接受。使用管道的优点是如果管道中没有数据就会阻塞，有数据才会恢复运行，这样就可以对产生的数据进行处理。</p>
<p>例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Sender <span class="keyword">extends</span> Thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PipedOnputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">    <span class="keyword">public</span> PipedOutputStream getPipedOutputStream()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i=-<span class="number">127</span>; i&lt;=<span class="number">128</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">                <span class="keyword">yield</span>();<span class="comment">//让步给sender处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedInputStream <span class="keyword">in</span>;</span><br><span class="line">        <span class="keyword">public</span> Receiver(Sender sender)<span class="keyword">throw</span> IOException</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过这个构造方法确定了两者的关系</span></span><br><span class="line">            <span class="keyword">in</span> = <span class="keyword">new</span> PipedInputStream(sender.getPepedOutputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">        &#123;</span><br><span class="line">            int data;</span><br><span class="line">            <span class="keyword">while</span>((data=<span class="keyword">in</span>.read()) != -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(data):</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">in</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="sequenceinputstream-顺序输入流"><a class="markdownIt-Anchor" href="#sequenceinputstream-顺序输入流"></a> SequenceInputStream 顺序输入流</h2>
<p>它可以把几个输入流混合到一起输入。</p>
<p>构造方法：</p>
<p>SequenceInputStream(Enumeration e): e是枚举类型，包含若干个输入流</p>
<p>SequenceInputStream(InputStream s1, InputStream s2):只合并两个</p>
<p>它关闭的时候只需要关闭SequenceInputStream就会一次关闭所有的输入流。</p>
<h2 id="装饰器设计模式"><a class="markdownIt-Anchor" href="#装饰器设计模式"></a> 装饰器设计模式</h2>
<p>假设有一个类要子类实现三种方法，并且有的子类只需要实现一个，有的要实现多个，那么就要2^3-1个子类，数量过多。我们可以采用装饰器思想减少子类数目。</p>
<p>装饰器也是一个子类。这个子类的特殊之处在于他实现了某一个方法并且它内部封装了父类的实例。它的构造方法是：<code>decorate(Base base)</code></p>
<p>例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">B </span><span class="keyword">extends </span>A</span><br><span class="line"></span><br><span class="line"><span class="keyword">B </span><span class="keyword">b </span>= new <span class="keyword">B();</span></span><br><span class="line"><span class="keyword">decorate1 </span>dec1 = new decorate1(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec1.method1();</span></span><br><span class="line"><span class="keyword">decorate2 </span>dec2 = new decorate2(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec2.method2();</span></span><br></pre></td></tr></table></figure>
<h2 id="filterinputstream-过滤输入流"><a class="markdownIt-Anchor" href="#filterinputstream-过滤输入流"></a> FilterInputStream 过滤输入流</h2>
<p>过滤输入流其实就是一个装饰器</p>
<p><strong>种类</strong></p>
<table>
<thead>
<tr>
<th>过滤输入流</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataInputStream</td>
<td>与DataOutputStream搭配使用，按照和平台无关的方式从流中读取基本类型（int，char，long等）</td>
</tr>
<tr>
<td>BufferedInputStream</td>
<td>利用缓冲区提高效率</td>
</tr>
<tr>
<td>PushbackInputStream</td>
<td>把督导的一个字节压回缓冲区中，编译器用</td>
</tr>
</tbody>
</table>
<p>这些都是FileterInputStream的子类,并且也是装饰器。</p>
<h3 id="datainputstream类"><a class="markdownIt-Anchor" href="#datainputstream类"></a> DataInputStream类</h3>
<p>它的不同方法可以按不同编码读取数据，并且都是以read开头：</p>
<ul>
<li>readByte()</li>
<li>readLong()</li>
<li>readFloat()</li>
<li>readUTF(): 从输入流中读取若干字节，并转化成UTF-8编码字符串</li>
</ul>
<p>UTF-8如果是ascii就只用一个字节，如果是其他字符就用两个或两个以上字节。</p>
<p>DataInputStream应该和DataOutputStream配套使用。只有配套使用才会保证数据的正确性（因为这里的UTF-8是java本土化的UTF-8,本来的UTF-8好像是稳定3个字节的）。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileOutputStream out1 = <span class="keyword">new</span> <span class="type">FileOutputStream</span>();</span><br><span class="line">        BufferedOutputStream out2 = <span class="keyword">new</span> <span class="type">BufferedOutputStream</span>(out1);</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> <span class="type">DataOutputStream</span>(out2);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bufferedinputstream"><a class="markdownIt-Anchor" href="#bufferedinputstream"></a> BufferedInputStream</h3>
<p>BufferedInputStream覆盖了读数据的行为，它利用缓冲区提高读取的效率。</p>
<p>构造方法：</p>
<ul>
<li>BufferedInputStream(InputStream in)</li>
<li>BufferedInputStream(InputStream in, int size):size指定缓冲区大小</li>
</ul>
<p>当数据源是文件时，可以用BufferedInputStream装饰数据流，然后再进行其他操作可以提高效率。</p>
<h3 id="pushbackinputstream"><a class="markdownIt-Anchor" href="#pushbackinputstream"></a> PushbackInputStream</h3>
<p>它有一个后推缓冲区，用于存放已经读入的字节。</p>
<h1 id="输出流"><a class="markdownIt-Anchor" href="#输出流"></a> 输出流</h1>
<p>输出流种类和输入流大致类似，sequenceInputStream对应的没有了，多了ObjectOutputStream。</p>
<p>ByteArrayOutputStream是把信息输出到字节数组中。例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        out.<span class="built_in">write</span>(<span class="string">&quot;你好&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//String的getBytes可以放回制定类型的编码</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = out.toByteArray();<span class="comment">//获得字符数组的方法</span></span><br><span class="line">        out.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先用write把要输入的数据输入到输出流中，然后通过toByteArray方法输出到字节数组中。</p>
<p><strong>文件输出流</strong></p>
<p>前面大致类似，多了一种构造方法<code>FileOutputStream(String name, boolean append)</code></p>
<p>其中append是为了确定是不是要在末尾追加数据。</p>
<h2 id="filteroutputstream-过滤输出流"><a class="markdownIt-Anchor" href="#filteroutputstream-过滤输出流"></a> FilterOutputStream 过滤输出流</h2>
<p>同样有DataOutputStream和BufferedOutputStream，大致和输入流类似，多了一种PrintStream类</p>
<h3 id="printstream"><a class="markdownIt-Anchor" href="#printstream"></a> PrintStream</h3>
<p>PrintStream和DataOutputStream类似，都可以输出格式化数据。他有如下方法。</p>
<ul>
<li>print(int i): 输出一个int</li>
<li>print(float i):</li>
<li>print(String i):</li>
<li>println(int i): 输出int型数据和换行符</li>
<li>println(float f):</li>
<li>println(String s):</li>
</ul>
<p>前面提到过，DataOutputStream和DataInputStream最好匹配使用是因为他们使用了特殊化的UTF-8编码。而PrintStream使用的是普通的UTF-8编码。</p>
<p>PrintStream的print()没有抛出IOException，但是他有checkError()判断写数据是否成功，如果返回true，则代表出现了错误。</p>
<p>PrintStream自带缓冲区。但是这和BufferedInputStream提供的缓冲区还有所不同。后者只有缓冲区满的时候才会输出，前者可以由用户决定数据量多少的时候输出。当然，默认还是满的时候输出。PrintStream还提供了一个自动化的输出方案：</p>
<ul>
<li>PrintStream(OutputStream out, boolean autoFlash)。当满足以下情况就会自动输出
<ul>
<li>输出一个字节数组</li>
<li>输出一个换行符，即执行print(&quot;\n&quot;)或println()</li>
</ul>
</li>
</ul>
<h1 id="readerwriter"><a class="markdownIt-Anchor" href="#readerwriter"></a> Reader/Writer</h1>
<p>InputStream和OutputStream处理的是字节，但是在很多场合要处理的是字符（java中字符时2字节）。Reader和Writer就是处理这些的。</p>
<p>java中字符时Unicode编码，但是文本文件中不一定是Unidcode编码，还有可能是UTF-8，GBK甚至ascii，因此如何处理不同类型编码就是一个难点。</p>
<p>String的getBytes(String encode)返回特定类型的编码，encode参数指定编码类型。如果不带参数就使用本地操作系统默认编码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">获得本地编码</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">&quot;file.encoding&quot;</span>)</span>);</span><br><span class="line">或：</span><br><span class="line">Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(cs);</span><br></pre></td></tr></table></figure>
<p>Reader类可以把其他类型的编码转换成java所使用的编码。Writer可以把Unicode转换成其他类型的编码。</p>
<h2 id="reader"><a class="markdownIt-Anchor" href="#reader"></a> Reader</h2>
<p>Reader和InputStream类的种类大致类似.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CharArrayReader</td>
<td>把字符数组转换成Reader，从字符数组中读取字符</td>
</tr>
<tr>
<td>BufferedReader</td>
<td>装饰器，提供缓冲区。同时他的readLine()方法还可以读入一个字符串</td>
</tr>
<tr>
<td>LineNumberReader</td>
<td>提供缓冲区。并且可以跟踪字符输入流中中的行号</td>
</tr>
<tr>
<td>StringReader</td>
<td>把字符串转成Reader（数据源是字符串，和CharArrayReader类似），从字符串中读字符</td>
</tr>
<tr>
<td>PipedReader</td>
<td>连接PipedWriter</td>
</tr>
<tr>
<td>FilterReader</td>
<td>扩展其他Reader功能</td>
</tr>
<tr>
<td>InputStreamReader</td>
<td>把InputStream转换成Reader，可以指定数据源编码</td>
</tr>
<tr>
<td>FileReader</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="inputstreamreader"><a class="markdownIt-Anchor" href="#inputstreamreader"></a> InputStreamReader</h3>
<p>构造方法：</p>
<ul>
<li>InputStreamReader(InputStream in): 按照本地的字符编码解读输入流中的字符</li>
<li>InputStreamReader(InputStream in, String charsetName): 按照charsetName指定的方式读取输入流中的字符</li>
</ul>
<p>这里的read读出来的不是一个字节而是一个字符</p>
<p>一些常用的方法：</p>
<ul>
<li>readLine(),一次读入一行</li>
<li>readFile(String fileName, String charsetName):从文件中读取字符串，并输出到控制台中</li>
<li>copyFile(String from, String charsetFrom, String to, String charsetTo): 把原文件复制到目标文件中，可以指定文件编码</li>
</ul>
<h2 id="writer"><a class="markdownIt-Anchor" href="#writer"></a> Writer</h2>
<p>Writer和OutputStream大致类似，也有PrintWriter,区别是PrintStream只能用系统本地编码，而PrintWriter可以使用任意编码。PrintWriter构造方法：</p>
<ul>
<li>PrintWriter(Writer writer, boolean autoFlush)</li>
<li>PrintWriter(OutputStream out, boolean autoFlush)</li>
</ul>
<h1 id="标准io"><a class="markdownIt-Anchor" href="#标准io"></a> 标准I/O</h1>
<p>在System类中，有三个静态变量：</p>
<ul>
<li><a href="http://System.in">System.in</a>: 代表标准输入流。默认输入时键盘</li>
<li>System.out: 是PrintStream类型（所以方法和PrintStream一样）。</li>
<li>System.err: 代表错误输出流，默认输出时输出到控制台。</li>
</ul>
<h2 id="对标准输入输出包装"><a class="markdownIt-Anchor" href="#对标准输入输出包装"></a> 对标准输入输出包装</h2>
<p>可以利用到前面所学的只是对标准输入输出进行包装。System.in是InputStream类型，可以先用InputStreamReader变成Reader，然后在用BufferedReader装饰。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> <span class="constructor">InputStreamReader(System.<span class="params">in</span>)</span>;</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> <span class="constructor">BufferedReader(<span class="params">reader</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向</h2>
<p>重定向方法：</p>
<ul>
<li>setIn(InputStream, in): 对标准输入重定向</li>
<li>setOut(printStream out):</li>
<li>setErr(PrintStream out):</li>
</ul>
<p>这些方法时System的静态方法，所以写的时候是System.setIn()</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void redirect(InputStream <span class="keyword">in</span>, PrintStream out, PrintStream err)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">In(<span class="params">in</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Out(<span class="params">out</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Err(<span class="params">err</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String<span class="literal">[]</span> args)throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    InputStream stdin = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span><span class="keyword">in</span>;</span><br><span class="line">    PrintStream stdout = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out;</span><br><span class="line">    PrintStream stderr = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>err;</span><br><span class="line">    InputStream <span class="keyword">in</span> = <span class="keyword">new</span> <span class="constructor">BufferedInputStream(<span class="string">&quot;D:\\temp.txt&quot;</span>)</span>;</span><br><span class="line">    PrintStream out = <span class="keyword">new</span> <span class="constructor">BufferedOutputStream(<span class="string">&quot;D:\\tempout.txt&quot;</span>)</span>;</span><br><span class="line">    redirect(<span class="keyword">in</span>, out, stderr);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="randomaccessfile-随机访问文件"><a class="markdownIt-Anchor" href="#randomaccessfile-随机访问文件"></a> RandomAccessFile 随机访问文件</h1>
<p>随机访问文件就是可以从文件任意位置读写数据，他有如下定位方法：</p>
<ul>
<li>getFilePointer(): 返回当前位置</li>
<li>seeek(long pos): 设置位置，与未见开头相距pos</li>
<li>skipBytes(int n): 从当前开始跳过n个字节</li>
<li>length(): 返回文件包含的字节数</li>
</ul>
<p>RandomAccessFile实现了DataInput和DataOutput接口，可以读取格式化数据；</p>
<ul>
<li>RandomAccessFile(File file, String mode)</li>
<li>RandomAccessFile(String name, String mode):name指定路径</li>
</ul>
<p>其中mode是访问模式，可以有&quot;r&quot;和&quot;rw&quot;。表示只读和读写，但是&quot;w&quot;是非法的。</p>
<h1 id="新-io库"><a class="markdownIt-Anchor" href="#新-io库"></a> 新 I/O库</h1>
<p>这些类位于java.nio包中，nio是newio。他映入了四个数据类型</p>
<ul>
<li>Buffer： 缓冲区</li>
<li>Charset： 把Unicode和其他类型相互转换</li>
<li>Channel： 数据传送通道，把Buffer内容输出或读入到Buffer</li>
<li>Selector： 支持异步I/O操作，也叫非阻塞I/O操作</li>
</ul>
<h2 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> Buffer</h2>
<p>缓冲区有两个作用：</p>
<ul>
<li>减少读取次数</li>
<li>和<a href="https://xinhecuican.github.io/post/7d1c86da.html">高速缓存</a>有关，这一段内存一直被重用。</li>
</ul>
<p>层次：<br />
<img src="/images/java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.jpg" alt="" /></p>
<p>他有以下属性：</p>
<ul>
<li>容量</li>
<li>极限： 表示当前所使用缓冲区大小.极限可以修改</li>
<li>位置： 表示<strong>下一个</strong>读写单元位置</li>
</ul>
<p>他有如下设置属性方法：</p>
<ul>
<li>clear(): 把极限设置成容量，并且把位置变成0</li>
<li>flip(): 把极限设置成位置，然后把位置变成0</li>
<li>rewind(): 不改变极限，把位置变成0</li>
</ul>
<p>Buffer类是一个抽象类，他有8个具体类。最基本的是ByteBuffer类，他没有公开构造方法，但是有静态工厂。</p>
<ul>
<li>allocate(int capacity):</li>
<li>directAllocate(int capacity): 返回一个直接缓冲区。直接缓冲区速度较快，但是分配所需时间较多，所以一般只在所需空间较大并且长期使用的情况下才会用它。</li>
</ul>
<p>除了boolean类型之外，其他类型都有缓冲区（感觉和c的allocate有点类似），例如LongBuffer。此外，还有一种MappedByteBuffer，这是ByteBuffer的子类。它可以把缓冲区和文件某个区域直接映射（输出）。</p>
<p>共用方法：</p>
<ul>
<li>get(): 从当前位置读一个单元，然后位置加*ex位置读一个单元</li>
<li>put(): 向当前位置写入一个数据，然后位置加1</li>
<li>put(int index):</li>
</ul>
<h2 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h2>
<p>Channel用来连接缓冲区和数据源。它是一个接口，有两个方法：</p>
<ul>
<li>close(): 关闭通道</li>
<li>isOpen(): 判断通道是否打开</li>
</ul>
<p>通道会在创建时被打开，一旦被关闭就不能再次打开。</p>
<p>子接口ReadableByteChannel声明了read(ByteBuffer dst),把数据源数据读入到缓冲区中。WritableByteChannel声明了write(ByteBuffer src)，这个把src缓冲区中的数据输出。</p>
<p>ByteChannel扩展了上面说的两个接口，可以同时读写</p>
<p>ScatteringByteChannel扩展了ReadableByteChannel，可以分散读取数据。分散读取是指可以一次把数据放到多个缓冲区中。</p>
<p>GatheringByteChannel接口扩展了WritableByteChannel,可以把多个缓冲区中的数据一次性输出。他的wirte(ByteBuffer[] srcs)用来输出数据。</p>
<p><strong>这些方法都是缓冲区没满就继续读入</strong></p>
<p>FileChannel是Channel的实现类，他实现了ByteChannel，ScatteringByteChannel，GatheringByteChannel接口。支持上面所有操作。但是他没有公开构造方法，但是FileInputStream，FileOutputStream，RandomAccessFile类中提供了getChannel()方法，返回相应的FileChannel对象。</p>
<h2 id="charset"><a class="markdownIt-Anchor" href="#charset"></a> Charset</h2>
<p>Charset类每个实例代表特定的字符编码类型。他有以下用于编码转换的方法：</p>
<ul>
<li>ByteBuffer encode(String str): 把str转换成当前编码</li>
<li>ByteBuffer encode(CharBuffer cb): 把cb指定的字符缓冲区变成当前编码</li>
<li>CharBuffer decode(ByteBuffer bb): 把bb指定的ByteBuffer变成Unicode编码</li>
</ul>
<p>Charset有一个defaultCharset(): 返回代表本地平台编码的Charset对象。</p>
<h2 id="filechannel读写文件"><a class="markdownIt-Anchor" href="#filechannel读写文件"></a> FileChannel读写文件</h2>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">&#123;</span><br><span class="line">    final <span class="built_in">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    FileChannel fc = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="string">&quot;D:\\temp.txt&quot;</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">&quot;你好&quot;</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//向文件末尾添加</span></span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">RandomAccessFile(<span class="string">&quot;D:\\temp.txt&quot;</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.position(fc.size<span class="literal">()</span>);<span class="comment">//定位到文件末尾</span></span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">&quot;朋友&quot;</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    </span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="string">&quot;D:\\temp.txt&quot;</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    ByteBuffer buff = <span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>allocate(BSIZE);</span><br><span class="line">    fc.read(buff);</span><br><span class="line">    buff.flip<span class="literal">()</span>;</span><br><span class="line">    Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(cs.decode(buff));</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2>
<p><strong>控制缓冲区</strong></p>
<p>前面说的clear(),flip，rewind看似没用，但是它可以方便我们读入输出数据</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">buff </span>= <span class="keyword">ByteBuffer.allocate(BSIZE);</span></span><br><span class="line"><span class="keyword">while(in.read(buff) </span>!= -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">buff.flip();</span></span><br><span class="line"><span class="keyword"> </span>   out.write(<span class="keyword">buff);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">buff.clear();</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这段代码前面的flip是为了保证只操作当前数据，而clear()是为了保证接受尽可能多的数据。</p>
<p><strong>字符编码转换</strong></p>
<p>CharBuffer存放的数据单元室Unicode字符，ByteBuffer中的asCharBuffer()可以把Byte中数据转换成Unicode字符，并且存放在CharBuffer中。</p>
<h2 id="缓冲区视图"><a class="markdownIt-Anchor" href="#缓冲区视图"></a> 缓冲区视图</h2>
<p>ByteBuffer类提供了asCharBuffer(),asIntBuffer(),和asFloatBuffer()来生成视图。通过视图，可以读取或写入各种类型的数据。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span>(bb.hasRemaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    bb.rewind();</span><br><span class="line">    CharBuffer cb = bb.asCharBuffer();</span><br><span class="line">    cb.<span class="built_in">put</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    whlie(bb.hasremaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mappedbytebuffer"><a class="markdownIt-Anchor" href="#mappedbytebuffer"></a> MappedByteBuffer</h2>
<p>用于创建和修改那些因为太大而不能放入内存的文件。</p>
<p>FIleChannel类提供了获得MappedByteBuffer的map方法：</p>
<ul>
<li>MappedByteBuffer map(FIleChannel.MapMode mode, long position, long size)</li>
</ul>
<p>position是文件映射起始位置，size是映射区域大小，mode是模式，有三种：</p>
<ul>
<li>MapMode.READ_ONLY</li>
<li>READ_WRITE</li>
<li>MapMode.PRIVATE: 对MappedByteBuffer的修改不会保存到文件中，且其他程序不可见。</li>
</ul>
<p>例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">0x8000000</span>;</span><br><span class="line">    MappedByteBuffer mb = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D:\\test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>).getChannel()</span><br><span class="line">    .<span class="built_in">map</span>(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, capacity);</span><br><span class="line">    mb.flip();</span><br><span class="line">    System.out.<span class="built_in">println</span>(Charset.forName(<span class="string">&quot;GBK&quot;</span>).decode(mb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件加锁"><a class="markdownIt-Anchor" href="#文件加锁"></a> 文件加锁</h2>
<p>他允许程序同步访问作为共享资源的文件，但是可能发生同一时间多个线程同时访问的情况，甚至还有可能要和其他进程竞争。所以java中的文件锁是其他线程可见的。</p>
<p>FileChannel的tryLock()或Lock()用于锁定文件，如果成功放回FileLock对象，如果不成功就立刻返回null。lock()是阻塞式的，如果没有获得线程就会进入阻塞状态。</p>
<p>也可以部分加锁</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br><span class="line">lock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br></pre></td></tr></table></figure>
<p>上面的shared如果为true表示共享锁，如果是false是排他锁。</p>
<ul>
<li>共享锁，如果一个线程获得了共享锁，那么其他线程还可以获得共享锁，但是不能获得排他锁</li>
<li>排他锁，如果一个县城获得了排他锁，那么其他线程不可以获得共享锁或排他锁。</li>
</ul>
<p>可以用FileLock的isShared()判断锁的类型，如果是true，则是共享锁。release()用于释放文件锁。</p>
<h1 id="自动释放资源"><a class="markdownIt-Anchor" href="#自动释放资源"></a> 自动释放资源</h1>
<p>因为和c++中的delete一样，经常会忘了close(),所以从JDK7开始，绝大多数I/O类都实现了AutoCloseable接口。他会在一定条件下自动关闭：</p>
<ul>
<li>定义在try块中，退出try块时会自动调用close()(无论是正常出去还是非正常退出）。</li>
</ul>
<h1 id="用file来查看创建删除文件目录"><a class="markdownIt-Anchor" href="#用file来查看创建删除文件目录"></a> 用File来查看，创建，删除文件目录</h1>
<p>File表示真实系统中的一个文件，他有如下构造方法：</p>
<ul>
<li>File(String pathname):</li>
<li>File(String parent, String child):parent表示根路径，child表示子路径。</li>
<li>File(File parent, String child)</li>
</ul>
<p>一般来说，如果只要处理一个文件，那么使用第一种构造方法，否则就用后面几种。</p>
<p>还提供管理文件方法：</p>
<ul>
<li>boolean canRead().测试程序是否能对进行读操作</li>
<li>boolean canWrite()</li>
<li>boolean delete():删除文件，如果删除的是目录并且目录中有东西就不能删除</li>
<li>boolean exists():看这个文件时候存在</li>
<li>String getAbsolutePath():获取文件绝对目录</li>
<li>String getChanonicalPath(): 获取真正的路径，没有<code>.</code>和<code>..</code></li>
<li>String getName()</li>
<li>String getParent()</li>
<li>String getPath(): 相对目录</li>
<li>String[] list(): 返回当前目录下所有文件列表</li>
<li>File[] listFiles().返回目录下的所有文件和目录的File对象</li>
<li>boolean mkdir(): 创建目录</li>
<li>boolean createNewFile(): 如果FIle表示文件且在当前目录下不存在，就创建</li>
</ul>
<h2 id="操作目录树"><a class="markdownIt-Anchor" href="#操作目录树"></a> 操作目录树</h2>
<p>Files类： 有移动文件的move(),复制文件的copy()，搜索目录树的find().此外newDirectoryStream()回创建一个目录流，程序可以通过这个目录流遍历整个目录，用walkFileTree()遍历。</p>
<p>Path接口： 表示一个路径。</p>
<p>Paths类： 提供创建Path的静态方法，他的get(String first, String… more)返回一个Path对象，这个对象以first为根路径，以more为子路径.例如：<code>Paths.get(&quot;/root&quot;, &quot;dir1&quot;, &quot;dir2&quot;)</code>返回路径<code>/root/dir1/dir2</code>.</p>
<p><strong>查看zip</strong></p>
<p>可以通过FileSystems的newFileSystem()创建表示zip文件的FileSystem对象。然后可以用walkFileTree()遍历zip中所有文件。</p>
<p>其中walkFileTree可以查看官方文档。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 图形界面</title>
    <url>/post/2170659a.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="awt-和-swing"><a class="markdownIt-Anchor" href="#awt-和-swing"></a> AWT 和 Swing</h1>
<p>GUI基本类在java.awt包中，这个包也称为抽象窗口工具包（Abstract Window Toolkit，AWT）。</p>
<p>java.awt包中有一个抽象类Component，它是除菜单类外所有类的父类，他有如下所有组件都有的方法</p>
<ul>
<li>getBackground(): 返回背景色</li>
<li>getGraphics(): 返回组件用的画笔</li>
<li>getHeight(): 返回组件高度</li>
<li>getLocation(): 获得组件位置</li>
<li>getSize(): 获得组件大小</li>
<li>getWidth(): 获得组件宽度</li>
<li>getX(): 获得组件x值</li>
<li>getY():</li>
<li>isVisible(): 组件是否可见</li>
<li>setBackGround(): 设置背景色</li>
<li>setBackGrounds(int x, int y, int width, int height): 设置位置及大小</li>
<li>setEnabled(boolean b): 设置组件是否可用</li>
<li>setFont(Font f): 设置字体</li>
<li>setForground(Color c): 设置前景色</li>
<li>setLocation(int x, int y): 设置组件位置</li>
<li>setSize(int width, int height): 设置组件宽高</li>
<li>setSize(Dimension d): 设置组件大小</li>
<li>setVisible(boolean b): 设置组件是否可见</li>
</ul>
<p>Container表示容器，继承了Component类。容器用来存放别的组件。有两种容器</p>
<ul>
<li>Window(窗口)： 他有两个子类，Frame(窗体）和Dialog（对话框）。Frame带有标题，并且可以自动调整大小，Dialog可以被移动，但不能改变大小</li>
<li>Panel（面板）： 他不能单独存在，只能存在于其他容器（如Window或其子类）。他有一个子类Applet，Applet可以在web中运行。</li>
</ul>
<p>为了使java创建的图形界面能够跨平台，引入了Swing组件。这些组件位于javax.swing包中。接下来主要讲swing。</p>
<p>多数Swing的父类是JComponent(除了JFrame和JDialog外其他都继承了这个）。</p>
<p>JComponent的一些方法</p>
<ul>
<li>setFont(Font font): 设置字体</li>
<li>setForeground(Color c): 设置字体颜色</li>
<li>setToolTipText(String text): 设置鼠标移动到上面的时候显示的文本</li>
<li>setBackGround(Color c)</li>
<li>setOpaque(boolean isOpaque)： 设置组件是否不透明，JLabel默认是透明。不透明才可以显示背景。</li>
<li>setLocationRelativeTo(Component c)： 设置窗口相对于指定组件的位置。当为null时，设置为中间。中点可以使用 GraphicsEnvironment.getCenterPoint 确定。</li>
<li>isFocusOwner(): 判断这个组件是否拥有焦点</li>
</ul>
<p>JFrame一些方法：</p>
<ul>
<li>setIconImage(Image image)</li>
<li>setResizable(boolean resizable)：窗口是否可以放大缩小</li>
<li>setLocation(int x, int y)： 位置</li>
<li>setBounds(int x, int y, int width, int height)： 设置大小和宽高</li>
<li>Point getLocationOnScreen()： 获得位置</li>
<li>dispose()： 销毁窗口。如果再次使用setVisiable()会重构组件</li>
</ul>
<h1 id="创建界面基本步骤"><a class="markdownIt-Anchor" href="#创建界面基本步骤"></a> 创建界面基本步骤</h1>
<p>JFrame有一个构造方法JFrame(String  title)。创建一个title位标题的JFrame对象，但是创建后它是不可见的，必须要经过下列步骤才可以可见：</p>
<ul>
<li>调用setSize(int width, int height): 设置JFrame大小，或者调用peck()自动确定大小。</li>
<li>调用setVisible(true): 使JFrame可见</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">&#123;</span><br><span class="line">    JFrame frame = <span class="keyword">new</span> JFrame(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    jframe.setSize(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    jframe.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个JFrame都会有内容面板(contentpane)，加入JFrame容器的组件实际上都是加入这个面板中</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Container content = jframe.getContentPane()<span class="comment">;</span></span><br><span class="line">content.add(jButton)<span class="comment">;//加入按钮组件</span></span><br></pre></td></tr></table></figure>
<p>add()方法直接向与之关联的内容面板加入组件，所以可以直接<code>jframe.add(jButton)</code>.</p>
<p>JFrame的setContentPane(Container content)用来重新设置面板。</p>
<p>JFrame的setDefaultCloseOperation(int operation)用来设置如何相应关闭操作<br />
operation可以有以下操作</p>
<ul>
<li>JFrame.DO_NOTHING_ON_CLOSE: 什么也不做</li>
<li>JFrame.HIDE_ON_CLOSE: 隐藏窗体，这是默认选项</li>
<li>JFrame.DISPOSE_ON_CLOSE: 销毁窗体</li>
<li>JFrame.EXIT_ON_CLOSE: 结束程序</li>
</ul>
<h1 id="布局管理器"><a class="markdownIt-Anchor" href="#布局管理器"></a> 布局管理器</h1>
<p>JFrame的默认布局管理器是BorderLayout，JPanel默认布局管理器是FlowLayout。</p>
<p>可以通过setLayout(Layout layout)设置布局。也可以通过setLayout(null)取消布局管理器，但是接下来要自己去管理布局，并且现在每个操作系统不同。</p>
<h2 id="flowlayout-流式布局管理器"><a class="markdownIt-Anchor" href="#flowlayout-流式布局管理器"></a> FlowLayout 流式布局管理器</h2>
<p>他按照组件先后顺序从左到右放到容器中，到达边界时，会放置到下一行。</p>
<p>当容器被缩放时，组件位置可能变化，但是组件大小不会改变</p>
<p>构造方法：</p>
<ul>
<li>FlowLayout()</li>
<li>FlowLayout(int align)</li>
<li>FlowLayout(int align, int hgap, int vgap):align设置对齐方式，可以有FlowLayout.LEFT,FlowLayout.RIGHT, FlowLayout.CENTER. hgap和vgap设置组件间水平和垂直间隙</li>
</ul>
<h2 id="borderlayout边界布局管理器"><a class="markdownIt-Anchor" href="#borderlayout边界布局管理器"></a> BorderLayout（边界布局管理器）</h2>
<p>他把容器分成五个区域：东西南北中。</p>
<ul>
<li>它的东和西组件保持最佳宽度，高度拉伸至和所在区域一样高。南北保持最佳高度，宽度和这个区域一样宽。中间和这个区域一样大。</li>
<li>窗口垂直拉伸时，东西中拉伸，当窗口垂直拉伸时，南北中拉伸。</li>
<li>窗口缩放时，组件相对位置不变，但是组件大小改变</li>
<li>如果某个区域组件添加不止一个，只有最后一个是可见的。</li>
</ul>
<p>构造方法：</p>
<ul>
<li>BorderLayout()</li>
<li>BorderLayout(int hgap, int vgap)</li>
</ul>
<p>添加组件： void add(Component comp, Object constraints)。其中constraints是区域，可以是BorderLayout.NORTH,BorderLayout.SOUTH，BorderLayout.EAST,BorderLayout.WEST,BorderLayout.CENTER. 默认是中</p>
<p>还可以直接用字符串设置区域。但是首字母必须大写，其他必须小写。<code>f.add(new JButton(&quot;b1&quot;), &quot;North&quot;)</code></p>
<h2 id="gridlayout网格布局管理器"><a class="markdownIt-Anchor" href="#gridlayout网格布局管理器"></a> GridLayout(网格布局管理器）</h2>
<p>他把容器分成许多行和列，添加组件时首先防止到左上角网格中，然后从左到右放置其他组件。</p>
<ul>
<li>组件相对位置不会随缩放而改变，但是组件大小会改变。</li>
<li>他总是忽略组件最佳大小，所有组件宽度相同，高度也相同</li>
</ul>
<p>构造方法：</p>
<ul>
<li>GridLayout()</li>
<li>GridLayout(int rows, int cols)</li>
<li>GirdLayout(int rows, int cols, int hgap, int vgap)</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculater</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JPanel panel;</span><br><span class="line">    <span class="keyword">private</span> JLabel label;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span>[] name = &#123;<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span></span><br><span class="line">    ,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;=&quot;</span>,<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> JButton[] buttons = <span class="keyword">new</span> <span class="type">JButton</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">public</span> Calculater(<span class="keyword">String</span> title)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">    &#125;</span><br><span class="line">    label = <span class="keyword">new</span> <span class="type">JLabel</span>(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">    panel = <span class="keyword">new</span> <span class="type">panel</span>();</span><br><span class="line">    panel.setLayout(<span class="keyword">new</span> <span class="type">GridLayout</span>(<span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line">    add(label, BorderLayout.NORTH);</span><br><span class="line">    add(panel, BorderLayout.CENTER);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;buttons.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buttons[i] = <span class="keyword">new</span> <span class="type">JButton</span>(name[i]);</span><br><span class="line">        panel.add(buttons[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    pack();</span><br><span class="line">    setVisible();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Calculater</span>(<span class="string">&quot;Calculater&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个计算器的图形界面，可以看到外面采用了BorderLayout，里面面板采用了GridLayout。</p>
<h2 id="cardlayout"><a class="markdownIt-Anchor" href="#cardlayout"></a> CardLayout</h2>
<p>他将界面看成一系列的卡片，任何时候只有一张卡片可见。</p>
<p>构造方法：</p>
<ul>
<li>CardLayout()</li>
<li>CardLayout(int hgap, int vgap)</li>
</ul>
<p>添加组件 void add(Component comp, Object constraints)。其中constraints实际上是一个字符串，表示卡片的名字。默认显示第一张卡片，可以采用show(Container parent, String name)指定显示哪一张卡片。parent指定容器</p>
<h2 id="gridbaglayout网格包-布局管理器"><a class="markdownIt-Anchor" href="#gridbaglayout网格包-布局管理器"></a> GridBagLayout（网格包 布局管理器）</h2>
<p>创建步骤：</p>
<ul>
<li>创建GridBagLayout，并启用</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">GridBagLayout layout = <span class="keyword">new</span> <span class="constructor">GridBagLayout()</span>;</span><br><span class="line">container.set<span class="constructor">Layout(<span class="params">layout</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个GridBagConstraints对象<code>GridBagConstraints constraints = new GridBagConstraints();</code></li>
<li>配置a的各种属性</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">constraints.gridx</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">constraints.gridy</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">constraints.gridwidth</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">constraints.gridwidth</span> = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置布局信息<code>lyout.setConstraints(component1, constraints)</code></li>
<li>加入容器<code>container.add(component1)</code></li>
</ul>
<p>其中GridBagConstraints只需要设置一个，然后重复设置里面属性即可。</p>
<p>这种布局器最为自由，可以完全自己配置，但是首先要画一个草图先规划好各个组件的坐标。</p>
<p>GridBagConstraints的属性：</p>
<ul>
<li>gridx和gridy： 左上角横纵坐标。最左边是（0，0）。默认值是RELATIVE，即最新添加元素后面</li>
<li>gridwidth，gridheight： 宽和高。默认值是1</li>
<li>fill： 当某组件显示区域大于他所要求大小时使用。可以设置如下取值
<ul>
<li>GridBagConstraints.NONE: 默认，不改变组件大小</li>
<li>GridBagConstraints.HORIZONTAL: 填充水平方向，不改变水平大小</li>
<li>GridBagConstraints.VERTICAL: 填充垂直方向</li>
<li>GridBagConstraints.BOTH: 水平垂直都扩大以适应大小</li>
</ul>
</li>
<li>ipadx，ipady： 指定内部填充大小，即最小尺寸下还要加多少。宽度和高度都至少要加ipadx/ipady</li>
<li>insets: 指定外部填充大小。组件和区域边界之间最小区域大小，例如<code>a.insets = new Insets(1, 1, 1, 1);//上左下右边距</code></li>
<li>anchor: 当组件小于区域的时候使用。决定了在区域中的位置，有GridBagContraints.CENTER,等九个区域（包括NORTHEAST等角上区域）</li>
<li>weightx，weighty： 水平重量和垂直重量。他们决定拉伸时谁将占据空白区域。注意每一行或每一列至少要有一个占据重量，不然拉伸时组件大小将不会发生改变，从而导致周围空白。</li>
</ul>
<h1 id="事件处理"><a class="markdownIt-Anchor" href="#事件处理"></a> 事件处理</h1>
<p>每一个可以触发的事件都是事件源，每一种事件都会有相应的监听器，监听器负责接受和处理这些事件。一个事件源可以触发多种事件，事件源可以使按钮，键盘，鼠标等，他们可以产生时间如按键，按按钮，点击然后触发事件处理。</p>
<h2 id="事件处理的实现"><a class="markdownIt-Anchor" href="#事件处理的实现"></a> 事件处理的实现</h2>
<p>每个具体的事件都是某个事件类的实例，事件类有： ActionEvent，ItemEvent，MouseEvent，KeyEvent，FocusEvent，WindowEvent等。每个事件类对应一个事件监听接口，如ActionEvent对应ActionListener。</p>
<p>如果程序需要处理某种事件，就需要实现这些接口。</p>
<p><strong>用内部类实现接口</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> ButtonCounter extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JButton button = <span class="keyword">new</span> <span class="constructor">JFrame(<span class="string">&quot;1&quot;</span>)</span>;</span><br><span class="line">    public <span class="constructor">ButtonCounter(String <span class="params">title</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(title);</span><br><span class="line">        <span class="comment">//注册监视器</span></span><br><span class="line">        button.add<span class="constructor">ActionListener(<span class="params">new</span> ActionListener()</span>&#123;</span><br><span class="line">            public void action<span class="constructor">Performed(ActionEvent <span class="params">evt</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> count = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">button</span>.<span class="params">getText</span>()</span>);</span><br><span class="line">                button.set<span class="constructor">Text(<span class="params">new</span> Integer(<span class="operator">++</span><span class="params">count</span>)</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add(button);</span><br><span class="line">        set<span class="constructor">Size(100, 100)</span>;</span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用容器类实现接口</strong></p>
<p>可以用容器类实现多个监听接口。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> FrmaeCounter extends JFrame implements ActionListener</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JButton button = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">&quot;1&quot;</span>)</span>;</span><br><span class="line">    public <span class="constructor">FrameCounter(String <span class="params">title</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(title);</span><br><span class="line">        <span class="comment">//注册监听器</span></span><br><span class="line">        button.add<span class="constructor">ActionListener(<span class="params">this</span>)</span>;</span><br><span class="line">        add(button);</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class="line">        set<span class="constructor">Szie(100, 100)</span>;</span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void action<span class="constructor">Performed(ActionEvent <span class="params">evt</span>)</span><span class="comment">//实现接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">button</span>.<span class="params">getText</span>()</span>);</span><br><span class="line">        button.set<span class="constructor">Text(<span class="params">new</span> Integer(<span class="operator">++</span><span class="params">count</span>)</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可以让按钮中的数字按一次就加一</p>
<p><strong>定义顶层类实现接口</strong></p>
<p>创建一个专门用来处理事件的类，优点是可以使处理时间的代码和创建GUI的代码分离，缺点是监听类无法直接访问事件源，必须通过事件类的getSource()方法获得事件源。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">pubilc <span class="class"><span class="keyword">class</span> <span class="title">OuterCounter</span> <span class="title">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> JButton button = <span class="keyword">new</span> JButton(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterCounter</span><span class="params">(<span class="keyword">String</span> title)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        super(title);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> MyListener(<span class="number">2</span>));<span class="comment">//创建监听器</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="title">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">step</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyListener</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">step</span> = <span class="built_in">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent evt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JButton button = (JButton)evt.getSource();<span class="comment">//获得事件源</span></span><br><span class="line">        <span class="keyword">int</span> count = Integer.<span class="built_in">parseInt</span>(button.getText());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有动作（按按钮）产生时，会产生ActionEvent让Mylistener处理，如果是在一个类里，我们可以直接使用这个事件源（按钮），但是如果是其他类，就需要ActionEvent的getSource()来获得事件源（谁产生的设个事件）。</p>
<p><strong>事件适配器</strong></p>
<p>如果实现监听街口，就必须实现里面所有的方法。MouseListener有五个方法：mousePressed(),mouseReleased(),mouseEntered(),mouseExited(),<br />
mouseClicked();在实际应用中，往往用不到这么多方法，因此可以使用适配器，适配器中实现了所有方法，但是都是空。例如MouseListener适配器类就是MouseAdapter</p>
<h2 id="事件源时间和监听器之间的关系"><a class="markdownIt-Anchor" href="#事件源时间和监听器之间的关系"></a> 事件源，时间和监听器之间的关系</h2>
<h3 id="事件和监听接口"><a class="markdownIt-Anchor" href="#事件和监听接口"></a> 事件和监听接口</h3>
<table>
<thead>
<tr>
<th>事件</th>
<th>监听接口</th>
<th>抽象方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Action</td>
<td>ActionListener</td>
<td>actioPerformed(ActionEvent evt)</td>
</tr>
<tr>
<td>ItemEvent</td>
<td>ItemListener</td>
<td>itemStateChanged(ItemEvent)</td>
</tr>
<tr>
<td>MouseEvent</td>
<td>MouseMotionListener</td>
<td>mouseDargged(MouseEvent)/mouseMoved(MouseEvent)</td>
</tr>
<tr>
<td>MouseEvent</td>
<td>MouseListener</td>
<td>mousePressed()/mouseReleased()/mouseEntered()/ mouseExited()/mouseClicked()</td>
</tr>
<tr>
<td>KeyEvent</td>
<td>KeyListener</td>
<td>keyPressed()/keyReleased()/keyTyped()</td>
</tr>
<tr>
<td>FocusEvent</td>
<td>FocusListener</td>
<td>focusGained()/foucusLost()</td>
</tr>
<tr>
<td>AdjustmentEvent</td>
<td>AdjustmentListener</td>
<td>adjustmentValueChanged()</td>
</tr>
<tr>
<td>ComponentEvent</td>
<td>ComponentListneer</td>
<td>componentMoved()/ componentResized()/componentShown()</td>
</tr>
<tr>
<td>WindowEvent</td>
<td>WinodwListener</td>
<td>windowClosing()/windowOpened()/    windowIconified()/windowDeiconfied()/ windowclosed() /windowActivated()/windowDeativated()</td>
</tr>
<tr>
<td>ContainerEvent</td>
<td>ContainerListener</td>
<td>componentAdded()/componentRemoved()</td>
</tr>
<tr>
<td>Textevent</td>
<td>TextListener</td>
<td>textValueChanged()</td>
</tr>
</tbody>
</table>
<p>MouseListener和MouseMotionListener都是监听MouseEvent。MouseMotionListener监听和鼠标移动相关事件。他们有以下方法</p>
<ul>
<li>mouseMoved(): 用户未按下鼠标直接移动时调用此方法</li>
<li>mouseDragged(): 按下鼠标并拖动</li>
<li>mouseClicked(): 单击鼠标</li>
<li>mosuePressed(): 按下鼠标</li>
<li>mouseReleased(): 释放鼠标</li>
<li>mouseExited(): 退出组件区域</li>
<li>mouseEntered(): 进入组件区域</li>
</ul>
<p><strong>组件及监听接口</strong></p>
<p>组件可以通过addxxxlistener方法注册监听器（监听器就是上面第二列）。</p>
<p><strong>适配器</strong></p>
<table>
<thead>
<tr>
<th>监听接口</th>
<th>监听器</th>
</tr>
</thead>
<tbody>
<tr>
<td>ComponentListener</td>
<td>ComponentAdapter</td>
</tr>
<tr>
<td>FocusListener</td>
<td>FocusAdapter</td>
</tr>
<tr>
<td>KeyListener</td>
<td>KeyAdapter</td>
</tr>
<tr>
<td>MouseListener</td>
<td>MouseAdapter</td>
</tr>
<tr>
<td>MouseMotionListener</td>
<td>MouseMotionAdapter</td>
</tr>
<tr>
<td>ContainerListener</td>
<td>ContainerAdapter</td>
</tr>
<tr>
<td>WindowListener</td>
<td>有</td>
</tr>
<tr>
<td>ItemListener</td>
<td>没有</td>
</tr>
<tr>
<td>ActionListener</td>
<td>没有</td>
</tr>
<tr>
<td>InputMethodListener</td>
<td>没有</td>
</tr>
</tbody>
</table>
<p>基本上有多个抽象方法的都有适配器</p>
<h1 id="awt绘图"><a class="markdownIt-Anchor" href="#awt绘图"></a> AWT绘图</h1>
<p>在component中有两个和绘图有关方法：</p>
<ul>
<li>paint(Graphics g): 绘制组件外观</li>
<li>repaint(): 调用paint(),刷新组件的外观（对于awt组件来说调用repaint前还要调用update方法）</li>
</ul>
<p>在下列情况中，会调用paint：</p>
<ul>
<li>第一次显示在屏幕上时</li>
<li>组件大小发生变化时</li>
<li>调用repaint</li>
</ul>
<p>JComponent覆盖了paint，并将会话任务委托给三个protected的方法：</p>
<ul>
<li>paintComponent(): 画当前组件，</li>
<li>paintBorder(): 画边界</li>
<li>paintChildren(): 如果这个组件时容器，则画容器包含的组件</li>
</ul>
<p>JComponent会议组件背景色覆盖整个区域，所以如果画了图形想清除的话只需要调用super.paintComponent().</p>
<p>例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorChange</span> <span class="keyword">extends</span> <span class="title">JPanel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Color color = Color.RED;</span><br><span class="line">    <span class="keyword">private</span> int times;</span><br><span class="line">    <span class="keyword">public</span> ColorChange()</span><br><span class="line">    &#123;</span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">&quot;change color&quot;</span>);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent event)</span><br><span class="line">            &#123;</span><br><span class="line">                color = (color==Color.RED) ? Color.GREEN : Color.RED;</span><br><span class="line">                repaint();<span class="comment">//刷新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add(button);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> paintComponent(Graphics g)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>.paintComponent(g);<span class="comment">//清空画板</span></span><br><span class="line">        g.setColor(color);</span><br><span class="line">        g.fillReet(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);<span class="comment">//画矩形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        frame.setContentPane(<span class="keyword">new</span> ColorChanger());</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就重写了paintComponent方法，然后repaint()调用的就是重写后的方法。</p>
<h2 id="graphics"><a class="markdownIt-Anchor" href="#graphics"></a> Graphics</h2>
<p>Graphics代表画笔，提供了各种绘制图形的方法：</p>
<ul>
<li>drawLine(int x1, int y1, int x2, int y2): 画一条直线</li>
<li>drawString(String string, int left, int bottom): 写字符串</li>
<li>drawImage(Image image, int left, int top, ImageObserver observer):画一个图片</li>
<li>drawRect(int left, int top, int width, int height): 画一个矩形</li>
<li>drawOval(int x, int y, int width, int height):画一个椭圆</li>
<li>fillRect(int left, int top, int width, int height): 填充矩形</li>
<li>fillOval(int x, int y, int width, int height): 填充一个椭圆</li>
</ul>
<p>其中left，top是左上角坐标。</p>
<p>如果没有调用Graphics的setColor()方法,将以前景色填充</p>
<p>使用完之后要用dispose()进行销毁</p>
<p>drawString(String str, int x, int y)将用当前画笔颜色和字体，将str显示.字符的左下角是(x,y)</p>
<h2 id="graphics2d"><a class="markdownIt-Anchor" href="#graphics2d"></a> Graphics2D</h2>
<p>方法：</p>
<ul>
<li>setStroke(Stroke s)； 获得画笔的特性</li>
<li>draw(Shape shape): 滑参数指定的图形</li>
<li>fill(Shape shape): 填充参数指定的图形</li>
<li>translate(int x, int y)： 平移</li>
<li>rotate(double theta, double originX, double originY)：旋转</li>
<li>scale(double sx, double sy)： 缩放</li>
</ul>
<p>一般使用BasicStroke类。构造方法是<code>BasicStroke(float width, int cap, int join, float miterlimit, float[] dash, float_phase)</code>：</p>
<ul>
<li>width：笔画宽度，此宽度必须大于或等于0.0f。如果将宽度设置为0.0f，则将笔画设置为当前设备的默认宽度</li>
<li>cap：线端点的装饰</li>
<li>join：应用在路径线段交汇处的装饰</li>
<li>miterlimit：斜接处的裁剪限制。该参数值必须大于或等于1.0f</li>
<li>dash：表示虚线模式的数组</li>
<li>dash phase：开始虚线模式的偏移量</li>
</ul>
<p>他还有一些绘制图形的类</p>
<ul>
<li>java.awt.geom.Line2D: 画直线</li>
<li>java.awt.geom.Ellipse2D: 画椭圆</li>
<li>java.awt.geom.Rectangle2D: 画矩形</li>
</ul>
<p>上面这些画图形的都是抽象类，他们都有两个子类：Double和Float。例如LineD.Double。</p>
<p>上面这些实现类的构造方法和前面说的draw大致相似。</p>
<p>还可以利用java.awt.Toolkit的getScreenSize()来获得屏幕大小，从而设定JFrame大小。</p>
<h1 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h1>
<p>虚拟机中会创建一个专门的awt线程处理窗口，但是需要我们专门添加，添加代码<code>SwingUtilities.invokeLater(Runnable doRun)</code></p>
<p>例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处处于 主线程，提交任务到 事件调度线程 创建窗口</span></span><br><span class="line">        SwingUtilities.invokeLater(</span><br><span class="line">                <span class="keyword">new</span> <span class="function"><span class="title">Runnable</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                        <span class="comment">// 此处处于 事件调度线程</span></span><br><span class="line">                        createGUI();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的线程只是用来创建窗口，绘图等不耗时的工作。<a href="https://blog.csdn.net/xietansheng/article/details/78389265">详细可看</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java 多线程</title>
    <url>/post/f8648a1d.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="java线程运行机制"><a class="markdownIt-Anchor" href="#java线程运行机制"></a> java线程运行机制</h3>
<p>java虚拟机中，执行程序是由线程完成的，每个线程都有独立的程序计数器（PC或rip<br />
)和栈</p>
<p>栈中有三个区，局部变量区，操作数栈和栈数据区。</p>
<p>操作数栈是线程的工作区，用来存放运算过程产生的临时变量（怎么有种寄存器的感觉）。</p>
<p>栈数据区为线程执行指令提供相关信息，例如定位到堆区和方法区的特定数据（类成员变量），正常退出方法等（存放地址信息）。</p>
<p>每次java虚拟机启动一个虚拟机进程时，虚拟机都会创建一个主线程。该线程从main开始执行。</p>
<p>例如在一个类中定义了一个实例变量a,然后再main函数中调用了这个类的成员函数A()，这个函数会让成员变量加一。首先进入这个方法，然后发现a++;就去栈数据区取出a的地址，之后定位到堆区取出a进行操作。</p>
<ul>
<li>方法区存放了字节码</li>
<li>堆区存放了线程所需要长时间保存的数据（类）</li>
<li>栈区存放了临时数据，栈帧和跳转到其他区域地址。</li>
</ul>
<h3 id="线程的创建和启动"><a class="markdownIt-Anchor" href="#线程的创建和启动"></a> 线程的创建和启动</h3>
<p>我们现在免费有了一个主线程，如果我们还想要创建其他线程的话，有两种方式。</p>
<ul>
<li>扩展java.lang.Thread类</li>
<li>实现Runnable接口</li>
</ul>
<p>要注意一点，创建了线程并启动之后会有自己的栈区，堆区，方法区，也就是说可以把它看成一个新的程序，里面的变量都是最原始的，不要认为主线程中操作的变量还有用。但是有些时候也可以使用主线程的对象</p>
<p><strong>一个线程只可以被启动一次</strong>。</p>
<h4 id="扩展javalangthread类"><a class="markdownIt-Anchor" href="#扩展javalangthread类"></a> 扩展java.lang.Thread类</h4>
<p>thread是线程，它的最主要的两个方法是：</p>
<ul>
<li>run(): 包含线程运行时执行的代码（相当于main方法）</li>
<li>start()： 用于启动线程，不需要覆盖</li>
</ul>
<p>start方法用来确定什么时候开始执行，可以在别的main函数中执行，例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">50</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start(); <span class="comment">//启动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，调用了start并不是指立刻执行这个线程，而是让这个线程进入就绪状态，如果想让这个线程执行可以使用yield。</p>
<h4 id="实现runnable接口"><a class="markdownIt-Anchor" href="#实现runnable接口"></a> 实现Runnable接口</h4>
<p>java不允许一个类继承多个类，所以一旦继承了Thread类，那么就不能继承其他类。所以说接口这时就体现出优越性了。定义如下：</p>
<p><code>public void run();</code></p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    [</span></span><br><span class="line"><span class="function">        Machine machine </span>= <span class="keyword">new</span> Machine();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> thread(machine);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread构造方法中有Runnable接口的，这个时候Thread就掌管了run方法，只要使用start就可以启动。</p>
<h4 id="主线程和用户自定义线程并发运行"><a class="markdownIt-Anchor" href="#主线程和用户自定义线程并发运行"></a> 主线程和用户自定义线程并发运行</h4>
<p>并发运行指的是一个线程没有结束另一个线程开始执行，上面举的例子都是并发运行。</p>
<p>Thread中的currentThread()静态方法返回当前线程的引用，getname()返回当前线程的名字，main方法名字是main，用户创建的线程根据顺序从Thread-0，Thread-1一直往后排，可以用setName()设置名字。</p>
<p>例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">String name = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line">相当于</span><br><span class="line">Thread thread = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">String name = thread.get<span class="constructor">Name()</span>;</span><br></pre></td></tr></table></figure>
<p>为了让每个线程轮流获得cpu，可以使用sleep(time)放弃cpu并睡眠若干时间。</p>
<h4 id="多个线程共享一个对象的实例变量"><a class="markdownIt-Anchor" href="#多个线程共享一个对象的实例变量"></a> 多个线程共享一个对象的实例变量</h4>
<p>例：</p>
<ul>
<li>方法内部局部变量不共享</li>
</ul>
<p>这是因为这些数据都是动态在栈中分配的，每个线程都有自己的堆栈。</p>
<ul>
<li>成员变量，如果是指向同一个对象就共享</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">package file2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Analy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        Num i=<span class="keyword">new</span> Num(<span class="number">0</span>);    <span class="comment">//新建对象，准备传递给线程</span></span><br><span class="line">        <span class="keyword">new</span> OwnThread(i).start();    <span class="comment">//新建线程，并启动</span></span><br><span class="line">        <span class="keyword">new</span> OwnThread(i).start();    <span class="comment">//新建线程，并启动</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程中i的值变为了：&quot;</span>+i.i);    <span class="comment">//获取目前对象i的数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OwnThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Num id;    <span class="comment">//申明对象，默认null，就是没有指向任何实体</span></span><br><span class="line">    int sno;    <span class="comment">//申明int变量。因为系统默认初始化为0，所以应该是定义一个int变量</span></span><br><span class="line">    OwnThread(Num id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            synchronized(<span class="built_in">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sno=id.i;    <span class="comment">//保存id.i的数值，到线程私有变量sno</span></span><br><span class="line">                id.i++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName()+<span class="string">&quot;,&quot;</span>+sno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span>    //定义一个类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    int i;</span><br><span class="line">    Num(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.i=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中主函数定义了Num对象的实例i，定义线程是传递到了Thread0和Thread1这样三个变量就共享了一个Num对象的实例。而线程Thread0和线程Thread1又有自己的私有变量sno，可以用来保存某一时刻的共享变量的数值。</p>
<p>(1)Java中判断对象是否为同一个对象使用地址判断的。地址相同就是同一个对象，上面的三个就是同一个对象。</p>
<p>(2)如果把上面的例子中共享的对象实例用基本数据类型替换是不行的。因为基本数据类型程序会自动的用默认值初始化，也就是申明和定义时一起的。此时在main函数中定义线程，传递的基本数据类型参数，只能是初始化线程中的另一个对象，而不是同一个对象。</p>
<p>也就是说，只有类才可以共享，并且用同一个实例启动多个线程的时候这个实例是共享的，并且也只有这个实例时共享的，如果在线程中创建的新实例也不是共享的。</p>
<p><a href="https://www.cnblogs.com/xudong-bupt/archive/2013/05/22/3087864.html">这里来自这篇博客</a></p>
<h3 id="线程状态转换"><a class="markdownIt-Anchor" href="#线程状态转换"></a> 线程状态转换</h3>
<p><strong>新建状态</strong></p>
<p>也就是只有new没有start状态。</p>
<p><strong>就绪状态</strong></p>
<p>调用了start方法后，就进入了就绪状态。虚拟机会为他创建栈和rip，这个线程在运行池中等待cpu使用权。</p>
<p><strong>运行状态</strong></p>
<p>就是得到了cpu使用权，如果是多个cpu，那么可以同时运行多个线程。</p>
<p><strong>阻塞状态</strong></p>
<p>阻塞状态优先级比就绪状态低，阻塞状态过去后首先进入就绪状态然后进入运行状态。</p>
<ul>
<li>如果调用了某个对象的wait()方法，那么会进入这个对象等待池中。</li>
<li>如果试图获得某个对象的同步锁（后面说）但是被其他线程使用时，会把这个线程放到这个对象的锁池中。</li>
<li>调用sleep。</li>
</ul>
<p><strong>死亡状态</strong></p>
<p>当退出了run后，进入死亡状态。前面已经提到过一个线程不能呗start两次。可以用Thread的isAlive()方法判断这个线程是否活着。如果处于新建状态时，也是false。</p>
<h3 id="线程调度"><a class="markdownIt-Anchor" href="#线程调度"></a> 线程调度</h3>
<p>线程调度就是确定cpu的使用权在那个线程手上，cpu通常只有一个。有两种调度模型：分时调度和抢占型调度。</p>
<p>分时型调度就是让每个线程都执行一定时间。</p>
<p>抢占型是java虚拟机采用的方式。它是将所有线程规定一个优先级，优先让优先级高的线程运行，如果优先级都相同，那么随机选取一个线程。一旦抢到cpu，那么它将会一直运行直到被迫停止运行。</p>
<p>被迫停止运行的可能：</p>
<ul>
<li>虚拟机让当前线程放弃cpu。</li>
<li>当前线程进入阻塞状态</li>
<li>线程运行结束</li>
</ul>
<p>不同操作系统对抢占型的实现不同，有的是会一直让这个线程运行，有的是一段时间后停止运行。</p>
<h4 id="调整优先级"><a class="markdownIt-Anchor" href="#调整优先级"></a> 调整优先级</h4>
<p>可以使用Thread的setPriority(int)和getPriority()设置优先级，可以使用currentThread().setPriority(?)设置等级。</p>
<p>三个静态常量：</p>
<ul>
<li>MAX_PRIORITY 10级，最高等级</li>
<li>MIN_PRIORITY 1,最低等级</li>
<li>NORM_PRIORITY 5, 默认等级</li>
</ul>
<p>如果将主线程优先级更改然后再创建其他线程，那么其他线程优先级也会更改。被创建者的默认优先级和创建者优先级保持相同。</p>
<p>注意，上面三个静态常量在不同操作系统中是不同的，例如windows只有七个优先级，所以最好只使用上面三种优先级。</p>
<h4 id="threadsleep线程睡眠"><a class="markdownIt-Anchor" href="#threadsleep线程睡眠"></a> Thread.sleep()线程睡眠</h4>
<p>如果使用sleep方法，那么他会放弃cpu进入阻塞状态。sleep后面的数据是以毫秒做单位。完成之后也不是立刻重新开始执行，而是先进入就绪状态，如果没人和它抢cpu就开始执行。</p>
<p>例如： sleep(100);表示阻塞100毫秒</p>
<p>可以使用sleep让两个线程比较同步的执行。例如每个线程都会调用sleep(100)，那么第一个线程调用睡眠后第二个线程开始执行，如果执行时间小于100ms那么第二个线程执行完后第一个线程仍在睡眠，如果大于100ms第一个线程会立刻开始执行。因为它已经睡了100ms进入就绪状态了（同样也是只有两个线程的情况）。</p>
<p>可以使用sleep.interrupt()中断睡眠</p>
<p>如果线程在睡眠时被中断，那么就会抛出InterruptedException，程序跳到异常处理代码块。</p>
<h4 id="threadyield线程让步"><a class="markdownIt-Anchor" href="#threadyield线程让步"></a> Thread.yield()线程让步</h4>
<p>执行yield后，如果有相同或者更高优先级的线程在就绪状态，那么将会把当前线程放入运行池中并让优先级高的线程执行。</p>
<h4 id="join等待其他线程结束"><a class="markdownIt-Anchor" href="#join等待其他线程结束"></a> join()等待其他线程结束</h4>
<p>当前线程可以调用另一个线程的join()方法，直到另一个线程结束这个线程才会又开始执行（进入就绪状态）。</p>
<p>如果加了参数，那么类似于sleep()将会休眠若干时间，不同的是join是给指定的线程执行。</p>
<h3 id="后台线程"><a class="markdownIt-Anchor" href="#后台线程"></a> 后台线程</h3>
<p>例如垃圾回收线程，只有当前台所有线程都停止之后，后台线程才会结束生命周期。</p>
<p>主线程默认是前台线程，前台线程创建的线程默认也是前台线程。</p>
<p>可以调用Thread的setDaemon(true)方法，把线程设置成后台线程。可以用isDaemon()判断是否是后台线程。</p>
<p>只有在线程启动前（使用start())之前才可以设置成后台。并且后台创建的线程还是后台线程。</p>
<h3 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h3>
<p>java.util包中提供了定时器Timer，TimerTask类表示定时器执行的一项任务。例；</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">package usetimer;</span><br><span class="line">improt java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> int a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> start()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>.start();<span class="comment">//想自定义start必须要先用父类的start</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(ture);<span class="comment">//把Timer关联的线程设为后台线程</span></span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">            &#123;</span><br><span class="line">                reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;<span class="comment">//匿名类，便于设置定时任务</span></span><br><span class="line">        timer.schedule(task, <span class="number">10</span>, <span class="number">50</span>);<span class="comment">//设置定时任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> reset()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:&quot;</span>+a++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TimerTask类是一个抽象类，它实现了RUnnable接口。start()中匿名类继承了TimerTask类。</p>
<p>TImer(boolean isDaemon)可以把相关联的线程设置成后台线程。如果是true就是后台</p>
<p>schedule(TimerTask task, long delay, long period)用来设置定时任务。所以前面的匿名类就是用来启动定时任务的。delay是推迟多少毫秒之后执行，period是每次执行任务的间隔。其中delay只在第一次运行时有效。</p>
<p>还可以不要period参数，表示只执行一次。例如,timer.schedule(task, 10);</p>
<p>同一个定时器可以执行多个任务。</p>
<h3 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h3>
<p>有时候线程的抢占可能导致问题。例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//共享</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a+=i;</span><br><span class="line">            Thread.<span class="built_in">yield</span>();<span class="comment">//让给其他线程执行</span></span><br><span class="line">            a-=i;</span><br><span class="line">            System.out.<span class="built_in">println</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Mahcine();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(machine);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(machine);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个程序本来是要一直输出零的，但是因为让给了t2执行，所以会输出1 2 2 3 …。这样就和原来的逻辑不符。</p>
<p>逻辑紧密相关的一组操作叫做原子操作，为了防止原子操作被打断，就提出了线程同步思想。</p>
<p>线程同步只有在两个线程使用同一变量时才会使用。如上面都使用了machine的a，另外一种情况是都使用了全局变量。</p>
<h4 id="synchronized同步代码块"><a class="markdownIt-Anchor" href="#synchronized同步代码块"></a> synchronized同步代码块</h4>
<p>例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    synchronized(<span class="built_in">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">String</span> goods = buffer[point];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就设置了this对象的锁。</p>
<ul>
<li>如果这个锁被其他线程占用，那么就会把该线程加入锁池中，进入阻塞状态</li>
<li>如果没有线程占用，那么他就会占用并执行代码块。</li>
</ul>
<p>也可以这样写；</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized <span class="built_in">String</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在同步代码块中同样也可以使用sleep和yield，同样也是把cpu给其他线程。只是如果其他线程正好碰到了同步代码块那么又要将控制权归还，</p>
<p>synchronized不会被继承，也就是说哪怕父类中写了synchronized如果子类没写也不是同步的。</p>
<p>同步代码块中应包含尽量少的操作，因为操作多了可能一线程要在这里工作很久，其他线程就会都进入锁池中无法工作，这样会给一些需要即时反应的线程带来麻烦</p>
<h4 id="释放对象的锁"><a class="markdownIt-Anchor" href="#释放对象的锁"></a> 释放对象的锁</h4>
<p>释放锁的情况：</p>
<ul>
<li>执行完同步代码块，会释放锁</li>
<li>线程异常终止时</li>
<li>执行了锁所属对象的wait()方法，这个线程会释放锁，并进入等待吃</li>
</ul>
<p>但是使用sleep或yield只会放弃cpu，并不会释放锁。还有suspend方法</p>
<h4 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h4>
<p>死锁指的是a在等b锁释放，b在等a锁释放，这样就永运无法释放，最为关键的是虚拟机并不会检查这类问题，所以只有程序员自己注意。</p>
<h3 id="线程通信"><a class="markdownIt-Anchor" href="#线程通信"></a> 线程通信</h3>
<p>线程通信就是一个线程告诉另外一个线程某个信息，通过配合完成某件事。</p>
<p>java.lang.Object类中有两个用于线程通信的方法：</p>
<ul>
<li>wait() 释放对象的锁，然后把该线程放入等待池中，等待其他线程把它唤醒</li>
<li>notify() 唤醒在等待池中的线程。随机选取等待池中的线程，并加入锁池中。</li>
</ul>
<p>进入等待池后，锁和cpu全部放弃。如果使用notify也只是进入锁池，还要和其他线程争夺锁。</p>
<p>notifyAll() 唤醒所有在等待池中的线程。</p>
<p>注意：wait()方法必须放在一个循环中。因为在调用notify后并不是立刻可以得到执行，而是先要获得该对象的锁和cpu执行权限才可以运行。这个时候可能其他线程又将状态改变了，这时又要重新运行。</p>
<p><strong>要注意的是想要唤醒等待池中的线程首先自己要掌握这个锁</strong>，也就是说必须在同步代码块中写notify，不然会报IllegalMonitorStateException错误。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized <span class="built_in">String</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(point == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.ptintln(Thread.currentThread().getName()+<span class="string">&quot;:wait&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，首先point是-1就要让一个线程处理，现在point是-1，然后一个线程调用wait()进入等待池，之后另一个线程操作了这个方法唤醒了该线程，但是这个时候线程并没有执行，而是先让其他的线程执行了一会才开始执行。但是其他线程执行过程中又把point变成-1了，这个时候处理线程已经结束，就会出现问题。</p>
<p>此外，<strong>wait必须写在synchronized中，不然运行时会报错。</strong></p>
<h3 id="中断阻塞"><a class="markdownIt-Anchor" href="#中断阻塞"></a> 中断阻塞</h3>
<p>当线程A处于阻塞状态的时候，B调用A的interrupt()方法，那么A会发送一个InterruptedExecption。</p>
<p>实际上interrupt方法如果处理处于阻塞状态的线程（如wait，sleep，join等）才会抛出异常，实际上它是把一个中断线程的标志位设为true，因为处于阻塞状态，所以抛出异常，仅此而已。决定是否退出线程还是由我们自己决定的，如果我们在catch块中没有退出，那么还是会继续运行。</p>
<p>如果interrput一个正在处于运行的线程，那么只会把标志位设置成true，不会做其他事。</p>
<p>可以通过isinterrupt来看标志位是否变成true</p>
<p>例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> int a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Timer timer = <span class="keyword">new</span> Timer(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> synchronized <span class="built_in">void</span> reset()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">    &#123;</span><br><span class="line">        final Thread thread = Thread.currentThread();</span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            publc <span class="built_in">void</span> run()</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">&quot;has waited for 3s&quot;</span>);</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            synchronized(<span class="built_in">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                timer.schedule(timerTask, <span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(InterruptException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(thread.getName);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a++;</span><br><span class="line">            System.out.println(<span class="string">&quot;a=&quot;</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序作用是如果a&gt;3，那么就把线程放入等待池，如果等待时间超过三秒，那么就抛出InterruptException信号从而中断线程。</p>
<h3 id="线程控制"><a class="markdownIt-Anchor" href="#线程控制"></a> 线程控制</h3>
<ul>
<li>start() 启动线程</li>
<li>suspend() 使线程暂停</li>
<li>resume() 使暂停的线程恢复运行</li>
<li>stop() 终止线程</li>
</ul>
<p>但是其实后面三种已经被废弃了，但是可以通过编程实现同样的功能</p>
<h4 id="用编程方式控制线程"><a class="markdownIt-Anchor" href="#用编程方式控制线程"></a> 用编程方式控制线程</h4>
<p>可以设置一个标志变量来表示现在的状态，假设标志变量有三个值。</p>
<ul>
<li>SUSP， 暂停状态</li>
<li>STOP， 终止状态</li>
<li>RUN， 运行状态</li>
</ul>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUSP = <span class="number">1</span>;<span class="comment">//设置静态变量的话所有类都可以看到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUN = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> state = RUN;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">if</span>(state == RUN)</span><br><span class="line">        &#123;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">checkState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(state == SUSP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(state == STOP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的两个方法，就可以对线程进行控制，但注意这种控制不是实时的，也就是说即使执行了setState也不会立刻进入暂停状态，而是machine先获得cpu，开始执行checkState方法时才会进入暂停状态。</p>
<h3 id="线程组"><a class="markdownIt-Anchor" href="#线程组"></a> 线程组</h3>
<p>ThreadGroup类表示线程组，他可以对一组线程集中管理。用户创建的线程都属于某个线程组。</p>
<p>指定线程组： <code>Thread(ThreadGroup group, String name)</code></p>
<p>如果线程A创建线程B且创建时没有指定线程组，那么会自动加入A的线程组中。一旦线程<strong>加入线程组，就不能退出</strong>。</p>
<p>用户创建的线程组都有父线程组，默认情况下，如果A创建了一个新线程组，那么A所在的线程组就是父亲线程组。</p>
<p>指定父亲线程组： <code>ThreadGroup(ThreadGroup parent, String name)</code></p>
<p>可以使用activeCount()返回当前活着的线程，enumerate(Thread[] tarray)把或者的线程复制到tarray中。</p>
<h3 id="处理线程未捕获的异常"><a class="markdownIt-Anchor" href="#处理线程未捕获的异常"></a> 处理线程未捕获的异常</h3>
<p>如果线程没有捕获异常，那么虚拟机会找UncaughtExceptionHandler实例（这东西是个接口）。并且调用它的uncaughtException(Thread t, Throwable e)方法</p>
<p>设置异常处理类：</p>
<p><code>setDefaultUncaughtExcpetionHandler(Thread.UncaughtExceptionHandler eh)</code><br />
<code>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code></p>
<p>第一个是设置默认异常处理器（静态方法），第二个是设置当前异常处理器（实例方法）。</p>
<p>ThreadGroup线程组实现了这个接口。每次出现未捕获异常时，先找当前线程的异常处理器，如果没找到就用线程组的异常处理器。</p>
<p>并且线程组的异常处理器还不是直接调用。如果这个线程有父线程，那么就调用父线程的。如果没有父线程，那么如果自己实现了这个接口，那么就用。如果没有，那么就打印调用堆栈的异常信息。</p>
<h3 id="threadlocal类"><a class="markdownIt-Anchor" href="#threadlocal类"></a> ThreadLocal类</h3>
<p>这个类用来存放线程的局部变量。这些局部变量是每个线程独有的，不会共享。</p>
<p>主要有三个方法：</p>
<p><code>public T get(): 返回当前线程局部变量 protected T initialValue(): 返回局部变量初始值 public void set(T value): 设置局部变量</code></p>
<p>其中initialValue()只会在第一次调用get()或set()时才会被使用，并且只会执行一次。</p>
<h3 id="concurrent并发包"><a class="markdownIt-Anchor" href="#concurrent并发包"></a> concurrent并发包</h3>
<p>在编写多线程程序时，既要考虑并发，又要防止死锁，还要考虑性能，难度很大。为了降低难度，增加了java.util.concurrent包。下面是包含的类和接口</p>
<h4 id="lock外部锁"><a class="markdownIt-Anchor" href="#lock外部锁"></a> Lock外部锁</h4>
<p>这个主要用于线程同步。这是由类提供的锁，区别于对象的锁（可以叫内部锁）。他有几个方法。</p>
<ul>
<li>lock() 获得当前线程的锁，如果被占用，那么进入阻塞状态。这和内部锁是一样的</li>
<li>tryLock() 试图获得当前线程的锁（看看现在锁是不是有人用），如果被占用，就返回false，否则返回true。</li>
<li>tryLock(long time, TimeUnit unit)，如果超过了设置时间没有获得锁，放回false。例如 tryLock(50L, TimeUnit.SECONDS)表示时间限制50s</li>
<li>unlock() 释放线程锁占用的锁。</li>
</ul>
<p>Lock接口有一个实现类ReentrantLock，构造方法ReentrantLock(boolean fair).fair如果是真，那么会采用公平策略。公平策略是指让阻塞时间长的更有可能获得锁。这是以性能作为代价的。</p>
<p>例：</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();<span class="comment">//创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部锁可以用来弥补内部所的一些不足，我们可以直接用lock，unlock而不使用synchronized。</p>
<h4 id="condition-线程通信接口"><a class="markdownIt-Anchor" href="#condition-线程通信接口"></a> Condition 线程通信接口</h4>
<p>java.lang.concurrent.locks.Conditon用于线程通信。Lock接口的newCondition()方法返回Condition的实例。</p>
<p>方法：</p>
<ul>
<li>await() 和wait()相似</li>
<li>await(long time, TimeUnit unit):和上面类似，如果超过时间线程没有被唤醒，返回false。</li>
<li>signal()： 和notify()类似。</li>
<li>signalAll()：和notifyAll()类似</li>
</ul>
<h4 id="callable和feture"><a class="markdownIt-Anchor" href="#callable和feture"></a> Callable和Feture</h4>
<p>这两个是用来做异步计算的。Runnable接口的返回值是void，如果其他线程需要这个线程的返回值怎么办呢？这个可以通过共享变量来实现，但是共享变量需要共享类，这又可能导致问题。所以这两个接口就是解决这类麻烦。</p>
<p>Callable接口：和Runnable接口类似，Runnable中的run()相当于Callable中的call()。但是call可以有泛型的返回值。此外，这个不能作为Thread类的参数。</p>
<p>Future接口： 保存运算结果，以下参数</p>
<ul>
<li>get()：返回异步运算的结果。如果结果没有出来，当前线程就会被阻塞直到运算结束。</li>
<li>get(long timeout, TimeUnit unit): 和第一个类似。只是如果超出时间还没有得到结果就会抛出TimeoutException。</li>
<li>cancel(boolean mayInterrupt): 取消该运算，如果运算没有开始，就立刻取消。如果已经开始，如果mayInterrrupt为true，那么也取消。</li>
<li>isCancelled()：判断运算时候被取消</li>
<li>isDone()：判断运算是否已经完成。</li>
</ul>
<p>FutureTask：这是一个适配器，同时实现Runnable和Future接口。还关联了一个Callable实例。FutureTask可以作为Thread类的参数。FutureTask类的构造函数可以带Callable的参数。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">Callable myComputation = <span class="literal">new</span> <span class="params">...</span></span><br><span class="line">FutureTask&lt;<span class="built_in">Integer</span>&gt; task = <span class="literal">new</span> FutureTask&lt;<span class="built_in">Integer</span>&gt;(myComputation);<span class="comment">//Integer是返回值</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Machine implements Callable&lt;<span class="type">Integer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">Integer</span> <span class="keyword">call</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            catch(<span class="keyword">Exception</span> e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(Stirng[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FutureTask&lt;<span class="type">Integer</span>&gt; task = <span class="built_in">new</span> FutureTask&lt;<span class="type">Integer</span>&gt;(<span class="built_in">new</span> Machine());</span><br><span class="line">        Thread thread = <span class="built_in">new</span> Thread(task);</span><br><span class="line">        threadMachine.<span class="keyword">start</span>();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;从1到100的和&quot;+task.<span class="keyword">get</span>());//调用<span class="keyword">get</span>返回值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过线程池管理多个线程"><a class="markdownIt-Anchor" href="#通过线程池管理多个线程"></a> 通过线程池管理多个线程</h4>
<p><img src="/images/java%E7%BA%BF%E7%A8%8B.jpg" alt="" /></p>
<p>Executor表示线程池，execute方法用来执行command的run()中指定的任务，线程会调度空闲的线程来执行该任务。到底什么时候执行，这是由cpu决定的。</p>
<ul>
<li>shutdown(): 预备关闭线程池。如果有任务提交上去，那么要等这些任务执行完后，才会关闭线程池，并且拒绝新任务的入内。</li>
<li>shutdownNow(): 终止已经开始的任务，立刻关闭线程池</li>
<li>isTermination(): 判断线程池是否关闭，如果关闭返回true</li>
<li>awaitTermination(): 等待线程池关闭。</li>
</ul>
<p>submit(Callable<T> task)和submit(Runnable task)和execute(Runnable command)类似，但是这个支持异步运算。他们都会返回异步运算结果的Future对象。</p>
<p>Excutors中静态方法：</p>
<ul>
<li>newCachedThreadPool(): 创建有缓存的线程池，有任务才创建新线程，空闲的线程停留60s。</li>
<li>newFixedThreadPool(int nThreads): 创建有固定数目线程的线程池，空闲线程一直保留</li>
<li>newSingleThreadExecution(): 创建只有一个县城的线程池。这个与newFixedThreadPool(1)不同之处在于这个终止就终止了，Fixed的终止了还会创建一个新的。</li>
<li>newScheduledThreadPool(int corePoolSize): 线程池会按时间计划创建任务。corePoolsize是线程<strong>最小</strong>数目。</li>
<li>newSingleThreadScheduledExecutor(): 创建只有一个线程的线程池，这个线程池按计划进行任务。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Machine</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Machine(i));</span><br><span class="line">        &#125;</span><br><span class="line">        service.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了5个线程给线程池，然后线程池中两个空白线程接到任务开始工作，工作完这两个线程后又执行下面两个线程，直到执行完5个线程。然后执行shutdown()关闭线程池。</p>
<h4 id="blockingqueue-阻塞队列"><a class="markdownIt-Anchor" href="#blockingqueue-阻塞队列"></a> BlockingQueue 阻塞队列</h4>
<p>java.util.concurrent.BlockingQueue接口继承了java.util.Queue接口。BlockingQueue接口为多个线程同时操作一个队列提供了方案。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>抛出异常</th>
<th>放回特定值</th>
<th>线程阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加元素</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>删除元素</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>读取元素</td>
<td>element()</td>
<td>peek()</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>前面两个是队列的，后面两个是阻塞队列的。这个具体等到队列那里再说。这里先把几个BlockingQueue的实现类列一下：</p>
<ul>
<li>LinkedBlockingQueue类： 默认情况下，LinkedBlockingQueue的容量是没有上限的，也可以指定大小，这是基于链表的队列</li>
<li>ArrayBlockingQueue类： ArrayBlockingQueue(int capacity, boolean fair)可以设定容量，并且可以选择是否采用公平策略。这是基于数组的队列。</li>
<li>PriorityBlockingQueue：这是优先队列（堆）</li>
<li>DelayQueue: 这个队列中存放的是延期元素。这些元素必须实现java.util.concurrent.Delayed接口。只有延期满的元素才可以被取出或者删除。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>python wxpython</title>
    <url>/post/235252ea.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="事件处理"><a class="markdownIt-Anchor" href="#事件处理"></a> 事件处理</h1>
<p>事件就是状态改变时发出的信号，然后你可以通过绑定指定一个函数去处理。例如按下按钮就产生了一个事件，之后可以让一个函数去处理按下按钮之后的反应。</p>
<p>绑定函数使用 Bind(event, handler, source=None, id=wx.ID_ANY, id2=wx.ID_ANY).event是产生的事件，handler是处理事件的方法,source是触发事件的对象。</p>
<p>例如 Bind(wx.EVT_BUTTON, self.Button_enter, button1)这样button1按下时会使用Button_enter函数</p>
<h1 id="frame"><a class="markdownIt-Anchor" href="#frame"></a> Frame</h1>
<p>方法： <code>Wx.Frame (parent, id, title, pos, size, style, name)</code></p>
<ul>
<li>parent是窗口父类，主要控制打开这个窗口时显示位置，一般显示在父窗口中央。如果是None显示在屏幕正中央。</li>
<li>id是窗口标识，一般选-1让id自动生成。</li>
<li>pos是左上角位置，用元组表示，例如(0,0),wx.DefaultPosition是由操作系统决定.</li>
<li>size是长和宽，wx.DefaultSize 是由操作系统决定。</li>
<li>style： 有wx.DEFAULT_FRAME_STYLE，wx.CAPTION，wx.MINIMIZE_BOX，wx.MAXIMIZE_BOX，wx.CLOSE_BOX，wx.SYSTEM_MENU，wx.RESIZE_BORDER，wx.STAY_ON_TOP，wx.FRAME_FLOAT_ON_PARENT</li>
<li>name： 内部用名</li>
</ul>
<p><img src="/images/wxpython4.png" alt="" /></p>
<p>例： window = wx.Frame(None, -1, “Hello”, pos = (10,10), size = (300,200),style = wxDEFAULT_FRAME_STYLE, name = “frame”)</p>
<p>成员函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CreateStatusBar()</td>
<td>创建窗口底部状态栏</td>
</tr>
<tr>
<td>CreateToolBar()</td>
<td>在顶部或左侧创建工具栏</td>
</tr>
<tr>
<td>GetMenuBar()</td>
<td>获取引用菜单栏</td>
</tr>
<tr>
<td>GetStatusBar()</td>
<td>获取引用状态栏</td>
</tr>
<tr>
<td>SetMenuBar()</td>
<td>显示菜单栏对象</td>
</tr>
<tr>
<td>setStatusBar()</td>
<td>关联状态栏对象到框架</td>
</tr>
<tr>
<td>SetToolBar()</td>
<td>关联工具栏对象到框架</td>
</tr>
<tr>
<td>SetStatusText()</td>
<td>在状态栏上显示的文字</td>
</tr>
<tr>
<td>Create()</td>
<td>创建有参数的框架</td>
</tr>
<tr>
<td>Centre()</td>
<td>让这个框架在中心</td>
</tr>
<tr>
<td>SetPosition()</td>
<td></td>
</tr>
<tr>
<td>SetSize()</td>
<td></td>
</tr>
<tr>
<td>SetTitle()</td>
<td></td>
</tr>
</tbody>
</table>
<p>事件：</p>
<ul>
<li>EVT_CLOSE： 当点击关闭按钮时</li>
<li>EVT_MENU_OPEN： 一个菜单要被打开时</li>
<li>EVT_MENU_CLOSE: 一个菜单被关闭后时</li>
<li>EVT_MENU_HIGHLIGHT： 让指定菜单凸显</li>
</ul>
<h1 id="panel"><a class="markdownIt-Anchor" href="#panel"></a> panel</h1>
<p>创建： wx.panel(parent, id=ID_ANY, pos=DefaultPosition, size=DefaultSize,<br />
style=TAB_TRAVERSAL, name=PanelNameStr)</p>
<p>parent指定了和Frame之间的父子关系。要定位布局或确定其他父子关系通过sizer(定位器)来完成(相当于layout)</p>
<h1 id="定位器"><a class="markdownIt-Anchor" href="#定位器"></a> 定位器</h1>
<p>下面是常见定位器：</p>
<ul>
<li>wx.BoxSizer(): 把窗口布置成水平或垂直框,有水平(wx.HORIZONTAL)和垂直布局(wx.VERTICAL)，默认水平</li>
<li>wx.StaticBoxSizer(orient,parent,label=&quot;&quot;)： 这是带有名字的StaticBoxSizer.创建的是一个静态框，也就是一个边框并且边框上有label</li>
<li>wx.StaticBoxSizer(box,orient=HORIZONTAL)： box是一个staticbox对象。</li>
<li>GridSizer(rows,cols,vgap,hgap): GridSizer创建一个若干行和列的小方格。其中vgap和hgap是两个方格之间的水平间隔和垂直间隔。</li>
<li>wx.FlexGridSizer(): GridSizer创建的方格大小是固定的，而FlexGridSizer大小可以改变。他有两个特殊的方法：AddGrowableRow(idx,proportion=0)、AddGrowableCo(idx,proportion=0).</li>
<li>wx.GridBagSizer(vgap,hgap): 这个可以横跨多个行和列。它的Add(control, pos, span, flags, border)，其中span是横跨的行数和列数，用一个元组表示。position是必须参数。它也可以用AddGrowableCo().idx是你想扩张的行，proportion是增加的比例。只要你的控件在那个行里拉伸时就会拉伸那个控件</li>
</ul>
<p>BoxSizer方法：</p>
<ul>
<li>AddSpacer()： 添加不可伸缩空间</li>
<li>AddStretchSpacer() ： 添加可伸缩空间</li>
<li>Clear(): 删除控件</li>
<li>Remove(): 销毁并删除一个控件</li>
</ul>
<p>调用容器的Fit()可以自动调整大小</p>
<p><strong>定位器的add函数</strong></p>
<p>add都是继承自wx.Sizer.</p>
<p>语法： Add(window,proportion=0,flag=0,border=0,userData=None)： window可以使要添加的组件，也可以是另外一个Sizer（嵌套）。</p>
<ul>
<li>proportion： 权重。如果为1表示sizer大小变化时，组件大小也会随之变化，变化速度为1。其值有0,1,2</li>
<li>flag： 用来控制对齐，边框和调整尺寸</li>
<li>border： 边框</li>
<li>userData： 用来传递额外的数据</li>
</ul>
<p>flag类型：</p>
<p><img src="/images/wxpython1.png" alt="" /><br />
<img src="/images/wxpython2.png" alt="" /><br />
<img src="/images/wxpython3.png" alt="" /></p>
<h1 id="statictext"><a class="markdownIt-Anchor" href="#statictext"></a> StaticText</h1>
<p>statictext是一个只读文本。</p>
<p>创建： Wx.StaticText(parent, id, label, position, size, style)：size是字号。style和上面的有所不同</p>
<p>style类型：</p>
<ul>
<li>wx.ALIGN_RIGHT,wx.ALIGN_LEFT,wx.ALIGN_CENTER: 控制文本出现位置</li>
<li>wx.ST_NO_AUTORESIZE: 防止标签的自动调整大小</li>
<li>wx.ST_ELLIPSIZE_START， wx.ST_ELLIPSIZE_MIDDLE， wx.ST_ELLIPSIZE_END: 省略号显示位置，有开始中间或结尾</li>
</ul>
<p>如果想要设置字体，首先要创建一个<code>wx.Font(pointSize,family,style,weight,underline,faceName,encoding)</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">family</span>: <span class="selector-tag">wx</span><span class="selector-class">.DECORATIVE</span>：一个正式的，老的英文样式字体。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.DEFAULT</span>：系统默认字体。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.MODERN</span>：一个单间隔（固定字符间距）字体。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.ROMAN</span>：<span class="selector-tag">serif</span>字体，通常类似于<span class="selector-tag">Times</span> <span class="selector-tag">New</span> <span class="selector-tag">Roman</span>。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.SCRIPT</span>：手写体或草写体。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.SWISS</span>：<span class="selector-tag">sans-serif</span>字体，通常类似于<span class="selector-tag">Helvetica</span>或<span class="selector-tag">Arial</span>。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.FONTSTYLE_ITALIC</span>是斜体、<span class="selector-tag">wx</span><span class="selector-class">.FONTSTYLE_SLANT</span>罗马式斜体</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">style</span>: 指定文本是否倾斜，<span class="selector-tag">SLANT</span>是罗马式倾斜</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.NORMAL</span>,</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.SLANT</span>,</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.ITALIC</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">weight</span>：控制字体醒目程度</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.NORMAL</span>,</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.LIGHT</span>,</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.BOLD</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">underline</span>： 下划线，如果是<span class="selector-tag">True</span>就是有</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">faceName</span>： 指定字体名字</span><br></pre></td></tr></table></figure>
<p>最后使用SetFont方法添加</p>
<h1 id="textctrl-文本框"><a class="markdownIt-Anchor" href="#textctrl-文本框"></a> TextCtrl 文本框</h1>
<p>创建： wx.TextCtrl(parent, id, value, pos, size, style)</p>
<p>value是起始文本</p>
<p>style参数：</p>
<ul>
<li>wx.TE_MULTILINE。允许文本框多行</li>
<li>wx.TE_PASSWORD。 输入变成星号，相当于密码框</li>
<li>wx.TE_READONLY. 只读</li>
<li>wx.TE_LEFT</li>
<li>wx.TE_RIGHT</li>
<li>wx.TE_CENTER</li>
<li>wx.HSCROLL: 纵向滚动条</li>
<li>wx.VSVROLL: 横向滚动条</li>
</ul>
<p>wx.TextAttr(colText, colBack=wx.NullColor, font=wx.NullFont)  : 分别是 分别为字体颜色，背景色，字体。文本色和背景色为wxPython对象，可由颜色名或颜色的RGB值（红，绿，蓝）来 指定</p>
<p>绑定事件：EVT_TEXT(改变文本框内容时），EVT_TEXT_ENTER(按下enter键时），EVT_TEXT_MAXLEN（当文本长度达到SetMaxLength()设定的长度时）</p>
<h1 id="button"><a class="markdownIt-Anchor" href="#button"></a> Button</h1>
<p>button是最普通的按钮，BitmapButton是用图片做按钮，ToggleButton有两种状态：按下和弹起。</p>
<p>button和ToggleButton的构造函数的参数都相同：<code>Wx.Button(parent, id, label, pos, size, style)。</code></p>
<p>其中label是显示在button上的文本。wx.BU_EXACTFIT是跨平台标记，使用了它就不会用系统默认的的尺寸作为最小尺寸，可以使用wx.BU_LEFT等标记设置对齐</p>
<p>BitmapButton的构造函数：</p>
<ul>
<li>Wx.Bitmap(fiiename, wx.BITMAP_TYPE)</li>
<li>Wx.BitmapButton(parent, id, bitmap, pos, size, style)</li>
</ul>
<p>BitmapButton有一些预定义的图片类型常量：</p>
<ul>
<li>wx.BITMAP_TYPE_BMP</li>
<li>wx.BITMAP_TYPE_ICO</li>
<li>wx.BITMAP_TYPE_CUR</li>
<li>wx.BITMAP_TYPE_TIFF</li>
<li>wx.BITMAP_TYPE_TIF</li>
<li>wx.BITMAP_TYPE_GIF</li>
<li>wx.BITMAP_TYPE_PNG</li>
<li>wx.BITMAP_TYPE_JPEG</li>
<li>wx.BITMAP_TYPE_PCX</li>
<li>wx.BITMAP_TYPE_ICON</li>
<li>wx.BITMAP_TYPE_ANY</li>
</ul>
<p>方法：</p>
<ul>
<li>
<p>SetLabel()： 设置标题</p>
</li>
<li>
<p>GetLabel()</p>
</li>
<li>
<p>SetDefault()： 按钮设置为默认顶层窗口。模拟click事件按下回车键</p>
</li>
<li>
<p>GetValue()： 这是ToggleButton的，获得按钮的状态。此外还有SetValue</p>
</li>
</ul>
<p>Button的事件是EVT_BUTTON</p>
<h2 id="radiobutton-radiobox"><a class="markdownIt-Anchor" href="#radiobutton-radiobox"></a> RadioButton &amp; RadioBox</h2>
<p>每个RadioButton会显示一个圆形的框。一般是用它做一组按钮，同一时刻只能选择其中一个。</p>
<p>如果想要多个选项中选择一个选项，首先需要把样式设置成wx.RB_GROUP。</p>
<p>RadioBox提供了边框和标签组.</p>
<p>构造函数： RadioButton(parent, id, label, pos, size, style)</p>
<p>style参数仅用于该组中的第一个按钮。它的值是wx.RB_GROUP。对于组中的随后的按钮，wx.RB_SINGLE的style 参数可以任选地使用。</p>
<p>事件： wx.EVT_RADIOBUTTON</p>
<p>RadioBox构造函数：<code>RadioBox(parent, id, label, pos, size, choices[], initialdimensions, style)</code></p>
<ul>
<li>style: wx.RA_SPECIFY_ROWS或wx.RA_SPECIFY_COLS</li>
<li>initialdimensions: 最初的行\列数</li>
<li>choices[]: 按钮名列表</li>
<li>label也可以是一个图片</li>
</ul>
<p>RadioBox的方法：</p>
<ul>
<li>GetSelection()： 返回所选项目的索引</li>
<li>SetSelection()： 选择编程项目</li>
<li>GetString(): 获得所选项的标签</li>
<li>Show(): 显示或隐藏指定标签</li>
</ul>
<p>事件： wx.EVT_RADIOBOX。</p>
<p>例：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">self.<span class="attr">rb1</span> = wx.RadioButton(pnl,<span class="number">11</span>, <span class="attr">label</span> = &#x27;Value A&#x27;, <span class="attr">pos</span> = (<span class="number">10</span>,<span class="number">10</span>), <span class="attr">style</span> = wx.RB_GROUP) </span><br><span class="line">self.<span class="attr">rb2</span> = wx.RadioButton(pnl,<span class="number">22</span>, <span class="attr">label</span> = &#x27;Value B&#x27;,<span class="attr">pos</span> = (<span class="number">10</span>,<span class="number">40</span>)) </span><br><span class="line">self.<span class="attr">rb3</span> = wx.RadioButton(pnl,<span class="number">33</span>, <span class="attr">label</span> = &#x27;Value C&#x27;,<span class="attr">pos</span> = (<span class="number">10</span>,<span class="number">70</span>))</span><br><span class="line"></span><br><span class="line">RadioBox</span><br><span class="line"></span><br><span class="line"><span class="attr">lblList</span> = [&#x27;Value X&#x27;, &#x27;Value Y&#x27;, &#x27;Value Z&#x27;]     </span><br><span class="line">self.<span class="attr">rbox</span> = wx.RadioBox(pnl,<span class="attr">label</span> = &#x27;RadioBox&#x27;, <span class="attr">pos</span> = (<span class="number">80</span>,<span class="number">10</span>), <span class="attr">choices</span> = lblList ,<span class="attr">majorDimension</span> = <span class="number">1</span>, <span class="attr">style</span> = wx.RA_SPECIFY_ROWS)</span><br></pre></td></tr></table></figure>
<h1 id="checkbox"><a class="markdownIt-Anchor" href="#checkbox"></a> CheckBox</h1>
<p><img src="/images/wxpython7.PNG" alt="" /></p>
<p>上图就是复选框，复选框可以有多个，允许用户多选</p>
<p>构造函数： Wx.CheckBox(parent, id, label, pos, size, style)</p>
<p>style有：</p>
<ul>
<li>wx.CHK_2STATE： 有两种选择，选或不选，这也是默认选项。</li>
<li>wx.CHK_3STATE： 三态复选框，第三状态称为混合或不确定的状态，一般用在“不适用”情景。</li>
<li>wx.ALIGN_RIGHT： 把名字放在左边，复选框放在右边</li>
</ul>
<p>方法：</p>
<ul>
<li>GetState()返回true或false</li>
<li>GetLabel()</li>
</ul>
<h1 id="combobox-choice"><a class="markdownIt-Anchor" href="#combobox-choice"></a> ComboBox &amp; Choice</h1>
<p>ComboBox是一个下拉列表或者也可以永久显示。Choice也是下拉列表，但是只能只读。</p>
<p>构造方法： ComboBox(parent, id, value, pos, size, choices[], style)：choices是要填充进下拉列表的文本。value是最开始在框中显示的文本</p>
<p>style参数：</p>
<ul>
<li>wx.CB_SIMPLE: 组合框和永久显示的列表</li>
<li>wx.CB_DROPDOWN: 组合框和永久显示的列表</li>
<li>wx.CB_READONLY： 只读</li>
<li>wx.CB_SORT： 按字母排序</li>
</ul>
<p>方法：</p>
<ul>
<li>GetCurrentSelection (): 获得当前被选中的项目</li>
<li>SetSelection(i)： 设置i为被选中状态</li>
<li>GetString(i): 获得i的字符串</li>
<li>SetString()</li>
<li>SetValue()</li>
<li>FindString()： 搜索列表中字符串</li>
<li>GetStringSelection()： 获得当前项目选中的文本</li>
</ul>
<p>事件：</p>
<ul>
<li>wx. COMBOBOX： 当有项目被选择时</li>
<li>wx. EVT_TEXT： 组合框文本发生变化</li>
<li>wx. EVT_COMBOBOX_DROPDOWN： 下拉列表时</li>
<li>wx. EVT_COMBOBOX_CLOSEUP： 列表折叠时</li>
</ul>
<h1 id="gauge-测量仪"><a class="markdownIt-Anchor" href="#gauge-测量仪"></a> Gauge 测量仪</h1>
<p>Gauge其实是进度条，有确定模式和不确定模式两种。确定模式即显示百分比</p>
<p>在确定模式，进度位置会定期更新。在不确定模式，调用 Pulse() 函数将更新进度条。</p>
<p>构造函数： wx.Gauge(parent, id, range, pos, size, style)： range是表上的最大值，如果是不确定模式忽略此参数。</p>
<p>style参数：</p>
<ul>
<li>wx.GA_HORIZONTAL</li>
<li>wx.GA_VERTICAL</li>
<li>wx.GA_SMOOTH： 平滑的进度条，一个像素一个像素的更新</li>
<li>wx.GA_TEXT： 显示百分比形式</li>
</ul>
<p>方法：</p>
<ul>
<li>GetRange(): 获得进度条的最大值</li>
<li>SetRange()： 设置进度条的最大值</li>
<li>GetValue()</li>
<li>Pulse(): 切换成不确定模式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_frame</span>(<span class="params">wx.Frame</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(parent=<span class="literal">None</span>, title=<span class="string">&quot;差评原因&quot;</span>, size=(<span class="number">1000</span>, <span class="number">600</span>))</span><br><span class="line">        self.Centre()</span><br><span class="line">        panel = wx.Panel(parent=self)</span><br><span class="line">        value = [<span class="string">&#x27;choice1&#x27;</span>, <span class="string">&#x27;choice2&#x27;</span>, <span class="string">&#x27;choice3&#x27;</span>]</span><br><span class="line">        self.gauge = wx.Gauge(panel, <span class="built_in">range</span>=<span class="number">20</span>, style=wx.GA_HORIZONTAL)</span><br><span class="line">        button = wx.Button(panel, label=<span class="string">&#x27;开始&#x27;</span>)</span><br><span class="line">        self.Bind(wx.EVT_BUTTON, self.Onstart, button)</span><br><span class="line"></span><br><span class="line">        sizer = wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        sizer.Add(self.gauge)</span><br><span class="line">        sizer.Add(button)</span><br><span class="line">        panel.SetSizer(sizer)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Onstart</span>(<span class="params">self, e</span>):</span></span><br><span class="line">        value = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            value += <span class="number">1</span></span><br><span class="line">            self.gauge.SetValue(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">app</span>(<span class="params">wx.App</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">OnInit</span>(<span class="params">self</span>):</span></span><br><span class="line">        frame = my_frame()</span><br><span class="line">        frame.Show()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">OnExit</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;退出&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = app()</span><br><span class="line">    app.MainLoop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/wxpython8.PNG" alt="" /></p>
<h1 id="slider"><a class="markdownIt-Anchor" href="#slider"></a> Slider</h1>
<p>Slider是一个滑块</p>
<p>构造函数： wx.Slider(parent, id, value, minValue, maxValue, pos, size, style) :</p>
<p>style参数：</p>
<ul>
<li>wx.SL_HORIZONTAL</li>
<li>wx.SL_VERTICAL</li>
<li>wx.SL_AUTOTICKS: 自动显示刻度线</li>
<li>wx.SL_LABELS: 显示最大值，最小值和当前值</li>
<li>wx.SL_MIN_MAX_LABELS: 只显示最大值和最小值</li>
<li>wx.SL_VALUE_LABEL： 只显示当前值</li>
</ul>
<p>方法：</p>
<ul>
<li>上面参数的set和get方法</li>
<li>SetTick()： 在给定位置显示刻度线</li>
<li>SetTickFreq()： 显示最大刻度和最小刻度之间的刻度间隔</li>
</ul>
<p>事件：</p>
<ul>
<li>wx.EVT_SCROLL： 因为他类似于滚动条，所以绑定滚动事件也可以发挥作用</li>
<li>wx.EVT_SLIDER: 刻度条位置发生变化时</li>
</ul>
<h1 id="menuitem-menu-menubar-菜单栏"><a class="markdownIt-Anchor" href="#menuitem-menu-menubar-菜单栏"></a> MenuItem, Menu &amp; MenuBar 菜单栏</h1>
<p>菜单栏就是应用程序最顶端显示的一些菜单。</p>
<p>MenuBar是创建一个菜单栏，然后Menu就是菜单栏上的菜单，MeunItem是菜单中的一个个选项</p>
<p>ManuBar构造函数： wx.MenuBar(n, menus, titles, style) ： n是菜单数量，menus是标题的字符串，style只有wx.MB_DOCKABLE，菜单栏可以停靠。</p>
<p>设置完后可以用frame.SetMenuBar()把菜单加进去</p>
<p>方法：</p>
<ul>
<li>Append()： 添加菜单到菜单栏</li>
<li>Check()： 选中菜单</li>
<li>Enable()</li>
<li>Remove()</li>
</ul>
<p>Menu一般使用空的构造方法</p>
<p>Menu的方法；</p>
<ul>
<li>
<p>Append(menu, title)： 添加一个菜单项,title是菜单的名字。</p>
</li>
<li>
<p>AppendMenu()： 添加一个子菜单</p>
</li>
<li>
<p>AppendRadioItem()： 追加可选当前项</p>
</li>
<li>
<p>AppendCheckItem()： 追加可检查当前项</p>
</li>
<li>
<p>AppendSeparator()： 添加分割线</p>
</li>
<li>
<p>Insert()： 在指定位置插入一个新菜单。后面还有几个Insert和上面一样</p>
</li>
<li>
<p>GetMenuItems() ： 返回菜单项列表</p>
</li>
<li>
<p>Remove()</p>
</li>
<li>
<p>wx.MenuItem.SetBitmap(wx.Bitmap(image file))： 设置图像</p>
</li>
</ul>
<p>MenuItem构造函数： wx.MenuItem(parentMenu, id, text, kind)：text是菜单项的名字</p>
<ul>
<li>kind是菜单项的类型，有wx.ITEM_NORMAL(普通菜单项,相当于Button),wx.ITEM_CHECK（检查菜单项，相当于ToggleButton), wx.ITEM_RADIO(单选菜单项,相当于RadioButton）</li>
</ul>
<p>如果想要添加快捷键，使用text参数。<code>text = &quot;名称/t快捷键&quot;</code>.例如text = &quot;Quit/tCtrl+Q&quot;这样为名称是Quit的菜单项注册了Ctrl+Q的快捷键</p>
<p>菜单项有一系列标准ID： wx.ID_SEPARATOR，wx.ID_ANY，wx.ID_OPEN，wx.ID_CLOSE，wx.ID_NEW，wx.ID_SAVE，wx.ID_SAVEAS，wx.ID_EDIT，wx.ID_CUT，wx.ID_COPY，wx.ID_PASTE</p>
<p>事件： EVT_MENU。然后可以使用e.GetId()的方法得知选了哪个菜单项</p>
<h1 id="toolbar"><a class="markdownIt-Anchor" href="#toolbar"></a> ToolBar</h1>
<p>工具栏包括文本文字说明或图标按钮的一个或多个水平条，通常放在MenuBar下面。</p>
<p>构造函数： Wx.ToolBar(parent, id, pos, size, style)：</p>
<p>style:</p>
<ul>
<li>wx.TB_FLAT: 平面效果</li>
<li>wx.TB_HORIZONTAL</li>
<li>wx.TB_VERTICAL</li>
<li>wx.TB_DEFAULT_STYLE: 综合FLAT和HORIZONAL</li>
<li>wx.TB_DOCKABLE： 使工具栏可以浮动和停靠</li>
<li>wx.TB_NO_TOOLTIPS ： 不显示提示</li>
<li>wx.TB_NOICONS： 没有图标</li>
<li>wx.TB_TEXT： 显示文本，默认情况下只有图标</li>
</ul>
<p>函数：</p>
<ul>
<li>AddTool(parent, id, bitmap)： 添加工具到工具栏</li>
<li>AddRadioTool()： 添加Radio组，即这些选项中只能选择一个</li>
<li>AddCheckTool()： 添加复选框</li>
<li>AddLabelTool()： 添加标签</li>
<li>AddSeparator()： 添加分隔符</li>
<li>AddControl()： 添加其他组件。例如Button ComboBox等</li>
<li>ClearTools()： 删除所有在工具栏中的按钮</li>
<li>RemoveTool()： 删除组件</li>
<li>Realize()： 增加调用，最后必须要写</li>
</ul>
<p>事件： EVT_TOOL。这个事件只负责传递，具体实现还需要GetId然后判断ID进行处理。</p>
<p>注意，如果是通过AddControl加进来的方法不能通过EVT_TOOL响应，必须要通过他们自己的事件进行响应。</p>
<h1 id="dialog"><a class="markdownIt-Anchor" href="#dialog"></a> Dialog</h1>
<p>Dialog就是平常弹出的对话框，如程序崩溃时发出的警告消息等。</p>
<p>wxpython中预定义了一些Dialog。如：MessageDialog，FileDialog，FontDialog类等。</p>
<p>构造函数：wx.Dialog(parent, id, title, pos, size, style)</p>
<p>style：</p>
<ul>
<li>wx.CAPTION： 对话框的文字说明</li>
<li>wx.DEFAULT_DIALOG_STYLE；相当于wx.CAPTION，wx.CLOSE_BOX和wx.SYSTEM_MENU的组合</li>
<li>wx.RESIZE_BORDER: 显示可调框架窗口大小</li>
<li>wx.SYSTEM_MENU: 显示系统菜单</li>
<li>wx.CLOSE_BOX： 显示关闭</li>
<li>wx.MAXIMIZE_BOX： 显示最大化菜单</li>
<li>wx.MINIMIZE_BOX</li>
<li>wx.STAY_ON_TOP: 该窗口显示在所有窗口顶部</li>
<li>wx.DIALOG_NO_PARENT</li>
</ul>
<p>事件：</p>
<ul>
<li>EVT_CLOSE： 关闭时产生</li>
<li>EVT_INIT_DIALOG： 初始化时产生</li>
</ul>
<p>函数：</p>
<ul>
<li>DoOK()： 当按下ok键时调用</li>
<li>ShowModal()： 显示了在应用程序模态方式的对话框</li>
<li>ShowWindowModal()： 对话框显示在顶层父窗口的模式</li>
<li>EndModal()： ShowModal调用传递值结束一个对话框模式</li>
</ul>
<h2 id="messagedialog"><a class="markdownIt-Anchor" href="#messagedialog"></a> MessageDialog</h2>
<p>构造函数： wx.MessageDialog(parent, message, caption, style, pos) :caption是标题</p>
<p>style:</p>
<ul>
<li>wx.OK： 有是否两个选项，用了这个就不能用YES_NO或YES</li>
<li>wx.CANCEL</li>
<li>wx.YES_NO: 有是否取消三个选项。</li>
<li>WX.YES_DEFAULT: 使yes按钮为默认</li>
<li>wx.NO_DEFAULT</li>
<li>wx.ICON_EXCLAMATION： 显示警告图标</li>
<li>wx.ICON_ERROR</li>
<li>wx.ICON_INFORMATION： 显示一个信息图标</li>
<li>wx.ICON_QUESTION</li>
</ul>
<p>还有一种简便形式是MessageBox,直接就可以展示，不需要Show。</p>
<p>例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">a = wx.<span class="constructor">MessageDialog(<span class="params">self</span>.<span class="params">panel</span>, <span class="string">&quot;消息&quot;</span>, <span class="string">&quot;标题&quot;</span>, <span class="params">style</span>=<span class="params">wx</span>.OK | <span class="params">wx</span>.CANCEL | <span class="params">wx</span>.ICON_ERROR)</span>.<span class="constructor">ShowModal()</span></span><br><span class="line"></span><br><span class="line">wx.<span class="constructor">MessageBox(<span class="string">&quot;消息&quot;</span>, &#x27;标题&#x27;, <span class="params">style</span>=<span class="params">wx</span>.OK | <span class="params">wx</span>.CANCEL | <span class="params">wx</span>.ICON_ERROR)</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/wxpython9.PNG" alt="" /></p>
<h2 id="textentrydialog"><a class="markdownIt-Anchor" href="#textentrydialog"></a> TextEntryDialog</h2>
<p>这个类的对象显示一个文本字段，可定制的标签，提示用户输入以及两个按钮使用预定义样式的对话框。里面的文本框是TextCtrl，所以Style可以使用TextCtrl的</p>
<p>构造函数： wx.TextEntryDialog(parent, id, message, caption, value, style, pos) ： value是默认字符串。</p>
<p>方法：</p>
<ul>
<li>SetMaxLength()： 设置文本输入最大长度</li>
<li>SetValue()</li>
<li>GetValue()： 返回文本框中的内容</li>
<li>ShowModal()： 返回 wx.ID_OK 如果用户确认输入，以及 wx.ID_CANCEL 如果对话框被拒绝</li>
</ul>
<p>例：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">a = wx.TextEntryDialog(self.panel, <span class="attribute">message</span>=<span class="string">&#x27;看一看&#x27;</span>, <span class="attribute">caption</span>=<span class="string">&#x27;标题&#x27;</span>)</span><br><span class="line">a.SetMaxLength(20)</span><br><span class="line"><span class="keyword">if</span>(a.ShowModal() == wx.ID_OK):</span><br><span class="line">    <span class="builtin-name">print</span>(a.GetValue())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">&#x27;nothing&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/wxpython10.PNG" alt="" /></p>
<h2 id="filedialog"><a class="markdownIt-Anchor" href="#filedialog"></a> FileDialog</h2>
<p>此类表示一个文件选择对话框。它使用户可以浏览文件系统并选择要打开文件或保存.文件滤波器也可以应用到只显示指定扩展名的文件。启动目录和默认的文件名也可以设置。</p>
<p>构造函数： wx.FileDialog(parent, message, DefaultDir, DefaultFile, wildcard, style, pos, size) ： DefaultDir是默认目录， DefaultFile是默认选择文件.wildcard是筛选器，可以使用正则表达式</p>
<p>style参数：</p>
<ul>
<li>wx.FD_DEFAULT_STYLE： 相当于wx.FD_OPEN</li>
<li>wx.FD_OPEN： 打开对话框，默认标题是打开</li>
<li>wx.FD_SAVE</li>
<li>wx.FD_OVERWRITE_PROMPT： 保存对话框，如果一个文件被覆盖时会提示</li>
<li>wx.FD_MULTIPLE： 允许选择多个文件</li>
<li>wx.FD_CHANGE_DIR： 更改当前工作目录到用户选择的文件目录</li>
</ul>
<p>方法：</p>
<ul>
<li>GetDirectory()： 返回默认目录</li>
<li>GetFileName()： 返回默认文件名</li>
<li>GetPath()： 获得选定文件的完整目录</li>
<li>SetDirectory()</li>
<li>SetFileName()</li>
<li>SetPath()</li>
<li>ShowModal(): 如果用户单击OK按钮返回wx.ID_OK，否则 wx.ID_CANCEL</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">filesFilter = <span class="string">&quot;txt(*.txt) | *.txt|&quot;</span> <span class="string">&quot;All files (*.*)|*.*&quot;</span></span><br><span class="line">        a = wx.<span class="constructor">FileDialog(<span class="params">self</span>.<span class="params">panel</span>, &#x27;看一看&#x27;, &#x27;C:<span class="operator">/</span>&#x27;, &#x27;C:<span class="operator">/</span>Program Files&#x27;, <span class="params">filesFilter</span>, <span class="params">wx</span>.FD_OPEN)</span></span><br><span class="line">        <span class="keyword">if</span>(a.<span class="constructor">ShowModal()</span><span class="operator"> == </span>wx.ID_OK):</span><br><span class="line">            <span class="keyword">with</span> <span class="keyword">open</span>(a.<span class="constructor">GetPath()</span>, <span class="character">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                self.text.<span class="constructor">SetValue(<span class="params">f</span>.<span class="params">read</span>()</span>)</span><br><span class="line">        a.<span class="constructor">Destroy()</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/wxpython12.PNG" alt="" /></p>
<h1 id="fontdialog"><a class="markdownIt-Anchor" href="#fontdialog"></a> FontDialog</h1>
<p>这个类的对象是一个字体选择对话框,所选字体的形式返回作为此对话框的返回值。</p>
<p>构造函数：wx.FontDialog(parent, data)： data一般使用wx.FontData()</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">a = wx.<span class="constructor">FontDialog(<span class="params">self</span>, <span class="params">wx</span>.FontData()</span>)</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="constructor">ShowModal()</span><span class="operator"> == </span>wx.ID_OK):</span><br><span class="line">            data = a.<span class="constructor">GetFontData()</span></span><br><span class="line">            font = data.<span class="constructor">GetChosenFont()</span></span><br><span class="line">            self.text.<span class="constructor">SetFont(<span class="params">font</span>)</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/wxpython13.PNG" alt="" /></p>
<h1 id="window"><a class="markdownIt-Anchor" href="#window"></a> Window</h1>
<h2 id="splitterwindow"><a class="markdownIt-Anchor" href="#splitterwindow"></a> SplitterWindow</h2>
<p>这个类的对象是一个布局管理器，它拥有两个子窗口的大小可以通过拖动它们之间的界限来动态变化。Splitter控件给出了句柄来拖动调整控件。</p>
<p>构造函数： wx.SplitterWindow(self, id, pos, size, style)</p>
<p>style：</p>
<ul>
<li>wx.SP_3D： 绘制3D效果的边框和窗扇(sash)</li>
<li>wx.SP_THIN_SASH： 绘制一个薄的sash</li>
<li>wx.SP_3DSASH: 绘制3D效果的sash</li>
<li>wx.SP_BORDER: 绘制标准边框</li>
<li>wx.SP_NOBORDER： 无边框（默认）</li>
<li>wx.SP_PERMIT_UNSPLIT: 总是允许取消分割，即使采用最小的窗格大小不为零</li>
</ul>
<p>方法：</p>
<ul>
<li>SplitVertically(panel1, panel2): 设置左右面板，这两个面板的父亲必须是该splitterwindow</li>
</ul>
<p>事件：</p>
<ul>
<li>EVT_SPLITTER_SASH_POS_CHANGING()： sash位置改变时</li>
<li>EVT_SPLITTER_SASH_POS_CHANGED()： 窗框位置改变时</li>
<li>EVT_SPLITTER_UNSPLIT()： 一直取消分割</li>
<li>EVT_SPLITTER_DCLICK()： 窗框被双点击。默认行为是在取消分割窗口出现这种情况时</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import wx</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my<span class="constructor">_frame(<span class="params">wx</span>.Frame)</span>:</span><br><span class="line">    def <span class="constructor">__init__(<span class="params">self</span>)</span>:</span><br><span class="line">        super<span class="literal">()</span>.<span class="constructor">__init__(<span class="params">parent</span>=None, <span class="params">title</span>=<span class="string">&quot;差评原因&quot;</span>, <span class="params">size</span>=(1000, 600)</span>)</span><br><span class="line">        split = wx.<span class="constructor">SplitterWindow(<span class="params">self</span>, <span class="params">style</span>=<span class="params">wx</span>.SP_3D)</span></span><br><span class="line">        self.<span class="constructor">Centre()</span></span><br><span class="line">        self.panel = wx.<span class="constructor">Panel(<span class="params">parent</span>=<span class="params">split</span>)</span></span><br><span class="line">        value = <span class="literal">[&#x27;<span class="identifier">choice1</span>&#x27;, &#x27;<span class="identifier">choice2</span>&#x27;, &#x27;<span class="identifier">choice3</span>&#x27;]</span></span><br><span class="line"></span><br><span class="line">        panel2 = wx.<span class="constructor">Panel(<span class="params">split</span>)</span></span><br><span class="line"></span><br><span class="line">        button = wx.<span class="constructor">Button(<span class="params">self</span>.<span class="params">panel</span>, <span class="params">label</span>=&#x27;按钮&#x27;)</span></span><br><span class="line">        self.text = wx.<span class="constructor">TextCtrl(<span class="params">self</span>.<span class="params">panel</span>, <span class="params">style</span>=<span class="params">wx</span>.TE_MULTILINE)</span></span><br><span class="line">        self.text.<span class="constructor">SetEditable(False)</span></span><br><span class="line">        self.<span class="constructor">Bind(<span class="params">wx</span>.EVT_BUTTON, <span class="params">self</span>.Onstart, <span class="params">button</span>)</span></span><br><span class="line">        sizer = wx.<span class="constructor">BoxSizer(<span class="params">wx</span>.VERTICAL)</span></span><br><span class="line">        sizer.<span class="constructor">Add(<span class="params">button</span>, <span class="params">flag</span>=<span class="params">wx</span>.ALIGN_CENTER)</span></span><br><span class="line">        sizer.<span class="constructor">Add(<span class="params">self</span>.<span class="params">text</span>, <span class="params">border</span>=20, <span class="params">proportion</span>=1, <span class="params">flag</span>=<span class="params">wx</span>.ALL | <span class="params">wx</span>.EXPAND)</span></span><br><span class="line"></span><br><span class="line">        sizer2 = wx.<span class="constructor">BoxSizer(<span class="params">wx</span>.VERTICAL)</span></span><br><span class="line">        sizer2.<span class="constructor">Add(<span class="params">wx</span>.ListBox(<span class="params">panel2</span>, <span class="params">style</span>=<span class="params">wx</span>.LB_SINGLE)</span>, flag=wx.EXPAND, proportion=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.panel.<span class="constructor">SetSizer(<span class="params">sizer</span>)</span></span><br><span class="line">        panel2.<span class="constructor">SetSizer(<span class="params">sizer2</span>)</span></span><br><span class="line">        split.<span class="constructor">SplitVertically(<span class="params">panel2</span>, <span class="params">self</span>.<span class="params">panel</span>)</span></span><br><span class="line">    def <span class="constructor">Onstart(<span class="params">self</span>, <span class="params">e</span>)</span>:</span><br><span class="line">        a = wx.<span class="constructor">FontDialog(<span class="params">self</span>, <span class="params">wx</span>.FontData()</span>)</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="constructor">ShowModal()</span><span class="operator"> == </span>wx.ID_OK):</span><br><span class="line">            data = a.<span class="constructor">GetFontData()</span></span><br><span class="line">            font = data.<span class="constructor">GetChosenFont()</span></span><br><span class="line">            self.text.<span class="constructor">SetFont(<span class="params">font</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> app(wx.App):</span><br><span class="line">    def <span class="constructor">OnInit(<span class="params">self</span>)</span>:</span><br><span class="line">        frame = my<span class="constructor">_frame()</span></span><br><span class="line">        frame.<span class="constructor">Show()</span></span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def <span class="constructor">OnExit(<span class="params">self</span>)</span>:</span><br><span class="line">        print(<span class="string">&quot;退出&quot;</span>)</span><br><span class="line">        return <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__<span class="operator"> == </span>&#x27;__main__&#x27;:</span><br><span class="line">    app = app<span class="literal">()</span></span><br><span class="line">    app.<span class="constructor">MainLoop()</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/wxpython14.PNG" alt="" /></p>
<h2 id="htmlwindow"><a class="markdownIt-Anchor" href="#htmlwindow"></a> HtmlWindow</h2>
<p>wx.HtmlWindow对象是一个通用的HTML浏览器。他是在html1库中的。</p>
<p>构造函数： wx.htmll.HtmlWindow(Parent, id, pos, size, style)</p>
<p>样式：</p>
<ul>
<li>wx.HW_SCROLLBAR_NEVER: 永运不显示进度条</li>
<li>wx.HW_SCROLLBAR_AUTO： 只有在窗口放不下时才显示进度条</li>
<li>wx.HW_NO_SELECTION： 不让用户选择文本</li>
</ul>
<p>事件：</p>
<ul>
<li>EVT_HTML_CELL_CLICKED： 当一个wx.HtmlCell被点击</li>
<li>EVT_HTML_CELL_HOVER： 经过一个HtmlCell</li>
<li>EVT_HTML_LINK_CLICKED: 一个超链接被点击</li>
</ul>
<p>方法；</p>
<ul>
<li>AppendToPage()： Html追加到当前显示的文本，并刷新</li>
<li>HistoryBack()： 回到以前访问过的网页</li>
<li>HistoryForward()： 转到历史的下一页</li>
<li>LoadPage()： 加载一个Html文件</li>
<li>OnLinkClicked()： 超链接被点击时调用</li>
<li>SetPage()： 设置标记HTML的标签，文字作为页面内容</li>
</ul>
<h1 id="可停靠窗口"><a class="markdownIt-Anchor" href="#可停靠窗口"></a> 可停靠窗口</h1>
<p>大致过程：</p>
<ol>
<li>创建一个AuiManager对象。<code>self.mgr = wx.aui.AuiManager(self)</code></li>
<li>创建面板和里面的控件。</li>
<li>创建AuiPanelInfo. <code>info1 = wx.aui.AuiPaneInfo().Bottom()</code></li>
<li>把设计的面板添加到管理器。 <code>self.mgr.AddPane(pnl,info1)</code></li>
</ol>
<p>AuiPaneInfo参数：</p>
<ul>
<li>方向： Top, Bottom, Left, Right, 或 Center</li>
<li>位置： 多个窗格中可以放置一个可停靠的区域内。每个被赋予位置编号。</li>
<li>行： 多个窗格中显示在一排。就像一个以上的工具栏出现在同一行中。</li>
<li>层： 窗格可以放置在层中</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>swing面板和其他组件</title>
    <url>/post/ae8362df.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://blog.csdn.net/xietansheng/article/details/72814492">学习自</a></p>
<h1 id="面板"><a class="markdownIt-Anchor" href="#面板"></a> 面板</h1>
<h2 id="jpanel"><a class="markdownIt-Anchor" href="#jpanel"></a> JPanel</h2>
<p>可以在大布局里设计另一种布局</p>
<h2 id="jscrollpane-滚动面板"><a class="markdownIt-Anchor" href="#jscrollpane-滚动面板"></a> JScrollPane 滚动面板</h2>
<p>它可以显示在文本较多的时候显示水平或垂直滚动条。如JTextArea或JTextField（水平滚动）或JList等可以使用滚动面板</p>
<p>JScrollPane内有一个ViewPort（视口），表示JScrollPane的显示区域，视口内包含一个需要滚动的组件。</p>
<p>构造方法：</p>
<ul>
<li>JScrollPane(Component view, int vsbPolicy, int hsbPolicy): view是需要加入视口的组件，vsb和hsb是水平和垂直滚动策略。</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">策略取值</span><br><span class="line">ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED    <span class="regexp">//</span> 需要时显示（默认）</span><br><span class="line">ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER        <span class="regexp">//</span> 从不显示</span><br><span class="line">ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS       <span class="regexp">//</span> 总是显示</span><br><span class="line">水平就是把VERTICAL改成HORIZONAL</span><br></pre></td></tr></table></figure>
<p>方法：</p>
<ul>
<li>setViewportView(Component view)： 设置滚动条内组件(最好不要用add，容易出问题)</li>
<li>setVerticalScrollBarPolicy(int policy)： 垂直滚动条显示策略</li>
<li>setHorizontalScrollBarPolicy(int policy)： 水平滚动条显示策略</li>
<li>setWheelScrollingEnabled(boolean handleWheel)：是否响应鼠标，默认响应</li>
</ul>
<h2 id="jsplitpane-分隔面板"><a class="markdownIt-Anchor" href="#jsplitpane-分隔面板"></a> JSplitPane 分隔面板</h2>
<p>分隔面板可以分隔两个组件。组件位置可以是上下或者左右。并且两个组件的分割线可以拉伸。</p>
<p>构造方法：</p>
<ul>
<li>JSplitPane(int orientation, boolean continuousLayout, Component leftComponent, Component rightComponent)： orientation是分割方向，可以取JSplitPane.HORIZONTAL_SPLIT或JSplitPane.VERTICAL_SPLIT。continuousLayout是拖动分割线时是否重绘组件。如果是false，那么拖动完了才会重绘。后面两个参数时两个组件</li>
</ul>
<p>方法：</p>
<ul>
<li>setOrientation(int orientation)：设置分割方向</li>
<li>setLeftComponent(Component comp)：设置左边/上面组件</li>
<li>setRightComponent(Component comp)</li>
<li>setContinuousLayout(boolean continuousLayout)</li>
<li>setOneTouchExpandable(boolean newValue)： 分隔条上快速折叠/展开组件小按钮</li>
<li>setDividerSize(int newSize)： 分隔条宽度</li>
<li>setDividerLocation(int location)：分隔条位置，相对于左边/上面的像素值</li>
<li>setDividerLocation(double proportionalLocation)： 这个是在0到1间取值，也是位置。</li>
</ul>
<h2 id="jtabbedpane-选项卡面板"><a class="markdownIt-Anchor" href="#jtabbedpane-选项卡面板"></a> JTabbedPane 选项卡面板</h2>
<p>可以通过点击在组件之间进行切换。</p>
<p>构造方法：</p>
<ul>
<li>JTabbedPane(int tabPlacement, int tabLayoutPolicy)： 选项卡标题的位置, 值为 JTabbedPane.TOP、JTabbedPane.BOTTOM、JTabbedPane.LEFT 或 JTabbedPane.RIGHT, 默认为 TOP。tabLayoutPolicy是选项放不下时放置选项策略。有JTabbedPane.WRAP_TAB_LAYOUT 或 JTabbedPane.SCROLL_TAB_LAYOUT。</li>
</ul>
<p>方法：</p>
<ul>
<li>void addTab(String title, Icon icon, Component component, String tip)：添加选项，tip是焦点在选项卡时显示的文本。</li>
<li>insertTab(String title, Icon icon, Component component, String tip, int index)： 指定位置插入选项卡</li>
<li>removeTabAt(int index)：移除选项卡</li>
<li>remove(int index)</li>
<li>remove(Component component)</li>
<li>removeAll()</li>
<li>setSelectedIndex(int index)： 设置选中的选项卡</li>
<li>getSelectedIndex()： 获得选中的选项卡索引</li>
<li>Component getSelectedComponent()： 获得选项卡组件</li>
<li>setTitleAt(int index, String title)： 设置选项卡标题</li>
<li>setIconAt(int index, Icon icon)： 设置选项卡图标</li>
<li>setEnabledAt(int index, boolean enabled)： 设置选项是否可用</li>
<li>setComponentAt(int index, Component component)：设置组件</li>
<li>getTabCount()： 获得选项卡数量</li>
<li>setTabComponentAt(int index, Component titleComponent)：把一个组件放到标题位置（其他是标题位置就是标题，组件在下面）</li>
</ul>
<p>监听器： <code>addChangeListener(ChangeListener l)</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        JTabbedPane tabbedPane = <span class="keyword">new</span> <span class="constructor">JTabbedPane()</span>;</span><br><span class="line">        JTextArea textArea = <span class="keyword">new</span> <span class="constructor">JTextArea(20, 20)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectionColor(Color.RED)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectedTextColor(Color.YELLOW)</span>;</span><br><span class="line">        textArea.set<span class="constructor">CaretColor(Color.BLUE)</span>;</span><br><span class="line">        textArea.set<span class="constructor">LineWrap(<span class="params">true</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Font(<span class="params">new</span> Font(<span class="params">null</span>, Font.PLAIN, 20)</span>);</span><br><span class="line">        textArea.set<span class="constructor">WrapStyleWord(<span class="params">true</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        tabbedPane.add<span class="constructor">Tab(<span class="string">&quot;text&quot;</span>, <span class="params">textArea</span>)</span>;</span><br><span class="line">        tabbedPane.add<span class="constructor">Tab(<span class="string">&quot;try&quot;</span>, <span class="params">new</span> JButton(<span class="string">&quot;ha&quot;</span>)</span>);</span><br><span class="line">        tabbedPane.add<span class="constructor">Tab(<span class="string">&quot;picture&quot;</span>, <span class="params">new</span> ImageIcon(<span class="string">&quot;F:\\hexo\\wodeboke\\source\\images\\pasted-0.png&quot;</span>)</span>, <span class="keyword">new</span> <span class="constructor">JPasswordField(10)</span>);</span><br><span class="line">        add(tabbedPane);</span><br><span class="line"></span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">        set<span class="constructor">Size(100, 200)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">&quot;Hello&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swing%E9%9D%A2%E6%9D%BF1.PNG" alt="" /></p>
<h2 id="jlayerpane-层级面板"><a class="markdownIt-Anchor" href="#jlayerpane-层级面板"></a> JLayerPane 层级面板</h2>
<p>层级面板允许组件重叠出现，并且把组件分成若干层。层取值-1到n-1</p>
<p>每一层组件位置可以设置编号，编号决定前后。层之间编号越大在前面，层中编号越大越接近底部。</p>
<p>加入层的组件必须要设置位置和大小（width和height），否则不予显示</p>
<p>构造方法：</p>
<ul>
<li>JLayerPane()</li>
</ul>
<p>方法：</p>
<ul>
<li>add(Component comp, Object layer, int position):因为layer是object，说明不能直接用整型，而是要用Integer类。</li>
<li>add(Component comp, Object layer)</li>
<li>setLayer(Component c, int layer, int position)</li>
<li>setLayer(Component c, int layer)</li>
<li>moveToFront(Component c): 把组件移到最顶端的位置</li>
<li>moveToBack(Component c)</li>
<li>setPosition(Component c, int position)：设置组件所在层</li>
</ul>
<h1 id="jdialog和joptionpane"><a class="markdownIt-Anchor" href="#jdialog和joptionpane"></a> JDialog和JOptionPane</h1>
<p>JOpintionPane是已经实现好的JDialog，以静态方法的形式提供调用。</p>
<p>JOpintionPane提供的调用：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>showMessageDialog</td>
<td>消息对话框，向用户展示一个消息，没有返回值。</td>
</tr>
<tr>
<td>showConfirmDialog</td>
<td>确认对话框，询问一个问题是否执行。</td>
</tr>
<tr>
<td>showInputDialog</td>
<td>输入对话框，要求用户提供某些输入。</td>
</tr>
<tr>
<td>showOptionDialog</td>
<td>选项对话框，上述三项的大统一，自定义按钮文本，询问用户需要点击哪个按钮。</td>
</tr>
</tbody>
</table>
<p>静态方法中的参数：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(1)</span> <span class="attr">parentComponent:</span> <span class="string">对话框的父级组件，决定对话框显示的位置，对话框的显示会尽量紧靠组件的中心，如果传</span> <span class="literal">null</span><span class="string">，则显示在屏幕的中心。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(2)</span> <span class="attr">title:</span> <span class="string">对话框标题。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(3)</span> <span class="attr">message:</span> <span class="string">消息内容。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(4)</span> <span class="attr">messageType:</span> <span class="string">消息类型，主要是提供默认的对话框图标。可能的值为：</span></span><br><span class="line"></span><br><span class="line"><span class="string">JOptionPane.PLAIN_MESSAGE</span> <span class="string">简单消息（不使用图标）</span></span><br><span class="line"><span class="string">JOptionPane.INFORMATION_MESSAGE</span> <span class="string">信息消息（默认）</span></span><br><span class="line"><span class="string">JOptionPane.QUESTION_MESSAGE</span> <span class="string">问题消息</span></span><br><span class="line"><span class="string">JOptionPane.WARNING_MESSAGE</span> <span class="string">警告消息</span></span><br><span class="line"><span class="string">JOptionPane.ERROR_MESSAGE</span> <span class="string">错误消息</span></span><br><span class="line"><span class="string">(5)</span> <span class="attr">icon:</span> <span class="string">自定义的对话框图标，如果传</span> <span class="literal">null</span><span class="string">，则图标类型由</span> <span class="string">messageType</span> <span class="string">决定。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(6)</span> <span class="attr">optionType:</span> <span class="string">选项按钮的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(7)</span> <span class="string">options、initialValue:</span> <span class="string">自定义的选项按钮（如果穿</span> <span class="literal">null</span><span class="string">，则选项按钮由</span> <span class="string">optionType</span> <span class="string">决定），以及默认选中的选项按钮。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(8)</span> <span class="string">selectionValues、initialSelectionValue:</span> <span class="string">提供的输入选项，以及默认选中的选项。</span></span><br></pre></td></tr></table></figure>
<p>但是不是每种选项都拥有所有参数,下面是每个方法最多的选项</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> showMessageDialog(Component parentComponent, </span><br><span class="line">                              <span class="built_in">Object</span> message, </span><br><span class="line">                              <span class="built_in">String</span> title, </span><br><span class="line">                              <span class="built_in">int</span> messageType, </span><br><span class="line">                              Icon icon)</span><br><span class="line">                              </span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> showConfirmDialog(Component parentComponent, </span><br><span class="line">                             <span class="built_in">Object</span> message, </span><br><span class="line">                             <span class="built_in">String</span> title, </span><br><span class="line">                             <span class="built_in">int</span> optionType, </span><br><span class="line">                             <span class="built_in">int</span> messageType, </span><br><span class="line">                             Icon icon)</span><br><span class="line">                             </span><br><span class="line"><span class="keyword">static</span> <span class="built_in">Object</span> showInputDialog(Component parentComponent, </span><br><span class="line">                              <span class="built_in">Object</span> message, </span><br><span class="line">                              <span class="built_in">String</span> title, </span><br><span class="line">                              <span class="built_in">int</span> messageType, </span><br><span class="line">                              Icon icon, </span><br><span class="line">                              <span class="built_in">Object</span>[] selectionValues, </span><br><span class="line">                              <span class="built_in">Object</span> initialSelectionValue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> showOptionDialog(Component parentComponent, </span><br><span class="line">                            <span class="built_in">Object</span> message, </span><br><span class="line">                            <span class="built_in">String</span> title, </span><br><span class="line">                            <span class="built_in">int</span> optionType, </span><br><span class="line">                            <span class="built_in">int</span> messageType, </span><br><span class="line">                            Icon icon, </span><br><span class="line">                            <span class="built_in">Object</span>[] options, </span><br><span class="line">                            <span class="built_in">Object</span> initialValue)</span><br></pre></td></tr></table></figure>
<p>其中showconfirmDialog的messageType参数可以是JOptionPane.YES_OPTION（是）或JOptionPane.NO_OPTION（否）或JOptionPane.CANCEL_OPTION（取消）或JOptionPane.CLOSED_OPTION（关闭）。也可以是JOptionPane.YES_NO_CANCEL_OPTION;等组合选项。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Calculate(<span class="built_in">String</span> name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        JButton Button2 = <span class="keyword">new</span> JButton(<span class="string">&quot;show message&quot;</span>);</span><br><span class="line">        Button2.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;message&quot;</span>, <span class="string">&quot;Hello&quot;</span>, QUESTION_MESSAGE, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">&quot;show input&quot;</span>);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">String</span>[] select = <span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">&quot;水果&quot;</span>, <span class="string">&quot;食物&quot;</span>&#125;;</span><br><span class="line">                <span class="built_in">Object</span> input = showInputDialog(</span><br><span class="line">                        <span class="literal">null</span>,</span><br><span class="line">                        <span class="string">&quot;input something&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">                        WARNING_MESSAGE</span><br><span class="line">                );</span><br><span class="line">                System.out.println(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        JButton button1 = <span class="keyword">new</span> JButton(<span class="string">&quot;total&quot;</span>);</span><br><span class="line">        button1.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">String</span>[] select = <span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">&quot;水果&quot;</span>, <span class="string">&quot;食物&quot;</span>&#125;;</span><br><span class="line">                int o = showOptionDialog(</span><br><span class="line">                        <span class="literal">null</span>,</span><br><span class="line">                        <span class="string">&quot;please select one&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">                        YES_NO_CANCEL_OPTION,</span><br><span class="line">                        PLAIN_MESSAGE,</span><br><span class="line">                        <span class="literal">null</span>,</span><br><span class="line">                        select,</span><br><span class="line">                        select[<span class="number">0</span>]);</span><br><span class="line">                System.out.println(select[o]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Box vBox = Box.createVerticalBox();</span><br><span class="line">        vBox.add(button);</span><br><span class="line">        vBox.add(Button2);</span><br><span class="line">        vBox.add(button1);</span><br><span class="line">        add(vBox);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        pack();</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Calculate(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swing%E9%9D%A2%E6%9D%BF2.PNG" alt="" /><br />
<img src="/images/swing%E9%9D%A2%E6%9D%BF3.PNG" alt="" /><br />
<img src="/images/swing%E9%9D%A2%E6%9D%BF4.PNG" alt="" /></p>
<p>注意：showOptionDialog如果后面没有Object[]，那么下面的选项是YES_NO_CANCEL_OPTION。并且它的返回值是一个int型，如果点了叉那么返回值是-1.</p>
<p>showInputDialog返回值是输入的信息，</p>
<h1 id="jfilechooser-文件选择器"><a class="markdownIt-Anchor" href="#jfilechooser-文件选择器"></a> JFileChooser 文件选择器</h1>
<p>可以用来打开和保存文件。</p>
<p>构造方法：</p>
<ul>
<li>JFileChooser(File currentDirectory)：打开文件时默认显示的文件夹。可以使用绝对目录</li>
</ul>
<p>方法：</p>
<ul>
<li>setCurrentDirectory(File dir)： 设置当前文件夹</li>
<li>setFileSelectionMode(int mode)：有三种模式。JFileChooser.FILES_ONLY: 只能选文件 或 JFileChooser.DIRECTORIES_ONLY: 只能选文件夹 或 JFileChooser.FILES_AND_DIRECTORIES: 文件和文件夹都可以选。</li>
<li>setMultiSelectionEnabled(boolean b)：是否可以选多个（默认不允许）</li>
<li>addChoosableFileFilter(FileFilter filter)： 添加文件类型选择。例如<code>fileChooser.setFileFilter(new FileNameExtensionFilter(&quot;image(*.jpg, *.png, *.gif)&quot;, &quot;jpg&quot;, &quot;png&quot;, &quot;gif&quot;));</code>前面是描述，后面是选择类型。</li>
<li>setFileFilter(FileFilter filter)： 设置默认使用的过滤器</li>
<li>setSelectedFile(File file)： 设置默认被选中的文件</li>
<li>setSelectedFiles(File[] selectedFiles)</li>
<li>showOpenDialog(Component parent)： 打开对话框（线程会被阻塞），parent是父组件，设置会让对话框显示在父组件中心，如果是null显示在屏幕中心。返回值有JFileChooser.CANCEL_OPTION: 点击了取消或关闭 或 JFileChooser.APPROVE_OPTION: 点击了确认或保存 或 JFileChooser.ERROR_OPTION: 出现错误</li>
<li>File getSelectedFile()： 获得选择的文件</li>
</ul>
<p>例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> File files;</span><br><span class="line">    <span class="keyword">private</span> FileReader fileReader;</span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">name</span>)</span> throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        JFileChooser fileChooser = <span class="keyword">new</span> <span class="constructor">JFileChooser(<span class="string">&quot;F:\\系统设置\\Desktop\\我的文档&quot;</span>)</span>;</span><br><span class="line">        fileChooser.add<span class="constructor">ChoosableFileFilter(<span class="params">new</span> FileNameExtensionFilter(<span class="string">&quot;*.zip&quot;</span>,<span class="string">&quot;zip&quot;</span>)</span>);</span><br><span class="line">        fileChooser.add<span class="constructor">ChoosableFileFilter(<span class="params">new</span> FileNameExtensionFilter(<span class="string">&quot;*.txt&quot;</span>, <span class="string">&quot;txt&quot;</span>)</span>);</span><br><span class="line">        fileChooser.set<span class="constructor">FileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES)</span>;</span><br><span class="line">        fileChooser.set<span class="constructor">MultiSelectionEnabled(<span class="params">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">        JButton button = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">&quot;open to copy&quot;</span>)</span>;</span><br><span class="line">        JTextArea textArea = <span class="keyword">new</span> <span class="constructor">JTextArea( 40, 40)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectedTextColor(Color.YELLOW)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectionColor(Color.RED)</span>;</span><br><span class="line">        textArea.set<span class="constructor">CaretColor(Color.BLUE)</span>;</span><br><span class="line">        textArea.set<span class="constructor">WrapStyleWord(<span class="params">false</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Font(<span class="params">new</span> Font(<span class="params">null</span>, Font.PLAIN, 20)</span>);</span><br><span class="line">        textArea.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        JTextField textField = <span class="keyword">new</span> <span class="constructor">JTextField(<span class="string">&quot;The content of the file will show here&quot;</span>)</span>;</span><br><span class="line">        textField.set<span class="constructor">Editable(<span class="params">false</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Foreground(Color.RED)</span>;</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="constructor">JPanel()</span>;</span><br><span class="line">        panel.set<span class="constructor">Layout(<span class="params">new</span> BorderLayout()</span>);</span><br><span class="line">        JPanel panel1 = <span class="keyword">new</span> <span class="constructor">JPanel()</span>;</span><br><span class="line">        panel1.set<span class="constructor">Layout(<span class="params">new</span> BorderLayout()</span>);</span><br><span class="line">        panel1.add(button, BorderLayout.NORTH);</span><br><span class="line">        panel1.add(textField, BorderLayout.CENTER);</span><br><span class="line">        panel.add(panel1, BorderLayout.NORTH);</span><br><span class="line">        panel.add(textArea, BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line">        button.add<span class="constructor">ActionListener(<span class="params">new</span> ActionListener()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fileChooser.show<span class="constructor">OpenDialog(<span class="params">panel</span>)</span><span class="operator"> == </span>JFileChooser.APPROVE_OPTION)</span><br><span class="line">                &#123;</span><br><span class="line">                    files = fileChooser.get<span class="constructor">SelectedFile()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(fileChooser.show<span class="constructor">OpenDialog(<span class="params">panel</span>)</span><span class="operator"> == </span>JFileChooser.ERROR_OPTION)</span><br><span class="line">                &#123;</span><br><span class="line">                    show<span class="constructor">MessageDialog(<span class="params">fileChooser</span>, <span class="string">&quot;something wrong&quot;</span>, <span class="string">&quot;hello&quot;</span>, ERROR_MESSAGE, <span class="params">null</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fileReader = <span class="keyword">new</span> <span class="constructor">FileReader(<span class="params">files</span>)</span>;</span><br><span class="line">                    <span class="built_in">int</span> c;</span><br><span class="line">                    <span class="keyword">while</span>((c=fileReader.read<span class="literal">()</span>) != -<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        textArea.append(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of((<span class="params">char</span>)</span> c));</span><br><span class="line">                    &#125;</span><br><span class="line">                    fileReader.close<span class="literal">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        add(panel);</span><br><span class="line"></span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">        pack<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">&quot;hello&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swing%E5%9B%BE%E5%BD%A25.PNG" alt="" /></p>
<p>如果想使用系统的ui可以用java.awt.FileDialog</p>
<h1 id="jcolorchooser-颜色选择器"><a class="markdownIt-Anchor" href="#jcolorchooser-颜色选择器"></a> JColorChooser 颜色选择器</h1>
<p>提供一个让用户选择颜色的对话框。</p>
<p>构造方法：</p>
<ul>
<li>public static Color showDialog(Component component, String title, Color initialColor)： 这是JColorChooser的静态方法。Component是父组件，title标题。</li>
</ul>
<h1 id="jmenubar-菜单"><a class="markdownIt-Anchor" href="#jmenubar-菜单"></a> JMenuBar 菜单</h1>
<p>把菜单添加到JFrame后，会在顶部出现。菜单有三种：</p>
<ul>
<li>JMenu： 菜单栏上的菜单</li>
<li>JMenuBar： 菜单栏</li>
<li>JMenuItem, JCheckBoxMenuItem, JRadioButtonMenuItem： 子菜单，表示子菜单\带复选框的子菜单\带单选按钮的子菜单。</li>
</ul>
<p>JMenu、JCheckBoxMenuItem、JRadioButtonMenuItem 均继承自 JMenuItem。</p>
<p>JMenuItem的构造方法：</p>
<ul>
<li>JMenuItem(String title, Icon icon)： icon是菜单显示的图标</li>
</ul>
<p>把JMenuBar添加到JFrame是用setJmenuBar()方法</p>
<p>JMenuItem常用方法：</p>
<ul>
<li>setIcon(Icon defaultIcon)</li>
<li>setText(String text)</li>
<li>setMnemonic(int mnemonic): 设置快捷键助记符。也就是在标题后面会加一个下划线或其他标识然后再加上这个字母。它是用来提示你按下那个键触发快捷键的。例如： menuItem.setMnemonic(KeyEvent.VK_N);</li>
<li>setAccelerator(KeyStroke keyStroke)： 设置快捷键。例如：menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N, ActionEvent.ALT_MASK));</li>
<li>setActionCommand(String actionCommand)：设置菜单项的Action名称。如果多个菜单项使用同一个监听器就可以用这个方法设置名字用来辨别到底是哪一个触发了。</li>
</ul>
<p>监听器： addActionListener(ActionListener l)</p>
<p>JCheckBoxMenuItem、JRadioButtonMenuItem 常用方法:：</p>
<p>其实就是JCheckBoxButton类似的方法.它的监听器是addChangeListener(ChangeListener l)</p>
<p>JMenu常用方法：</p>
<ul>
<li>JMenuItem add(JMenuItem menuItem)： 添加一个子菜单到JMenu中</li>
<li>addSeparator()： 添加一个子菜单分界线</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Menu(<span class="keyword">String</span> name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JMenuBar menuBar = <span class="keyword">new</span> <span class="type">JMenuBar</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一级菜单</span></span><br><span class="line">        JMenu menu_File = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">        JMenu menu_Edit = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">&quot;edit&quot;</span>);</span><br><span class="line">        JMenu menu_about = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">&quot;about&quot;</span>);</span><br><span class="line">        <span class="comment">//menu_File.setMnemonic(KeyEvent.VK_N);</span></span><br><span class="line">        <span class="comment">//menu_File.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N, ActionEvent.ALT_MASK));</span></span><br><span class="line">        menuBar.add(menu_about);</span><br><span class="line">        menuBar.add(menu_Edit);</span><br><span class="line">        menuBar.add(menu_File);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//file子菜单</span></span><br><span class="line">        JMenuItem File_open = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        JMenuItem file_save = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;save&quot;</span>);</span><br><span class="line">        JMenuItem file_new <span class="type"></span>= <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;new&quot;</span>);</span><br><span class="line">        JMenuItem file_close = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        menu_File.add(file_new<span class="type"></span>);</span><br><span class="line">        menu_File.add(file_save);</span><br><span class="line">        menu_File.add(File_open);</span><br><span class="line">        menu_File.addSeparator();</span><br><span class="line">        menu_File.add(file_close);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//edit子菜单</span></span><br><span class="line">        JMenuItem edit_paste = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;paste&quot;</span>);</span><br><span class="line">        JMenuItem edit_cut= <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;cut&quot;</span>);</span><br><span class="line">        JMenuItem edit_copy = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;copy&quot;</span>);</span><br><span class="line">        menu_Edit.add(edit_copy);</span><br><span class="line">        menu_about.add(edit_cut);</span><br><span class="line">        menu_about.add(edit_paste);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//about子菜单</span></span><br><span class="line">        JMenuItem about_author = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">        JMenu menu_about_conference = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">&quot;conference&quot;</span>);</span><br><span class="line">        menu_about.add(about_author);</span><br><span class="line">        menu_about.add(menu_about_conference);</span><br><span class="line"></span><br><span class="line">        JMenuItem conference_link1 = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">        JMenuItem conference_link2 = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">        menu_about_conference.add(conference_link1);</span><br><span class="line">        menu_about_conference.add(conference_link2);</span><br><span class="line">        setJMenuBar(menuBar);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Menu</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swing%E9%9D%A2%E6%9D%BF7.PNG" alt="" /></p>
<h1 id="jtoolbar-工具栏"><a class="markdownIt-Anchor" href="#jtoolbar-工具栏"></a> JToolBar 工具栏</h1>
<p>工具栏显示了一些常用组件。它支持拖动，为了确保可以拖动，可以把它加入到BorderLayout的任意一边，并且不要再其他四边中加入子级</p>
<p>构造方法：</p>
<ul>
<li>JToolBar(String name, int orientation)： orientation是工具栏方向，可以取SwingConstants.HORIZONTAL或SwingConstants.VERTICAL，默认水平</li>
</ul>
<p>方法：</p>
<ul>
<li>Component add(Component comp)：添加组件到工具栏</li>
<li>addSeparator()：添加分割线</li>
<li>addSeparator(Dimension size)</li>
<li>Component getComponentAtIndex(int index)：获取指定位置组件（包括分隔符）</li>
<li>setFloatable(boolean b)：工具栏是否可以拖动</li>
<li>setOrientation(int o)</li>
<li>setMargin(Insets m)： 设置内边距</li>
<li>setBorderPainted(boolean b)： 是否绘制边框</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tool</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> tool(<span class="built_in">String</span> name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line"></span><br><span class="line">        JToolBar toolBar = <span class="keyword">new</span> JToolBar();</span><br><span class="line">        toolBar.setFloatable(<span class="literal">true</span>);</span><br><span class="line">        add(toolBar, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">        JButton button_next_music = <span class="keyword">new</span> JButton(<span class="string">&quot;next&quot;</span>, <span class="keyword">new</span> ImageIcon(<span class="string">&quot;D:\\截图\\next.png&quot;</span>));</span><br><span class="line">        JButton button_pause_music = <span class="keyword">new</span> JButton(<span class="string">&quot;pause&quot;</span>, <span class="keyword">new</span> ImageIcon(<span class="string">&quot;D:\\截图\\pause.png&quot;</span>));</span><br><span class="line">        JButton button_previous_music = <span class="keyword">new</span> JButton(<span class="string">&quot;previous&quot;</span>, <span class="keyword">new</span> ImageIcon(<span class="string">&quot;D:\\截图\\previous.png&quot;</span>));</span><br><span class="line">        toolBar.add(button_previous_music);</span><br><span class="line">        toolBar.addSeparator();</span><br><span class="line">        toolBar.add(button_pause_music);</span><br><span class="line">        toolBar.addSeparator();</span><br><span class="line">        toolBar.add(button_next_music);</span><br><span class="line">        button_next_music.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;next music&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button_pause_music.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button_previous_music.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;previous music&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> tool(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/swing%E9%9D%A2%E6%9D%BF8.PNG" alt="" />把它拖到左上角又可以固定。</p>
<h1 id="jpopupmenu-右键菜单"><a class="markdownIt-Anchor" href="#jpopupmenu-右键菜单"></a> JPopupMenu 右键菜单</h1>
<p>这个挺熟悉的，又叫弹出式菜单。它的使用和JToolBar类似。</p>
<h1 id="jinternalframe-内部窗口"><a class="markdownIt-Anchor" href="#jinternalframe-内部窗口"></a> JInternalFrame 内部窗口</h1>
<p>内部窗口是在JFrame内部显示一个完整的子窗口。</p>
<p>在实际使用中，通常将 JInternalFrame 添加到 JDesktopPane 中，由其来维护和显示 JInternalFrame。</p>
<p>方法等和JFrame类似</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JInternalFrame createInternalFrame() &#123;</span><br><span class="line">        <span class="comment">// 创建一个内部窗口</span></span><br><span class="line">        JInternalFrame internalFrame = <span class="keyword">new</span> <span class="type">JInternalFrame</span>(</span><br><span class="line">                <span class="string">&quot;内部窗口&quot;</span>,  <span class="comment">// title</span></span><br><span class="line">                <span class="literal">true</span>,       <span class="comment">// resizable</span></span><br><span class="line">                <span class="literal">true</span>,       <span class="comment">// closable</span></span><br><span class="line">                <span class="literal">true</span>,       <span class="comment">// maximizable</span></span><br><span class="line">                <span class="literal">true</span>        <span class="comment">// iconifiable</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置窗口的宽高</span></span><br><span class="line">        internalFrame.setSize(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 设置窗口的显示位置</span></span><br><span class="line">        internalFrame.setLocation(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 内部窗口的关闭按钮动作默认就是销毁窗口，所有不用设置</span></span><br><span class="line">        <span class="comment">// internalFrame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建内容面板</span></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="type">JPanel</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加组件到面板</span></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="type">JLabel</span>(<span class="string">&quot;Label001&quot;</span>));</span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="type">JButton</span>(<span class="string">&quot;JButton001&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置内部窗口的内容面板</span></span><br><span class="line">        internalFrame.setContentPane(panel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 对于内部窗口，还可以不需要手动设置内容面板，直接把窗口当做普通面板使用，</span></span><br><span class="line"><span class="comment">         * 即直接设置布局，然后通过 add 添加组件，如下代码:</span></span><br><span class="line"><span class="comment">         *     internalFrame.setLayout(new FlowLayout());</span></span><br><span class="line"><span class="comment">         *     internalFrame.add(new JLabel(&quot;Label001&quot;));</span></span><br><span class="line"><span class="comment">         *     internalFrame.add(new JButton(&quot;JButton001&quot;));</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示内部窗口</span></span><br><span class="line">        internalFrame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> internalFrame;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="desktop"><a class="markdownIt-Anchor" href="#desktop"></a> DeskTop</h1>
<p>DeskTop可以让java程序启动本机上注册的程序。一般程序有</p>
<ul>
<li>打开浏览器</li>
<li>打开邮件</li>
<li>打开文件</li>
</ul>
<p>方法：</p>
<ul>
<li>static boolean isDesktopSupported()： 当前平台是否支持此类</li>
<li>static Desktop getDesktop()： 获得DeskTop实例</li>
<li>browse(URI uri)： 启用默认浏览器显示URI</li>
<li>open(File file)： 启用默认应用程序打开文件</li>
<li>edit(File file)： 启用默认编辑器编辑文件</li>
<li>print(File file)： 打印</li>
<li>mail()： 启用邮件管理</li>
<li>mail(URI mailtoURI)： 启用邮件管理并填充URI</li>
<li>isSupported(Desktop.Action action)： 查看当前平台是否支持上述操作。<a href="http://xn--DeskTop-vk7ku1ybt3c.Action.xxx">取值是DeskTop.Action.xxx</a> xxx是上面操作的大写</li>
</ul>
<h1 id="系统剪切板"><a class="markdownIt-Anchor" href="#系统剪切板"></a> 系统剪切板</h1>
<p>获得系统剪切板：</p>
<p><code>Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();</code></p>
<p>使用：</p>
<figure class="highlight plain"><figcaption><span>class Main &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 把文本设置到剪贴板（复制）</span><br><span class="line">        setClipboardString(&quot;Hello System Clipboard!&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从剪贴板中获取文本（粘贴）</span><br><span class="line">        String text &#x3D; getClipboardString();</span><br><span class="line">        System.out.println(&quot;text: &quot; + text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 把文本设置到剪贴板（复制）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void setClipboardString(String text) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取系统剪贴板</span><br><span class="line">        Clipboard clipboard &#x3D; Toolkit.getDefaultToolkit().getSystemClipboard();</span><br><span class="line">        &#x2F;&#x2F; 封装文本内容</span><br><span class="line">        Transferable trans &#x3D; new StringSelection(text);</span><br><span class="line">        &#x2F;&#x2F; 把文本内容设置到系统剪贴板</span><br><span class="line">        clipboard.setContents(trans, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从剪贴板中获取文本（粘贴）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getClipboardString() &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取系统剪贴板</span><br><span class="line">        Clipboard clipboard &#x3D; Toolkit.getDefaultToolkit().getSystemClipboard();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取剪贴板中的内容</span><br><span class="line">        Transferable trans &#x3D; clipboard.getContents(null);</span><br><span class="line"></span><br><span class="line">        if (trans !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断剪贴板中的内容是否支持文本</span><br><span class="line">            if (trans.isDataFlavorSupported(DataFlavor.stringFlavor)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取剪贴板中的文本内容</span><br><span class="line">                    String text &#x3D; (String) trans.getTransferData(DataFlavor.stringFlavor);</span><br><span class="line">                    return text;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/post/eefe591f.html</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1>
<p>进程是正在运行的程序，它包含代码和执行状态（栈堆寄存器等）。而程序仅仅是一些静态的代码。一个程序可以生成多个进程（如记事本进程）。进程是资源分配最小单元</p>
<h1 id="linux系统进程"><a class="markdownIt-Anchor" href="#linux系统进程"></a> Linux系统进程</h1>
<p>Linux进程是采用进程树的方式。程序开始时创建一个零号进程，然后零号进程创建一号进程再由一号进程创建其他的进程。linux进程是一种树状结构，可以通过pstree命令查看进程树。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">sys/types.h：储存了一些宏定义如<span class="keyword">pid_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>fork():创建当前进程的子进程，并且子进程和当前进程完全相同。</p>
</blockquote>
<p>返回值：返回两个返回值，如果返回值是零，代表当前在子进程中。如果返回值&gt;0,代表在父进程中并且返回值是子进程pid，如果返回值&lt;0,代表出错。</p>
<p><strong>注意</strong>： 这里复制子进程是采用copy on right的方式，即开始子进程与父进程完全相同，只有当子父进程之间有差异时才会额外开辟空间储存差异。</p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is the child process\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is the parent process\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>getpid(): 获得pid</p>
</blockquote>
<blockquote>
<p>exec家族， 用于在子进程中调用系统中有的函数</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> execl(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> execv(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> execle(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> execve(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> execlp(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> execvp(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span><br><span class="line"></span><br><span class="line">其中有p的代表会自动在系统路径中搜索，例如</span><br><span class="line">execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot; -l&quot;</span>, <span class="literal">NULL</span>)会执行ls -l指令，如果没有p，则需要/bin/ls</span><br><span class="line"></span><br><span class="line">v代表传入一个数组，这个字符数组加起来就是命令，最后以<span class="literal">NULL</span>结尾</span><br><span class="line"></span><br><span class="line">e代表绝对地址</span><br></pre></td></tr></table></figure>
<blockquote>
<p>int wait(int *status)： 会阻塞当前进程，直到找到了僵尸子进程（死了的子进程），之后就彻底杀死子进程并返回进程号，失败会返回-1。status可以设置成NULL，</p>
</blockquote>
<blockquote>
<p>pid_t waitpid(pid_t pid,int *status,int options): pid是子进程进程号，表示只等待这一个子进程，其他子进程终止仍处于阻塞状态。</p>
</blockquote>
<p>options有：</p>
<ul>
<li>WNOHANG(wait no hung)： 即使没有子进程退出，它也会立即返回</li>
<li>Returns information about a child process stopped by SIGTTIN,<br />
SIGTTOU, SIGSSTP, and SIGTSTOP signals.(返回子进程被某些信号而停止的信息）</li>
</ul>
<h2 id="进程的状态"><a class="markdownIt-Anchor" href="#进程的状态"></a> 进程的状态</h2>
<p>进程的状态一般可以分为三大类：运行，就绪，阻塞。</p>
<p><strong>运行</strong>状态是指正在cpu中执行指令的进程。</p>
<p><strong>就绪</strong> 是指获得了除cpu意外所有资源，正在等待cpu的进程</p>
<p><strong>阻塞</strong> 是指因为某些原因放弃争夺cpu的进程</p>
<h2 id="进程的调度"><a class="markdownIt-Anchor" href="#进程的调度"></a> 进程的调度</h2>
<h3 id="批处理系统中的调度"><a class="markdownIt-Anchor" href="#批处理系统中的调度"></a> 批处理系统中的调度</h3>
<p>批处理系统就是不具备交互性，单纯完成任务的系统。这种系统一般需要考虑提高cpu利用率（早期计算机使用批处理系统）。批处理系统中的任务一般相对固定，所以可以大致知道它所需要花费的时间。</p>
<h4 id="先来先服务"><a class="markdownIt-Anchor" href="#先来先服务"></a> 先来先服务</h4>
<p>指的是先来的任务先进行服务，这种方式最大的问题是单位时间内可以执行的任务数量比较低。如果一个任务时间很短而前面有一个需要大量时间的任务，那么他将不得不花很长的时间去等待。</p>
<h4 id="最短时间优先"><a class="markdownIt-Anchor" href="#最短时间优先"></a> 最短时间优先</h4>
<p>指的是时间短的进程先来服务。但是这种方式可能让时间长的进程一直无法执行（如果中间一直插入时间短的进程的话）</p>
<h4 id="高响应率优先"><a class="markdownIt-Anchor" href="#高响应率优先"></a> 高响应率优先</h4>
<p>这种方法考虑了等待时间的影响，是对最短时间优先的改进。</p>
<p>响应率 = 1 + 等待时间/完成任务需要时间</p>
<p>通过比较响应率，响应率高的先执行。</p>
<p>这种方法考虑了时间的影响，在时间短的进程先运行的同时不会让长进程无限制的等待。</p>
<h3 id="交互式系统中的调度"><a class="markdownIt-Anchor" href="#交互式系统中的调度"></a> 交互式系统中的调度</h3>
<p>交互式系统就是现在微机所使用的系统，在系统中需要运行的进程一般有很多，因此需要不停的将进程调入调出来让使用者感觉上进程是并行执行的。因此需要规定一个时间片避免进程无限制的执行。时间片到了会强制将当前进程调出然后从进程池中调入一个新的进程。在windows系统中时间片是15ms，linux系统中时间片是10ms</p>
<h4 id="轮转调度"><a class="markdownIt-Anchor" href="#轮转调度"></a> 轮转调度</h4>
<p>轮转调度是使用一个队列，运行完的进程放到队列的尾部，然后从队列的首部拉入一个进程执行。这种方法最大的问题是没有考虑到一些进程需要紧急执行（如火灾报警程序）</p>
<h4 id="优先级调度"><a class="markdownIt-Anchor" href="#优先级调度"></a> 优先级调度</h4>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B1.PNG" alt="" /></p>
<p>如图，这是优先级调度的一种组织形式。数字低的是高优先级（windows或linux中），他会首先从高优先级查找，如果有待执行的程序就执行它。</p>
<p>在windows系统中，正常的优先级是80，低于80是高优先级，高于80是低优先级。如果高优先级较多，低优先级可能一直没有执行的机会。所以高优先级一般都是服务进程，在不需要服务的时候他们会阻塞，一旦有信号将他们唤醒他们便会优先执行。</p>
<p>有时还会对使用cpu时间长的程序进行惩罚。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Priority</span> = base + nice + CPU_PENALTY</span><br><span class="line"><span class="attribute">CPU_PENALTY</span> = CPU_USAGE * R</span><br><span class="line"><span class="attribute">CPU_USAGE</span> = CPU_USAGE * D</span><br><span class="line"></span><br><span class="line"><span class="attribute">CPU_USAGE</span> 是CPU使用次数，每过<span class="number">1</span>s（或其他时间）就会执行第三条指令防止CPU_USAGE一直增大。而CPU_PENALTY就是根据CPU_USAGE得来的。</span><br><span class="line"></span><br><span class="line"><span class="attribute">nice</span>是我们可以设置的优先级，在linux中有个nice命令可以在程序运行前设置优先级，范围是-<span class="number">20</span>-<span class="number">19</span>，非root用户只能变大不能变小。renice可以在运行时设置优先级</span><br></pre></td></tr></table></figure>
<h1 id="竞争条件和信号量"><a class="markdownIt-Anchor" href="#竞争条件和信号量"></a> 竞争条件和信号量</h1>
<p>进程之间有两种关系，协同和竞争。而怎么防止两个进程同时使用一个东西或如何通知其他进程便是多进程中需要考虑的问题</p>
<h2 id="引例"><a class="markdownIt-Anchor" href="#引例"></a> 引例</h2>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B2.PNG" alt="" /></p>
<p>这个队列是等待使用打印机的队列，out是即将被答应的文件。</p>
<p>我们可以假设这种情况，进程a刚刚访问in发现它是7但是这时时间片到了。它被迫退出cpu。此时进程b进入cpu发现in是7并且将文件放在7处。之后再回到a，a会把他的文件放在7处然后in++。这时b的文件就被覆盖掉了</p>
<h3 id="皮德森算法"><a class="markdownIt-Anchor" href="#皮德森算法"></a> 皮德森算法</h3>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B3.PNG" alt="" /></p>
<p>我们可以考虑这种情况，a进程到了turn = process处停止，b进程一路往下到了while，发现a进程对他有兴趣而终止。</p>
<p>而如果a到了turn = process终止，b也到turn = process终止，那么此时因为turn被改变，所以while第一个条件不满足，进入临界区。</p>
<p>这种算法可以解决竞争条件，但是首先它是对两个进程来说的，多个进程不好扩展，另外每次都要写这两个函数非常麻烦。</p>
<h3 id="tsl信号法"><a class="markdownIt-Anchor" href="#tsl信号法"></a> TSL信号法</h3>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B4.PNG" alt="" /></p>
<p>此方法使用了一条汇编指令TSL，这条指令执行了两个内容<code>mov lock, %register;mov $1, %lock ；</code>前面相当于读锁的内容，后面是更改锁的值</p>
<blockquote>
<p>这条指令和上面例子的区别是这是<strong>原子指令</strong>，也就是说要么都不做，要么必须做完，时钟中断不会产生干扰。</p>
</blockquote>
<h2 id="pv操作"><a class="markdownIt-Anchor" href="#pv操作"></a> PV操作</h2>
<p>更为常用的方法是使用pv操作，p就使信号量-1，v就使信号量+1.</p>
<p><strong>信号量可正可负</strong></p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B5.PNG" alt="" /></p>
<p>信号量可正可负代表有一个等待队列，信号量为负时代表有多少个进程正在等待。</p>
<p>**信号量只有1或0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">P(Semaphore e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!s)</span><br><span class="line">    s--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(Semaphore e)</span><br><span class="line">&#123;</span><br><span class="line">    s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>： pv操作是操作系统提供的，他也是原子操作。</p>
<h2 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h2>
<p><strong>生产者消费者问题</strong></p>
<p>有一个生产者和消费者并且有一个队列可以存放生产者生产的产品。</p>
<p>一个普通的办法是</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">#define N <span class="number">100</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> producer(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">TRUE</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        item = produce_item();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> == N)sleep();</span><br><span class="line">        insert_item(item);</span><br><span class="line">        <span class="keyword">count</span> = <span class="keyword">count</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> == <span class="number">1</span>)wakeup(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> consumer(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">TRUE</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep();</span><br><span class="line">        &#125;</span><br><span class="line">        item = remove_item();</span><br><span class="line">        <span class="keyword">count</span> -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> == N-<span class="number">1</span>)wakeup(producer);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法是有问题的。假如消费者先运行，发现count == 0，然后发生时钟中断，之后生产者生产一个物品并发送wakeup信号，但这个时候consumer并没有睡眠，所以这个信号是没有用的。之后consumer睡眠，然后生产者一直生产物品也进行睡眠。这就产生了死锁。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define N <span class="number">100</span></span><br><span class="line">semophore mutex = <span class="number">1</span>;</span><br><span class="line">semophore empty = N;</span><br><span class="line">semophore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">void producer(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        item = produce<span class="constructor">_item()</span>;</span><br><span class="line">        <span class="constructor">P(<span class="params">empty</span>)</span>;</span><br><span class="line">        <span class="constructor">P(<span class="params">mutex</span>)</span>;</span><br><span class="line">        insert<span class="constructor">_item(<span class="params">item</span>)</span>;</span><br><span class="line">        <span class="constructor">V(<span class="params">mutex</span>)</span>;</span><br><span class="line">        <span class="constructor">V(<span class="params">full</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">另外一个类似</span><br></pre></td></tr></table></figure>
<p>这里empty和full也可以变成一个信号量，但是P的逻辑需要更改。empty初始值是N，每次生产一个就会减一，当empty变成0也就是满的时候就会阻塞。</p>
<p><strong>哲学家就餐问题</strong></p>
<p>哲学家问题是五个哲学家五根筷子，有五盘面，每个哲学家从左边和右边各拿一个筷子就可以吃到面，问怎样才可以让所有哲学家都吃到面。</p>
<p>如果完全不加控制，可能会出现五个人同时拿起左边筷子又同时拿起右边筷子的情况，这样就会饿死。</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B6.PNG" alt="" /><br />
<img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B7.PNG" alt="" /><br />
<img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B8.PNG" alt="" /></p>
<p>这里使用了信号量mutex保证同一时间只有一个人试图拿筷子</p>
<p><strong>读写问题</strong></p>
<p>读写问题是同一时间可以有多个读的，但是同一时间最多有一个写的，如果有人在读那么写的就要等待</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B9.PNG" alt="" /><br />
<img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B10.PNG" alt="" /></p>
<p>这是读者优先的策略，还有写者优先和公平竞争。</p>
<p><strong>写者优先</strong></p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">reader</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">p</span>(<span class="variable">read</span>);</span></span><br><span class="line"><span class="function">    <span class="title">p</span>(<span class="variable">readcntsign</span>);</span></span><br><span class="line"><span class="function">    <span class="title">if</span>(<span class="variable">readcnt</span> == <span class="number">0</span>)</span></span><br><span class="line">        <span class="function"><span class="title">p</span>(<span class="variable">file</span>);</span></span><br><span class="line"><span class="function">    <span class="variable">readcnt</span>++;</span></span><br><span class="line"><span class="function">    <span class="title">v</span>(<span class="variable">readcntsign</span>);</span></span><br><span class="line"><span class="function">    <span class="title">v</span>(<span class="variable">read</span>);</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">    <span class="title">do_something</span>();</span></span><br><span class="line"><span class="function">    <span class="title">p</span>(<span class="variable">readcntsign</span>);</span></span><br><span class="line"><span class="function">    <span class="variable">readcnt</span>--;</span></span><br><span class="line"><span class="function">    <span class="title">if</span>(<span class="variable">readcnt</span> == <span class="number">0</span>)</span></span><br><span class="line">        <span class="function"><span class="title">v</span>(<span class="variable">file</span>);</span></span><br><span class="line"><span class="function">    <span class="title">v</span>(<span class="variable">readcntsign</span>);</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="variable">writer</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">p</span>(<span class="variable">writecntsign</span>);</span></span><br><span class="line"><span class="function">    <span class="title">if</span>(<span class="variable">writecntsign</span> == <span class="number">0</span>)</span></span><br><span class="line">        <span class="function"><span class="title">p</span>(<span class="variable">read</span>);</span></span><br><span class="line"><span class="function">    <span class="variable">writecnt</span>++;</span></span><br><span class="line"><span class="function">    <span class="title">v</span>(<span class="variable">writecntsign</span>);</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">p</span>(<span class="variable">file</span>);</span></span><br><span class="line"><span class="function">    <span class="title">do_something</span>();</span></span><br><span class="line"><span class="function">    <span class="title">v</span>(<span class="variable">file</span>);</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">p</span>(<span class="variable">writecntsign</span>);</span></span><br><span class="line"><span class="function">    <span class="variable">writecntsign</span>--;</span></span><br><span class="line"><span class="function">    <span class="title">if</span>(<span class="variable">writecnt</span> == <span class="number">0</span>)</span></span><br><span class="line">        <span class="function"><span class="title">v</span>(<span class="variable">read</span>);</span></span><br><span class="line"><span class="function">    <span class="title">v</span>(<span class="variable">writecntsign</span>);</span></span><br></pre></td></tr></table></figure>
<p><strong>公平竞争</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/* 读者队列初始值为0，其他资源初始值为1*/</span></span><br><span class="line">int readCount = <span class="number">0</span>;</span><br><span class="line">semaphore keySignal = <span class="number">1</span>;</span><br><span class="line">semaphore OneSignal = <span class="number">1</span>;</span><br><span class="line">semaphore readCountSignal = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">reader()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(true)</span><br><span class="line">    &#123;</span><br><span class="line">      wait(keySignal);        <span class="regexp">//</span>申请令牌</span><br><span class="line">      wait(readCountSignal);  <span class="regexp">//</span>申请计数器资源</span><br><span class="line">      <span class="keyword">if</span>(!readCount)          <span class="regexp">//</span>为零则申请文件资源</span><br><span class="line">         wait(fileSrc);</span><br><span class="line">      readCount++;</span><br><span class="line">      signal(readCountSignal); <span class="regexp">//</span>释放计数器资源</span><br><span class="line">      signal(keySignale);      <span class="regexp">//</span>释放令牌</span><br><span class="line"> </span><br><span class="line">      ...</span><br><span class="line">      perform read operation  <span class="regexp">//</span>执行临界区代码</span><br><span class="line">      ...</span><br><span class="line">  </span><br><span class="line">      wait(readCountSignal);  <span class="regexp">//</span>申请计数器资源</span><br><span class="line">      readCount--;</span><br><span class="line">      <span class="keyword">if</span>(!readCount)                <span class="regexp">//</span>为零则释放文件资源</span><br><span class="line">         signal(fileSrc);</span><br><span class="line">    signal(readCountSignal); <span class="regexp">//</span>释放读者计数器资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">writer()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span>(true)</span><br><span class="line">     &#123;</span><br><span class="line">        wait(OneSignal);     <span class="regexp">//</span>申请令牌资源</span><br><span class="line">        wait(keySignal);     <span class="regexp">//</span>申请令牌</span><br><span class="line">        wait(fileSrc);       <span class="regexp">//</span>申请文件资源</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line">        perform write operation <span class="regexp">//</span>执行临界区代码</span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">        signal(fileSrc);   <span class="regexp">//</span>释放文件资源</span><br><span class="line">        signal(keysignal); <span class="regexp">//</span>释放令牌</span><br><span class="line">        signal(OneSignal); <span class="regexp">//</span>释放令牌资源</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的OneSignal是为了保证写的顺序，如果没有onesignal那么一旦多个写者被阻塞恢复时就是靠操作系统调度，加了onesignal保证一定是最先进来的最先执行。但是这也仅限于两个，如果有三个以上写者还是会让操作系统调度。</p>
<h2 id="进程间通讯"><a class="markdownIt-Anchor" href="#进程间通讯"></a> 进程间通讯</h2>
<ul>
<li>给进程发信号，但是信号只有63种并且有些还不能使用所以这种方法一般不使用。</li>
<li>使用进程间通讯的函数<img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B11.PNG" alt="" /></li>
</ul>
<p>这些是进程间通讯的信号量，和下面线程间通讯不同。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/sem.h&gt;</span></span><br><span class="line">+int semget(key_t key, int nesms, int semflg);key是信号量键值，nesm是创建信号量数量， semflg如果是IPC_EXCL创建唯一一个信号量，如果键值已经存在，那么就会出错。而IPC_CRATE即使存在也不会出错.返回semid</span><br><span class="line">+int semctl(int semid, int semnum, int cmd, <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">arg</span>): 删除或调整信号量，具体使用看下面</span></span><br><span class="line">+int semop(int semid, <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> *<span class="title">sops</span>, <span class="title">size_t</span> <span class="title">nsops</span>):<span class="title">nsop</span>是操作信号量数目（一般是1），结构体结构看下面</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">	int val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">	unsigned short int *array;</span><br><span class="line">	/*<span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *<span class="title">__buf</span>;</span>*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">struct sembuf &#123;</span></span><br><span class="line"><span class="regexp">	short sem_num;</span></span><br><span class="line"><span class="regexp">	short sem_op;</span></span><br><span class="line"><span class="regexp">	short sem_flg;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">static void sem_del(semaphore sem_id)</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">    union semun sem_union;</span></span><br><span class="line"><span class="regexp">    if (semctl(sem_id, 0, IPC_RMID, sem_union) == -1)</span></span><br><span class="line"><span class="regexp">        fprintf(stderr, &quot;Failed to delete semaphore\n&quot;);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int sem_p(semaphore sem_id)</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">    struct sembuf sem_b;</span></span><br><span class="line"><span class="regexp">    sem_b.sem_num = 0;</span></span><br><span class="line"><span class="regexp">    sem_b.sem_op = -1; /</span>* P() *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    sem_b.sem_flg = SEM_UNDO;/</span><span class="regexp">/进程结束而信号量没释放时，会自动释放信号量</span></span><br><span class="line"><span class="regexp">    if (semop(sem_id, &amp;sem_b, 1) == -1) &#123;</span></span><br><span class="line"><span class="regexp">        fprintf(stderr, &quot;semaphore_p failed\n&quot;);</span></span><br><span class="line"><span class="regexp">        return(0);</span></span><br><span class="line"><span class="regexp">    	&#125;</span></span><br><span class="line"><span class="regexp">    return(1);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int sem_v(semaphore sem_id)</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">    struct sembuf sem_b;</span></span><br><span class="line"><span class="regexp">    sem_b.sem_num = 0;</span></span><br><span class="line"><span class="regexp">    sem_b.sem_op = 1; /</span>* V() *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    sem_b.sem_flg = SEM_UNDO;</span></span><br><span class="line"><span class="regexp">    if (semop(sem_id, &amp;sem_b, 1) == -1) &#123;</span></span><br><span class="line"><span class="regexp">        fprintf(stderr, &quot;semaphore_v failed\n&quot;);</span></span><br><span class="line"><span class="regexp">        return(0);</span></span><br><span class="line"><span class="regexp">    	 &#125;</span></span><br><span class="line"><span class="regexp">   return(1);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h1>
<p>线程可以看成比较小的进程，有自己的状态（寄存器和参数等），也会有一些可以被多个线程共享的参数（全局变量）。线程使独立运行和独立调度最小单元。线程可以分为用户级线程和内核级线程和混合线程三种方式。</p>
<ul>
<li>用户级线程： 这种线程不需要内核参与调度。优点是切换快（和函数调用类似），可以在不支持内核级线程的操作系统中执行。但是有一个缺点就是有一个线程被阻塞，那么其余该进程线程也会被阻塞-<strong>在操作系统层面上只会看到一个进程</strong>。</li>
<li>内核级线程，由内核参与线程的调度。优点是一个线程被阻塞，那么其他的线程不会被阻塞，缺点是线程间切换所需时间多（要清空高速缓存等）</li>
</ul>
<p>现在操作系统一般使用内核级线程</p>
<h2 id="linux线程编程-c语言"><a class="markdownIt-Anchor" href="#linux线程编程-c语言"></a> linux线程编程 C语言</h2>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">头文件&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">线程创建</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> pthread_create (pthread_t *__restrict __newthread,</span><br><span class="line">			   <span class="keyword">const</span> pthread_attr_t *__restrict __attr,</span><br><span class="line">			   <span class="keyword">void</span> *(*__start_routine) (<span class="keyword">void</span> *),</span><br><span class="line">			   <span class="keyword">void</span> *__restrict __arg) </span><br><span class="line">第一个参数是指向这个线程的指针。第二个参数设置线程的属性，一般设置成<span class="literal">NULL</span>。第三个参数是这个线程运行时所运行的函数。第四个参数是运行时函数的参数。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span>* test(<span class="keyword">void</span>* args)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;this is the arguments-%s&quot;</span>, (<span class="keyword">char</span>*)args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t p;</span><br><span class="line">    pthread_create(&amp;p, <span class="literal">NULL</span>, test, <span class="string">&quot;arg1&quot;</span>);</span><br><span class="line">    pthread_join(p, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出： <span class="keyword">this</span> is the arguments-arg1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int pthread_join(pthread_t thread, void **retval);</code>.它的作用是让主线程等待某个线程结束再执行。retval是线程结束后的返回值，可以设置成NULL。</li>
</ul>
<p>需要使用pthread_join的原因是主线程结束这个程序就结束了，这时候其他线程不一定执行完成。</p>
<ul>
<li>
<p>线程信号量 头文件pthread.h</p>
<ul>
<li>pthread_mutex_t lock_put;//信号量创建</li>
<li>pthread_mutex_lock(&amp;lock_put);</li>
<li>pthread_mutex_unlock(&amp;lock_put);</li>
<li>pthread_mutex_init(&amp;lock_put, NULL);//初始化，后面一般是NULL,当然也可以是下列值
<ul>
<li>
<p>PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。</p>
</li>
<li>
<p>PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。</p>
</li>
<li>
<p>PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。</p>
</li>
<li>
<p>PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>线程信号量2 头文件semaphore.h</p>
<ul>
<li>int sem_init (sem_t *sem , int pshared, unsigned int value);初始化,pshared固定是0来表示线程间通讯
<ul>
<li>value - 信号量 sem 的初始值。</li>
</ul>
</li>
<li>int sem_post(sem_t *sem); 加1</li>
<li>int sem_wait(sem_t *sem); 减1</li>
<li>int sem_destroy(sem_t *sem); 销毁</li>
</ul>
</li>
<li>
<p>屏障： 屏障是当不满足条件时阻塞线程，满足条件之后再一起释放</p>
<ul>
<li>pthread_cond_t   cond; 创建</li>
<li><code>int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr)</code>： 初始化，但是Linux中cond_attr并没有实现，所以直接NULL</li>
<li><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)</code>  : 等待,注意 还必须要有一个互斥量，只有拿到了互斥量才可以执行等待，并且与此同时会释放mutex。</li>
<li>pthread_cond_signal(): 激活一个等待线程</li>
<li>pthread_cond_broadcast()：激活所有等待线程，要注意激活后是从等待位置开始而不是从broadcast位置开始。</li>
</ul>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> t = bstate.round;</span><br><span class="line">    <span class="keyword">assert</span> (i<span class="operator"> == </span>t);</span><br><span class="line">    </span><br><span class="line">    pthread<span class="constructor">_mutex_lock(&amp;<span class="params">bstate</span>.<span class="params">barrier_mutex</span>)</span>;</span><br><span class="line">    bstate.nthread++;</span><br><span class="line">    <span class="keyword">if</span>(bstate.nthread &lt; nthread)<span class="comment">//没都到就待着</span></span><br><span class="line">    &#123;</span><br><span class="line">	    pthread<span class="constructor">_cond_wait(&amp;<span class="params">bstate</span>.<span class="params">barrier_cond</span>, &amp;<span class="params">bstate</span>.<span class="params">barrier_mutex</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//到了就全部激活</span></span><br><span class="line">    &#123;</span><br><span class="line">	    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">	    bstate.round++;</span><br><span class="line">	    pthread<span class="constructor">_cond_broadcast(&amp;<span class="params">bstate</span>.<span class="params">barrier_cond</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">bstate</span>.<span class="params">barrier_mutex</span>)</span>;</span><br><span class="line">    usleep(random<span class="literal">()</span> % <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="死锁问题"><a class="markdownIt-Anchor" href="#死锁问题"></a> 死锁问题</h1>
<p>死锁条件：</p>
<ul>
<li>互斥条件</li>
<li>保持和等待条件： 一个进程因请求而进入阻塞时，对自身已获得的资源不放。</li>
<li>无抢占条件（抢占就是在一定条件下可以抢夺这个资源，如CPU就是抢占条件）</li>
<li>循环等待条件： 形成首尾相接的环。如下</li>
</ul>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B12.PNG" alt="" /></p>
<p>如图，圆代表进程，方形代表资源，由方形指向圆代表这个进程有这个资源，由圆指向方形代表这个进程需要这个资源。如果形成环路就代表出现了死锁。</p>
<p>资源按需分配可以破坏循环等待条件。</p>
<p>死锁解决方法：</p>
<ul>
<li>忽略问题</li>
<li>检测复原，例如隔多少分钟产生一个备份，一旦死锁就让某个进程回到这个备份，相应资源也会被释放</li>
<li>杀死某个进程释放资源</li>
<li>动态避免通过小心的资源分配</li>
</ul>
<h2 id="银行家算法"><a class="markdownIt-Anchor" href="#银行家算法"></a> 银行家算法</h2>
<p>银行家算法是通过资源分配来避免（不是预防）死锁的。并且没有破坏死锁的任何一个条件</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B13.PNG" alt="" /></p>
<p>首先要知道总共有多少资源，已经分配了多少资源，总共还剩多少资源，还需要多少资源。</p>
<p>![](/images/进程与线程 14.PNG)</p>
<p><strong>现在还有(3, 2, 2)资源可以使用</strong></p>
<p>之后一旦有进程请求就先把资源给他。如果资源不够就不给，如果资源够就用剩下的资源进行安全状态检查。</p>
<p>安全状态检查就是看看现有资源可以分配给哪个进程，有就把资源给他然后回收这个进程资源（不用考虑其他进程还会申请资源）。然后用这些资源再进行分配，如果最后由进程分配不了则说明这个状态不安全。</p>
<ul>
<li>例如p4申请了(2, 1, 0)资源，先把资源给他，那么现在还有(1, 1, 2)资源可以使用，p4变成(2, 2, 1)先把资源给p3然后回收，那么p3完成，剩余资源变成（3, 2, 3)</li>
<li>把资源给p1, 剩余资源变成(5, 3, 3)</li>
<li>资源给p4，剩余资源变成（7， 4， 5）</li>
<li>之后就一步一步分配</li>
</ul>
]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
</search>
