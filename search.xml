<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>储存设备</title>
    <url>/post/7d1c86da.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 16 2020 14:05:31 GMT+0800 (中国标准时间) --><h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p><img src="/images/%E7%A1%AC%E7%9B%98.jpg" alt></p><p>结构： 由若干个盘片组成，每个盘片有2两面，每一面上有若干个磁道，每个磁道上又划分成若干个扇区，扇区是数据访问的最小单位。中间的轴在不停转动。每个扇区都有一个编号。</p><p>显然如果扇区划分时是从中心发出多根射线的话是不好的。因为内圈的扇区划分小，外面的扇区划分大，因此每个扇区读写数据数目可能会有较大的差距。但是很可能只需要利用其中很小一部分，这样就造成了浪费。所以磁道与磁道之间扇区数目是不同的，尽量使数据分布均匀。</p><p>图中左边的架子是读写头，可以前后滑动。数据就是通过读写头进行读写的。</p><p><strong>大致过程</strong>：先移动到对应扇区（寻道），然后等待读写头划过我们要读取的扇区。之后在读取这个扇区。要注意即使只需要读取一个字节也要把这个扇区全部读取完。如果是写的话，先把扇区中数据读取出来，然后再在这些数据中进行更改，最后再把这些数据写入到扇区中。</p><p>一般寻道在2-9ms，旋转也是10ms左右，而读取只需要0.02ms，所以说大头都在寻找过程中。并且要比dram慢2500倍，比sram慢40000倍。</p><p>机械硬盘扇区的读取次数是由限制的，大概是十万到100万次左右。如果某一扇区坏了是不是会导致整个硬盘都异常呢？当然这是不可能的，那样也太不经用了。</p><p>为了解决这个问题，可以用逻辑编号代替物理编号，然后用一定的映射规则转换到物理编号，如果某一个扇区损坏，硬盘中有一些备用的扇区可以替补上，这样就可以解决某一个扇区损坏的问题。可能某些逻辑扇区会被频繁的使用，如果对应规则是确定的那么可能很快那个扇区就会损坏，所以对应规则也要不断变化使每个扇区利用大致平均。</p><h3 id="固态硬盘（ssd）"><a href="#固态硬盘（ssd）" class="headerlink" title="固态硬盘（ssd）"></a>固态硬盘（ssd）</h3><p>结构： 固态硬盘最小的结构是页，每一页有若干个字节。之后若干个页组成了块。它是由闪存构成的（就是usb所使用的）</p><p>读写过程：读的过程是以<strong>页</strong>作为单位，也需要通过一定的映射使之利用均衡。但是写的过程却是以<strong>块</strong>作为单位，就算只改一个字节也需要读取整个块，并且写的过程中需要先把原来的内容全部擦除，所以写过程比读过程慢的多。</p><p>ssd好处是读写较快，但是价格贵，并且读写次数少，只有1万到10万次。</p><h3 id="局部性和高速缓存"><a href="#局部性和高速缓存" class="headerlink" title="局部性和高速缓存"></a>局部性和高速缓存</h3><p>局部性分为时间局部性和空间局部性。</p><p>时间局部性指的是在短时间内多次重复使用某个内存。</p><p>空间局部性指的是一个内存被使用，很可能接下来会使用这段内存附近的数据。</p><p>现代计算机cpu运算速度已经很快了，但是内存的访问速度却跟不上cpu的运算速度。因此现在更重要的是解决内存读取速度的问题。</p><p>根据上面所说的局部性原理（这是人们通过大量观察总结得出的规律），人们想到可以把常用的数据放在一个更快的储存器里，这样就可以提高运算速度。</p><p>于是就有了高速缓存。高速缓存（cahce）是用sram制成的，它的速度很快但是容量很小，直接集成到了cpu内部，每次cpu访问内存的时候都会先从高速缓存中读取。如果高速缓存中没有才会去内存中查找。从内存中取出数据并不是只取那几个字节，而是把附近的指令都放到高速缓存中（因为局部性原理），这样就可以提高速度。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>进程和作业控制</title>
    <url>/post/31a6b40.html</url>
    <content><![CDATA[<!-- build time:Fri Apr 17 2020 17:07:38 GMT+0800 (中国标准时间) --><p>进程就是加载到内存中准备执行的程序。当进程创建的时候，内核赋予了唯一的标识号，这个标识号叫做进程ID或PID。</p><p>进程同一时间内可达数百个之多，为了管理这么多的进程。系统提供了一个调度器来维护。调度器维护一个所有进程的列表，每次选择一个进程（实际上可以一次选择多个进程），然后执行一个短暂的时间（时间片）。</p><p>典型的时间片是10毫秒。为了为了下一个时间片还可以顺利的执行，系统必须要保存下一条指令的位置，环境的副本等。</p><h3 id="进程分叉到死亡"><a href="#进程分叉到死亡" class="headerlink" title="进程分叉到死亡"></a>进程分叉到死亡</h3><p>当进程需要使用内核的服务时，会使用<strong>系统调用</strong>发送请求。在编写程序时，系统调用的使用方法取决于语言。例如，c语言使用标准库中的函数进行调用。</p><p>下面列举一些常见的系统调用函数</p><table><thead><tr><th>系统调用</th><th>作用</th></tr></thead><tbody><tr><td><strong>进程控制</strong></td><td></td></tr><tr><td>fork</td><td>创建当前进程的一个副本</td></tr><tr><td>wait</td><td>等待另一个程序结束后执行（强制暂停当前进程）</td></tr><tr><td>exec</td><td>在当前进程中执行一个新进程</td></tr><tr><td>exit</td><td>中止当前进程</td></tr><tr><td>kill</td><td>杀死子进程</td></tr><tr><td><strong>文件I/O</strong></td><td></td></tr><tr><td>open</td><td>打开一个用于读取或写入的文件</td></tr><tr><td>read</td><td>从文件中读取数据</td></tr><tr><td>write</td><td>向文件中写入了数据</td></tr><tr><td>close</td><td>关闭文件</td></tr></tbody></table><p>fork打开的一个新进程叫做当前进程的子女，当前进程是新进程的双亲。</p><p>例如，shell打开内部命令时首先就要调用fork创建一个新进程，当子进程结束时会调用exit释放资源，被杀死的进程叫做僵进程。但是进程表中却仍然保存子进程的数据，因为父进程可能需要这些数据。。</p><p>当子进程创建时，父进程停止运行，等到子进程被杀死之后，父进程先看一眼进程表中子进程的数据，然后开始运行，与此同时，子进程从进程表中被销毁。</p><h3 id="孤儿进程，父进程，子进程"><a href="#孤儿进程，父进程，子进程" class="headerlink" title="孤儿进程，父进程，子进程"></a>孤儿进程，父进程，子进程</h3><p>孤儿进程指的是父进程意外死亡，这时只有子进程。所以当子进程结束时，因为没有人来接受它，会一直留在进程表中，直到系统结束才会死亡。</p><p>当然，现代系统没有这么傻。孤儿进程会自动被init进程收养，通过这种方式，每当产生孤儿进程时，都会迅速的被init进程销毁。</p><p>除了父进程意外死亡外子进程也可能一直不死，这种情况一般是程序出现bug无法正常退出时产生的，这个程序会一直消耗系统资源。kill可以解决这种问题。kill会杀死父进程然后让init进程托管，在适当的时候会杀死子进程（我估计是一定时间，猜测）。</p><p>关于父进程，fork创建一个和父进程一模一样的副本，那么这时如何知道谁是父进程，谁是子进程呢？其实fork创建子进程完成之后会返回给父进程和子进程一个值，子进程返回值是零，父进程返回值大于零。如果某个进程得到了零，那么他就会开始工作，得到大于零的就会停止工作（通过wait使自己暂停）</p><h3 id="init-第一个进程"><a href="#init-第一个进程" class="headerlink" title="init 第一个进程"></a>init 第一个进程</h3><p>假设进程是通过分叉创建的，那么除第一个进程外的进程一定会有父进程，也一定会有第一个进程。</p><p>实际上也是这样，Linux在启动时会创建一个特殊的进程，PID是0，这个进程叫做空闲进程。</p><p>在进行了一些操作之后，0号进程开始分叉创建1号进程。之后0号进程就会死亡，然后由1号进程进行剩余的初始化步骤，例如进行多次分叉创建其他进程。因为 他要执行初始化步骤，所以叫初始化进程，也就是init进程。</p><h3 id="前台和后台进程"><a href="#前台和后台进程" class="headerlink" title="前台和后台进程"></a>前台和后台进程</h3><p>前台进程就是当前需要我们交互的进程，后台进程就是自己跑的进程。</p><p>例如： sort &lt; temp &gt; temp2 &amp;。后面的与符号就是让程序自己去后面跑，这时我们就可以直接使用shell了。</p><p>但是后台进程不能从标准输入中读取，可以输出到标准输出中，这就带来一个问题。如果这个程序需要输入但是你却把它划分成后台程序，那么他会一直等待输入。</p><h3 id="sleep-创建延迟"><a href="#sleep-创建延迟" class="headerlink" title="sleep 创建延迟"></a>sleep 创建延迟</h3><p>语法： sleep interval [s | m | h | d ]</p><p>interval是时间间隔，后面是单位，默认是秒。</p><p>例如 sleep 5 表示中断5秒。</p><h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><p>作业就是每一条输入的指令，该作业有一个唯一的作业号来标识。作业控制就是对输入的指令进行调控。常见的作业控制命令如下表。</p><table><thead><tr><th>作业控制命令</th><th></th></tr></thead><tbody><tr><td>jobs</td><td>显示作业列表</td></tr><tr><td>ps</td><td>显示进程列表</td></tr><tr><td>fg</td><td>将作业移至前台</td></tr><tr><td>bg</td><td>将作业移至后台</td></tr><tr><td>suspend</td><td>挂起当前shell</td></tr><tr><td>^Z</td><td>挂起当前前台作业</td></tr><tr><td>kill</td><td>终止作业</td></tr><tr><td>suspend</td><td>挂起shell，例如超级用户暂时返回普通用户</td></tr></tbody></table><p>echo $$ 显示当前shell的PID</p><p>echo $! 显示上一条移至后台的PID</p><p>stty tostop 挂起试图向终端写数据的后台作业</p><p>set -o monitor 允许作业控制</p><p>set -o notify 当后台作业结束时立刻通报</p><h3 id="在后台运行作业"><a href="#在后台运行作业" class="headerlink" title="在后台运行作业"></a>在后台运行作业</h3><p>为了在后台运行作业，需要在命令的最后加一个&amp;符号。</p><p>每次在后台运行作业时，系统都会自动分配一个作业号，从1开始，依次向后增加。</p><p>每次后台作业完成时，都会向终端发送一个信息表示已经完成。</p><h3 id="fg-将作业移至前台"><a href="#fg-将作业移至前台" class="headerlink" title="fg 将作业移至前台"></a>fg 将作业移至前台</h3><p>挂起可能令人有些误解，其实就是暂停程序。可以用fg将挂起的作业恢复。</p><p>例如当你用vi编辑一个文件时，突然忘了某些东西想通过man查一下，可以先用ctrl+Z把vi挂起，然后查找，查找完了之后又用fg命令将vi唤醒。</p><p>如果有挂起的程序那么关机时系统会给你提示，你可以选择关机或者先把挂起的程序移至前台。</p><p>语法： fg %[job]</p><p>fg %%代表唤起当前进程。因为一般进程挂起后都是运行别的进程，运行完了才又唤醒进程，此时挂起的进程又成了最前面的进程。</p><p>后面的job是作业编号，可以通过jobs程序查看。</p><p>bg和fg大致相同。</p><h3 id="ps程序"><a href="#ps程序" class="headerlink" title="ps程序"></a>ps程序</h3><p>ps程序是用来显示进程状态的</p><p>语法： ps [-aefFly] [-p pid] [-u userid]</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">ps</span> <span class="string">显示与当前用户标识和终端相关的进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-a 所有与用户标识进程与终端相关的非守护进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-e 所有进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-p pid 显示指定pid的进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-u userid 显示指定userid的进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-ef 显示所有用户的进程，完整输出</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-t 显示所有守护进程</span></span><br></pre></td></tr></table></figure></div><p>下面列举了ps输出时的标题和所代表的含义</p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>ADDR</td><td>进程表中虚拟地址</td></tr><tr><td>C</td><td>处理器利用率</td></tr><tr><td>CMD</td><td>命令名称</td></tr><tr><td>F</td><td>进程相关的标志</td></tr><tr><td>NI</td><td>nice值，用于设置优先级</td></tr><tr><td>PID</td><td>进程ID</td></tr><tr><td>PPID</td><td>父进程ID</td></tr><tr><td>PRI</td><td>优先级（大数字 = 小优先级 ）</td></tr><tr><td>RSS</td><td>内存预留空间大小</td></tr><tr><td>S</td><td>状态代码（D,R,S,T,Z）</td></tr><tr><td>STIME</td><td>累计系统时间</td></tr><tr><td>SZ</td><td>物理页大小</td></tr><tr><td>TIME</td><td>累计cpu时间</td></tr><tr><td>TTY</td><td>控制终端完整名称</td></tr><tr><td>UID</td><td>用户标识</td></tr><tr><td>WCHAN</td><td>等待通道</td></tr></tbody></table><p>状态代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">D</span> <span class="string">不可中断睡眠，等待事件结束</span></span><br><span class="line"><span class="attr">I</span> <span class="string">空闲，超过20s的睡眠</span></span><br><span class="line"><span class="attr">R</span> <span class="string">正在运行或者可运行（可运行是在运行队列中等待）</span></span><br><span class="line"><span class="attr">S</span> <span class="string">可中断睡眠，等待时间结束</span></span><br><span class="line"><span class="attr">T</span> <span class="string">挂起</span></span><br><span class="line"><span class="attr">Z</span> <span class="string">僵进程</span></span><br></pre></td></tr></table></figure></div><p>-ly 显示状态代码</p><h3 id="监视系统进程"><a href="#监视系统进程" class="headerlink" title="监视系统进程"></a>监视系统进程</h3><p>语法： top [-d delay] [-n count] [p pid[,pid]…]</p><p>top的作用是动态显示进程信息。</p><p>-d 每隔多少秒刷新一次</p><p>-n 只在特定的时间进行刷新</p><p>-p 对某几个进程进行监视</p><h3 id="显示进程树"><a href="#显示进程树" class="headerlink" title="显示进程树"></a>显示进程树</h3><p>语法： pstree [-aAcGnpu] [pid | userid]</p><p>作用：因为进程几乎都是通过分叉产生的，所以这个作用是显示进程之间的关系（即谁是父进程谁是子进程）。</p><p>具体的可以去看联机手册</p><h3 id="kill-杀死进程，向进程发送信号"><a href="#kill-杀死进程，向进程发送信号" class="headerlink" title="kill 杀死进程，向进程发送信号"></a>kill 杀死进程，向进程发送信号</h3><p>语法： kill [-signal] pid… | jobid…</p><p>| signal | 含义 |<br>| 1 | 中止，注销或终端失去连接时发送给进程 |<br>| 2 | 中断，按下^C时发送 |<br>| 9 | 杀死，立刻杀死，进程不能捕获 |<br>| 15 | 终止，请求终止，进程不能捕获 |<br>| 18 | 继续，恢复挂起的进程，由fg或bg发送 |<br>| 19 | 停止（挂起），按^Z发送 |</p><h3 id="设置进程优先级-nice，renice"><a href="#设置进程优先级-nice，renice" class="headerlink" title="设置进程优先级 nice，renice"></a>设置进程优先级 nice，renice</h3><p>优先级决定了你能享有的系统资源。nice程序用于设定优先级。</p><p>语法： nice [-n adjustment] command</p><p>使用nice时要注意，只能对外部程序例如软件和自己写的程序设置优先级，系统内部命令不能设定优先级。其次，一般只对后台程序降低优先级，对前台程序降低优先级是自己找罪受。</p><p>不使用nice时优先级是0，使用nice默认的优先级是10，数字越大优先级越低，最大可以设到20，最小可以设到-20.当设负数的时候是提高优先级。</p><p><strong>renice</strong>重新设置优先级。</p><p>语法： renice niceness -p processid</p><p>niceness是nice值，processid是进程ID。</p><p>niec程序是在程序开始运行时确定的，使用nice程序后command程序便开始运行。而renice是对已运行的程序重新设置优先级。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>很多程序并不是由用户运行的，由系统运行的程序就是守护程序。相当于windows中的服务程序。这些程序不受终端控制</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>文件操作</title>
    <url>/post/95495db.html</url>
    <content><![CDATA[<!-- build time:Thu Apr 16 2020 12:55:30 GMT+0800 (中国标准时间) --><h3 id="touch-创建文件"><a href="#touch-创建文件" class="headerlink" title="touch 创建文件"></a>touch 创建文件</h3><p>创建文件有许多种方式，例如用vi创建文件，利用重定向创建文件。</p><p>语法： touch [-acm] [-t time] file…</p><p>作用： 创建文件，改变文件的修改时间和访问时间。</p><p>-m 改变修改时间</p><p>-a 改变访问时间</p><p>-t 用一个具体的时间去替换</p><p>如果不加参数会将修改时间和访问时间全部修改。</p><p>例如： touch * ，这个命令会修改目录下的所有文件的访问时间和修改时间。</p><p>如果后面接的文件名不存在，touch将会创建一个文件。</p><p>-c 不创建文件。如果文件存在，会修改时间，如果文件不存在，不进行操作。</p><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>要求：</p><ol><li>文件名最长是255个字符</li><li>文件名可以包含除了/外的任何字符</li></ol><p>虽然说创建文件名的时候没有太多的要求，但是最好创建有意义的名字并且不要实用一些特殊字符。例如-，虽然创建的时候不会出现问题，但是使用命令进行操作的时候却会带来麻烦。</p><h3 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp 复制文件"></a>cp 复制文件</h3><p>语法： cp [-ip] file1 file2</p><p>file1是已有文件 file2是目标文件</p><p>例如： cp /etc/passwd ~/pword</p><p>这个命令会复制passwd文件到pword中，如果pword不存在，那么就会创建。这时需要特别小心，如果目标文件存在，那么复制完之后原来的内容咩有办法找回。</p><p>如果想追加数据，则不能用cp，只能用cat重定向追加内容。</p><p>cp很容易错误的清楚数据，为了保险起见，可以用-i选项。这个选项会在替换已有文件时先询问。可以在初始化文件中直接设定。</p><p>还有一个选项是-p，这个命令使目标文件和原文件有相同的修改时间访问时间和权限。</p><p><strong>-r</strong>，将一个目录复制到另一个目录中。</p><p><strong>将文件复制到不同目录中</strong></p><p>就是将file2变成directory。</p><h3 id="mv-移动文件"><a href="#mv-移动文件" class="headerlink" title="mv 移动文件"></a>mv 移动文件</h3><p><a href="https://xinhecuican.github.io/post/61312.html#more">在前面博客中已经提到</a></p><h3 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm 删除文件"></a>rm 删除文件</h3><p>语法： rm [-fir] file…</p><p>rm删除同样是不可恢复的。为了防止误删文件，可以使用-i选项，每次删除之前请求许可。</p><p>-f 强制删除文件，不考虑权限和-i。</p><p>-r 删除整个目录树，这个选项会将从工作目录开始的所有文件全部删除</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>权限一共有三种，读权限，写权限，执行权限。这些权限和用户标识也有关，如果是普通用户，可能对一些文件没有写权限和执行权限。</p><p>设置权限有两个目的，限制其他用户的访问和避免自己错误的使用。</p><p>下面是权限的作用</p><table><thead><tr><th>文件</th><th></th></tr></thead><tbody><tr><td>读</td><td>读取文件(没有这个权限使用命令也无法查看文件）</td></tr><tr><td>写</td><td>写入文件，没有写权限的话在删除和替换时都会先询问</td></tr><tr><td>执行</td><td>执行文件</td></tr><tr><td>** 目录**</td><td></td></tr><tr><td>读</td><td>读取（查看）目录</td></tr><tr><td>写</td><td>创建、移动、复制或删除目录</td></tr><tr><td>执行</td><td>搜索目录</td></tr></tbody></table><p>例如，有这个文件的写权限和执行权限，那么无法看到它（也就是点文件），但是如果知道它的位置，还是可以对他进行操作。</p><h4 id="id-groups-维护文件权限"><a href="#id-groups-维护文件权限" class="headerlink" title="id groups 维护文件权限"></a>id groups 维护文件权限</h4><p>创建文件的用户标识就是文件的属主。每个用户都属于一个组，第二组是组中其他人，第三组是其他人，可以为这三组设置读写和执行权限。</p><p>系统中组标识的列表在/etc/group中，这个文件可以自由查看</p><p>id就是用来查看当前用户标识和属于那个组的。groups命令是同样的作用。</p><h4 id="ls-l显示文件权限"><a href="#ls-l显示文件权限" class="headerlink" title="ls -l显示文件权限"></a>ls -l显示文件权限</h4><p>使用-l时，从左边开始会有一些字符。例如-rwx等等</p><p>首先第一个字符是-或者d，-代表普通文件，d代表目录。之后会有9个字符分成3组，分别代表个人权限，族权限，其他人权限。</p><p>除了这种表示方法，还可以用三个数字表示三中类型的权限</p><ul><li>r: 读权限 数字 4</li><li>w: 写权限 数字 2</li><li>x: 执行权限 数字 1</li><li>-: 没有权限 数字 0</li></ul><p>例如只有读写权限，那么就可以用6来代表。</p><h4 id="改变文件权限"><a href="#改变文件权限" class="headerlink" title="改变文件权限"></a>改变文件权限</h4><p>可以使用chmod（change file mode）来改变文件权限</p><p>语法： chmod mode file…</p><p>这里的mode是使用数字表示的，并且一次要写三种类型。</p><p>例如： chmod 644 file1</p><h3 id="shred-清空文件内容"><a href="#shred-清空文件内容" class="headerlink" title="shred 清空文件内容"></a>shred 清空文件内容</h3><p>前面讲的rm命令只是删除了文件，但是文件所在的空间还是可以重新被使用的。甚至这个时候如果用昂贵的设备，那么其中的内容还是可以恢复的。如果使用了shred，那么就会毁坏硬盘（后备隐藏能源？），这时数据就永远无法恢复了。这里就不展开了。</p><h3 id="stat-ls-i-链接的概念"><a href="#stat-ls-i-链接的概念" class="headerlink" title="stat ls -i 链接的概念"></a>stat ls -i 链接的概念</h3><p>当linux创建文件时，进行两个操作。在储存设备上保留一块空间来保存数据，之后创建一个索引节点（i节点）来存放数据的基本信息。i节点包含使用文件所需的全部信息</p><p>stat命令就是查看i节点的内容</p><p>所有的i节点存放于一个大表中，称为i节点表。在节点表中，每个i节点由索引号和i节点号表示。为了查看节点号，可以使用ls -i选项。如果想查看所有节点，可以使用ls -il。</p><p>处理目录时，其实我们处理的是i节点号和节点名称。所以目录实际上很小。只有一个名称，每一个名称对应一个i节点号。</p><p>例如，我们现在bin目录中创建swap文件。那么先保留一块空间，如果查看i节点表，查找一个空闲的i节点。然后linux将信息填充到属于这个文件的i节点中。之后在bin目录中放入一个条目，该条目有名称和i节点号。</p><p>文件名和i节点之间的连接叫链接。</p><h3 id="多重链接，一个文件，多个名字"><a href="#多重链接，一个文件，多个名字" class="headerlink" title="多重链接，一个文件，多个名字"></a>多重链接，一个文件，多个名字</h3><p>多重链接就是一个文件可以有不同的名称。因为文件标识实际上是i节点号，我们从目录中查询的时候也是查询i节点号然后根据节点号中的信息去访问。因此我们可以在不同目录中创建指向同一个节点号的文件，这其实就是快捷方式。</p><h4 id="ln-创建新链接"><a href="#ln-创建新链接" class="headerlink" title="ln 创建新链接"></a>ln 创建新链接</h4><p>语法： ln file newname</p><p>作用：每当创建文件时，系统都会自动在文件和文件名间创建一个链接。如果我们想为已有文件创建一个新链接，就可以用ln（link）。</p><p>我们也可以将newname改成directory，那么就是创建快捷方式</p><p><strong>移除链接</strong></p><p>直接用rm命令即可，除非所有链接都被删除，不然文件不会被删除。</p><h3 id="符号链接-ln-s"><a href="#符号链接-ln-s" class="headerlink" title="符号链接 ln -s"></a>符号链接 ln -s</h3><p>前面讲的链接有两点限制。一，不能为目录创建链接。二，不能为不同文件系统创建链接。（因为目录没有i节点）</p><p>如果想克服上述情况，就需要创建符号链接。符号链接包含的不是文件的i节点号，而是原文件的路径名。</p><p>但是用ls -l时，左边会有一个l代表链接。实际符号链接在右边。用一个-&gt;符号后面加上指向的真实文件名表示。因为符号链接只存一个路径，所以大小也只有4字节。注意这是符号链接才会有-&gt;符号，一般的链接不会显示。</p><p>一般的链接叫做硬链接，就是起了一个别名。符号链接叫做软链接，实际上并不是存放那个文件，只是存放一个指向文件的地址。</p><p>硬链接数量ls -l可以显示，但是软链接无法显示，因为系统也不知道有多少软链接。并且当文件被删除时，软链接也不会被删除，只是打开时发生错误</p><h4 id="目录使用符号链接"><a href="#目录使用符号链接" class="headerlink" title="目录使用符号链接"></a>目录使用符号链接</h4><p>当我们对目录使用符号链接之后，cd时到底应该显示真实的目录还是符号链接目录呢？实际上两种都可以。</p><p>如果使用cd -L选项，将把符号链接视为真实目录，使用-P选项将用真实目录替换符号链接，也就是直接进入真实目录。默认情况是-L。</p><p>我们使用-L情况是和-P一样的，使用-L时目录显示与原文件相同，就是实际对源文件进行操作的时候想要进行跳转。</p><h3 id="locate-通过数据库查看文件"><a href="#locate-通过数据库查看文件" class="headerlink" title="locate 通过数据库查看文件"></a>locate 通过数据库查看文件</h3><p>语法： locate [-bcirS] pattern…</p><p>作用： 在一个特殊的数据库（包含所有的可公共访问的文件，且定期更新）查找文件。</p><p>如果想使用正则表达式，可以使用-r选项 ，可以用^和$表示开头和结尾。</p><p>例如 locate -r ‘.jpg$’ 是找jpg图片</p><p>locate -ir ‘^/usr*x11$’ 是找以/usr开头，x11结尾的。</p><ul><li>-c 统计数目，而不显示位置</li><li>-i 忽略大小写</li></ul><h3 id="find-搜索目录树查找文件"><a href="#find-搜索目录树查找文件" class="headerlink" title="find 搜索目录树查找文件"></a>find 搜索目录树查找文件</h3><p>语法： find path… test… action…</p><p>输入命令后，find执行三步</p><ol><li>路径，先查看每个路径，检查这个路径代表的整个目录树</li><li>测试，对于遇到的每个文件，find用指定的测试条件进行测试，成功就进行下一步</li><li>动作，一旦搜索完成，对成功通过上面两个步骤的文件做的操作</li></ol><p>例如： find /home/harley -name important -print</p><p>路径： /home/harley。表示从harley目录开始进行搜索，也就是home目录不搜索。路径可以有多个</p><p>动作： -name important。这个的含义是查找名字是important的文件</p><p>动作： -print。输出路径名</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>下列是一些模式</p><table><thead><tr><th>文件名</th><th></th></tr></thead><tbody><tr><td>-name pattern</td><td>包含pattern的文件名</td></tr><tr><td>-iname pattern</td><td>不区分大小写</td></tr><tr><td><strong>文件特征</strong></td><td></td></tr><tr><td>-type [df]</td><td>文件类型 d：目录 f：普通文件</td></tr><tr><td>-perm mode</td><td>文件权限</td></tr><tr><td>-user userid</td><td>文件属主</td></tr><tr><td>-group groupid</td><td>组为groupid</td></tr><tr><td>-size [-+]n[cbkMG]</td><td>大小为n[字节，块，kb，mb，gb]</td></tr><tr><td>-empty</td><td>空文件</td></tr><tr><td><strong>访问时间，修改时间</strong></td><td></td></tr><tr><td>-amin [-+]n</td><td>n分钟之前访问，-是小于这个时间</td></tr><tr><td>-atime [-+]n</td><td>n天之前访问</td></tr><tr><td>-anewer file</td><td>file之后访问</td></tr><tr><td>-cmin [-+]n</td><td>n分钟之前状态改变</td></tr><tr><td>-cnewer file</td><td>file状态改变之后改变</td></tr><tr><td>-time [-+]n</td><td>…</td></tr><tr><td>-mmin [-+]n</td><td>n分钟之前修改</td></tr><tr><td>-mtime [-+]n</td><td>n天之前修改</td></tr><tr><td>-newer file</td><td>file文件之后修改</td></tr></tbody></table><p>最重要的是type和name。中括号中的加减号代表的是大于和小于。</p><p>type控制查找那些类型。除了上面的之外，还有b(块设备），c（字符设备），p（命名管道），l（符号链接）</p><p>例如： <code>find . -type f -name important -print</code></p><p>其中name后面的pattern可以用通配符。</p><p>cmin代表的是访问或修改。</p><p>例如： find ~ -cmin -10 -print</p><p>这个的含义是查找10分钟内被访问或修改的文件。</p><h4 id="使用！对测试求反"><a href="#使用！对测试求反" class="headerlink" title="使用！对测试求反"></a>使用！对测试求反</h4><p>使用!时要注意两个问题：</p><ol><li>！号两边要有空格</li><li>必须要引用！，可以<code>\!</code>,也可以’!’</li></ol><p>并且一个感叹号只对一个测试有效。</p><h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><table><thead><tr><th>动作</th><th></th></tr></thead><tbody><tr><td>-print</td><td>将路径名写入标准输出</td></tr><tr><td>-fprint file</td><td>将输出写入file中</td></tr><tr><td>-ls</td><td>显示长目录列表，和ls -l输出样式差不多</td></tr><tr><td>-fls file</td><td>输出写入file中</td></tr><tr><td>-delete</td><td>输出文件</td></tr><tr><td>-exec command {} ;</td><td>执行command，{}指示匹配的文件名</td></tr><tr><td>-ok command {} ;</td><td>同exec，在执行command前先确认</td></tr></tbody></table><p>exec后面的command是linux的程序例如ls，echo等。这条命令以;（封号）结尾，前面的\是转义字符。而{}有些系统必须要加转义字符。</p><p>例如： <code>find . -name &#39;*.backup&#39; -exec ls -dils {} \;</code></p><h4 id="xargs-处理查找到的文件"><a href="#xargs-处理查找到的文件" class="headerlink" title="xargs 处理查找到的文件"></a>xargs 处理查找到的文件</h4><p>对于查找到的文件可以用exec处理，但是这里专门有一个程序去处理。</p><p>语法： xargs [-prt] [-i string] [command | argument…]</p><p>command是希望运行的程序，string是占位符，argument是从标准输入中读取的参数。</p><p>例如： find ~ -type f | xargs ls -s</p><p>如果想多次运行同一命令，那么需要使用-i选项，并且后面要使用 { }作为占位符，占位符在命令开始之前会被参数替代。</p><p>例如： find . -type f | xargs -i echo { } { }</p><p>这条命令将会连续输出两次。如果想自己指定占位符，可以直接在-i后面添加字符串。</p><p>例如： find . -type f | xargs -iXX mv XX ~/backups/XX.old</p><p>这条命令即移动又进行了重命名（变成XX.old)</p><p>-p 运行命令之前先提示</p><p>-t 运行命令不会请求许可但是会显示在标准输出中。</p><p>-r 如果没有参数，则不执行。</p><p>例如： <code>find . -empty | xarg -r ls -l</code></p><p>原本如果是没有空文件的话ls将会输出整个目录，这当然不对，所以没有空文件的时候就可以让他忽略。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>流水线</title>
    <url>/post/b4c1d206.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>cpu运算可以简化成两大块，运算单元和寄存器。大致过程是先从寄存器中取值然后放入运算单元中运算完成之后又放入寄存器中。大致过程可分为六个部分</p><ol><li>fetch(取指），读入指令</li><li>decode(译码),解码然后把寄存器中的值放到运算单元中</li><li>execute(执行), 进行计算</li><li>memory(访存),把结果放到内存中</li><li>write back（写回），把结果放到寄存器中</li><li>PC（更新PC）</li></ol><p>这六个部分和把数据放到寄存器所用的总时间就是执行一条指令所需要的时间。cpu中有一个时钟，时钟以特定的周期进行高电压和低电压的变换。每一个周期内cpu执行一条指令，这个周期就是时钟周期。</p><p>但是这样速度不够快，因为cpu同一时间内只有一部分在工作，其他的都处于待机状态，所以可以用一种办法把其他部分利用起来。</p><p>之前我们之所以不能连续送入多条指令的原因是如果牵一条指令还未执行完成后一条指令便开始执行很可能导致电路出现问题（先这样理解吧）。如果我们在中间插入寄存器的话便不存在这个问题了。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GHERKIN"><figure class="iseeu highlight /gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> 算术单元 </span>|<span class="string"> 寄存器 </span>|</span><br><span class="line">|<span class="string"> 300ps   </span>|<span class="string">  20ps  </span>|</span><br><span class="line">|<span class="string"> 算术单元1 </span>|<span class="string"> 寄存器1 </span>|<span class="string"> 算术单元2 </span>|<span class="string"> 寄存器2 </span>|<span class="string"> 算术单元3 </span>|<span class="string"> 寄存器</span></span><br><span class="line">|<span class="string"> 100ps    </span>|<span class="string"> 20ps   </span>|<span class="string"> 100ps    </span>|<span class="string"> 20ps   </span>|<span class="string"> 100ps    </span>|<span class="string"> 20ps</span></span><br></pre></td></tr></table></figure></div><p>乍一看加了寄存器之后时钟周期反而变长了，便成360ps。但实际上现在可以每120ps送入一条指令，先前的运算结果可以先储存在寄存器中，新一个时钟周期时把寄存器中的值送入下一个运算单元，这样就节省了时间</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VIM"><figure class="iseeu highlight /vim"><table><tr><td class="code"><pre><span class="line">如果把时间分成<span class="number">3</span>部分来运算</span><br><span class="line">abcabcabc  不用流水线</span><br><span class="line"><span class="keyword">abc</span></span><br><span class="line"> <span class="keyword">abc</span>      用流水线</span><br><span class="line">  <span class="keyword">abc</span></span><br></pre></td></tr></table></figure></div><p>可以看出使用流水线后时间明显缩短</p><p>但是流水线也有一些问题。</p><ol><li>不能无限划分，随着划分的增多价格问题也越来越严重，性能提升却不大。甚至无限划分的时候，时间反而会变成无穷大（因为寄存器上时间过多，永远也执行不了指令）。</li><li>不一致的划分，因为流水线的时钟频率是根据耗时最长的那一阶段来确定的，所以如果划分不一致，就会导致最长的那段时间增大。正因如此，cpu一般把取指和PC这两个阶段当做一个阶段在最开始执行。</li><li>数据相关。 程序中上一条指令和下一条指令很可能有关联[例]<br>[例]: movq rax rbx movq rbx rcx</li><li>控制相关。 主要是条件跳转指令，因为一次输入了多条指令，所以很可能前面的判断没有完成的时候条件判断语句后面的指令已经开始计算了，这时候如果条件跳转指令跳转到了另一个地方，那前面开始计算的部分全部要清空，然后重新载入流水线。这样就会极大的影响效率。</li></ol><p>解决办法：</p><p>对于数据相关可以中间插入一个空命令例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="code"><pre><span class="line">a阶段只有命令的传入，并没有涉及到数据的传入,假设第一条和第二条有冲突</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br><span class="line">  空</span><br><span class="line">    <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br><span class="line">      <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br></pre></td></tr></table></figure></div><p>但是这样还是会导致效率的降低。</p><p>一个更好的办法是在cpu内部对命令进行重排，但是又不影响运行逻辑。</p><p>对于控制相关可以使用数据传输指令，但是数据传输指令也具有局限性。</p><p>还可以通过分支预测的方法。如果是第一次进入分支，直接顺序传入指令，如果不是第一次，可以传入上一次分支运行时的指令。这样对循环具有优化作用。</p><p>此外在编译器层面，可以提前预测那种可能性比较大。然后把可能性大的部分放在分支语句的后面。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>linux目录操作</title>
    <url>/post/61312.html</url>
    <content><![CDATA[<!-- build time:Mon Apr 13 2020 16:57:02 GMT+0800 (中国标准时间) --><h3 id="目录名和工作目录"><a href="#目录名和工作目录" class="headerlink" title="目录名和工作目录"></a>目录名和工作目录</h3><p>斜杠表示根目录，如果最后一个名称代表的是文件名。当然，这个文件名也可以是一个目录。</p><p>工作目录又叫当前目录，也是进行操作的根目录（但不是系统的根目录），如果命令后面直接输入一个文件名，那么就是代表这个目录在工作目录中，系统也只会在当前目录中搜寻。</p><h3 id="绝对目录和相对目录"><a href="#绝对目录和相对目录" class="headerlink" title="绝对目录和相对目录"></a>绝对目录和相对目录</h3><p>绝对目录就是从根目录开始。在Linux系统中，根目录是home（这个根目录是当前用户的根目录）目录。</p><p>相对目录就是从工作目录（当前目录）开始。大多数时候我们输入一个文件名其实都是输入相对目录，我们也可以输入绝对目录，但那样过于麻烦。</p><h3 id="路径名缩写"><a href="#路径名缩写" class="headerlink" title="路径名缩写"></a>路径名缩写</h3><p><strong>第一个</strong>： ..（两个点号）。这个符号的含义是父目录，也就是上级目录。用..可以回到上级目录然后在进入子目录</p><p>例：现在绝对目录是 /home/abcd/ceshi，如果我想进入abcd的gongzuoqu目录，那么输入cd ../gongzuoqu即可。这是从左向右读的， ..代表进入父目录，然后再进入父目录中的工作区目录。</p><p><strong>第二个</strong>： .(一个点号）。代表的是当前目录，注意<strong>任何不以/开头的路径名都被认为相对于工作目录</strong>。所以大部分情况下直接输入文件名即可，但是在某些情况下必须输入完整的目录，因此这个时候就需要.代表当前目录便于输入。</p><p>unix只能运行它能找到的程序，也就是在path环境变量中的路径。但是如果我们输入绝对路径的话，程序也能运行，因此这里我们就可以简单的用 . 来代替长长的绝对路径名。</p><p>如果我们想运行new程序，而这个程序不在搜索路径中，那么可以用 ./new来运行它</p><p>一个点号和两个点号都是缩写，所以其实我们运用点号时都是输入<strong>绝对路径名</strong></p><p><strong>第三个</strong> ~(波浪号）。 用这个符号代表home目录（这里的home是系统的根，也就是没有目录包含它）。</p><h3 id="cd-pwd-在目录树中移动"><a href="#cd-pwd-在目录树中移动" class="headerlink" title="cd pwd 在目录树中移动"></a>cd pwd 在目录树中移动</h3><p>pwd命令是显示当前的绝对目录</p><p>cd 命令</p><p>语法： cd [-LP] [directory | - ]</p><p>其中dircetory是你想切换到的目录的名称。</p><p>如果只输入cd，那么会进入home目录下。如果输入cd -， 那么将会进入前一个目录，与cd ..命令效果相同。</p><p>如果使用绝对路径名，那么第一个符号是/。</p><p>例如 cd /home/abcd/gongzuoqu</p><p>如果使用相对路径名，那么第一个就没有/</p><p>例如 cd gongzuoqu/temp</p><h3 id="mkdir-rmdir新建目录和移除目录"><a href="#mkdir-rmdir新建目录和移除目录" class="headerlink" title="mkdir rmdir新建目录和移除目录"></a>mkdir rmdir新建目录和移除目录</h3><p>语法： mkdir [-P] dictory…</p><p>首先，可以使用字母，数字和没有特殊含义的标点符号作为文件名。</p><p>创建目录要遵循两条规则。第一条，不能在一个目录下创建两个同名的目录。第二条，默认情况下，如果父目录不存在，那么就无法创建目录。可以使用-p选项忽略第二条规则。</p><p>语法： redir [-p] directory …</p><p>这里要注意只能移除空的目录。如果想要移除非空的目录，可以使用rm程序</p><p>如果想一次性移除一串目录，那么可以使用-p选项。但是有一个不是空的就不行（除了在这条链上的目录外）</p><p>其次，不能移除根目录和工作目录之间的任何程序。也就是说就算是使用了绝对地址，如果它在工作目录外部，那么也无法移除它。</p><h3 id="mv-移动或重命名目录"><a href="#mv-移动或重命名目录" class="headerlink" title="mv 移动或重命名目录"></a>mv 移动或重命名目录</h3><p>语法： mv directory target</p><p>target如果是一个路径，那么一定是移动目录，如果是名字，那么要看情况。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HASKELL"><figure class="iseeu highlight /haskell"><table><tr><td class="code"><pre><span class="line">/home/harley/<span class="class"><span class="keyword">data</span></span></span><br><span class="line">/home/harley/storge</span><br><span class="line"></span><br><span class="line"><span class="title">mv</span> <span class="class"><span class="keyword">data</span> storage</span></span><br><span class="line"></span><br><span class="line">现在的位置： /home/harley/storge/<span class="class"><span class="keyword">data</span></span></span><br></pre></td></tr></table></figure></div><p>也就是说，如果该路径下没有这个名字的目录，那么就会重命名，但是如果有这个名字的目录，那么就会移动到这个目录下。</p><h3 id="pushd-popd-dirs-使用目录栈"><a href="#pushd-popd-dirs-使用目录栈" class="headerlink" title="pushd,popd,dirs 使用目录栈"></a>pushd,popd,dirs 使用目录栈</h3><p>语法： pushd [directory | +n]</p><p>pop [+n]</p><p>dirs [-c] [-l] [-v]</p><p>push是将目录的名称压入栈中，pop是弹出栈中，dirs是显示栈的内容，n是标识符</p><table><thead><tr><th>命令</th><th>动作</th></tr></thead><tbody><tr><td>dirs</td><td>显示名称，home显示为~</td></tr><tr><td>dirs -l</td><td>home显示为完整路径</td></tr><tr><td>dirs -v</td><td>每行一个显示名称，并有标识符</td></tr><tr><td>pushd directory</td><td>将其压入栈中</td></tr><tr><td>push +n</td><td>把n移到栈顶</td></tr><tr><td>popd +n</td><td>把n移除</td></tr><tr><td>dirs -c</td><td>除当前目录外，移除所有目录</td></tr></tbody></table><p>在任何时候，栈顶都是存放当前工作目录的名称。每当改变工作目录时，栈顶元素也会随之改变。</p><p>如果我们使用了pushd命令，这时我们也会进入这个目录，同时只能进入自己的下级目录。</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>语法： ls [aCdFglrRs1] [name…]</p><p>作用，列举该目录下的文件名称。</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-C 横的列举文件</span></span><br><span class="line"><span class="deletion">-1 竖的列举文件 可以与wc -l组成管道</span></span><br><span class="line"><span class="deletion">-r 按字母表相反顺序进行排序。</span></span><br><span class="line"><span class="deletion">-R 递归。也就是列举完这一层继续列举下一层。如果这个很长的话，可以用less程序</span></span><br><span class="line"><span class="deletion">-F 检查文件类型，会增加几种标识，如下表所示</span></span><br><span class="line"><span class="deletion">--color 使用不同颜色来显示不同类型文件</span></span><br><span class="line"><span class="deletion">-l 显示长列表</span></span><br><span class="line"><span class="deletion">-u 显示访问时间</span></span><br><span class="line"><span class="deletion">-r reverse 从旧的到新的</span></span><br><span class="line"><span class="deletion">-h 自动显示大小</span></span><br><span class="line"><span class="deletion">-d 显示目录本身的信息。</span></span><br><span class="line"><span class="deletion">-a 显示隐藏文件</span></span><br></pre></td></tr></table></figure></div><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>空</td><td>非可执行文件</td></tr><tr><td>*</td><td>可执行文件</td></tr><tr><td>/</td><td>目录</td></tr><tr><td>@</td><td>符号链接</td></tr><tr><td>竖线</td><td>命名管道 /FIFO</td></tr></tbody></table><h4 id="hs-du-df-quota-掌握磁盘空间使用情况"><a href="#hs-du-df-quota-掌握磁盘空间使用情况" class="headerlink" title="-hs du -df -quota 掌握磁盘空间使用情况"></a>-hs du -df -quota 掌握磁盘空间使用情况</h4><p>-s 前面以字节为单位输出文件的大小</p><p>-sh 自动选择合适的单位</p><p>du（disk usage) 显示文件的大小，这是一个程序</p><p>语法： du [-achs] [name…]</p><p>-h 显示单位</p><p>如果不指定名称，du会递归搜索整个目录树</p><p>-s 显示总和</p><p>-c 是先输出每个文件的大小，最后输出总量</p><p>df 显示磁盘可用空间</p><p>quota 显示配额</p><h3 id="file-检查文件类型"><a href="#file-检查文件类型" class="headerlink" title="file 检查文件类型"></a>file 检查文件类型</h3><p>file的使用相当直接，只需要file + 路径就可以检查那个路径下的文件类型，但是比ls显示的更为详细。</p><p>可能显示下列几种类型：</p><ul><li>ELF:可执行和链接模式</li><li>32-bit： 字长</li><li>LSB： 采用最低有效字节编译（小端序）</li><li>executable： 可执行文件</li><li>Intel 80386： 内部文件格式版本</li><li>GNU/linux2.6.9 操作系统和内核版本</li><li>dynamically linked 使用共享库</li><li>stripped 将符号表移除的可执行文件</li></ul><h3 id="块和分配单元"><a href="#块和分配单元" class="headerlink" title="块和分配单元"></a>块和分配单元</h3><p>在文件系统中，空间以固定大小进行分配，我们把固定大小的组块叫做块。块的大小在不同系统中不同。块的大小有512,1,2,4kb等。典型的linux系统是1kb。</p><p>此时我们只是说在文件系统中的分配方式。但是写入到磁盘中时出于效率的考虑，磁盘中也有特定的单元叫做分配单元或者簇。例如，分配单元为8kb代表即使只有1btye的数据系统也会自动分配8kb</p><h3 id="使用通配符进行通配"><a href="#使用通配符进行通配" class="headerlink" title="使用通配符进行通配"></a>使用通配符进行通配</h3><p>使用通配符可以指定特定的文件名，类似于正则表达式。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>匹配任何0个或多个字符组成的序列</td></tr><tr><td>？</td><td>匹配任何单个字符</td></tr><tr><td>[list]</td><td>匹配list中任意字符</td></tr><tr><td>[^list]</td><td>匹配不再list中任意字符</td></tr><tr><td>{string1竖线string2}</td><td>匹配任意一个字符串</td></tr></tbody></table><p>其实就是一个简化版的正则表达式。例如： ls h*表示显示所有以h为开头的文件或目录</p><p>此外，还可以使用一些预定义字符类，例如[[:lower:]]等</p><h3 id="显示目录树"><a href="#显示目录树" class="headerlink" title="显示目录树"></a>显示目录树</h3><p>语法： tree [-adfFilrst] [-L level] [directory…]</p><p>level是树的深度</p><p>作用：绘制文件系统中任意部分的图形（真的就是一个目录图表，可以自己试一下）。</p><p>选项：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-a 显示所有文件，包括点文件</span></span><br><span class="line"><span class="deletion">-s 显示文件大小</span></span><br><span class="line"><span class="deletion">-F 显示标识文件的标志</span></span><br><span class="line"><span class="deletion">-r 以相反顺序输出</span></span><br><span class="line"><span class="deletion">-t 按修改时间顺序输出</span></span><br><span class="line"><span class="deletion">-d 只显示目录</span></span><br><span class="line"><span class="deletion">-i 省略缩进，这种模式只会输出一条条路径，但是不会生成一个图标</span></span><br><span class="line"><span class="deletion">-L 限制树的深度。后面的数字就是树的深度</span></span><br></pre></td></tr></table></figure></div><p>个人意见可以重定向到一个文件中然后再文件中查找。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>gdb</title>
    <url>/post/63002.html</url>
    <content><![CDATA[<!-- build time:Sat Apr 18 2020 19:39:59 GMT+0800 (中国标准时间) --><h3 id="进入gdb"><a href="#进入gdb" class="headerlink" title="进入gdb"></a>进入gdb</h3><p>首先gdb一般都是用来调试c或c++的，gdb是要运行可执行文件的，所以先要进行编译。具体命令如下：</p><p><code>gcc -g 源文件.c -o 输出的目标文件</code></p><p>-g是用来插入编译所需的信息, -o是用来生成可执行文件</p><p>生成的时候会产生一大堆信息，如果不想看的话可以使用 -q 选项，如果想永久设定可以在bashrc中设置别名 alias gdb = ‘gdb -q’</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>start</td><td>进入main函数</td><td>无</td></tr><tr><td>run</td><td>重新开始运行 run-text 加载文本文件 run-bin加载二进制文件</td><td>r</td></tr><tr><td>next</td><td>执行一行程序，不进入函数，直接把函数执行完</td><td>n</td></tr><tr><td>step</td><td>执行一行程序，进入函数</td><td>s</td></tr><tr><td>list</td><td>查看程序，list+函数名查看函数</td><td>l</td></tr><tr><td>continue</td><td>继续执行到断点处</td><td>c</td></tr><tr><td>quit</td><td>终止程序</td><td>q</td></tr><tr><td>set 参数</td><td>设置断点</td><td>无</td></tr><tr><td>nexti</td><td>运行一条机器指令</td><td>ni</td></tr><tr><td>jump + 标号</td><td>跳转到某一位置执行</td><td>j</td></tr></tbody></table><p>注意jump命令跳转后仍是一直执行，所以要在某一位置手动设置断点</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>return</td><td>退出函数且不执行后面代码，也可以return+参数指定返回值</td><td>无</td></tr><tr><td>finish</td><td>退出函数且执行完剩下的代码</td><td>无</td></tr><tr><td>call/print</td><td>直接调用函数执行</td><td>无</td></tr><tr><td>info files</td><td>显示所有程序及位置</td><td>无</td></tr><tr><td>info functions（regex）</td><td>显示函数（可加正则表达式）</td><td>无</td></tr><tr><td>set step-mode on</td><td>进入不带调试信息的函数（如printf）</td><td>无</td></tr></tbody></table><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>break</td><td>设置断点</td><td>b</td></tr><tr><td>tbreak</td><td>设置临时断点（只</td><td></td></tr><tr><td>能使用一次）</td><td>tb</td><td></td></tr><tr><td>info breakpoints</td><td>查看当前所有断点</td><td>i b</td></tr><tr><td>enable/disable breakpoints</td><td>启用/禁用断点</td><td>无</td></tr><tr><td>clear+编号</td><td>删除断点</td><td>无</td></tr><tr><td>** break参数 **</td><td></td><td><strong>例</strong></td></tr><tr><td>*+地址</td><td>在某一地址设置断点</td><td>b *0x400522</td></tr><tr><td>函数名</td><td>在某一函数进入前停止</td><td>b main</td></tr><tr><td>行号</td><td>在某一行号处设置断点</td><td>b 7</td></tr><tr><td>+offset/-offset</td><td>在当前行前后offset行设置</td><td>无</td></tr><tr><td>break … if &lt; condition&gt;</td><td>只有在条件满足时，断点才会被触发</td><td>b 10 if i==101</td></tr><tr><td>ignore bnum count</td><td>忽略bnum次编号为count的断点</td><td>ignore 1 5</td></tr><tr><td><strong>观察点</strong></td><td>观察变量值的变化</td><td></td></tr><tr><td>watch</td><td>当一个值发生变化时，程序会停下来，相当于是写观察点</td><td>无</td></tr><tr><td>reatch</td><td>当一个值发生读行为时，程序停止</td><td>无</td></tr><tr><td>awatch</td><td>每次读取或改变a的值都会让程序停下来</td><td>aw</td></tr><tr><td>info watch</td><td>显示观察点</td><td>i watch</td></tr><tr><td><strong>catchpoint</strong></td><td>当程序异常终止或加载链接库时停止运行，这里不展开</td><td></td></tr></tbody></table><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">）设置catchpoints:</span></span><br><span class="line"><span class="attr">a. catch event:</span> <span class="string">当事件event发生的时候，程序停止运行，这里event的取值有：</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">）throw:</span> <span class="string">C++抛出异常</span></span><br><span class="line"><span class="number">2</span><span class="string">）catch:</span> <span class="string">C++捕捉到异常</span></span><br><span class="line"><span class="number">3</span><span class="string">）exec:</span> <span class="string">exec被调用</span></span><br><span class="line"><span class="number">4</span><span class="string">）fork:</span> <span class="string">fork被调用</span></span><br><span class="line"><span class="number">5</span><span class="string">）vfork:</span> <span class="string">vfork被调用</span></span><br><span class="line"><span class="number">6</span><span class="string">）load:</span> <span class="string">加载动态库</span></span><br><span class="line"><span class="number">7</span><span class="string">）load</span> <span class="attr">libname:</span> <span class="string">加载名为libname的动态库</span></span><br><span class="line"><span class="number">8</span><span class="string">）unload:</span> <span class="string">卸载动态库</span></span><br><span class="line"><span class="number">9</span><span class="string">）unload</span> <span class="attr">libname:</span> <span class="string">卸载名为libname的动态库</span></span><br><span class="line"><span class="number">10</span><span class="string">）syscall</span> <span class="string">[args]:</span> <span class="string">调用系统调用，args可以指定系统调用号，或者系统名称</span></span><br><span class="line"><span class="attr">b. tcatch event:</span> <span class="string">设置只停一次的catchpoint，第一次生效后，该catchpoint被自动删除</span></span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/kevinx_xu/article/details/36261571" target="_blank" rel="external nofollow noopener noreferrer">这一段从网上扒的</a></p><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>disassemble 如果不带参数，会自动显示后面若干条汇编指令。简写disas</p><p>如果带一个参数，可以带函数名也可以带某一个地址，都是显示那个地址处的函数的汇编代码。</p><p>如果带两个参数，也就是起始地址和终止地址，那么就会显示两个之间的代码</p><h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>reverse-continue</td><td>反向运行程序知道遇到一个能使程序中断的事件（比如断点，观察点，异常）</td><td>无</td></tr><tr><td>reverse-step</td><td>返回到上一次执行的源代码行</td><td>无</td></tr><tr><td>reverse-stepi</td><td>返回上一条机器指令</td><td>无</td></tr><tr><td>reverse-next</td><td>返回上一次执行的源代码行，但不执行函数</td><td>无</td></tr><tr><td>reverse-nexti</td><td>反向运行到上一条机器指令，除非这条指令用来返回一个函数调用、整个函数将会被反向执行。</td><td>无</td></tr><tr><td>reverse-finish</td><td>反向运行程序回到调用当前函数的地方</td><td>无</td></tr></tbody></table><p>注意，想使用回退功能先要用record命令对指令进行录制</p><h3 id="调试带参数的程序"><a href="#调试带参数的程序" class="headerlink" title="调试带参数的程序"></a>调试带参数的程序</h3><p>方法1： gdb启动时候加参数</p><p>gdb –args ./main aaaa bb</p><p>方法2：</p><p>gdb main //先启动起来</p><p>(gdb)run aaaa bb</p><p>方法3</p><p>gdb main //先启动起来</p><p>(gdb)set args aaaa bb</p><p>(gdb)run //或者start</p><p>(gdb)show args</p><p><a href="https://blog.csdn.net/mw_nice/java/article/details/100991341" target="_blank" rel="external nofollow noopener noreferrer">这部分照搬的</a></p><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>** 函数栈帧打印**</td><td></td><td></td></tr><tr><td>i frame</td><td>输出了当前函数堆栈帧的地址，指令寄存器的值，局部变量地址及值等信息</td><td>无</td></tr><tr><td>frame n</td><td>打印第n层的函数栈帧</td><td>无</td></tr><tr><td>up/down n</td><td>向上/向下切换栈帧</td><td>无</td></tr><tr><td>print + 数组名</td><td>打印数组内容</td><td>p</td></tr><tr><td>set print array-indexes on</td><td>打印数组时打印下标</td><td>无</td></tr><tr><td>info locals</td><td>打印局部变量值</td><td>i locals</td></tr><tr><td>backtrace full n</td><td>由内向外显示n个栈帧的值</td><td>bt</td></tr><tr><td>set print pretty on</td><td>打印结构体</td><td>无</td></tr><tr><td>p *array@len</td><td>array数组名 len 数据长度</td><td>无</td></tr><tr><td>p $寄存器名</td><td>查看某个寄存器的值</td><td>无</td></tr><tr><td>info register</td><td>查看所有寄存器</td><td>i reg</td></tr></tbody></table><h4 id="x-显示内存中内容命令"><a href="#x-显示内存中内容命令" class="headerlink" title="x 显示内存中内容命令"></a>x 显示内存中内容命令</h4><p>格式: x /nfu<addr></addr></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">n表示要显示的内存单元的个数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">f表示显示方式,</span> <span class="string">可取如下值</span></span><br><span class="line"><span class="attr">x</span> <span class="string">按十六进制格式显示变量。</span></span><br><span class="line"><span class="attr">d</span> <span class="string">按十进制格式显示变量。</span></span><br><span class="line"><span class="attr">u</span> <span class="string">按十进制格式显示无符号整型。</span></span><br><span class="line"><span class="attr">o</span> <span class="string">按八进制格式显示变量。</span></span><br><span class="line"><span class="attr">t</span> <span class="string">按二进制格式显示变量。</span></span><br><span class="line"><span class="attr">a</span> <span class="string">按十六进制格式显示变量。</span></span><br><span class="line"><span class="attr">i</span> <span class="string">指令地址格式</span></span><br><span class="line"><span class="attr">c</span> <span class="string">按字符格式显示变量。</span></span><br><span class="line"><span class="attr">f</span> <span class="string">按浮点数格式显示变量。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">u表示一个地址单元的长度</span></span><br><span class="line"><span class="attr">b表示单字节，</span></span><br><span class="line"><span class="attr">h表示双字节，</span></span><br><span class="line"><span class="attr">w表示四字节，</span></span><br><span class="line"><span class="attr">g表示八字节</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>unix文件系统</title>
    <url>/post/35532.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>文件就是任意源，有一个名称，可以从中写入读出数据。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>unix中有三种文件类型，普通文件，目录和伪文件。</p><p>普通文件是大多数时候所使用的文件，包括文本文件和二进制文件。例如，纯文本，shell脚本，源程序，配置文件，html文件等。</p><p>目录不同之处在于他们用来组织，访问其他文件。从概念上讲，目录包含其他文件。这个文件其实类似于windows下的文件夹。</p><p>伪文件有时候也称为设备文件。这种文件是物理设备的内部表示。例如键盘，显示器，打印机等，这些设备都可以当成一个文件进行访问。</p><p>有一种特殊的伪文件时proc文件，这种文件可以访问linux内核中的信息，设置可以修改Linux内核中的数据。</p><h3 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h3><p>特殊文件就是表示物理设备的伪文件。这些文件都被存放于/dev下</p><p>一些常见的设备如下</p><table><thead><tr><th>位置</th><th>硬件</th></tr></thead><tbody><tr><td>/dev/sda</td><td>SCSI硬盘</td></tr><tr><td>/dev/sda</td><td>第一分区</td></tr><tr><td>/dev/hda</td><td>硬盘</td></tr><tr><td>/dev/Ip0</td><td>打印机</td></tr><tr><td>/dev/tty</td><td>当前终端</td></tr><tr><td>/dev/random</td><td>随机数生成器</td></tr><tr><td>/dev/null</td><td>放弃输入 输入不返回内容</td></tr><tr><td>/dev/zero</td><td>放弃送站，输入返回0</td></tr></tbody></table><p>写入到/dev/null 或/dev/zero 中的任何文件都会被抛弃，因此这些文件又叫做位桶。</p><p>如果想读取随即数，只需要读取/dev/random。</p><h3 id="mkfifo-命名管道"><a href="#mkfifo-命名管道" class="headerlink" title="mkfifo 命名管道"></a>mkfifo 命名管道</h3><p>在前面我们已经介绍过了管道，那种管道是匿名管道，就是只有当程序运行的时候它才被创建。</p><p>命名管道与匿名管道的显著区别就是必须显式的创建管道，其次，当命令结束之后，管道并不会消失，而是会继续存在，除非使用命令删除他们。</p><p>通常将命名管道称为FIFO，实际上就是队列。</p><p>语法： mkfifo [-m mode] pipe</p><p>其中，mode是chmod程序使用的一种文件类型，pipe是希望创建的管道名称。</p><p>用途：经常被用来两个进程中的通信。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="code"><pre><span class="line">mkfifo fifotest</span><br><span class="line"><span class="keyword">grep</span> bash <span class="regexp">/etc/</span>passwd &gt; fifotest <span class="comment">//第一个窗口上的命令</span></span><br><span class="line">wc -l &lt; fifotest <span class="comment">//这是第二个窗口上的命令</span></span><br></pre></td></tr></table></figure></div><p>如果想要去除管道，只需要rm + 管道名即可。</p><h3 id="proc文件"><a href="#proc文件" class="headerlink" title="proc文件"></a>proc文件</h3><p>proc文件时那些提供一些简单途径来检查多种类型的系统信息的伪文件。proc文件可以直接从内核中提取数据。</p><p>所有的proc文件都存放在/proc目录下，在这个目录中，可以发现每一个进程对应一个子目录。</p><p>如果想提取这些进程的信息，可以使用cat命令去找到当前有那些进程正在执行，如果进入这些目录，还可以知道这些进程的详细状态。</p><p>有一个特殊的proc文件，/proc/kcore，这个文件表示计算机的实际物理内存。可以使用ls -l选项查看这个文件的大小。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="根目录-子目录"><a href="#根目录-子目录" class="headerlink" title="根目录 子目录"></a>根目录 子目录</h4><p>目录是一个树形结构，对于每一层一定会有一个根，而用root过于麻烦，所以一般用/表示根目录。</p><p>例如 ls / 表示列举根目录下的所有文件。这样 ls /bin代表列bin目录下的所有文件。但是实际上如果列举根目录下的文件是不需要加/的，直接加上名字就好了，如果想访问根目录下子目录中的文件，就需要在子目录和子目录文件之间加一个/</p><p>例如： ls homework/bomb</p><h4 id="mount-umount挂载文件系统"><a href="#mount-umount挂载文件系统" class="headerlink" title="mount umount挂载文件系统"></a>mount umount挂载文件系统</h4><p>在系统中，有许多设备，也就有许多个文件系统。但是如果都是完全分隔的话，没办法在不同文件系统之间进行访问，所以一定有一颗主树，然后其他树挂载在主树上，这一个个文件系统其实类似于windows下的磁盘分区。</p><p>当小的文件系统连接上主树时，我们称为挂载。小文件系统附加到主树上的目录叫做挂载点</p><p>一般来说，系统已经自动挂载好了子树，但是有时候需要我们手动挂载子树（例如插入u盘时，当然现在也是自动挂载了）。这时需要mount程序。这里不再展开</p><h4 id="漫游根目录"><a href="#漫游根目录" class="headerlink" title="漫游根目录"></a>漫游根目录</h4><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>/</td><td>根目录</td></tr><tr><td>/bin</td><td>基本程序</td></tr><tr><td>/boot</td><td>启动系统时所需要的文件</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/dev</td><td>设备文件</td></tr><tr><td>/home</td><td>用户home目录</td></tr><tr><td>/lib</td><td>基本共享库，内核模块</td></tr><tr><td>/lost+found</td><td>由fsck恢复的受损文件</td></tr><tr><td>/media</td><td>可移动介质的挂载点</td></tr><tr><td>/mnt</td><td>不能挂载在其他位置的挂载点</td></tr><tr><td>/opt</td><td>第三方应用程序</td></tr><tr><td>/proc</td><td></td></tr><tr><td>/root</td><td>超级用户home目录</td></tr><tr><td>/srv</td><td>本地系统提供服务的数据</td></tr><tr><td>/tmp</td><td>临时文件</td></tr><tr><td>/usr</td><td>静态数据使用的文件系统</td></tr><tr><td>/var</td><td>可变数据使用的文件系统</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>线索二叉树</title>
    <url>/post/43817.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>普通的二叉树中空节点数量很多，例如一个有2n条分支的二叉树，其中节点数只有n-1个，空节点有n+1个，因此就要想办法把这些没用到的节点利用起来。</p><p>可以用原来的空节点去存放指针，指向其他节点，这中指针叫做线索。</p><p>记ptr指向二叉链表中的一个结点，以下是建立线索的规则：</p><p>（1）如果ptr-&gt;lchild为空，则存放指向中序遍历序列中该结点的前驱结点。这个结点称为ptr的中序前驱；</p><p>（2）如果ptr-&gt;rchild为空，则存放指向中序遍历序列中该结点的后继结点。这个结点称为ptr的中序后继；</p><p>显然，在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继，需要一个区分标志的。因此，我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是区分0或1数字的布尔型变量，其占用内存空间要小于像lchild和rchild的指针变量。结点结构如下所示。<br><img src="/images/26548237_13584034551s55.jpg" alt></p><p>ltag = 0 表示指向左孩子，= 1 表示指向前驱</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉线索存储结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;Link, Thread&#125;PointerTag;    <span class="comment">//Link = 0表示指向左右孩子指针；Thread = 1表示指向前驱或后继的线索</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="keyword">char</span> data;                                      <span class="comment">//结点数据</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>                <span class="comment">//左右孩子指针</span></span><br><span class="line">       PointerTag  Ltag;                               <span class="comment">//左右标志</span></span><br><span class="line">       PointerTag  rtal;</span><br><span class="line">&#125;BitNode, *BiTree;</span><br></pre></td></tr></table></figure></div><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以，线索化的过程就是在遍历的过程中修改空指针的过程。<br></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="code"><pre><span class="line"> BiTree pre = NULL;                 <span class="comment">//全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"><span class="comment">//中序遍历进行中序线索化</span></span><br><span class="line">void InThreading(BiTree p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>lchild);          <span class="comment">//递归左子树线索化</span></span><br><span class="line">                <span class="comment">//===</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(!p-&gt;</span>lchild)           <span class="comment">//没有左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>ltag = Thread;    <span class="comment">//前驱线索</span></span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>lchild = pre; <span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(!pre-&gt;</span>rchild)     <span class="comment">//没有右孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rtag = Thread;  <span class="comment">//后继线索</span></span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rchild = p; <span class="comment">//前驱右孩子指针指向后继(当前结点p)</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">                <span class="comment">//===</span></span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>rchild);      <span class="comment">//递归右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>上述代码除了//===之间的代码以外，和二叉树中序遍历的递归代码机会完全一样。只不过将打印结点的功能改成了线索化的功能。<p></p><p>因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if(!pre-&gt;rchild)表示如果为空，则p就是pre的后继，于是pre-&gt;rchild = p，并且设置pre-&gt;rtag = Thread，完成后继结点的线索化。</p><p>前驱指的是某种遍历顺序中在你前面的节点，而后继就是在你后面的节点，这也是为什么pre = p 要写在InThreading(p-&gt;lchild)后面的原因，中序遍历是先做子树的，那么它只能是右子树的前驱而不能是左子树的前驱</p><p>遍历代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//t指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点。</span></span><br><span class="line"><span class="comment">//中序遍历二叉线索树表示二叉树t</span></span><br><span class="line">int InOrderThraverse_Thr(BiTree t)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="function"><span class="title">p</span> = t-&gt;</span>lchild;                               <span class="comment">//p指向根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != t)                               <span class="comment">//空树或遍历结束时p == t</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span>ltag == Link)                       <span class="comment">//当ltag = 0时循环到中序序列的第一个结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">printf</span>("%c ", p-&gt;</span><span class="keyword">data</span>);                      <span class="comment">//显示结点数据，可以更改为其他对结点的操作</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">rtag</span> == Thread &amp;&amp; p-&gt;</span>rchild != t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;</span><br><span class="line">            <span class="function"><span class="title">printf</span>("%c ", p-&gt;</span><span class="keyword">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;                         <span class="comment">//p进入其右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树链表构建和应用</title>
    <url>/post/11799.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>中序</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="code"><pre><span class="line">void inorder(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> != NULL)</span><br><span class="line">    &#123; </span><br><span class="line">        inorder(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">T</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">        inorder(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>前序</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="code"><pre><span class="line">void preorder(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">T</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">        preorder(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        preorder(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>后序遍历同理。</p><p>这个算法是以当前节点为基点，先输出当前节点数值，然后再去输出左子树数值，然后再递归输出左子树数值知道NULL，才又递归输出右子树数值。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="二叉树构建"><a href="#二叉树构建" class="headerlink" title="二叉树构建"></a>二叉树构建</h4><p>如果我们只给出数值和构建顺序，是无法构建二叉树的。例如，给出三个数，然后给出构建顺序是123这样总共有5中构建方法。因此还要把空节点加上才可以构建。空节点的值为-1或@</p><p>前序遍历构建</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="R"><figure class="iseeu highlight /r"><table><tr><td class="code"><pre><span class="line">void create(binarytree *<span class="literal">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'@'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">T</span> = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">T</span> = new binarynode;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">T</span> == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">T</span>-&gt;data = c;</span><br><span class="line">        create(<span class="literal">T</span>-&gt;left);</span><br><span class="line">        create(<span class="literal">T</span>-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里是先构造当前节点，如果当前节点不是空节点，那么构造左节点和右节点。如果是，直接空节点返回。</p><h4 id="计算叶结点个数"><a href="#计算叶结点个数" class="headerlink" title="计算叶结点个数"></a>计算叶结点个数</h4><p>叶节点的特点就是左右子树都是空。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="COQ"><figure class="iseeu highlight /coq"><table><tr><td class="code"><pre><span class="line">int calculate(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)//空树</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;<span class="built_in">left</span> == NULL &amp;&amp; T-&gt;<span class="built_in">right</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(T-&gt;<span class="built_in">left</span>) + calculate(T-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="计算节点个数"><a href="#计算节点个数" class="headerlink" title="计算节点个数"></a>计算节点个数</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="COQ"><figure class="iseeu highlight /coq"><table><tr><td class="code"><pre><span class="line">int calulate(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + calculate(T-&gt;<span class="built_in">left</span>) + calculate(T-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="计算二叉树高度"><a href="#计算二叉树高度" class="headerlink" title="计算二叉树高度"></a>计算二叉树高度</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> counthigh(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = counthigh(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">n</span> = counthigh(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">        return m &gt; <span class="built_in">n</span> ? m+<span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>它的思想是比较左子树和右子树高度，然后再加上根的高度。</p><h4 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h4><p>按前序遍历的方法最好复制</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="code"><pre><span class="line">binode* <span class="keyword">copy</span>(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    binode *<span class="keyword">temp</span> = <span class="built_in">new</span> node;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">temp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">exit</span>(overflow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">temp</span>-&gt;data = T-&gt;data;</span><br><span class="line">    <span class="keyword">temp</span>-&gt;left = <span class="keyword">copy</span>(T-&gt;left);</span><br><span class="line">    <span class="keyword">temp</span>-&gt;right = <span class="keyword">copy</span>(T-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="非递归搜索二叉树"><a href="#非递归搜索二叉树" class="headerlink" title="非递归搜索二叉树"></a>非递归搜索二叉树</h3><p>非递归构造二叉树主要用到了栈来模拟递归过程。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> inorder(binode *T)</span><br><span class="line">&#123;</span><br><span class="line">    binode *p;</span><br><span class="line">    stack&lt;binode*&gt; s;<span class="comment">//如果不行就自己构建一个栈</span></span><br><span class="line">    s.<span class="keyword">push</span>(T);<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( p == s.gettop() &amp;&amp; p != <span class="keyword">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">push</span>(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="comment">/*因为是push左子树，所以最后先push进一个空然后才会退出循环</span></span><br><span class="line"><span class="comment">        所以要先把这个NULL去掉*/</span></span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p = s.gettop();</span><br><span class="line">            cout &lt;&lt; p-&gt;data;</span><br><span class="line">            s.<span class="keyword">pop</span>();<span class="comment">//去掉p节点</span></span><br><span class="line">            s.<span class="keyword">push</span>(p-&gt;right);</span><br><span class="line">            <span class="comment">/*如果p是叶结点，那么push右边也是NULL,内层循环不会执行，然后</span></span><br><span class="line"><span class="comment">            执行pop取点NULL，之后if中又会取出上一层节点继续找右子树*/</span></span><br><span class="line">            <span class="comment">//如果右子树中还有分支，那么会继续这个过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段程序的含义是先找左节点，然后把中间节点退出去，找右节点，在右节点中重复找左节点。</p><p><strong>前序遍历</strong>又稍有不同，因为前序遍历是先直接输出根节点，所以根节点就不需要存入栈中，实际栈中存入的是右节点。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(binode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;binode*&gt; s;</span><br><span class="line">    binode *p = T;</span><br><span class="line">    s.push(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;left;<span class="comment">//进入左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s.gettop();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码是先输出根，然后把右子树拖入栈中，进入左子树，如果左子树遍历完了，p-&gt;left == NULL,之后就到右子树那边去遍历。</p><p><strong>后序遍历</strong>更为麻烦，stack要用自己的，设置一个标志位确定现在是左子树还是右子树</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stacknode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    binode *ptr;</span><br><span class="line">    <span class="keyword">enum</span> tag&#123;L,R&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(binode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> s;</span><br><span class="line">    stacknode w;</span><br><span class="line">    binode *p = T;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            w.ptr = p;</span><br><span class="line">            w.tag = L;</span><br><span class="line">            push(s,w);</span><br><span class="line">            p = p-&gt;leftchild;</span><br><span class="line">        &#125;<span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">continue</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">continue</span> != <span class="number">0</span> &amp;&amp; !stackempty(s))</span><br><span class="line">        &#123;</span><br><span class="line">             pop(s,w);</span><br><span class="line">             p = w.ptr;</span><br><span class="line">             <span class="keyword">switch</span>(w.tag)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">case</span> L: w.tag = R;<span class="comment">//这时算作根节点，根节点为R那么下次就会输出</span></span><br><span class="line">                      push(s,w);</span><br><span class="line">                      <span class="keyword">continue</span> = <span class="number">0</span>;<span class="comment">//退出循环</span></span><br><span class="line">                      p = p-&gt;right;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> R: <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(p != <span class="literal">NULL</span> || !stackempty(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>进程的储存和缓冲区溢出</title>
    <url>/post/27045.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p>用户空间是用户可以使用的空间，与之对应的是内核空间，这是系统所使用的空间。用户空间的大小有2的48次方，远远超出了内存的大小。</p><p>用户空间主要分为四个区域：</p><ul><li>栈，栈位于用户空间的最高处，从高处向低处生长。linux系统中栈空间大小是8MB</li><li>堆， 用于存放一些动态分配的数据</li><li>数据， 用来存放全局变量，静态变量，字符串常量</li><li>代码， 存放指令和共享库</li></ul><p>在Linux中，对于大小小于某一阈值的数据，在堆中分配时是从低地址向高地址生长。反之，从高地址向低地址生长</p><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>常见原因： 申请了一个数组但是访问时越界。</p><p>我们可以把数组叫做缓冲区，超出边界就是缓冲区溢出。</p><p>常见表现，对于输入的字符串没有进行长度检查直接赋值。如果缓冲区分配在栈中，就有可能造成栈中数据的破坏。如果造成了返回地址的破坏，可能直接导致程序的崩溃。这种错误叫做 segmentation fault</p><p>这里便可以被黑客利用，先故意把返回地址破坏了并且让返回地址到他自己写的程序上，这样retq时就可以调用自己写的程序。这种方法叫做注入。一般注入的数据有三部分，第一部分是恶意的指令。第二部分是占位数据，这部分数据没什么含义，只是和指令加起来正好到返回地址处，第三部分就是篡改的地址，篡改后的地址指向缓冲区底部即恶意指令所在的地方。</p><h3 id="防御代码注入攻击"><a href="#防御代码注入攻击" class="headerlink" title="防御代码注入攻击"></a>防御代码注入攻击</h3><ul><li>程序员：不要使用不安全的函数</li><li>系统： 栈基地址随机化分配。设置可执行权限位（就是设置一些地方的bit只能当做数据而不能当做指令）</li><li>编译器： 添加栈破坏检测。通过添加金丝雀值（canary value），位于当前栈帧底部。如果金丝雀值被破坏，那么就终止程序。</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>结构体</title>
    <url>/post/6880.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h3 id="结构体的构成"><a href="#结构体的构成" class="headerlink" title="结构体的构成"></a>结构体的构成</h3><p>首先位于结构体中的元素在计算机也是对应存储的。而结构体的名字其实就可以看成是第一个变量的首地址。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在内存中是这样的</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">| val | c | a[<span class="number">0</span>] | a[<span class="number">1</span>]</span><br><span class="line">p   p+<span class="number">4</span>   p+<span class="number">5</span>   p+<span class="number">9</span></span><br></pre></td></tr></table></figure></div><p>而变量在内存中的位置于定义时的位置是对应的</p><h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>首先说明什么事字节对齐。它指的是变量在内存中的首地址是变量的长度的整数倍。</p><p>例如定义一个int型变量，那么这个变量首地址尽量要是4的整数倍。也就是地址最后两位一定为零，如果是long型，地址最后三位一定为零</p><p><strong>为什么要字节对齐？</strong></p><p>字节对齐可以加快访问数据的效率。原因是64位处理器数据总线是64位的，一次传过来8个字节的数据，所以如果我们是按8的整倍数进行存放，那么一定可以一次性取完，但是如果不是8的整倍数，例如int型首地址是6，那么就不可以一次性取完，要两次来取。而如果我们放在4这个位置，那么一定可以一次性取完。</p><p>此外例如首地址是2，这样也可以一次性取完，但是这样会造成空间浪费，因为现在不能再存int型了，可能会导致剩下4个字节都不能用。</p><p>对于x86系列，可以通过拼凑的方式把数据合起来。但是arm系列，如果没字节对齐，甚至会直接报错。</p><p>因此对于上面这个例子在c这个位置后面应该是p+8,为了让后面的整型保持对齐。而这多出的三个字节不会被使用（从此我们可以得出定义char型最好定义4个，不然多浪费）</p><p>此外，结构体的首地址的倍数由后面元素中占用空间最多的那个来决定。<strong>结尾的地址也要是占用空间最多的整倍数</strong>。结尾也要符合标准是为了便于用数组，因为数组的地址是连续的，所以每个的头和尾都要满足要求。</p><p>字节对齐还有利于结构体中元素的访问。我们之所以可以直接写a.data是因为每个元素在结构体中所占用的空间大小是一样的（考虑字节对齐），这样我们就可以像数组那样直接加上一个偏移量去访问。</p><p><strong>提示</strong>，为了节省空间，把相同类型的元素放到一块写，</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">|</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodeb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>可以看出，第一种写法为保证字节对齐需要多消耗6字节的空间，而第二种写法只需要消耗两字节的空间。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>vi</title>
    <url>/post/20198.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="启动vi"><a href="#启动vi" class="headerlink" title="启动vi"></a>启动vi</h3><p>语法： vi [-rR] [file…]</p><p>如果用vi启动了一个不存在的文件，那么他将新建这个文件。如果只输入vi，那么他将在当前文件夹下创建一个空文件</p><p>-R 以只读模式启动</p><p>vim是vi的进阶版本</p><p>语法： vi -C [-rR] [file…]</p><p>-C是兼容模式，它将尽可能的和vi保持一样</p><h3 id="命令模式和编辑模式"><a href="#命令模式和编辑模式" class="headerlink" title="命令模式和编辑模式"></a>命令模式和编辑模式</h3><p>当使用vi时，存放数据的区域叫做编辑缓冲区（editing buffer),如果想编辑文件，那么vi就将文件的内容复制到缓冲区中，然后再缓冲区中编辑。因此处理的其实是文件的副本。</p><p>在命令模式中，输入的一切字符都是命令。例如，在命令模式中，单个字母x就是删除一个字符。dd就是删除整行的命令。</p><p>第二种模式就是输入模式。这种模式下，任何内容都会输入到缓冲区中。</p><p>在启动过程中，vi完成三件事情。将文件中的内容复制到编辑缓冲区，将光标定位到缓冲区第一行的开头。最后vi进入命令模式。</p><h3 id="数据的恢复和关闭vi"><a href="#数据的恢复和关闭vi" class="headerlink" title="数据的恢复和关闭vi"></a>数据的恢复和关闭vi</h3><p>当使用vi时，数据会保存在编辑缓冲区内，因此当程序非正常终止时，临时文件依然存在。使用-r(recovery)就可以重新打开缓冲区</p><p>如果需要先保存再退出，使用的命令时ZZ,即先按下shift键，然后按z两次。这个命令不需要按enter键</p><p>如果不保存直接退出，可以 :q!，然后按return键</p><h3 id="vi屏幕的格式即vi和ex命令"><a href="#vi屏幕的格式即vi和ex命令" class="headerlink" title="vi屏幕的格式即vi和ex命令"></a>vi屏幕的格式即vi和ex命令</h3><p>屏幕底部的一行叫做命令行。这一行有两种功能：显示消息和显示键入时的命令。</p><p>大多数时候vi编辑的数据都是纯文本（字母，数字，标点符号等）。如果想输入控制字符，需要使用^v。 例如，如果想输入^c,那么需要输入^v^c.</p><p>vi和ex命令其实都是vi编辑器中的命令。大多数vi命令都是单字母或双字母形式。大多数vi命令无需按下return键。例如，一但输入dd，那么立刻会删除一行。</p><p>ex命令一般都比较长，并且在键入过程中会显示在屏幕下方。如果键入有错误，可以backspace删除单个字符或者^x/^u删除所有字符。</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>h 向左移动一个字符</p><p>j 向下移动一个字符</p><p>k 向上移动一个字符</p><p>l 向右移动一个字符</p><p>另外一种方式是上下左右键。</p><p>此外，backspace 向左移动一个位置，space向右移动一个位置。-号移动到上一行，+号移动到下一行。</p><p>0移动到当前行的开头，$移动到当前行的结尾。^移动到第一个非制表符/空格字符上</p><p>w移动到下一个单词的开头，e移动到下一个单词的结尾。b移动到上一个单词的开头</p><p>W，E，B的作用和w，e，b的作用相同，但是忽略标点符号</p><p>( 移动到上一个句子</p><p>) 移动到下一个句子</p><p>{ 移动到上一个段落</p><p>} 移动到下一个段落</p><p>句子的定义时一个字符串，以句号，逗号，问号和感叹号结尾，并且后面要接一个新行字符或者两个空格</p><p>H 移动到屏幕的顶部（是当前屏幕，不是整个文章）</p><p>M 移动到屏幕的中间</p><p>L 移动到屏幕的底部</p><p>为了增强命令的功能，可以在命令之前输入数字确定重复次数。例如：10w代表跳过十个单词。不需要输enter。</p><h4 id="整屏移动"><a href="#整屏移动" class="headerlink" title="整屏移动"></a>整屏移动</h4><p>^f(ctrl+f,forward) 移动到下一屏</p><p>^B(backward) 移动到上一屏</p><p>^d 下移半屏，^u 上移半屏</p><p>这里^d和^u前面加数字与前面略有不同。前面只对该次有效，而这里是一直有效</p><h4 id="跳转到前一位置"><a href="#跳转到前一位置" class="headerlink" title="跳转到前一位置"></a>跳转到前一位置</h4><p>可以使用两个反引号跳转到前一位置。这个前一位置并不简单指的是上一条指令的位置。如果你一直使用行跳转的话那么这条指令将会带你去没进行行跳转时的位置。其实相当于保存了两个地址，你可以在两个地址之间跳转进行修改，第一个地址就是每跳转之前的地址。第二个地址就是跳转之后的地址。如果你现在位于第二个地址上，那么进行跳转只会改变第二个地址。用了反引号后直接回到第一个地址，然后如果再在第一个地址上跳转，那么只会修改第一个地址。</p><p>第二个跳转地址是在你第一次使用移动命令后产生的，也可以看为开始第一个地址和第二个地址再同一位置。之后一直都是在对第二地址进行修改。</p><p>如果使用两个单引号，那么将会回到对应地址的开头。</p><p>此外，我们还可以通过设置标识来新增跳转地址。先键入m，再输入标识符，之后就可以直接跳转到有标识符的位置。标识符是不可见字符，所以最好自己先记好。</p><p>例如： ma设置a标识符。 `a回到a的位置</p><h3 id="搜索模式"><a href="#搜索模式" class="headerlink" title="搜索模式"></a>搜索模式</h3><p>符号： / ?</p><p>/ 向下面搜索，/+字符表示要搜索哪个字符。如果还想继续搜索该字符只需要输入/然后回车就会搜索下一个</p><p>？ 用法相同，向上搜索</p><p>或者按n继续向下搜索，N继续向上搜索</p><p>此外，还可以使用正则表达式中的锚</p><h3 id="使用行号和切换模式"><a href="#使用行号和切换模式" class="headerlink" title="使用行号和切换模式"></a>使用行号和切换模式</h3><p>可以通过 :set number 设置显示行号</p><p>如果行号关闭，可以通过 ^G键查看现在在文本中的哪个位置</p><p>可以通过 数字+G（大写）跳转到任意一行</p><p>此外，还可以通过 :+数字跳转到任意一行，其中 :$ 跳转到文本末尾</p><p>前文已经说了vi有两种模式，一种是编辑模式，一种是命令模式，从编辑模式切换成命令模式只有一种方法，按esc键。但是从命令模式转换到编辑模式有十二种之多</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">i</span> <span class="string">在当前光标之前插入字符</span></span><br><span class="line"><span class="attr">a</span> <span class="string">在光标之后插入字符</span></span><br><span class="line"><span class="attr">I</span> <span class="string">在当前行的开头插入字符</span></span><br><span class="line"><span class="attr">A</span> <span class="string">在当前行的末尾插入字符</span></span><br><span class="line"><span class="attr">o</span> <span class="string">在当前行下面插入一行</span></span><br><span class="line"><span class="attr">O</span> <span class="string">在当前行上面插入一行</span></span><br></pre></td></tr></table></figure></div><h3 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h3><p>如果只需要修改一个字符的话，那么可以在命令模式下输入r+字符就可以修改光标后面的字符（注意不是增加而是直接把光标后面的字符变成输入的字符）</p><p>如果想要修改很多字符，可以输入R，这时会切换到输入模式。随后键入的每个字符都会替换当前字符。</p><p>如果想要修改的字符数与原来并不相同，那么可以使用s（substitute)命令把一个字符变成许多个字符。如果输入了s，那么将回到输入模式，且此时光标后面的后面的字符将会变成$，然后再输入字符，$就会变成对应的字符</p><p>例如 m|a,输入s后变成 m|$，然后输入other，就会变成 mother</p><p>此外C命令是将光标后面的字符都替换，如果输入了这个命令，那么在该行的最后将会出现$</p><p>cc命令可以替换一整行，无论光标在哪里</p><p>c+移动光标命令，这将替换从光标处到移动后的光标处所有的字符，可以有重复次数</p><h3 id="替换文本"><a href="#替换文本" class="headerlink" title="替换文本"></a>替换文本</h3><p>这里我们主要谈论的是ex命令。这些命令都以 ： 为开始。</p><p>替换语法： :s/pattern/replace/</p><p>这条命令的含义是替换第一个pattern，如果后面加上g（global），那么将替换所有pattern。</p><p>如果希望改变之前先请求同意，可以在后面加上 c（confirm）。也可以同时使用gc</p><p>如果想要删除某些pattern，只需要 :s/pattern//g即可</p><p>在s前面加上数字表示替换某些行。例如： :57s/unix/linux 表示把第57行第一次出现的unix变成linux。</p><p>如果想从当前行到末尾，那么可以使用 : . , $s/pattern/replace/</p><p>其中 .(点）表示当前行，$表示最后一行，中间用逗号分割开来。</p><h3 id="删除字符"><a href="#删除字符" class="headerlink" title="删除字符"></a>删除字符</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">x</span> 删除右边的字符</span><br><span class="line"><span class="selector-tag">X</span> 删除左边的字符</span><br><span class="line"><span class="selector-tag">D</span> 删除当前光标到本行末尾的字符</span><br><span class="line"><span class="selector-tag">d</span>+移动指令 删除从当前光标到移动指令后的字符</span><br><span class="line"><span class="selector-tag">dd</span> 删除当前行</span><br><span class="line"><span class="selector-tag">ex</span> 命令</span><br><span class="line"><span class="selector-pseudo">:lined</span> 删除指定行</span><br><span class="line"><span class="selector-pseudo">:line</span>,<span class="selector-tag">lined</span> 删除多个行</span><br></pre></td></tr></table></figure></div><p>如果要删除所有行，一种是 :1,$d，另一种是:%d，%指的是所有行</p><h3 id="撤销或重复改变"><a href="#撤销或重复改变" class="headerlink" title="撤销或重复改变"></a>撤销或重复改变</h3><p>撤销就是如果命令输入错误，可以使用命令撤销</p><p>u 撤销上一命令对缓冲区进行的修改</p><p>U 恢复当前行</p><p>. 重复上一命令对编辑缓冲区进行的修改</p><p>其中 U 指的是将撤销至移动到当前行的那一刻起，对当前行所进行的所有改变</p><p>.命令可以用来重复，但是如果使用了撤销，那么它将会使用撤销所恢复的命令</p><h4 id="恢复删除"><a href="#恢复删除" class="headerlink" title="恢复删除"></a>恢复删除</h4><p>每当删除<strong>一行或者多行</strong>文本时，vi都将文本储存在一个缓冲区中，这个缓冲区称为编号缓冲区。vi有9个缓冲区。在任何时候，都可以将一个编号缓冲区中的内容插入到编辑缓冲区中。这样做时，需要键入一个双引号（“），后面跟着缓冲区的编号，再后面跟着一个p（put)命令，p是在当前行下面插入，P是在当前行上面插入。</p><p>如果你忘记是哪个编号缓冲区的话，可以先撤销一次，然后使用.号重复插入，这时vi将自动把缓冲区编号加1</p><h3 id="移动文本"><a href="#移动文本" class="headerlink" title="移动文本"></a>移动文本</h3><p>vi总是在一个称为无名缓冲区的地方为上一次删除保存一个副本。与编号缓冲区不同，编号缓冲区只会保存删除的多行，删除少数字符是不会被保存的。</p><p>p 命令用来把无名缓冲区的内容插入到当前位置之后</p><p>考虑组合命令xp，x是删除当前光标处的字符。p是把字符插入光标的右边。这样相当于把两个自住房换了一下顺序。</p><p>另一个重要的组合命令是deep，这个命令是将两个单词换序</p><p>ddp 调换两行，因为dd是删除一行，删除这行后光标在原本该行的下一行，然后p是插入到这一行的后一行，相当于两行换了位置。</p><h3 id="复制文本"><a href="#复制文本" class="headerlink" title="复制文本"></a>复制文本</h3><p>复制文本分为三步：</p><ol><li>使用y，yy或Y命令将文本有编辑缓冲区复制到无名缓冲区中，但不删除原始文本。</li><li>将光标移动到希望插入文本的位置。</li><li>使用p或P命令命令执行插入</li></ol><p>在不删除文本的情况下将文本复制到无名缓冲区，叫做接出（yank)，因此将命令命名为y，yy，Y。y，yy命令和d命令执行情况相同，</p><h3 id="改变字母大小写"><a href="#改变字母大小写" class="headerlink" title="改变字母大小写"></a>改变字母大小写</h3><p>符号： ~</p><p>该命令会改变vi当前字母的大小写，然后将光标向前移动一个字符。改变大小写的意思是把大写变成小写，小写变成大写。</p><p>有些版本的vi使用这个命令不会超过一行，just like me。</p><h3 id="设置选项"><a href="#设置选项" class="headerlink" title="设置选项"></a>设置选项</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> showmode 输入模式提醒</span><br><span class="line">:<span class="builtin-name">set</span> number 显示行号</span><br><span class="line">:<span class="builtin-name">set</span> nonumber 不显示行号</span><br><span class="line">:<span class="builtin-name">set</span> tabstop = number 设置制表符间距</span><br><span class="line">:<span class="builtin-name">set</span> autoindent 缩进以匹配上一行/下一行</span><br><span class="line">:<span class="builtin-name">set</span> autowrite 如果文本已修改，则在切换文件前保存</span><br><span class="line">:<span class="builtin-name">set</span> errorbells 显示错误信息时发出声音</span><br><span class="line">:<span class="builtin-name">set</span> list 将制表符显示成^I,将行的结束显示成$</span><br><span class="line">:<span class="builtin-name">set</span> showmatch 显示匹配的 () &#123;&#125; []</span><br><span class="line">:<span class="builtin-name">set</span> wrapscan 环绕文本进行搜索</span><br><span class="line">:<span class="builtin-name">set</span> lines 设置文本行数</span><br><span class="line">:<span class="builtin-name">set</span> wrapmargin = n 在键入过程中自动换行，n是离右边缘的位置，例如<span class="attribute">n</span>=6意味着在例右边缘6个字符的地方换行，为0关闭自动换行</span><br></pre></td></tr></table></figure></div><p>如果想查看当前选项是在什么状态，可以使用:set 选项？</p><p>如果显示所有选项的值，可以使用 :set all</p><h3 id="复制移动行"><a href="#复制移动行" class="headerlink" title="复制移动行"></a>复制移动行</h3><p>如果想指定行号进行移动，可以使用ex命令中的 :co(copy) :m(move)</p><p>:5co10,复制第5行，并将其放在第10行的下面</p><p>:4,8co20 复制4到8行，并将其放在20行的下面</p><h3 id="输入shell命令"><a href="#输入shell命令" class="headerlink" title="输入shell命令"></a>输入shell命令</h3><p>可以通过 :!+命令的方式，在不退出vi的情况下进行shell命令</p><p>:!! 重复上一条shell命令</p><p>如果现在缓冲区中直接插入shell命令的输出，可以使用 :r !</p><p>例如 :1r !date，就是将date输出插入第一行的后面</p><p>如果直接用感叹号，那么就会将文件中的数据交给shell命令进行操作，然后再将操作后的文件复制到原位置</p><p>例如： 5!!sort ，这个命令将会从当前开始把接下来5行排序。</p><p>!}sort 这个命令是将接下来一段排序。</p><h3 id="将文件中的数据插入编辑缓冲区中"><a href="#将文件中的数据插入编辑缓冲区中" class="headerlink" title="将文件中的数据插入编辑缓冲区中"></a>将文件中的数据插入编辑缓冲区中</h3><p>语法： :[line]r file</p><p>line 是行号 file是文件名</p><p>:r命令读取文件中的内容，然后将其插入指定行的后面</p><h3 id="不退出vi的情况下进行保存"><a href="#不退出vi的情况下进行保存" class="headerlink" title="不退出vi的情况下进行保存"></a>不退出vi的情况下进行保存</h3><p>:w 将数据写入原有文件<br>:w file 将数据写入一个新文件中<br>:w! file 覆盖原有文件<br>:w&gt;&gt; file 将数据追加到一个新文件中<br>:10w! save 将特定行保存到文件中<br>:wq 保存退出vi 和 ZZ有同样的效果</p><h3 id="切换到一个新文件"><a href="#切换到一个新文件" class="headerlink" title="切换到一个新文件"></a>切换到一个新文件</h3><p>:e + 文件名</p><p>当编辑一个新文件时，原有缓冲区内容会消失，所以首先要使用 :w保存.当使用:e时，系统会自动检查是否保存，如果没有保存，不允许切换到新文件。如果希望忽略这种保护，可以使用:e!命令</p><h3 id="使用缩写"><a href="#使用缩写" class="headerlink" title="使用缩写"></a>使用缩写</h3><p>:ab [short long]</p><p>short是缩写，long是缩写的原文。如果确定了缩写，那么在编辑模式下，如果拼写了缩写，系统会自动变成全称。当然，只有在这个缩写是一个单词（两边有空格）的情况下才会变全称。</p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>:map命令可以创建命令模式下的缩写，实际上，这就可以自己创建命令。这些命令叫做宏</p><p>语法： :map [x commands]</p><p>x是一个字符，commands是vi或ex命令序列</p><p>例如 :map K deep就是将两个单词换位的命令设置成一个宏</p><h3 id="初始化文件"><a href="#初始化文件" class="headerlink" title="初始化文件"></a>初始化文件</h3><p>对于vim来说，初始化文件是.vimrc,</p><p>如果想删除一个缩写，可以使用 :una short</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>汇编 函数</title>
    <url>/post/30479.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>进入函数在汇编中其实就是callq，出函数就是retq。</p><p>而callq和retq的功能之前已经提到过</p><h3 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h3><p>在x86-64位系统中，有六个寄存器负责传入参数，分别是rdi，rsi，rdx，rcx,r8,r9，同时程序返回时返回值放在rax中。如果大于6个，多的部分就要放在栈上。如果我们想操作在栈上的参数，就要通过 x(%rsp)来操作了。</p><p>例如有7个参数，此时第7个参数就放在栈上那么 8(%rsp)就可以访问这个参数了，pushq操作分为两部分，首先是rsp-8，然后把数据放进去。这个时候其实数据就是在rsp-rsp+8的区域中，也就是说我们直接movq (%rsp)…就可以访问到我们刚才放进去的元素了</p><p>我们这里不采用(%rsp)的原因是因为调用函数是callq，在最后应该是把rip放到栈中，所以要加8到下一个元素。</p><p>如果有8个参数，那么栈中要先存第8个，然后再存第7个。</p><h3 id="栈上的局部储存"><a href="#栈上的局部储存" class="headerlink" title="栈上的局部储存"></a>栈上的局部储存</h3><p>由于现代编译器的不断优化和寄存器的增多，我们一般不把局部变量放到栈中，但是有的时候我们不得不把他们放到栈中。</p><ol><li>寄存器不足时</li><li>某一变量用了&amp;（取地址），因此这个时候不得不把它放到栈中，这样才有一个地址</li><li>当局部变量是数组或结构体时</li></ol><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PERL"><figure class="iseeu highlight /perl"><table><tr><td class="code"><pre><span class="line">long <span class="keyword">caller</span>()</span><br><span class="line">&#123;</span><br><span class="line">    long <span class="keyword">x</span> = <span class="number">534</span>;</span><br><span class="line">    long <span class="keyword">y</span> = <span class="number">1057</span>;</span><br><span class="line">    long sum = swap_add(&amp;<span class="keyword">x</span>, &amp;<span class="keyword">y</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">汇编代码为：</span><br><span class="line"><span class="keyword">caller</span>:</span><br><span class="line">  subq $16, %rsp</span><br><span class="line">  movq $534, (%rsp)</span><br><span class="line">  movq $1057, <span class="number">8</span>(%rsp)</span><br><span class="line">  leaq <span class="number">8</span>(%rsp), %rsi</span><br><span class="line">  movq %rsp, %rdi</span><br><span class="line">  callq swap_add</span><br><span class="line">  ...</span><br><span class="line">  addq $16,%rsp</span><br></pre></td></tr></table></figure></div><p>汇编中第一行代码为rsp-16，这是为局部变量分配内存空间。534存在最近的一个，1057存在较远的一个，这与前面多个参数存储符合。</p><p>注意在这个函数结束时，分配的栈空间也要清除，也就是最后的addq</p><p>例2：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="code"><pre><span class="line">long call_proc()</span><br><span class="line">&#123;</span><br><span class="line">    long <span class="keyword">x</span><span class="number">1</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="comment">    int x2 = 2;</span></span><br><span class="line"><span class="comment">    short x3 = 3;</span></span><br><span class="line"><span class="comment">    char x4 = 4;</span></span><br><span class="line"><span class="comment">    proc(x1,&amp;x1,x2,&amp;x2,x3,&amp;x3,x4,&amp;x4);</span></span><br><span class="line"><span class="comment">    return x1-x2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">汇编：</span></span><br><span class="line"><span class="comment">call_proc:</span></span><br><span class="line"><span class="comment">  subq $32,%rsp</span></span><br><span class="line"><span class="comment">  movq $1, 24(%rsp)</span></span><br><span class="line"><span class="comment">  movq $2, 20(%rsp)</span></span><br><span class="line"><span class="comment">  movq $3, 18(%rsp)</span></span><br><span class="line"><span class="comment">  movq $4, 17(%rsp)</span></span><br><span class="line"><span class="comment">  leaq 17(%rsp), %rax</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  movq %rax, 8(%rsp)</span></span><br><span class="line"><span class="comment">  movl $4, (%rsp)</span></span><br><span class="line"><span class="comment">  leaq 18(%rsp), %r9</span></span><br><span class="line"><span class="comment">  movl $3, %r8d</span></span><br><span class="line"><span class="comment">  leaq 20(%rsp), %rcx</span></span><br><span class="line"><span class="comment">  movl $2,%edx</span></span><br><span class="line"><span class="comment">  leaq 24(%rsp), %rsi</span></span><br><span class="line"><span class="comment">  movl $1, %edi</span></span><br><span class="line"><span class="comment">  call proc</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">  add $32,%rsp</span></span><br></pre></td></tr></table></figure></div><p>注意空行前面是存储地址，因为后面函数的参数中有使用。空行后面就是把8个参数赋值。可能这里会有疑问就是这里把参数都赋了值，那么函数返回到原函数时那些参数值不都变了吗？</p><p>按照惯例，寄存器 %rbx，%rbp 和 %r12到%15被划分成被调用者保存寄存器，也就是说，这些寄存器在被调用的函数中都会保存好，因此我们可以把参数存在这些寄存器中，然后需要的时候又从这些寄存器中取出来，这样就保证了参数值不会被改变。其他寄存器[1]<br>。叫做调用者保存寄存器，这些寄存器由调用者自己去保护，例如rdi，rsi等，被调用者并不会保护这些寄存器，也就是说传入参数时，要先把这些寄存器压入栈中，以防止被改变<br>[1]:rsp除外</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PERL"><figure class="iseeu highlight /perl"><table><tr><td class="code"><pre><span class="line">long p(long <span class="keyword">x</span>, long <span class="keyword">y</span>)</span><br><span class="line">&#123;</span><br><span class="line">    long u = <span class="string">q(y)</span>;</span><br><span class="line">    long v = <span class="string">q(x)</span>;</span><br><span class="line">    <span class="keyword">return</span> u+v;</span><br><span class="line">&#125;</span><br><span class="line">汇编：</span><br><span class="line">p:</span><br><span class="line">  pushq %rbp</span><br><span class="line">  pushq %rbx</span><br><span class="line">  subq $8,%rsp</span><br><span class="line">  movq %rdi, %rbp</span><br><span class="line">  movq %rsi, %rdi</span><br><span class="line">  call <span class="keyword">q</span></span><br><span class="line">  movq %rax, %rbx//保存得到的函数值</span><br><span class="line">  movq %rbp, %rdi</span><br><span class="line">  calll <span class="keyword">q</span></span><br><span class="line">  addq %rbx, %rax</span><br><span class="line">  addq $8, %rsp</span><br><span class="line">  popq %rbx</span><br><span class="line">  popq %rbp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure></div><p>这段代码开始把rbp和rbx拉进栈，是因为后面要改变rbx和rbp，而p本身也是一个函数，要保证被调用者保存寄存器不会被改变，之后在q函数传递参数前先把p的参数保存到rbp和rbx中，这样就保证了参数在函数中不会被破坏。之后传递参数时也可以直接从rbp中传入，</p><h3 id="栈中的内容"><a href="#栈中的内容" class="headerlink" title="栈中的内容"></a>栈中的内容</h3><p>从上面我们可以看到，栈中的内容可能会有寄存器，局部变量，下一个函数所需要的参数等。</p><p>有三类函数，一种是只有调用者的身份，一种是既有调用者又有被调用者的身份，第三种是只有被调用者的身份。</p><p>对于第一种。首先保存参数，之后保存调用者保存寄存器和局部变量，然后保存返回地址。</p><p>对于第二种，同样首先保存参数，之后保存局部变量，但是这里还可能要保存被调用者保存寄存器。同样保存返回地址</p><p>对于第三种，其他大致相同，但是不需要保存被调用者保存寄存器了。</p><p>对于函数的大致过程，首先传入参数，然后运用call进入函数。然后里面可能有一些局部变量需要保存或者寄存器需要保存，这时我们需要分配一个栈帧。之后如果进入函数，首先我们要传递参数（如果进入多个函数且这些函数运动了调用者函数的参数那此时先要把调用者参数放到被调用者保存寄存器中，防止调用者的参数被破坏）。然后call进入函数，被调用者函数返回前先要把被调用者保存寄存器中的内容弹出，和把栈帧释放。之后在调用者函数返回之前要先把调用者保存寄存器弹出，最后返回。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
        <category>AT&amp;T</category>
      </categories>
  </entry>
  <entry>
    <title>压缩矩阵</title>
    <url>/post/56929.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>对于特殊的矩阵，例如上下三角矩阵，对称矩阵，三对角矩阵，可以转化成1维矩阵，减小空间的消耗。</p><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>对称矩阵有 aij=aji的特性，因此可以只保存一边，也就是压缩成 <code>n(n+1)/2</code>个</p><p>如果我们用一个一维数组s[n(n+1)/2]来保存，那么它域原矩阵的对应关系</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="code"><pre><span class="line">k= <span class="built_in">i</span>(<span class="built_in">i</span><span class="number">-1</span>)/<span class="number">2</span>+<span class="built_in">j</span><span class="number">-1</span> <span class="built_in">i</span>&gt;=<span class="built_in">j</span></span><br><span class="line">    <span class="built_in">j</span>(<span class="built_in">j</span><span class="number">-1</span>)/<span class="number">2</span>+<span class="built_in">i</span><span class="number">-1</span>  <span class="built_in">i</span>&lt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure></div><p>这个式子先只考虑一边，先看i&gt;=j的情况。此时第一行中压缩矩阵只保存一个值，第二行两个值，依此类推。所以对于第i行先把前i-1行中对应压缩矩阵的值的数量加起来，也就死i(i-1)/2，之后再加上第j行的第j-1个（这里因为数组下标是从0开始）。</p><p>这个例子中的行数是从第一行开始，实际上应该从第0行开始，所以</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="code"><pre><span class="line">k= <span class="built_in">i</span>(<span class="built_in">i</span>+<span class="number">1</span>)/<span class="number">2</span>+<span class="built_in">j</span> <span class="built_in">i</span>&gt;=<span class="built_in">j</span></span><br><span class="line">  <span class="built_in">j</span>(<span class="built_in">j</span>+<span class="number">1</span>)/<span class="number">2</span>+<span class="built_in">i</span> <span class="built_in">i</span>&lt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure></div><p>举个例子，第0行第0个在k中对应位置就是0</p><h4 id="上下三角矩阵"><a href="#上下三角矩阵" class="headerlink" title="上下三角矩阵"></a>上下三角矩阵</h4><p>对称矩阵行数和列数相同</p><p>上三角矩阵其实就是对称矩阵中 i&gt;=j的那一段</p><p>下三角矩阵中第一行的压缩矩阵元素数量是n,第二行是n-1,以此类推，我们也可以得到相应的关系式</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="code"><pre><span class="line">k=（<span class="number">2</span>*n-<span class="built_in">i</span><span class="number">-1</span>)*<span class="built_in">i</span>/<span class="number">2</span>+<span class="built_in">j</span> <span class="built_in">i</span>&lt;=<span class="built_in">j</span></span><br><span class="line">  (<span class="number">2</span>*n-<span class="built_in">j</span><span class="number">-1</span>)*<span class="built_in">j</span>/<span class="number">2</span>+<span class="built_in">i</span> <span class="built_in">i</span>&gt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure></div><h4 id="三对角矩阵"><a href="#三对角矩阵" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h4><p>除了第一行和最后一行有两个元素之外，其他行都有三个元素</p><p>对于<code>a[i][j]</code>来说，前面有 3*i-1个元素，本行它前面有j-i+1个位置。所以k=2 * i+j</p><p>反之，如果在压缩矩阵中是第k个位置，那么在原矩阵中 i=(k+1)/3 j=k-2*i</p><h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p>对于非零元素较少的矩阵，可以直接用一个结构体保存 i,j ,sum，然后再用一个结构体数组来保存所有的值。这个数组是从左至右扫描遍历的。一般稀疏矩阵中元素只占5%</p><h5 id="稀疏矩阵转置的算法"><a href="#稀疏矩阵转置的算法" class="headerlink" title="稀疏矩阵转置的算法"></a>稀疏矩阵转置的算法</h5><p>首先，如果用朴素的算法，就是从第零行开始遍历每一列，然后把列变成行。</p><p>如果我们用两个数组分别保存 每一列中元素的数量以及每一列在新的稀疏矩阵中的位置，就有办法可以加快速度</p><p>例如：<img src="/images/%E6%8D%95%E8%8E%B71.PNG" alt></p><p><img src="/images/%E6%8D%95%E8%8E%B7.PNG" alt></p><p>cpot 第一个位置是一是因为数组下标从1开始</p><p>for循环中注意q=cpot[col]，代表现在这个位置已经有东西了，所以再最后++cpot[col]代表现在这一列在新稀疏矩阵的首位置要后移一位。</p><p>其次，因为转置前行号已经是从小到大排了，所以行号小的一定在前面。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>union</title>
    <url>/post/9197.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>首先看一下结构体，c语言中的结构体占用字节数是所有类型字节数的总和。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>用sizeof测试一下结果是8，但是如果用union呢？会发现结果是4</p><p>union中的参数共用同一块内存空间，它们在内存中起始地址都相同，也就是说同一时间内联合体中其实只会有一个参数存在，当另一个参数被赋值时，此时内存中存的就是另一个参数的值，而前面的参数会被覆盖</p><p>但是size并不一定是根据最长的那个长度来决定的（实测不是，但是不懂），还要考虑内存对齐的问题</p><p>如果此时已经给某一变量赋上了值，再用另外一个变量输出，那么内存中的编码并不会改变，只是会按找相应类型的编码方式进行编码然后输出。</p><ul><li>在c++中的使用</li></ul><p>大致相同，但是union中不能有类，如果我们在再类CA中添加了构造函数，或者添加析构函数，我们就会发现程序就会出现错误。由于union里面的东西共享内存，所以不能定义静态、引用类型的变量。由于在union里也不允许存放带有构造函数、析构函数和复制构造函数等的类的对象，但是可以存放对应的类对象指针</p><ul><li>应用 类型转换</li></ul><p>因为union共用一片地址，所以我可以通过不同的定义去访问这片地址。例如一个double类型的数据，我可以用int型访问低四字节和高四字节，并且不改变位级别的数据，这就相当于类型转换</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>广义表</title>
    <url>/post/14379.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>广义表一般记作：LS=（a1,a2,…)</p><p>其中ai在线性表中只可以是单个元素，而在广义表中即可以是单个元素，也可以是广义表。如果是单个元素，叫做原子，如果是广义表，叫做子表。当广义表非空时，第一个元素叫做广义表的表头，其余所有元素叫做广义表的表尾。</p><p>例如： A（），空表</p><p>B（e) 只有一个原子元素e,长度为1</p><p>c（a,(b,c,d)) 长度是2</p><p>d( a ( d)) 递归表</p><ul><li>广义表的储存结构</li></ul><p>通常用链式存储结构</p><p>每个节点有tag域（标志域），hp，tp三个域，但是原子节点（就是表头节点）只有两个域，标志域和值域</p><p>定义：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRYSTAL"><figure class="iseeu highlight /crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">glnnode</span></span></span><br><span class="line">&#123;</span><br><span class="line">    int tag;<span class="regexp">//</span>表示是原子节点还是表结点</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        int atom;<span class="regexp">//</span>原子节点值域</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ptr</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            glnnode *hp,*tp;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>除了空表表头指针为空外，其他表表头指针必定指向一个表节点</p><p>同一层次的表可以从第一个节点通过尾节点依次往后数，而头结点则指向一个原子节点或者是一个子表。</p><p>例如，画出c表的表示</p><p>| | | 代表tag， 头结点，尾结点</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GHERKIN"><figure class="iseeu highlight /gherkin"><table><tr><td class="code"><pre><span class="line">c-&gt; 1|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> -&gt; 1</span>|<span class="string"> </span>|<span class="string"> NULL</span></span><br><span class="line"><span class="string">    </span>|<span class="string">      </span>|<span class="string">  </span></span><br><span class="line"><span class="string">    -&gt;0</span>|<span class="string">a</span>|<span class="string">   -&gt;1</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt;1</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt;1</span>|<span class="string"> </span>|NULL</span><br><span class="line">             |<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">             -&gt;0|<span class="string">b</span>|<span class="string">  -&gt;0</span>|<span class="string">c</span>|<span class="string">  -&gt;0</span>|<span class="string">c</span>|</span><br></pre></td></tr></table></figure></div><p>这个代表的是 c=（a,(b,c,d))，可以看到，第一层节点的数目就是表的长度，第一层如果头结点接一个原子节点，那么在表中代表一个数，如果接一个表节点，代表一个子表，同理，第二层头节点如果是一个数，那么就代表第二层增加一个元素，如果头结点接一个表节点，那么说明还有一个子表</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>汇编指令 AT&amp;T版 64位</title>
    <url>/post/1326.html</url>
    <content><![CDATA[<!-- build time:Tue Apr 14 2020 08:56:07 GMT+0800 (中国标准时间) --><p>用g++ -Og -S -masm=intel name.c 可以生成intel格式的汇编代码，-S是生成汇编代码，-Og是省去不重要的部分，如果不加这个，可能5条指令要变成十多条指令</p><p>-fno-if-conversion 分支语句不要采用条件传输的方式，条件跳转的方式</p><p>-g debug</p><p>objdump -d 反汇编</p><p>gdb 调试 b+ 标号 设置断点 info register 查看寄存器 r 执行到断点出</p><p>n（next） 执行下一条命令</p><h4 id="mov-移动指令"><a href="#mov-移动指令" class="headerlink" title="mov 移动指令"></a>mov 移动指令</h4><p>格式： movq a,b</p><p>a是原操作数，b是目标操作数</p><p>这个指令中的q代表的是64位</p><table><thead><tr><th>长度</th><th>类型</th><th>别名</th><th>缩写</th></tr></thead><tbody><tr><td>1</td><td>char</td><td>byte</td><td>b</td></tr><tr><td>2</td><td>short</td><td>word</td><td>w</td></tr><tr><td>4</td><td>int</td><td>double word（long word）</td><td>l</td></tr><tr><td>8</td><td>long</td><td>quad word</td><td>q</td></tr><tr><td>8</td><td>char*</td><td>quad word</td><td>q</td></tr><tr><td>4</td><td>float</td><td>…</td><td>s</td></tr><tr><td>8</td><td>double</td><td>…</td><td>l</td></tr></tbody></table><table><thead><tr><th>源操作数</th><th>目标操作数</th></tr></thead><tbody><tr><td>立即数（idata)</td><td>寄存器 ，地址</td></tr><tr><td>寄存器</td><td>寄存器，地址</td></tr><tr><td>地址</td><td>寄存器</td></tr></tbody></table><table><thead><tr><th>操作数</th><th>符号</th></tr></thead><tbody><tr><td>立即数</td><td>$</td></tr><tr><td>寄存器</td><td>%</td></tr><tr><td>地址</td><td>（）</td></tr><tr><td>地址中数据</td><td>不加任何符号</td></tr></tbody></table><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PERL"><figure class="iseeu highlight /perl"><table><tr><td class="code"><pre><span class="line">movq $2,%rax</span><br><span class="line">movq %rax,%rbx</span><br><span class="line">mov<span class="string">q (%rax)</span>,%rbx</span><br></pre></td></tr></table></figure></div><p>注意；</p><ul><li>当源操作数为地址的时候，目标操作数不能也是地址，因为一定要通过cpu进行调控，从地址到地址代表没有经过cpu（解释是这样，但我觉得不太合理）</li><li>立即数不能为8字节，使用 movabsq 可以让立即数为8字节</li><li>地址都是8字节，也就是上面的char*</li><li>如果把一个32位数给64位寄存器，那么高三十二位自动变成0.但是如果是16位或者8位的话高位不会改变</li></ul><p>例如：</p><p>movabsq $0x0011223344556677,%rax</p><p>movq $-1,%rax</p><p>%rax= 00000000ffffffff</p><h5 id="地址的写法"><a href="#地址的写法" class="headerlink" title="地址的写法"></a>地址的写法</h5><p>地址可以写为一个四元组 A（寄存器1，寄存器2，B）</p><p>这个四元组其实是 寄存器1+B*寄存器2+A</p><p>其中B可以是1,2,4,8。从数组的角度来看，寄存器1相当于起始地址，寄存器2相当于偏移地址，B是一个数据的字节数</p><p>同时 64位寄存器前缀是r，三十二位前缀是e，16位没有前缀，8位后面是l和h</p><p>例：</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rax</span></span><br><span class="line"><span class="built_in">eax</span></span><br><span class="line"><span class="built_in">ax</span></span><br><span class="line"><span class="built_in">al</span></span><br><span class="line"><span class="number">ah</span></span><br></pre></td></tr></table></figure><h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>格式 movzab</p><p>a代表原格式，b代表现格式，一般是从小的转换成大的。而z代表多的位补0</p><p>例： movzlq</p><p>特殊形式： cltq 把32位寄存器扩展到64位并且赋值给自己，</p><p>movsab 有符号扩展，最高位为1那么扩展出来的位全是1。</p><h4 id="leaq-地址转移"><a href="#leaq-地址转移" class="headerlink" title="leaq 地址转移"></a>leaq 地址转移</h4><p>格式 leaq 地址，寄存器</p><p>看起来与mov没什么区别，但是mov中的地址是要取地址中的数，而这里的地址只是把对应地址给寄存器</p><p>例如： leaq (%rax,%rbx,4),%rdx 这条指令类似于把数组中某一元素的地址给了rdx</p><p>它还可用来求值</p><p>例如 要求x* 12</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PERL"><figure class="iseeu highlight /perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mul(<span class="keyword">int</span> <span class="keyword">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">   lea<span class="string">q (%rdi,%rdi,2)</span>,%rax</span><br><span class="line">   salq %rax,<span class="number">2</span>//左移指令</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">x</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码只要看中间两条指令就可以了，leaq 中的数运算之后是3rdi，然后左移两位就是12了。</p><p>但是这条指令不会判断溢出，且不会改变标志寄存器</p><h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><p>这里涉及到标志寄存器，<a href="https://xinhecuican.github.io/2020/01/29/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/">在前面一篇博客中已经提到</a></p><p>cmpq 比较指令</p><p>textq 与比较</p><p>textq b a 把a与b相与，不改变a和b的值，只会改变标志寄存器中的zf和sf。</p><p>这个指令通常用来判断某一位是否是1，例如 textq a,0x1 ，如果最低位为1，那么zf就是0，说明最低位是1</p><h5 id="标志寄存器的访问"><a href="#标志寄存器的访问" class="headerlink" title="标志寄存器的访问"></a>标志寄存器的访问</h5><table><thead><tr><th>操作名</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>sete</td><td>ZF</td><td>Equal</td></tr><tr><td>setne</td><td>~ZF</td><td>not equal</td></tr><tr><td>sets</td><td>SF</td><td>sign</td></tr><tr><td>setns</td><td>~SF</td><td></td></tr><tr><td>setg</td><td><del>(SF^OF)&amp;</del>ZF</td><td>greater 有符号数</td></tr><tr><td>setge</td><td>~(SF^OF)</td><td>大于等于</td></tr><tr><td>setl</td><td>(SF^OF)</td><td>less</td></tr><tr><td>setle</td><td>…</td><td>小于等于</td></tr><tr><td>seta</td><td><del>CF&amp;</del>ZF</td><td>above 无符号数</td></tr><tr><td>setb</td><td>CF</td><td>below 小于</td></tr></tbody></table><p>这些指令都是返回到8位寄存器上，将高七位置0，最低位依据含义所进行的运算来判断是0还是1</p><p>之后可以 movzbl %al,%eax，这时高三十二位也会被清零</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p><a href="https://xinhecuican.github.io/2020/01/31/%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%8C%87%E4%BB%A4/">前面博客中也已谈到过</a></p><p>这里再补充jg和gb等，其实就是上面同样的模式</p><p>此外，由于是64位系统，没有cs寄存器，且intel使用cisc指令集，所以会自动根据指令长度进行判断用多少位长来储存位移</p><p>此外 x86 64位系统中 还提供了一种 jmp *(%rax) 也就是把rax作为地址，取内存中的内容</p><h4 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h4><p>格式： cmov +后缀 a b，后缀格式就是前面set的格式</p><p>作用: 如果满足条件，则把a赋值给b，如果不满足，则不做处理</p><p>现代编译器在遇到分支语句时会尽量用条件跳转的格式执行，因为cpu采用了流水线作业的模式（就是一次提前搬运多条指令） 但是条件跳转指令会使流水线停止运行，而流水线可以明显增加cpu速度。</p><p>条件跳转的格式就是先把 if 和else的内容都计算出来，然后在最后用条件跳转指令进行比较。</p><p>例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SAS"><figure class="iseeu highlight /sas"><table><tr><td class="code"><pre><span class="line">int a;</span><br><span class="line"><span class="meta">if</span>(<span class="meta">x</span>&gt;y)</span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="meta">x</span>-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">else</span></span><br><span class="line">&#123;</span><br><span class="line">    a=y-<span class="meta">x</span>;</span><br><span class="line">&#125;</span><br><span class="line">汇编模式</span><br><span class="line">movq <span class="name">%rdi</span>,<span class="name">%rax</span></span><br><span class="line">subq <span class="name">%rsi</span>,<span class="name">%rax</span></span><br><span class="line">movq <span class="name">%rsi</span>,<span class="name">%rdx</span></span><br><span class="line">subq <span class="name">%rdi</span>,<span class="name">%rdx</span></span><br><span class="line">cmovle <span class="name">%rdx</span>,<span class="name">%rax</span></span><br></pre></td></tr></table></figure></div><p>可以看出，用条件跳转模式会多计算一些指令，不会破坏流水线，如果在流水线上减少的时间大于多进行指令所消耗的时间，那么用条件跳转指令比较合适。反之，直接用条件指令。</p><p>下列几种情况不适合用条件跳转指令</p><ol><li>分支语句计算量大（执行时间过多，划不来）</li><li>在要判断是否可以运算的情况，例如 var=p ？*p ： 0，这条语句意思是如果p不为空指针那么将p的内容赋给var，否则赋0.但是如果用条件跳转会出错，因为空指针不能取值</li><li>计算可能产生副作用（即前后两个分支之间会产生影响）。例如 var=x&gt;0 ? x*=3 : x+=6,这个分支前面对后面会产生影响，因此不能简单粗暴的直接条件跳转</li></ol><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ul><li>do-while循环</li></ul><p>do-while循环用goto语句表达成</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ADA"><figure class="iseeu highlight /ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br></pre></td></tr></table></figure></div><p>这段代码便是先执行，后比较。很容易就可以转化成汇编。goto可以用条件转移指令代替。</p><ul><li>while循环</li></ul><p>while循环有两种形式，第一种是在最开始进行一次跳转，如果符合则进入循环，不符合则退出</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ADA"><figure class="iseeu highlight /ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!x) <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></div><p>第二种是先跳过第一次循环直接进行判断。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SUBUNIT"><figure class="iseeu highlight /subunit"><table><tr><td class="code"><pre><span class="line">goto test;</span><br><span class="line">loop:</span><br><span class="line">statement;</span><br><span class="line">test:</span><br><span class="line">if(x) goto loop;</span><br></pre></td></tr></table></figure></div><p>由于cpu流水线的限制，两条连续的跳转指令会减慢cpu运行的速度，因此最好采用第一种办法（虽然代码多）</p><ul><li>for循环</li></ul><p>for(init; test; update)</p><p>可以转化成</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="code"><pre><span class="line">init<span class="comment">;</span></span><br><span class="line">while(test)</span><br><span class="line">&#123;</span><br><span class="line">  statement<span class="comment">;</span></span><br><span class="line">  update<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>再然后就可以变成汇编代码</p><h4 id="switch-汇编实现"><a href="#switch-汇编实现" class="headerlink" title="switch 汇编实现"></a>switch 汇编实现</h4><p>首先要了解条件语句和switch的区别，if语句要从上倒下一条一条判断，如果数量多的话时间开销大。而switch是根据标号直接跳转，无论要跳转到哪一个时间开销都一定。</p><p>内存中实际上在编译时已经设定了一个跳转表，这个跳转表的标号是一个固定的地址，不能被改变，这个标号内的数据就是每一条指令的跳转地址，而且是8字节。</p><p>因此跳转语句可以这样写: jmp .L4(,%rdi,8)</p><p>其中.L4代表的是跳转表的标号（不一定是这个名字，举个例子）而rdi就是switch中的x，</p><p>如果标号很大，例如10000甚至1000000开始的时候，如果把前面的查找表一个个全部设置出来，空间开销会很大，所以编译器会先自动的减去一个数使他处于较小的范围，但是这种情况只适用于数据密集的情况。</p><p>如果数据稀疏例如一个是1一个是10000，这个时候偏移也不行了，只有通过先排序再二分搜索来查找标号，这个复杂度是logn</p><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul><li>inc 自增</li><li>dec 自减</li><li>neg 取负 -x</li><li>not 取非 ~x</li><li>imul 乘</li><li>xor 异或</li><li>or 或</li><li>and 与</li><li>sal shl 左移</li><li>sar 算数右移</li><li>shr 逻辑右移</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>AT&amp;T</tag>
      </tags>
  </entry>
  <entry>
    <title>在不更改注册表的情况下把程序移出c盘</title>
    <url>/post/44336.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>这里用的类似于快捷方式。用mklink命令，这个命令可以将两个文件夹连接，一个是真实存放内容的文件夹，另一个只有名称，实际内容并不放在哪里。所以我们可以创建一个这样的文件夹来骗过程序。例如 office</p><p>首先要用cmd而不能用powershell，这是系统自带命令.然后在其他盘建一个同名的文件夹。注意c盘的文件夹不要创建，执行命令后系统自动创建。</p><p><code>mklink /J &quot;C:\Program Files (x86)\Microsoft Files&quot; &quot;D:\Program Files (x86)\Microsoft Files&quot;</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>c语言的动态内存分配</title>
    <url>/post/8039.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>头文件： malloc.h</p><p>原型 void* malloc( size)（不标准写法）</p><p>其中size表示的是你想申请的字节数，为了准确我们一般使用sizeof函数，而返回的是一个void指针，这就导致了我们一般都要强制类型转换到对应的类型。</p><p>例： int* p=(int*)malloc(sizeof(int))</p><p>int* p=(int<em>)malloc(10</em>sizeof(int)) //数组</p><p>前面的int* 就是强制类型转换</p><p>此外，malloc一般分配完内存后还要进行检查看是否分配成功</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AWK"><figure class="iseeu highlight /awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p==NULL)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);<span class="regexp">//</span>退出程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>而且malloc是不会自动初始化的，所以在分配完内存后最好先用NULL初始化一下。</p><h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><p>字面意思，就是给一个已经分配内存的指针增加内存,原内存中的数据不变</p><p>头文件 #include &lt;stdlib.h&gt; 有些编译器需要#include &lt;alloc.h&gt;</p><p>原型： void* realloc(void *mem_address, unsigned int newsize);</p><p>mem_address是原指针，newsize是原有空间加上新增的空间</p><p>可能有下列几种情况</p><ol><li>如果原有空间后面还有足够的内存空间，那么直接在后面增加内存空间</li><li>如果原有空间不足，会重新分配空间到其他地方，同时原地址中的数据也会复制过去</li><li>如果没有可供分配的空间，返回NULL。此时，原指针仍然有效</li></ol><p>注意，如果分配成功，无论是否分到新空间，原指针都会被释放掉</p><p>如果 mem_address为0 那么和malloc相似，也是分配一块内存空间</p><p>如果 newsize为0，相当于free</p><p>也就是说，最好不要出现 p=realloc(p,size)这种写法，防止分配失败后指针直接丢失。好的办法是先用另一个参数接受realloc的内容，如果不为null，再让p=q</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* q;</span><br><span class="line">q=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(p,newsize);</span><br><span class="line"><span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>释放动态申请的内存空间</p><p>原型： void free(void* ptr)</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>程序的进入与退出</title>
    <url>/post/27890.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h3 id="程序进入"><a href="#程序进入" class="headerlink" title="程序进入"></a>程序进入</h3><p>在c++中，程序的入口是main函数，并且main函数有两个参数</p><p>int main(int argc,char* argv[])</p><p>argc是用来记录输入的参数的数量，而argv是用来记录输入的参数。</p><p>例如： ls -la，这个输入中有两个参数，第一个参数是ls，第二个参数是-la</p><h3 id="程序退出"><a href="#程序退出" class="headerlink" title="程序退出"></a>程序退出</h3><p>return 是退出当前函数，例如退出主函数或者退出任意函数</p><p>而 exit 是退出当前进程，也就是说就算是在调用的函数中，这个程序也会直接结束</p><p>exit(0)表示正常退出，exit(1)表示异常退出，更深入的内容涉及到进程。</p><p>exit函数在stdlib.h头文件中</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>过滤器</title>
    <url>/post/3257.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中），但是在最前面的和在最后面的不一定是过滤器。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="cat-复制"><a href="#cat-复制" class="headerlink" title="cat 复制"></a>cat 复制</h4><p>cat的用途就是把标准输入中的数据复制到标准输出中</p><p>应用：可以与重定向结合。cat &gt; data，这样从键盘中输入的数据将直接传到data文件中</p><p>此外还可以让文件内容显示在控制台上，有 cat &lt; data，标准输入变成了data文件，标准输出是屏幕。为了方便，直接cat 文件名也是可以的</p><p>此外，tail也有类似的功能，但是它只能显示最后的十行</p><p>另外一个应用就是把一个文件复制到另一个文件。例如，cat &lt; data &gt; newdata</p><h5 id="增强cat功能"><a href="#增强cat功能" class="headerlink" title="增强cat功能"></a>增强cat功能</h5><p>cat &lt; file…= cat file …</p><p>有三个点说明了可以同时输入多个文件，这样就为组合多个文件提供了途径</p><p>cat data1 data2 data3 &gt;file</p><p>后缀：</p><pre><code>-n 在每行后面加一个行号
-b 与-n一起使用，不要对空白行加行号
-s 将多个连续的空白行变成一个空白行</code></pre><h4 id="split-分为不同文件"><a href="#split-分为不同文件" class="headerlink" title="split 分为不同文件"></a>split 分为不同文件</h4><p>语法 split [-d] [-a num] [-l lines] [file [prefix]]</p><p>作用： 将一个大文件分解成几个小文件。默认情况下，split将创建1000行长的空间</p><p>参数：</p><pre><code>-l 创建一个5000行的空间
-d 将文件名改为从00开始编号
-a 后面加数字，例如3表示从000开始，总共1000个文件名</code></pre><p>默认情况下，split创建的文件将以x开头，后面加aa，ab等</p><h4 id="tac-反转复制"><a href="#tac-反转复制" class="headerlink" title="tac 反转复制"></a>tac 反转复制</h4><p>相关过滤器： cat，rev</p><p>作用：和cat类似，但是在写入文件时把文件内容反转（tac是将cat反过来）。注意，这里的反过来并不是指从后往前倒着写，而是把行与行将顺序反过来。</p><h4 id="rev-反转字符顺序"><a href="#rev-反转字符顺序" class="headerlink" title="rev 反转字符顺序"></a>rev 反转字符顺序</h4><p>相关过滤器： cat tac</p><p>作用： 将各行字符顺序反转</p><p>语法： rev [file…]</p><p>例如： 有一个文件data，里面有</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">12345</span></span><br><span class="line">abcde</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure></div><p>之后用rev后会变成</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">54321</span></span><br><span class="line">edcba</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure></div><p>rev也是直接输出到标准输出上的，也就是说并不会对源文件造成改变，如果想输出到文件中，还要重定向一下</p><h4 id="head，tail-从数据开头或者结尾读取"><a href="#head，tail-从数据开头或者结尾读取" class="headerlink" title="head，tail 从数据开头或者结尾读取"></a>head，tail 从数据开头或者结尾读取</h4><p>语法： head/tail [-n lines]，lines是希望选择的数据行</p><p>默认情况下，head和tail都只会选择十行数据，用-n可以选择任意行数</p><p>例： calculate | tail -n 15</p><h4 id="colrm-删除数据列"><a href="#colrm-删除数据列" class="headerlink" title="colrm 删除数据列"></a>colrm 删除数据列</h4><p>相关过滤器： cut paste</p><p>colrm（“column remove”)程序从标准输入中读取数据，删除指定数据列（也就是竖的删除），将剩余数据写入标准输出</p><p>语法： colrm [startcol [endcol]]，编号从1开始</p><p>例： colrm 14 30 &lt;students | less</p><h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><h4 id="cmp-比较两个任意文件"><a href="#cmp-比较两个任意文件" class="headerlink" title="cmp 比较两个任意文件"></a>cmp 比较两个任意文件</h4><p>相关过滤器：comm diff sdiff</p><p>语法: cmp file1 file2</p><p>cmp程序逐字节的比较文件，查看两个文件是否相同。如果两个文件相同，那么不做任何处理，如果不同，将会返回第一个不同的行和列</p><h4 id="comm-比较有序文件"><a href="#comm-比较有序文件" class="headerlink" title="comm 比较有序文件"></a>comm 比较有序文件</h4><p>语法：comm [-123] file1 file2</p><p>comm程序一行一行的比较两个有序的文本间，程序输出三列，第一列输出只包含在第一个文件中的行，第二列输出只包含在第二个文件中的行，第三列输出两个文件中都有的行。</p><p>因为comm是逐行比较，所以在比较之前最好使用sort进行排序</p><p>参数： -1 -2 -3 取消第一二三列的输出</p><h4 id="diff-比较无序文件"><a href="#diff-比较无序文件" class="headerlink" title="diff 比较无序文件"></a>diff 比较无序文件</h4><p>语法： diff [-bBiqswy] [-c| -Clines | -u | -Ulines] file1 file2</p><p>lines是说明上下文关系的行号</p><p>输出： diff的输出有三个不同的单字符指示： c（change） d（delete） a（append）。这三个字符说明了要想让两个文件相同需要做哪些改变。</p><p>这三个字符左右两边都会有数字，代表着需要修改的行号。例如，3c3代表把左边文件中的第三行变成右边文件中的第三行。</p><p>diff要求改变时，就会给出每一个文件的实际行，第一个文件中的行用小于号标记，第二个文件中的行用大于号标记。两组行之间还会有横线分隔开</p><p>例如，第一个文件为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="code"><pre><span class="line">abcd</span><br><span class="line">asdf</span><br><span class="line"><span class="keyword">as</span> df</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure></div><p>第二个文件为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EBNF"><figure class="iseeu highlight /ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">a</span>     </span><br><span class="line"><span class="attribute">abcd</span></span><br><span class="line"><span class="attribute">asdf</span></span><br><span class="line"><span class="attribute">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure></div><p>结果为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">0a1</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">a</span>     </span><br><span class="line"><span class="number">3</span><span class="string">,4c4</span></span><br><span class="line"><span class="string">&lt;</span> <span class="string">as</span> <span class="string">df</span></span><br><span class="line"><span class="string">&lt;</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure></div><p>a左边的数代表在左边数后面追加一行，例如0a1代表在第0行后面加上右边的第一行</p><p>d一般只需要管左边的数字，它的意思是删去左边的那一行</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-i 忽略大小写区别</span></span><br><span class="line"><span class="deletion">-w（whitespace) 忽略所有空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别，就是把多个空白符看成一个</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行，</span></span><br><span class="line"><span class="deletion">-q 当两个文本不同时，忽略所有细节，只说两文本不同</span></span><br><span class="line"><span class="deletion">-s 会明确告诉两个文本相同</span></span><br><span class="line"><span class="deletion">-c 全文比较，+代表要增加，-代表要减少，！代表要替换</span></span><br><span class="line"><span class="deletion">-u 与-c类似，但是把两个文件混合在一起显示，两个重复行只输出一个</span></span><br><span class="line"><span class="deletion">-y 把两个文件并排输出</span></span><br></pre></td></tr></table></figure></div><h4 id="sdiff"><a href="#sdiff" class="headerlink" title="sdiff"></a>sdiff</h4><p>语法： sdiff [-bBilsW] [-w columns] file1 file2</p><p>作用：与 diff -y 类似，并排比较<br>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-l 当两个文件有共同行时，只显示左边的列</span></span><br><span class="line"><span class="deletion">-s 不显示两个文件中任何相同的行</span></span><br><span class="line"><span class="deletion">-w+数字 改变列的宽度</span></span><br><span class="line"><span class="deletion">-i 忽略大写和小写的区别</span></span><br><span class="line"><span class="deletion">-W 忽略所有的空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行</span></span><br></pre></td></tr></table></figure></div><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p>例如： diff game1_ver1.0.c game2_ver2.0.c &gt; game2_ver2.1</p><p>这个命令会把第一个文件和第二个文佳之间的差保存下来，这样可以节省空间，此外在日后不慎丢失文件时也有办法快速找回</p><h4 id="cut-抽取数据列"><a href="#cut-抽取数据列" class="headerlink" title="cut 抽取数据列"></a>cut 抽取数据列</h4><p>相关过滤器： colrm join paste</p><p>语法： cut -c list [file…]</p><p>list就是要抽取的数据列，各个列之间用逗号隔开，不能有空格，或者14-19表示从14列到19列</p><p>作用：抽取指定的列</p><p>这种按列切分遇到长度不同的数据时就显得无能为力，因此还有另一种抽取方式，抽取字段，即按照一定的定界符进行分割（如逗号，空格等）</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SAS"><figure class="iseeu highlight /sas"><table><tr><td class="code"><pre><span class="line">-c  <span class="meta">list</span> [<span class="meta">file</span>...] <span class="meta">list</span>表明抽取第几个字段</span><br><span class="line">-f  <span class="meta">list</span> [-d <span class="meta">delimiter</span>] [-s] [<span class="meta">file</span>...]  -d后面是定界符种类 -s（suppress 抑制）抛弃没有定界符的行。例如 cut -f 1 -d <span class="string">':'</span> ./temp</span><br></pre></td></tr></table></figure></div><h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>语法： paste [-d char…] [file…]</p><p>其中char是用来做分隔符的字符，默认情况为一个制表符或者是空格</p><p>作用： 把几个文件组合成一个表格（组合数据列）</p><p>如果指定了不止一个定界符，那么将会轮流使用定界符</p><p>例如： paste -d ‘|%’ name phone ，这个指令中就有两个定界符</p><h3 id="统计和格式化"><a href="#统计和格式化" class="headerlink" title="统计和格式化"></a>统计和格式化</h3><h4 id="nl-创建行号"><a href="#nl-创建行号" class="headerlink" title="nl 创建行号"></a>nl 创建行号</h4><p>语法： nl [-v start] [-i increment] [-b a] [-n ln|rn|rz] [file…]</p><p>start是起始行号 ，increment是增量</p><p>作用：希望在一些数据中永久的插入行号，在输出中临时插入行号。一般状况下，插入的行号都是临时的，原始数据并不会发生改变，除非重定向输出到文件中。</p><p>默认情况下，不会对空行编号</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-v 改变起始编号，默认起始编号是1</span></span><br><span class="line"><span class="deletion">-i 改变增量，默认增量为1</span></span><br><span class="line"><span class="deletion">-b a 对所有行编号，包括空行</span></span><br><span class="line"><span class="deletion">-n ln 左对齐 rn 右对齐 rz 右对齐，有前导0</span></span><br></pre></td></tr></table></figure></div><h4 id="wc（word-count）统计行单词和字符的数量"><a href="#wc（word-count）统计行单词和字符的数量" class="headerlink" title="wc（word count）统计行单词和字符的数量"></a>wc（word count）统计行单词和字符的数量</h4><p>语法： wc [-clLw] [file…]</p><p>作用：统计行，单词，字符的数量。所统计的数据可以来自另一个程序或者是一个或多个文件</p><p>输出依次输出行，单词数，字符数 和文件名。如果不止一个文件，那么会为每一个文件显示一个输出，然后最后一行是一个总输出。</p><p>参数</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-l 统计行</span></span><br><span class="line"><span class="deletion">-w 统计单词</span></span><br><span class="line"><span class="deletion">-c 统计字符</span></span><br><span class="line"><span class="deletion">-L 该选项显示输入中最长行的长度</span></span><br></pre></td></tr></table></figure></div><p>此外，还可以用wc来统计某一目录中文件的数量，假设一个文件一行，用ls file | wc -l.</p><h4 id="制表符和空格"><a href="#制表符和空格" class="headerlink" title="制表符和空格"></a>制表符和空格</h4><p>在老式机器中，会在某些特定的为做一些机器标记，这些标记叫做制表位，如果按了制表位，那么机器会直接跳转到下一个制表位上，tab键与这个作用类似。一旦按了tab键，那么他将会自动跳转到下一个制表位。例如输入<code>A&lt;Tab&gt;BBBB&lt;Tab&gt;CCC</code>，实际上看起来中间有空格，实际上只有一个Tab</p><p>可视化制表符</p><p>第一种办法是在vi中，set list 那么制表符会转化成^I符号</p><h4 id="expand-将制表符转化成空格"><a href="#expand-将制表符转化成空格" class="headerlink" title="expand 将制表符转化成空格"></a>expand 将制表符转化成空格</h4><p>语法： expand [-i] [-t size] [-t list] [file…]</p><p>其中size是固定宽度制表符的大小（默认为8)，list是制表位列表</p><p>作用：expand将输入文件中所有的制表符转化成空格，别切维持与原文本相同的对齐方式</p><p>-i 只转换开头的制表符，其他的制表符保持不变</p><h4 id="unexpand-将空格转化成制表符"><a href="#unexpand-将空格转化成制表符" class="headerlink" title="unexpand 将空格转化成制表符"></a>unexpand 将空格转化成制表符</h4><p>语法： unexpand [-a] [-t size] [-t list] [file…]</p><p>其中size是制表符的大小（希望设置的），list是制表位列表</p><p>一般情况下，unexpand只转化第一行的空格，如果想要转换所有行的空格，那么需要-a选项</p><h4 id="fold-格式化行"><a href="#fold-格式化行" class="headerlink" title="fold 格式化行"></a>fold 格式化行</h4><p>相关过滤器： fmt ,pr</p><p>语法： fold [-s] [w witch] [file…]</p><p>其中witch是新行的宽度。</p><p>作用： 将长的行分割成短行。也就是把一行分成多行。其实就是在适当位置插入一个回车符</p><p>默认状态下，80个字符为一行。</p><p>-s选项是告诉程序不要分割单词，也就是说如果那个单词正好在要分割的位置，那么现在会先显示这个单词在转到下一行。</p><h4 id="fmt-格式化段落"><a href="#fmt-格式化段落" class="headerlink" title="fmt 格式化段落"></a>fmt 格式化段落</h4><p>语法： fmt [-su] [-w width] [file…]</p><p>作用：让各行连接在一起，并且不改变空白符。</p><p>当它读取文本时，假定段落由空行分隔。一个“段落”就是一个或多个连续的文本行，不包括空行。fmt根据下列规则读取一个段落</p><ul><li>行宽： 让每行尽可能的长，并且不超过指定的长度。默认情况下，每行最多75个字符</li><li>句子： 无论何时，尽可能在句子末尾分隔行。避免在句子的第一个单词之后或最后一个单词之前分隔行。</li><li>空白符： 保持单词及空行之间的所有缩进，空格。</li><li>制表符： 所有制表符转化成空格。并在最后输出时合适的位置插入制表符</li></ul><p>说起来复杂，其实就是让那些长短不一的段落尽量变得长。</p><p>例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SUBUNIT"><figure class="iseeu highlight /subunit"><table><tr><td class="code"><pre><span class="line">As we all know,</span><br><span class="line"><span class="keyword">success </span>cones slowly and</span><br><span class="line">is due to a number of different factors all coming</span><br><span class="line">together</span><br><span class="line">over a period of years</span><br></pre></td></tr></table></figure></div><p>使用命令后</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">As</span> we <span class="keyword">all</span> know, <span class="type">real</span> success comes slowly <span class="keyword">and</span> <span class="keyword">is</span></span><br><span class="line">due <span class="keyword">to</span> a number <span class="keyword">of</span> different factors <span class="keyword">all</span> coming</span><br><span class="line">together <span class="keyword">over</span> a period <span class="keyword">of</span> years.</span><br></pre></td></tr></table></figure></div><p>此外，它是一段的作用，如果两行之间有个空行就把他们当成两段单独处理，互不影响</p><p>参数</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-u(uniform spacing 统一间距) 减少空格，每个单词之间最多只有一个空格，句子末尾最多只有两个空格。</span></span><br><span class="line"><span class="deletion">-w 设定宽度</span></span><br></pre></td></tr></table></figure></div><h4 id="pr-按页格式化文本"><a href="#pr-按页格式化文本" class="headerlink" title="pr 按页格式化文本"></a>pr 按页格式化文本</h4><p>语法： pr [-dt] [+beg[:end]] [-h text] [-l n] [-o margin] [-W width] [file…]</p><p>作用： 按页格式化文件，以便于打印。</p><p>其中 beg是需要格式化的第一页，end是最后一页，text是标题，n是每页的行数，margin是左边缘的大小，width是输出的宽度。</p><p>默认情况下，pr是通过顶端插入一个标题，左边插入一个边缘，底部插入一个页尾来格式化文件。标题包括修改时间，文件名称和页号。</p><p>如果想查看效果，最好在less程序中</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-d 双倍行距文本（word中的）</span></span><br><span class="line"><span class="addition">+begin;end 从那页到哪页格式化</span></span><br><span class="line"><span class="deletion">-l 改变每页总行数</span></span><br><span class="line"><span class="deletion">-o 设置左边缘</span></span><br><span class="line"><span class="deletion">-W 改变每一行的字符数（默认是72）</span></span><br></pre></td></tr></table></figure></div><p>还可以按列格式化文本</p><p>语法： pr [-mt] [-columns] [-l lines] [-W width] [file…]</p><p>column是输出列的数量，lines是每页的行数，width是每行的字符数。这个选项不建议用，会截断字符。</p><h3 id="选取，排序，组合，变换"><a href="#选取，排序，组合，变换" class="headerlink" title="选取，排序，组合，变换"></a>选取，排序，组合，变换</h3><h4 id="grep-选取特定模式的行"><a href="#grep-选取特定模式的行" class="headerlink" title="grep 选取特定模式的行"></a>grep 选取特定模式的行</h4><p>相关过滤器： look strings</p><p>语法： grep [-cilLnrsvwx] pattern [file…]</p><p>pattern是要搜索的格式</p><p>作用： 从标准输入或文件中读取数据，抽取所有包含特定模式的行，并写入标准输出。</p><p>这个模式可以是字符串标点符号等，但是如果是标号或者特殊字符时，最好用’’强引用，以防止歧义。</p><p>选项：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-c(count) 统计所抽取行的数量，但不显示行本身</span></span><br><span class="line"><span class="deletion">-i（ignore) 忽略大小写的区别</span></span><br><span class="line"><span class="deletion">-n 所选行在原文件中的位置</span></span><br><span class="line"><span class="deletion">-l（list），如果在不只一个文件中搜索，使用这个选项可以只把匹配的文件名列举出来，此时文件名也要输出多个</span></span><br><span class="line"><span class="deletion">-L 显示不包含该模式的文件名</span></span><br><span class="line"><span class="deletion">-v（reverse） 选取不包含模式的行</span></span><br><span class="line"><span class="deletion">-x 选取完全匹配的行</span></span><br><span class="line"><span class="deletion">-r（recursive递归） 搜索整个目录树</span></span><br></pre></td></tr></table></figure></div><h5 id="fgrep，egrep-grep变体"><a href="#fgrep，egrep-grep变体" class="headerlink" title="fgrep，egrep grep变体"></a>fgrep，egrep grep变体</h5><p>fgrep，历史上使用，现在基本不用</p><p>egrep grep扩展版本，功能比grep强大，可以通过 grep -E的方式<br>-w 只匹配完整的单词，并且最好配合-l使用。</p><h4 id="look-选取以特定模式开头的行"><a href="#look-选取以特定模式开头的行" class="headerlink" title="look 选取以特定模式开头的行"></a>look 选取以特定模式开头的行</h4><p>格式： look [-df] pattern file…</p><p>作用： 搜索以字母顺序排列的数据，并查找所有以特定模式开头的行。然后输出这些行</p><p>look其实并不是一个过滤器，它只能从文件中读入，因此只能写于管道线的开头</p><p>-d 忽略标点和其他字符，本来是指搜索第一个单词</p><p>-f（fold同等） 忽略大写和小写的区别</p><h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h4><p>格式 sort [-dfnru] [-o outfile] [infile…]</p><p>作用： 排序数据和查看数据是否已经有序。他可以比较整行，也可以从每行中选取一部分进行比较。</p><p>sort可以重定向输出到另一个文件，但是不能输出到输入文件</p><p>例如： sort temp &gt; temp 是不可以的</p><p>但是可以使用-o选项，此时该文件中原有数据将会被保存，排序后的数据也会被追加到这个文件中</p><h5 id="dfnr-控制数据排序的顺序"><a href="#dfnr-控制数据排序的顺序" class="headerlink" title="-dfnr 控制数据排序的顺序"></a>-dfnr 控制数据排序的顺序</h5><p>-d(dictionary) 只查看字母，数字和空白符，当确定有阻碍排序的因素（如标点符号等），可以使用这个选项。</p><p>-f（fold 等同）不区分大小写</p><p>-n（numeric 数字） 识别开头或者字段开头的数字，并按照数字进行排序</p><p>-r 反向排序</p><p>-u（unique 唯一） 对于相同行，只保留一行</p><h5 id="检测数据是否有序-c"><a href="#检测数据是否有序-c" class="headerlink" title="检测数据是否有序 -c"></a>检测数据是否有序 -c</h5><p>-c（check） 不会排列数据，只会告诉数据是否有序，如果有序，将不会显示任何内容</p><h4 id="uniq-查找重复的行"><a href="#uniq-查找重复的行" class="headerlink" title="uniq 查找重复的行"></a>uniq 查找重复的行</h4><p>语法： uniq [-cdu] [infile [outfile]</p><p>作用： 消除重复行，选取重复行，选取唯一行，统计重复行的数量。不加选项输出非重复行和只输出一次重复行</p><p>注意uniq的输入必须是有序的</p><p>-d 只查看重复行</p><p>-u 只查看非重复行</p><p>-c 统计重复行出现的次数</p><h4 id="join-合并两个文件的有序数据"><a href="#join-合并两个文件的有序数据" class="headerlink" title="join 合并两个文件的有序数据"></a>join 合并两个文件的有序数据</h4><p>相关过滤器： colrm cut paste</p><p>语法： join [-i] [-al|-vl] [-a2|-v2] [-l field1] [-2 field2] file1 file2</p><p>其中field是引用特定数段的数字</p><p>作用： 把两个文件中对应行合并到一起。但是这又和sort不同，sort是直接把两个文件拼接在一起，而join则是重复数据合并为一个输出。不重复数据直接输出。读取输入时，会忽略前导空白符。</p><p>不使用其他标号情况下，只会显示有匹配的连接字段（也就是两个文件对应行有相同字段），如果使用-a(all)选项，将会显示整个文件，后面要加a1或a2。a1代表把第一个文件中不匹配的内容也加上去。如果是v1，显示V1中不匹配的行</p><p>-1+sum 将第一个文件中的第sum个字段和第二个文件中的第一个字段进行匹配</p><h4 id="tsort-由偏序创建全序"><a href="#tsort-由偏序创建全序" class="headerlink" title="tsort 由偏序创建全序"></a>tsort 由偏序创建全序</h4><p>语法： tsort file</p><p>作用：将一系列的事一件一件从头到尾输出</p><p>例如：两个单词第二个单词代表在第一个单词后要做的事</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="code"><pre><span class="line">eat clean-<span class="keyword">dishes</span></span><br><span class="line"><span class="keyword">clean-dishes </span>watch-TV</span><br><span class="line"><span class="keyword">shop </span>cook</span><br><span class="line">cook eat</span><br></pre></td></tr></table></figure></div><p>在使用了tsort后，输出为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">shop</span></span><br><span class="line"><span class="keyword">cook</span></span><br><span class="line"><span class="keyword">eat</span></span><br><span class="line"><span class="keyword">clean-dishes</span></span><br><span class="line"><span class="keyword">watch-TV</span></span><br></pre></td></tr></table></figure></div><h4 id="strings-在二进制文件中搜索字符串"><a href="#strings-在二进制文件中搜索字符串" class="headerlink" title="strings 在二进制文件中搜索字符串"></a>strings 在二进制文件中搜索字符串</h4><p>语法： strings [-length] file…</p><p>在现代软件中基本都有这种功能，不再展开</p><h4 id="转换字符-tr"><a href="#转换字符-tr" class="headerlink" title="转换字符 tr"></a>转换字符 tr</h4><p>语法： tr [-cds] [set1 [set2]]</p><p>set1是字符组</p><p>作用：可以将一个字符转化成另一个字符，例如将小写转化成大写，将制表符转化成空格，或者将0转化成x等。此外，还可以将多个字符变成一个字符，例如将多个空格转化成一个空格。最后，还可以删除指定字符，例如删除制表符。</p><p>例如： tr a A &lt; old tr a-z A-Z &lt; old</p><p>当需要替换的字符中出现由特殊意义的字符时，需要引用他们</p><p>还有几种特殊的缩写 [:lower:] 代表小写字母，[:upper:]代表大写字母，[:digit:]代表数字</p><p>tr还可以转换不可见字符</p><p>例如： tr ‘\n’ ‘\t’ &lt; old</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAML"><figure class="iseeu highlight /haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">s 多个字符变成一个字符 例如 tr -s <span class="string">' '</span> <span class="string">' '</span> &lt; old</span></span><br><span class="line"><span class="ruby">-d 删除指定字符</span></span><br><span class="line"><span class="ruby">-c 把没选上的字符变成另一个字符，例如 tr -c <span class="string">' \n'</span> x &lt; old，这个的意思就是除了空格和换行之外其他所有字符都变成x</span></span><br></pre></td></tr></table></figure></div><h4 id="sed-非交互式文本编辑"><a href="#sed-非交互式文本编辑" class="headerlink" title="sed 非交互式文本编辑"></a>sed 非交互式文本编辑</h4><p>交互式文本编辑就是有一个窗口，例如gedit vi等。而非交互式则需要提前设计命令，然后将命令发给程序。</p><p>语法： sed [-i] command | -e command… [file…]</p><p>command是sed命令</p><p>作用： sed是一个标准的过滤器，可以对标准输入或者标准输出进行修改</p><p>sed从输入流中每次读取一行。然后执行下面三个步骤</p><ol><li>从输入流中读取一行</li><li>执行指定的命令，对该行进行必要的修改</li><li>将该行写入输出流中</li></ol><p>因为是修改标准输入或者标准输出，所以源文件不会被修改，如果要修改原文件，可以加上-i(in-place)选项，这个选项会将输出保存到一个临时文件，一但所有数据处理完，sed就会把临时文件复制到原文件中</p><h5 id="使用sed进行替换"><a href="#使用sed进行替换" class="headerlink" title="使用sed进行替换"></a>使用sed进行替换</h5><p>想要用sed对标准输入或输出的内容进行修改，可以采用 s命令</p><p>形式： /address|pattern/ s /search/replacement/[g]</p><p>address 是输入流中一个行或者多个行的地址，pattern是一个字符串，search是正则表达式，replacement是一个替换文本</p><p>例如 sed s/harley/Harley,这个例子意思就是把每一行的第一个harley改成Harley，如果想把所有都改了，那么在后面要加上一个g</p><p>如果只对一些行进行操作，可以用下列语法：</p><p>number[,number] /regex/</p><p>number是行号</p><p>例如： sed ‘5s/harley/Harley/g’ names</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>加法溢出和乘法溢出</title>
    <url>/post/41763.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>无符号数加法便是两个数相加，如果超过最大值那么就截断超过的位数。截断超过的位数也就相当于mod2^n,因为这样做超过的位都会被模去变成0.</p><p>有符号数加法相对复杂。先是变成无符号数加法，加完 之后再按有符号数编码去理解，这样就会产生两种溢出，正溢出和负溢出。</p><p>首先，如果两个数一正一负，则不可能产生进位。</p><p>正溢出很好理解，最高一位为符号位，假如两个正数一加，超过了最大值，那么第2^w-1位就会变成1，这一位是符号位，因此这个数字便会变成负数。</p><p>如果是负溢出，因为两个数最高位一定为1，如果2^w-2位没有发生进位的话，那么就产生了溢出，此时最高位为0，变成正数</p><p>例如：10111111+10111111（-65）=01111110（126）</p><p>所以说如果是正数溢出，则需要-2^m,如果是负溢出，则需要加上2^m</p><p>判定是否发生溢出</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line">s=a+b;</span><br><span class="line"><span class="keyword">if</span>((a&gt;<span class="number">0</span>==b&gt;<span class="number">0</span>)&amp;&amp;(a&lt;<span class="number">0</span>!=s&lt;<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"发生溢出"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"没有发生溢出"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>a&gt;0==b&gt;0的意义是判断a和b的符号是否相同,相同为真.a&lt;0!=s&lt;0的含义是判断a和s的符号是否<br>乘法溢出相对简单粗暴，直接把高位全部截断，也就是对2^w取模，有符号数乘法是先不管符号位直接把后面的位相乘，然后再把符号位补上。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
  </entry>
  <entry>
    <title>重定向与管道</title>
    <url>/post/22102.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h3 id="标准输入-标准输出和标准错误"><a href="#标准输入-标准输出和标准错误" class="headerlink" title="标准输入 标准输出和标准错误"></a>标准输入 标准输出和标准错误</h3><p>基本思想：每个基于文本的程序都可以从任何源接受输入，并向任何目标输出</p><p>标准输入指的是一种读取数据的通用办法，标准输出有两种，一种是标准输出，另一种是标准错误</p><p>而输入输出其实正常情况下有shell决定。为了保证程序的输出，需要告诉shell将输出目标设置成文件。</p><h3 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h3><p>在登陆时，shell会自动将标准输入设置成键盘，将标准输出和标准错误设置成屏幕。</p><p>但是每次输入命令时，可以告诉shell在此命令执行期间更换输入输出对象。</p><p>如果想把一个命令输出送到一个文件中，例如sort命令 可以写成 sort &gt; names</p><p>以这种命令输出时，如果文件不存在，shell会自动创建这个文件。如果文件存在，那他将会把文件内容全部清空然后再把内容输入到里面去</p><p>如果我们只想追加内容到这个文件中，可以用 &gt;&gt; 。如果文件不存在，这个命令也会创建新文件，如果存在，那么会追加内容到后面。</p><p>如果取消清空文件重新输入的选项，可以设置nonclobber选项。但是设置完之后，如果确实想替换掉这个文件，可以临时忽略掉noclobber，这时需要用<code>&gt;|</code>替换 &gt;</p><h4 id="重定向标准输入"><a href="#重定向标准输入" class="headerlink" title="重定向标准输入"></a>重定向标准输入</h4><p>符号： &lt;</p><p>左边是你要运行的程序，右边是你有读入数据的文件</p><p>例如 sort &lt; /etc/passwd</p><p>标准输入和标准输出可以同时指定</p><p>例如 sort &lt; rawdata &gt; report，这个命令会把rawdata中的数据给sort处理，然后把结果给report文件</p><h4 id="重定向标准错误"><a href="#重定向标准错误" class="headerlink" title="重定向标准错误"></a>重定向标准错误</h4><p>shell提供两种输出目标，标准输出和标准错误。正常情况下，两种输出同时显示在屏幕上，在需要时，可以把两种输出分隔开。</p><p>首先对unix处理I/O过程了解。每个输入源和每个输出目标都有一个唯一的数字标识，，这个数字 称为文件描述符。例如一个进程可能从#8中读取数据，并将文件写入#6中</p><p>例如为了将输出写入到文件8中，可以sort 8&gt; results，results就是第8个文件</p><p>默认情况下，Unix为每个进程提供三个预定义的文件描述符。而且大多数时候都可以使用。0代表标准输入，1代表标准输出，3代表标准错误。</p><p>所以要想重定向输入，可以用 0&lt;</p><p>而要想重定向标准输出，可以用 1&gt; ,这样错误信息就会留在屏幕上便于我们查看，而输出信息在文件中。如果想让标准错误在文件中，可以 2&gt;</p><p>此外，平常写的 &gt; 实际上代表的是 1&gt;</p><h4 id="子shell"><a href="#子shell" class="headerlink" title="子shell"></a>子shell</h4><p>进程就是加载到内存中准备运行的程序，当进程需要启动另一个进程的时候，这个进程创建了一个副本进程，原始跌进程叫做父进程，而这个进程叫做子进程。</p><p>而子进程一旦结束，优惠唤醒父进程继续执行命令，此时子进程消失。</p><p>子shell指的是在父shell中重新开一个shell，这样在子shell中造成的改变不会影响父shell，甚至是环境变量也一样，除非把它写入初始化文件中，不然这个全局变量也会随着子shell进程的结束而消亡。</p><p>如果有时你想在子shell中执行一条指令，又不想启动一个全新的shell，那么一个办法就是在外面加上小括号(),例如 （date）</p><h4 id="组合标准重定向输出和错误"><a href="#组合标准重定向输出和错误" class="headerlink" title="组合标准重定向输出和错误"></a>组合标准重定向输出和错误</h4><p>在bash中，基本思想是建议将一种类型的输出重定向到一个文件，然后再追加</p><p>command x&gt; outputfile y&gt;&amp;x</p><blockquote><p>&amp; 符号的意思是替代</p></blockquote><p>y&gt;&amp; x的意思是把2的输出发送给1相同的位置。</p><p>例： sort 2&gt;&amp;1 &gt;output 这个意思是把2的输出发送到与一相同的位置，而一是发送到屏幕的，于是2也发送到屏幕了</p><h4 id="抛弃输出"><a href="#抛弃输出" class="headerlink" title="抛弃输出"></a>抛弃输出</h4><p>为什么要抛弃输出呢？</p><p>有时候，需要运行一个程序。因为可能你并不关心这个文件的输出。有时候，可能希望查看文件正常输出，而不关心错误信息。</p><p>那么这个时候只需要重定向输出到 /etc/null即可。这个文件的特殊之处在于发送给他的任何东西都会消失。所以 它有个奇怪的名字叫做 位桶(bit bucket)</p><h3 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h3><p>管道线的作用就是让各个程序组合发挥作用</p><p>shell允许创建一系列的命令，在这一系列的命令中，一个命令的标准输出可以发送给下一个程序的标准输入。当这样做时，两个程序之间的连接就是管道，而命令序列本身叫做管道线。</p><p>在创建管道线时，只需将希望键入的命令用竖线| （管道符号） 分隔开即可</p><p>能从标准输入读取文本，并向标准输出写入文本的程序，称为过滤器。</p><h4 id="管道线分流-tee"><a href="#管道线分流-tee" class="headerlink" title="管道线分流 tee"></a>管道线分流 tee</h4><p>有时候，可能希望把程序的输出发送到两个地方</p><p>语法： tee [-a] file…</p><p>file就是希望将数据发送到的文件的名称</p><p>例：cat name1 name2 | tee masterlist | grep Harley</p><p>这个指令中的tee 会将输出保存到masterlist中并且将cat的输出给grep</p><p>同样，如果这个文件存在，那么tee将会重写这个文件。如果想要追加内容，那么可以tee -a(append)</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>初始化文件</title>
    <url>/post/8274.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>有两个初始化文件，第一个文件是在启动时执行的，叫做登录文件（login file).第二个文件是在启动shell时执行的，叫做环境文件(environment file)。<br>有的shell还有注销文件，注销文件指的是在shell关闭时执行的文件</p><p>bash shell中登录文件文件名（.Bash_profile .bash_login)，环境文件（.bashrc),注销文件（.bash_logout)</p><p>这些文件名都是以点开头，点文件的别名是隐藏文件，意义是除非你用ls指令去查看，通常状况你无法看到这个文件</p><p>登录shell指的是登录时默认启动的shell，非登录shel则需要在登录shell中执行命令才可以启动</p><p>登录shell执行登录文件和环境文件，非登录shell只执行环境文件</p><h4 id="初始化文件中放什么内容"><a href="#初始化文件中放什么内容" class="headerlink" title="初始化文件中放什么内容"></a>初始化文件中放什么内容</h4><p>登录文件有两项任务，设置环境和初始化工作对话（不知道什么意思）</p><p>所以登录文件有两项任务</p><ol><li>创建或修改环境变量的命令（PATH,PAGER等）</li><li>执行所有一次性操作的命令</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>宏定义</title>
    <url>/post/39968.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>宏定义就是在开始用井号（#）定义一个函数或者是常量，这种定义在编译器中被处理，运算速度快，但使用宏定义时可能会出现一些隐蔽的问题</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="FORTRAN"><figure class="iseeu highlight /fortran"><table><tr><td class="code"><pre><span class="line">#define <span class="keyword">DATA</span> sizeof(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">for(<span class="built_in">int</span> i=cnt;i-<span class="keyword">DATA</span>&gt;=<span class="number">0</span>;i-=<span class="keyword">DATA</span>)</span><br></pre></td></tr></table></figure></div><p>乍一看这样做似乎没什么问题，要注意sizeof返回的是一个无符号数，有符号数和无符号数做比较的时候会先把有符号数变成无符号数。而负数的有符号数最高位一定为1，这样就可能会导致数据异常。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>delete的一个注意事项</title>
    <url>/post/58313.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>实际上delete后的指针并不会变成空指针，仍指向堆里的地址。但是这个时候这块空间已经可以被其他的new申请了，如果你没有把原指针更改的话，有可能对原指针进行的修改会影响到新指针。因此每次delete完之后最好把这个指针变成空指针</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>位运算和移位运算</title>
    <url>/post/61738.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h3><p>这里的与运算并不是平常的bool运算，而是按位与。这种运算比加减法快</p><p>符号： &amp;</p><p>例： 1010&amp;1000=1000 1001&amp;0110=0000</p><p>含义： 1&amp;1=1,1&amp;0=0,0&amp;1=0,0&amp;0=0，只要不是两个都是,1，那么结果就是0</p><p>应用：</p><ul><li>替换指定位的值</li></ul><p>一个典型应用就是大小写转换，如果平常转换我们可能要写一大堆，但是经过仔细观察后发现大写字母和小写字母之间差距只有第5位，如果第五位为0，就是大写字母，为1就是小写字母，所以只要<code>a&amp;0b11011111</code>这一段代码就可以完成小写到大写的转换</p><ul><li>清零</li></ul><p>通过 a&amp;0b00000000 ,可以快速的把某个数变成零</p><ul><li>消去最后一位 1</li></ul><p>x &amp; (x-1) 例如 x 1010 x-1 1001 ，计算之后1000。减1就是让最小的那个1变成0然后后面全是1</p><ul><li>找到最小一位1</li></ul><p>x &amp; (-x) 在lowbit函数中用到， -x=~（x-1），大于最小一位1的都由于取反变成0，然后最小一位1及其后面本来是0111…,取反变成1000…，而原来是100…，所以最终是00…0100…</p><h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h3><p>符号： |</p><p>例： 1010|1000=1010 1001|0110=1111</p><p>含义： 1|1=1,1|0=1，0|1=1，0|0=0</p><p>应用：</p><ul><li>设定某一个数据位为1，例如想把第五位设为1，只要 a|0b00100000</li></ul><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>符号： ^</p><p>例： 1010^1000=0010, 1001^0110=1111</p><p>含义： 1^1=0,1^0=1,0^1=1,0^0=0，同为假，异为真</p><p>应用：</p><ul><li><p>x^11111…=~x;</p></li><li><p>异或满足交换率，结合率</p></li><li><p>x^x=0,x^0=x,自己是自己的逆元，0是幺元</p></li><li><p>a^b^a=b,因此可以用这种性质做许多应用，一个应用就是交换两个变量的值</p></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*&amp; a,<span class="keyword">int</span>*&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a=*a ^ *b;  <span class="comment">//a=a^b</span></span><br><span class="line">    *b=*a ^ *b; <span class="comment">//b=a^b^b=a</span></span><br><span class="line">    *a=*a ^ *b; <span class="comment">//a=a^b^a=b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另外还可以用来检查重复数或者在其余都是偶数个重复数字中找到一个奇数</p><p>例：1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现<br>一次。每个数组元素只能访问一次</p><p>将所有的数全部异或，得到的结果与1^2^3^…^1000的结果进行异或，得到的结果就是重复数。</p><h3 id="按位非"><a href="#按位非" class="headerlink" title="按位非"></a>按位非</h3><p>符号： ~</p><p>例： ~1001=0110， ~1010=0101</p><p>含义： <del>1=0，</del>0=1 ,取反</p><p>应用：</p><ul><li><p>对于有符号数 <del>a=-(a+1),因为一般采用补码，而补码的负数就是正数-1再取反得到，所以</del>(a-1)=-a，可得~a=-(a+1)</p></li><li><p>把最低位变成0，a&amp;~1</p><h3 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h3></li></ul><p>符号： &lt;&lt;</p><p>例 00001010&lt;&lt;1 =&gt; 00010100</p><p>含义： 把所有的位向左移位，高位删去，低位补零，相当于乘上2的n次方</p><p>注意：如果移动次数超过了最高位，那么这是一个未定义行为。所以不同编译器，不同cpu对其有不同解释。gcc会将其自动变成0，而微软的编译器会先将移动位数模上最大位数然后再左移相应位数。cpu中也是取模的方式。</p><p>例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;</span><br><span class="line">b=a&lt;&lt;<span class="number">40</span>;<span class="comment">//此时b=0，因为这个命令是在编译器中完成的</span></span><br><span class="line">a&lt;&lt;=<span class="number">40</span>;<span class="comment">//此时a！=0，因为这个命令是在cpu中完成的</span></span><br></pre></td></tr></table></figure></div><h3 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h3><p>符号： &gt;&gt;</p><p>含义 将所有位向右移位，高位视情况而定，低位舍弃</p><p>视情况而定是因为实际上有两种右移，第一种是逻辑右移，第二种是算术右移</p><ul><li>逻辑右移，高位直接取0</li><li>算术右移，高位要看情况，如果原来最高位是0，则取0。如果最高位是1，则后面加的都是1.</li></ul><p><strong>逻辑右移的符号： &gt;&gt;&gt;</strong>(java)</p><p>那什么时候用逻辑右移还是算术右移呢？一般来说，有符号数算术右移，无符号数逻辑右移。因为有符号数用的是补码，如果是负数右移最高位补1才能让这个数还是负数</p><p>应用：</p><ul><li>不用-号把1变成-1<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;</span><br><span class="line">a&gt;&gt;=<span class="number">31</span>;<span class="comment">//最高位为1，其余都为0</span></span><br><span class="line">a&lt;&lt;=<span class="number">31</span>;<span class="comment">//都为1</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="右移运算对整数的影响"><a href="#右移运算对整数的影响" class="headerlink" title="右移运算对整数的影响"></a>右移运算对整数的影响</h4><p>右移运算相当于除2，之后低位相当于小数点后面的数字。这时我们把它截断相当于取整，对于无符号数和有符号数中的非负数，这个取整是没什么影响的，但对于有符号数中的负数，取整却与除法取整有所偏差。</p><p>除法取整是趋向于零。也就是说，非负数向下取整，负数向上取整。而右移确是把小数后面的数全部舍弃，就相当于让这个数更小了。</p><p>例如： 假如右移后是 -1234.32423，结果是-1235.因为把小数点舍弃会使这个数更小。</p><p>有一种情况除外。就是右移产生的小数点位中全是0，这时舍弃它并不会产生影响，所以不会发生向下取整。</p><p>为了解决这个问题，一种办法就是 <code>(x+2^k-1)&gt;&gt;k</code>，为了加快速度，可以写成<code>(x+1&lt;&lt;k-1)&gt;&gt;k</code></p><p>现在来看这个式子的正确性，当最后几位全为0时，例如1000000右移三位，那么2^3-1=0b111,因为本来这个结果就是正确答案，现在加上111并没有改变它的值，0b1111000.111后面三位舍弃与原来相同，因此这个时候结论正确</p><p>如果后面不是全为0，那么这时必定产生进位，例如1101右移三位那么加上之后必定会使第四位进一位，这时我们再右移三位，便相当于让原来的答案加一，达到了向上取整的效果</p><p>最后，只有在有符号数中的负数中才要采用这种算法，在非负数中直接右移即可</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>c++输出16进制，10进制和2进制</title>
    <url>/post/8372.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>hex是输出16进制，例如<br><code>cout&lt;&lt;hex&lt;&lt;18&lt;&lt;endl;</code></p><p>dec十进制</p><p>另外这两种用了之后后面输出一直是这种进制，如果用了hex之后想要用十进制要写dec</p><p>二进制bitset</p><p>bitset有头文件 <code>&lt;bitset&gt;</code></p><p>使用方法 bitset&lt;8&gt;(数字），其中8的含义是要输处几位二进制数，所以如果用int型是32，如果想把字符型转换就直接写8</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>shell内部命令与外部命令与搜索路径</title>
    <url>/post/18431.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>有些命令是shell外部的，shell会解析参数然后调用外部的程序去处理它，另外还有一些是对shell起作用的，叫shell内置命令</p><p>如果先查看内部命令，需要 man + shell名称 ，例如，man bash</p><h3 id="外部命令和搜索路径"><a href="#外部命令和搜索路径" class="headerlink" title="外部命令和搜索路径"></a>外部命令和搜索路径</h3><p>shell是如何知道那些程序都在哪呢？ 实际上shell是检查PATH环境变量，PATH包含一串字符，这串字符就是一系列目录名称，称作搜索路径。如果输入一个命令，shell会依次按这些目录去搜索命令</p><p>先要看PATH 直接 echo $PATH即可</p><h3 id="修改搜索路径"><a href="#修改搜索路径" class="headerlink" title="修改搜索路径"></a>修改搜索路径</h3><p>可以用export命令，export命令可以使PATH变量变成环境变量，这就意味着shell和随后所有进程都可以使用它，例如<code>export PATH=&quot;/bin:/usr/bin:/usr/ucb:/usr/local/bin&quot;</code></p><p>如果希望在搜索路径的末尾加上一条路径，可以 <code>export PATH=&quot;$PATH:$HOME/bin&quot;</code><br>如果想在最后加上一条指令，可以<code>export PATH=&quot;$HOME/bin:$PATH&quot;</code></p><p>如果把自己写的date命令放在开头，系统将会执行自己写的date命令，而不会执行系统本身的命令</p><p>实际上用export设置的环境变量在下次启动时就会失效，如果想一直保存需要修改一些特定的文件</p><h3 id="修改命令行提示"><a href="#修改命令行提示" class="headerlink" title="修改命令行提示"></a>修改命令行提示</h3><p>命令行提示的路径在PS1的环境变量当中,因此要修改的话只需要export PS1=”$ “就可以了</p><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>用反引号<code></code> `,用了这种符号会先执行反引号你饿不的命令然后再执行外部命令，</p><p>例如 <code>echo &quot;Date is</code>date` “</p><p>这个命令会显示Date is + 具体时间，注意要用双引号，单引号会把反引号引用掉</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>元字符的使用</title>
    <url>/post/38072.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>元字符指的是Linux中有特殊含义的字符，例如 ； 换行符等。</p><h3 id="字符引用和转义"><a href="#字符引用和转义" class="headerlink" title="字符引用和转义"></a>字符引用和转义</h3><p>如果不想用元字符内在含义，只想打出这个字符，那么就需要用到引用字符。</p><p>字符引用的方法有三种，使用反斜线，使用一对单引号或者使用一对双引号</p><p>例如 echo a ; b 这样就会把他们当成不同的指令，但是如果 echo a; b,这样就会当成同一个指令，实际上\是转义字符，转义字符指的是把一个字符从一中状态转移到另一种状态</p><p>单引号会将一切字符引用，这样有时例如我需要引用其中一个变量的值的时候就会出现问题</p><p>这时我们就可以用到双引号，双引号不会引用 $ , \ , `(反引号），</p><p>引用能力强弱 ，&gt;‘’&gt;””</p><p>如果输入换行字符，单引号并不会转义它，但是\会转义它</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>顺序表</title>
    <url>/post/52078.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>顺序表就是将元素放入一个连续的内存空间里，它的优点是可以快速访问，缺点是插入和删除操作时间复杂度高</p><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> datasize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>* p;<span class="comment">//存储空间的基址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//现在有的元素数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(node&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.p=<span class="keyword">new</span> <span class="keyword">int</span>[datasize];</span><br><span class="line">    <span class="keyword">if</span>(a.p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"储存分配失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> [] a.p;</span><br><span class="line">    &#125;</span><br><span class="line">    a.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>初始化有两点要注意的地方，第一点是用了传引用，第二点是动态分配内存，这就表示如果使用完了要delete</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="code"><pre><span class="line">int <span class="built_in">find</span>(node&amp; a,int x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;a.<span class="built_in">length</span>;<span class="built_in">i</span>++)</span><br><span class="line">   &#123;</span><br><span class="line">   		<span class="keyword">if</span>(a.p[<span class="built_in">i</span>]==x)</span><br><span class="line">      &#123;</span><br><span class="line">      		<span class="keyword">return</span> <span class="built_in">i</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入操作是把一个数插入第i位，其他位顺序后移</p><p>如果插入某一位概率相同，那么在第0位插入需要移动n个数，第一位插入需要移动n-1个数……在第n位插入需要移动0个数，总共有n-1中可能，总共需要移动的次数为n(n+1)/2,所以平均需要移动次数为n/2</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="code"><pre><span class="line">int insert(node&amp; a,int x,int <span class="built_in">i</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">i</span>&lt;<span class="number">0</span>||<span class="built_in">i</span>&gt;a.<span class="built_in">length</span>||a.<span class="built_in">length</span>==datasize)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">j</span>=a.<span class="built_in">length</span>;<span class="built_in">j</span>&gt;<span class="built_in">i</span>;<span class="built_in">j</span>--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="built_in">j</span>]=a[<span class="built_in">j</span><span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="built_in">i</span>]=x;</span><br><span class="line">    a.<span class="built_in">length</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>与上面操作类似，这里需要前移，并且平均操作次数为(n-1)/2</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> Delete(node&amp; a,<span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i;k&lt;a.length<span class="number">-1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.p[k]=a.p[k+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a.length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>linux指令学习</title>
    <url>/post/26477.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h5 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h5><p>一次输入多条命令，可以在命令之间用 <code>;</code>分割开来</p><p>语法： 命令名称 选项 参数</p><p><strong>选项</strong>有时被称为开关（switches）或标志（flags），选项通常是由一个连字符后面接着一些字母，或者两个连字符后接着一个单词构成。例如 –help，–version（显示版本信息）</p><p>使用多个单字符选项时，可以把他们连接在一起，用一个连字符来表示。例如 ls -lF<br>。注意，unix的选项区分大小写</p><p>实际上许多长参数有着对应的短参数，但是长参数是一个完整的单词，为了便于记忆，有时也是用长参数，这时就要用两个连字符</p><p>输入命令时，必须要把每个选项和参数用空格分隔开</p><p>有些命令有默认值，有些命令没有默认值，例如 ls 如果只输入ls的话他会返回当前工作目录下所有文件</p><p>手册中提示的语法</p><ol><li>方括号中的项是可选的</li><li>不再方括号中的项是必选项</li><li>黑体字必须原样输入</li><li>斜体字可以用适当的值代替</li><li>有省略号代表可以重复多次</li><li>如果一个单独的选项和参数组合在一起，这二者必须同时出现</li><li>由竖线（|）字符分开的两个或者多个项，宝石可以从这个列表中选择任意一项</li></ol><h5 id="用户提醒命令"><a href="#用户提醒命令" class="headerlink" title="用户提醒命令"></a>用户提醒命令</h5><ul><li>who 用来显示用这个计算机的用户</li><li>whoami 用来显示当前用户标识</li><li>quota 用来看自己拥有多少空间</li><li>lock 临时上锁 lock -5 锁5分钟</li><li>leave leave +15 十五分钟后离开 leave 1344 13点44分离开，到了时间它会不停的提醒你，相当于一个闹钟</li><li>id 用来显示你的基本信息</li><li>date 时间 date -u 协调世界时间（UTC时间）</li><li>cal 显示日历 cal+某一年份可以显示某一年份的日历 cal 7 2019 显示2019年7月的日历 cal -j +… 会显示第几天，所以想要知道这一年是不是闰年只需 cal -j 12 + 年份，看看12月最后一天是不是366天就可以了</li><li>su（substitute user） 这个指令是用来切换用户的，如果你知道一个用户的口令，那么就可以采用su+用户名的方式切换，这个时候用户标识改变了，但是你仍位于旧的环境之中。就像你让别人来你家做事，如果你想让别人在自己家做事，就要用su+’-‘+用户名</li></ul><p>特别的，如果你想拥有root权限，你需要 su - root ，这时你输入的是你自己的口令而不是root口令，因为在计算机中有特殊的配置文件，这个文件只有管理员能操作，他可以修改那些人可以通过su口令获得root权限</p><ul><li>man 联机文档帮助 当你查看联机文档时，可以用/符加上你想搜索的内容进行搜索，用n来显示下一个，用N来显示上一个。？符是向下搜索。<br>如果想在查看man文档时执行指令，只需输入！在输入命令，之后按enter键又能回到man文档中</li><li>foo bar 可以指代任意标识<br>man文档显示的内容</li></ul><ol><li>命令</li><li>系统调用</li><li>库函数</li><li>特殊文件</li><li>文件格式</li><li>游戏</li><li>杂项</li><li>系统管理</li></ol><ul><li><p>whatis 显示说明书页的第一行（名字和用途）例如 whatis time date，这样同时显示两条指令的信息。这种指令可以用 man -f 替换</p></li><li><p>apropos 搜索命令 他将显示所有带有该字符的命令。这种命令可以用man -k代替</p></li><li><p>info 另一种搜索命令，这种命令的特点是它有到其他命令的连接，就好像网页一样。这时一种树形结构，n跳转到下一个节点，p跳转到上一个节点，t跳转到当前文件的顶节点</p><h5 id="登入登出命令"><a href="#登入登出命令" class="headerlink" title="登入登出命令"></a>登入登出命令</h5></li><li><p>exit 退出当前用户，例如想从root模式退出用exit</p></li><li><p>sudo 以超级用户模式运行一条指令。如果你经常使用超级用户，可能在无意间删去一些重要文件导致系统出现故障，因此超级用户需慎用。因此要用可以用sudo命令。</p></li><li><p>less 浏览配置文件。例如我想浏览passwd文件，只需 less /etc/passwd</p></li></ul><p>配置文件就像windows系统下的注册表和ini文件</p><ul><li>dmesg 显示启动信息，但是这种显示太快，看不清</li><li>dmesg | less 显示启动信息</li><li>init 设置运行级别，1为单用户，2为多用户，等等，0是关机，6是重启</li></ul><p>如果想重启，可以用 sudo init 6</p><ul><li>reboot 重启 sudo reboot</li><li>shutdown 关机，这个要说关机时间，经常用的是sudo shutdown now</li></ul><h5 id="快捷键和便捷输入命令"><a href="#快捷键和便捷输入命令" class="headerlink" title="快捷键和便捷输入命令"></a>快捷键和便捷输入命令</h5><ul><li>erase 删除最好一个键入的字符，Ctrl+H</li><li>werase 删除最后一个单词 Ctrl+W</li><li>kill 删除一行 Ctrl+U</li><li>intr 停止程序 有些系统是Ctrl+C，有些是delete</li><li>quit 停止程序 Ctrl+\ 它不仅会停止程序，还会生成一个副本保存在core的文件中</li><li>stop 停止屏幕显示，Ctrl+S</li><li>start 开始屏幕显示 Ctrl+Q</li><li>eof 文件终止信号 Ctrl+D<br>可以通过Ctrl+D终止shell，但是有时候会不小心按到。为了让shell忽略eof，需要使用一个叫IGNOREEOF的环境变量，这个变量表示注销前BASH会忽略多少次eof，设置这个变量时，要 IGNOREEOF = 数字</li><li>stty -a 显示键盘映射，这个命令是表示各个快捷方式如erase的快捷键。stty是set terminal(设置终端）-a表示显示所有设置</li><li>stty 修改键映射。例如想修改kill命令 ，可以 stty kill Ctrl a</li><li>返回字符 ^M，指的是返回到这一行的开头</li><li>换行字符 ^J<br>文件每一行最后一定是一个返回加换行</li><li>stty sane，reset 候终端的设置被弄乱，可以采用这个命令是终端恢复到初始值</li><li>up 向上键，会转到上一条指令</li><li>down 转到下一条指令</li><li>fc 查看历史命令列表，用fc -l来查看，前面都有一个编号。如果想转到某一条指令，可以 fc -s(substitute) 编号。如果后面不接编号，则默认为上一条指令。但是用fc -s会立刻执行这条指令</li></ul><p>可以对这条命令进行小范围修改，格式为 fc -s pattern=replacement number<br>。pattern和replacement 都是字符串，而number是要修改时间的编号</p><ul><li>tab 自动补全命令，按一下如果有歧义，会发出提示声<h5 id="立即使用的程序"><a href="#立即使用的程序" class="headerlink" title="立即使用的程序"></a>立即使用的程序</h5></li><li>gedit 文本编辑器，相当于windows下的记事本</li><li>which 看某个命令会使用那些程序，如果显示地址，则说明有这些程序，如果没有输出，或者输出错误信息，则说明这个命令无法使用</li><li>quit 终止程序命令，但是也可以输入eof使程序终止</li><li>bc 计算器 如果想用bc内部的函数，要用bc -l命令（library)。如果是多个算式，中间要用”;”号隔开</li></ul><p>常用函数</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">s</span><span class="params">(x)</span></span> sinx  弧度制</span><br><span class="line"><span class="function"><span class="title">c</span><span class="params">(x)</span></span> cosx</span><br><span class="line"><span class="function"><span class="title">a</span><span class="params">(x)</span></span> arctanx</span><br><span class="line"><span class="function"><span class="title">ln</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">j</span><span class="params">(n,x)</span></span>  x的n次整阶贝塞尔函数</span><br></pre></td></tr></table></figure></div><p>如果想用小数运算，先要设置标度因子 scale 来确定精确到小数点后多少位。如果输入scale 则会返回scale的当前值 scale=3，则设置小数点后三位</p><p>有一点需要注意，当你用来 bc -l时，scale会自动设置为20</p><p>bc实际上是一套功能完整的数学编程语言，可以使用的变量有26个字母<br>例如 x=100 就是将x变量设为100</p><h5 id="变量显示命令"><a href="#变量显示命令" class="headerlink" title="变量显示命令"></a>变量显示命令</h5><p>环境变量实际上就是全局变量，用env显示环境变量，如果想让输出按字母表排序，可以用 env | sort | less</p><ul><li><p>set 显示shell变量</p></li><li><p>echo 显示赋予它对象的值，例如 echo I 将会输出I</p></li></ul><p>如果要显示一个变量的值，可以用$(美元符号），后面的变量最好加花括号（{}）</p><p>例如 echo ${TERM}</p><p>实际上，很多标点符号都有特殊的用途，为了能正确显示他们，要在最外面用双引号</p><ul><li><p>变量创建只需要一边写变量名，另一边写值即可。例如，HARLEY=cool，如果希望变量中有空格，则需使用双引号</p></li><li><p>export 将变量导出环境中（即变成全局变量）。还可以在创建同时导出。用 export 变量名=值即可</p></li><li><p>unset 删除变量。实际上没有办法简单的从环境中移除变量，因此最简单的办法是直接删除它。</p></li><li><p>set 显示shell所有选项的当前值，如果用 -o 则会简要的显示 +o是详细的显示。例如，set -o ignoreeof 这样在按 Ctrl+D的时候就不会突出shell了，如果想复位，只要+o</p></li><li><p>alias 建立别名，语法为alias name=command 例如 <code>alias It=&#39;-l temp*&#39;</code>。这种时候，单引号就比双引号要好，因为这样可以防止一些特殊字符被转义。此外，可以通过alias name 知道这个别名的当前值。可以只输入alias得知所有别名，通过unalias删去别名。如果想暂时不用别名，可以在命令之前输入” \ “</p></li></ul><h5 id="文件显示指令"><a href="#文件显示指令" class="headerlink" title="文件显示指令"></a>文件显示指令</h5><ul><li>less，这条指令是让大量的数据分成一页一页进行查看，如果不使用这个程序。那么输出时会直接到这些数据的末尾。less在正常情况下是区分大小写的，如果想不区分，可以使用I选项。此外，less命令内部还有许多搜索，翻页等指令，这些指令可以通过help去查看。</li></ul><p>less还有一个特殊的功能，就是直接跳转到某一页。less +5g …代表跳转到第5页，less +/buffer …是从第一个buffer处开始。</p><h6 id="显示十六进制文件"><a href="#显示十六进制文件" class="headerlink" title="显示十六进制文件"></a>显示十六进制文件</h6><p>显示二进制文件的命令是 hexdump（显示十六进制文件），od（显示八进制文件），</p><p>hexdump -C file。将自动选取适合的选项组合进行输出。</p><p>-s 偏移一定字节数开始输出。</p><p>-n 显示多少字节输出</p><h5 id="条件执行指令"><a href="#条件执行指令" class="headerlink" title="条件执行指令"></a>条件执行指令</h5><p>command1 &amp;&amp; command2</p><p>在条件1满足的情况下执行command2</p><p>command1|| command2</p><p>在条件1不满足的情况下也执行command2</p><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>regular expression 通常简写成regex或re，是一种指定字符串模式的输出方式。</p><p>例如： harley1 harley2 harley3 ，作为正则表达式，可以用harley[123]表达这组模式。</p><p>从这里我们可以了解到，正则表达式就像把许多字符串化为一个表达式。</p><p>下面介绍一些常用的正则表达式</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>除新行字符外，匹配任意的单个字符</td></tr><tr><td>^</td><td>锚，匹配行的开头</td></tr><tr><td>$</td><td>锚，匹配行的末尾</td></tr><tr><td>\ &lt;</td><td>锚，匹配单词的开头</td></tr><tr><td>\ &gt;</td><td>锚，匹配单词的末尾</td></tr><tr><td>[list]</td><td>字符类，匹配list中的任意字符</td></tr><tr><td>^[list]</td><td>子父类，匹配不再list中的任意字符</td></tr><tr><td>()</td><td>组，视为一个单独的单元</td></tr><tr><td>竖线</td><td>匹配选择之一</td></tr><tr><td>\</td><td>引用： 从字面上解释元字符</td></tr><tr><td><strong>注意</strong></td><td><strong>下面是判定匹配次数的字符</strong></td></tr><tr><td>*</td><td>匹配0次或者多次</td></tr><tr><td>+</td><td>匹配一次或者多次</td></tr><tr><td>？</td><td>匹配0次或1次</td></tr><tr><td>{n}</td><td>匹配n次</td></tr><tr><td>{0，m}</td><td>最多匹配m次</td></tr><tr><td>{n,}</td><td>最少匹配n次</td></tr><tr><td>{，m}</td><td>最多匹配m次</td></tr><tr><td>{n,m}</td><td>最少n次，最多m次</td></tr><tr><td><strong>注意</strong></td><td><strong>预定义字符类</strong></td></tr><tr><td>[:lower:]</td><td>小写字母</td></tr><tr><td>[:upper:]</td><td>大写字母</td></tr><tr><td>[:alpha:]</td><td>大小写字母</td></tr><tr><td>[:alnum:]</td><td>大小写字母，数字</td></tr><tr><td>[:digit:]</td><td>数字</td></tr><tr><td>[:punct:]</td><td>标点符号</td></tr><tr><td>[:blank:]</td><td>制表符或者空格</td></tr></tbody></table><h6 id="基本和扩展正则表达式"><a href="#基本和扩展正则表达式" class="headerlink" title="基本和扩展正则表达式"></a>基本和扩展正则表达式</h6><h6 id="匹配行和单词"><a href="#匹配行和单词" class="headerlink" title="匹配行和单词"></a>匹配行和单词</h6><p>有些元字符具有定位的作用，这些字符叫做<strong>锚</strong>。例如，harley$仍是匹配字符串harley，但是这个时候只匹配行末尾的字符了。</p><p>如果我们要找以harley开头的行，可以</p><p>grep ‘^harley’ data</p><p>注意，当我们使用含有元字符的表达式时，为了不干扰，最好加上单引号</p><p>通过使用 ^$ ，我们可以很方便的查找空行。这个的意思就是既找行首又找行尾，只有空行才满足这个条件。</p><p>例如： grep ‘^$’ data | wc -l</p><p>如果我们要找 某个字符位于开头的，可以用 &lt;</p><p>例如： grep ‘&lt;kn’ data，这个就是找kn为于单词开头的单词。或者grep ‘kn&gt;‘ data</p><p>在linux系统中，可以采用\b代替&lt;和&gt;，\b相当于边界标记。此外，要尊重客观规律，不能把开头标记和结尾标记都写在开头。</p><p>如果想匹配所有包含字母 H ，后面加a或者A的，可以用 grep ‘H[aA]’ data</p><p>如果想表示一个范围，可以用 [a-b]，例如 [3-6] 或 [a-z]，这应该是按ascii码来的</p><p>grep ‘[^A-Z,a-z]’ data可以用来搜索所有不包含字母的行</p><h6 id="重复使用运算符"><a href="#重复使用运算符" class="headerlink" title="重复使用运算符"></a>重复使用运算符</h6><p>例如，如果我想找首字母是大写H，后面接了0个或者多个字母的行，可以使用</p><p>grep ‘H[[:alpha:]]*’ data</p><p>如果想搜索一个或者多个，可以用+号，</p><p>例如： grep ‘variable[0-9]+’ data</p><p>到现在，我们一直使用单个字符作为查找对象，如果想用多个字符作为查找对象，就需要用到组（小括号）</p><p>例如： (xyz){5},这条命令就是查找重复出现xyz五次的字符串</p><p>如果我们想搜索多个单词，可以用 | 分隔开来。</p><p>例如： grep ‘(cat | dog | bird) ‘ data</p><p>如果我们想搜索有特殊含义的元字符，可以用(转义字符）把这些字符的含义变成常规字符，如果我们想搜索 \ 本身，那么可以用两个 \</p><p>例如： grep ‘$‘ data</p><h6 id="字典文件"><a href="#字典文件" class="headerlink" title="字典文件"></a>字典文件</h6><p>字典顾名思义，就是许多经常用的单词放到一起，每个单词一行，并且按照字母表顺序排列。一般储存在 /usr/share/dict/words中。</p><p>利用这个文件，我们就可以很方便的查找单词。例如，那些单词以qu开头并且以y结尾呢？</p><p>grep ‘^qu[a-z]+y$’ /usr/share/dict/words</p><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td>PATH</td><td>设置shell搜索路径</td></tr><tr><td>PS1</td><td>设置标识符</td></tr><tr><td>SHELL</td><td>shell路径</td></tr><tr><td>HISTSIZE</td><td>fc中最大保存的指令数</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>开始使用unix</title>
    <url>/post/9187.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>当你使用Unix系统的时候，第一件要你做的事便是输入用户标识和口令（账号密码），注意，在Unix中，密码是完全不可见的，甚至连*号都不会出现。</p><p>登陆之后出现的欢迎界面，这一部分源于一个特殊的初始化文档，这就意味着你可以对文档内容进行修改从而定制化你的初始化界面。</p><p>一旦初始化命令结束执行，Unix将启动shell，并将控制权交给他。这时shell会出现一个提示-称为shell提示，并等待命令。接下来就可以输入各种命令了。</p><p>最终，没有命令时，你可以通过注销结束工作会话，此时shell将停止运行。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>unix基础</title>
    <url>/post/10919.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><ol><li>操作系统有初始化功能，初始化过程只是引导过程的一部分</li></ol><p>引导过程是计算机启动时会运行一个小程序，然后再运行另一个程序，逐层运行，最后运行一个十分复杂的程序，这个程序名字是内核。</p><p>内核是操作系统的核心，因此只要计算机开启，内核边一直运行。</p><p>内核可以分为微内核和单内核两种。单内核较大，运行速度较快，但是由于没有采用模块化设计，维护修改比较困难。而微内核自己只能运行最基本的功能，其他功能要交给服务器去运行（微内核调用的其他程序），微内核速度慢，但适用于定制化的任务，如移动电话。</p><h3 id="unix-内核-使用工具"><a href="#unix-内核-使用工具" class="headerlink" title="unix=内核+使用工具"></a>unix=内核+使用工具</h3><p>只有内核并不能带来很好的用户体验，因此还有许多其他的程序。最重要的是为用户提供计算机界面的程序，shell 和 GUI。</p><p>shell 是一种提供基于文本的界面的程序，也就是平时所说的命令提示符。</p><p>而 GUI（graphical user interface）是使用窗口，鼠标指针，图标等提供图形界面.</p><p>这些工具称为Unix实用工具，有几百个。</p><h3 id="服务器和客户端"><a href="#服务器和客户端" class="headerlink" title="服务器和客户端"></a>服务器和客户端</h3><p>早期由于主机昂贵而终端便宜，所以经常是多个主机连接一个终端。因此服务器和客户端的概念也因此产生。</p><p>提供某种类型的服务的程序叫做服务器，使用服务的程序叫做客户端。例如，但你用键盘键入字符时，是主机而不是终端把字符显示出来，终端只是向主机发出了一个输出字符的请求，然后主机进行解析然后把字符输出</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>单调队列</title>
    <url>/post/8498.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>也就是有一个数列a，要求你求数列b和c，b[i]是a[i]…a[i+w-1]中的最小值，c[i]是最大值。如果a是1,3,-1,-3,5,3,6,7，则b为-1,-3,-3,-3,3,3，c为3,3,5,5,6,7。</p><p>这个问题相当于一个数据流（数列a）在不断地到来，而数据是不断过期的，相当于我们只能保存有限的数据（sliding window中的数据，此题中就是窗口的宽度w），对于到来的查询（此题中查询是每时刻都有的），我们要返回当前滑动窗口中的最大值\最小值。注意，元素是不断过期的。</p><p>解决这个问题可以使用一种叫做单调队列的数据结构，它维护这样一种队列：</p><p>a)从队头到队尾，元素在我们所关注的指标下是递减的（严格递减，而不是非递增），比如查询如果每次问的是窗口内的最小值，那么队列中元素从左至右就应该递增，如果每次问的是窗口内的最大值，则应该递减，依此类推。这是为了保证每次查询只需要取队头元素。</p><p>b)从队头到队尾，元素对应的时刻（此题中是该元素在数列a中的下标）是递增的，但不要求连续，这是为了保证最左面的元素总是最先过期，且每当有新元素来临的时候一定是插入队尾。</p><p>满足以上两点的队列就是单调队列，首先，只有第一个元素的序列一定是单调队列。</p><p>那么怎么维护这个单调队列呢？无非是处理插入和查询两个操作。</p><p>对于插入，由于性质b，因此来的新元素插入到队列的最后就能维持b)继续成立。但是为了维护a)的成立，即元素在我们关注的指标下递减，从队尾插入新元素的时候可能要删除队尾的一些元素，具体说来就是，找到第一个大于（在所关注指标下）新元素的元素，删除其后所有元素，并将新元素插于其后。因为所有被删除的元素都比新元素要小，而且比新元素要旧，因此在以后的任何查询中都不可能成为答案，所以可以放心删除。</p><p>对于查询，由于性质b，因此所有该时刻过期的元素一定都集中在队头，因此利用查询的时机删除队头所有过期的元素，在不含过期元素后，队头得元素就是查询的答案（性质a），将其返回即可。</p><p>由于每个元素都进队出队一次，因此摊销复杂度为O(n)。</p><p>这个讲的十分清楚，我只是<a href="https://blog.csdn.net/Baoli1008/article/details/47001513" target="_blank" rel="external nofollow noopener noreferrer">搬运</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>双端队列deque</title>
    <url>/post/35848.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>普通的队列有许多限制，例如从一边删除插入，不能使用迭代器（因为空间不连续）等等。<br>双端队列就允许从两边插入</p><p>deque的特点：</p><p>1、支持随机访问，即支持[]以及at()，但是性能没有vector好。</p><p>2、可以在内部进行插入和删除操作，但性能不及list。</p><p>deque和vector的不同之处：</p><p>1、两端都能够快速插入和删除元素。vector只能在尾端进行。</p><p>2、deque的元素存取和迭代器操作会稍微慢一些。因为deque的内部结构会多一个间接过程。</p><p>3、迭代器是特殊的智能指针，而不是一般指针。它需要在不同的区块之间跳转。</p><p>4、deque可以包含更多的元素，其max_size可能更大。因为不止使用一块内存。</p><p>5、不支持对容量和内存分配时机的控制。</p><p>注意：在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector。因为其内部结构显示不需要复制所有元素。</p><p>迭代器属于随机存取迭代器。</p><p>以上都是复制粘贴的，从以上我们可以看出它与vector相似，不同在于它可以从两头插入，这样插入效率高，如果从中间插入，要把很多元素都移动一遍，效率低</p><p>格式： deque&lt;类型&gt; 标识符</p><p>当生成一个 deque 容器时，也可以用由两个迭代器标识的一段元素来初始化它：</p><p>std::deque<a href="std::string">std::string</a> words_part { std::begin(words),std::begin(words) + 5 };</p><p>deque的成员函数：</p><p>deq[ ]：用来访问双向队列中单个的元素。</p><p>deq.front()：返回第一个元素的引用。</p><p>deq.back()：返回最后一个元素的引用。</p><p>deq.push_front(x)：把元素x插入到双向队列的头部。</p><p>deq.pop_front()：弹出双向队列的第一个元素。</p><p>deq.push_back(x)：把元素x插入到双向队列的尾部。</p><p>deq.pop_back()：弹出双向队列的最后一个元素。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何基础</title>
    <url>/post/8050.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h3 id="判断两直线是否相交"><a href="#判断两直线是否相交" class="headerlink" title="判断两直线是否相交"></a>判断两直线是否相交</h3><p>P(x1,y1) Q(x2,y2) 两向量的叉积为 x1<em>y2-x2</em>y1</p><p>如果 p*q&gt;0 p在q的顺时针方向</p><p>p*q&lt;0 p在q的逆时针方向</p><p>=0 ，共线或反向</p><p><img src="/images/20170428234108337.png" alt></p><p>先做一次快速排斥实验，判断下一个线段中 x 较大的端点是否小于另一个线段中 x 较小的段点，若是，则说明两个线段必然没有交点，同理判断下 y</p><p>代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="code"><pre><span class="line">max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>x)&lt;min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>x)<span class="operator"> || </span>max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>y)&lt;min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>y) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">max(<span class="constructor">A</span>.x,<span class="constructor">B</span>.x)&lt;min(<span class="constructor">C</span>.x,<span class="constructor">D</span>.x) <span class="operator">||</span> max(<span class="constructor">A</span>.y,<span class="constructor">B</span>.y)&lt;min(<span class="constructor">C</span>.y,<span class="constructor">C</span>.y)</span></span><br></pre></td></tr></table></figure></div><p>如图所示，如果想判断两线段相交，只需要判断A 和 B在cd两侧即可</p><p>所以只需要 向量<code>AD*CD</code>与 BD*CD异号即可</p><p>如果端点正好在另一条线段上，两者乘积等于0</p><p>如果两者平行，叉积也为0但是可以在快速排斥实验中排除掉</p><p>总代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="code"><pre><span class="line">struct Line &#123;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">x</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="comment">    double y1;</span></span><br><span class="line"><span class="comment">    double x2;</span></span><br><span class="line"><span class="comment">    double y2;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">bool intersection(const Line &amp;l1, const Line &amp;l2)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    //快速排斥实验</span></span><br><span class="line"><span class="comment">    if ((l1.x1 &gt; l1.x2 ? l1.x1 : l1.x2) &lt; (l2.x1 &lt; l2.x2 ? l2.x1 : l2.x2) ||</span></span><br><span class="line"><span class="comment">        (l1.y1 &gt; l1.y2 ? l1.y1 : l1.y2) &lt; (l2.y1 &lt; l2.y2 ? l2.y1 : l2.y2) ||</span></span><br><span class="line"><span class="comment">        (l2.x1 &gt; l2.x2 ? l2.x1 : l2.x2) &lt; (l1.x1 &lt; l1.x2 ? l1.x1 : l1.x2) ||</span></span><br><span class="line"><span class="comment">        (l2.y1 &gt; l2.y2 ? l2.y1 : l2.y2) &lt; (l1.y1 &lt; l1.y2 ? l1.y1 : l1.y2))</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //跨立实验</span></span><br><span class="line"><span class="comment">    if ((((l1.x1 - l2.x1)*(l2.y2 - l2.y1) - (l1.y1 - l2.y1)*(l2.x2 - l2.x1))*</span></span><br><span class="line"><span class="comment">        ((l1.x2 - l2.x1)*(l2.y2 - l2.y1) - (l1.y2 - l2.y1)*(l2.x2 - l2.x1))) &gt; 0 ||</span></span><br><span class="line"><span class="comment">        (((l2.x1 - l1.x1)*(l1.y2 - l1.y1) - (l2.y1 - l1.y1)*(l1.x2 - l1.x1))*</span></span><br><span class="line"><span class="comment">        ((l2.x2 - l1.x1)*(l1.y2 - l1.y1) - (l2.y2 - l1.y1)*(l1.x2 - l1.x1))) &gt; 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/HelloZEX/article/details/80880385" target="_blank" rel="external nofollow noopener noreferrer">参考</a></p><h3 id="判断点是否在多边形内部"><a href="#判断点是否在多边形内部" class="headerlink" title="判断点是否在多边形内部"></a>判断点是否在多边形内部</h3><p>我们先将横纵坐标存在一个数组内</p><p>第一步</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.x &lt; minX <span class="params">||</span> p.x &gt; maxX <span class="params">||</span> p.y &lt; minY <span class="params">||</span> p.y &gt; maxY) &#123;</span><br><span class="line">     /<span class="regexp">/ 这个测试都过不了。。。直接返回false；</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这个测试是画一个四边形</p><p>第二步， 这里我们就要讲一个定理了，以某一点为端点画一条射线，如果穿过图形次数为奇数次，则在图形内，如果是偶数次，在图形外</p><p>为了方便讨论，我们将以x轴正方向做一条射线</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="code"><pre><span class="line">int pnpoly (int nvert, float *vertx, float *verty, float testx, float testy) &#123;</span><br><span class="line">    int <span class="built_in">i</span>, <span class="built_in">j</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">i</span> = <span class="number">0</span>, <span class="built_in">j</span> = nvert<span class="number">-1</span>; <span class="built_in">i</span> &lt; nvert; <span class="built_in">j</span> = <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ( (verty[<span class="built_in">i</span>]&gt;testy) != (verty[<span class="built_in">j</span>]&gt;testy) ) &amp;&amp;</span><br><span class="line">(testx &lt; (vertx[<span class="built_in">j</span>]-vertx[<span class="built_in">i</span>]) * (testy-verty[<span class="built_in">i</span>]) / (verty[<span class="built_in">j</span>]-verty[<span class="built_in">i</span>]) + vertx[<span class="built_in">i</span>]) )</span><br><span class="line">            c = !c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>nvert 是 顶点数量，testx和testy是顶点横纵坐标</p><p>第一段的意思是</p><p>verty[i] &lt;testy &lt; verty[j]</p><p>或者</p><p>verty[j] &lt;testy &lt; verty[i]</p><p>这段代码是用来粗略判断射线是否会经过该边的（没考虑反向和端点）</p><p>第二段是用来判断测试点是否在两点连线之下，这里用了斜率（移下项）</p><p>c=!c;是用来判断奇数次还是偶数次的</p><h3 id="多边形的面积"><a href="#多边形的面积" class="headerlink" title="多边形的面积"></a>多边形的面积</h3><p>s=pow(p<em>(p-a)</em>(p-b)*(p-c),0.5),p=(a+b+c)/2</p><p>凸多边形都可以通过划分变成三角形</p><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>用最少的点把给出的点全部包住</p><h4 id="andraw算法"><a href="#andraw算法" class="headerlink" title="andraw算法"></a>andraw算法</h4><p>把所有点按第一关键字x第二关键字y按从小到大排序，并且删除重复点，得到序列p1…pn</p><p>把p1 p2放入凸包中，凸包中的点用栈来保存</p><p>然后 p1p2和p2p3叉积，如果叉积大于0，则说明p1p2在p2p3右边，说明p3在内部，我们就不选，反之则把它拖入栈中并且要把p2拖出栈中</p><p>这样一直到pn算完成了一遍（下凸包），我们还要从pn反过来到p1（上凸包）,合起来就是完整的凸包</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y==b.y&amp;&amp;a.x&lt;b.x)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">xcross</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b,<span class="built_in">point</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);<span class="comment">//斜率</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">point</span> node[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node,node+n,cmp);</span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">0</span>; num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;xcross(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">        top--;</span><br><span class="line">        top++;</span><br><span class="line">        num[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> basic=top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;basic&amp;&amp;xcross(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">        top--;</span><br><span class="line">        top++;</span><br><span class="line">        num[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> s;</span><br><span class="line">    s=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=dis(node[num[i<span class="number">-1</span>]],node[num[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1lf"</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h3><p>旋转卡壳可以用来求凸包的直径，宽度，两个不相交凸包间最大距离和最小距离等</p><p>如果过凸包上的两个点可以画一对平行直线，使凸包上所有点都夹在两<br>条平行线之间 || 落在平行线上，那么这两个点称为一对对踵点。</p><p><img src="/images/4429524-41118e7599b80fb5.webp" alt><br>其实简单来说就是用一对平行线“卡”住凸包进行旋转。<br>被一对卡壳正好卡住的对应点对称为对踵点，对锺点的具体定义不好说，不过从图上还是比较好理解的。可以证明对鍾点的个数不超过3*n/2</p><p>卡壳有两种情况，第一种是一点对一点， 也就是上图中的</p><p><img src="/images/4429524-6d28ceac8cc2b711.webp" alt></p><p>另一种是一边只有一点，另外一边有两个点</p><p>第二种情况中我们可以发现对鍾点到对应边的距离比其他的要大（不要问我为什么）</p><p>Step1：计算多边形 y 方向上的端点，称之为 ymin 和 ymax。</p><p>Step2：通过 ymin 和 ymax 构造两条水平切线，由于他们已经是一对对<br>踵点，计算他们之间的距离并维护一个当前最大值。</p><p>Step3：同时旋转两条直线到其中一条与多边形的一条边重合。</p><p>Step4：一个新的对踵点对此时产生，计算新的距离，并和当前最大值进<br>行比较，若大于当前最大值。则更新。</p><p>Step5：重复 Step3 和 Step4 的过程直到再次产生新的对踵点对。</p><p>Step6：输出最大直径的对踵点对。</p><p>听起来有点小麻烦，观察可以发现当平行线和多边形的一条边重合的时<br>候最会产生一对新的对踵点<br>这条边的两个端点和原来的点都可能更新最大值</p><p>不妨考虑找离每条边最远的点，显然，这条边的两个端点都和最远点是<br>对踵点<br>特殊情况，如果有两条边是平行的，必须考虑所有的对踵点。<br>旋转卡壳的均摊复杂度 O(n)，但这个问题需要求凸包，复杂度是<br>O(nlogn)</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">void solve2(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ymax=-1e5,ymin=1e5<span class="comment">;</span></span><br><span class="line">    <span class="keyword">int</span> ymaxidx,yminidx<span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">int</span> i=<span class="number">1</span><span class="comment">;i&lt;=num;i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if(<span class="number">ch</span>[i].y&gt;ymax)</span><br><span class="line">        &#123;</span><br><span class="line">            ymax=<span class="number">ch</span>[i].y<span class="comment">;</span></span><br><span class="line">            ymaxidx=i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="number">ch</span>[i].y&lt;ymin)</span><br><span class="line">        &#123;</span><br><span class="line">            ymin=<span class="number">ch</span>[i].y<span class="comment">;</span></span><br><span class="line">            yminidx=i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx])<span class="comment">;</span></span><br><span class="line">    <span class="number">ch</span>[num+<span class="number">1</span>]=<span class="number">ch</span>[<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">int</span> t=<span class="number">1</span><span class="comment">;t&lt;=num;t++,yminidx=yminidx%num+1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        while(xmult(<span class="number">ch</span>[yminidx+<span class="number">1</span>],<span class="number">ch</span>[ymaxidx+<span class="number">1</span>],<span class="number">ch</span>[yminidx])&gt;xmult(<span class="number">ch</span>[yminidx+<span class="number">1</span>],<span class="number">ch</span>[ymaxidx],<span class="number">ch</span>[yminidx]))ymaxidx=ymaxidx%num+<span class="number">1</span><span class="comment">;</span></span><br><span class="line">        ans=max(ans,dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx]))<span class="comment">;</span></span><br><span class="line">        ans=max(ans,dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx+<span class="number">1</span>]))<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,ans)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>数论</title>
    <url>/post/15425.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h3><p>如果a能被b整除，a=b*q，q为一整数记作b|a,a是被除的那个</p><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>如果a和bmod m 是同一个值，则称a和b同余，记作a (三横线） b(mod m)</p><p>例如： 3 和 8 关于5 同余 因为 3%5=3,8%5=3</p><p>重要性质：</p><pre><code>（a+b)%c=a%c+b%c
(a*b)%c=(a%c*b%c)%c
(a^b)%c=(a%c^b)%c</code></pre><h3 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h3><p>任何大于1的正整数n都可以被分解为若干质数的乘积</p><p>约数个数 例如 72=2^3<em>3^2 ，而72有 1 2 3 4 6 8 9 12 18 24 36 72 12个约数<br>，而我可以从2^3 中提取出0个2,1个2，两个2，三个2把其他的数放到另一边，这样我们就可以得到4个约数，3也同理，用一下分配率，就可以得到约数个数为3</em>4=12</p><p>约数和 因为约数是从2和3中随机挑出若干个数进行分配，所以用分配率可得约数和为</p><p>(1+2+2^2+2^3)(1+3+3^2)</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>如果p是质数且a与p互质，则</p><p>a^(p-1)%p=1(a的p-1次方和1关于p同余）</p><p>互质指的是 二者除了1以外没有相同的约数</p><h3 id="求质数的方法"><a href="#求质数的方法" class="headerlink" title="求质数的方法"></a>求质数的方法</h3><p><a href="http://localhost:4000/2020/01/04/%E5%9F%83%E6%B0%8F%E7%AD%9B/" target="_blank" rel="external nofollow noopener noreferrer">埃氏筛</a></p><p><a href="http://localhost:4000/2020/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B/" target="_blank" rel="external nofollow noopener noreferrer">线性筛</a></p><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>概念：表示0到n-1中与n互素的数的个数</p><p>积性函数：如果 m和n互质 ，则f(m<em>n)=f(m)</em>f(n)</p><p>欧拉函数的性质：</p><ol><li>对于质数p f(p)=p-1</li><li>如果n=p^k,则f(n)=p^k-p^k-1</li><li>欧拉函数是积性函数，但不是完全积性函数，当n为质数时成立，当m=2,n为奇数时，f(2*n)=n</li><li>n&gt;2时 f(n)是偶数</li><li>与n互质的数的和为 f(n)*n/2</li><li>n的因数的欧拉函数的和为n</li></ol><h3 id="模意义下的乘法逆元"><a href="#模意义下的乘法逆元" class="headerlink" title="模意义下的乘法逆元"></a>模意义下的乘法逆元</h3><p>例 1/5%7=?</p><p>3*5%7=1,所以1/5的逆元是3，所以1/5%7=3</p><p>逆元的求法</p><p>1 费马小定理</p><p>a*a^-1%p=1,a^p-1%p=1</p><p>可得 a^-1%p=a^p-2%p，然后用快速幂。但是费马小定理要求必须要是素数</p><p>2 线性求逆元（不理解）</p><p>公式：inv(a)=-p/a*inv(p%a)%p;</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">2</span>;<span class="built_in">i</span>&lt;=n;++<span class="built_in">i</span>)&#123;</span><br><span class="line">inv[<span class="built_in">i</span>]=((<span class="number">1</span>ll*(-p/<span class="built_in">i</span>)*inv[p<span class="comment">%i]%p)+p)%p;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>3 扩展欧几里得法</p><p>exgcd</p><p>exgcd用来求解ax+by=c，其中a，b，c都为整数</p><p>裴蜀定理</p><p>不定方程 ax+by=c存在整数解当且仅当gcd(a,b)|c ，当存在一组整数解时，必存在无限组解<br>ax+by=gcd(a,b)=&gt;bx1+a%by1=gcd(b,a%b)=&gt;x=x1,y=x1-(a/b)y1</p><p>x=x1+k<em>b/gcd(a,b) , y= y1-k</em>a/gcd(a,b)</p><p>之后一直求解直到x=1,y=0,这时b=0,所以gcd(a,b)=a,方程一定成立</p><p>在这里我们可以用递归反推，把x=1,y=0带入方程，一步步向上推</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> exgcd(<span class="built_in">int</span> a,<span class="built_in">int</span> b,<span class="built_in">int</span> &amp;x,<span class="built_in">int</span> &amp;y)&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> x1,y1;</span><br><span class="line">exgcd(b,a%b,x1,y1);</span><br><span class="line">x=y1;</span><br><span class="line">y=x1-(a/b)*y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里我们就可以得到第三种方法</p><p>求逆元可以转化为：求关于x的同余方程ax（三横）1 mod b的最小正整数解</p><p>ax%b=1 ax=kb+1</p><p>即 ax-by=1</p><p>最后 x1%b+b即是答案</p><p><a href="https://big-news.cn/2019/05/19/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/" target="_blank" rel="external nofollow noopener noreferrer">可以看这篇博客</a></p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>求C(m,n)%p的值</p><p>可变成 (n!/m!(n-m)!)%p</p><p>之后就用费马小定理求逆元</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> ksm(<span class="built_in">int</span> a,<span class="built_in">int</span> b,<span class="built_in">int</span> p)&#123;</span><br><span class="line"><span class="built_in">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=<span class="number">1</span>ll*ret*a%p;</span><br><span class="line">a=<span class="number">1</span>ll*a*a%p;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> fac[maxn];</span><br><span class="line"><span class="built_in">int</span> inv(<span class="built_in">int</span> x)&#123;</span><br><span class="line"><span class="keyword">return</span> ksm(x,p<span class="number">-2</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> C(<span class="built_in">int</span> n,<span class="built_in">int</span> m)&#123;</span><br><span class="line"><span class="built_in">int</span> qwq=<span class="number">1</span>ll*fac[n]*inv(fac[n-m])%p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>ll*qwq*inv(fac[m])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> n,m;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">fac[i]=<span class="number">1</span>ll*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"%d"</span>,C(n,m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>图论基础</title>
    <url>/post/15201.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>如果图中有权值，称为网，仅在无向图中考虑这些问题，生成树指删去一些边变为树</p><h4 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h4><p>这个也被称为加边法，</p><ol><li>把图中所有边按权值从小到大排序</li><li>把图中n个点看为n个独立的连通块</li><li>选择端点分属两个联通块且权值最小的边，若可选择的边有多条，任选其中一条即可</li><li>重复三，直至只剩一个连通块</li></ol><p>如何存边？</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;x,<span class="keyword">const</span> node&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxm];</span><br></pre></td></tr></table></figure></div><p>其中u代表起点v代表终点，而w代表权值</p><p>采用了并查集的思想</p><p>怎么看加边后是否会变成环？只需要查找u，v的根节点，如果根节点相同则说明加边后 会变成环</p><p>模板，n个点m条边，找最小生成树</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,e,w;</span><br><span class="line">    <span class="keyword">friend</span> opoerator &lt; (<span class="keyword">const</span> node&amp; x,<span class="keyword">const</span> node&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=a;</span><br><span class="line">    <span class="keyword">while</span>(father[r]!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        r=father[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=a;</span><br><span class="line">    <span class="keyword">while</span>(father[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=father[x];</span><br><span class="line">        father[x]=x;</span><br><span class="line">        x=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">int</span> fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        father[fx]=fy;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; nod[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;nod[i].s&gt;&gt;nod[i].e&gt;&gt;nod[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nod.<span class="built_in">begin</span>(),nod.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(join(nod[i].s,nod[i].e))</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">                ans+=nod[i].val;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="prim-算法"><a href="#prim-算法" class="headerlink" title="prim 算法"></a>prim 算法</h4><p>先把点分为两个集合，在最开始的时候第一个集合中只有任意一点，其他点在另外一个集合中，之后选择属于集合一点在集合B中一点在集合A中且与A权值最小的边</p><p>选择时注意只要把最近选的那个点的权值与原来 权值相比就可以了</p><p>我们如何保存边？用邻接矩阵</p><p>在这里我们不用考虑形成环的问题，因为我们是从两个集合中拿边，而想要形成环必定是在一个集合内拿边</p><p>模板</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[maxn][maxn],dis[maxn];<span class="comment">//dis用来记录以i为起点的最小权值</span></span><br><span class="line"><span class="keyword">bool</span> mark[maxn];<span class="comment">//用来判断某点是否加入</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,ox3f,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="keyword">sizeof</span>(mark));</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">1</span>,mi;</span><br><span class="line">    mark[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[v]=<span class="built_in">min</span>(dis[v],g[u][v]);<span class="comment">//将从前的最小值与第u个点的最小值相比</span></span><br><span class="line">        &#125;</span><br><span class="line">        mi=ox3f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mark[v]&amp;&amp;dis[v]&lt;mi)<span class="comment">//找到与A集合中权值最小的</span></span><br><span class="line">            &#123;</span><br><span class="line">                u=v;</span><br><span class="line">                mi=dis[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=mi;</span><br><span class="line">        mark[u]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意，g数组开始要初始化为正无穷</p><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><p>在有向网中，求结点之间边权和最小的路被称为最短路问题</p><h4 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h4><p>多源最短路指的是任意两点之间的最短路径</p><p>一般采用floyd-warshall算法，并且要求图中没有负权环（不然一直绕着环走就可以一直减小）</p><h6 id="flord算法"><a href="#flord算法" class="headerlink" title="flord算法"></a>flord算法</h6><p>用一个二维数组f[i][j]表示从i到j最小路长度，初始化时输入i，j点的路的长度并且f[i][i]=0.</p><p>我们怎么找到最短的路程呢？ 通过观察可以发现，如果我们把一些点作为中转点的话，有可能会让路程变小。例如，我们只用1作为中转，可以得到</p><p>f[i][j]=min(f[i][j],f[i][1]+f[1][j]);</p><p>如果我们拿1和2作为中转点，可以得到</p><p>f[i][j]=min(f[i][j],f[i][1]+f[1][j]);</p><p>f[i][j]=min(f[i][j],f[i][2]+f[2][j]);</p><p>这段代码的意思是我先拿1作为中转，找到1做中转的最小路径之后我再拿2做为中转</p><p>模板<br><img src="/images/%E5%9B%BE%E7%89%8715.png" alt><br>第一层是k，表示以1,2。。。n为中转</p><p>离散上的传递闭包<br><img src="/images/%E5%9B%BE%E7%89%8716.png" alt></p><h4 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h4><p>默认s可达全部点，用dis[i]表示从s到i的最短路径</p><p>它的基本思想是贪心，与prim算法类似</p><p>松弛操作</p><p>每次给目标集合加入一个点时，都要用该点重新判断最小的路径</p><p><img src="/images/%E5%9B%BE%E7%89%8717.png" alt></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dijkstra(int x)</span><br><span class="line">&#123;</span><br><span class="line">	int visit[maxn],<span class="built_in">i</span>,<span class="built_in">j</span>,<span class="built_in">min</span>,next=x;</span><br><span class="line">	memset(visit,<span class="number">0</span>,sizeof(visit));</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=n;++<span class="built_in">i</span>)</span><br><span class="line">		dis[<span class="built_in">i</span>]=map[x][<span class="built_in">i</span>];</span><br><span class="line">	visit[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">2</span>;<span class="built_in">i</span>&lt;=n;++<span class="built_in">i</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">min</span>=INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=n;++<span class="built_in">j</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visit[<span class="built_in">j</span>]&amp;&amp;dis[<span class="built_in">j</span>]&lt;<span class="built_in">min</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">min</span>=dis[<span class="built_in">j</span>];</span><br><span class="line">				next=<span class="built_in">j</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		visit[next]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=n;++<span class="built_in">j</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visit[<span class="built_in">j</span>]&amp;&amp;dis[<span class="built_in">j</span>]&gt;dis[next]+map[next][<span class="built_in">j</span>])</span><br><span class="line">				dis[<span class="built_in">j</span>]=dis[next]+map[next][<span class="built_in">j</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title> 链式前向星</title>
    <url>/post/8072.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>静态链表（链式前向星）是表示图的另外一种方法</p><h3 id="前向星"><a href="#前向星" class="headerlink" title="前向星"></a>前向星</h3><p>前向星也称为邻接数组</p><p>例 <img src="/images/static_linked_list_example.svg" alt></p><p>总共有这几条边</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></div><p>现在将这些边按从小到大排序，变成</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>) --|</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>) --| =&gt; len[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>) --|</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>) =&gt; head[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><p>然后再将数据填入三个数组中，分别是</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">es</span><span class="selector-attr">[]</span> 这个数组是用来记录每条边的终点的，而因为前面已经排好了序，起点很容易知道</span><br><span class="line"><span class="selector-tag">head</span><span class="selector-attr">[]</span> 记录以<span class="selector-tag">i</span>为起点的边在数组中的第一个位置</span><br><span class="line"><span class="selector-tag">len</span><span class="selector-attr">[]</span> 记录以<span class="selector-tag">i</span>为起点的边有多少</span><br></pre></td></tr></table></figure></div><table><thead><tr><th>Array</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>es</td><td>2</td><td>3</td><td>4</td><td>4</td><td>2</td><td>4</td><td>3</td></tr><tr><td>head</td><td>1</td><td>4</td><td>5</td><td>7</td><td></td><td></td><td></td></tr><tr><td>len</td><td>3</td><td>1</td><td>2</td><td>1</td><td></td><td></td><td></td></tr></tbody></table><p>head[2]=4表示2为起点的第一条边在es中的位置为4</p><p>通过这几个函数我们就能很清楚的知道点与边的关系</p><p>例如，我们想知道起点为1的所有边，我们只需要知道len[1]和head[1],这样我们知道起点为1的边有三个且从es[1]开始</p><p>但是前向星要排序，时间复杂度高，因此并不怎么使用</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表通常用vector来实现</p><p>vector<int>g[max_v]，g[i]表示了以i为起点的所有边</int></p><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>其他部分与前向星相同，但是链式前向星多了一个next数组，取消了len数组（因为没有排序了）</p><p>next数组的含义是下一条以i为节点的边在es中的位置，如果这是最后一个节点，则令next[i]=0</p><p>例如</p><table><thead><tr><th>Array</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>es</td><td>2</td><td>4</td><td>4</td><td>3</td><td>3</td><td>2</td><td>4</td></tr><tr><td>head</td><td>1</td><td>2</td><td>3</td><td>5</td><td></td><td></td><td></td></tr><tr><td>next</td><td>4</td><td>0</td><td>6</td><td>7</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>举个例子，我们要求以1为起始边的所有节点</p><p>先从head中知道了第一个以1为起始点的边是1号，所以可以知道（1，2），然后next[1]=4,而4的es=3，所以（1,3）也知道，然后同理</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxn=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxm=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> head[maxn];</span><br><span class="line"><span class="built_in">int</span> n,m,nEdge;      <span class="comment">//n为顶点数，m为边数，nEdge为存储的边的数量</span></span><br><span class="line">                    <span class="comment">//如果边是双向的，那么存储的边的数量就是2m</span></span><br><span class="line">struct NODE<span class="comment">//这里是双向的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> to;</span><br><span class="line">    <span class="built_in">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">NODE edge[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">void</span> addedges(<span class="built_in">int</span> u,<span class="built_in">int</span> v)       <span class="comment">//将边(u,v)添加进去</span></span><br><span class="line">&#123;</span><br><span class="line">    nEdge++;</span><br><span class="line">    edge[nEdge].next=head[u];</span><br><span class="line">    edge[nEdge].to=v;</span><br><span class="line">    head[u]=nEdge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> foreach()       <span class="comment">//遍历边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=head[i];k!=<span class="number">-1</span>;k=edge[k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;edge[k].to&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> Init()</span><br><span class="line">&#123;</span><br><span class="line">    nEdge=<span class="number">-1</span>;</span><br><span class="line">    memset(head,<span class="number">0xff</span>,sizeof(head));</span><br><span class="line">    <span class="built_in">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        addedges(u,v);</span><br><span class="line">        addedges(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/post/61809.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>并查集指的是一个图中的若干个连通分支，任意两个连通分支间没有关系，而每个连通分支内部可以以任意一个点作为根节点，根节点指向它自己，而其他点指向他们的上级节点（因为是连通图，两点之间必定可达），因此只要在同一连通分支，必定可以到同一根节点，从而判断两者可达</p><p>例如：pre[2]=3表示2的上级节点为3，pre[3]=3表示这是一个根节点</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                    <span class="comment">//查找我（x）的掌门</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=x;                      <span class="comment">//委托 r 去找掌门</span></span><br><span class="line">    <span class="keyword">while</span> (pre[r ]!=r)           <span class="comment">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）</span></span><br><span class="line">    r=pre[r ] ;                 <span class="comment">// r 就接着找他的上级，直到找到掌门为止。</span></span><br><span class="line">    <span class="keyword">return</span>  r ;                <span class="comment">//掌门驾到~~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另外如何将两个连通分支合并为一个连通分支呢？</p><p>我们可以把任意一个根节点指向另外一个根节点（因为我们不考虑内部的关系，指向知道是否可达），这样就变为一个连通分支了</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>          <span class="comment">//我想让虚竹和周芷若做朋友</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);         <span class="comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span></span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)                         <span class="comment">//玄慈和灭绝显然不是同一个人</span></span><br><span class="line">    pre[fx ]=fy;                       <span class="comment">//方丈只好委委屈屈地当了师太的手下啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>如果我们要经转很多个上级才能找到根节点，这样显然效率较低，假如我们可以直接让自己的上级是根节点，那就再好不过了</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pre[<span class="number">1000</span> ];</span><br><span class="line"><span class="built_in">int</span> find(<span class="built_in">int</span> x)                                       <span class="comment">//查找根节点</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )                           <span class="comment">//返回根节点 r</span></span><br><span class="line">          r=pre[r];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">int</span> i=x , j ;</span><br><span class="line">    <span class="keyword">while</span>( i != r )                                   <span class="comment">//路径压缩</span></span><br><span class="line">    &#123;</span><br><span class="line">         j = pre[ i ]; 				<span class="comment">// 在改变上级之前用临时变量  j 记录下他的值 </span></span><br><span class="line">         pre[ i ]= r ; 				<span class="comment">//把上级改为根节点</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><p>带权值的并查集只不过是在并查集中加入了一个value[ ]数组<br>value[ ]可以记录很多种东西，不一定是类似距离这种东西，也可以是相对于根节点的状态</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GML"><figure class="iseeu highlight /gml"><table><tr><td class="code"><pre><span class="line">int findfat(int <span class="symbol">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keywords">if</span>(fat[<span class="symbol">x</span>] == <span class="symbol">x</span>) <span class="keywords">return</span> <span class="symbol">x</span>;</span><br><span class="line">	int tmp=fat[<span class="symbol">x</span>];</span><br><span class="line">	fat[<span class="symbol">x</span>]=findfat(fat[<span class="symbol">x</span>]);</span><br><span class="line">	<span class="comment">//在此处修改val比如：</span></span><br><span class="line">	value[<span class="symbol">x</span>]=value[tmp]+<span class="number">1</span>;</span><br><span class="line">	<span class="keywords">return</span> fat[<span class="symbol">x</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/liujian20150808/article/details/50848646" target="_blank" rel="external nofollow noopener noreferrer">参考文章</a></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>int指令</title>
    <url>/post/57453.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>格式： int n，n为中断类型码</p><p>在程序中可以采用int指令调用任何一个中断处理程序</p><p>例如： int 0 ，就会调用除法溢出的处理程序</p><p>所以说，int指令最终的功能与call指令类似，都是调用一段程序</p><p>例 用中断程序实现循环</p><p>要想实现循环，需要知道两个量，第一个是循环次数，第二个是跳转位移。循环次数用cx来保存，跳转位移用bx来保存</p><p>而为了实现loop指令，中断例程需要实现两个功能</p><ol><li>dec cx</li><li>cx=0，则顺序执行，否则，跳转</li></ol><p>代码</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ...安装</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bx</span>,offset s-offset se</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span></span><br><span class="line"><span class="symbol"> s:</span> <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="string">'!'</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">7ch</span>；这时<span class="built_in">ip</span>指向下一条指令即se标号</span><br><span class="line"><span class="symbol">se:</span> <span class="keyword">nop</span></span><br><span class="line"><span class="symbol">lp:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">dec</span> <span class="built_in">cx</span> <span class="comment">;cx--</span></span><br><span class="line">   <span class="keyword">jcxz</span> lpret</span><br><span class="line">   <span class="keyword">add</span> [<span class="built_in">bp</span>+<span class="number">2</span>],<span class="built_in">bx</span>//因为入栈顺序为标志寄存器，<span class="built_in">cs</span>，<span class="built_in">ip</span>，而<span class="keyword">add</span>是与后两个字节<span class="keyword">add</span></span><br><span class="line"><span class="symbol">ipret:</span> <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">     <span class="keyword">iret</span> //没到<span class="built_in">cx</span>=<span class="number">0</span>时也会终止，但这时<span class="built_in">ip</span>就不会回到s标号处</span><br></pre></td></tr></table></figure><h3 id="blos-和-dos中断例程安装过程"><a href="#blos-和-dos中断例程安装过程" class="headerlink" title="blos 和 dos中断例程安装过程"></a>blos 和 dos中断例程安装过程</h3><ol><li><p>开机后，cs：ip初始化为0ffff：0 ，这里有一条跳转指令，自动跳转到blos中的硬件系统检测和安装程序</p></li><li><p>初始化程序将建立blos所支持的中断向量，即把blos提供的中断例程载入中断向量表中</p></li><li><p>硬件检测完之后，调用int 19h进行操作系统的引导，从此把计算机给操作系统控制</p><h3 id="blos中断例程的应用"><a href="#blos中断例程的应用" class="headerlink" title="blos中断例程的应用"></a>blos中断例程的应用</h3><p>int 10h 中断例程是blos提供的，包含多个与屏幕输出有关的子程序</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span></span><br></pre></td></tr></table></figure><p>ah=2表示调用10h中的2号子程序，功能为设置光标的位置，</p><p>bh=0，dh=5，dl=12 设置光标到第0页，第5行，第12列</p><p>mov ah ，9 表示调用第9号子程序，功能为在光标位置显示字符，可以提供显示字符的各种属性</p></li></ol><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">9</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="string">'a'</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">11001010b</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span>//字符重复次数</span><br><span class="line">    <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="dos中断例程的应用"><a href="#dos中断例程的应用" class="headerlink" title="dos中断例程的应用"></a>dos中断例程的应用</h3><p>int 21h就是dos的中断例程，</p><p>我们一直使用的是int 21h中的4ch功能，即程序返回功能</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">4ch</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure><p>ah=4ch表示调用21h中的4ch号子程序</p><p>21h 中的光标位置显示字符功能</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ds:</span><span class="built_in">dx</span> 指向字符串</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>，<span class="number">9</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure><p>调用第九号子程序</p><p>dh中放行号，dl中放列号</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>内中断</title>
    <url>/post/44914.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>一般cpu都有一种能力，就是接受cpu内部或外部发来的信号，停止当前程序而取执行其他的程序。这种信息叫做中断信息，中断信息指的是cpu接受到这种信息后立刻处理这个信息。接受到这个信息后cpu会交给专门的程序去处理，叫做中断处理程序</p><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>内中断指的是中断信息来自cpu内部。当cpu接受到相应几种情况时，会产生相应的中断信息</p><ol><li>除法错误 例如 ，div除法溢出</li><li>单步执行</li><li>执行into指令</li><li>执行int 指令</li></ol><p>我们先不需要了解具体含义。为了更方便的知道到底属于那种中断信息，8086cpu用了一个字节的中断类型码来确定。</p><ol><li>除法错误 0</li><li>单步执行 1</li><li>执行into指令 4</li><li>int： int n ，n就是中断类型码</li></ol><p>cpu根据cs:ip知道程序的入口，所以中断类型码中必定有cs:ip的信息，可cpu如何根据8位的类型吗知道程序的入口呢？</p><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>cpu通过中断类型码找到中断向量表，而中断向量表中就保存着程序的入口。中断向量表在内存中保存。中断内存表位于0000:0000 到 0000:03ff 1024个字节中</p><h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>找到cs：ip的过程叫做中断过程。</p><p>cpu收到中断信息后，要对中断信息进行处理。但是完成中断程序之后还要返回，就像call和ret一样。所以总过程如下</p><ol><li>获得中断类型码</li><li>标志寄存器的值入栈（因为中断过程会改变标志寄存器的值）</li><li>设置标志寄存器第8位和第九位的值为0</li><li>cs入栈</li><li>ip入栈</li><li>设置cs：ip</li></ol><p>更简洁的说明</p><ol><li>获得 中断类型码 n</li><li>pushf</li><li>tf=0 if=0</li><li>push cs</li><li>push ip</li><li>ip=n<em>4，cs=n</em>4+2</li></ol><h3 id="iret指令"><a href="#iret指令" class="headerlink" title="iret指令"></a>iret指令</h3><p>中断处理程序用iret进行返回</p><p>内容</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">popf</span><br></pre></td></tr></table></figure></div><p>这个正好与进栈顺序相反</p><h3 id="除法错误中断的处理"><a href="#除法错误中断的处理" class="headerlink" title="除法错误中断的处理"></a>除法错误中断的处理</h3><p>cpu如果产生除法溢出错误，将会产生中断类型码为0的中断信息。引发中断过程。然后中断处理程序会返回 divide overflow 再返回到主程序中</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span> do0安装程序</span><br><span class="line">     设置中断向量表</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00h</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol"> do0:</span> 显示字符串“overflow！”</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意：do0也要返回</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>用movsb指令，将do0的代码送入0:200处</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> 设置<span class="built_in">es</span>:<span class="built_in">di</span>指向目的地址</span><br><span class="line">     设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向源地址</span><br><span class="line">     设置传输长度</span><br><span class="line">     设置传输方向为正</span><br><span class="line">     <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line">     </span><br><span class="line">     设置中断表</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>我们如何知道do0代码长度？</p><p>可以用编译器来知道do0的长度</p><p><code>mov cx,offset do0end-offset do0</code></p><p>“-”是编译器识别的符号，编译器可以用它来做两个常数的减法</p><p>例如 mov ax,(5+3)*5/10 被编译器识别为 mov ax，4</p><h3 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h3><p>do0的主要任务是显示字符串</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">do0:</span> 设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向字符串</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">9</span></span><br><span class="line"><span class="symbol">  s:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">do0end:</span><span class="keyword">nop</span></span><br></pre></td></tr></table></figure><p>这个程序看起来对，实际上有问题，因为程序执行完后内存立刻被释放，其中保存的内容也可能被其他的程序覆盖。正确的程序如下</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="symbol">do0:</span> <span class="keyword">jmp</span> short do0start</span><br><span class="line">   <span class="built_in">db</span> <span class="string">"overflow!"</span></span><br><span class="line"><span class="symbol">do0start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">202h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">9</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span>//用<span class="keyword">iret</span>也可以，用的话表示还会返回主程序中</span><br><span class="line"><span class="symbol">do0end:</span> <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h3><p>现在do0的入口为 0:200 ,写入中断向量表的0号表项中。使do0成为0号中断处理程序<br>0号表项地址为0:0 ，其中0:0存放偏移地址，0:2存放段地址。程序如下</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>cpu执行完一条指令后，如果检测到tf=1，则产生单步中断，单步中断类型码为1，过程如下</p><ol><li>获得中断类型码</li><li>标志寄存器入栈，tf if设置为0</li><li>cs，ip入栈</li><li>ip=1<em>4 cs=1</em>4+2</li></ol><p>cpu为什么要提供单步中断呢？在debug的t命令中，为什么执行完一条 指令后，能够实时的反映寄存器的状态？这便是cpu单步中断导致可以一条条指令执行</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>df标志和传送指令</title>
    <url>/post/28579.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>flag第十位是df，方向标志位，在串处理指令中，控制每次操作后si，di的增减</p><p>df=0，每次操作后都是si，di增</p><p>df=1，减</p><h4 id="串传送指令"><a href="#串传送指令" class="headerlink" title="串传送指令"></a>串传送指令</h4><h5 id="movsb"><a href="#movsb" class="headerlink" title="movsb"></a>movsb</h5><p>格式： movsb</p><p>功能：</p><ol><li>es<em>16+di=ds</em>16+si</li><li>如果df=0，则 si=si+1，di=di+1，等于一相反</li></ol><p>汇编语言描述</p><ol><li>mov se:[di],byte ptr ds:[si] （汇编不支持这样的指令）</li><li>如果df=0 inc si inc di else dec si dec di</li></ol><p>movsb的功能是将ds：si中的数据传到 es：di中</p><h5 id="movsw"><a href="#movsw" class="headerlink" title="movsw"></a>movsw</h5><p>格式 movsw</p><p>这个是按字来传送，si和di+2或-2</p><h5 id="rep"><a href="#rep" class="headerlink" title="rep"></a>rep</h5><p>rep movsb</p><p>相当于</p><pre><code>s: movsb
  loop s</code></pre><p>rep的作用是根据cx的值，重复执行后面的串传送指令</p><h4 id="df-设置指令"><a href="#df-设置指令" class="headerlink" title="df 设置指令"></a>df 设置指令</h4><p>cld 指令： 将df设置为0<br>std指令： 将df设置为1</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>检测比较结果的条件转移指令</title>
    <url>/post/57449.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>转移是指它可以修改ip，条件指在某种特定情况下才会修改</p><p>例如 jcxz就是一个条件转移指令，只有在cx=0的情况下才会跳转</p><p>下列转移指令都是根据cmp指令进行的转移</p><h3 id="无符号数情况下的转移"><a href="#无符号数情况下的转移" class="headerlink" title="无符号数情况下的转移"></a>无符号数情况下的转移</h3><table><thead><tr><th>指令</th><th>含义</th><th>检测的标志位</th></tr></thead><tbody><tr><td>je</td><td>等于则转移</td><td>zf=1</td></tr><tr><td>jne</td><td>不等于则转移</td><td>zf=0</td></tr><tr><td>jb</td><td>小于则转移</td><td>cf=1</td></tr><tr><td>jnb</td><td>大于等于则转移</td><td>cf=0</td></tr><tr><td>ja</td><td>高于则转移</td><td>cf=0且zf=0</td></tr><tr><td>jna</td><td>不高于则转移</td><td>cf=1或zf=1</td></tr></tbody></table><p>记忆方法：第一个字母都是j，代表jump</p><p>e：equal</p><p>ne：not equal</p><p>b：below</p><p>a：above</p><p>不一定要在前面是cmp指令，例如</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">je</span> s</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="symbol">s:</span> <span class="keyword">inc</span> <span class="built_in">ax</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>标志寄存器</title>
    <url>/post/57339.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>标志寄存器16位中只有9位有特殊作用</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>CF</td><td>0</td><td>PF</td><td>0</td><td>AF</td><td>0</td><td>ZF</td><td>SF</td><td>IF</td><td>DF</td><td>OF</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id="ZF"><a href="#ZF" class="headerlink" title="ZF"></a>ZF</h4><p>ZF含义是执行完指令后结果是否为0，为0,ZF=1，不为0,ZF=0</p><p>例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PERL"><figure class="iseeu highlight /perl"><table><tr><td class="code"><pre><span class="line">mov ax,<span class="number">1</span> ;ZF=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">ax</span>,1 </span>;ZF=<span class="number">1</span></span><br></pre></td></tr></table></figure></div><h4 id="PF"><a href="#PF" class="headerlink" title="PF"></a>PF</h4><p>奇偶标志位，它记录相关指令执行后，其结果的所有bit为中1的个数是否为偶数，如果1的个数为偶数，pf=1,反之则为0</p><h4 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h4><p>符号标志位，看结果是否为负，如果为负，则SF=1</p><h4 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h4><p>进位标志位，一般情况下，对无符号数运算时，它记录了超过最高位的值</p><p>例如 ，add 255,255 这时已经超过最高位了，我们已经知道，超过最高位的数据都会被丢失，实际上它被保存在CF中，但只会保存一位</p><p>做减法时，还有可能发生错位，例如，两个8位数据，-4+5，将产生错位。错位后，相当于计算 252+5，超过255，因此会记录，因为无符号数中负数就是255-该值。<strong>小的减大的时会产生借位</strong></p><h4 id="OF"><a href="#OF" class="headerlink" title="OF"></a>OF</h4><p>溢出标志位，在有符号数运算时，可能会产生溢出，即小于最小值或大于最大值，如果超出，就会让OF=1</p><h4 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h4><p>adc是带进位加法指令，它利用了CF位上记录的进位值</p><p>格式 adc 对象1，对象2</p><p>功能 对象1=对象1+对象2+CF</p><p>例</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行后ax=4，adc执行时，相当于计算 ax+1+CF=2+1+1=4</p><p>这个指令有什么意义呢？实际上加法都可以分为两步操作，第一步是低位相加，第二步是高位相加再加上低位的进位，用汇编语言可以表示为</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="keyword">adc</span> <span class="number">ah</span>,<span class="number">bh</span></span><br></pre></td></tr></table></figure><p>这样我们就可以对更大的数据进行运算</p><p>例：计算1EF0001000H+2010001EF0H,结果放在ax（最高16位），bx，cx中<br>计算分三步</p><ol><li>先将低16位相加，完成后，CF记录本次进位值</li><li>再将中16位与CF相加，完成后，CF记录本次相加进位值</li><li>最后将高16位与CF相加<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">001eh</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0f000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">cx</span>,<span class="number">1ef0h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">0020h</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h4><p>带借位减法指令</p><p>格式 sbb 对象1，对象2</p><p>功能： 对象1=对象1-对象2-CF</p><h4 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h4><p>比较指令，相当于减法指令，但是不保存结果，只对标志寄存器产生影响</p><p>格式： cmp 对象1，对象2</p><p>功能： 对象1-对象2，但并不保存结果，对寄存器产生影响</p><p>例：</p><p>cmp ax，bx</p><ol><li><p>ax=bx，则ax-bx=0，zf=1</p></li><li><p>ax！=bx，则zf=0</p></li><li><p>ax&lt;bx, 将产生借位，cf=1</p></li><li><p>ax&gt;=bx, cf=0</p></li><li><p>ax&gt;bx ,不产生借位结果又不为0，所以zf=0，cf=0</p></li><li><p>ax&lt;=bx,可能产生借位结果也可能为0，所以zf=1或cf=1</p></li></ol><p>这是无符号位的，还有有符号位的</p><p>同理</p><ol><li>ax=bx，则zf=1</li><li>ax！=bx，zf=0</li></ol><p>但是这时就不能简单的用sf来判断了，因为sf只是符号标志位，它记录了计算结果的正负，但它并不能判断溢出。所以我们同时还要运用寄存器of来判断溢出</p><p>例： sf=1，of=0. of=0，说明没有溢出，直接用sf判断即可，sf=1说明ax&lt;bx</p><p>sf=1,of=1.这样就说明有溢出，<strong>因此说明是由于溢出导致结果为负，所以真正的结果必然为正</strong>，所以ax&gt;bx</p><p>sf=0,,of=1. 有溢出，ah&lt;bh</p><h4 id="标志寄存器在debug中的表示"><a href="#标志寄存器在debug中的表示" class="headerlink" title="标志寄存器在debug中的表示"></a>标志寄存器在debug中的表示</h4><table><thead><tr><th>标志</th><th>值为1的标记</th><th>值为0的标记</th></tr></thead><tbody><tr><td>of</td><td>ov</td><td>nv</td></tr><tr><td>sf</td><td>ng</td><td>pl</td></tr><tr><td>zf</td><td>zr</td><td>nz</td></tr><tr><td>pf</td><td>pe</td><td>po</td></tr><tr><td>cf</td><td>cy</td><td>nc</td></tr><tr><td>df</td><td>dn</td><td>up</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编语言写函数</title>
    <url>/post/54613.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>例,计算data段第一行的三次方，并储存到第二行上</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">    <span class="built_in">dd</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span></span><br><span class="line"><span class="symbol">  s:</span> <span class="keyword">mov</span> <span class="built_in">bx</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">call</span> cube</span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">di</span>].<span class="number">2</span>,<span class="built_in">dx</span> ；这个的含义是[<span class="built_in">di</span>]的第二个字节</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">4</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">cube:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"> code ends</span><br><span class="line"> end start</span><br></pre></td></tr></table></figure><p>这个程序函数是cube，注意想要跳转就用call，想要返回就用ret。这时返回值存在ax和dx中，参数在bx中，可如果有多个参数，寄存器不够时，可以用栈来传递参数</p><h3 id="用栈传递参数"><a href="#用栈传递参数" class="headerlink" title="用栈传递参数"></a>用栈传递参数</h3><p>例：计算（a-b）^3，a，b为字型数据<br>参数 进入子程序时，栈顶存放ip，后面依次存放a，b<br>结果：（dx：ax）=(a-b)^3<br></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">difcube:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">4</span>] <span class="comment">;将a的值送入栈中</span></span><br><span class="line">      <span class="keyword">sub</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">6</span>] ；减去b的值</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">ret</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><br>ret n的含义为，pop ip add sp，n<p></p><p>而ret 4 的原因是此时栈中有2个数据，要想把栈清空，要移动四个单位（字型）。而push bp ，pop bp 是为了保证bp中的数据没有改变</p><h3 id="寄存器冲突问题"><a href="#寄存器冲突问题" class="headerlink" title="寄存器冲突问题"></a>寄存器冲突问题</h3><p>例 将data段中的字母变为大写，以0结尾<br></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">   <span class="built_in">db</span> <span class="string">'fafdsfs'</span>,<span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">call</span> capital</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">5</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">capital:</span> <span class="keyword">mov</span> <span class="built_in">cl</span>,,[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">jcxz</span> ok</span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">jmp</span> short capital</span><br><span class="line"><span class="symbol">    ok:</span><span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><br>这个程序实际上是有问题的，因为进行一次capital后，cx的值一定为0，直接退出主程序的循环<p></p><p>要解决这个问题，有两种方案</p><ol><li>找另一个没有使用的寄存器</li><li>不要使用会发生冲突的寄存器</li></ol><p>这样实际上是不可能的，例如cx，循环便一定会冲突</p><p>解决方案就是，在进入函数前把所用到寄存器的内容保存起来，结束函数在进行使用</p><p>由此我们可以得到子程序设计的标准</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">子程序开始： 子程序中使用的寄存器入栈</span><br><span class="line">         子程序内容</span><br><span class="line">         子程序所使用寄存器出栈</span><br><span class="line">         返回 （<span class="keyword">ret</span> ，<span class="keyword">retf</span>）</span><br></pre></td></tr></table></figure><p>这里要注意一个问题，当把寄存器内容入栈后，sp会发生改变，如果子程序中也要使用栈要注意地址的变化</p><p>同时还要注意入账和出栈的顺序<br>例<br></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">capital:</span> <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">      <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">cx</span></span><br></pre></td></tr></table></figure><br>后进先出<p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>mul指令</title>
    <url>/post/40583.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>两个相乘的数：</p><p>如果是8位，那么一个默认在al中，另一个在8位寄存器或内存字节单元中，如果是16位，一个在ax中，另一个在16位寄存器或内存字单元中</p><p>结果： 如果是8位，结果默认在ax中，如果是16位，高位默认在dx中，低位在ax中</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>call指令</title>
    <url>/post/18912.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>操作</p><ol><li>将当前的ip或cs压入栈中</li><li>转移</li></ol><p>这里的转移与jmp相同，也有位移和内存两种方式</p><h3 id="根据位移"><a href="#根据位移" class="headerlink" title="根据位移"></a>根据位移</h3><p>call 标号（将ip压入栈中后，转移到标号处进行指令）<br>过程：</p><ol><li>sp+=2，ss*16+sp=ip</li><li>ip=ip+16位位移</li></ol><p>16位位移=标号处地址-call指令后第一个字节的地址</p><p>相当于 push ip，jmp near ptr 标号</p><h3 id="根据目的地址"><a href="#根据目的地址" class="headerlink" title="根据目的地址"></a>根据目的地址</h3><p>call far ptr 实现段间转移</p><p>操作：</p><ol><li>sp-=2</li><li>ss*16+sp=cs</li><li>sp-=2</li><li>ss*16+sp=ip</li><li>cs=标号所在段地址，ip=；标号所在偏移地址</li></ol><p>段内转移一般是根据位移，段间转移一般是根据地址</p><p>如果地址在寄存器中， call reg，ip被修改</p><p>如果地址在内存中</p><p>1 call word ptr 内存地址</p><p>这种是段内转移，相当于 push ip，jmp word ptr</p><p>2 call dword ptr 内存地址</p><p>段间转移 例</p><p>call dword ptr ds：[0] ，这样ds:[0]和ds:[1]是ip ，ds:[2]和ds:[3]是cs</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>ret 和 retf</title>
    <url>/post/29378.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h3><p>ret指令用栈中的数据，修改ip中的内容，从而实现近转移</p><p>过程：</p><ol><li><p>ip=ss*16+sp</p></li><li><p>sp+=2</p></li></ol><p>相当于 pop ip</p><h3 id="retf"><a href="#retf" class="headerlink" title="retf"></a>retf</h3><p>修改cs和ip 的内容，实现远转移<br>过程</p><ol><li>ip=ss*16+sp</li><li>sp+=2</li><li>cs=ss*16+sp</li><li>sp+=2</li></ol><p>相当于 pop ip ，pop cs</p><p>例</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ss</span>:stack</span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这条指令相当于把ip变为0，指向第一条指令</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>jmp进行跳转</title>
    <url>/post/2647.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="根据位移进行的转移"><a href="#根据位移进行的转移" class="headerlink" title="根据位移进行的转移"></a>根据位移进行的转移</h3><p>用jmp进行跳转时，会发现一个奇怪的问题，无论它要跳转到哪里，它的机器码始终不变，为EB03，那么它到底是怎么告诉cpu修改ip地址的呢？</p><p>先回忆一下cpu读取指令的过程</p><ol><li>cs=076a ip=0006，cs：ip指向eb03</li><li>读取指令码eb03到指令缓冲器</li><li>ip=ip+指令长度=0008h，cs：ip指向下一条指令</li><li>cpu执行指令缓冲器中的指令eb03</li><li>执行完缓冲器中的指令后，ip被修改+</li></ol><p>jmp指令并不需要转移的目的地址，但是它是凭借什么转移的呢？这里有个03，正好跳过三个字节之后就是要转移的地址。原来jmp指令只需知道当前指令的下一个指令（因为执行完这条指令后ip会增加）与要跳转的指令的位移就可以了</p><p>jmp short 标号 功能是 ip=ip+8位位移（一字节）</p><p>jmp near ptr 标号 是16位</p><p>jmp far ptr 标号 是段间转移，可以修改cs</p><p>还可以直接 jmp 寄存器1：寄存器2</p><h3 id="根据内存进行的转移"><a href="#根据内存进行的转移" class="headerlink" title="根据内存进行的转移"></a>根据内存进行的转移</h3><p>转移地址再内存中的转移有两种格式</p><ol><li>jmp word ptr（段内转移）</li></ol><p>例 jmp word ptr ds：[0]</p><p>jmp word ptr [bx]</p><p>2.jmp dword ptr (段间转移）后面接两个字，第一个是偏移地址，第二个是段地址</p><p>例 jmp dword ptr ds：[0],0 完成后段地址为0</p><p>注意</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">nop</span></span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,offset s</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,offset s2</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cs</span>:[<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="symbol">   s0:</span> <span class="keyword">jmp</span> short s</span><br><span class="line"><span class="symbol">   s1:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">       <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">   s2:</span> <span class="keyword">jmp</span> short s1</span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这个程序奇怪之处在于运行到mov cs：[di],ax后 s处会变为jmp 0000，这里就要记住jmp传递的是偏移地址，也就是说，jmp short s1这个指令并不是真的跳到s1处，而是往前跳8个字节</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>操作符offset</title>
    <url>/post/59431.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>offset是由编译器处理的符号，它的功能是获得标号的偏移地址</p><p>例</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset start//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">0</span></span><br><span class="line"><span class="symbol">   s:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset s//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">3</span></span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><p>上面的程序中offset获得了start和s的偏移地址0和3</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>dup</title>
    <url>/post/43878.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>dup用来处理重复数据</p><p>例：db 3 dup (0) 这个意思是定义了三个0的字节型数据</p><p>db 3 dup （0,1,2) 定义了九个数据</p><p>db 3 dup (‘abc’,’ABC’)定义18个数据</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>dd</title>
    <url>/post/11051.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>dd是用来定义双字型</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HASKELL"><figure class="iseeu highlight /haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> segment</span></span><br><span class="line">    dd <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> ends</span></span><br></pre></td></tr></table></figure></div><p>要注意dd要占两个字，db一个字节，dw一个字</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编语言数据位置的表达</title>
    <url>/post/12334.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h3 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h3><p>其实就是idata，这种数据执行前在cpu的指令缓冲器中，在汇编指令中直接给出</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>指令要处理的数据在寄存器中，在汇编指令中给出相应寄存器名</p><h3 id="段地址（SA）和偏移地址（EA"><a href="#段地址（SA）和偏移地址（EA" class="headerlink" title="段地址（SA）和偏移地址（EA)"></a>段地址（SA）和偏移地址（EA)</h3><p>这些数据在内存中，在汇编指令中可以用[x]的方式给出</p><h2 id="指令要处理数据有多长"><a href="#指令要处理数据有多长" class="headerlink" title="指令要处理数据有多长"></a>指令要处理数据有多长</h2><p>用寄存器的ax或al可以很方便的说明数据长度，但是如果是内存之间的传递可以用<br>x ptr 的方式确定是字型传递还是字节性传递</p><p>例： mov word ptr ds:[0],1</p><p>mov byte ptr ds:[0],1</p><p>另外，push操作无需指明，因为push只对字进行操作</p><h2 id="结构体的汇编表达"><a href="#结构体的汇编表达" class="headerlink" title="结构体的汇编表达"></a>结构体的汇编表达</h2><p>一般来说，我们可以用[bx+idata+si]的方式来表达结构体中的数据，用bx定位整个结构体，用idata定义某一个数据项，用si确定数据项中的一个元素</p><p>可以简写为 [bx].idata,[bx].idata[si]</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编中的多层循环</title>
    <url>/post/6587.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>因为唯一的用于统计循环次数的寄存器就是cx，所以有多层循环的时候就会碰到循环次数难以记录的问题，以下是一种解决办法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span>//用另一个寄存器来存<span class="built_in">cx</span>的次数</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol"> s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>+<span class="built_in">bx</span>]</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">si</span>+<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">   <span class="keyword">loop</span> s</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>//这里把<span class="built_in">cx</span>次数取出来减一次</span><br><span class="line">   <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure><p>但是寄存器的数量是有限的，如果多次循环可能会导致寄存器不够用，因此可以先在数据段定义一个字型数据，然后直接把循环次数放到里面<br></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> </span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol">  s0:</span> <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">cx</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2</span></span><br><span class="line"><span class="symbol">  s:</span>  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">loop</span> s</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">     <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure><br>此外，还可以定义一个栈，直接用push，pop命令把cx值取出存入<p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>si和di</title>
    <url>/post/38145.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>si和di在8086cpu中的功能与bx类似，si与di不能分为两个8位寄存器来使用</p><p>也就是说 ds：[si]是可以的</p><p>如果不用这些寄存器直接写的话就会出现之前所说的编译器和exe对程序的不同处理</p><p>例 mov ax,[si]在exe中就是 ds：[si]，但是如果是 mov，ax,[1]在exe中就是把ax中的数据放入1中</p><p>甚至可以直接用[bx+si]的方式或[bx+si+idata]的方式来指明内存地址</p><h3 id="不同寻址方式的比较"><a href="#不同寻址方式的比较" class="headerlink" title="不同寻址方式的比较"></a>不同寻址方式的比较</h3><p>[idata]用于一个常量的寻址，直接定位一个内存单元</p><p>[bx]用于一个变量来表示内存地址，间接定位内存单元</p><p>只有bx,bp,di,si具有寻址能力，例如ds:[dx]等都是错误的</p><p>并且这几个寄存器间组合还有要求，只有bx+si,bx+di,bp+si,bp+di这四种情况是正确的</p><p>只要使用bp，它的段寄存器默认为ss</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>字符形式 的数据</title>
    <url>/post/30072.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>首先要知道asc11码</p><p>形式： db ‘…’</p><p>无论多少个单词都只需要单引号</p><p>例 db‘unix’</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>将不同代码放入不同段中</title>
    <url>/post/41840.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>举个栗子</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code <span class="built_in">ds</span>:data <span class="built_in">ss</span>:stack</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0345h</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">20h</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span> //<span class="built_in">ds</span>:<span class="built_in">bx</span>指向data中第一个内存单元</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s0:</span><span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s0</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"> code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>看了这个就差不多了，前面定义的时候要注意不同段对应不同的寄存器，而后面要注意各个段有独自的segment与ends，而且从start开始要把各个段寄存器赋值，以备后面使用（mov ax，data）<strong>注意</strong> mov ds，data是错误的，8086cpu不允许直接把一个数值送入段寄存器中</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>在代码段中使用栈</title>
    <url>/post/44487.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>实际上栈是我们人为定义的一段内存空间，所以先要用dw来申请</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>  //申请<span class="number">6</span>个字的内存空间，栈是由高内存地址到低内存地址，所以栈顶为<span class="built_in">cs</span>：<span class="number">Ch</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">Ch</span></span><br></pre></td></tr></table></figure><p>ss，sp就是前面所说的栈的指针</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>dw</title>
    <url>/post/58986.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>dw即define word，定义字型数据。例如，dw 0123h,0456h,0789h.这样就定义了几个字型数据，那这些数据都在哪里呢，他们的段地址都是从cs开始的，而偏移地址从0开始，也就是说，0123h的偏移地址是0,0456h的偏移地址是2,0789h的偏移地址是6。</p><p>但是这样会带来一个问题，因为前十六个字节是dw所定义的字型数据，所以这样可能使程序的入口出现问题，所以可以</p><pre><code>assume cs:codesg
codesg segment
dw 0123h,0456h,0789h

start: mov bx,0
mov ax,0
mov cx,8
s: add ax,cs:[bx]
add bx,2
loop s
mov ax,4c00h
int 21h

codesg ends
end start</code></pre><p>这里就是加上了一个标号start，这个标号的意思就是确定程序的入口，而最后在end这里还要来一个start，因为end的作用除了确定程序在哪里终止之外，还有一个作用是告诉编译器程序在哪里开始（因为这时一个伪指令）</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编指令学习（待补充）</title>
    <url>/post/47075.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><ul><li>mov 内存地址1：内存地址2。把地址上的数据从2赋值到1</li><li>sub 。。。 数据1-数据2</li><li>add 。。。 +</li><li>inc 寄存器 让寄存器上的数据+1</li><li>dw “define word” 定义字型数据</li><li>and 逻辑与命令，按位进行与运算 可以通过该命令将相应为变为0，其他位不变</li></ul><p>例如：</p><pre><code>mov al,01100011b
and al,00111011b</code></pre><p>执行后al=00100011b</p><ul><li>or 按位进行或运算 前面一个例子，如果是or的话为01111011b，可以通过该命令将相应位变为1，其他为不变</li><li>db，字符型数据</li><li>ptr word ptr,byte ptr ,确定是什么数据</li><li>div 除法指令，被除数要比除数多8位，如果除数为8位，被除数为16位，除数为16位，被除数为32位，被除数可以用dx和ax存放</li></ul><p>如果除数为8位，则用al储存商，ah储存余数，如果除数为16位，则用ax储存商，dx储存余数</p><p>例： div bl 这个就是除数为8位，默认被除数是ax</p><p>div bx 这个除数是16位，则要用dx和ax两个寄存器来储存被除数，先转为16进制，dx储存高位，ax储存低位</p><p>例 计算 100001/100<br>被除数大于65536，因此要用32位 寄存器，100001的16进制是186A1h<br></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>，<span class="number">1h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">86A1h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">100</span></span><br><span class="line"><span class="keyword">div</span> <span class="built_in">bx</span></span><br></pre></td></tr></table></figure><p></p><ul><li>diwdw（这不是关键字，这是一个子程序） 进行不会产生除法溢出的运算，被除数为dword型，除数为word型，结果为dword型</li></ul><p>参数： ax=dword 型数据低十六位</p><pre><code>dx=高十六位

cx=除数</code></pre><p>返回：dx=结果高十六位，ax=结果低十六位 cx=余数</p><p>原理（公式）：x/n=int(h/n)<em>65536+[rem(h/n)</em>65536+l]/n</p><p>x：被除数 ， n：除数 h :x高十六位 ，l :x低十六位，int（）:取商，例 int（38/10)=3,rem()：取余数</p><ul><li>dd 双字型</li><li>dup 用于数据的重复</li><li>jmp 用于跳转</li><li>jcxz 格式 jcxz 标号（如果cx=0，则跳转到标号处运行） 这是短指令</li><li>ret 用栈数据修改ip</li><li>retf 用栈数据修改cs和ip</li><li>call 先把ip存入栈，再跳转</li><li>call far ptr 先存 ip，再存cs，再跳转</li><li>call word ptr 根据内存</li><li>mul 乘法指令</li><li>offset 获取标号的偏移地址</li><li>adc 带进位加法指令</li><li>sbb 带借位减法指令</li><li>cmp 比较指令</li><li>j… 例 je ja jb 带条件跳转指令</li><li>movsb， movsw ，串传送指令</li><li>rep 根据cx的值，重复执行串传送指令</li><li>cld df=0</li><li>std df=1</li><li>pushf，将标志寄存器的值压入栈</li><li>popf，将标志寄存器的值弹出栈</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>debug和源程序对指令的不同处理</title>
    <url>/post/54300.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3><a href="#" class="headerlink" title="[]"></a>[]</h3><p>debug程序中[0]表示 ds：0处的数据进行处理</p><p>而源程序中表示把0这个数据给要处理的数据</p><p>例 mov ax,[0]在debug中表示把ds：0处元素给ax，而在源程序中表示把0给ax</p><p>在程序中，可以直接使用段寄存器加偏移地址来确定访问的元素，例如：ds：[bx],cs:[bx],ss:[bx]等</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>[bx]和loop</title>
    <url>/post/3320.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h3><p>mov ax,[bx]</p><p>这个的意思是把ds：bx处的内容放入ax中</p><p>mov [bx],ax</p><p>这个的意思是把ax中的内容放入 地址ds：bx处</p><h3 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h3><p>实际上还有更加灵活的方式指明内存地址，就是bx后加一个数据，这个数据可以是常数，也可以是变量</p><p>例 mov ax,ds:[bx+200]，也可以直接写为ds：200[bx]</p><p>这种处理方式可以方便的处理数组</p><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>格式：loop+标识符</p><p>执行过程：执行到loop时，先让cx-=1,再判断cx中的值，不为0则转至标号处继续执行，为0则进行下一步操作，寄存器cx用来储存循环次数</p><p>例</p><pre><code>mov cx,3
mov ax,2
s: add ax,ax
  loop s</code></pre><p>这段程序的作用是计算2的三次方，首先让循环次数为3，ax=2，再从s处开始循环，当cx=0时退出，即进行3次</p><h3 id="用debug跟踪loop指令"><a href="#用debug跟踪loop指令" class="headerlink" title="用debug跟踪loop指令"></a>用debug跟踪loop指令</h3><p>tip：汇编程序中，数据不能以字母开头，所以如A231h等等前面都要加一个零</p><p>如果想直接结束循环可以用p命令，如果用t命令的话，只会结束这一次循环</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>程序执行过程的跟踪</title>
    <url>/post/7564.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>运用debug +程序名进入debug过程</p><p>例如 debug 1.exe</p><p>程序开始都是从0000的偏移地址开始的，设段地址为A，而程序开始有一段不做该程序内容，而有其他用途。这段程序占256个字节，叫psp，之后段地址偏移10h，所以真正的程序是从A+10:0 开始的（256个字节在16进制中是10，而A也是用16进制表示的）</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>从asm到exe</title>
    <url>/post/28954.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>先要有masm.exe和link.exe，然后输入masm+程序名和link+程序名</p><p>或者masm+盘符+程序名，可以省略中间过程，节省时间<br>例：masm c:\1.asm</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编的第一个程序</title>
    <url>/post/48220.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>编译器中，包含两种指令，一种是汇编指令，一种是伪指令。伪指令是给编译器看的，最终不会被cpu执行。先了解三个最为基础的伪指令</p><ul><li>XXX segment，XXX ends，这两个是配套使用的。功能是定义一个代码段，一个段必须要有一个名称标识（XXX是也）</li></ul><p>例如codesg segment ，codesg ends</p><ul><li>assume</li></ul><p>这条指令作用是假设某一寄存器和程序中的某一个用segment和ends定义的段相关联，写在最开头。</p><ul><li>end</li></ul><p>没什么特别的，程序的结束标识，不写程序不知道在哪里结束</p><h3 id="一个程序"><a href="#一个程序" class="headerlink" title="一个程序"></a>一个程序</h3><pre><code>assume cs: codesg
codesg segment
    mov ax,0123
    mov bx,0456
    add ax,bx
    mov ax,4c00
    int 21
codesg ends
end</code></pre><h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>在单任务操作系统上，一次只可以执行一个程序，那么当我们写的这个程序执行完之后，还要把cpu控制权交给dos，而mov ax，4c00 和 int 21 就是做这个工作的</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>栈.                                      </title>
    <url>/post/51491.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>栈是一段连续的内存空间，这个空间的特殊性在于，最后进入这个空间的数据，最先出去</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过ss sp 两个寄存器确定了一个栈顶指针，然后随着一些操作，这个指针会向上向下移动<br>例如 push ax，这条指令会将ax中的内容运到栈中，然后sp-2。<strong>注意</strong>，栈顶地址为低地址，栈底地址为高地址，因此增加元素会使sp值减小</p><p>在栈为空的时候，偏移地址为栈底地址加2，例如栈底为000F，则此时偏移地址为10，在拉一个元素进栈后，偏移地址为000E，恰好是数据最高位（一个数据一个字，两个字节，栈底为000F，用了两个空间，因此此时元素到了000E，恰好sp也是000E</p><h3 id="超界问题"><a href="#超界问题" class="headerlink" title="超界问题"></a>超界问题</h3><p>8086cpu并没有特定的机制来检查我们是否超界，只能够靠自己小心，超界是一个十分严重的问题，因为既然这一段被分配为栈了，说明其他的内存有其他的用途，如果超界，可能会干扰其他程序的运行。要注意，栈的范围最大是0到ffff即2的16次方字节</p><h3 id="push-pop-命令"><a href="#push-pop-命令" class="headerlink" title="push pop 命令"></a>push pop 命令</h3><p>push 寄存器 pop 寄存器<br>也可以是push内存地址，pop内存地址</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>debug</title>
    <url>/post/41129.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>这里列举几个debug的基本命令</p><h4 id="r"><a href="#r" class="headerlink" title="r"></a>r</h4><p>用来查看此时寄存器内的数值和下一步将要执行的命令<br>r 还可以接寄存器，用于修改寄存器内的内容<br>例：r ax 这样会出现ax的内容和一个冒号，然后就可以输入数据修改了</p><h3 id="d"><a href="#d" class="headerlink" title="d"></a>d</h3><p>格式：d 段地址：偏移地址<br>作用：列举出该地址下的机器码<br>例 d 1000:0,这样子将会列举从1000:0 到1000:7f的所有内容</p><h3 id="e"><a href="#e" class="headerlink" title="e"></a>e</h3><p>格式：e 段地址：偏移地址<br>作用：修改改地址下的机器码</p><h3 id="t"><a href="#t" class="headerlink" title="t"></a>t</h3><p>执行cs ip所指向内存地址的命令，直接输入t，不需要输入其他东西</p><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>作用：用汇编语言输入指令到内存上<br>写法： a 段地址：偏移地址<br>例： a 1000:0<br>输出1000：0 （input）mov ax，1<br>然后1000:0 到1000:3 就会输入这条指令了，之后将cs ip地址设置一下，然后用t指令运行</p><h3 id="u"><a href="#u" class="headerlink" title="u"></a>u</h3><p>作用：查看某地址下的汇编程序<br>写法： u 段地址：偏移地址<br>例 u 1000:0<br>然后就会输出1000:0 开始有的汇编指令了</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>树状数组和线段树</title>
    <url>/post/58481.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h3 id="lowbit函数"><a href="#lowbit函数" class="headerlink" title="lowbit函数"></a>lowbit函数</h3><p>lowbit函数指的是将元素与元素的补码按位与，即a&amp;-a，这个值返回的是从右数第一个1开始的值</p><p>例如 6&amp;-6， 6二进制位为110，所以6的lowbit函数值为10，即十进制下的二</p><pre><code>ll lowbit(ll num)
{
    return num&amp;-num;
}</code></pre><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>首先我们可以把一整个数组分为若干小部分，然后让这几个小部分叠加就可以得到数组总的和。例如，我想求a[91],我可以先求c[88],发现c[88]管理2个数，再找c[86]，这样一直进行下去就可以了。</p><p>c又是什么呢？例如c[6]，它的lowbit函数为2，因此它管理两位数，所以c[6]=a[5]+a[6]</p><p>奇数位的c[i]只有他自己，而偶数位c[i]为2的k次方</p><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">add</span>(int <span class="keyword">x</span>, int k) &#123;</span><br><span class="line">  while (<span class="keyword">x</span> &lt;= n) &#123;  //不能越界</span><br><span class="line">    <span class="keyword">c</span>[<span class="keyword">x</span>] = <span class="keyword">c</span>[<span class="keyword">x</span>] + k<span class="comment">;</span></span><br><span class="line"><span class="comment">    x = x + lowbit(x);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这个函数是把a[x]加上k，小于x的c不用修改</p><p>关键是x=x+lowbit(x)<br><img src="/images/1103198-20180725163149813-311841231.png" alt><br>从此图中我们可以看出，要想求偶数位节点大小，需要将所有子节点加起来，先要加自己和比自己小一位的奇数，再加上所有i+lowbit(i)=8的偶数</p><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GML"><figure class="iseeu highlight /gml"><table><tr><td class="code"><pre><span class="line">int getsum(int <span class="symbol">x</span>) &#123;  <span class="comment">// a[1]……a[x]的和</span></span><br><span class="line">  int ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keywords">while</span> (<span class="symbol">x</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ans = ans + c[<span class="symbol">x</span>];</span><br><span class="line">    <span class="symbol">x</span> = <span class="symbol">x</span> - lowbit(<span class="symbol">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keywords">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">  <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; ++<span class="built_in">i</span>) &#123;</span><br><span class="line">    t[<span class="built_in">i</span>] += a[<span class="built_in">i</span>];</span><br><span class="line">    int <span class="built_in">j</span> = <span class="built_in">i</span> + lowbit(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">j</span> &lt;= n) t[<span class="built_in">j</span>] += t[<span class="built_in">i</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> kth(<span class="built_in">int</span> k) &#123;  <span class="comment">//权值树状数组查询第k小</span></span><br><span class="line">  <span class="built_in">int</span> cnt = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = log2(n); ~i; --i) &#123;</span><br><span class="line">    ret += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= n || cnt + t[ret] &gt;= k)</span><br><span class="line">      ret -= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cnt += t[ret];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>含义：线段树指的是将一个区间不断二分所形成的一个二叉树，根结点代表arr[0:N]区间所对应的信息，接着根结点被分为两个子树，分别存储arr[0:(N-1)/2]及arr[(N-1)/2+1:N]两个子区间对应的信息</p><p>初始化：注意此处我们对于segmentTree]数组的索引从1开始算起。则对于数组中的任意结点i，其左子结点为<code>2*i</code>，右子结点为<code>2*i + 1</code>，其母结点为i/2。<br><img src="/images/%E5%9B%BE%E7%89%879.png" alt><br><img src="/images/%E5%9B%BE%E7%89%8710.png" alt><br><img src="/images/%E5%9B%BE%E7%89%878.png" alt><br>递归实际意义是先向底层递归，然后从底层向上回溯，p的意思是节点的编号</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> build(<span class="built_in">int</span> s, <span class="built_in">int</span> t, <span class="built_in">int</span> p) &#123;</span><br><span class="line">  <span class="comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">  <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">int</span> m = (s + t) / <span class="number">2</span>;</span><br><span class="line">  build(s, m, p * <span class="number">2</span>), build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p>区间修改指的是把区间内连续多个数同时修改</p><p><img src="/images/%E5%9B%BE%E7%89%8711.png" alt>标记的作用是记录每次、每个节点要更新的值</p><p>另一种写法</p><p><img src="/images/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt></p><p>当使用lazy函数时，会让下一层的数加上相应的数并附上相应懒标记，同时根节点的懒标记将被清除，这样一层层往下就可以让每一个数都加上该值</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span>;</span><br><span class="line">    <span class="built_in">int</span> lz;</span><br><span class="line">&#125;sgm[<span class="built_in">MAX</span>*<span class="number">4</span>];</span><br><span class="line">#define <span class="built_in">mid</span> ((l+r)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">#define lc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">#define rc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">voide lazy(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> l,<span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">/*懒标记的作用是标记当前区间应该加上/减去的值，但是先不直接加，而是进行标记*/</span><br><span class="line">    sgm[lc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[lc].<span class="built_in">sum</span>+=(<span class="built_in">mid</span>-l+<span class="number">1</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].<span class="built_in">sum</span>+=(r-<span class="built_in">mid</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[<span class="built_in">n</span>].lz=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p><img src="/images/%E5%9B%BE%E7%89%8712.png" alt></p><p>这里的push_down就是另一种写法中的lazy</p><p>总代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define lc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">#define rc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">#define <span class="built_in">mid</span> ((l+r)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">#define <span class="built_in">MAX</span> <span class="number">100</span></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span>;</span><br><span class="line">    <span class="built_in">int</span> lz;</span><br><span class="line">&#125;sgm[<span class="built_in">MAX</span>*<span class="number">4</span>];</span><br><span class="line">void lazy(<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sgm[lc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[lc].<span class="built_in">sum</span>+=(<span class="built_in">mid</span>-l+<span class="number">1</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].<span class="built_in">sum</span>+=(r-<span class="built_in">mid</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[<span class="built_in">n</span>].lz=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">void build(<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> a[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=a[l];</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    build(l,<span class="built_in">mid</span>,lc,a);</span><br><span class="line">    build(<span class="built_in">mid</span>+<span class="number">1</span>,r,rc,a);</span><br><span class="line">    sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=sgm[lc].<span class="built_in">sum</span>+sgm[rc].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line">void update(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> L,<span class="built_in">int</span> R,<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>+=(r-l+<span class="number">1</span>)*num;</span><br><span class="line">        sgm[<span class="built_in">n</span>].lz+=num;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy(l,r,<span class="built_in">n</span>);</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(lc,L,R,l,<span class="built_in">mid</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(R&gt;<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(rc,L,R,<span class="built_in">mid</span>+<span class="number">1</span>,r,num);</span><br><span class="line">    &#125;</span><br><span class="line">    sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=sgm[lc].<span class="built_in">sum</span>+sgm[rc].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> ask(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> L,<span class="built_in">int</span> R,<span class="built_in">int</span> l,<span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        return sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy(l,r,<span class="built_in">n</span>);</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=ask(lc,L,R,l,<span class="built_in">mid</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(R&gt;<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=ask(rc,L,R,<span class="built_in">mid</span>+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a[<span class="number">10</span>];</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>,a);</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;sgm[i].<span class="built_in">sum</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    update(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ask(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>字符串之KMP算法</title>
    <url>/post/57671.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="由（扯）来（蛋）"><a href="#由（扯）来（蛋）" class="headerlink" title="由（扯）来（蛋）"></a>由（扯）来（蛋）</h3><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这三人的姓氏命名此算法。</p><h3 id="最长前缀和与后缀和"><a href="#最长前缀和与后缀和" class="headerlink" title="最长前缀和与后缀和"></a>最长前缀和与后缀和</h3><p>例如给出一个字符串ABCDABD<br><img src="/images/331.jpg" alt><br>前缀和就是从前往后数i个，后缀和是从第n-i个数到最后一个，首先我们便要找到每一个字母的最长相同前缀后缀和，然后求next数组，注意，只有一个元素时是不计算前缀后缀的，直接看为0</p><h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>next数组考虑的是除当前字符外的最长相同前缀后缀，实际上就是前一个前缀后缀和，因为把最后一个字母上去之后必定会使后缀和少一个，因此前缀后缀和也会-1，注意next数组中会出现-1，<strong>实际上这个数组就是将原数组整体右移一位，然后在第0位补上-1</strong></p><p><img src="/images/3331.jpg" alt></p><p><img src="/images/3332.jpg" alt></p><h3 id="用next数组进行匹配"><a href="#用next数组进行匹配" class="headerlink" title="用next数组进行匹配"></a>用next数组进行匹配</h3><p>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀 pj-k pj-k+1, …, pj-1 跟文本串 si-k si-k+1, …, si-1 匹配成功，但 pj 跟 si 匹配失败时，因为 next[j] = k，相当于在不包含 pj 的模式串中有最大长度为 k 的相同前缀后缀，即 p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令 j = next[j]，从而让模式串右移 j - next[j] 位，使得模式串的前缀 p0 p1, …, pk-1 对应着文本串 si-k si-k+1, …, si-1，而后让 pk 跟 si 继续匹配。如下图所示：<br><img src="/images/323.jpg" alt></p><p><strong>解释</strong>：因为前缀和后缀和相等，当最后一个匹配失误的时候就可以直接跳到后缀和开始的地方，这样就一下子匹配到了几位数，加快速度，至于合理性 ，K M P 这三个人已经证明过，而具体要跳几位呢？</p><p>比如说你有7个数，前面6个数已经匹配好了，结果第七位出了问题，这时一找next数组，发现第6位前缀和为2，那我们就要跳到第五位上去，找找规律，就是j-next[j]呀，没错，就是要跳这么多位，忘了自己推一下就好了，挺好推的</p><p><strong><em>失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</em></strong></p><h3 id="next数组求法"><a href="#next数组求法" class="headerlink" title="next数组求法"></a>next数组求法</h3><p>这里运用了递归的思想，首先对于前一两个可以直接写出来，然后对于后面的，假如第j个next值我们已经求出来了，那么对于第j+1个，</p><ol><li>如果p[k]=p[j]，则next[j+1]=k+1</li></ol><p>例如<img src="/images/3343.jpg" alt><br>C为p[j]，E为p[j+1]，next[j]=2,则第一，第二个与第五，第六个相同，如果第三个和3七个相同，则最大相同长度就为3，即p[k]=p[j]</p><p>2.如果p[k]!=p[j],则递归找p[next[k]]是否等于p[j]，p[next[next[k]]]是否等于p[j],直到找到或到了开头</p><p>对于第二种情况，也可以通过图来展示<br><img src="/images/3344.jpg" alt><br>现在p[j]!=p[k]，那么肯定要缩小范围，我么已经知道第一个与第二个是匹配的了，那么第五个第六个对应与第一个第二个匹配，但如果那里面没有前后缀的话，你减去一个就相当于破坏了结构（前缀从前往后，后缀也是从前往后，减去一个便要求这这个前缀串里面前几个要和后缀串里面后面几个匹配，因此要求next[k]就是为了里面要匹配，这样只需比较p[next[k]]和p[j]即可），假如中间就碰到了，那么next[j+1]=next[next[k]]+1,如果没碰到，那么next[j+1]=0（一朝回到解放前）</p><p>代码实现：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> GetNext(char* p,<span class="built_in">int</span> next[])  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">int</span> pLen = strlen(p);  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k;  </span><br><span class="line">            ++j;  </span><br><span class="line">            next[j] = k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="nextval"><a href="#nextval" class="headerlink" title="nextval"></a>nextval</h3><p>nextval是next的进阶版。例如某一位是next[5]，但是next[5]和5的字符相同，这样肯定还是不行，所以多比了一次。</p><p>nextval判断方法：在next的基础上,s是用来匹配的串</p><p>s[next[i]] = s[i], 继续比较。如果next[i]和next[next[i]]还是相同，那么要继续比，直到不相同或者过了第一个为止</p><p>s[next[i]] != s[i] , nextval[flag] = next[i]</p><h3 id="匹配（最终代码）"><a href="#匹配（最终代码）" class="headerlink" title="匹配（最终代码）"></a>匹配（最终代码）</h3><p>匹配过程：</p><p>“假设现在文本串S匹配到 i 位置，模式串 P 匹配到 j 位置</p><p>如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符；</p><p>如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j] 位。</p><p>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。”</p><p>例 <img src="/images/3353.png" alt></p><p>例如此时i=10,j=6,此时文本串该位为空格，而匹配串为D，这时不匹配，就要让匹配串移动6-next[6]=4位，我令i=10,j=2,即匹配串为C,这就相当于让匹配位左移4位，而文本对应位不变，于是相当于匹配串右移4位（有种物理相对运动的既视感）</p><p>代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      </span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      </span></span><br><span class="line">            <span class="comment">//next[j]即为j所对应的next值        </span></span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>感到了代码的优美感有没有！</p><p>但是这样还可以优化</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AWK"><figure class="iseeu highlight /awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>优化过后的<span class="keyword">next</span> 数组求法  </span><br><span class="line">void GetNextval(char* p, int <span class="keyword">next</span>[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int pLen = strlen(p);  </span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;  </span><br><span class="line">    int k = -<span class="number">1</span>;  </span><br><span class="line">    int j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">//</span>p[k]表示前缀，p[j]表示后缀    </span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k])  </span><br><span class="line">        &#123;  </span><br><span class="line">            ++j;  </span><br><span class="line">            ++k;  </span><br><span class="line">            <span class="regexp">//</span>较之前<span class="keyword">next</span>数组求法，改动在下面<span class="number">4</span>行  </span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])  </span><br><span class="line">                <span class="keyword">next</span>[j] = k;   <span class="regexp">//</span>之前只有这一行  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="regexp">//</span>因为不能出现p[j] = p[ <span class="keyword">next</span>[j ]]，所以当出现时需要继续递归，k = <span class="keyword">next</span>[k] = <span class="keyword">next</span>[<span class="keyword">next</span>[k]]  </span><br><span class="line">                <span class="keyword">next</span>[j] = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            k = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里有点蒙，就先这样吧</p><p><a href="https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html" target="_blank" rel="external nofollow noopener noreferrer">参考文章（这篇文章真的太好了，生怕你不会）</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串之hash算法</title>
    <url>/post/11491.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="hash基础概念"><a href="#hash基础概念" class="headerlink" title="hash基础概念"></a>hash基础概念</h3><p>但在工程实践中，要查找的关键字往往都不是自然数，即使是自然数也有可能是很大的值。因此，只要我们提前把关键字转换为在固定较小范围内的自然数，就可以实现常数时间的查找。那么问题来了，如何实现该转换关系呢？这就是哈希函数所要完成的工作。</p><p>哈希函数：又称散列函数，是把一段有限二进制串（字符串，整数等）转换为自然数的一种函数。</p><p>哈希值：哈希函数输出的最终结果。</p><p>字符串哈希函数：输入是字符串的哈希函数。</p><p>注：实际上就是用一个函数将字符串转化为整数，然后尽可能使一个整数对应一个字符串</p><p>现在的哈希函数基本上都是满射，多个字符串会对应一个数字，这种情况佳作冲突，为了减小冲突，列举几种方法</p><p><img src="/images/%E5%9B%BE%E7%89%876.png" alt><br>这种方法就是用进制转换的观念，一般用128,但这样十分容易超int型的范围，因此要想办法减小范围，可以用一个较大的数去摸，这时又出现了冲突的问题，那可以用两个数同时去摸，这样用两个数表示一个字符串冲突的几率便大大降低</p><p>BKDRHash算法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BKDR Hash Function</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);<span class="comment">//ox7FFFFFFF代表int型最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&amp;是与运算符，<a href="https://blog.csdn.net/ssdjdk/article/details/90199634" target="_blank" rel="external nofollow noopener noreferrer">详细看这</a></p><p>关于 <a href="https://blog.csdn.net/MyLinChi/article/details/79509455" target="_blank" rel="external nofollow noopener noreferrer">BKDRHash算法可以看</a></p><p>最好用unsigned int 类型，<a href="https://www.cnblogs.com/lailailai/p/4030151.html" target="_blank" rel="external nofollow noopener noreferrer">这样相当于每次hash操作都取了一次模</a></p><p>APhash算法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LISP"><figure class="iseeu highlight /lisp"><table><tr><td class="code"><pre><span class="line">// AP Hash Function</span><br><span class="line">unsigned int APHash(<span class="name">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int hash = 0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    for (i=0; *str<span class="comment">; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if ((<span class="name">i</span> &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= ((<span class="name">hash</span> &lt;&lt; <span class="number">7</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">3</span>))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= (~((<span class="name">hash</span> &lt;&lt; <span class="number">11</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">5</span>)))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return (<span class="name">hash</span> &amp; <span class="number">0</span>x7FFFFFFF)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/MyLinChi/article/details/79508112" target="_blank" rel="external nofollow noopener noreferrer">这篇博客讲的很详细</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/post/55046.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h3><p>无后效性是一个问题可以用动态规划求解的标志之一，理解无后效性对求解动态规划类题目非常重要</p><p>概念：某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响（某度上找的定义）</p><p>理解：无后效性指的是之前做过的事现在还可以继续去做，这便是前一阶段做的事对后一阶段无影响。如果前面做过了后面便不能去做或者做的事受限这便是有后效性</p><p>例：<a href="https://blog.csdn.net/qq_30137611/article/details/77655707" target="_blank" rel="external nofollow noopener noreferrer">这篇博客讲的很清楚</a></p><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p><a href="https://xinhecuican.github.io/2020/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" target="_blank" rel="external nofollow noopener noreferrer">之前的一篇博客</a></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">struct Good&#123;</span><br><span class="line"><span class="code">    int w;</span></span><br><span class="line"><span class="code">    int v;</span></span><br><span class="line">&#125;goods[101];</span><br><span class="line">int dp[<span class="string">101</span>][<span class="symbol">1001</span>];</span><br><span class="line">int n,S;//n表示有n个物品，S表示背包的最大容积</span><br><span class="line">for (i = 1; i <span class="xml"><span class="tag">&lt;<span class="name">=</span> <span class="attr">n</span>; <span class="attr">i</span>++)</span></span></span><br><span class="line"><span class="xml">&#123;</span></span><br><span class="line"><span class="xml">    for (j = S; j &gt;</span>= goods[i].w; j--)</span><br><span class="line"><span class="code">        dp[j] = max(dp[j], dp[j - goods[i].w] + goods[i].v);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这段代码中，之所将j初始化为S，逆序循环更新状态是为了保证在更新dp[j]时，dp[j-goods[i].w]的状态尚未因为本次更新而发生改变，即等价于由</p><p>dp[i-1][j-goods[i].w]转移得到dp[i][j]。保证了更新dp[j]时，dp[j-goods[i].w]是没有放入物品i时的数据dp[i-1][j-goods[i].w]。</p><p>实际上01背包问题同一种思路代码写法有两种，如果s从0开始遍历就不需要逆序，但是从大于w[i]开始就需要逆序</p><p>实际上这里的二维数组可以优化变为一维数组</p><p>dp[i][j] = max{dp[i-1][j-w[i]]+v[i]，dp[i-1][j]，这里的i与i-1实际上是第i个物体与第i-1个物体，而这个可以用数组下标直接代替，这样便可以用一维数组解决背包问题，但是一维数组与二维数组的区别是二维数组保存了前i个物品所可以获得的最大价值，而一维数组只能保存题目要求的s个物品的最大价值，因此用一维还是用二维因题目而异</p><p>dp[j] = max{dp[j]，dp[j-w[i]]+v[i]}。从这个方程中我们可以发现，有两个dp[j]，但是要区分开。等号左边的dp[j]是当前i的状态，右边中括号内的dp[j]是第i-1状态下的值。</p><p>所以为了保证状态的正确转移，我们需要先更新等号左边中的dp[j]（当前状态的dp[j]）。</p><p>代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,maxv;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;maxv;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">1001</span>],v[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxv;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=maxv;k&gt;=w[i];k--)<span class="comment">/*这里是因为当背包体积小于物品体积时不可能成立，相当于if(k&lt;w[i])&#123;dp[i][k]=dp[i-1][k];&#125;*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[k]=<span class="built_in">max</span>(dp[k],dp[k-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[maxv]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>拓展问题</p><p>继续0-1背包问题，如果在上面的问题加上一个限制条件，所选择的物品必须恰好装满背包，否则输出-1。这时数组初始化为负无穷</p><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">int w<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int v<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int maxv;</span><br><span class="line">int n;</span><br><span class="line">int dp<span class="comment">[MAXSIZE]</span><span class="comment">[MAXSIZE]</span>;</span><br><span class="line"></span><br><span class="line">int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &gt; b)</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxv;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w<span class="comment">[i]</span> &gt;&gt; v<span class="comment">[i]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化，当容积为0时，即不能装入，最大价值即为0</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[0]</span> = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化为-1，表示没有装满</span><br><span class="line">    for (int i = 0; i &lt;= n; i++)</span><br><span class="line">    for (int j = 1; j &lt;= maxv; j++)</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[j]</span> = -1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = maxv; j &gt;= w<span class="comment">[i]</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1表示容积为j - w<span class="comment">[i]</span>时没有装满，所以当容积为j，装w<span class="comment">[i]</span>时一定不能装满</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt; dp<span class="comment">[i-1]</span><span class="comment">[j]</span>表示装入物品i时签好装满并且总价值比前i-1个物品的总价值要大</span><br><span class="line">            if (dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1 &amp;&amp; dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt;= dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>)</span><br><span class="line">                dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = w<span class="comment">[i]</span> - 1; j &gt;= 1; j--)</span><br><span class="line">            dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp<span class="comment">[n]</span><span class="comment">[maxv]</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它大致相同，现在dp[i][j]表示的是恰好装j空间时价值的最大值</p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>题目：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for (i = 1; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (j = goods<span class="comment">[i]</span>.w; j &lt;= S; j++)</span><br><span class="line">        dp<span class="comment">[j]</span> = max(dp<span class="comment">[j]</span>, dp<span class="comment">[j - goods<span class="comment">[i]</span>.w]</span> + goods<span class="comment">[i]</span>.v);</span><br><span class="line">&#125;//不是很理解，但是先把模板记下吧</span><br></pre></td></tr></table></figure><p>这个代码和01背包代码十分相似，只有循环方向不同，为什么可以这样做呢？因为01背包要求每个物品只能选一次，因此根据这个式子，有可能会导致多选的就是dp[j - goods[i].w],如果从前往后循环，j-goods[i].w可能是已经选择了当前物品的情况</p><p><a href="https://pangyuworld.github.io/2019/04/03/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/#%E9%A2%98%E7%9B%AE%E7%B1%BB%E5%9E%8B-1" target="_blank" rel="external nofollow noopener noreferrer">可以去看</a></p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>有N种物品和一个容量为V的背包。第 i 种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p>实际上可以转化为01背包，把每一种物品中多件拆开</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="code"><pre><span class="line">int k = n + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; <span class="built_in">i</span>++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (number[<span class="built_in">i</span>]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			w[k] = w[<span class="built_in">i</span>];</span><br><span class="line">			value[k] =value[<span class="built_in">i</span>];</span><br><span class="line">			k++;</span><br><span class="line">			number[<span class="built_in">i</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; <span class="built_in">i</span>++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (int <span class="built_in">j</span> = v; <span class="built_in">j</span> &gt;= w[<span class="built_in">i</span>]; <span class="built_in">j</span>--) &#123;</span><br><span class="line">			f[<span class="built_in">j</span>] = <span class="built_in">max</span>(f[<span class="built_in">j</span>], f[<span class="built_in">j</span> - w[<span class="built_in">i</span>]] + value[<span class="built_in">i</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div><p>但是这样可能导致时间复杂度过高，可以考虑采用二进制思想，每一个数例如7可以用二进制来表示，而这样我们就可以把它拆为3个数，7二进制为111，所以可以拆为100,010,001，这样我们就只需要储存3个数，降低了时间复杂度。但是假如不是正好的话<br>例如13 ，二进制为1101，则可以分解为0110,0001,0010,0100（如果最好不足2^i，则取x-2^i-1)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> num[maxn][<span class="number">2</span>], dp[maxn];</span><br><span class="line"><span class="built_in">int</span> N, V, c, w, n, tot;</span><br><span class="line">memset(dp, <span class="number">0</span>, sizeof dp);</span><br><span class="line">cin &gt;&gt; V &gt;&gt; N; tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; c &gt;&gt; w &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">1</span>; k &lt; n; k&lt;&lt;=<span class="number">1</span>)<span class="comment">//左移求下一个所需二进制数 </span></span><br><span class="line">	&#123;</span><br><span class="line">		num[tot][<span class="number">0</span>] = k*c;</span><br><span class="line">		num[tot++][<span class="number">1</span>] = k*w;<span class="comment">//注意这时我们把若干物体看为1个物体，它的总重量也要变</span></span><br><span class="line">		n -= k;</span><br><span class="line">	&#125;</span><br><span class="line">	num[tot][<span class="number">0</span>] = n*c;</span><br><span class="line">	num[tot++][<span class="number">1</span>] = n*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; tot; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = V; j &gt;= num[i][<span class="number">0</span>]; --j)</span><br><span class="line">		dp[j] = max(dp[j], dp[j-num[i][<span class="number">0</span>]]+num[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索和广度优先搜索</title>
    <url>/post/37663.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>基本思想：它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念</p><p>例<img src="/images/%E5%9B%BE%E7%89%871.png" alt></p><p>V0-&gt;V1-&gt;V4-&gt;V3-&gt;V5-&gt;V6,先从v0到V1，再从V1到V4，发现到了终点，就退回到V1继续寻找</p><p>代码</p><p>注意恢复初始状态十分重要，在一种情况走不了的情况下它可以使其恢复初始状态试下一条路</p><p><img src="/images/%E5%9B%BE%E7%89%872.png" alt></p><p>例题：<img src="/images/%E5%9B%BE%E7%89%873.png" alt></p><p>遍历连通图，能否从v0到v6</p><p>答案<img src="/images/%E5%9B%BE%E7%89%874.png" alt></p><p>说明，重要的便是模板，先判断当前情况是否满足，如果满足则退出，不满足则遍历所有情况，如果某一位置到了头便会返回false，然后返回到分叉点，搜索下一步（遍历作用在这），而最后一定要回到初始状态，因为别的搜索也可能用</p><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">广度优先搜索是最简便的图的搜索算法之一，别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中</span><br></pre></td></tr></table></figure></div><p>模板<br><img src="/images/%E5%9B%BE%E7%89%875.png" alt></p><p>说明：从某一个起始节点开始，看是否满足，如果不满足， 遍历所有可能的情况，这里便是tt，如果tt存在，那么就把它送入队列中，之后继续遍历可能情况，这里需要两个数组，一个数组是用来确定这点是否已经走过，另外一个数组是用来记录步数的。<a href="https://blog.csdn.net/freezhanacmore/article/details/8168265" target="_blank" rel="external nofollow noopener noreferrer">另外，有些题可能会导致数组超过范围，这时就要写一个判断条件排除掉越界的</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>scanf printf</title>
    <url>/post/46925.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>格式：scanf(const char *format, …)</p><p>format – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。</p><p>format 说明符形式为:</p><p>[=%[*][width][modifiers]type=]</p><p><code>*</code>这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。</p><p>width 这指定了在当前读取操作中读取的最大字符数。</p><p>modifiers 为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）</p><p>type 一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格</p><table><thead><tr><th>符号</th><th>作用</th><th>具体含义</th></tr></thead><tbody><tr><td>%a、%A</td><td>读入一个浮点值(仅 C99 有效)</td><td>float*</td></tr><tr><td>%c</td><td>单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td><td>char *</td></tr><tr><td>%d</td><td>十进制整数：数字前面的 + 或 - 号是可选的。</td><td>int *</td></tr><tr><td>%e、%E、%f、%F、%g、%G</td><td>浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4</td><td>float *</td></tr><tr><td>%i</td><td>读入十进制，八进制，十六进制整数 。</td><td>int *</td></tr><tr><td>%o</td><td>八进制整数。</td><td>int *</td></tr><tr><td>%s</td><td>字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td><td>char *</td></tr><tr><td>%u</td><td>无符号的十进制整数。</td><td>unsigned int *</td></tr></tbody></table><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>scanf读入数据时碰到空白符（空白符：指空格符、制表符、回车符）就会停止函数，例如 你输入 1\n ，这个时候scanf只会读入1，\n留在了缓冲区，但是这样会导致十分严重的问题，所以scanf还有一个特性，<strong>忽略在数据之前的空白符</strong>，而这样当你读取完之后，缓冲区中一般还有一个空白符，如果这个时候你用了”%c”，那么%c会毫不犹豫的把这个空白字符读入，%c是读入一个字符，无论这个字符是什么。%s就会忽略前面的空白符</p><p>这里有一个相对有用的方法 scanf（”%d\n”,…)这样就会在读入一个整数的同时把后面的\n也读入，但是如果不是换行符而是空格那就熟手无策了。</p><p>另外还有一种函数gets()，这个函数除了换行符其它一概不管，并且他会把换行符吃掉（变成NULL）</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>格式 printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p><p>声明 printf(const char *format, …)</p><p>format中有这几种：%[标志][最小宽度][.精度][类型长度]类型</p><h5><a href="#" class="headerlink" title="%"></a>%</h5><table><thead><tr><th>格式字符</th><th>意义</th></tr></thead><tbody><tr><td>d</td><td>以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td>o</td><td>以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td>x,X</td><td>以十六进制形式输出无符号整数(不输出前缀Ox)</td></tr><tr><td>u</td><td>以十进制形式输出无符号整数</td></tr><tr><td>f</td><td>以小数形式输出单、双精度实数</td></tr><tr><td>e,E</td><td>以指数形式输出单、双精度实数</td></tr><tr><td>g,G</td><td>以%f或%e中较短的输出宽度输出单、双精度实数</td></tr><tr><td>c</td><td>输出单个字符</td></tr><tr><td>s</td><td>输出字符串</td></tr><tr><td>p</td><td>输出指针地址</td></tr><tr><td>lu</td><td>32位无符号整数</td></tr><tr><td>llu</td><td>64位无符号整数</td></tr></tbody></table><h5 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h5><table><thead><tr><th>字符</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>-</td><td>减号</td><td>结果左对齐，右边填空格。默认是右对齐，左边填空格。</td></tr><tr><td>+</td><td>加号</td><td>输出符号(正号或负号)</td></tr><tr><td>space</td><td>空格</td><td>输出值为正时加上空格，为负时加上负号</td></tr><tr><td>#</td><td>井号</td><td>type是o、x、X时，增加前缀0、0x、0X。type是a、A、e、E、f、g、G时，一定使用小数点。默认的，如果使用.0控制不输出小数部分，则不输出小数点。type是g、G时，尾部的0保留。</td></tr><tr><td>0</td><td>数字零</td><td>将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用“-”）</td></tr></tbody></table><p>示例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LSL"><figure class="iseeu highlight /lsl"><table><tr><td class="code"><pre><span class="line">printf(<span class="string">"%5d<span class="subst">\n</span>"</span>,<span class="number">1000</span>); 				<span class="comment">//默认右对齐,左边补空格</span></span><br><span class="line">printf(<span class="string">"%-5d<span class="subst">\n</span>"</span>,<span class="number">1000</span>); 				<span class="comment">//左对齐,右边补空格</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%+d %+d<span class="subst">\n</span>"</span>,<span class="number">1000</span>,<span class="number">-1000</span>);		<span class="comment">//输出正负号</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"% d % d<span class="subst">\n</span>"</span>,<span class="number">1000</span>,<span class="number">-1000</span>);		<span class="comment">//正号用空格替代，负号输出</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%x %#x<span class="subst">\n</span>"</span>,<span class="number">1000</span>,<span class="number">1000</span>);		<span class="comment">//输出0x</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%.0f %#.0f<span class="subst">\n</span>"</span>,<span class="number">1000.0</span>,<span class="number">1000.0</span>)<span class="comment">//当小数点后不输出值时依然输出小数点</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%g %#g<span class="subst">\n</span>"</span>,<span class="number">1000.0</span>,<span class="number">1000.0</span>);	<span class="comment">//保留小数点后后的0</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"%05d<span class="subst">\n</span>"</span>,<span class="number">1000</span>);				<span class="comment">//前面补0</span></span><br></pre></td></tr></table></figure></div><h3 id="输出最小宽度"><a href="#输出最小宽度" class="headerlink" title="输出最小宽度"></a>输出最小宽度</h3><p>这是指的小数点前的宽度，如果小于最小宽度，前面补空格，如果大于，那么直接输出。另外如果用了flag中的0，那么前面将会补零</p><table><thead><tr><th>width</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>数值</td><td>十进制整数</td><td>printf(“%06d”,1000);输出:001000</td></tr><tr><td>*</td><td>星号。不显示指明输出最小宽度，而是以星号代替，在printf的输出参数列表中给出</td><td>printf(“%0*d”,6,1000);输出:001000</td></tr></tbody></table><h3 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h3><p>精度以点<code>.</code>开头，后面再接</p><table><thead><tr><th>.precision</th><th>描述</th></tr></thead><tbody><tr><td>.数值</td><td>十进制整数。(1)对于整型（d,i,o,u,x,X）,precision表示输出的最小的数字个数，不足补前导零，超过不截断。(2)对于浮点型（a, A, e, E, f ），precision表示小数点后数值位数，默认为六位，不足补后置0，超过则截断。(3)对于类型说明符g或G，表示可输出的最大有效数字。(4)对于字符串（s），precision表示最大可输出字符数，不足正常输出，超过则截断。precision不显示指定，则默认为0</td></tr><tr><td>.*</td><td>以星号代替数值，类似于width中的*，在输出参数列表中指定精度。</td></tr></tbody></table><p>对于整数型，这个作用与最小宽度作用类似，例如，”%08d” 与 “%.8d”作用是一样的</p><h3 id="类型长度"><a href="#类型长度" class="headerlink" title="类型长度"></a>类型长度</h3><p>printf(“%hhd\n”,’A’); //输出有符号char</p><p>printf(“%hhu\n”,’A’+128); //输出无符号char</p><p>printf(“%hd\n”,32767); //输出有符号短整型short int</p><p>printf(“%hu\n”,65535); //输出无符号短整型unsigned short int</p><p>printf(“%ld\n”,0x7fffffffffffffff); //输出有符号长整型long int</p><p>printf(“%lu\n”,0xffffffffffffffff); //输出有符号长整型unsigned long int</p><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>用户在输入字符时，其实并不是直接显示到屏幕上，而是放在缓冲区中，在一些条件之下才会输出</p><p>printf在glibc中默认为行缓冲，在下列情况中会刷新缓冲区</p><ol><li>缓冲区填满</li><li>写入字符中有换行符（’\n’)或回车符（’\r’)</li><li>调用fflush手动刷新缓冲区</li><li>调用scanf读取数据时</li></ol><p>可使用setbuf(stdout,NULL)关闭行缓冲，或者setbuf(stdout,uBuff)设置新的缓冲区，uBuff为自己指定的缓冲区。也可以使用setvbuf(stdout,NULL,_IOFBF,0);来改变标准输出为全缓冲。全缓冲与行缓冲的区别在于遇到换行符不刷新缓冲区。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>在运用printf和scanf中，前面的format是一个字符串，所以可以作为参数传入</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putout</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(s,...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样可以用一个函数实现重复输出不同类型的进制数</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>队列</title>
    <url>/post/26671.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h3 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h3><p>队列是一种线性结构，有队头（front）队尾（rear）两个指针，每次拉进来一个元素会让队尾加一，而每次删除一个元素会让队头加一，这是一种先进先出的结构。</p><p>队列特殊情况判断</p><p>空队列 front=rear</p><p>满队列 rear-front=N（N指的是开的数组的大小）</p><p>POP 从队头删元素</p><p>push 拉元素到队尾</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">duilie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> front ,rear;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        front=rear=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front)==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear-front==N<span class="number">-1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(full())<span class="comment">//如果满了就不能拖进去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[++rear]=key;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>上面一种队列并不是真的有n个空间，如果pop了元素那空间就要减小，这样便浪费了许多空间，而用模运算组成一个循环可以使空间充分利用</p><p>特殊情况判断</p><p>空 ： front=rear</p><p>满 ：（ rear+1）% N=front</p><p>代码实现</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const <span class="built_in">int</span> Queue_Size=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">typedef <span class="keyword">struct</span> circlQueue</span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> *elem;</span><br><span class="line">       <span class="built_in">int</span> rear;</span><br><span class="line">       <span class="built_in">int</span> front;</span><br><span class="line">       <span class="built_in">int</span> queueSize;</span><br><span class="line">&#125;circlQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">void init<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem=<span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[Q<span class="identifier">ueue_Size</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;<span class="comment">//首尾指针相等说明队列为空。</span></span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=Queue_Size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*销毁队列*/</span></span><br><span class="line">void destroy<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       delete <span class="literal">[]</span><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*求队列的长度*/</span></span><br><span class="line"><span class="built_in">int</span>  length<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">int</span> length;</span><br><span class="line">       length=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear-<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;<span class="comment">/*一般情况下，rear在front的上方，此种算法是用于</span></span><br><span class="line"><span class="comment">  rear已到front的下方，即已出现假溢出的情况。*/</span></span><br><span class="line">       return length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*入队列*/</span></span><br><span class="line">void enter<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q,<span class="params">char</span> <span class="params">x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span>(((<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)<span class="comment">//判断栈满的情况</span></span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue OverFlow!"</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">rear</span>]</span>=x;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%Queue_Size;<span class="comment">//尾指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="built_in">char</span> output<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> e;</span><br><span class="line">       <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)</span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue Empty"</span>;</span><br><span class="line">       e=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">front</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;;<span class="comment">//头指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">       return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「hackerain」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/hackerain/article/details/5934240</span></span><br></pre></td></tr></table></figure></div><h3 id="队列的函数"><a href="#队列的函数" class="headerlink" title="队列的函数"></a>队列的函数</h3><p>push()：脱元素到队尾</p><p>pop()删队首元素</p><p>size()</p><p>front()返回队首元素</p><p>back()返回队尾元素</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>front无法使用迭代器，因为queue在物理地址上不连续，所以queue无法遍历，想要遍历只能不停top POP，这样会销毁队列</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>HDU 1387</li></ul><p>Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.<br>In a team queue each element belongs to a team. If an element enters the queue, it first searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.</p><p>Your task is to write a program that simulates such a team queue.</p><p>Input</p><p>The input will contain one or more test cases. Each test case begins with the number of teams t (1&lt;=t&lt;=1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0 - 999999. A team may consist of up to 1000 elements.</p><p>Finally, a list of commands follows. There are three different kinds of commands:</p><p>ENQUEUE x - enter element x into the team queue<br>DEQUEUE - process the first element and remove it from the queue<br>STOP - end of test case<br>The input will be terminated by a value of 0 for t.</p><p>Output</p><p>For each test case, first print a line saying “Scenario #k”, where k is the number of the test case. Then, for each DEQUEUE command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">Sample Input</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line"><span class="number">3</span> <span class="number">201</span> <span class="number">202</span> <span class="number">203</span></span><br><span class="line">ENQUEUE <span class="number">101</span></span><br><span class="line">ENQUEUE <span class="number">201</span></span><br><span class="line">ENQUEUE <span class="number">102</span></span><br><span class="line">ENQUEUE <span class="number">202</span></span><br><span class="line">ENQUEUE <span class="number">103</span></span><br><span class="line">ENQUEUE <span class="number">203</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">259001</span> <span class="number">259002</span> <span class="number">259003</span> <span class="number">259004</span> <span class="number">259005</span></span><br><span class="line"><span class="number">6</span> <span class="number">260001</span> <span class="number">260002</span> <span class="number">260003</span> <span class="number">260004</span> <span class="number">260005</span> <span class="number">260006</span></span><br><span class="line">ENQUEUE <span class="number">259001</span></span><br><span class="line">ENQUEUE <span class="number">260001</span></span><br><span class="line">ENQUEUE <span class="number">259002</span></span><br><span class="line">ENQUEUE <span class="number">259003</span></span><br><span class="line">ENQUEUE <span class="number">259004</span></span><br><span class="line">ENQUEUE <span class="number">259005</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">ENQUEUE <span class="number">260002</span></span><br><span class="line">ENQUEUE <span class="number">260003</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">1</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">201</span></span><br><span class="line"><span class="number">202</span></span><br><span class="line"><span class="number">203</span></span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">2</span></span><br><span class="line"><span class="number">259001</span></span><br><span class="line"><span class="number">259002</span></span><br><span class="line"><span class="number">259003</span></span><br><span class="line"><span class="number">259004</span></span><br><span class="line"><span class="number">259005</span></span><br><span class="line"><span class="number">260001</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/post/63711.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>归并排序运用了分治的思想，先将数组二分成一个元素（一个元素时看为有序），然后将这些元素不断合并，每合并一次排一次序，最后就可以得到有序的数组。</p><p>比如说一个序列:12 ,23,1,44,233,10,9,8。我们先分成两段：12 ,23,1,44 和 233,10,9,8，<br>发现还能再分成4段：12 ,23 和 1,44——233,10 和 9,8。<br>再分成8段：12–23–1–44 和233–10–9–8。<br>这时候开始把子序列进行排序合并，一个元素就是有序的。所以不用排序。<br>合并成2个一组排序得到：12，23—-1，44—10，233—8，9。<br>再合并成4个一组排序得到：1，12，23，44—8，9，10，233。<br>最后合并得到最终结果：1，8，9，10，12，23，44，233。</p><p>合并过程看代码</p><p>链接：<a href="https://www.jianshu.com/p/b50a6034eb90" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/b50a6034eb90</a></p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/images/1024555-20161218163120151-452283750.png" alt></p><p>这个图片蓝色部分就是拆的过程，而绿的部分为并的过程</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paixu</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> mid,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span><span class="comment">//这是合并过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1=first,l2=mid+<span class="number">1</span>,r1=mid,r2=last;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1&amp;&amp;l2&lt;=r2)<span class="comment">//两部分都存在时看哪个小就加上哪个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l1]&lt;=a[l2])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1)<span class="comment">//第一部分有剩余就把第一部分剩下的全加上</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2&lt;=r2)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i+first]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xunhuan</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(first+last)/<span class="number">2</span>;</span><br><span class="line">        xunhuan(first,mid,a,temp);<span class="comment">//拆左边</span></span><br><span class="line">        xunhuan(mid+<span class="number">1</span>,last,a,temp);<span class="comment">//拆右边</span></span><br><span class="line">        paixu(first,mid,last,a,temp);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[last-first];<span class="comment">//建一个临时数组，合并时用</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="comment">//判断是否传入空数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xunhuan(first,last,a,p);</span><br><span class="line">    <span class="keyword">delete</span> [] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/post/26737.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="前缀和概念"><a href="#前缀和概念" class="headerlink" title="前缀和概念"></a>前缀和概念</h3><p>前缀和指的是用另一个数组b[n]来保存a[n]中前n项的和</p><p>例如，b[0]=a[0],b[1]=a[0]+a[1],…</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="求数组某一区间长度数字的和"><a href="#求数组某一区间长度数字的和" class="headerlink" title="求数组某一区间长度数字的和"></a>求数组某一区间长度数字的和</h4><p>如果我给你一串长度为n的数列a1,a2,a3……an,再给出m个询问，每次询问给出L，R两个数，要求给出区间[L,R]里的数的和，一般可能是从L到R遍历一次，但这样很花时间，有了前缀和之后可以直接b[R]-b[L]就得到L到R的和</p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分就是将数列中的每一项分别与前一项数做差</p><p>一个序列1 2 5 4 7 3，差分后得到1 1 3 -1 3 -4 -3</p><p>这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0）<br>差分序列最后比原序列多一个数（相当于0减最后一个数）</p><p>例 给你一串长度为n的数列a1,a2,a3……an，要求对a[L]~a[R]进行m次操作：</p><p>操作一：将a[L]~a[R]内的元素都加上P</p><p>操作二：将a[L]~a[R]内的元素都减去P</p><p>最后再给出一个询问求a[L]-a[R]内的元素之和？</p><p>如果用一般做法就是遍历加减，时间复杂度高，现在可以直接让b[L] 加上P，再让b[R+1]减去P，这样因为b[L+1]=b[L]+a[L+1]，所以L到R上每一项都会加P，而b[R+1]减去P是为了对后面的数不产生影响</p><p>如果有多次修改操作，可以先将每次修改保存到一个数组中，然后求前缀和时再加上<br>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int maxn=1e5+9;<br>int a[maxn],b[maxn];<br>int main(){<br>int i,j,k,n,m,p;<br>cin&gt;&gt;n&gt;&gt;m;<br>for(i=1;i&lt;=n;i++){<br>cin&gt;&gt;a[i];<br>}<br>for(i=1;i&lt;=m;i++){<br>int L,R,t;<br>cin&gt;&gt;t&gt;&gt;L&gt;&gt;R&gt;&gt;p;<br>if(t==1){<br>b[L]+=p;b[R+1]-=p; //仔细想想为什么b[R+1]要减去p<br>}<br>else{<br>b[L]-=p;b[R+1]+=p;//这是减去p<br>}<br>}<br>int add=0;<br>for(i=1;i&lt;=n;i++){<br>add+=b[i];<br>a[i]+=a[i-1]+add;//这是求前缀和数组，并且add是把需要加p的地方加上<br>}<br>int x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>cout&lt;&lt;a[y]-a[x-1]&lt;&lt;endl;<br>}</p><h4 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4><p>1、差分序列求前缀和可得原序列</p><p>2、将原序列区间[L,R]中的元素全部+1，可以转化操作为差分序列L处+1，R+1处-1</p><p>3、按照性质2得到，每次修改原序列一个区间+1，那么每次差分序列修改处增加的和减少的相同</p><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>二维前缀和对应的是二维数组</p><p><img src="/images/20180817161822690.png" alt></p><p>b[2][4]表示的是b[1][1]+b[1][2]+b[1][3]+b[1][4]+b[2][1]+b[2][2]+b[2][3]</p><p>因此可以先加上b[1][4]+b[2][3]，这时重复了b[1][3]，再减去</p><p>因此公式<br>a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1]，因为这样，二维前缀和最好从一开始，0处全赋值为0</p><p>这时想知道从(x1,y1)到(x2,y2)的和要a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]</p><p>例如，求(3,3)到(4,4)的值，实际上是a[3][3]+a[3][4]+a[4][3]+a[4][4]</p><h3 id="二维差分（不是很清楚）"><a href="#二维差分（不是很清楚）" class="headerlink" title="二维差分（不是很清楚）"></a>二维差分（不是很清楚）</h3><p>和一维差分的第四个问题类似，让（x1,y1)和（x2,y2）矩形内的数都加上x</p><p>b[x1][y1]+=x; b[x2+1][y2+1]+=x;</p><p>b[x1][y2+1]-=x; b[x2+1][y1]-=x;</p><p>参考博客<a href="https://blog.csdn.net/k_r_forever/article/details/81775899" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/k_r_forever/article/details/81775899</a></p><p><a href="https://blog.csdn.net/Healer66/article/details/87201014" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/Healer66/article/details/87201014</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>memset</title>
    <url>/post/46466.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>memset(标识符，填充数据,大小)</p><p>memset是一个字节一个字节填充的，所以一般只能填充0或-1因为这个一个字节和四个字节相同</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>快速输入</title>
    <url>/post/54778.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="attribute">x</span>=0,f=1;</span><br><span class="line">    char <span class="attribute">ch</span>=getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span> (<span class="attribute">ch</span>=='-') <span class="attribute">f</span>=-1;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;<span class="attribute">x</span>=x*10+ch-'0';ch=getchar();&#125;</span><br><span class="line">    return x<span class="number">*f</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个快速输入只适合int类型，另外如果参加比赛，最好不要用cin，cout，速度较慢<br>用scanf，printf更好</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>qsort</title>
    <url>/post/5490.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>自带的快排函数</p><p>qsortvoid qsort(void <em>base, size_t nitems, size_t size, int (*compar)(const void *, const void</em>))</p><p>参数</p><p>base– 指向要排序的数组的第一个元素的指针。<br>nitems– 由 base 指向的数组中元素的个数。<br>size– 数组中每个元素的大小，以字节为单位。<br>compar– 用来比较两个元素的函数，即函数指针（回调函数）</p><p>回调函数：</p><p>回调函数就是一个通过函数指针调用的函数。如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。 [2]<br>compar参数<br>compar参数指向一个比较两个元素的函数。比较函数的原型应该像下面这样。注意两个形参必须是const void *型，同时在调用compar 函数（compar实质为函数指针，这里称它所指向的函数也为compar）时，传入的实参也必须转换成const void *型。在compar函数内部会将const void *型转换成实际类型。<br>int compar(const void *p1, const void *p2);</p><p>如果compar返回值小于0（&lt; 0），那么p1所指向元素会被排在p2所指向元素的左面；<br>如果compar返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定；<br>如果compar返回值大于0（&gt; 0），那么p1所指向元素会被排在p2所指向元素的右面。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>pair</title>
    <url>/post/27621.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>pair实际上是一个结构体，它可以把两种类型结合起来使用,定义在<code>&lt;utility&gt;</code>中</p><p>定义：pair&lt;类型A,类型B&gt; 标识符</p><p>操作 pa.first 表示类型A pa.second 表示类型B</p><p>注意不能用-> 操作符，虽然我也不知道为什么</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器支持的运算</title>
    <url>/post/37318.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>之前写搜狗在线测试题目的时候，曾经想遍历一个set遍历。当时是这样写的。</p><p>set<int>::iterator b = a.begin()+1</int></p><p>后来发现程序报错。究其原因是，set迭代器不支持加减数操作。<br>查看了一下维基百科，下面是有关说明。</p><p>1.所有迭代器都应该实现自增算符：iter++,++iter</p><p>2.Bidirectional迭代器：是在前向迭代器的基础上，多了单步向后遍历的能力。也就是–iter,iter–。</p><p>3.Random Access迭代器：在双向迭代器基础上，具有直接访问各数据元素的能力。随机迭代器增加了“迭代器算术运算”：</p><p>iter+=i 迭代器递增i位</p><p>iter-=i 迭代器递减i位</p><p>iter+i 加i位后的迭代器</p><p>iter-i 减i位后的迭代器</p><p>iter[i] 加i位后的迭代器的解引用</p><p>iter&lt;iter1 如果迭代器iter的位置在iter1前，返回true，否则返回false</p><p>iter&lt;=iter1 如果iter的位置在iter1的前面或同一位置时返回true，否则返回false</p><p>iter&gt;iter1 如果迭代器iter的位置在iter1后，返回true，否则返回false</p><p>iter&gt;=iter1 如果iter的位置在iter1的后面或同一位置时返回true，否则返回false</p><p>4.在STL定义的容器中，string，vector与deque提供了随机访问迭代器，list、set、multiset、map、multimap提供了双向迭代器。</p><p>————————————————</p><p>版权声明：本文为CSDN博主「ShenYounger」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wusecaiyun/article/details/49563197" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/wusecaiyun/article/details/49563197</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>vector</title>
    <url>/post/54708.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h3><p>vector&lt;数据类型&gt; 标识符</p><h3 id="vector的函数"><a href="#vector的函数" class="headerlink" title="vector的函数"></a>vector的函数</h3><p>begin()返回开头元素的迭代器</p><p>end()同理</p><p>front() 返回开头元素的引用</p><p>back() 返回末尾元素的引用</p><p>size()返回vector内元素的数量</p><p>erase(迭代器) 删除一个元素</p><p>clear() 清空</p><p>insert(迭代器，a) 把a插入迭代器后</p><p><strong>例</strong>vector中现在有1 2 3 三个元素，vec.insert(vec.begin()+2,4)得到1 2 4 3</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>reverse(vec.begin(),vec.end()) <strong>(头文件<code>&lt;algorithm&gt;</code>)</strong></p><p>实际上不一定是begin到end，也可以begin()+1到、、、，只需要用迭代器就行了</p><p>sort排序，也要用<code>&lt;algorithm&gt;</code>默认升序</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> <span class="constructor">Comp(<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">a</span>,<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><pre><code>vector&lt;vector&lt;数据类型&gt; &gt; vec[3];//3行
vector&lt;数据类型&gt; veci;
for(int i=0;i&lt;3;i++)
{
   for(int k=0;k&lt;4;k++)
   {
      veci.push_back();
   }
   vec.push_back(veci);
}//四列</code></pre><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>prioity_queue</title>
    <url>/post/54612.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="prioity-queue"><a href="#prioity-queue" class="headerlink" title="prioity_queue"></a>prioity_queue</h3><p>实际上是一个大顶堆，定义在<code>&lt;queue&gt;</code>中</p><p><code>prioity_queue&lt;int&gt; qu</code>为大顶堆</p><p><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qu;</code>为小顶堆</p><p>.push()</p><p>.pop()取出元素，但不返回值</p><p>.top()不取出元素，返回值</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>set</title>
    <url>/post/44250.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="set之iterator"><a href="#set之iterator" class="headerlink" title="set之iterator"></a>set之iterator</h3><p>定义：set::iterator iter</p><p>运用：*iter</p><p>遍历 for(iter=set.begin();iter!=set.end();iter++)</p><p>还可以直接用auto it=set.begin() (auto是自动匹配类型)</p><p><strong>注意</strong><br>iterator只能用++，–运算符。不能*（iter-1），另外还要注意iter++后自身会改变</p><p>例：set中有0,2,4，iter指向2，现在cout&lt;&lt;<em>iter&lt;&lt;” “&lt;&lt;</em>(iter–)&lt;&lt;endl;</p><p>输出0,2，先执行iter–，我也不知道为什么</p><h3 id="set之lower-bound"><a href="#set之lower-bound" class="headerlink" title="set之lower_bound()"></a>set之lower_bound()</h3><p>lower_bound()返回从first开始的第一个大于或等于val的元素的地址。如果所有元素都小于val，则返回last的地址，所以必须要</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">iter=st.lower_bound(一个数字)</span><br></pre></td></tr></table></figure></div><p>upper_bound()返回最后一个大于等于val的元素的地址</p><h3 id="set基础"><a href="#set基础" class="headerlink" title="set基础"></a>set基础</h3><p>定义：set&lt;数据类型&gt; 标识符 ，set中元素都唯一</p><p>set实际上运用了红黑树。另外，set中元素会自动排序</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>begin()，返回的是开头元素迭代器</p><p>end()</p><p>clear()</p><p>empty()</p><p>size()</p><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>count(数据)判断某个值是否在set中</p><ul><li><p>erase(iterator) 删去迭代器所指向的值</p></li><li><p>erase(iteratora,iteratorb)删去a，b之间的值</p></li><li><p>erase(数据)删去该数据</p></li><li><p>set删除是不会检查任何错误的，使用时小心</p></li></ul><p>find(数据)返回指定元素的迭代器，没有则返回最后一个元素的迭代器</p><p>当set中没有元素的时候，*s.end()=0</p><p>insert(某一个值),将一个值插入set中，<strong>注意</strong>这是唯一的将元素弄到set中的方法，并且重复插入无效</p><h6 id="判断insert插入是否成功的方法（具体可看"><a href="#判断insert插入是否成功的方法（具体可看" class="headerlink" title="判断insert插入是否成功的方法（具体可看)"></a>判断insert插入是否成功的方法（<a href="https://blog.csdn.net/liyuqian199695/article/details/49100543" target="_blank" rel="external nofollow noopener noreferrer">具体可看</a>)</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typedef pair&lt;iterator, bool&gt; _Pairib;</span></span><br><span class="line">	pair&lt;<span class="built_in">set</span>&lt;Student,FuncStudent&gt;::iterator,<span class="keyword">bool</span>&gt; pair1=set1.insert(s1);</span><br><span class="line">	<span class="keyword">if</span>(pair1.second==<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入s1成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入s1失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>&amp;&amp;与||小提示</title>
    <url>/post/25699.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h4 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h4><p>&amp;&amp;运算符从左自由依次判断 ，如果判断有一个为假则停止判断</p><h4><a href="#" class="headerlink" title="||"></a>||</h4><p>同理如果判断有一个为真则停止判断</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
    int a=0,b=1,c;
    c = (a != b) || (++a == b++);
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;
    return 0;
}</code></pre><p>输出为0 1因为前面一个为真，直接退出判断</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>字符数组</title>
    <url>/post/22493.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="前方高能"><a href="#前方高能" class="headerlink" title="前方高能"></a>前方高能</h3><pre><code>char a[4]={&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;};
cout&lt;&lt;a&lt;&lt;endl;</code></pre><p>这将输出什么呢，是<code>abcd</code>，实际上是<code>abcdPpB</code></p><p>这就有点神奇</p><h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>char +标识符+[]，注意字符数组的最后一定会有’\0’，</p><p>例如<code>char[]=&quot;abcd&quot;,这就是一个合法的赋值，但是char[4]=&quot;abcd&quot;是不合法的因为带双引号的为字符串，赋值给字符数组时编译器会自动加上&#39;\0&#39;这时需要5个空间</code></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为本来是要加上’\0’的，但是这时位子不够了，编译器只好帮它扩扩容，也就是说这是字符数组（其实现在已经不是字符数组了）长度已经不是4了，编译器会为后面几个位子附上值（不是随机的，我也有点不清楚，这样解释先），因此后面会多输出一些。但是如果开始就把长度设为5，这时’\0’就有位子放了，也就不会多出后面那些奇奇怪怪的字符</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>next主题出现404的一个解决方法</title>
    <url>/post/7119.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>在<code>主题配置文件中</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DTS"><figure class="iseeu highlight /dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">home:</span> /|| home</span><br><span class="line"></span><br><span class="line"><span class="symbol">about:</span> <span class="meta-keyword">/about/</span>|| user</span><br><span class="line"></span><br><span class="line"><span class="symbol">tags:</span> <span class="meta-keyword">/tags/</span>|| tags</span><br><span class="line"></span><br><span class="line"><span class="symbol">categories:</span> <span class="meta-keyword">/categories/</span>|| th</span><br><span class="line"></span><br><span class="line"><span class="symbol">archives:</span> <span class="meta-keyword">/archives/</span>|| archive</span><br><span class="line"></span><br><span class="line"><span class="meta">#schedule: /schedule/|| calendar</span></span><br><span class="line"><span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">#commonweal: /404/|| heartbeat</span></span><br></pre></td></tr></table></figure></div><p>注意/||，原来是/ ||，不要中间那个空格，亲测有效</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>next</category>
      </categories>
  </entry>
  <entry>
    <title>文件输入输出</title>
    <url>/post/7502.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h4 id="文件输入in"><a href="#文件输入in" class="headerlink" title="文件输入in"></a>文件输入in</h4><p>文件输入指的是从文件_输入_给程序，对应的有in，get，read，seekg等</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">seekg和seekp中有三个定位基址，分别是cur（当前）beg（开始），end（末尾）&lt;p&gt;</span><br><span class="line">例如 seekg（<span class="number">100</span>，ios：：beg）；seekg（<span class="number">2</span>*sizeof(Student)) student是一个类</span><br></pre></td></tr></table></figure></div><p></p><h4 id="文件输出out"><a href="#文件输出out" class="headerlink" title="文件输出out"></a>文件输出out</h4><p>文件输出指的是从程序<code>输出</code>给文件，对应的有out，put，write，seekp等</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/16107.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external nofollow noopener noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external nofollow noopener noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external nofollow noopener noreferrer">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external nofollow noopener noreferrer">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external nofollow noopener noreferrer">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external nofollow noopener noreferrer">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="external nofollow noopener noreferrer">Deployment</a></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>二分搜索</title>
    <url>/post/41829.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h1 id="（主要是怕自己忘记了）"><a href="#（主要是怕自己忘记了）" class="headerlink" title="（主要是怕自己忘记了）"></a>（主要是怕自己忘记了）<p></p></h1><p>一个要点，用二分时要先排序</p><p></p><pre><code>int erfen(int arr[],int key,int n)
    {
        int low=0,high=n-1;
        while(low&lt;=high)
        {
            int mid=(low+high)/2;
            if(arr[mid]&lt;key)
            {
                low=mid+1;
            }
            if(arr[mid]==key)
            {
                return mid;
            }
            if(arr[mid]&gt;key)
            {
                high=mid-1;
            }
        }
        return -mid-1;
     }</code></pre><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>合法的字符常量</title>
    <url>/post/3526.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>用英文单引号括起来的一个字符，例如’a’,’ ‘等等。空格也是一个字符常量</p><p>注意</p><p>1.转义字符也属于字符常量，例如'\t','\n'等，但是'\97'不算</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>字符常量</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/post/11306.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>步骤：<br>1.先从数列中取出一个数作为基准数。</p><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p><p>3．再对左右区间重复第二步，直到各区间只有一个数。</p><p>例 6 1 2 7 9 3 4 5 10 8 进行排序</p><p><br>1 以6为基准数，先从右边找比6小的数，我们用一个变量j一步步向左移动，好在移动三次后我<br>们找到了5，j为7。现在再让另一个变量i向右移动去找比6大的数，当i为3时找到了7.现在再让5<br>和7互换，得到了6 1 2 5 9 3 4 7 10 8,。在让j向左移动，找到了4，i向右找到了9，再让两个数<br>互换，j再向左到3，此时i向左也到3，两者相遇，便让3和6互换，第一次结束<br>（想想原因）</p><p><br>2 现在分为两部分，左边全比6小，右边全比6大，为3 1 2 5 4 6 9 7 10 8<br>再在3 1 2 5 4 中用同样的方法搜索一次得到2 1 3 5 4,再在2 1 中搜索得到1 2<br>然后在5 4 中搜索得到4 5，左边排序完成，右边用同样的方法排序就可得到答案</p><p>不说了，上代码</p><pre><code>void sort(int a[],int l,int r)
{
  if(l&lt;r)//l大于等于r时这一段排序结束
  {
      int i=l,j=r,x=a[l];
      while(i&lt;j)
      {
          while(i&lt;j&amp;&amp;a[j]&gt;=x)
          {
              j--;
          }
          while(i&lt;j&amp;&amp;a[i]&lt;=x)
          {
              i++;
          }
          swap(a[i],a[j]);
      }
      swap(a[l],a[i]);
      sort(a,l,i-1);
      sort(a,i+1,r);
 }
}</code></pre><p>引用 转载请标明出处，原文地址：<a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/morewindows/article/details/6684558</a><br>csdn 我见过最通俗易懂的快速排序过程讲解，转自《坐在马桶上看算法：快速排序》</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划背包问题</title>
    <url>/post/21624.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="第一类背包问题"><a href="#第一类背包问题" class="headerlink" title="第一类背包问题"></a>第一类背包问题</h3><p>问题，有N件物品和一个容量为V的背包。第i件物品的大小是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p><p><strong>思路</strong> 可以用一个二维数组a[i][j]，表示把前i个物体放入一个容量为j的容器中所获得的最大价值，而a[i][j]=max(a[i-1][j],a[i-1][j-c[i]]+w[i])</p><p>这个式子表示到底是不装第i个物品价值大还是花去c[i]的空间装获得w[i]的价值所得的总价值最大，</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">n 	w v    <span class="number">1</span>   <span class="number">2</span>  <span class="number">3</span>	  <span class="number">4</span>	  <span class="number">5</span>	  <span class="number">6</span>	  <span class="number">7</span>	  <span class="number">8</span>	  <span class="number">9</span>	  <span class="number">10</span></span><br><span class="line">a	<span class="number">2</span>	<span class="number">6</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">12</span>	<span class="number">12</span>	<span class="number">15</span>	<span class="number">15</span>	<span class="number">15</span></span><br><span class="line">b	<span class="number">2</span>	<span class="number">3</span>	<span class="number">0</span>	<span class="number">3</span>	<span class="number">3</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">10</span>	<span class="number">11</span></span><br><span class="line">c	<span class="number">6</span>	<span class="number">5</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">10</span>	<span class="number">11</span></span><br><span class="line">d	<span class="number">5</span>	<span class="number">4</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">10</span>	<span class="number">10</span></span><br><span class="line">e	<span class="number">4</span>	<span class="number">6</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span></span><br></pre></td></tr></table></figure></div><p>为了叙述方便，用e2单元格表示e行2列的单元格，这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了。</p><p>对于d2单元格，表示只有物品e，d时,承重为2的背包,所能装入的最大价值，仍然是0，因为物品e,d都不是这个背包能装的。</p><p>上代码</p><p>————————————————<br>版权声明：本文为CSDN博主「从杰」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/mu399/article/details/7722810" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/mu399/article/details/7722810</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>线性筛</title>
    <url>/post/38035.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>埃氏筛中有重复，例如6,2与3都筛了一次，效率低<br>线性筛定理，（口语不准确）一个数i乘以小于等于它的最小素因数的素数所得到的合数之间没有重复</p><pre><code>#define N 10000
int flag[N+1],prime[N+1],pnum;
/*
flag[n] 表示n是否是素数，1是素数，0不是
prime   中是所有的素数按从小到大排列、
pnum  表示素数的个数
*/
void CreatePrime(){
    pnum=0;//初始化没有素数
    //先将所有数看做素数，然后开始筛选
    for(int i=0; i&lt;=N; i++){
        flag[i]=1;
    }
    //遍历筛去所有最大因数是i的合数
    for(int i=2; i&lt;=N; i++){
        if(flag[i]==1){
        //把素数记录下来
            p[pnum++]=i;
        }
        //遍历已知素数表中比i的最小素因数小的素数，并筛去合数
        for(int j=0; j&lt;pnum &amp;&amp; p[j]*i&lt;=N; j++){
        //筛去合数
            flag[p[j]*i]=0;
            if(i%p[j]==0)
            //找到i的最小素因数，找到了就终止
                break;
        }
    }</code></pre><p>————————————————<br>版权声明：本文为CSDN博主「太上绝情」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/bjrxyz/article/details/8125913" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/bjrxyz/article/details/8125913</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>埃氏筛</title>
    <url>/post/29949.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>在筛质数时，我们会发现，筛去2后，2的倍数4、6、8等一定不是素数;筛去3后，3的倍数6、9、12等一定不是倍数。简单模拟这个过程如下</p><pre><code>const int MAXN = 1000000；  
void Prime()  
{  
    for (int i=0; i&lt;MAXN; i++) prime[i]=1;  //先把每个数都定义为质数
    prime[0]=prime[1]=0;  
    for (int i=2; i&lt;MAXN; i++)  
    {  
        if (!prime[i]) continue;  
        for (int j=i*2; j&lt;MAXN; j+=i) prime[j] = 0;  //将i的倍数标记为合数
    }  
}</code></pre><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>组合</title>
    <url>/post/44454.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>本程序的思路是开一个数组，其下标表示1到n个数，数组元素的值为1表示其代表的数被选中，为0则没选中。</p><p>首先初始化，将数组前n个元素置1，表示第一个组合为前n个数。</p><p>然后从左到右扫描数组元素值的“10”组合，找到第一个“10”组合后将其变为“01”组合，同时将其左边的所有“1”全部移动到数组的最左端。</p><p>当第一个“1”移动到数组的n-m的位置，即n个“1”全部移动到最右端时，就得到了最后一个组合。</p><p>例如求5中选3的组合：</p><p>1 1 1 0 0 //1,2,3</p><p>1 1 0 1 0 //1,2,4</p><p>1 0 1 1 0 //1,3,4</p><p>0 1 1 1 0 //2,3,4</p><p>1 1 0 0 1 //1,2,5</p><p>1 0 1 0 1 //1,3,5</p><p>0 1 1 0 1 //2,3,5</p><p>1 0 0 1 1 //1,4,5</p><p>0 1 0 1 1 //2,4,5</p><p>0 0 1 1 1 //3,4,5<br>————————————————<br>版权声明：本文为CSDN博主「文如王勃三生慧」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/hf19931101/article/details/79452799" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/hf19931101/article/details/79452799</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>string大小写字母转换</title>
    <url>/post/14511.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>在algorithm库中有transform函数<br>transform(str.begin(),str.end(),str.begin(),::toupper)<br>注意transform有四个输入参数<br>1：str.begin()字符串的起始地址；<br>2：str.end()字符串的终止地址；<br>3：str.begin()是转换之后，输出到原str字符串的起始地址；<br>4：转换操作，可以选择toupper，tolower。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>“凸包”</title>
    <url>/post/6589.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>凸包就是把平面中所有点都包进去的凸多边形，当然多边形上的点也是题目中给出的点</p><p>分治法<br>1 首先，横坐标最小p1和最大pn的点一定是凸包上的点<br>2上包，即离p1pn最远的点，记pmax<br>3再把pmax与p1连接，求左侧的上包，重复上述过程即可求解<img src="/images/20150530094927274" alt></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>神奇的逗号运算符</title>
    <url>/post/27980.html</url>
    <content><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>cout&lt;&lt;(a,c),此时只会输出c的内容，但是a中的内容也会被计算，例如a=5,b=6,c=7 cout&lt;&lt;(（d=a+b),c) 输出为7，d=11</p><!-- rebuild by neat -->]]></content>
  </entry>
</search>
