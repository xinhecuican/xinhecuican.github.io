<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>顺序表</title>
    <url>/2020/02/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<p>顺序表就是将元素放入一个连续的内存空间里，它的优点是可以快速访问，缺点是插入和删除操作时间复杂度高</p>
<h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> datasize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>* p;<span class="comment">//存储空间的基址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//现在有的元素数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(node&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.p=<span class="keyword">new</span> <span class="keyword">int</span>[datasize];</span><br><span class="line">    <span class="keyword">if</span>(a.p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"储存分配失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> [] a.p;</span><br><span class="line">    &#125;</span><br><span class="line">    a.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化有两点要注意的地方，第一点是用了传引用，第二点是动态分配内存，这就表示如果使用完了要delete</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int <span class="built_in">find</span>(node&amp; a,int x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;a.<span class="built_in">length</span>;<span class="built_in">i</span>++)</span><br><span class="line">   &#123;</span><br><span class="line">   		<span class="keyword">if</span>(a.p[<span class="built_in">i</span>]==x)</span><br><span class="line">      &#123;</span><br><span class="line">      		<span class="keyword">return</span> <span class="built_in">i</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入操作是把一个数插入第i位，其他位顺序后移</p>
<p>如果插入某一位概率相同，那么在第0位插入需要移动n个数，第一位插入需要移动n-1个数……在第n位插入需要移动0个数，总共有n-1中可能，总共需要移动的次数为n(n+1)/2,所以平均需要移动次数为n/2</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int insert(node&amp; a,int x,int <span class="built_in">i</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">i</span>&lt;<span class="number">0</span>||<span class="built_in">i</span>&gt;a.<span class="built_in">length</span>||a.<span class="built_in">length</span>==datasize)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">j</span>=a.<span class="built_in">length</span>;<span class="built_in">j</span>&gt;<span class="built_in">i</span>;<span class="built_in">j</span>--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="built_in">j</span>]=a[<span class="built_in">j</span><span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="built_in">i</span>]=x;</span><br><span class="line">    a.<span class="built_in">length</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>与上面操作类似，这里需要前移，并且平均操作次数为(n-1)/2</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> Delete(node&amp; a,<span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i;k&lt;a.length<span class="number">-1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.p[k]=a.p[k+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a.length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>linux指令学习</title>
    <url>/2020/02/16/linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h5 id="用户提醒命令"><a href="#用户提醒命令" class="headerlink" title="用户提醒命令"></a>用户提醒命令</h5><ul>
<li>who 用来显示用这个计算机的用户</li>
<li>whoami 用来显示当前用户标识</li>
<li>quota 用来看自己拥有多少空间</li>
<li>lock 临时上锁 lock -5 锁5分钟</li>
<li>leave leave +15 十五分钟后离开 leave 1344 13点44分离开，到了时间它会不停的提醒你，相当于一个闹钟</li>
<li>id 用来显示你的基本信息</li>
<li>date 时间 date -u 协调世界时间（UTC时间）</li>
<li>cal 显示日历 cal+某一年份可以显示某一年份的日历 cal 7 2019 显示2019年7月的日历 cal -j +… 会显示第几天，所以想要知道这一年是不是闰年只需 cal -j 12 + 年份，看看12月最后一天是不是366天就可以了</li>
<li>su（substitute user） 这个指令是用来切换用户的，如果你知道一个用户的口令，那么就可以采用su+用户名的方式切换，这个时候用户标识改变了，但是你仍位于旧的环境之中。就像你让别人来你家做事，如果你想让别人在自己家做事，就要用su+’-‘+用户名</li>
</ul>
<p>特别的，如果你想拥有root权限，你需要 su - root ，这时你输入的是你自己的口令而不是root口令，因为在计算机中有特殊的配置文件，这个文件只有管理员能操作，他可以修改那些人可以通过su口令获得root权限</p>
<h5 id="登入登出命令"><a href="#登入登出命令" class="headerlink" title="登入登出命令"></a>登入登出命令</h5><ul>
<li>exit 退出当前用户，例如想从root模式退出用exit</li>
<li>sudo 以超级用户模式运行一条指令。如果你经常使用超级用户，可能在无意间删去一些重要文件导致系统出现故障，因此超级用户需慎用。因此要用可以用sudo命令。</li>
<li>less 浏览配置文件。例如我想浏览passwd文件，只需 less /etc/passwd</li>
</ul>
<p>配置文件就像windows系统下的注册表和ini文件</p>
<ul>
<li>dmesg 显示启动信息，但是这种显示太快，看不清</li>
<li>dmesg | less 显示启动信息</li>
<li>init 设置运行级别，1为单用户，2为多用户，等等，0是关机，6是重启</li>
</ul>
<p>如果想重启，可以用 sudo init 6</p>
<ul>
<li>reboot 重启 sudo reboot</li>
<li>shutdown 关机，这个要说关机时间，经常用的是sudo shutdown now</li>
</ul>
<h5 id="快捷键命令"><a href="#快捷键命令" class="headerlink" title="快捷键命令"></a>快捷键命令</h5><ul>
<li>erase 删除最好一个键入的字符，Ctrl+H</li>
<li>werase 删除最后一个单词 Ctrl+W</li>
<li>kill 删除一行 Ctrl+U</li>
<li>intr 停止程序 有些系统是Ctrl+C，有些是delete</li>
<li>quit 停止程序 Ctrl+\ 它不仅会停止程序，还会生成一个副本保存在core的文件中</li>
<li>stop 停止屏幕显示，Ctrl+S</li>
<li>start 开始屏幕显示 Ctrl+Q</li>
<li>eof 文件终止信号 Ctrl+D<br>可以通过Ctrl+D终止shell，但是有时候会不小心按到。为了让shell忽略eof，需要使用一个叫IGNOREEOF的环境变量，这个变量表示注销前BASH会忽略多少次eof，设置这个变量时，要 IGNOREEOF = 数字</li>
<li>stty -a 显示键盘映射，这个命令是表示各个快捷方式如erase的快捷键。stty是set terminal(设置终端）-a表示显示所有设置</li>
<li>stty 修改键映射。例如想修改kill命令 ，可以 stty kill Ctrl a</li>
<li>echo 简单显示赋予它的内容</li>
<li>返回字符 ^M，指的是返回到这一行的开头</li>
<li>换行字符 ^J<br>文件每一行最后一定是一个返回加换行</li>
<li>stty sane，reset 候终端的设置被弄乱，可以采用这个命令是终端恢复到初始值</li>
</ul>
<h5 id="立即使用的程序"><a href="#立即使用的程序" class="headerlink" title="立即使用的程序"></a>立即使用的程序</h5><ul>
<li>which 看某个命令会使用那些程序，如果显示地址，则说明有这些程序，如果没有输出，或者输出错误信息，则说明这个命令无法使用</li>
<li>quit 终止程序命令，但是也可以输入eof使程序终止</li>
<li>bc 计算器 如果想用bc内部的函数，要用bc -l命令（library)。如果是多个算式，中间要用”;”号隔开</li>
</ul>
<p>常用函数</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">s</span><span class="params">(x)</span></span> sinx  弧度制</span><br><span class="line"><span class="function"><span class="title">c</span><span class="params">(x)</span></span> cosx</span><br><span class="line"><span class="function"><span class="title">a</span><span class="params">(x)</span></span> arctanx</span><br><span class="line"><span class="function"><span class="title">ln</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">j</span><span class="params">(n,x)</span></span>  x的n次整阶贝塞尔函数</span><br></pre></td></tr></table></figure>
<p>如果想用小数运算，先要设置标度因子 scale 来确定精确到小数点后多少位。如果输入scale 则会返回scale的当前值 scale=3，则设置小数点后三位</p>
<p>有一点需要注意，当你用来 bc -l时，scale会自动设置为20</p>
<p>bc实际上是一套功能完整的数学编程语言，可以使用的变量有26个字母<br>例如 x=100 就是将x变量设为100</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>开始使用unix</title>
    <url>/2020/02/13/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8unix/</url>
    <content><![CDATA[<p>当你使用Unix系统的时候，第一件要你做的事便是输入用户标识和口令（账号密码），注意，在Unix中，密码是完全不可见的，甚至连*号都不会出现。</p>
<p>登陆之后出现的欢迎界面，这一部分源于一个特殊的初始化文档，这就意味着你可以对文档内容进行修改从而定制化你的初始化界面。</p>
<p>一旦初始化命令结束执行，Unix将启动shell，并将控制权交给他。这时shell会出现一个提示-称为shell提示，并等待命令。接下来就可以输入各种命令了。</p>
<p>最终，没有命令时，你可以通过注销结束工作会话，此时shell将停止运行。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>unix基础</title>
    <url>/2020/02/13/unix%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ol>
<li>操作系统有初始化功能，初始化过程只是引导过程的一部分</li>
</ol>
<p>引导过程是计算机启动时会运行一个小程序，然后再运行另一个程序，逐层运行，最后运行一个十分复杂的程序，这个程序名字是内核。</p>
<p>内核是操作系统的核心，因此只要计算机开启，内核边一直运行。</p>
<p>内核可以分为微内核和单内核两种。单内核较大，运行速度较快，但是由于没有采用模块化设计，维护修改比较困难。而微内核自己只能运行最基本的功能，其他功能要交给服务器去运行（微内核调用的其他程序），微内核速度慢，但适用于定制化的任务，如移动电话。</p>
<h3 id="unix-内核-使用工具"><a href="#unix-内核-使用工具" class="headerlink" title="unix=内核+使用工具"></a>unix=内核+使用工具</h3><p>只有内核并不能带来很好的用户体验，因此还有许多其他的程序。最重要的是为用户提供计算机界面的程序，shell 和 GUI。</p>
<p>shell 是一种提供基于文本的界面的程序，也就是平时所说的命令提示符。</p>
<p>而 GUI（graphical user interface）是使用窗口，鼠标指针，图标等提供图形界面.</p>
<p>这些工具称为Unix实用工具，有几百个。</p>
<h3 id="服务器和客户端"><a href="#服务器和客户端" class="headerlink" title="服务器和客户端"></a>服务器和客户端</h3><p>早期由于主机昂贵而终端便宜，所以经常是多个主机连接一个终端。因此服务器和客户端的概念也因此产生。</p>
<p>提供某种类型的服务的程序叫做服务器，使用服务的程序叫做客户端。例如，但你用键盘键入字符时，是主机而不是终端把字符显示出来，终端只是向主机发出了一个输出字符的请求，然后主机进行解析然后把字符输出</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>单调队列</title>
    <url>/2020/02/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>也就是有一个数列a，要求你求数列b和c，b[i]是a[i]…a[i+w-1]中的最小值，c[i]是最大值。如果a是1,3,-1,-3,5,3,6,7，则b为-1,-3,-3,-3,3,3，c为3,3,5,5,6,7。</p>
<p>这个问题相当于一个数据流（数列a）在不断地到来，而数据是不断过期的，相当于我们只能保存有限的数据（sliding window中的数据，此题中就是窗口的宽度w），对于到来的查询（此题中查询是每时刻都有的），我们要返回当前滑动窗口中的最大值\最小值。注意，元素是不断过期的。</p>
<p>解决这个问题可以使用一种叫做单调队列的数据结构，它维护这样一种队列：</p>
<p>a)从队头到队尾，元素在我们所关注的指标下是递减的（严格递减，而不是非递增），比如查询如果每次问的是窗口内的最小值，那么队列中元素从左至右就应该递增，如果每次问的是窗口内的最大值，则应该递减，依此类推。这是为了保证每次查询只需要取队头元素。</p>
<p>b)从队头到队尾，元素对应的时刻（此题中是该元素在数列a中的下标）是递增的，但不要求连续，这是为了保证最左面的元素总是最先过期，且每当有新元素来临的时候一定是插入队尾。</p>
<p>满足以上两点的队列就是单调队列，首先，只有第一个元素的序列一定是单调队列。</p>
<p>那么怎么维护这个单调队列呢？无非是处理插入和查询两个操作。</p>
<p>对于插入，由于性质b，因此来的新元素插入到队列的最后就能维持b)继续成立。但是为了维护a)的成立，即元素在我们关注的指标下递减，从队尾插入新元素的时候可能要删除队尾的一些元素，具体说来就是，找到第一个大于（在所关注指标下）新元素的元素，删除其后所有元素，并将新元素插于其后。因为所有被删除的元素都比新元素要小，而且比新元素要旧，因此在以后的任何查询中都不可能成为答案，所以可以放心删除。</p>
<p>对于查询，由于性质b，因此所有该时刻过期的元素一定都集中在队头，因此利用查询的时机删除队头所有过期的元素，在不含过期元素后，队头得元素就是查询的答案（性质a），将其返回即可。</p>
<p>由于每个元素都进队出队一次，因此摊销复杂度为O(n)。</p>
<p>这个讲的十分清楚，我只是<a href="https://blog.csdn.net/Baoli1008/article/details/47001513" target="_blank" rel="noopener">搬运</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>双端队列deque</title>
    <url>/2020/02/09/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque/</url>
    <content><![CDATA[<p>普通的队列有许多限制，例如从一边删除插入，不能使用迭代器（因为空间不连续）等等。<br>双端队列就允许从两边插入</p>
<p>deque的特点：</p>
<p>1、支持随机访问，即支持[]以及at()，但是性能没有vector好。</p>
<p>2、可以在内部进行插入和删除操作，但性能不及list。</p>
<p>deque和vector的不同之处：</p>
<p>1、两端都能够快速插入和删除元素。vector只能在尾端进行。</p>
<p>2、deque的元素存取和迭代器操作会稍微慢一些。因为deque的内部结构会多一个间接过程。</p>
<p>3、迭代器是特殊的智能指针，而不是一般指针。它需要在不同的区块之间跳转。</p>
<p>4、deque可以包含更多的元素，其max_size可能更大。因为不止使用一块内存。</p>
<p>5、不支持对容量和内存分配时机的控制。</p>
<p>注意：在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector。因为其内部结构显示不需要复制所有元素。</p>
<p>迭代器属于随机存取迭代器。</p>
<p>以上都是复制粘贴的，从以上我们可以看出它与vector相似，不同在于它可以从两头插入，这样插入效率高，如果从中间插入，要把很多元素都移动一遍，效率低</p>
<p>格式： deque&lt;类型&gt; 标识符</p>
<p>当生成一个 deque 容器时，也可以用由两个迭代器标识的一段元素来初始化它：</p>
<p>std::deque<a href="std::string">std::string</a> words_part { std::begin(words),std::begin(words) + 5 };</p>
<p>deque的成员函数：</p>
<p>deq[ ]：用来访问双向队列中单个的元素。</p>
<p>deq.front()：返回第一个元素的引用。</p>
<p>deq.back()：返回最后一个元素的引用。</p>
<p>deq.push_front(x)：把元素x插入到双向队列的头部。</p>
<p>deq.pop_front()：弹出双向队列的第一个元素。</p>
<p>deq.push_back(x)：把元素x插入到双向队列的尾部。</p>
<p>deq.pop_back()：弹出双向队列的最后一个元素。</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何基础</title>
    <url>/2020/02/06/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="判断两直线是否相交"><a href="#判断两直线是否相交" class="headerlink" title="判断两直线是否相交"></a>判断两直线是否相交</h3><p>P(x1,y1) Q(x2,y2) 两向量的叉积为  x1<em>y2-x2</em>y1</p>
<p>如果 p*q&gt;0 p在q的顺时针方向</p>
<p>p*q&lt;0 p在q的逆时针方向</p>
<p>=0  ，共线或反向</p>
<p><img src="/images/20170428234108337.png" alt=""></p>
<p>先做一次快速排斥实验，判断下一个线段中 x 较大的端点是否小于另一个线段中 x 较小的段点，若是，则说明两个线段必然没有交点，同理判断下 y</p>
<p>代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>x)&lt;min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>x)<span class="operator"> || </span>max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>y)&lt;min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>y) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">max(<span class="constructor">A</span>.x,<span class="constructor">B</span>.x)&lt;min(<span class="constructor">C</span>.x,<span class="constructor">D</span>.x) <span class="operator">||</span> max(<span class="constructor">A</span>.y,<span class="constructor">B</span>.y)&lt;min(<span class="constructor">C</span>.y,<span class="constructor">C</span>.y)</span></span><br></pre></td></tr></table></figure>

<p>如图所示，如果想判断两线段相交，只需要判断A 和 B在cd两侧即可</p>
<p>所以只需要 向量<code>AD*CD</code>与 BD*CD异号即可</p>
<p>如果端点正好在另一条线段上，两者乘积等于0</p>
<p>如果两者平行，叉积也为0但是可以在快速排斥实验中排除掉</p>
<p>总代码</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">struct Line &#123;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">x</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="comment">    double y1;</span></span><br><span class="line"><span class="comment">    double x2;</span></span><br><span class="line"><span class="comment">    double y2;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">bool intersection(const Line &amp;l1, const Line &amp;l2)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    //快速排斥实验</span></span><br><span class="line"><span class="comment">    if ((l1.x1 &gt; l1.x2 ? l1.x1 : l1.x2) &lt; (l2.x1 &lt; l2.x2 ? l2.x1 : l2.x2) ||</span></span><br><span class="line"><span class="comment">        (l1.y1 &gt; l1.y2 ? l1.y1 : l1.y2) &lt; (l2.y1 &lt; l2.y2 ? l2.y1 : l2.y2) ||</span></span><br><span class="line"><span class="comment">        (l2.x1 &gt; l2.x2 ? l2.x1 : l2.x2) &lt; (l1.x1 &lt; l1.x2 ? l1.x1 : l1.x2) ||</span></span><br><span class="line"><span class="comment">        (l2.y1 &gt; l2.y2 ? l2.y1 : l2.y2) &lt; (l1.y1 &lt; l1.y2 ? l1.y1 : l1.y2))</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //跨立实验</span></span><br><span class="line"><span class="comment">    if ((((l1.x1 - l2.x1)*(l2.y2 - l2.y1) - (l1.y1 - l2.y1)*(l2.x2 - l2.x1))*</span></span><br><span class="line"><span class="comment">        ((l1.x2 - l2.x1)*(l2.y2 - l2.y1) - (l1.y2 - l2.y1)*(l2.x2 - l2.x1))) &gt; 0 ||</span></span><br><span class="line"><span class="comment">        (((l2.x1 - l1.x1)*(l1.y2 - l1.y1) - (l2.y1 - l1.y1)*(l1.x2 - l1.x1))*</span></span><br><span class="line"><span class="comment">        ((l2.x2 - l1.x1)*(l1.y2 - l1.y1) - (l2.y2 - l1.y1)*(l1.x2 - l1.x1))) &gt; 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/HelloZEX/article/details/80880385" target="_blank" rel="noopener">参考</a></p>
<h3 id="判断点是否在多边形内部"><a href="#判断点是否在多边形内部" class="headerlink" title="判断点是否在多边形内部"></a>判断点是否在多边形内部</h3><p>我们先将横纵坐标存在一个数组内</p>
<p>第一步</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.x &lt; minX <span class="params">||</span> p.x &gt; maxX <span class="params">||</span> p.y &lt; minY <span class="params">||</span> p.y &gt; maxY) &#123;</span><br><span class="line">     /<span class="regexp">/ 这个测试都过不了。。。直接返回false；</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个测试是画一个四边形</p>
<p>第二步， 这里我们就要讲一个定理了，以某一点为端点画一条射线，如果穿过图形次数为奇数次，则在图形内，如果是偶数次，在图形外</p>
<p>为了方便讨论，我们将以x轴正方向做一条射线</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int pnpoly (int nvert, float *vertx, float *verty, float testx, float testy) &#123;</span><br><span class="line">    int <span class="built_in">i</span>, <span class="built_in">j</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">i</span> = <span class="number">0</span>, <span class="built_in">j</span> = nvert<span class="number">-1</span>; <span class="built_in">i</span> &lt; nvert; <span class="built_in">j</span> = <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ( (verty[<span class="built_in">i</span>]&gt;testy) != (verty[<span class="built_in">j</span>]&gt;testy) ) &amp;&amp;</span><br><span class="line">(testx &lt; (vertx[<span class="built_in">j</span>]-vertx[<span class="built_in">i</span>]) * (testy-verty[<span class="built_in">i</span>]) / (verty[<span class="built_in">j</span>]-verty[<span class="built_in">i</span>]) + vertx[<span class="built_in">i</span>]) )</span><br><span class="line">            c = !c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nvert 是 顶点数量，testx和testy是顶点横纵坐标</p>
<p>第一段的意思是</p>
<p>verty[i] &lt;testy &lt; verty[j]</p>
<p>或者</p>
<p>verty[j] &lt;testy &lt; verty[i]</p>
<p>这段代码是用来粗略判断射线是否会经过该边的（没考虑反向和端点）</p>
<p>第二段是用来判断测试点是否在两点连线之下，这里用了斜率（移下项）</p>
<p>c=!c;是用来判断奇数次还是偶数次的</p>
<h3 id="多边形的面积"><a href="#多边形的面积" class="headerlink" title="多边形的面积"></a>多边形的面积</h3><p>s=pow(p<em>(p-a)</em>(p-b)*(p-c),0.5),p=(a+b+c)/2</p>
<p>凸多边形都可以通过划分变成三角形</p>
<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>用最少的点把给出的点全部包住</p>
<h4 id="andraw算法"><a href="#andraw算法" class="headerlink" title="andraw算法"></a>andraw算法</h4><p>把所有点按第一关键字x第二关键字y按从小到大排序，并且删除重复点，得到序列p1…pn</p>
<p>把p1 p2放入凸包中，凸包中的点用栈来保存</p>
<p>然后 p1p2和p2p3叉积，如果叉积大于0，则说明p1p2在p2p3右边，说明p3在内部，我们就不选，反之则把它拖入栈中并且要把p2拖出栈中</p>
<p>这样一直到pn算完成了一遍（下凸包），我们还要从pn反过来到p1（上凸包）,合起来就是完整的凸包</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y==b.y&amp;&amp;a.x&lt;b.x)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">xcross</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b,<span class="built_in">point</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);<span class="comment">//斜率</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">point</span> node[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node,node+n,cmp);</span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">0</span>; num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;xcross(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">        top--;</span><br><span class="line">        top++;</span><br><span class="line">        num[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> basic=top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;basic&amp;&amp;xcross(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">        top--;</span><br><span class="line">        top++;</span><br><span class="line">        num[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> s;</span><br><span class="line">    s=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=dis(node[num[i<span class="number">-1</span>]],node[num[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1lf"</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h3><p>旋转卡壳可以用来求凸包的直径，宽度，两个不相交凸包间最大距离和最小距离等</p>
<p>如果过凸包上的两个点可以画一对平行直线，使凸包上所有点都夹在两<br>条平行线之间 || 落在平行线上，那么这两个点称为一对对踵点。</p>
<p><img src="/images/4429524-41118e7599b80fb5.webp" alt=""><br>其实简单来说就是用一对平行线“卡”住凸包进行旋转。<br>被一对卡壳正好卡住的对应点对称为对踵点，对锺点的具体定义不好说，不过从图上还是比较好理解的。可以证明对鍾点的个数不超过3*n/2</p>
<p>卡壳有两种情况，第一种是一点对一点， 也就是上图中的</p>
<p><img src="/images/4429524-6d28ceac8cc2b711.webp" alt=""></p>
<p>另一种是一边只有一点，另外一边有两个点</p>
<p>第二种情况中我们可以发现对鍾点到对应边的距离比其他的要大（不要问我为什么）</p>
<p>Step1：计算多边形 y 方向上的端点，称之为 ymin 和 ymax。</p>
<p>Step2：通过 ymin 和 ymax 构造两条水平切线，由于他们已经是一对对<br>踵点，计算他们之间的距离并维护一个当前最大值。</p>
<p>Step3：同时旋转两条直线到其中一条与多边形的一条边重合。</p>
<p>Step4：一个新的对踵点对此时产生，计算新的距离，并和当前最大值进<br>行比较，若大于当前最大值。则更新。</p>
<p>Step5：重复 Step3 和 Step4 的过程直到再次产生新的对踵点对。</p>
<p>Step6：输出最大直径的对踵点对。</p>
<p>听起来有点小麻烦，观察可以发现当平行线和多边形的一条边重合的时<br>候最会产生一对新的对踵点<br>这条边的两个端点和原来的点都可能更新最大值</p>
<p>不妨考虑找离每条边最远的点，显然，这条边的两个端点都和最远点是<br>对踵点<br>特殊情况，如果有两条边是平行的，必须考虑所有的对踵点。<br>旋转卡壳的均摊复杂度 O(n)，但这个问题需要求凸包，复杂度是<br>O(nlogn)</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">void solve2(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ymax=-1e5,ymin=1e5<span class="comment">;</span></span><br><span class="line">    <span class="keyword">int</span> ymaxidx,yminidx<span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">int</span> i=<span class="number">1</span><span class="comment">;i&lt;=num;i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if(<span class="number">ch</span>[i].y&gt;ymax)</span><br><span class="line">        &#123;</span><br><span class="line">            ymax=<span class="number">ch</span>[i].y<span class="comment">;</span></span><br><span class="line">            ymaxidx=i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="number">ch</span>[i].y&lt;ymin)</span><br><span class="line">        &#123;</span><br><span class="line">            ymin=<span class="number">ch</span>[i].y<span class="comment">;</span></span><br><span class="line">            yminidx=i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx])<span class="comment">;</span></span><br><span class="line">    <span class="number">ch</span>[num+<span class="number">1</span>]=<span class="number">ch</span>[<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">int</span> t=<span class="number">1</span><span class="comment">;t&lt;=num;t++,yminidx=yminidx%num+1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        while(xmult(<span class="number">ch</span>[yminidx+<span class="number">1</span>],<span class="number">ch</span>[ymaxidx+<span class="number">1</span>],<span class="number">ch</span>[yminidx])&gt;xmult(<span class="number">ch</span>[yminidx+<span class="number">1</span>],<span class="number">ch</span>[ymaxidx],<span class="number">ch</span>[yminidx]))ymaxidx=ymaxidx%num+<span class="number">1</span><span class="comment">;</span></span><br><span class="line">        ans=max(ans,dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx]))<span class="comment">;</span></span><br><span class="line">        ans=max(ans,dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx+<span class="number">1</span>]))<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,ans)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>数论</title>
    <url>/2020/02/06/%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h3><p>如果a能被b整除，a=b*q，q为一整数记作b|a,a是被除的那个</p>
<h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>如果a和bmod m 是同一个值，则称a和b同余，记作a (三横线） b(mod m)</p>
<p>例如： 3 和 8 关于5 同余  因为 3%5=3,8%5=3</p>
<p>重要性质：  </p>
<pre><code>（a+b)%c=a%c+b%c
(a*b)%c=(a%c*b%c)%c
(a^b)%c=(a%c^b)%c</code></pre><h3 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h3><p>任何大于1的正整数n都可以被分解为若干质数的乘积</p>
<p>约数个数 例如 72=2^3<em>3^2  ，而72有 1 2 3 4 6 8 9 12 18 24 36 72 12个约数<br>，而我可以从2^3 中提取出0个2,1个2，两个2，三个2把其他的数放到另一边，这样我们就可以得到4个约数，3也同理，用一下分配率，就可以得到约数个数为3</em>4=12</p>
<p>约数和  因为约数是从2和3中随机挑出若干个数进行分配，所以用分配率可得约数和为</p>
<p>(1+2+2^2+2^3)(1+3+3^2)</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>如果p是质数且a与p互质，则</p>
<p>a^(p-1)%p=1(a的p-1次方和1关于p同余）</p>
<p>互质指的是 二者除了1以外没有相同的约数</p>
<h3 id="求质数的方法"><a href="#求质数的方法" class="headerlink" title="求质数的方法"></a>求质数的方法</h3><p><a href="http://localhost:4000/2020/01/04/%E5%9F%83%E6%B0%8F%E7%AD%9B/" target="_blank" rel="noopener">埃氏筛</a></p>
<p><a href="http://localhost:4000/2020/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B/" target="_blank" rel="noopener">线性筛</a></p>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>概念：表示0到n-1中与n互素的数的个数</p>
<p>积性函数：如果 m和n互质 ，则f(m<em>n)=f(m)</em>f(n)</p>
<p>欧拉函数的性质：</p>
<ol>
<li>对于质数p  f(p)=p-1</li>
<li>如果n=p^k,则f(n)=p^k-p^k-1</li>
<li>欧拉函数是积性函数，但不是完全积性函数，当n为质数时成立，当m=2,n为奇数时，f(2*n)=n</li>
<li>n&gt;2时 f(n)是偶数</li>
<li>与n互质的数的和为 f(n)*n/2</li>
<li>n的因数的欧拉函数的和为n</li>
</ol>
<h3 id="模意义下的乘法逆元"><a href="#模意义下的乘法逆元" class="headerlink" title="模意义下的乘法逆元"></a>模意义下的乘法逆元</h3><p>例 1/5%7=?</p>
<p>3*5%7=1,所以1/5的逆元是3，所以1/5%7=3</p>
<p>逆元的求法</p>
<p>1 费马小定理</p>
<p>a*a^-1%p=1,a^p-1%p=1</p>
<p>可得 a^-1%p=a^p-2%p，然后用快速幂。但是费马小定理要求必须要是素数</p>
<p>2 线性求逆元（不理解）</p>
<p>公式：inv(a)=-p/a*inv(p%a)%p;</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">2</span>;<span class="built_in">i</span>&lt;=n;++<span class="built_in">i</span>)&#123;</span><br><span class="line">inv[<span class="built_in">i</span>]=((<span class="number">1</span>ll*(-p/<span class="built_in">i</span>)*inv[p<span class="comment">%i]%p)+p)%p;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 扩展欧几里得法</p>
<p>exgcd</p>
<p>exgcd用来求解ax+by=c，其中a，b，c都为整数</p>
<p>裴蜀定理</p>
<p>不定方程 ax+by=c存在整数解当且仅当gcd(a,b)|c ，当存在一组整数解时，必存在无限组解<br>ax+by=gcd(a,b)=&gt;bx1+a%by1=gcd(b,a%b)=&gt;x=x1,y=x1-(a/b)y1</p>
<p>x=x1+k<em>b/gcd(a,b) , y= y1-k</em>a/gcd(a,b)</p>
<p>之后一直求解直到x=1,y=0,这时b=0,所以gcd(a,b)=a,方程一定成立</p>
<p>在这里我们可以用递归反推，把x=1,y=0带入方程，一步步向上推</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> exgcd(<span class="built_in">int</span> a,<span class="built_in">int</span> b,<span class="built_in">int</span> &amp;x,<span class="built_in">int</span> &amp;y)&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> x1,y1;</span><br><span class="line">exgcd(b,a%b,x1,y1);</span><br><span class="line">x=y1;</span><br><span class="line">y=x1-(a/b)*y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们就可以得到第三种方法</p>
<p>求逆元可以转化为：求关于x的同余方程ax（三横）1 mod b的最小正整数解</p>
<p>ax%b=1  ax=kb+1</p>
<p>即 ax-by=1</p>
<p>最后 x1%b+b即是答案</p>
<p><a href="https://big-news.cn/2019/05/19/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/" target="_blank" rel="noopener">可以看这篇博客</a></p>
<h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>求C(m,n)%p的值</p>
<p>可变成  (n!/m!(n-m)!)%p</p>
<p>之后就用费马小定理求逆元</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> ksm(<span class="built_in">int</span> a,<span class="built_in">int</span> b,<span class="built_in">int</span> p)&#123;</span><br><span class="line"><span class="built_in">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=<span class="number">1</span>ll*ret*a%p;</span><br><span class="line">a=<span class="number">1</span>ll*a*a%p;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> fac[maxn];</span><br><span class="line"><span class="built_in">int</span> inv(<span class="built_in">int</span> x)&#123;</span><br><span class="line"><span class="keyword">return</span> ksm(x,p<span class="number">-2</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> C(<span class="built_in">int</span> n,<span class="built_in">int</span> m)&#123;</span><br><span class="line"><span class="built_in">int</span> qwq=<span class="number">1</span>ll*fac[n]*inv(fac[n-m])%p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>ll*qwq*inv(fac[m])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> n,m;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">fac[i]=<span class="number">1</span>ll*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"%d"</span>,C(n,m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>图论基础</title>
    <url>/2020/02/04/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>如果图中有权值，称为网，仅在无向图中考虑这些问题，生成树指删去一些边变为树</p>
<h4 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h4><p>这个也被称为加边法，</p>
<ol>
<li>把图中所有边按权值从小到大排序</li>
<li>把图中n个点看为n个独立的连通块</li>
<li>选择端点分属两个联通块且权值最小的边，若可选择的边有多条，任选其中一条即可</li>
<li>重复三，直至只剩一个连通块</li>
</ol>
<p>如何存边？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;x,<span class="keyword">const</span> node&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxm];</span><br></pre></td></tr></table></figure>
<p>其中u代表起点v代表终点，而w代表权值</p>
<p>采用了并查集的思想</p>
<p>怎么看加边后是否会变成环？只需要查找u，v的根节点，如果根节点相同则说明加边后 会变成环</p>
<p>模板，n个点m条边，找最小生成树</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,e,w;</span><br><span class="line">    <span class="keyword">friend</span> opoerator &lt; (<span class="keyword">const</span> node&amp; x,<span class="keyword">const</span> node&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=a;</span><br><span class="line">    <span class="keyword">while</span>(father[r]!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        r=father[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=a;</span><br><span class="line">    <span class="keyword">while</span>(father[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=father[x];</span><br><span class="line">        father[x]=x;</span><br><span class="line">        x=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">int</span> fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        father[fx]=fy;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; nod[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;nod[i].s&gt;&gt;nod[i].e&gt;&gt;nod[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nod.<span class="built_in">begin</span>(),nod.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(join(nod[i].s,nod[i].e))</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">                ans+=nod[i].val;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prim-算法"><a href="#prim-算法" class="headerlink" title="prim 算法"></a>prim 算法</h4><p>先把点分为两个集合，在最开始的时候第一个集合中只有任意一点，其他点在另外一个集合中，之后选择属于集合一点在集合B中一点在集合A中且与A权值最小的边</p>
<p>选择时注意只要把最近选的那个点的权值与原来 权值相比就可以了</p>
<p>我们如何保存边？用邻接矩阵</p>
<p>在这里我们不用考虑形成环的问题，因为我们是从两个集合中拿边，而想要形成环必定是在一个集合内拿边</p>
<p>模板</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[maxn][maxn],dis[maxn];<span class="comment">//dis用来记录以i为起点的最小权值</span></span><br><span class="line"><span class="keyword">bool</span> mark[maxn];<span class="comment">//用来判断某点是否加入</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,ox3f,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="keyword">sizeof</span>(mark));</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">1</span>,mi;</span><br><span class="line">    mark[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[v]=<span class="built_in">min</span>(dis[v],g[u][v]);<span class="comment">//将从前的最小值与第u个点的最小值相比</span></span><br><span class="line">        &#125;</span><br><span class="line">        mi=ox3f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mark[v]&amp;&amp;dis[v]&lt;mi)<span class="comment">//找到与A集合中权值最小的</span></span><br><span class="line">            &#123;</span><br><span class="line">                u=v;</span><br><span class="line">                mi=dis[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=mi;</span><br><span class="line">        mark[u]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，g数组开始要初始化为正无穷</p>
<h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><p>在有向网中，求结点之间边权和最小的路被称为最短路问题</p>
<h4 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h4><p>多源最短路指的是任意两点之间的最短路径</p>
<p>一般采用floyd-warshall算法，并且要求图中没有负权环（不然一直绕着环走就可以一直减小）</p>
<h6 id="flord算法"><a href="#flord算法" class="headerlink" title="flord算法"></a>flord算法</h6><p>用一个二维数组f[i][j]表示从i到j最小路长度，初始化时输入i，j点的路的长度并且f[i][i]=0.</p>
<p>我们怎么找到最短的路程呢？ 通过观察可以发现，如果我们把一些点作为中转点的话，有可能会让路程变小。例如，我们只用1作为中转，可以得到</p>
<p>f[i][j]=min(f[i][j],f[i][1]+f[1][j]);</p>
<p>如果我们拿1和2作为中转点，可以得到</p>
<p>f[i][j]=min(f[i][j],f[i][1]+f[1][j]);</p>
<p>f[i][j]=min(f[i][j],f[i][2]+f[2][j]);</p>
<p>这段代码的意思是我先拿1作为中转，找到1做中转的最小路径之后我再拿2做为中转</p>
<p>模板<br><img src="/images/%E5%9B%BE%E7%89%8715.png" alt=""><br>第一层是k，表示以1,2。。。n为中转</p>
<p>离散上的传递闭包<br><img src="/images/%E5%9B%BE%E7%89%8716.png" alt=""></p>
<h4 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h4><p>默认s可达全部点，用dis[i]表示从s到i的最短路径</p>
<p>它的基本思想是贪心，与prim算法类似</p>
<p>松弛操作</p>
<p>每次给目标集合加入一个点时，都要用该点重新判断最小的路径</p>
<p><img src="/images/%E5%9B%BE%E7%89%8717.png" alt=""></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dijkstra(int x)</span><br><span class="line">&#123;</span><br><span class="line">	int visit[maxn],<span class="built_in">i</span>,<span class="built_in">j</span>,<span class="built_in">min</span>,next=x;</span><br><span class="line">	memset(visit,<span class="number">0</span>,sizeof(visit));</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=n;++<span class="built_in">i</span>)</span><br><span class="line">		dis[<span class="built_in">i</span>]=map[x][<span class="built_in">i</span>];</span><br><span class="line">	visit[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">2</span>;<span class="built_in">i</span>&lt;=n;++<span class="built_in">i</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">min</span>=INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=n;++<span class="built_in">j</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visit[<span class="built_in">j</span>]&amp;&amp;dis[<span class="built_in">j</span>]&lt;<span class="built_in">min</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">min</span>=dis[<span class="built_in">j</span>];</span><br><span class="line">				next=<span class="built_in">j</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		visit[next]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=n;++<span class="built_in">j</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visit[<span class="built_in">j</span>]&amp;&amp;dis[<span class="built_in">j</span>]&gt;dis[next]+map[next][<span class="built_in">j</span>])</span><br><span class="line">				dis[<span class="built_in">j</span>]=dis[next]+map[next][<span class="built_in">j</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title> 链式前向星</title>
    <url>/2020/02/04/%E9%93%BE%E8%A1%A8-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</url>
    <content><![CDATA[<p>静态链表（链式前向星）是表示图的另外一种方法</p>
<h3 id="前向星"><a href="#前向星" class="headerlink" title="前向星"></a>前向星</h3><p>前向星也称为邻接数组</p>
<p>例 <img src="/images/static_linked_list_example.svg" alt=""></p>
<p>总共有这几条边</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>现在将这些边按从小到大排序，变成</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>) --|</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>) --| =&gt; len[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>) --|</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>) =&gt; head[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>然后再将数据填入三个数组中，分别是</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">es</span><span class="selector-attr">[]</span> 这个数组是用来记录每条边的终点的，而因为前面已经排好了序，起点很容易知道</span><br><span class="line"><span class="selector-tag">head</span><span class="selector-attr">[]</span> 记录以<span class="selector-tag">i</span>为起点的边在数组中的第一个位置</span><br><span class="line"><span class="selector-tag">len</span><span class="selector-attr">[]</span> 记录以<span class="selector-tag">i</span>为起点的边有多少</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Array</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>es</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>2</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>head</td>
<td>1</td>
<td>4</td>
<td>5</td>
<td>7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>len</td>
<td>3</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>head[2]=4表示2为起点的第一条边在es中的位置为4</p>
<p>通过这几个函数我们就能很清楚的知道点与边的关系</p>
<p>例如，我们想知道起点为1的所有边，我们只需要知道len[1]和head[1],这样我们知道起点为1的边有三个且从es[1]开始</p>
<p>但是前向星要排序，时间复杂度高，因此并不怎么使用</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表通常用vector来实现</p>
<p>vector<int> g[max_v]，g[i]表示了以i为起点的所有边</p>
<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>其他部分与前向星相同，但是链式前向星多了一个next数组，取消了len数组（因为没有排序了）</p>
<p>next数组的含义是下一条以i为节点的边在es中的位置，如果这是最后一个节点，则令next[i]=0</p>
<p>例如</p>
<table>
<thead>
<tr>
<th>Array</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>es</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>head</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>next</td>
<td>4</td>
<td>0</td>
<td>6</td>
<td>7</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>举个例子，我们要求以1为起始边的所有节点</p>
<p>先从head中知道了第一个以1为起始点的边是1号，所以可以知道（1，2），然后next[1]=4,而4的es=3，所以（1,3）也知道，然后同理</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxn=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxm=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> head[maxn];</span><br><span class="line"><span class="built_in">int</span> n,m,nEdge;      <span class="comment">//n为顶点数，m为边数，nEdge为存储的边的数量</span></span><br><span class="line">                    <span class="comment">//如果边是双向的，那么存储的边的数量就是2m</span></span><br><span class="line">struct NODE<span class="comment">//这里是双向的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> to;</span><br><span class="line">    <span class="built_in">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">NODE edge[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">void</span> addedges(<span class="built_in">int</span> u,<span class="built_in">int</span> v)       <span class="comment">//将边(u,v)添加进去</span></span><br><span class="line">&#123;</span><br><span class="line">    nEdge++;</span><br><span class="line">    edge[nEdge].next=head[u];</span><br><span class="line">    edge[nEdge].to=v;</span><br><span class="line">    head[u]=nEdge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> foreach()       <span class="comment">//遍历边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=head[i];k!=<span class="number">-1</span>;k=edge[k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;edge[k].to&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> Init()</span><br><span class="line">&#123;</span><br><span class="line">    nEdge=<span class="number">-1</span>;</span><br><span class="line">    memset(head,<span class="number">0xff</span>,sizeof(head));</span><br><span class="line">    <span class="built_in">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        addedges(u,v);</span><br><span class="line">        addedges(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/02/04/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>并查集指的是一个图中的若干个连通分支，任意两个连通分支间没有关系，而每个连通分支内部可以以任意一个点作为根节点，根节点指向它自己，而其他点指向他们的上级节点（因为是连通图，两点之间必定可达），因此只要在同一连通分支，必定可以到同一根节点，从而判断两者可达</p>
<p>例如：pre[2]=3表示2的上级节点为3，pre[3]=3表示这是一个根节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                    <span class="comment">//查找我（x）的掌门</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=x;                      <span class="comment">//委托 r 去找掌门</span></span><br><span class="line">    <span class="keyword">while</span> (pre[r ]!=r)           <span class="comment">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）</span></span><br><span class="line">    r=pre[r ] ;                 <span class="comment">// r 就接着找他的上级，直到找到掌门为止。</span></span><br><span class="line">    <span class="keyword">return</span>  r ;                <span class="comment">//掌门驾到~~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外如何将两个连通分支合并为一个连通分支呢？</p>
<p>我们可以把任意一个根节点指向另外一个根节点（因为我们不考虑内部的关系，指向知道是否可达），这样就变为一个连通分支了</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>          <span class="comment">//我想让虚竹和周芷若做朋友</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);         <span class="comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span></span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)                         <span class="comment">//玄慈和灭绝显然不是同一个人</span></span><br><span class="line">    pre[fx ]=fy;                       <span class="comment">//方丈只好委委屈屈地当了师太的手下啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>如果我们要经转很多个上级才能找到根节点，这样显然效率较低，假如我们可以直接让自己的上级是根节点，那就再好不过了</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pre[<span class="number">1000</span> ];</span><br><span class="line"><span class="built_in">int</span> find(<span class="built_in">int</span> x)                                       <span class="comment">//查找根节点</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )                           <span class="comment">//返回根节点 r</span></span><br><span class="line">          r=pre[r];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">int</span> i=x , j ;</span><br><span class="line">    <span class="keyword">while</span>( i != r )                                   <span class="comment">//路径压缩</span></span><br><span class="line">    &#123;</span><br><span class="line">         j = pre[ i ]; 				<span class="comment">// 在改变上级之前用临时变量  j 记录下他的值 </span></span><br><span class="line">         pre[ i ]= r ; 				<span class="comment">//把上级改为根节点</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><p>带权值的并查集只不过是在并查集中加入了一个value[ ]数组<br>value[ ]可以记录很多种东西，不一定是类似距离这种东西，也可以是相对于根节点的状态</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">int findfat(int <span class="symbol">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keywords">if</span>(fat[<span class="symbol">x</span>] == <span class="symbol">x</span>) <span class="keywords">return</span> <span class="symbol">x</span>;</span><br><span class="line">	int tmp=fat[<span class="symbol">x</span>];</span><br><span class="line">	fat[<span class="symbol">x</span>]=findfat(fat[<span class="symbol">x</span>]);</span><br><span class="line">	<span class="comment">//在此处修改val比如：</span></span><br><span class="line">	value[<span class="symbol">x</span>]=value[tmp]+<span class="number">1</span>;</span><br><span class="line">	<span class="keywords">return</span> fat[<span class="symbol">x</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/liujian20150808/article/details/50848646" target="_blank" rel="noopener">参考文章</a></p>
]]></content>
  </entry>
  <entry>
    <title>int指令</title>
    <url>/2020/02/02/int%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>格式： int n，n为中断类型码</p>
<p>在程序中可以采用int指令调用任何一个中断处理程序</p>
<p>例如： int 0 ，就会调用除法溢出的处理程序</p>
<p>所以说，int指令最终的功能与call指令类似，都是调用一段程序</p>
<p>例 用中断程序实现循环</p>
<p>要想实现循环，需要知道两个量，第一个是循环次数，第二个是跳转位移。循环次数用cx来保存，跳转位移用bx来保存</p>
<p>而为了实现loop指令，中断例程需要实现两个功能</p>
<ol>
<li>dec cx</li>
<li>cx=0，则顺序执行，否则，跳转</li>
</ol>
<p>代码</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ...安装</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bx</span>,offset s-offset se</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span></span><br><span class="line"><span class="symbol"> s:</span> <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="string">'!'</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">7ch</span>；这时<span class="built_in">ip</span>指向下一条指令即se标号</span><br><span class="line"><span class="symbol">se:</span> <span class="keyword">nop</span></span><br><span class="line"><span class="symbol">lp:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">dec</span> <span class="built_in">cx</span> <span class="comment">;cx--</span></span><br><span class="line">   <span class="keyword">jcxz</span> lpret</span><br><span class="line">   <span class="keyword">add</span> [<span class="built_in">bp</span>+<span class="number">2</span>],<span class="built_in">bx</span>//因为入栈顺序为标志寄存器，<span class="built_in">cs</span>，<span class="built_in">ip</span>，而<span class="keyword">add</span>是与后两个字节<span class="keyword">add</span></span><br><span class="line"><span class="symbol">ipret:</span> <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">     <span class="keyword">iret</span> //没到<span class="built_in">cx</span>=<span class="number">0</span>时也会终止，但这时<span class="built_in">ip</span>就不会回到s标号处</span><br></pre></td></tr></table></figure>
<h3 id="blos-和-dos中断例程安装过程"><a href="#blos-和-dos中断例程安装过程" class="headerlink" title="blos 和 dos中断例程安装过程"></a>blos 和 dos中断例程安装过程</h3><ol>
<li><p>开机后，cs：ip初始化为0ffff：0 ，这里有一条跳转指令，自动跳转到blos中的硬件系统检测和安装程序</p>
</li>
<li><p>初始化程序将建立blos所支持的中断向量，即把blos提供的中断例程载入中断向量表中</p>
</li>
<li><p>硬件检测完之后，调用int 19h进行操作系统的引导，从此把计算机给操作系统控制</p>
<h3 id="blos中断例程的应用"><a href="#blos中断例程的应用" class="headerlink" title="blos中断例程的应用"></a>blos中断例程的应用</h3><p>int 10h 中断例程是blos提供的，包含多个与屏幕输出有关的子程序</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span></span><br></pre></td></tr></table></figure>
<p>ah=2表示调用10h中的2号子程序，功能为设置光标的位置，</p>
<p>bh=0，dh=5，dl=12 设置光标到第0页，第5行，第12列</p>
<p>mov ah ，9 表示调用第9号子程序，功能为在光标位置显示字符，可以提供显示字符的各种属性</p>
</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">9</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="string">'a'</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">11001010b</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span>//字符重复次数</span><br><span class="line">    <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="dos中断例程的应用"><a href="#dos中断例程的应用" class="headerlink" title="dos中断例程的应用"></a>dos中断例程的应用</h3><p>int 21h就是dos的中断例程，</p>
<p>我们一直使用的是int 21h中的4ch功能，即程序返回功能</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">4ch</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure>
<p>ah=4ch表示调用21h中的4ch号子程序</p>
<p>21h 中的光标位置显示字符功能</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ds:</span><span class="built_in">dx</span> 指向字符串</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>，<span class="number">9</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure>
<p>调用第九号子程序</p>
<p>dh中放行号，dl中放列号</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>内中断</title>
    <url>/2020/02/01/%E5%86%85%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<p>一般cpu都有一种能力，就是接受cpu内部或外部发来的信号，停止当前程序而取执行其他的程序。这种信息叫做中断信息，中断信息指的是cpu接受到这种信息后立刻处理这个信息。接受到这个信息后cpu会交给专门的程序去处理，叫做中断处理程序</p>
<h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>内中断指的是中断信息来自cpu内部。当cpu接受到相应几种情况时，会产生相应的中断信息</p>
<ol>
<li>除法错误 例如 ，div除法溢出</li>
<li>单步执行</li>
<li>执行into指令</li>
<li>执行int 指令</li>
</ol>
<p>我们先不需要了解具体含义。为了更方便的知道到底属于那种中断信息，8086cpu用了一个字节的中断类型码来确定。</p>
<ol>
<li>除法错误 0</li>
<li>单步执行 1</li>
<li>执行into指令 4</li>
<li>int： int n ，n就是中断类型码</li>
</ol>
<p>cpu根据cs:ip知道程序的入口，所以中断类型码中必定有cs:ip的信息，可cpu如何根据8位的类型吗知道程序的入口呢？</p>
<h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>cpu通过中断类型码找到中断向量表，而中断向量表中就保存着程序的入口。中断向量表在内存中保存。中断内存表位于0000:0000 到 0000:03ff 1024个字节中</p>
<h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>找到cs：ip的过程叫做中断过程。</p>
<p>cpu收到中断信息后，要对中断信息进行处理。但是完成中断程序之后还要返回，就像call和ret一样。所以总过程如下</p>
<ol>
<li>获得中断类型码</li>
<li>标志寄存器的值入栈（因为中断过程会改变标志寄存器的值）</li>
<li>设置标志寄存器第8位和第九位的值为0</li>
<li>cs入栈</li>
<li>ip入栈</li>
<li>设置cs：ip</li>
</ol>
<p>更简洁的说明</p>
<ol>
<li>获得 中断类型码 n</li>
<li>pushf</li>
<li>tf=0 if=0</li>
<li>push cs</li>
<li>push ip</li>
<li>ip=n<em>4，cs=n</em>4+2</li>
</ol>
<h3 id="iret指令"><a href="#iret指令" class="headerlink" title="iret指令"></a>iret指令</h3><p>中断处理程序用iret进行返回</p>
<p>内容</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>
<p>这个正好与进栈顺序相反</p>
<h3 id="除法错误中断的处理"><a href="#除法错误中断的处理" class="headerlink" title="除法错误中断的处理"></a>除法错误中断的处理</h3><p>cpu如果产生除法溢出错误，将会产生中断类型码为0的中断信息。引发中断过程。然后中断处理程序会返回 divide overflow 再返回到主程序中</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span> do0安装程序</span><br><span class="line">     设置中断向量表</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00h</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol"> do0:</span> 显示字符串“overflow！”</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>注意：do0也要返回</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>用movsb指令，将do0的代码送入0:200处</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> 设置<span class="built_in">es</span>:<span class="built_in">di</span>指向目的地址</span><br><span class="line">     设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向源地址</span><br><span class="line">     设置传输长度</span><br><span class="line">     设置传输方向为正</span><br><span class="line">     <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line">     </span><br><span class="line">     设置中断表</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>
<p>我们如何知道do0代码长度？</p>
<p>可以用编译器来知道do0的长度</p>
<p><code>mov cx,offset do0end-offset do0</code></p>
<p>“-”是编译器识别的符号，编译器可以用它来做两个常数的减法</p>
<p>例如 mov ax,(5+3)*5/10 被编译器识别为 mov ax，4</p>
<h3 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h3><p>do0的主要任务是显示字符串</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">do0:</span> 设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向字符串</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">9</span></span><br><span class="line"><span class="symbol">  s:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">do0end:</span><span class="keyword">nop</span></span><br></pre></td></tr></table></figure>
<p>这个程序看起来对，实际上有问题，因为程序执行完后内存立刻被释放，其中保存的内容也可能被其他的程序覆盖。正确的程序如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="symbol">do0:</span> <span class="keyword">jmp</span> short do0start</span><br><span class="line">   <span class="built_in">db</span> <span class="string">"overflow!"</span></span><br><span class="line"><span class="symbol">do0start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">202h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">9</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span>//用<span class="keyword">iret</span>也可以，用的话表示还会返回主程序中</span><br><span class="line"><span class="symbol">do0end:</span> <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h3><p>现在do0的入口为 0:200 ,写入中断向量表的0号表项中。使do0成为0号中断处理程序<br>0号表项地址为0:0 ，其中0:0存放偏移地址，0:2存放段地址。程序如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>cpu执行完一条指令后，如果检测到tf=1，则产生单步中断，单步中断类型码为1，过程如下</p>
<ol>
<li>获得中断类型码</li>
<li>标志寄存器入栈，tf if设置为0</li>
<li>cs，ip入栈</li>
<li>ip=1<em>4 cs=1</em>4+2</li>
</ol>
<p>cpu为什么要提供单步中断呢？在debug的t命令中，为什么执行完一条 指令后，能够实时的反映寄存器的状态？这便是cpu单步中断导致可以一条条指令执行</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>df标志和传送指令</title>
    <url>/2020/01/31/df%E6%A0%87%E5%BF%97%E5%92%8C%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>flag第十位是df，方向标志位，在串处理指令中，控制每次操作后si，di的增减</p>
<p>df=0，每次操作后都是si，di增</p>
<p>df=1，减</p>
<h4 id="串传送指令"><a href="#串传送指令" class="headerlink" title="串传送指令"></a>串传送指令</h4><h5 id="movsb"><a href="#movsb" class="headerlink" title="movsb"></a>movsb</h5><p>格式： movsb</p>
<p>功能：</p>
<ol>
<li>es<em>16+di=ds</em>16+si</li>
<li>如果df=0，则 si=si+1，di=di+1，等于一相反</li>
</ol>
<p>汇编语言描述</p>
<ol>
<li>mov se:[di],byte ptr ds:[si] （汇编不支持这样的指令）</li>
<li>如果df=0 inc si inc di else dec si dec di</li>
</ol>
<p>movsb的功能是将ds：si中的数据传到 es：di中</p>
<h5 id="movsw"><a href="#movsw" class="headerlink" title="movsw"></a>movsw</h5><p>格式 movsw</p>
<p>这个是按字来传送，si和di+2或-2</p>
<h5 id="rep"><a href="#rep" class="headerlink" title="rep"></a>rep</h5><p>rep movsb</p>
<p>相当于</p>
<pre><code>s: movsb
  loop s</code></pre><p>rep的作用是根据cx的值，重复执行后面的串传送指令</p>
<h4 id="df-设置指令"><a href="#df-设置指令" class="headerlink" title="df 设置指令"></a>df 设置指令</h4><p>cld 指令： 将df设置为0<br>std指令： 将df设置为1</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>检测比较结果的条件转移指令</title>
    <url>/2020/01/31/%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>转移是指它可以修改ip，条件指在某种特定情况下才会修改</p>
<p>例如 jcxz就是一个条件转移指令，只有在cx=0的情况下才会跳转</p>
<p>下列转移指令都是根据cmp指令进行的转移</p>
<h3 id="无符号数情况下的转移"><a href="#无符号数情况下的转移" class="headerlink" title="无符号数情况下的转移"></a>无符号数情况下的转移</h3><p>|指令|含义|检测的标志位|<br>|—-|<br>|je|等于则转移|zf=1|<br>|jne|不等于则转移|zf=0|<br>|jb|小于则转移|cf=1|<br>|jnb|大于等于则转移|cf=0|<br>|ja|高于则转移|cf=0且zf=0|<br>|jna|不高于则转移|cf=1或zf=1|</p>
<p>记忆方法：第一个字母都是j，代表jump</p>
<p>e：equal</p>
<p>ne：not equal</p>
<p>b：below</p>
<p>a：above </p>
<p>不一定要在前面是cmp指令，例如</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">je</span> s</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="symbol">s:</span> <span class="keyword">inc</span> <span class="built_in">ax</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>标志寄存器</title>
    <url>/2020/01/29/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<p>标志寄存器16位中只有9位有特殊作用</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody><tr>
<td>CF</td>
<td>0</td>
<td>PF</td>
<td>0</td>
<td>AF</td>
<td>0</td>
<td>ZF</td>
<td>SF</td>
<td>IF</td>
<td>DF</td>
<td>OF</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<h4 id="ZF"><a href="#ZF" class="headerlink" title="ZF"></a>ZF</h4><p>ZF含义是执行完指令后结果是否为0，为0,ZF=1，不为0,ZF=0</p>
<p>例如 </p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">mov ax,<span class="number">1</span> ;ZF=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">ax</span>,1 </span>;ZF=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="PF"><a href="#PF" class="headerlink" title="PF"></a>PF</h4><p>奇偶标志位，它记录相关指令执行后，其结果的所有bit为中1的个数是否为偶数，如果1的个数为偶数，pf=1,反之则为0</p>
<h4 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h4><p>符号标志位，看结果是否为负，如果为负，则SF=1</p>
<h4 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h4><p>进位标志位，一般情况下，对无符号数运算时，它记录了超过最高位的值</p>
<p>例如 ，add 255,255 这时已经超过最高位了，我们已经知道，超过最高位的数据都会被丢失，实际上它被保存在CF中，但只会保存一位</p>
<p>做减法时，还有可能发生错位，例如，两个8位数据，-4+5，将产生错位。错位后，相当于计算 252+5，超过255，因此会记录，因为无符号数中负数就是255-该值。<strong>小的减大的时会产生借位</strong></p>
<h4 id="OF"><a href="#OF" class="headerlink" title="OF"></a>OF</h4><p>溢出标志位，在有符号数运算时，可能会产生溢出，即小于最小值或大于最大值，如果超出，就会让OF=1</p>
<h4 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h4><p>adc是带进位加法指令，它利用了CF位上记录的进位值</p>
<p>格式 adc 对象1，对象2</p>
<p>功能 对象1=对象1+对象2+CF</p>
<p>例</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>执行后ax=4，adc执行时，相当于计算 ax+1+CF=2+1+1=4</p>
<p>这个指令有什么意义呢？实际上加法都可以分为两步操作，第一步是低位相加，第二步是高位相加再加上低位的进位，用汇编语言可以表示为</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="keyword">adc</span> <span class="number">ah</span>,<span class="number">bh</span></span><br></pre></td></tr></table></figure>
<p>这样我们就可以对更大的数据进行运算</p>
<p>例：计算1EF0001000H+2010001EF0H,结果放在ax（最高16位），bx，cx中<br>计算分三步</p>
<ol>
<li>先将低16位相加，完成后，CF记录本次进位值</li>
<li>再将中16位与CF相加，完成后，CF记录本次相加进位值</li>
<li>最后将高16位与CF相加<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">001eh</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0f000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">cx</span>,<span class="number">1ef0h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">0020h</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h4><p>带借位减法指令</p>
<p>格式 sbb 对象1，对象2</p>
<p>功能： 对象1=对象1-对象2-CF</p>
<h4 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h4><p>比较指令，相当于减法指令，但是不保存结果，只对标志寄存器产生影响</p>
<p>格式： cmp 对象1，对象2</p>
<p>功能： 对象1-对象2，但并不保存结果，对寄存器产生影响</p>
<p>例：</p>
<p>cmp ax，bx</p>
<ol>
<li><p>ax=bx，则ax-bx=0，zf=1</p>
</li>
<li><p>ax！=bx，则zf=0</p>
</li>
<li><p>ax&lt;bx, 将产生借位，cf=1</p>
</li>
<li><p>ax&gt;=bx, cf=0</p>
</li>
<li><p>ax&gt;bx  ,不产生借位结果又不为0，所以zf=0，cf=0</p>
</li>
<li><p>ax&lt;=bx,可能产生借位结果也可能为0，所以zf=1或cf=1</p>
</li>
</ol>
<p>这是无符号位的，还有有符号位的</p>
<p>同理 </p>
<ol>
<li>ax=bx，则zf=1</li>
<li>ax！=bx，zf=0</li>
</ol>
<p>但是这时就不能简单的用sf来判断了，因为sf只是符号标志位，它记录了计算结果的正负，但它并不能判断溢出。所以我们同时还要运用寄存器of来判断溢出</p>
<p>例： sf=1，of=0. of=0，说明没有溢出，直接用sf判断即可，sf=1说明ax&lt;bx</p>
<p>sf=1,of=1.这样就说明有溢出，<strong>因此说明是由于溢出导致结果为负，所以真正的结果必然为正</strong>，所以ax&gt;bx</p>
<p>sf=0,,of=1. 有溢出，ah&lt;bh</p>
<h4 id="标志寄存器在debug中的表示"><a href="#标志寄存器在debug中的表示" class="headerlink" title="标志寄存器在debug中的表示"></a>标志寄存器在debug中的表示</h4><table>
<thead>
<tr>
<th>标志</th>
<th>值为1的标记</th>
<th>值为0的标记</th>
</tr>
</thead>
<tbody><tr>
<td>of</td>
<td>ov</td>
<td>nv</td>
</tr>
<tr>
<td>sf</td>
<td>ng</td>
<td>pl</td>
</tr>
<tr>
<td>zf</td>
<td>zr</td>
<td>nz</td>
</tr>
<tr>
<td>pf</td>
<td>pe</td>
<td>po</td>
</tr>
<tr>
<td>cf</td>
<td>cy</td>
<td>nc</td>
</tr>
<tr>
<td>df</td>
<td>dn</td>
<td>up</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编语言写函数</title>
    <url>/2020/01/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%86%99%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>例,计算data段第一行的三次方，并储存到第二行上</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">    <span class="built_in">dd</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span></span><br><span class="line"><span class="symbol">  s:</span> <span class="keyword">mov</span> <span class="built_in">bx</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">call</span> cube</span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">di</span>].<span class="number">2</span>,<span class="built_in">dx</span> ；这个的含义是[<span class="built_in">di</span>]的第二个字节</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">4</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">cube:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"> code ends</span><br><span class="line"> end start</span><br></pre></td></tr></table></figure>
<p> 这个程序函数是cube，注意想要跳转就用call，想要返回就用ret。这时返回值存在ax和dx中，参数在bx中，可如果有多个参数，寄存器不够时，可以用栈来传递参数</p>
<h3 id="用栈传递参数"><a href="#用栈传递参数" class="headerlink" title="用栈传递参数"></a>用栈传递参数</h3><p> 例：计算（a-b）^3，a，b为字型数据<br> 参数 进入子程序时，栈顶存放ip，后面依次存放a，b<br> 结果：（dx：ax）=(a-b)^3<br> <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">difcube:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">4</span>] <span class="comment">;将a的值送入栈中</span></span><br><span class="line">      <span class="keyword">sub</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">6</span>] ；减去b的值</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">ret</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><br> ret n的含义为，pop ip add sp，n</p>
<p> 而ret 4 的原因是此时栈中有2个数据，要想把栈清空，要移动四个单位（字型）。而push bp ，pop bp 是为了保证bp中的数据没有改变</p>
<h3 id="寄存器冲突问题"><a href="#寄存器冲突问题" class="headerlink" title="寄存器冲突问题"></a>寄存器冲突问题</h3><p> 例 将data段中的字母变为大写，以0结尾<br> <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">   <span class="built_in">db</span> <span class="string">'fafdsfs'</span>,<span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">call</span> capital</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">5</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">capital:</span> <span class="keyword">mov</span> <span class="built_in">cl</span>,,[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">jcxz</span> ok</span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">jmp</span> short capital</span><br><span class="line"><span class="symbol">    ok:</span><span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><br>这个程序实际上是有问题的，因为进行一次capital后，cx的值一定为0，直接退出主程序的循环</p>
<p>要解决这个问题，有两种方案</p>
<ol>
<li>找另一个没有使用的寄存器</li>
<li>不要使用会发生冲突的寄存器</li>
</ol>
<p>这样实际上是不可能的，例如cx，循环便一定会冲突</p>
<p>解决方案就是，在进入函数前把所用到寄存器的内容保存起来，结束函数在进行使用</p>
<p>由此我们可以得到子程序设计的标准</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">子程序开始： 子程序中使用的寄存器入栈</span><br><span class="line">         子程序内容</span><br><span class="line">         子程序所使用寄存器出栈</span><br><span class="line">         返回 （<span class="keyword">ret</span> ，<span class="keyword">retf</span>）</span><br></pre></td></tr></table></figure>
<p> 这里要注意一个问题，当把寄存器内容入栈后，sp会发生改变，如果子程序中也要使用栈要注意地址的变化</p>
<p> 同时还要注意入账和出栈的顺序<br> 例<br> <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">capital:</span> <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">      <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">cx</span></span><br></pre></td></tr></table></figure><br> 后进先出</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>mul指令</title>
    <url>/2020/01/27/mul%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>两个相乘的数：</p>
<p>如果是8位，那么一个默认在al中，另一个在8位寄存器或内存字节单元中，如果是16位，一个在ax中，另一个在16位寄存器或内存字单元中</p>
<p>结果： 如果是8位，结果默认在ax中，如果是16位，高位默认在dx中，低位在ax中</p>
]]></content>
  </entry>
  <entry>
    <title>call指令</title>
    <url>/2020/01/27/call%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>操作</p>
<ol>
<li>将当前的ip或cs压入栈中</li>
<li>转移</li>
</ol>
<p>这里的转移与jmp相同，也有位移和内存两种方式</p>
<h3 id="根据位移"><a href="#根据位移" class="headerlink" title="根据位移"></a>根据位移</h3><p>call 标号（将ip压入栈中后，转移到标号处进行指令）<br>过程：</p>
<ol>
<li>sp+=2，ss*16+sp=ip</li>
<li>ip=ip+16位位移</li>
</ol>
<p>16位位移=标号处地址-call指令后第一个字节的地址</p>
<p>相当于 push ip，jmp near ptr 标号</p>
<h3 id="根据目的地址"><a href="#根据目的地址" class="headerlink" title="根据目的地址"></a>根据目的地址</h3><p>call far ptr 实现段间转移</p>
<p>操作： </p>
<ol>
<li>sp-=2</li>
<li>ss*16+sp=cs</li>
<li>sp-=2</li>
<li>ss*16+sp=ip</li>
<li>cs=标号所在段地址，ip=；标号所在偏移地址</li>
</ol>
<p>段内转移一般是根据位移，段间转移一般是根据地址</p>
<p>如果地址在寄存器中， call reg，ip被修改</p>
<p>如果地址在内存中</p>
<p>1 call word ptr 内存地址</p>
<p>这种是段内转移，相当于 push ip，jmp word ptr</p>
<p>2 call dword ptr 内存地址</p>
<p>段间转移 例</p>
<p>call dword ptr ds：[0] ，这样ds:[0]和ds:[1]是ip ，ds:[2]和ds:[3]是cs</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>ret 和 retf</title>
    <url>/2020/01/27/ret-%E5%92%8C-retf/</url>
    <content><![CDATA[<h3 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h3><p>ret指令用栈中的数据，修改ip中的内容，从而实现近转移</p>
<p>过程：</p>
<ol>
<li><p>ip=ss*16+sp</p>
</li>
<li><p>sp+=2</p>
</li>
</ol>
<p>相当于 pop ip</p>
<h3 id="retf"><a href="#retf" class="headerlink" title="retf"></a>retf</h3><p>修改cs和ip 的内容，实现远转移<br>过程</p>
<ol>
<li>ip=ss*16+sp</li>
<li>sp+=2</li>
<li>cs=ss*16+sp</li>
<li>sp+=2</li>
</ol>
<p>相当于 pop ip ，pop cs</p>
<p>例</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ss</span>:stack</span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>这条指令相当于把ip变为0，指向第一条指令</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>jmp进行跳转</title>
    <url>/2020/01/26/jmp%E8%BF%9B%E8%A1%8C%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<h3 id="根据位移进行的转移"><a href="#根据位移进行的转移" class="headerlink" title="根据位移进行的转移"></a>根据位移进行的转移</h3><p>用jmp进行跳转时，会发现一个奇怪的问题，无论它要跳转到哪里，它的机器码始终不变，为EB03，那么它到底是怎么告诉cpu修改ip地址的呢？</p>
<p>先回忆一下cpu读取指令的过程</p>
<ol>
<li>cs=076a ip=0006，cs：ip指向eb03</li>
<li>读取指令码eb03到指令缓冲器</li>
<li>ip=ip+指令长度=0008h，cs：ip指向下一条指令</li>
<li>cpu执行指令缓冲器中的指令eb03</li>
<li>执行完缓冲器中的指令后，ip被修改+</li>
</ol>
<p>jmp指令并不需要转移的目的地址，但是它是凭借什么转移的呢？这里有个03，正好跳过三个字节之后就是要转移的地址。原来jmp指令只需知道当前指令的下一个指令（因为执行完这条指令后ip会增加）与要跳转的指令的位移就可以了</p>
<p>jmp short 标号 功能是 ip=ip+8位位移（一字节）</p>
<p>jmp near ptr 标号 是16位</p>
<p>jmp far ptr 标号 是段间转移，可以修改cs</p>
<p>还可以直接 jmp 寄存器1：寄存器2</p>
<h3 id="根据内存进行的转移"><a href="#根据内存进行的转移" class="headerlink" title="根据内存进行的转移"></a>根据内存进行的转移</h3><p>转移地址再内存中的转移有两种格式</p>
<ol>
<li>jmp word  ptr（段内转移）</li>
</ol>
<p>例 jmp word ptr ds：[0]</p>
<p>jmp word ptr [bx]</p>
<p>2.jmp dword ptr (段间转移）后面接两个字，第一个是偏移地址，第二个是段地址</p>
<p>例 jmp dword ptr ds：[0],0 完成后段地址为0</p>
<p>注意</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">nop</span></span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,offset s</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,offset s2</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cs</span>:[<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="symbol">   s0:</span> <span class="keyword">jmp</span> short s</span><br><span class="line"><span class="symbol">   s1:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">       <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">   s2:</span> <span class="keyword">jmp</span> short s1</span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>这个程序奇怪之处在于运行到mov cs：[di],ax后 s处会变为jmp 0000，这里就要记住jmp传递的是偏移地址，也就是说，jmp short s1这个指令并不是真的跳到s1处，而是往前跳8个字节</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>操作符offset</title>
    <url>/2020/01/26/%E6%93%8D%E4%BD%9C%E7%AC%A6offset/</url>
    <content><![CDATA[<p>offset是由编译器处理的符号，它的功能是获得标号的偏移地址</p>
<p>例</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset start//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">0</span></span><br><span class="line"><span class="symbol">   s:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset s//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">3</span></span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>
<p>上面的程序中offset获得了start和s的偏移地址0和3</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>dup</title>
    <url>/2020/01/24/dup/</url>
    <content><![CDATA[<p>dup用来处理重复数据</p>
<p>例：db 3 dup (0) 这个意思是定义了三个0的字节型数据</p>
<p>db 3 dup （0,1,2) 定义了九个数据</p>
<p>db 3 dup (‘abc’,’ABC’)定义18个数据</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>dd</title>
    <url>/2020/01/24/dd/</url>
    <content><![CDATA[<p>dd是用来定义双字型</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> segment</span></span><br><span class="line">    dd <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> ends</span></span><br></pre></td></tr></table></figure>
<p>要注意dd要占两个字，db一个字节，dw一个字</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编语言数据位置的表达</title>
    <url>/2020/01/24/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE/</url>
    <content><![CDATA[<h3 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h3><p>其实就是idata，这种数据执行前在cpu的指令缓冲器中，在汇编指令中直接给出</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>指令要处理的数据在寄存器中，在汇编指令中给出相应寄存器名</p>
<h3 id="段地址（SA）和偏移地址（EA"><a href="#段地址（SA）和偏移地址（EA" class="headerlink" title="段地址（SA）和偏移地址（EA)"></a>段地址（SA）和偏移地址（EA)</h3><p>这些数据在内存中，在汇编指令中可以用[x]的方式给出</p>
<h2 id="指令要处理数据有多长"><a href="#指令要处理数据有多长" class="headerlink" title="指令要处理数据有多长"></a>指令要处理数据有多长</h2><p>用寄存器的ax或al可以很方便的说明数据长度，但是如果是内存之间的传递可以用<br>x ptr 的方式确定是字型传递还是字节性传递</p>
<p>例： mov word ptr ds:[0],1</p>
<p>mov byte ptr ds:[0],1</p>
<p>另外，push操作无需指明，因为push只对字进行操作</p>
<h2 id="结构体的汇编表达"><a href="#结构体的汇编表达" class="headerlink" title="结构体的汇编表达"></a>结构体的汇编表达</h2><p>一般来说，我们可以用[bx+idata+si]的方式来表达结构体中的数据，用bx定位整个结构体，用idata定义某一个数据项，用si确定数据项中的一个元素</p>
<p>可以简写为 [bx].idata,[bx].idata[si]</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编中的多层循环</title>
    <url>/2020/01/24/%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>因为唯一的用于统计循环次数的寄存器就是cx，所以有多层循环的时候就会碰到循环次数难以记录的问题，以下是一种解决办法</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span>//用另一个寄存器来存<span class="built_in">cx</span>的次数</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol"> s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>+<span class="built_in">bx</span>]</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">si</span>+<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">   <span class="keyword">loop</span> s</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>//这里把<span class="built_in">cx</span>次数取出来减一次</span><br><span class="line">   <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure>

<p> 但是寄存器的数量是有限的，如果多次循环可能会导致寄存器不够用，因此可以先在数据段定义一个字型数据，然后直接把循环次数放到里面<br> <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> </span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol">  s0:</span> <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">cx</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2</span></span><br><span class="line"><span class="symbol">  s:</span>  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">loop</span> s</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">     <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure><br> 此外，还可以定义一个栈，直接用push，pop命令把cx值取出存入</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>si和di</title>
    <url>/2020/01/24/si%E5%92%8Cdi/</url>
    <content><![CDATA[<p>si和di在8086cpu中的功能与bx类似，si与di不能分为两个8位寄存器来使用</p>
<p>也就是说  ds：[si]是可以的</p>
<p>如果不用这些寄存器直接写的话就会出现之前所说的编译器和exe对程序的不同处理</p>
<p>例   mov ax,[si]在exe中就是 ds：[si]，但是如果是 mov，ax,[1]在exe中就是把ax中的数据放入1中</p>
<p>甚至可以直接用[bx+si]的方式或[bx+si+idata]的方式来指明内存地址</p>
<h3 id="不同寻址方式的比较"><a href="#不同寻址方式的比较" class="headerlink" title="不同寻址方式的比较"></a>不同寻址方式的比较</h3><p>[idata]用于一个常量的寻址，直接定位一个内存单元</p>
<p>[bx]用于一个变量来表示内存地址，间接定位内存单元</p>
<p>只有bx,bp,di,si具有寻址能力，例如ds:[dx]等都是错误的</p>
<p>并且这几个寄存器间组合还有要求，只有bx+si,bx+di,bp+si,bp+di这四种情况是正确的</p>
<p>只要使用bp，它的段寄存器默认为ss</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>字符形式 的数据</title>
    <url>/2020/01/23/%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F-%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>首先要知道asc11码</p>
<p>形式： db ‘…’</p>
<p>无论多少个单词都只需要单引号</p>
<p>例 db‘unix’</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>将不同代码放入不同段中</title>
    <url>/2020/01/23/%E5%B0%86%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E6%AE%B5%E4%B8%AD/</url>
    <content><![CDATA[<p>举个栗子</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code <span class="built_in">ds</span>:data <span class="built_in">ss</span>:stack</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0345h</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">20h</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span> //<span class="built_in">ds</span>:<span class="built_in">bx</span>指向data中第一个内存单元</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s0:</span><span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s0</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"> code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>看了这个就差不多了，前面定义的时候要注意不同段对应不同的寄存器，而后面要注意各个段有独自的segment与ends，而且从start开始要把各个段寄存器赋值，以备后面使用（mov ax，data）<strong>注意</strong> mov ds，data是错误的，8086cpu不允许直接把一个数值送入段寄存器中</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>在代码段中使用栈</title>
    <url>/2020/01/23/%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88/</url>
    <content><![CDATA[<p>实际上栈是我们人为定义的一段内存空间，所以先要用dw来申请</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>  //申请<span class="number">6</span>个字的内存空间，栈是由高内存地址到低内存地址，所以栈顶为<span class="built_in">cs</span>：<span class="number">Ch</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">Ch</span></span><br></pre></td></tr></table></figure>
<p>ss，sp就是前面所说的栈的指针</p>
]]></content>
  </entry>
  <entry>
    <title>dw</title>
    <url>/2020/01/23/dw/</url>
    <content><![CDATA[<p>dw即define word，定义字型数据。例如，dw 0123h,0456h,0789h.这样就定义了几个字型数据，那这些数据都在哪里呢，他们的段地址都是从cs开始的，而偏移地址从0开始，也就是说，0123h的偏移地址是0,0456h的偏移地址是2,0789h的偏移地址是6。</p>
<p>但是这样会带来一个问题，因为前十六个字节是dw所定义的字型数据，所以这样可能使程序的入口出现问题，所以可以</p>
<pre><code>assume cs:codesg
codesg segment
dw 0123h,0456h,0789h

start: mov bx,0
mov ax,0
mov cx,8
s: add ax,cs:[bx]
add bx,2
loop s
mov ax,4c00h
int 21h

codesg ends
end start</code></pre><p>这里就是加上了一个标号start，这个标号的意思就是确定程序的入口，而最后在end这里还要来一个start，因为end的作用除了确定程序在哪里终止之外，还有一个作用是告诉编译器程序在哪里开始（因为这时一个伪指令）</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>debug和源程序对指令的不同处理</title>
    <url>/2020/01/22/debug%E5%92%8C%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%AF%B9%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title="[]"></a>[]</h3><p>debug程序中[0]表示 ds：0处的数据进行处理</p>
<p>而源程序中表示把0这个数据给要处理的数据</p>
<p>例 mov ax,[0]在debug中表示把ds：0处元素给ax，而在源程序中表示把0给ax</p>
<p>在程序中，可以直接使用段寄存器加偏移地址来确定访问的元素，例如：ds：[bx],cs:[bx],ss:[bx]等</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>[bx]和loop</title>
    <url>/2020/01/21/bx-%E5%92%8Cloop/</url>
    <content><![CDATA[<h3 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h3><p>mov ax,[bx]</p>
<p>这个的意思是把ds：bx处的内容放入ax中</p>
<p>mov [bx],ax</p>
<p>这个的意思是把ax中的内容放入 地址ds：bx处</p>
<h3 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h3><p>实际上还有更加灵活的方式指明内存地址，就是bx后加一个数据，这个数据可以是常数，也可以是变量</p>
<p>例 mov ax,ds:[bx+200]，也可以直接写为ds：200[bx]</p>
<p>这种处理方式可以方便的处理数组</p>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>格式：loop+标识符</p>
<p>执行过程：执行到loop时，先让cx-=1,再判断cx中的值，不为0则转至标号处继续执行，为0则进行下一步操作，寄存器cx用来储存循环次数</p>
<p>例</p>
<pre><code>mov cx,3
mov ax,2
s: add ax,ax
  loop s</code></pre><p>这段程序的作用是计算2的三次方，首先让循环次数为3，ax=2，再从s处开始循环，当cx=0时退出，即进行3次</p>
<h3 id="用debug跟踪loop指令"><a href="#用debug跟踪loop指令" class="headerlink" title="用debug跟踪loop指令"></a>用debug跟踪loop指令</h3><p> tip：汇编程序中，数据不能以字母开头，所以如A231h等等前面都要加一个零</p>
<p> 如果想直接结束循环可以用p命令，如果用t命令的话，只会结束这一次循环</p>
]]></content>
  </entry>
  <entry>
    <title>程序执行过程的跟踪</title>
    <url>/2020/01/21/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B7%9F%E8%B8%AA/</url>
    <content><![CDATA[<p>运用debug +程序名进入debug过程</p>
<p>例如 debug 1.exe</p>
<p>程序开始都是从0000的偏移地址开始的，设段地址为A，而程序开始有一段不做该程序内容，而有其他用途。这段程序占256个字节，叫psp，之后段地址偏移10h，所以真正的程序是从A+10:0 开始的（256个字节在16进制中是10，而A也是用16进制表示的）</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>从asm到exe</title>
    <url>/2020/01/21/%E4%BB%8Easm%E5%88%B0exe/</url>
    <content><![CDATA[<p>先要有masm.exe和link.exe，然后输入masm+程序名和link+程序名</p>
<p>或者masm+盘符+程序名，可以省略中间过程，节省时间<br>例：masm c:\1.asm</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编的第一个程序</title>
    <url>/2020/01/20/%E6%B1%87%E7%BC%96%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>编译器中，包含两种指令，一种是汇编指令，一种是伪指令。伪指令是给编译器看的，最终不会被cpu执行。先了解三个最为基础的伪指令</p>
<ul>
<li>XXX segment，XXX ends，这两个是配套使用的。功能是定义一个代码段，一个段必须要有一个名称标识（XXX是也）</li>
</ul>
<p>例如codesg segment ，codesg ends</p>
<ul>
<li>assume </li>
</ul>
<p>这条指令作用是假设某一寄存器和程序中的某一个用segment和ends定义的段相关联，写在最开头。</p>
<ul>
<li>end</li>
</ul>
<p>没什么特别的，程序的结束标识，不写程序不知道在哪里结束</p>
<h3 id="一个程序"><a href="#一个程序" class="headerlink" title="一个程序"></a>一个程序</h3><pre><code>assume cs: codesg
codesg segment
    mov ax,0123
    mov bx,0456
    add ax,bx
    mov ax,4c00
    int 21
codesg ends
end</code></pre><h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>在单任务操作系统上，一次只可以执行一个程序，那么当我们写的这个程序执行完之后，还要把cpu控制权交给dos，而mov ax，4c00 和 int 21 就是做这个工作的</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>栈.                                      </title>
    <url>/2020/01/20/%E6%A0%88/</url>
    <content><![CDATA[<p>栈是一段连续的内存空间，这个空间的特殊性在于，最后进入这个空间的数据，最先出去</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过ss sp 两个寄存器确定了一个栈顶指针，然后随着一些操作，这个指针会向上向下移动<br>例如 push ax，这条指令会将ax中的内容运到栈中，然后sp-2。<strong>注意</strong>，栈顶地址为低地址，栈底地址为高地址，因此增加元素会使sp值减小</p>
<p>在栈为空的时候，偏移地址为栈底地址加2，例如栈底为000F，则此时偏移地址为10，在拉一个元素进栈后，偏移地址为000E，恰好是数据最高位（一个数据一个字，两个字节，栈底为000F，用了两个空间，因此此时元素到了000E，恰好sp也是000E</p>
<h3 id="超界问题"><a href="#超界问题" class="headerlink" title="超界问题"></a>超界问题</h3><p>8086cpu并没有特定的机制来检查我们是否超界，只能够靠自己小心，超界是一个十分严重的问题，因为既然这一段被分配为栈了，说明其他的内存有其他的用途，如果超界，可能会干扰其他程序的运行。要注意，栈的范围最大是0到ffff即2的16次方字节</p>
<h3 id="push-pop-命令"><a href="#push-pop-命令" class="headerlink" title="push pop 命令"></a>push pop 命令</h3><p>push 寄存器 pop 寄存器<br>也可以是push内存地址，pop内存地址 </p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>debug</title>
    <url>/2020/01/20/debug/</url>
    <content><![CDATA[<p>这里列举几个debug的基本命令</p>
<h4 id="r"><a href="#r" class="headerlink" title="r"></a>r</h4><p>用来查看此时寄存器内的数值和下一步将要执行的命令<br>r 还可以接寄存器，用于修改寄存器内的内容<br>例：r ax 这样会出现ax的内容和一个冒号，然后就可以输入数据修改了</p>
<h3 id="d"><a href="#d" class="headerlink" title="d"></a>d</h3><p>格式：d 段地址：偏移地址<br>作用：列举出该地址下的机器码<br>例 d 1000:0,这样子将会列举从1000:0 到1000:7f的所有内容</p>
<h3 id="e"><a href="#e" class="headerlink" title="e"></a>e</h3><p>格式：e 段地址：偏移地址<br>作用：修改改地址下的机器码</p>
<h3 id="t"><a href="#t" class="headerlink" title="t"></a>t</h3><p>执行cs ip所指向内存地址的命令，直接输入t，不需要输入其他东西</p>
<h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>作用：用汇编语言输入指令到内存上<br>写法： a 段地址：偏移地址<br>例： a 1000:0<br>输出1000：0  （input）mov ax，1<br>然后1000:0 到1000:3 就会输入这条指令了，之后将cs ip地址设置一下，然后用t指令运行</p>
<h3 id="u"><a href="#u" class="headerlink" title="u"></a>u</h3><p>作用：查看某地址下的汇编程序<br>写法： u 段地址：偏移地址<br>例 u 1000:0<br>然后就会输出1000:0 开始有的汇编指令了</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>树状数组和线段树</title>
    <url>/2020/01/18/%E7%BA%BF%E6%AE%B5%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h3 id="lowbit函数"><a href="#lowbit函数" class="headerlink" title="lowbit函数"></a>lowbit函数</h3><p>lowbit函数指的是将元素与元素的补码按位与，即a&amp;-a，这个值返回的是从右数第一个1开始的值</p>
<p>例如 6&amp;-6， 6二进制位为110，所以6的lowbit函数值为10，即十进制下的二</p>
<pre><code>ll lowbit(ll num)
{
    return num&amp;-num;
}</code></pre><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>首先我们可以把一整个数组分为若干小部分，然后让这几个小部分叠加就可以得到数组总的和。例如，我想求a[91],我可以先求c[88],发现c[88]管理2个数，再找c[86]，这样一直进行下去就可以了。</p>
<p>c又是什么呢？例如c[6]，它的lowbit函数为2，因此它管理两位数，所以c[6]=a[5]+a[6]</p>
<p>奇数位的c[i]只有他自己，而偶数位c[i]为2的k次方</p>
<h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">add</span>(int <span class="keyword">x</span>, int k) &#123;</span><br><span class="line">  while (<span class="keyword">x</span> &lt;= n) &#123;  //不能越界</span><br><span class="line">    <span class="keyword">c</span>[<span class="keyword">x</span>] = <span class="keyword">c</span>[<span class="keyword">x</span>] + k<span class="comment">;</span></span><br><span class="line"><span class="comment">    x = x + lowbit(x);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个函数是把a[x]加上k，小于x的c不用修改</p>
<p>关键是x=x+lowbit(x)<br><img src="/images/1103198-20180725163149813-311841231.png" alt=""><br>从此图中我们可以看出，要想求偶数位节点大小，需要将所有子节点加起来，先要加自己和比自己小一位的奇数，再加上所有i+lowbit(i)=8的偶数</p>
<h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">int getsum(int <span class="symbol">x</span>) &#123;  <span class="comment">// a[1]……a[x]的和</span></span><br><span class="line">  int ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keywords">while</span> (<span class="symbol">x</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ans = ans + c[<span class="symbol">x</span>];</span><br><span class="line">    <span class="symbol">x</span> = <span class="symbol">x</span> - lowbit(<span class="symbol">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keywords">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">  <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; ++<span class="built_in">i</span>) &#123;</span><br><span class="line">    t[<span class="built_in">i</span>] += a[<span class="built_in">i</span>];</span><br><span class="line">    int <span class="built_in">j</span> = <span class="built_in">i</span> + lowbit(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">j</span> &lt;= n) t[<span class="built_in">j</span>] += t[<span class="built_in">i</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> kth(<span class="built_in">int</span> k) &#123;  <span class="comment">//权值树状数组查询第k小</span></span><br><span class="line">  <span class="built_in">int</span> cnt = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = log2(n); ~i; --i) &#123;</span><br><span class="line">    ret += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= n || cnt + t[ret] &gt;= k)</span><br><span class="line">      ret -= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cnt += t[ret];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>含义：线段树指的是将一个区间不断二分所形成的一个二叉树，根结点代表arr[0:N]区间所对应的信息，接着根结点被分为两个子树，分别存储arr[0:(N-1)/2]及arr[(N-1)/2+1:N]两个子区间对应的信息</p>
<p>初始化：注意此处我们对于segmentTree]数组的索引从1开始算起。则对于数组中的任意结点i，其左子结点为<code>2*i</code>，右子结点为<code>2*i + 1</code>，其母结点为i/2。<br><img src="/images/%E5%9B%BE%E7%89%879.png" alt=""><br><img src="/images/%E5%9B%BE%E7%89%8710.png" alt=""><br><img src="/images/%E5%9B%BE%E7%89%878.png" alt=""><br>递归实际意义是先向底层递归，然后从底层向上回溯，p的意思是节点的编号</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> build(<span class="built_in">int</span> s, <span class="built_in">int</span> t, <span class="built_in">int</span> p) &#123;</span><br><span class="line">  <span class="comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">  <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">int</span> m = (s + t) / <span class="number">2</span>;</span><br><span class="line">  build(s, m, p * <span class="number">2</span>), build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p>区间修改指的是把区间内连续多个数同时修改</p>
<p><img src="/images/%E5%9B%BE%E7%89%8711.png" alt="">标记的作用是记录每次、每个节点要更新的值</p>
<p>另一种写法</p>
<p><img src="/images/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt=""></p>
<p>当使用lazy函数时，会让下一层的数加上相应的数并附上相应懒标记，同时根节点的懒标记将被清除，这样一层层往下就可以让每一个数都加上该值</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span>;</span><br><span class="line">    <span class="built_in">int</span> lz;</span><br><span class="line">&#125;sgm[<span class="built_in">MAX</span>*<span class="number">4</span>];</span><br><span class="line">#define <span class="built_in">mid</span> ((l+r)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">#define lc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">#define rc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">voide lazy(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> l,<span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">/*懒标记的作用是标记当前区间应该加上/减去的值，但是先不直接加，而是进行标记*/</span><br><span class="line">    sgm[lc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[lc].<span class="built_in">sum</span>+=(<span class="built_in">mid</span>-l+<span class="number">1</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].<span class="built_in">sum</span>+=(r-<span class="built_in">mid</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[<span class="built_in">n</span>].lz=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p><img src="/images/%E5%9B%BE%E7%89%8712.png" alt=""></p>
<p>这里的push_down就是另一种写法中的lazy</p>
<p>总代码</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define lc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">#define rc (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">#define <span class="built_in">mid</span> ((l+r)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">#define <span class="built_in">MAX</span> <span class="number">100</span></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span>;</span><br><span class="line">    <span class="built_in">int</span> lz;</span><br><span class="line">&#125;sgm[<span class="built_in">MAX</span>*<span class="number">4</span>];</span><br><span class="line">void lazy(<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sgm[lc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].lz+=sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[lc].<span class="built_in">sum</span>+=(<span class="built_in">mid</span>-l+<span class="number">1</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[rc].<span class="built_in">sum</span>+=(r-<span class="built_in">mid</span>)*sgm[<span class="built_in">n</span>].lz;</span><br><span class="line">    sgm[<span class="built_in">n</span>].lz=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">void build(<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> a[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=a[l];</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    build(l,<span class="built_in">mid</span>,lc,a);</span><br><span class="line">    build(<span class="built_in">mid</span>+<span class="number">1</span>,r,rc,a);</span><br><span class="line">    sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=sgm[lc].<span class="built_in">sum</span>+sgm[rc].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line">void update(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> L,<span class="built_in">int</span> R,<span class="built_in">int</span> l,<span class="built_in">int</span> r,<span class="built_in">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>+=(r-l+<span class="number">1</span>)*num;</span><br><span class="line">        sgm[<span class="built_in">n</span>].lz+=num;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy(l,r,<span class="built_in">n</span>);</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(lc,L,R,l,<span class="built_in">mid</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(R&gt;<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(rc,L,R,<span class="built_in">mid</span>+<span class="number">1</span>,r,num);</span><br><span class="line">    &#125;</span><br><span class="line">    sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>=sgm[lc].<span class="built_in">sum</span>+sgm[rc].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> ask(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> L,<span class="built_in">int</span> R,<span class="built_in">int</span> l,<span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        return sgm[<span class="built_in">n</span>].<span class="built_in">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy(l,r,<span class="built_in">n</span>);</span><br><span class="line">    <span class="built_in">if</span>(L&lt;=<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=ask(lc,L,R,l,<span class="built_in">mid</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span>(R&gt;<span class="built_in">mid</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=ask(rc,L,R,<span class="built_in">mid</span>+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a[<span class="number">10</span>];</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>,a);</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;sgm[i].<span class="built_in">sum</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    update(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ask(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>字符串之KMP算法</title>
    <url>/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8BKMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="由（扯）来（蛋）"><a href="#由（扯）来（蛋）" class="headerlink" title="由（扯）来（蛋）"></a>由（扯）来（蛋）</h3><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这三人的姓氏命名此算法。</p>
<h3 id="最长前缀和与后缀和"><a href="#最长前缀和与后缀和" class="headerlink" title="最长前缀和与后缀和"></a>最长前缀和与后缀和</h3><p>例如给出一个字符串ABCDABD<br><img src="/images/331.jpg" alt=""><br>前缀和就是从前往后数i个，后缀和是从第n-i个数到最后一个，首先我们便要找到每一个字母的最长相同前缀后缀和，然后求next数组，注意，只有一个元素时是不计算前缀后缀的，直接看为0</p>
<h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>next数组考虑的是除当前字符外的最长相同前缀后缀，实际上就是前一个前缀后缀和，因为把最后一个字母上去之后必定会使后缀和少一个，因此前缀后缀和也会-1，注意next数组中会出现-1，<strong>实际上这个数组就是将原数组整体右移一位，然后在第0位补上-1</strong></p>
<p><img src="/images/3331.jpg" alt=""></p>
<p><img src="/images/3332.jpg" alt=""></p>
<h3 id="用next数组进行匹配"><a href="#用next数组进行匹配" class="headerlink" title="用next数组进行匹配"></a>用next数组进行匹配</h3><p>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀 pj-k pj-k+1, …, pj-1 跟文本串 si-k si-k+1, …, si-1 匹配成功，但 pj 跟 si 匹配失败时，因为 next[j] = k，相当于在不包含 pj 的模式串中有最大长度为 k 的相同前缀后缀，即 p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令 j = next[j]，从而让模式串右移 j - next[j] 位，使得模式串的前缀 p0 p1, …, pk-1 对应着文本串 si-k si-k+1, …, si-1，而后让 pk 跟 si 继续匹配。如下图所示：<br><img src="/images/323.jpg" alt=""></p>
<p><strong>解释</strong>：因为前缀和后缀和相等，当最后一个匹配失误的时候就可以直接跳到后缀和开始的地方，这样就一下子匹配到了几位数，加快速度，至于合理性 ，K M P 这三个人已经证明过，而具体要跳几位呢？</p>
<p>比如说你有7个数，前面6个数已经匹配好了，结果第七位出了问题，这时一找next数组，发现第6位前缀和为2，那我们就要跳到第五位上去，找找规律，就是j-next[j]呀，没错，就是要跳这么多位，忘了自己推一下就好了，挺好推的</p>
<p><strong><em>失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</em></strong></p>
<h3 id="next数组求法"><a href="#next数组求法" class="headerlink" title="next数组求法"></a>next数组求法</h3><p>这里运用了递归的思想，首先对于前一两个可以直接写出来，然后对于后面的，假如第j个next值我们已经求出来了，那么对于第j+1个，</p>
<ol>
<li>如果p[k]=p[j]，则next[j+1]=k+1</li>
</ol>
<p>例如<img src="/images/3343.jpg" alt=""><br>C为p[j]，E为p[j+1]，next[j]=2,则第一，第二个与第五，第六个相同，如果第三个和3七个相同，则最大相同长度就为3，即p[k]=p[j]</p>
<p>2.如果p[k]!=p[j],则递归找p[next[k]]是否等于p[j]，p[next[next[k]]]是否等于p[j],直到找到或到了开头</p>
<p>对于第二种情况，也可以通过图来展示<br><img src="/images/3344.jpg" alt=""><br>现在p[j]!=p[k]，那么肯定要缩小范围，我么已经知道第一个与第二个是匹配的了，那么第五个第六个对应与第一个第二个匹配，但如果那里面没有前后缀的话，你减去一个就相当于破坏了结构（前缀从前往后，后缀也是从前往后，减去一个便要求这这个前缀串里面前几个要和后缀串里面后面几个匹配，因此要求next[k]就是为了里面要匹配，这样只需比较p[next[k]]和p[j]即可），假如中间就碰到了，那么next[j+1]=next[next[k]]+1,如果没碰到，那么next[j+1]=0（一朝回到解放前）</p>
<p>代码实现：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> GetNext(char* p,<span class="built_in">int</span> next[])  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">int</span> pLen = strlen(p);  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k;  </span><br><span class="line">            ++j;  </span><br><span class="line">            next[j] = k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配（最终代码）"><a href="#匹配（最终代码）" class="headerlink" title="匹配（最终代码）"></a>匹配（最终代码）</h3><p>匹配过程：</p>
<p>“假设现在文本串S匹配到 i 位置，模式串 P 匹配到 j 位置</p>
<p>如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符；</p>
<p>如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j] 位。</p>
<p>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。”</p>
<p>例 <img src="/images/3353.png" alt=""></p>
<p>例如此时i=10,j=6,此时文本串该位为空格，而匹配串为D，这时不匹配，就要让匹配串移动6-next[6]=4位，我令i=10,j=2,即匹配串为C,这就相当于让匹配位左移4位，而文本对应位不变，于是相当于匹配串右移4位（有种物理相对运动的既视感）</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      </span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      </span></span><br><span class="line">            <span class="comment">//next[j]即为j所对应的next值        </span></span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感到了代码的优美感有没有！</p>
<p>但是这样还可以优化</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>优化过后的<span class="keyword">next</span> 数组求法  </span><br><span class="line">void GetNextval(char* p, int <span class="keyword">next</span>[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int pLen = strlen(p);  </span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;  </span><br><span class="line">    int k = -<span class="number">1</span>;  </span><br><span class="line">    int j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">//</span>p[k]表示前缀，p[j]表示后缀    </span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k])  </span><br><span class="line">        &#123;  </span><br><span class="line">            ++j;  </span><br><span class="line">            ++k;  </span><br><span class="line">            <span class="regexp">//</span>较之前<span class="keyword">next</span>数组求法，改动在下面<span class="number">4</span>行  </span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])  </span><br><span class="line">                <span class="keyword">next</span>[j] = k;   <span class="regexp">//</span>之前只有这一行  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="regexp">//</span>因为不能出现p[j] = p[ <span class="keyword">next</span>[j ]]，所以当出现时需要继续递归，k = <span class="keyword">next</span>[k] = <span class="keyword">next</span>[<span class="keyword">next</span>[k]]  </span><br><span class="line">                <span class="keyword">next</span>[j] = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            k = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有点蒙，就先这样吧</p>
<p><a href="https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html" target="_blank" rel="noopener">参考文章（这篇文章真的太好了，生怕你不会）</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串之hash算法</title>
    <url>/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8Bhash%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="hash基础概念"><a href="#hash基础概念" class="headerlink" title="hash基础概念"></a>hash基础概念</h3><p>但在工程实践中，要查找的关键字往往都不是自然数，即使是自然数也有可能是很大的值。因此，只要我们提前把关键字转换为在固定较小范围内的自然数，就可以实现常数时间的查找。那么问题来了，如何实现该转换关系呢？这就是哈希函数所要完成的工作。</p>
<p>哈希函数：又称散列函数，是把一段有限二进制串（字符串，整数等）转换为自然数的一种函数。</p>
<p>哈希值：哈希函数输出的最终结果。</p>
<p>字符串哈希函数：输入是字符串的哈希函数。</p>
<p>注：实际上就是用一个函数将字符串转化为整数，然后尽可能使一个整数对应一个字符串</p>
<p>现在的哈希函数基本上都是满射，多个字符串会对应一个数字，这种情况佳作冲突，为了减小冲突，列举几种方法</p>
<p><img src="/images/%E5%9B%BE%E7%89%876.png" alt=""><br>这种方法就是用进制转换的观念，一般用128,但这样十分容易超int型的范围，因此要想办法减小范围，可以用一个较大的数去摸，这时又出现了冲突的问题，那可以用两个数同时去摸，这样用两个数表示一个字符串冲突的几率便大大降低</p>
<p>BKDRHash算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BKDR Hash Function</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);<span class="comment">//ox7FFFFFFF代表int型最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;是与运算符，<a href="https://blog.csdn.net/ssdjdk/article/details/90199634" target="_blank" rel="noopener">详细看这</a></p>
<p>关于 <a href="https://blog.csdn.net/MyLinChi/article/details/79509455" target="_blank" rel="noopener">BKDRHash算法可以看</a></p>
<p>最好用unsigned int 类型，<a href="https://www.cnblogs.com/lailailai/p/4030151.html" target="_blank" rel="noopener">这样相当于每次hash操作都取了一次模</a></p>
<p>APhash算法</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">// AP Hash Function</span><br><span class="line">unsigned int APHash(<span class="name">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int hash = 0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    for (i=0; *str<span class="comment">; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if ((<span class="name">i</span> &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= ((<span class="name">hash</span> &lt;&lt; <span class="number">7</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">3</span>))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= (~((<span class="name">hash</span> &lt;&lt; <span class="number">11</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">5</span>)))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return (<span class="name">hash</span> &amp; <span class="number">0</span>x7FFFFFFF)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/MyLinChi/article/details/79508112" target="_blank" rel="noopener">这篇博客讲的很详细</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/01/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h3><p>无后效性是一个问题可以用动态规划求解的标志之一，理解无后效性对求解动态规划类题目非常重要</p>
<p>概念：某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响（某度上找的定义）</p>
<p>理解：无后效性指的是之前做过的事现在还可以继续去做，这便是前一阶段做的事对后一阶段无影响。如果前面做过了后面便不能去做或者做的事受限这便是有后效性</p>
<p>例：<a href="https://blog.csdn.net/qq_30137611/article/details/77655707" target="_blank" rel="noopener">这篇博客讲的很清楚</a></p>
<h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p><a href="https://xinhecuican.github.io/2020/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">之前的一篇博客</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">struct Good&#123;</span><br><span class="line"><span class="code">    int w;</span></span><br><span class="line"><span class="code">    int v;</span></span><br><span class="line">&#125;goods[101];</span><br><span class="line">int dp[<span class="string">101</span>][<span class="symbol">1001</span>];</span><br><span class="line">int n,S;//n表示有n个物品，S表示背包的最大容积</span><br><span class="line">for (i = 1; i <span class="xml"><span class="tag">&lt;<span class="name">=</span> <span class="attr">n</span>; <span class="attr">i</span>++)</span></span></span><br><span class="line"><span class="xml">&#123;</span></span><br><span class="line"><span class="xml">    for (j = S; j &gt;</span>= goods[i].w; j--)</span><br><span class="line"><span class="code">        dp[j] = max(dp[j], dp[j - goods[i].w] + goods[i].v);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，之所将j初始化为S，逆序循环更新状态是为了保证在更新dp[j]时，dp[j-goods[i].w]的状态尚未因为本次更新而发生改变，即等价于由</p>
<p>dp[i-1][j-goods[i].w]转移得到dp[i][j]。保证了更新dp[j]时，dp[j-goods[i].w]是没有放入物品i时的数据dp[i-1][j-goods[i].w]。</p>
<p>实际上01背包问题同一种思路代码写法有两种，如果s从0开始遍历就不需要逆序，但是从大于w[i]开始就需要逆序</p>
<p>实际上这里的二维数组可以优化变为一维数组</p>
<p>dp[i][j] = max{dp[i-1][j-w[i]]+v[i]，dp[i-1][j]，这里的i与i-1实际上是第i个物体与第i-1个物体，而这个可以用数组下标直接代替，这样便可以用一维数组解决背包问题，但是一维数组与二维数组的区别是二维数组保存了前i个物品所可以获得的最大价值，而一维数组只能保存题目要求的s个物品的最大价值，因此用一维还是用二维因题目而异</p>
<p>dp[j] = max{dp[j]，dp[j-w[i]]+v[i]}。从这个方程中我们可以发现，有两个dp[j]，但是要区分开。等号左边的dp[j]是当前i的状态，右边中括号内的dp[j]是第i-1状态下的值。</p>
<p>所以为了保证状态的正确转移，我们需要先更新等号左边中的dp[j]（当前状态的dp[j]）。</p>
<p>代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,maxv;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;maxv;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">1001</span>],v[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxv;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=maxv;k&gt;=w[i];k--)<span class="comment">/*这里是因为当背包体积小于物品体积时不可能成立，相当于if(k&lt;w[i])&#123;dp[i][k]=dp[i-1][k];&#125;*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[k]=<span class="built_in">max</span>(dp[k],dp[k-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[maxv]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展问题</p>
<p>继续0-1背包问题，如果在上面的问题加上一个限制条件，所选择的物品必须恰好装满背包，否则输出-1。这时数组初始化为负无穷</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">int w<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int v<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int maxv;</span><br><span class="line">int n;</span><br><span class="line">int dp<span class="comment">[MAXSIZE]</span><span class="comment">[MAXSIZE]</span>;</span><br><span class="line"></span><br><span class="line">int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &gt; b)</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxv;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w<span class="comment">[i]</span> &gt;&gt; v<span class="comment">[i]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化，当容积为0时，即不能装入，最大价值即为0</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[0]</span> = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化为-1，表示没有装满</span><br><span class="line">    for (int i = 0; i &lt;= n; i++)</span><br><span class="line">    for (int j = 1; j &lt;= maxv; j++)</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[j]</span> = -1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = maxv; j &gt;= w<span class="comment">[i]</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1表示容积为j - w<span class="comment">[i]</span>时没有装满，所以当容积为j，装w<span class="comment">[i]</span>时一定不能装满</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt; dp<span class="comment">[i-1]</span><span class="comment">[j]</span>表示装入物品i时签好装满并且总价值比前i-1个物品的总价值要大</span><br><span class="line">            if (dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1 &amp;&amp; dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt;= dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>)</span><br><span class="line">                dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = w<span class="comment">[i]</span> - 1; j &gt;= 1; j--)</span><br><span class="line">            dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp<span class="comment">[n]</span><span class="comment">[maxv]</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它大致相同，现在dp[i][j]表示的是恰好装j空间时价值的最大值</p>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>题目：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for (i = 1; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (j = goods<span class="comment">[i]</span>.w; j &lt;= S; j++)</span><br><span class="line">        dp<span class="comment">[j]</span> = max(dp<span class="comment">[j]</span>, dp<span class="comment">[j - goods<span class="comment">[i]</span>.w]</span> + goods<span class="comment">[i]</span>.v);</span><br><span class="line">&#125;//不是很理解，但是先把模板记下吧</span><br></pre></td></tr></table></figure>
<p>这个代码和01背包代码十分相似，只有循环方向不同，为什么可以这样做呢？因为01背包要求每个物品只能选一次，因此根据这个式子，有可能会导致多选的就是dp[j - goods[i].w],如果从前往后循环，j-goods[i].w可能是已经选择了当前物品的情况</p>
<p><a href="https://pangyuworld.github.io/2019/04/03/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/#%E9%A2%98%E7%9B%AE%E7%B1%BB%E5%9E%8B-1" target="_blank" rel="noopener">可以去看</a></p>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>有N种物品和一个容量为V的背包。第 i 种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p>实际上可以转化为01背包，把每一种物品中多件拆开</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int k = n + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; <span class="built_in">i</span>++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (number[<span class="built_in">i</span>]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			w[k] = w[<span class="built_in">i</span>];</span><br><span class="line">			value[k] =value[<span class="built_in">i</span>];</span><br><span class="line">			k++;</span><br><span class="line">			number[<span class="built_in">i</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; <span class="built_in">i</span>++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (int <span class="built_in">j</span> = v; <span class="built_in">j</span> &gt;= w[<span class="built_in">i</span>]; <span class="built_in">j</span>--) &#123;</span><br><span class="line">			f[<span class="built_in">j</span>] = <span class="built_in">max</span>(f[<span class="built_in">j</span>], f[<span class="built_in">j</span> - w[<span class="built_in">i</span>]] + value[<span class="built_in">i</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样可能导致时间复杂度过高，可以考虑采用二进制思想，每一个数例如7可以用二进制来表示，而这样我们就可以把它拆为3个数，7二进制为111，所以可以拆为100,010,001，这样我们就只需要储存3个数，降低了时间复杂度。但是假如不是正好的话<br>例如13 ，二进制为1101，则可以分解为0110,0001,0010,0100（如果最好不足2^i，则取x-2^i-1)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> num[maxn][<span class="number">2</span>], dp[maxn];</span><br><span class="line"><span class="built_in">int</span> N, V, c, w, n, tot;</span><br><span class="line">memset(dp, <span class="number">0</span>, sizeof dp);</span><br><span class="line">cin &gt;&gt; V &gt;&gt; N; tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; c &gt;&gt; w &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">1</span>; k &lt; n; k&lt;&lt;=<span class="number">1</span>)<span class="comment">//左移求下一个所需二进制数 </span></span><br><span class="line">	&#123;</span><br><span class="line">		num[tot][<span class="number">0</span>] = k*c;</span><br><span class="line">		num[tot++][<span class="number">1</span>] = k*w;<span class="comment">//注意这时我们把若干物体看为1个物体，它的总重量也要变</span></span><br><span class="line">		n -= k;</span><br><span class="line">	&#125;</span><br><span class="line">	num[tot][<span class="number">0</span>] = n*c;</span><br><span class="line">	num[tot++][<span class="number">1</span>] = n*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; tot; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = V; j &gt;= num[i][<span class="number">0</span>]; --j)</span><br><span class="line">		dp[j] = max(dp[j], dp[j-num[i][<span class="number">0</span>]]+num[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索和广度优先搜索</title>
    <url>/2020/01/14/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>基本思想：它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念</p>
<p>例<img src="/images/%E5%9B%BE%E7%89%871.png" alt=""></p>
<p>V0-&gt;V1-&gt;V4-&gt;V3-&gt;V5-&gt;V6,先从v0到V1，再从V1到V4，发现到了终点，就退回到V1继续寻找</p>
<p>代码</p>
<p>注意恢复初始状态十分重要，在一种情况走不了的情况下它可以使其恢复初始状态试下一条路</p>
<p><img src="/images/%E5%9B%BE%E7%89%872.png" alt=""></p>
<p>例题：<img src="/images/%E5%9B%BE%E7%89%873.png" alt=""></p>
<p>遍历连通图，能否从v0到v6</p>
<p>答案<img src="/images/%E5%9B%BE%E7%89%874.png" alt=""></p>
<p>说明，重要的便是模板，先判断当前情况是否满足，如果满足则退出，不满足则遍历所有情况，如果某一位置到了头便会返回false，然后返回到分叉点，搜索下一步（遍历作用在这），而最后一定要回到初始状态，因为别的搜索也可能用</p>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">广度优先搜索是最简便的图的搜索算法之一，别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中</span><br></pre></td></tr></table></figure>
<p>模板<br><img src="/images/%E5%9B%BE%E7%89%875.png" alt=""></p>
<p>说明：从某一个起始节点开始，看是否满足，如果不满足， 遍历所有可能的情况，这里便是tt，如果tt存在，那么就把它送入队列中，之后继续遍历可能情况，这里需要两个数组，一个数组是用来确定这点是否已经走过，另外一个数组是用来记录步数的。<a href="https://blog.csdn.net/freezhanacmore/article/details/8168265" target="_blank" rel="noopener">另外，有些题可能会导致数组超过范围，这时就要写一个判断条件排除掉越界的</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>scanf printf</title>
    <url>/2020/01/13/scanf-printf/</url>
    <content><![CDATA[<h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>格式：scanf(const char *format, …)</p>
<p>format – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。</p>
<p>format 说明符形式为:</p>
<p>[=%[*][width][modifiers]type=]</p>
<p><code>*</code>这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。</p>
<p>width    这指定了在当前读取操作中读取的最大字符数。</p>
<p>modifiers    为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）</p>
<p>type    一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格</p>
<p>| %a、%A|读入一个浮点值(仅 C99 有效)|float*|<br>| :——————————————-|<br>| %c     | 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。|    char *<br>|%d    |十进制整数：数字前面的 + 或 - 号是可选的。|    int *<br>|%e、%E、%f、%F、%g、%G    |浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4    |float *<br>|%i|    读入十进制，八进制，十六进制整数 。|    int *<br>|%o    |八进制整数。|    int *<br>|%s    |字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。|    char *<br>|%u    |无符号的十进制整数。|    unsigned int *</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>用%c 读数组时注意它不会读入换行符，因此每次用完之后要用getchar()<br>，而%s就不用担心这个问题</p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>格式 printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p>
<p>声明 printf(const char *format, …)</p>
<p>|格式字符|    意义<br>|————————-|<br>|d|    以十进制形式输出带符号整数(正数不输出符号)<br>|o    |以八进制形式输出无符号整数(不输出前缀0)<br>|x,X    |以十六进制形式输出无符号整数(不输出前缀Ox)<br>|u    |以十进制形式输出无符号整数<br>|f|    以小数形式输出单、双精度实数<br>|e,E    |以指数形式输出单、双精度实数<br>|g,G    |以%f或%e中较短的输出宽度输出单、双精度实数<br>|c|    输出单个字符<br>|s    |输出字符串<br>|p|    输出指针地址<br>|lu    |32位无符号整数<br>|llu|    64位无符号整数</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2020/01/13/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h3><p>队列是一种线性结构，有队头（front）队尾（rear）两个指针，每次拉进来一个元素会让队尾加一，而每次删除一个元素会让队头加一，这是一种先进先出的结构。</p>
<p>队列特殊情况判断</p>
<p>空队列 front=rear</p>
<p>满队列 rear-front=N（N指的是开的数组的大小）</p>
<p>POP 从队头删元素</p>
<p>push 拉元素到队尾</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">duilie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> front ,rear;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        front=rear=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front)==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear-front==N<span class="number">-1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(full())<span class="comment">//如果满了就不能拖进去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[++rear]=key;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>上面一种队列并不是真的有n个空间，如果pop了元素那空间就要减小，这样便浪费了许多空间，而用模运算组成一个循环可以使空间充分利用</p>
<p>特殊情况判断</p>
<p>空 ： front=rear</p>
<p>满 ：（ rear+1）% N=front</p>
<p>代码实现</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const <span class="built_in">int</span> Queue_Size=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">typedef <span class="keyword">struct</span> circlQueue</span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> *elem;</span><br><span class="line">       <span class="built_in">int</span> rear;</span><br><span class="line">       <span class="built_in">int</span> front;</span><br><span class="line">       <span class="built_in">int</span> queueSize;</span><br><span class="line">&#125;circlQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">void init<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem=<span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[Q<span class="identifier">ueue_Size</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;<span class="comment">//首尾指针相等说明队列为空。</span></span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=Queue_Size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*销毁队列*/</span></span><br><span class="line">void destroy<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       delete <span class="literal">[]</span><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*求队列的长度*/</span></span><br><span class="line"><span class="built_in">int</span>  length<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">int</span> length;</span><br><span class="line">       length=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear-<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;<span class="comment">/*一般情况下，rear在front的上方，此种算法是用于</span></span><br><span class="line"><span class="comment">  rear已到front的下方，即已出现假溢出的情况。*/</span></span><br><span class="line">       return length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*入队列*/</span></span><br><span class="line">void enter<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q,<span class="params">char</span> <span class="params">x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span>(((<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)<span class="comment">//判断栈满的情况</span></span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue OverFlow!"</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">rear</span>]</span>=x;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%Queue_Size;<span class="comment">//尾指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="built_in">char</span> output<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> e;</span><br><span class="line">       <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)</span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue Empty"</span>;</span><br><span class="line">       e=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">front</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;;<span class="comment">//头指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">       return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「hackerain」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/hackerain/article/details/5934240</span></span><br></pre></td></tr></table></figure>

<h3 id="队列的函数"><a href="#队列的函数" class="headerlink" title="队列的函数"></a>队列的函数</h3><p>push()：脱元素到队尾</p>
<p>pop()删队首元素</p>
<p>size()</p>
<p>front()返回队首元素</p>
<p>back()返回队尾元素</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>front无法使用迭代器，因为queue在物理地址上不连续，所以queue无法遍历，想要遍历只能不停top POP，这样会销毁队列</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>HDU 1387 </li>
</ul>
<p>Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.<br>In a team queue each element belongs to a team. If an element enters the queue, it first searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.</p>
<p>Your task is to write a program that simulates such a team queue.</p>
<p>Input</p>
<p>The input will contain one or more test cases. Each test case begins with the number of teams t (1&lt;=t&lt;=1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0 - 999999. A team may consist of up to 1000 elements.</p>
<p>Finally, a list of commands follows. There are three different kinds of commands:</p>
<p>ENQUEUE x - enter element x into the team queue<br>DEQUEUE - process the first element and remove it from the queue<br>STOP - end of test case<br>The input will be terminated by a value of 0 for t.</p>
<p>Output</p>
<p>For each test case, first print a line saying “Scenario #k”, where k is the number of the test case. Then, for each DEQUEUE command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Sample Input</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line"><span class="number">3</span> <span class="number">201</span> <span class="number">202</span> <span class="number">203</span></span><br><span class="line">ENQUEUE <span class="number">101</span></span><br><span class="line">ENQUEUE <span class="number">201</span></span><br><span class="line">ENQUEUE <span class="number">102</span></span><br><span class="line">ENQUEUE <span class="number">202</span></span><br><span class="line">ENQUEUE <span class="number">103</span></span><br><span class="line">ENQUEUE <span class="number">203</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">259001</span> <span class="number">259002</span> <span class="number">259003</span> <span class="number">259004</span> <span class="number">259005</span></span><br><span class="line"><span class="number">6</span> <span class="number">260001</span> <span class="number">260002</span> <span class="number">260003</span> <span class="number">260004</span> <span class="number">260005</span> <span class="number">260006</span></span><br><span class="line">ENQUEUE <span class="number">259001</span></span><br><span class="line">ENQUEUE <span class="number">260001</span></span><br><span class="line">ENQUEUE <span class="number">259002</span></span><br><span class="line">ENQUEUE <span class="number">259003</span></span><br><span class="line">ENQUEUE <span class="number">259004</span></span><br><span class="line">ENQUEUE <span class="number">259005</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">ENQUEUE <span class="number">260002</span></span><br><span class="line">ENQUEUE <span class="number">260003</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">1</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">201</span></span><br><span class="line"><span class="number">202</span></span><br><span class="line"><span class="number">203</span></span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">2</span></span><br><span class="line"><span class="number">259001</span></span><br><span class="line"><span class="number">259002</span></span><br><span class="line"><span class="number">259003</span></span><br><span class="line"><span class="number">259004</span></span><br><span class="line"><span class="number">259005</span></span><br><span class="line"><span class="number">260001</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/01/13/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>归并排序运用了分治的思想，先将数组二分成一个元素（一个元素时看为有序），然后将这些元素不断合并，每合并一次排一次序，最后就可以得到有序的数组。</p>
<p>比如说一个序列:12 ,23,1,44,233,10,9,8。我们先分成两段：12 ,23,1,44 和 233,10,9,8，<br>发现还能再分成4段：12 ,23 和 1,44——233,10 和 9,8。<br>再分成8段：12–23–1–44 和233–10–9–8。<br>这时候开始把子序列进行排序合并，一个元素就是有序的。所以不用排序。<br>合并成2个一组排序得到：12，23—-1，44—10，233—8，9。<br>再合并成4个一组排序得到：1，12，23，44—8，9，10，233。<br>最后合并得到最终结果：1，8，9，10，12，23，44，233。</p>
<p>合并过程看代码</p>
<p>链接：<a href="https://www.jianshu.com/p/b50a6034eb90" target="_blank" rel="noopener">https://www.jianshu.com/p/b50a6034eb90</a></p>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/images/1024555-20161218163120151-452283750.png" alt=""></p>
<p>这个图片蓝色部分就是拆的过程，而绿的部分为并的过程</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paixu</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> mid,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span><span class="comment">//这是合并过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1=first,l2=mid+<span class="number">1</span>,r1=mid,r2=last;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1&amp;&amp;l2&lt;=r2)<span class="comment">//两部分都存在时看哪个小就加上哪个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l1]&lt;=a[l2])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1)<span class="comment">//第一部分有剩余就把第一部分剩下的全加上</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2&lt;=r2)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i+first]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xunhuan</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(first+last)/<span class="number">2</span>;</span><br><span class="line">        xunhuan(first,mid,a,temp);<span class="comment">//拆左边</span></span><br><span class="line">        xunhuan(mid+<span class="number">1</span>,last,a,temp);<span class="comment">//拆右边</span></span><br><span class="line">        paixu(first,mid,last,a,temp);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[last-first];<span class="comment">//建一个临时数组，合并时用</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="comment">//判断是否传入空数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xunhuan(first,last,a,p);</span><br><span class="line">    <span class="keyword">delete</span> [] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/2020/01/13/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<h3 id="前缀和概念"><a href="#前缀和概念" class="headerlink" title="前缀和概念"></a>前缀和概念</h3><p>前缀和指的是用另一个数组b[n]来保存a[n]中前n项的和</p>
<p>例如，b[0]=a[0],b[1]=a[0]+a[1],…</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="求数组某一区间长度数字的和"><a href="#求数组某一区间长度数字的和" class="headerlink" title="求数组某一区间长度数字的和"></a>求数组某一区间长度数字的和</h4><p>如果我给你一串长度为n的数列a1,a2,a3……an,再给出m个询问，每次询问给出L，R两个数，要求给出区间[L,R]里的数的和，一般可能是从L到R遍历一次，但这样很花时间，有了前缀和之后可以直接b[R]-b[L]就得到L到R的和</p>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分就是将数列中的每一项分别与前一项数做差</p>
<p>一个序列1 2 5 4 7 3，差分后得到1 1 3 -1 3 -4 -3</p>
<p>这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0）<br>差分序列最后比原序列多一个数（相当于0减最后一个数）</p>
<p>例 给你一串长度为n的数列a1,a2,a3……an，要求对a[L]~a[R]进行m次操作：</p>
<p>操作一：将a[L]~a[R]内的元素都加上P</p>
<p>操作二：将a[L]~a[R]内的元素都减去P</p>
<p>最后再给出一个询问求a[L]-a[R]内的元素之和？</p>
<p>如果用一般做法就是遍历加减，时间复杂度高，现在可以直接让b[L] 加上P，再让b[R+1]减去P，这样因为b[L+1]=b[L]+a[L+1]，所以L到R上每一项都会加P，而b[R+1]减去P是为了对后面的数不产生影响</p>
<p>如果有多次修改操作，可以先将每次修改保存到一个数组中，然后求前缀和时再加上<br>    #include&lt;bits/stdc++.h&gt;<br>    using namespace std;<br>    const int maxn=1e5+9;<br>    int a[maxn],b[maxn];<br>    int main(){<br>     int i,j,k,n,m,p;<br>     cin&gt;&gt;n&gt;&gt;m;<br>     for(i=1;i&lt;=n;i++){<br>        cin&gt;&gt;a[i];<br>     }<br>     for(i=1;i&lt;=m;i++){<br>        int L,R,t;<br>        cin&gt;&gt;t&gt;&gt;L&gt;&gt;R&gt;&gt;p;<br>        if(t==1){<br>            b[L]+=p;b[R+1]-=p; //仔细想想为什么b[R+1]要减去p<br>        }<br>        else{<br>            b[L]-=p;b[R+1]+=p;//这是减去p<br>        }<br>    }<br>    int add=0;<br>    for(i=1;i&lt;=n;i++){<br>        add+=b[i];<br>        a[i]+=a[i-1]+add;//这是求前缀和数组，并且add是把需要加p的地方加上<br>    }<br>    int x,y;<br>    cin&gt;&gt;x&gt;&gt;y;<br>    cout&lt;&lt;a[y]-a[x-1]&lt;&lt;endl;<br>}</p>
<h4 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4><p>1、差分序列求前缀和可得原序列</p>
<p>2、将原序列区间[L,R]中的元素全部+1，可以转化操作为差分序列L处+1，R+1处-1</p>
<p>3、按照性质2得到，每次修改原序列一个区间+1，那么每次差分序列修改处增加的和减少的相同</p>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>二维前缀和对应的是二维数组</p>
<p><img src="/images/20180817161822690.png" alt=""></p>
<p>b[2][4]表示的是b[1][1]+b[1][2]+b[1][3]+b[1][4]+b[2][1]+b[2][2]+b[2][3]</p>
<p>因此可以先加上b[1][4]+b[2][3]，这时重复了b[1][3]，再减去</p>
<p>因此公式<br>a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1]，因为这样，二维前缀和最好从一开始，0处全赋值为0</p>
<p>这时想知道从(x1,y1)到(x2,y2)的和要a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]</p>
<p>例如，求(3,3)到(4,4)的值，实际上是a[3][3]+a[3][4]+a[4][3]+a[4][4]</p>
<h3 id="二维差分（不是很清楚）"><a href="#二维差分（不是很清楚）" class="headerlink" title="二维差分（不是很清楚）"></a>二维差分（不是很清楚）</h3><p>和一维差分的第四个问题类似，让（x1,y1)和（x2,y2）矩形内的数都加上x</p>
<p>b[x1][y1]+=x; b[x2+1][y2+1]+=x;</p>
<p>b[x1][y2+1]-=x; b[x2+1][y1]-=x;</p>
<p> 参考博客<a href="https://blog.csdn.net/k_r_forever/article/details/81775899" target="_blank" rel="noopener">https://blog.csdn.net/k_r_forever/article/details/81775899</a></p>
<p> <a href="https://blog.csdn.net/Healer66/article/details/87201014" target="_blank" rel="noopener">https://blog.csdn.net/Healer66/article/details/87201014</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>结构体</title>
    <url>/2020/01/12/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<p>在c++中，结构体与类类似，都有个体域和成员函数，不同是class中默认的成员访问权限是private的，而struct中则是public的。 (2)class继承默认是private继承，而从struct继承默认是public继承。</p>
<p>定义：</p>
<pre><code> struct tag 
{
  member-list
}variable-list;</code></pre><p>注：struct为结构体关键字；<br>   tag为结构体的标志；<br>   member-list为结构体成员变量及成员函数列表，其必须列出其所有成员；<br>   variable-list为此结构体声明的变量；</p>
<p>tag相当于class中的类名，而variable-list相当于class中创建的对象</p>
<p>另外，如果想多创建几个对象，只需要<code>tag 变量名</code>即可</p>
<p>在c++中，可以直接用<code>variable-list+变量名</code>创建对象</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>memset</title>
    <url>/2020/01/11/memset/</url>
    <content><![CDATA[<p>memset(标识符，填充数据,大小)</p>
<p>memset是一个字节一个字节填充的，所以一般只能填充0或-1因为这个一个字节和四个字节相同</p>
]]></content>
  </entry>
  <entry>
    <title>快速输入</title>
    <url>/2020/01/11/%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5/</url>
    <content><![CDATA[<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="attribute">x</span>=0,f=1;</span><br><span class="line">    char <span class="attribute">ch</span>=getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span> (<span class="attribute">ch</span>=='-') <span class="attribute">f</span>=-1;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;<span class="attribute">x</span>=x*10+ch-'0';ch=getchar();&#125;</span><br><span class="line">    return x<span class="number">*f</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个快速输入只适合int类型，另外如果参加比赛，最好不要用cin，cout，速度较慢<br>用scanf，printf更好</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>qsort</title>
    <url>/2020/01/11/qsort/</url>
    <content><![CDATA[<p>自带的快排函数</p>
<p>qsortvoid qsort(void <em>base, size_t nitems, size_t size, int (*compar)(const void *, const void</em>))</p>
<p>参数</p>
<p>base– 指向要排序的数组的第一个元素的指针。<br>nitems– 由 base 指向的数组中元素的个数。<br>size– 数组中每个元素的大小，以字节为单位。<br>compar– 用来比较两个元素的函数，即函数指针（回调函数）</p>
<p>回调函数：</p>
<p>回调函数就是一个通过函数指针调用的函数。如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。 [2]<br>compar参数<br>compar参数指向一个比较两个元素的函数。比较函数的原型应该像下面这样。注意两个形参必须是const void *型，同时在调用compar 函数（compar实质为函数指针，这里称它所指向的函数也为compar）时，传入的实参也必须转换成const void *型。在compar函数内部会将const void *型转换成实际类型。<br>int compar(const void *p1, const void *p2);</p>
<p>如果compar返回值小于0（&lt; 0），那么p1所指向元素会被排在p2所指向元素的左面；<br>　　如果compar返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定；<br>　　如果compar返回值大于0（&gt; 0），那么p1所指向元素会被排在p2所指向元素的右面。</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>pair</title>
    <url>/2020/01/11/pair/</url>
    <content><![CDATA[<p>pair实际上是一个结构体，它可以把两种类型结合起来使用,定义在<code>&lt;utility&gt;</code>中</p>
<p>定义：pair&lt;类型A,类型B&gt; 标识符</p>
<p>操作 pa.first 表示类型A pa.second 表示类型B</p>
<p>注意不能用-> 操作符，虽然我也不知道为什么

]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器支持的运算</title>
    <url>/2020/01/11/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>之前写搜狗在线测试题目的时候，曾经想遍历一个set遍历。当时是这样写的。</p>
<p>set<int>::iterator b = a.begin()+1</p>
<p>后来发现程序报错。究其原因是，set迭代器不支持加减数操作。<br>查看了一下维基百科，下面是有关说明。</p>
<p>1.所有迭代器都应该实现自增算符：iter++,++iter</p>
<p>2.Bidirectional迭代器：是在前向迭代器的基础上，多了单步向后遍历的能力。也就是–iter,iter–。</p>
<p>3.Random Access迭代器：在双向迭代器基础上，具有直接访问各数据元素的能力。随机迭代器增加了“迭代器算术运算”：</p>
<p>iter+=i 迭代器递增i位</p>
<p>iter-=i 迭代器递减i位</p>
<p>iter+i 加i位后的迭代器</p>
<p>iter-i 减i位后的迭代器</p>
<p>iter[i] 加i位后的迭代器的解引用</p>
<p>iter&lt;iter1 如果迭代器iter的位置在iter1前，返回true，否则返回false</p>
<p>iter&lt;=iter1 如果iter的位置在iter1的前面或同一位置时返回true，否则返回false</p>
<p>iter&gt;iter1 如果迭代器iter的位置在iter1后，返回true，否则返回false</p>
<p>iter&gt;=iter1 如果iter的位置在iter1的后面或同一位置时返回true，否则返回false</p>
<p>4.在STL定义的容器中，string，vector与deque提供了随机访问迭代器，list、set、multiset、map、multimap提供了双向迭代器。</p>
<p>————————————————</p>
<p>版权声明：本文为CSDN博主「ShenYounger」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wusecaiyun/article/details/49563197" target="_blank" rel="noopener">https://blog.csdn.net/wusecaiyun/article/details/49563197</a></p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>vector</title>
    <url>/2020/01/11/vector/</url>
    <content><![CDATA[<h3 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h3><p>vector&lt;数据类型&gt; 标识符</p>
<h3 id="vector的函数"><a href="#vector的函数" class="headerlink" title="vector的函数"></a>vector的函数</h3><p>begin()返回开头元素的迭代器</p>
<p>end()同理</p>
<p>front() 返回开头元素的引用</p>
<p>back() 返回末尾元素的引用</p>
<p>size()返回vector内元素的数量</p>
<p>erase(迭代器) 删除一个元素</p>
<p>clear() 清空</p>
<p>insert(迭代器，a) 把a插入迭代器后</p>
<p><strong>例</strong>vector中现在有1 2 3 三个元素，vec.insert(vec.begin()+2,4)得到1 2 4 3</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>reverse(vec.begin(),vec.end()) <strong>(头文件<code>&lt;algorithm&gt;</code>)</strong></p>
<p>实际上不一定是begin到end，也可以begin()+1到、、、，只需要用迭代器就行了

<p>sort排序，也要用<code>&lt;algorithm&gt;</code>默认升序</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> <span class="constructor">Comp(<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">a</span>,<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序。</p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><pre><code>vector&lt;vector&lt;数据类型&gt; &gt; vec[3];//3行
vector&lt;数据类型&gt; veci;
for(int i=0;i&lt;3;i++)
{
   for(int k=0;k&lt;4;k++)
   {
      veci.push_back();
   }
   vec.push_back(veci);
}//四列</code></pre>]]></content>
  </entry>
  <entry>
    <title>prioity_queue</title>
    <url>/2020/01/11/prioity-queue/</url>
    <content><![CDATA[<h3 id="prioity-queue"><a href="#prioity-queue" class="headerlink" title="prioity_queue"></a>prioity_queue</h3><p>实际上是一个大顶堆，定义在<code>&lt;queue&gt;</code>中</p>
<p><code>prioity_queue&lt;int&gt; qu</code>为大顶堆</p>
<p><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qu;</code>为小顶堆</p>
<p>.push()</p>
<p>.pop()取出元素，但不返回值</p>
<p>.top()不取出元素，返回值</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>set</title>
    <url>/2020/01/11/set/</url>
    <content><![CDATA[<h3 id="set之iterator"><a href="#set之iterator" class="headerlink" title="set之iterator"></a>set之iterator</h3><p>定义：set::iterator iter</p>
<p>运用：*iter</p>
<p>遍历 for(iter=set.begin();iter!=set.end();iter++)</p>
<p>还可以直接用auto it=set.begin() (auto是自动匹配类型)</p>
<p><strong>注意</strong><br>iterator只能用++，–运算符。不能*（iter-1），另外还要注意iter++后自身会改变</p>
<p>例：set中有0,2,4，iter指向2，现在cout&lt;&lt;<em>iter&lt;&lt;” “&lt;&lt;</em>(iter–)&lt;&lt;endl;</p>
<p>输出0,2，先执行iter–，我也不知道为什么</p>
<h3 id="set之lower-bound"><a href="#set之lower-bound" class="headerlink" title="set之lower_bound()"></a>set之lower_bound()</h3><p>lower_bound()返回从first开始的第一个大于或等于val的元素的地址。如果所有元素都小于val，则返回last的地址，所以必须要</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">iter=st.lower_bound(一个数字)</span><br></pre></td></tr></table></figure>

<p>upper_bound()返回最后一个大于等于val的元素的地址</p>
<h3 id="set基础"><a href="#set基础" class="headerlink" title="set基础"></a>set基础</h3><p>定义：set&lt;数据类型&gt; 标识符 ，set中元素都唯一</p>
<p>set实际上运用了红黑树。另外，set中元素会自动排序</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>begin()，返回的是开头元素迭代器</p>
<p>end()</p>
<p>clear()</p>
<p>empty()</p>
<p>size()</p>
<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p> count(数据)判断某个值是否在set中</p>
<ul>
<li><p>erase(iterator) 删去迭代器所指向的值</p>
</li>
<li><p>erase(iteratora,iteratorb)删去a，b之间的值</p>
</li>
<li><p>erase(数据)删去该数据</p>
</li>
<li><p>set删除是不会检查任何错误的，使用时小心</p>
</li>
</ul>
<p>find(数据)返回指定元素的迭代器，没有则返回最后一个元素的迭代器</p>
<p>当set中没有元素的时候，*s.end()=0</p>
<p>insert(某一个值),将一个值插入set中，<strong>注意</strong>这是唯一的将元素弄到set中的方法，并且重复插入无效</p>
<h6 id="判断insert插入是否成功的方法（具体可看"><a href="#判断insert插入是否成功的方法（具体可看" class="headerlink" title="判断insert插入是否成功的方法（具体可看)"></a>判断insert插入是否成功的方法（<a href="https://blog.csdn.net/liyuqian199695/article/details/49100543" target="_blank" rel="noopener">具体可看</a>)</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typedef pair&lt;iterator, bool&gt; _Pairib;</span></span><br><span class="line">	pair&lt;<span class="built_in">set</span>&lt;Student,FuncStudent&gt;::iterator,<span class="keyword">bool</span>&gt; pair1=set1.insert(s1);</span><br><span class="line">	<span class="keyword">if</span>(pair1.second==<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入s1成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入s1失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>&amp;&amp;与||小提示</title>
    <url>/2020/01/07/%E4%B8%8E-%E5%B0%8F%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<h4 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h4><p>&amp;&amp;运算符从左自由依次判断 ，如果判断有一个为假则停止判断</p>
<h4 id=""><a href="#" class="headerlink" title="||"></a>||</h4><p>同理如果判断有一个为真则停止判断</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
    int a=0,b=1,c;
    c = (a != b) || (++a == b++);
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;
    return 0;
}</code></pre><p>输出为0 1因为前面一个为真，直接退出判断</p>
]]></content>
  </entry>
  <entry>
    <title>字符数组</title>
    <url>/2020/01/07/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="前方高能"><a href="#前方高能" class="headerlink" title="前方高能"></a>前方高能</h3><pre><code>char a[4]={&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;};
cout&lt;&lt;a&lt;&lt;endl;</code></pre><p>这将输出什么呢，是<code>abcd</code>，实际上是<code>abcdPpB</code></p>
<p>这就有点神奇</p>
<h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>char +标识符+[]，注意字符数组的最后一定会有’\0’，</p>
<p>例如<code>char[]=&quot;abcd&quot;,这就是一个合法的赋值，但是char[4]=&quot;abcd&quot;是不合法的因为带双引号的为字符串，赋值给字符数组时编译器会自动加上&#39;\0&#39;这时需要5个空间</code></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为本来是要加上’\0’的，但是这时位子不够了，编译器只好帮它扩扩容，也就是说这是字符数组（其实现在已经不是字符数组了）长度已经不是4了，编译器会为后面几个位子附上值（不是随机的，我也有点不清楚，这样解释先），因此后面会多输出一些。但是如果开始就把长度设为5，这时’\0’就有位子放了，也就不会多出后面那些奇奇怪怪的字符</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>next主题出现404的一个解决方法</title>
    <url>/2020/01/07/next%E4%B8%BB%E9%A2%98%E5%87%BA%E7%8E%B0404%E7%9A%84%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在<code>主题配置文件中</code></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">home:</span> /|| home</span><br><span class="line"></span><br><span class="line"><span class="symbol">about:</span> <span class="meta-keyword">/about/</span>|| user</span><br><span class="line"></span><br><span class="line"><span class="symbol">tags:</span> <span class="meta-keyword">/tags/</span>|| tags</span><br><span class="line"></span><br><span class="line"><span class="symbol">categories:</span> <span class="meta-keyword">/categories/</span>|| th</span><br><span class="line"></span><br><span class="line"><span class="symbol">archives:</span> <span class="meta-keyword">/archives/</span>|| archive</span><br><span class="line"></span><br><span class="line"><span class="meta">#schedule: /schedule/|| calendar</span></span><br><span class="line"><span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">#commonweal: /404/|| heartbeat</span></span><br></pre></td></tr></table></figure>
  <p>注意/||，原来是/ ||，不要中间那个空格，亲测有效]]></content>
      <categories>
        <category>next</category>
      </categories>
  </entry>
  <entry>
    <title>文件输入输出</title>
    <url>/2020/01/07/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h4 id="文件输入in"><a href="#文件输入in" class="headerlink" title="文件输入in"></a>文件输入in</h4><p>文件输入指的是从文件_输入_给程序，对应的有in，get，read，seekg等

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">seekg和seekp中有三个定位基址，分别是cur（当前）beg（开始），end（末尾）&lt;p&gt;</span><br><span class="line">例如 seekg（<span class="number">100</span>，ios：：beg）；seekg（<span class="number">2</span>*sizeof(Student)) student是一个类</span><br></pre></td></tr></table></figure>

<h4 id="文件输出out"><a href="#文件输出out" class="headerlink" title="文件输出out"></a>文件输出out</h4><p>文件输出指的是从程序<code>输出</code>给文件，对应的有out，put，write，seekp等</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>二分搜索</title>
    <url>/2020/01/07/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="（主要是怕自己忘记了）"><a href="#（主要是怕自己忘记了）" class="headerlink" title="（主要是怕自己忘记了）"></a>（主要是怕自己忘记了）<p></h1><p>  一个要点，用二分时要先排序<p></p>
<pre><code>int erfen(int arr[],int key,int n)
    {
        int low=0,high=n-1;
        while(low&lt;=high)
        {
            int mid=(low+high)/2;
            if(arr[mid]&lt;key)
            {
                low=mid+1;
            }
            if(arr[mid]==key)
            {
                return mid;
            }
            if(arr[mid]&gt;key)
            {
                high=mid-1;
            }
        }
        return -mid-1;
     }</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>合法的字符常量</title>
    <url>/2020/01/07/%E5%90%88%E6%B3%95%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<p>用英文单引号括起来的一个字符，例如’a’,’ ‘等等。空格也是一个字符常量</p>
<p>注意<p>
  1.转义字符也属于字符常量，例如'\t','\n'等，但是'\97'不算]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>字符常量</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/01/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>步骤：<br>1.先从数列中取出一个数作为基准数。</p>
<p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p>
<p>3．再对左右区间重复第二步，直到各区间只有一个数。</p>
<p>例 6 1 2 7 9 3 4 5 10 8 进行排序<p><br> 1 以6为基准数，先从右边找比6小的数，我们用一个变量j一步步向左移动，好在移动三次后我<br> 们找到了5，j为7。现在再让另一个变量i向右移动去找比6大的数，当i为3时找到了7.现在再让5<br> 和7互换，得到了6 1 2 5 9 3 4 7 10 8,。在让j向左移动，找到了4，i向右找到了9，再让两个数<br> 互换，j再向左到3，此时i向左也到3，两者相遇，便让3和6互换，第一次结束<br> （想想原因）<p><br> 2 现在分为两部分，左边全比6小，右边全比6大，为3 1 2 5 4 6 9 7 10 8<br> 再在3 1 2 5 4 中用同样的方法搜索一次得到2 1 3 5 4,再在2 1 中搜索得到1 2<br> 然后在5 4 中搜索得到4 5，左边排序完成，右边用同样的方法排序就可得到答案</p>
<p> 不说了，上代码</p>
<pre><code>void sort(int a[],int l,int r)
{
  if(l&lt;r)//l大于等于r时这一段排序结束
  {
      int i=l,j=r,x=a[l];
      while(i&lt;j)
      {
          while(i&lt;j&amp;&amp;a[j]&gt;=x)
          {
              j--;
          }
          while(i&lt;j&amp;&amp;a[i]&lt;=x)
          {
              i++;
          }
          swap(a[i],a[j]);
      }
      swap(a[l],a[i]);
      sort(a,l,i-1);
      sort(a,i+1,r);
 }
}</code></pre><p>  引用 转载请标明出处，原文地址：<a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="noopener">http://blog.csdn.net/morewindows/article/details/6684558</a><br>         csdn 我见过最通俗易懂的快速排序过程讲解，转自《坐在马桶上看算法：快速排序》</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划背包问题</title>
    <url>/2020/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="第一类背包问题"><a href="#第一类背包问题" class="headerlink" title="第一类背包问题"></a>第一类背包问题</h3><p>问题，有N件物品和一个容量为V的背包。第i件物品的大小是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p>
<p><strong>思路</strong> 可以用一个二维数组a[i][j]，表示把前i个物体放入一个容量为j的容器中所获得的最大价值，而a[i][j]=max(a[i-1][j],a[i-1][j-c[i]]+w[i])</p>
<p>这个式子表示到底是不装第i个物品价值大还是花去c[i]的空间装获得w[i]的价值所得的总价值最大，</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">n 	w v    <span class="number">1</span>   <span class="number">2</span>  <span class="number">3</span>	  <span class="number">4</span>	  <span class="number">5</span>	  <span class="number">6</span>	  <span class="number">7</span>	  <span class="number">8</span>	  <span class="number">9</span>	  <span class="number">10</span></span><br><span class="line">a	<span class="number">2</span>	<span class="number">6</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">12</span>	<span class="number">12</span>	<span class="number">15</span>	<span class="number">15</span>	<span class="number">15</span></span><br><span class="line">b	<span class="number">2</span>	<span class="number">3</span>	<span class="number">0</span>	<span class="number">3</span>	<span class="number">3</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">10</span>	<span class="number">11</span></span><br><span class="line">c	<span class="number">6</span>	<span class="number">5</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">10</span>	<span class="number">11</span></span><br><span class="line">d	<span class="number">5</span>	<span class="number">4</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">10</span>	<span class="number">10</span></span><br><span class="line">e	<span class="number">4</span>	<span class="number">6</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>为了叙述方便，用e2单元格表示e行2列的单元格，这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了。</p>
<p>对于d2单元格，表示只有物品e，d时,承重为2的背包,所能装入的最大价值，仍然是0，因为物品e,d都不是这个背包能装的。</p>
<p>上代码</p>
<p>————————————————<br>版权声明：本文为CSDN博主「从杰」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/mu399/article/details/7722810" target="_blank" rel="noopener">https://blog.csdn.net/mu399/article/details/7722810</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>线性筛</title>
    <url>/2020/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<p>埃氏筛中有重复，例如6,2与3都筛了一次，效率低<br>线性筛定理，（口语不准确）一个数i乘以小于等于它的最小素因数的素数所得到的合数之间没有重复</p>
<pre><code>#define N 10000
int flag[N+1],prime[N+1],pnum;
/*
flag[n] 表示n是否是素数，1是素数，0不是
prime   中是所有的素数按从小到大排列、
pnum  表示素数的个数
*/
void CreatePrime(){
    pnum=0;//初始化没有素数
    //先将所有数看做素数，然后开始筛选
    for(int i=0; i&lt;=N; i++){
        flag[i]=1;
    }
    //遍历筛去所有最大因数是i的合数
    for(int i=2; i&lt;=N; i++){
        if(flag[i]==1){
        //把素数记录下来
            p[pnum++]=i;
        }
        //遍历已知素数表中比i的最小素因数小的素数，并筛去合数
        for(int j=0; j&lt;pnum &amp;&amp; p[j]*i&lt;=N; j++){
        //筛去合数
            flag[p[j]*i]=0;
            if(i%p[j]==0)
            //找到i的最小素因数，找到了就终止
                break;
        }
    }</code></pre><p>————————————————<br>版权声明：本文为CSDN博主「太上绝情」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/bjrxyz/article/details/8125913" target="_blank" rel="noopener">https://blog.csdn.net/bjrxyz/article/details/8125913</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>埃氏筛</title>
    <url>/2020/01/04/%E5%9F%83%E6%B0%8F%E7%AD%9B/</url>
    <content><![CDATA[<p>在筛质数时，我们会发现，筛去2后，2的倍数4、6、8等一定不是素数;筛去3后，3的倍数6、9、12等一定不是倍数。简单模拟这个过程如下</p>
<pre><code>const int MAXN = 1000000；  
void Prime()  
{  
    for (int i=0; i&lt;MAXN; i++) prime[i]=1;  //先把每个数都定义为质数
    prime[0]=prime[1]=0;  
    for (int i=2; i&lt;MAXN; i++)  
    {  
        if (!prime[i]) continue;  
        for (int j=i*2; j&lt;MAXN; j+=i) prime[j] = 0;  //将i的倍数标记为合数
    }  
}</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>组合</title>
    <url>/2020/01/03/%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>本程序的思路是开一个数组，其下标表示1到n个数，数组元素的值为1表示其代表的数被选中，为0则没选中。</p>
<p>首先初始化，将数组前n个元素置1，表示第一个组合为前n个数。</p>
<p>然后从左到右扫描数组元素值的“10”组合，找到第一个“10”组合后将其变为“01”组合，同时将其左边的所有“1”全部移动到数组的最左端。</p>
<p>当第一个“1”移动到数组的n-m的位置，即n个“1”全部移动到最右端时，就得到了最后一个组合。</p>
<p>例如求5中选3的组合：</p>
<p>1 1 1 0 0 //1,2,3</p>
<p>1 1 0 1 0 //1,2,4</p>
<p>1 0 1 1 0 //1,3,4</p>
<p>0 1 1 1 0 //2,3,4</p>
<p>1 1 0 0 1 //1,2,5</p>
<p>1 0 1 0 1 //1,3,5</p>
<p>0 1 1 0 1 //2,3,5</p>
<p>1 0 0 1 1 //1,4,5</p>
<p>0 1 0 1 1 //2,4,5</p>
<p>0 0 1 1 1 //3,4,5<br>————————————————<br>版权声明：本文为CSDN博主「文如王勃三生慧」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/hf19931101/article/details/79452799" target="_blank" rel="noopener">https://blog.csdn.net/hf19931101/article/details/79452799</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>string大小写字母转换</title>
    <url>/2020/01/01/%E2%80%9Dstring%E7%B1%BB%E5%AD%97%E7%AC%A6%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E2%80%9C/</url>
    <content><![CDATA[<p>在algorithm库中有transform函数<br>transform(str.begin(),str.end(),str.begin(),::toupper)<br>注意transform有四个输入参数<br>1：str.begin()字符串的起始地址；<br>2：str.end()字符串的终止地址；<br>3：str.begin()是转换之后，输出到原str字符串的起始地址；<br>4：转换操作，可以选择toupper，tolower。</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>“凸包”</title>
    <url>/2019/12/31/%E2%80%9C%E5%87%B8%E5%8C%85%E2%80%9D/</url>
    <content><![CDATA[<p>凸包就是把平面中所有点都包进去的凸多边形，当然多边形上的点也是题目中给出的点</p>
<p>分治法<br>  1 首先，横坐标最小p1和最大pn的点一定是凸包上的点<br>  2上包，即离p1pn最远的点，记pmax<br>  3再把pmax与p1连接，求左侧的上包，重复上述过程即可求解<img src="/images/20150530094927274" alt=""></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>神奇的逗号运算符</title>
    <url>/2019/12/05/%E7%A5%9E%E5%A5%87%E7%9A%84%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>   cout&lt;&lt;(a,c),此时只会输出c的内容，但是a中的内容也会被计算，例如a=5,b=6,c=7  cout&lt;&lt;(（d=a+b),c) 输出为7，d=11</p>
]]></content>
  </entry>
</search>
