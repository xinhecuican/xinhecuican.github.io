<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mul指令</title>
    <url>/2020/01/27/mul%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>两个相乘的数：</p>
<p>如果是8位，那么一个默认在al中，另一个在8位寄存器或内存字节单元中，如果是16位，一个在ax中，另一个在16位寄存器或内存字单元中</p>
<p>结果： 如果是8位，结果默认在ax中，如果是16位，高位默认在dx中，低位在ax中</p>
]]></content>
  </entry>
  <entry>
    <title>call指令</title>
    <url>/2020/01/27/call%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>操作</p>
<ol>
<li>将当前的ip或cs压入栈中</li>
<li>转移</li>
</ol>
<p>这里的转移与jmp相同，也有位移和内存两种方式</p>
<h3 id="根据位移"><a href="#根据位移" class="headerlink" title="根据位移"></a>根据位移</h3><p>call 标号（将ip压入栈中后，转移到标号处进行指令）<br>过程：</p>
<ol>
<li>sp+=2，ss*16+sp=ip</li>
<li>ip=ip+16位位移</li>
</ol>
<p>16位位移=标号处地址-call指令后第一个字节的地址</p>
<p>相当于 push ip，jmp near ptr 标号</p>
<h3 id="根据目的地址"><a href="#根据目的地址" class="headerlink" title="根据目的地址"></a>根据目的地址</h3><p>call far ptr 实现段间转移</p>
<p>操作： </p>
<ol>
<li>sp-=2</li>
<li>ss*16+sp=cs</li>
<li>sp-=2</li>
<li>ss*16+sp=ip</li>
<li>cs=标号所在段地址，ip=；标号所在偏移地址</li>
</ol>
<p>段内转移一般是根据位移，段间转移一般是根据地址</p>
<p>如果地址在寄存器中， call reg，ip被修改</p>
<p>如果地址在内存中</p>
<p>1 call word ptr 内存地址</p>
<p>这种是段内转移，相当于 push ip，jmp word ptr</p>
<p>2 call dword ptr 内存地址</p>
<p>段间转移 例</p>
<p>call dword ptr ds：[0] ，这样ds:[0]和ds:[1]是ip ，ds:[2]和ds:[3]是cs</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>ret 和 retf</title>
    <url>/2020/01/27/ret-%E5%92%8C-retf/</url>
    <content><![CDATA[<h3 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h3><p>ret指令用栈中的数据，修改ip中的内容，从而实现近转移</p>
<p>过程：</p>
<ol>
<li><p>ip=ss*16+sp</p>
</li>
<li><p>sp+=2</p>
</li>
</ol>
<p>相当于 pop ip</p>
<h3 id="retf"><a href="#retf" class="headerlink" title="retf"></a>retf</h3><p>修改cs和ip 的内容，实现远转移<br>过程</p>
<ol>
<li>ip=ss*16+sp</li>
<li>sp+=2</li>
<li>cs=ss*16+sp</li>
<li>sp+=2</li>
</ol>
<p>相当于 pop ip ，pop cs</p>
<p>例</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ss</span>:stack</span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>这条指令相当于把ip变为0，指向第一条指令</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>jmp进行跳转</title>
    <url>/2020/01/26/jmp%E8%BF%9B%E8%A1%8C%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<h3 id="根据位移进行的转移"><a href="#根据位移进行的转移" class="headerlink" title="根据位移进行的转移"></a>根据位移进行的转移</h3><p>用jmp进行跳转时，会发现一个奇怪的问题，无论它要跳转到哪里，它的机器码始终不变，为EB03，那么它到底是怎么告诉cpu修改ip地址的呢？</p>
<p>先回忆一下cpu读取指令的过程</p>
<ol>
<li>cs=076a ip=0006，cs：ip指向eb03</li>
<li>读取指令码eb03到指令缓冲器</li>
<li>ip=ip+指令长度=0008h，cs：ip指向下一条指令</li>
<li>cpu执行指令缓冲器中的指令eb03</li>
<li>执行完缓冲器中的指令后，ip被修改+</li>
</ol>
<p>jmp指令并不需要转移的目的地址，但是它是凭借什么转移的呢？这里有个03，正好跳过三个字节之后就是要转移的地址。原来jmp指令只需知道当前指令的下一个指令（因为执行完这条指令后ip会增加）与要跳转的指令的位移就可以了</p>
<p>jmp short 标号 功能是 ip=ip+8位位移（一字节）</p>
<p>jmp near ptr 标号 是16位</p>
<p>jmp far ptr 标号 是段间转移，可以修改cs</p>
<p>还可以直接 jmp 寄存器1：寄存器2</p>
<h3 id="根据内存进行的转移"><a href="#根据内存进行的转移" class="headerlink" title="根据内存进行的转移"></a>根据内存进行的转移</h3><p>转移地址再内存中的转移有两种格式</p>
<ol>
<li>jmp word  ptr（段内转移）</li>
</ol>
<p>例 jmp word ptr ds：[0]</p>
<p>jmp word ptr [bx]</p>
<p>2.jmp dword ptr (段间转移）后面接两个字，第一个是偏移地址，第二个是段地址</p>
<p>例 jmp dword ptr ds：[0],0 完成后段地址为0</p>
<p>注意</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">nop</span></span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,offset s</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,offset s2</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cs</span>:[<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="symbol">   s0:</span> <span class="keyword">jmp</span> short s</span><br><span class="line"><span class="symbol">   s1:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">       <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">   s2:</span> <span class="keyword">jmp</span> short s1</span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>这个程序奇怪之处在于运行到mov cs：[di],ax后 s处会变为jmp 0000，这里就要记住jmp传递的是偏移地址，也就是说，jmp short s1这个指令并不是真的跳到s1处，而是往前跳8个字节</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>操作符offset</title>
    <url>/2020/01/26/%E6%93%8D%E4%BD%9C%E7%AC%A6offset/</url>
    <content><![CDATA[<p>offset是由编译器处理的符号，它的功能是获得标号的偏移地址</p>
<p>例</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset start//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">0</span></span><br><span class="line"><span class="symbol">   s:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset s//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">3</span></span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>
<p>上面的程序中offset获得了start和s的偏移地址0和3</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>dup</title>
    <url>/2020/01/24/dup/</url>
    <content><![CDATA[<p>dup用来处理重复数据</p>
<p>例：db 3 dup (0) 这个意思是定义了三个0的字节型数据</p>
<p>db 3 dup （0,1,2) 定义了九个数据</p>
<p>db 3 dup (‘abc’,’ABC’)定义18个数据</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>dd</title>
    <url>/2020/01/24/dd/</url>
    <content><![CDATA[<p>dd是用来定义双字型</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> segment</span></span><br><span class="line">    dd <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> ends</span></span><br></pre></td></tr></table></figure>
<p>要注意dd要占两个字，db一个字节，dw一个字</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编语言数据位置的表达</title>
    <url>/2020/01/24/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE/</url>
    <content><![CDATA[<h3 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h3><p>其实就是idata，这种数据执行前在cpu的指令缓冲器中，在汇编指令中直接给出</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>指令要处理的数据在寄存器中，在汇编指令中给出相应寄存器名</p>
<h3 id="段地址（SA）和偏移地址（EA"><a href="#段地址（SA）和偏移地址（EA" class="headerlink" title="段地址（SA）和偏移地址（EA)"></a>段地址（SA）和偏移地址（EA)</h3><p>这些数据在内存中，在汇编指令中可以用[x]的方式给出</p>
<h2 id="指令要处理数据有多长"><a href="#指令要处理数据有多长" class="headerlink" title="指令要处理数据有多长"></a>指令要处理数据有多长</h2><p>用寄存器的ax或al可以很方便的说明数据长度，但是如果是内存之间的传递可以用<br>x ptr 的方式确定是字型传递还是字节性传递</p>
<p>例： mov word ptr ds:[0],1</p>
<p>mov byte ptr ds:[0],1</p>
<p>另外，push操作无需指明，因为push只对字进行操作</p>
<h2 id="结构体的汇编表达"><a href="#结构体的汇编表达" class="headerlink" title="结构体的汇编表达"></a>结构体的汇编表达</h2><p>一般来说，我们可以用[bx+idata+si]的方式来表达结构体中的数据，用bx定位整个结构体，用idata定义某一个数据项，用si确定数据项中的一个元素</p>
<p>可以简写为 [bx].idata,[bx].idata[si]</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编中的多层循环</title>
    <url>/2020/01/24/%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>因为唯一的用于统计循环次数的寄存器就是cx，所以有多层循环的时候就会碰到循环次数难以记录的问题，以下是一种解决办法</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span>//用另一个寄存器来存<span class="built_in">cx</span>的次数</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol"> s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>+<span class="built_in">bx</span>]</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">si</span>+<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">   <span class="keyword">loop</span> s</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>//这里把<span class="built_in">cx</span>次数取出来减一次</span><br><span class="line">   <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure>

<p> 但是寄存器的数量是有限的，如果多次循环可能会导致寄存器不够用，因此可以先在数据段定义一个字型数据，然后直接把循环次数放到里面<br> <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> </span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol">  s0:</span> <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">cx</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2</span></span><br><span class="line"><span class="symbol">  s:</span>  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">loop</span> s</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">     <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure><br> 此外，还可以定义一个栈，直接用push，pop命令把cx值取出存入</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>si和di</title>
    <url>/2020/01/24/si%E5%92%8Cdi/</url>
    <content><![CDATA[<p>si和di在8086cpu中的功能与bx类似，si与di不能分为两个8位寄存器来使用</p>
<p>也就是说  ds：[si]是可以的</p>
<p>如果不用这些寄存器直接写的话就会出现之前所说的编译器和exe对程序的不同处理</p>
<p>例   mov ax,[si]在exe中就是 ds：[si]，但是如果是 mov，ax,[1]在exe中就是把ax中的数据放入1中</p>
<p>甚至可以直接用[bx+si]的方式或[bx+si+idata]的方式来指明内存地址</p>
<h3 id="不同寻址方式的比较"><a href="#不同寻址方式的比较" class="headerlink" title="不同寻址方式的比较"></a>不同寻址方式的比较</h3><p>[idata]用于一个常量的寻址，直接定位一个内存单元</p>
<p>[bx]用于一个变量来表示内存地址，间接定位内存单元</p>
<p>只有bx,bp,di,si具有寻址能力，例如ds:[dx]等都是错误的</p>
<p>并且这几个寄存器间组合还有要求，只有bx+si,bx+di,bp+si,bp+di这四种情况是正确的</p>
<p>只要使用bp，它的段寄存器默认为ss</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>字符形式 的数据</title>
    <url>/2020/01/23/%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F-%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>首先要知道asc11码</p>
<p>形式： db ‘…’</p>
<p>无论多少个单词都只需要单引号</p>
<p>例 db‘unix’</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>将不同代码放入不同段中</title>
    <url>/2020/01/23/%E5%B0%86%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E6%AE%B5%E4%B8%AD/</url>
    <content><![CDATA[<p>举个栗子</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code <span class="built_in">ds</span>:data <span class="built_in">ss</span>:stack</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0345h</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">20h</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span> //<span class="built_in">ds</span>:<span class="built_in">bx</span>指向data中第一个内存单元</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s0:</span><span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s0</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"> code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>看了这个就差不多了，前面定义的时候要注意不同段对应不同的寄存器，而后面要注意各个段有独自的segment与ends，而且从start开始要把各个段寄存器赋值，以备后面使用（mov ax，data）<strong>注意</strong> mov ds，data是错误的，8086cpu不允许直接把一个数值送入段寄存器中</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>在代码段中使用栈</title>
    <url>/2020/01/23/%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88/</url>
    <content><![CDATA[<p>实际上栈是我们人为定义的一段内存空间，所以先要用dw来申请</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>  //申请<span class="number">6</span>个字的内存空间，栈是由高内存地址到低内存地址，所以栈顶为<span class="built_in">cs</span>：<span class="number">Ch</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">Ch</span></span><br></pre></td></tr></table></figure>
<p>ss，sp就是前面所说的栈的指针</p>
]]></content>
  </entry>
  <entry>
    <title>dw</title>
    <url>/2020/01/23/dw/</url>
    <content><![CDATA[<p>dw即define word，定义字型数据。例如，dw 0123h,0456h,0789h.这样就定义了几个字型数据，那这些数据都在哪里呢，他们的段地址都是从cs开始的，而偏移地址从0开始，也就是说，0123h的偏移地址是0,0456h的偏移地址是2,0789h的偏移地址是6。</p>
<p>但是这样会带来一个问题，因为前十六个字节是dw所定义的字型数据，所以这样可能使程序的入口出现问题，所以可以</p>
<pre><code>assume cs:codesg
codesg segment
dw 0123h,0456h,0789h

start: mov bx,0
mov ax,0
mov cx,8
s: add ax,cs:[bx]
add bx,2
loop s
mov ax,4c00h
int 21h

codesg ends
end start</code></pre><p>这里就是加上了一个标号start，这个标号的意思就是确定程序的入口，而最后在end这里还要来一个start，因为end的作用除了确定程序在哪里终止之外，还有一个作用是告诉编译器程序在哪里开始（因为这时一个伪指令）</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>debug和源程序对指令的不同处理</title>
    <url>/2020/01/22/debug%E5%92%8C%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%AF%B9%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title="[]"></a>[]</h3><p>debug程序中[0]表示 ds：0处的数据进行处理</p>
<p>而源程序中表示把0这个数据给要处理的数据</p>
<p>例 mov ax,[0]在debug中表示把ds：0处元素给ax，而在源程序中表示把0给ax</p>
<p>在程序中，可以直接使用段寄存器加偏移地址来确定访问的元素，例如：ds：[bx],cs:[bx],ss:[bx]等</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>[bx]和loop</title>
    <url>/2020/01/21/bx-%E5%92%8Cloop/</url>
    <content><![CDATA[<h3 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h3><p>mov ax,[bx]</p>
<p>这个的意思是把ds：bx处的内容放入ax中</p>
<p>mov [bx],ax</p>
<p>这个的意思是把ax中的内容放入 地址ds：bx处</p>
<h3 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h3><p>实际上还有更加灵活的方式指明内存地址，就是bx后加一个数据，这个数据可以是常数，也可以是变量</p>
<p>例 mov ax,ds:[bx+200]，也可以直接写为ds：200[bx]</p>
<p>这种处理方式可以方便的处理数组</p>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>格式：loop+标识符</p>
<p>执行过程：执行到loop时，先让cx-=1,再判断cx中的值，不为0则转至标号处继续执行，为0则进行下一步操作，寄存器cx用来储存循环次数</p>
<p>例</p>
<pre><code>mov cx,3
mov ax,2
s: add ax,ax
  loop s</code></pre><p>这段程序的作用是计算2的三次方，首先让循环次数为3，ax=2，再从s处开始循环，当cx=0时退出，即进行3次</p>
<h3 id="用debug跟踪loop指令"><a href="#用debug跟踪loop指令" class="headerlink" title="用debug跟踪loop指令"></a>用debug跟踪loop指令</h3><p> tip：汇编程序中，数据不能以字母开头，所以如A231h等等前面都要加一个零</p>
<p> 如果想直接结束循环可以用p命令，如果用t命令的话，只会结束这一次循环</p>
]]></content>
  </entry>
  <entry>
    <title>程序执行过程的跟踪</title>
    <url>/2020/01/21/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B7%9F%E8%B8%AA/</url>
    <content><![CDATA[<p>运用debug +程序名进入debug过程</p>
<p>例如 debug 1.exe</p>
<p>程序开始都是从0000的偏移地址开始的，设段地址为A，而程序开始有一段不做该程序内容，而有其他用途。这段程序占256个字节，叫psp，之后段地址偏移10h，所以真正的程序是从A+10:0 开始的（256个字节在16进制中是10，而A也是用16进制表示的）</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>从asm到exe</title>
    <url>/2020/01/21/%E4%BB%8Easm%E5%88%B0exe/</url>
    <content><![CDATA[<p>先要有masm.exe和link.exe，然后输入masm+程序名和link+程序名</p>
<p>或者masm+盘符+程序名，可以省略中间过程，节省时间<br>例：masm c:\1.asm</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>汇编的第一个程序</title>
    <url>/2020/01/20/%E6%B1%87%E7%BC%96%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>编译器中，包含两种指令，一种是汇编指令，一种是伪指令。伪指令是给编译器看的，最终不会被cpu执行。先了解三个最为基础的伪指令</p>
<ul>
<li>XXX segment，XXX ends，这两个是配套使用的。功能是定义一个代码段，一个段必须要有一个名称标识（XXX是也）</li>
</ul>
<p>例如codesg segment ，codesg ends</p>
<ul>
<li>assume </li>
</ul>
<p>这条指令作用是假设某一寄存器和程序中的某一个用segment和ends定义的段相关联，写在最开头。</p>
<ul>
<li>end</li>
</ul>
<p>没什么特别的，程序的结束标识，不写程序不知道在哪里结束</p>
<h3 id="一个程序"><a href="#一个程序" class="headerlink" title="一个程序"></a>一个程序</h3><pre><code>assume cs: codesg
codesg segment
    mov ax,0123
    mov bx,0456
    add ax,bx
    mov ax,4c00
    int 21
codesg ends
end</code></pre><h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>在单任务操作系统上，一次只可以执行一个程序，那么当我们写的这个程序执行完之后，还要把cpu控制权交给dos，而mov ax，4c00 和 int 21 就是做这个工作的</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>栈.                                      </title>
    <url>/2020/01/20/%E6%A0%88/</url>
    <content><![CDATA[<p>栈是一段连续的内存空间，这个空间的特殊性在于，最后进入这个空间的数据，最先出去</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过ss sp 两个寄存器确定了一个栈顶指针，然后随着一些操作，这个指针会向上向下移动<br>例如 push ax，这条指令会将ax中的内容运到栈中，然后sp-2。<strong>注意</strong>，栈顶地址为低地址，栈底地址为高地址，因此增加元素会使sp值减小</p>
<p>在栈为空的时候，偏移地址为栈底地址加2，例如栈底为000F，则此时偏移地址为10，在拉一个元素进栈后，偏移地址为000E，恰好是数据最高位（一个数据一个字，两个字节，栈底为000F，用了两个空间，因此此时元素到了000E，恰好sp也是000E</p>
<h3 id="超界问题"><a href="#超界问题" class="headerlink" title="超界问题"></a>超界问题</h3><p>8086cpu并没有特定的机制来检查我们是否超界，只能够靠自己小心，超界是一个十分严重的问题，因为既然这一段被分配为栈了，说明其他的内存有其他的用途，如果超界，可能会干扰其他程序的运行。要注意，栈的范围最大是0到ffff即2的16次方字节</p>
<h3 id="push-pop-命令"><a href="#push-pop-命令" class="headerlink" title="push pop 命令"></a>push pop 命令</h3><p>push 寄存器 pop 寄存器<br>也可以是push内存地址，pop内存地址 </p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>debug</title>
    <url>/2020/01/20/debug/</url>
    <content><![CDATA[<p>这里列举几个debug的基本命令</p>
<h4 id="r"><a href="#r" class="headerlink" title="r"></a>r</h4><p>用来查看此时寄存器内的数值和下一步将要执行的命令<br>r 还可以接寄存器，用于修改寄存器内的内容<br>例：r ax 这样会出现ax的内容和一个冒号，然后就可以输入数据修改了</p>
<h3 id="d"><a href="#d" class="headerlink" title="d"></a>d</h3><p>格式：d 段地址：偏移地址<br>作用：列举出该地址下的机器码<br>例 d 1000:0,这样子将会列举从1000:0 到1000:7f的所有内容</p>
<h3 id="e"><a href="#e" class="headerlink" title="e"></a>e</h3><p>格式：e 段地址：偏移地址<br>作用：修改改地址下的机器码</p>
<h3 id="t"><a href="#t" class="headerlink" title="t"></a>t</h3><p>执行cs ip所指向内存地址的命令，直接输入t，不需要输入其他东西</p>
<h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>作用：用汇编语言输入指令到内存上<br>写法： a 段地址：偏移地址<br>例： a 1000:0<br>输出1000：0  （input）mov ax，1<br>然后1000:0 到1000:3 就会输入这条指令了，之后将cs ip地址设置一下，然后用t指令运行</p>
<h3 id="u"><a href="#u" class="headerlink" title="u"></a>u</h3><p>作用：查看某地址下的汇编程序<br>写法： u 段地址：偏移地址<br>例 u 1000:0<br>然后就会输出1000:0 开始有的汇编指令了</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>树状数组和线段树</title>
    <url>/2020/01/18/%E7%BA%BF%E6%AE%B5%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h3 id="lowbit函数"><a href="#lowbit函数" class="headerlink" title="lowbit函数"></a>lowbit函数</h3><p>lowbit函数指的是将元素与元素的补码按位与，即a&amp;-a，这个值返回的是从右数第一个1开始的值</p>
<p>例如 6&amp;-6， 6二进制位为110，所以6的lowbit函数值为10，即十进制下的二</p>
<pre><code>ll lowbit(ll num)
{
    return num&amp;-num;
}</code></pre><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>首先我们可以把一整个数组分为若干小部分，然后让这几个小部分叠加就可以得到数组总的和。例如，我想求a[91],我可以先求c[88],发现c[88]管理2个数，再找c[86]，这样一直进行下去就可以了。</p>
<p>c又是什么呢？例如c[6]，它的lowbit函数为2，因此它管理两位数，所以c[6]=a[5]+a[6]</p>
<p>奇数位的c[i]只有他自己，而偶数位c[i]为2的k次方</p>
<h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">add</span>(int <span class="keyword">x</span>, int k) &#123;</span><br><span class="line">  while (<span class="keyword">x</span> &lt;= n) &#123;  //不能越界</span><br><span class="line">    <span class="keyword">c</span>[<span class="keyword">x</span>] = <span class="keyword">c</span>[<span class="keyword">x</span>] + k<span class="comment">;</span></span><br><span class="line"><span class="comment">    x = x + lowbit(x);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个函数是把a[x]加上k，小于x的c不用修改</p>
<p>关键是x=x+lowbit(x)<br><img src="/images/1103198-20180725163149813-311841231.png" alt=""><br>从此图中我们可以看出，要想求偶数位节点大小，需要将所有子节点加起来，先要加自己和比自己小一位的奇数，再加上所有i+lowbit(i)=8的偶数</p>
<h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">int getsum(int <span class="symbol">x</span>) &#123;  <span class="comment">// a[1]……a[x]的和</span></span><br><span class="line">  int ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keywords">while</span> (<span class="symbol">x</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ans = ans + c[<span class="symbol">x</span>];</span><br><span class="line">    <span class="symbol">x</span> = <span class="symbol">x</span> - lowbit(<span class="symbol">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keywords">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">  <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; ++<span class="built_in">i</span>) &#123;</span><br><span class="line">    t[<span class="built_in">i</span>] += a[<span class="built_in">i</span>];</span><br><span class="line">    int <span class="built_in">j</span> = <span class="built_in">i</span> + lowbit(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">j</span> &lt;= n) t[<span class="built_in">j</span>] += t[<span class="built_in">i</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> kth(<span class="built_in">int</span> k) &#123;  <span class="comment">//权值树状数组查询第k小</span></span><br><span class="line">  <span class="built_in">int</span> cnt = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = log2(n); ~i; --i) &#123;</span><br><span class="line">    ret += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= n || cnt + t[ret] &gt;= k)</span><br><span class="line">      ret -= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cnt += t[ret];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>含义：线段树指的是将一个区间不断二分所形成的一个二叉树，根结点代表arr[0:N]区间所对应的信息，接着根结点被分为两个子树，分别存储arr[0:(N-1)/2]及arr[(N-1)/2+1:N]两个子区间对应的信息</p>
<p>初始化：注意此处我们对于segmentTree]数组的索引从1开始算起。则对于数组中的任意结点i，其左子结点为<code>2*i</code>，右子结点为<code>2*i + 1</code>，其母结点为i/2。<br><img src="/images/%E5%9B%BE%E7%89%879.png" alt=""><br><img src="/images/%E5%9B%BE%E7%89%8710.png" alt=""><br><img src="/images/%E5%9B%BE%E7%89%878.png" alt=""><br>递归实际意义是先向底层递归，然后从底层向上回溯，p的意思是节点的编号</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> build(<span class="built_in">int</span> s, <span class="built_in">int</span> t, <span class="built_in">int</span> p) &#123;</span><br><span class="line">  <span class="comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">  <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">int</span> m = (s + t) / <span class="number">2</span>;</span><br><span class="line">  build(s, m, p * <span class="number">2</span>), build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p><img src="/images/%E5%9B%BE%E7%89%8711.png" alt="">标记的作用是记录每次、每个节点要更新的值</p>
<h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p><img src="/images/%E5%9B%BE%E7%89%8712.png" alt=""></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>字符串之KMP算法</title>
    <url>/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8BKMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="由（扯）来（蛋）"><a href="#由（扯）来（蛋）" class="headerlink" title="由（扯）来（蛋）"></a>由（扯）来（蛋）</h3><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这三人的姓氏命名此算法。</p>
<h3 id="最长前缀和与后缀和"><a href="#最长前缀和与后缀和" class="headerlink" title="最长前缀和与后缀和"></a>最长前缀和与后缀和</h3><p>例如给出一个字符串ABCDABD<br><img src="/images/331.jpg" alt=""><br>前缀和就是从前往后数i个，后缀和是从第n-i个数到最后一个，首先我们便要找到每一个字母的最长相同前缀后缀和，然后求next数组，注意，只有一个元素时是不计算前缀后缀的，直接看为0</p>
<h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>next数组考虑的是除当前字符外的最长相同前缀后缀，实际上就是前一个前缀后缀和，因为把最后一个字母上去之后必定会使后缀和少一个，因此前缀后缀和也会-1，注意next数组中会出现-1，<strong>实际上这个数组就是将原数组整体右移一位，然后在第0位补上-1</strong></p>
<p><img src="/images/3331.jpg" alt=""></p>
<p><img src="/images/3332.jpg" alt=""></p>
<h3 id="用next数组进行匹配"><a href="#用next数组进行匹配" class="headerlink" title="用next数组进行匹配"></a>用next数组进行匹配</h3><p>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀 pj-k pj-k+1, …, pj-1 跟文本串 si-k si-k+1, …, si-1 匹配成功，但 pj 跟 si 匹配失败时，因为 next[j] = k，相当于在不包含 pj 的模式串中有最大长度为 k 的相同前缀后缀，即 p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令 j = next[j]，从而让模式串右移 j - next[j] 位，使得模式串的前缀 p0 p1, …, pk-1 对应着文本串 si-k si-k+1, …, si-1，而后让 pk 跟 si 继续匹配。如下图所示：<br><img src="/images/323.jpg" alt=""></p>
<p><strong>解释</strong>：因为前缀和后缀和相等，当最后一个匹配失误的时候就可以直接跳到后缀和开始的地方，这样就一下子匹配到了几位数，加快速度，至于合理性 ，K M P 这三个人已经证明过，而具体要跳几位呢？</p>
<p>比如说你有7个数，前面6个数已经匹配好了，结果第七位出了问题，这时一找next数组，发现第6位前缀和为2，那我们就要跳到第五位上去，找找规律，就是j-next[j]呀，没错，就是要跳这么多位，忘了自己推一下就好了，挺好推的</p>
<p><strong><em>失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</em></strong></p>
<h3 id="next数组求法"><a href="#next数组求法" class="headerlink" title="next数组求法"></a>next数组求法</h3><p>这里运用了递归的思想，首先对于前一两个可以直接写出来，然后对于后面的，假如第j个next值我们已经求出来了，那么对于第j+1个，</p>
<ol>
<li>如果p[k]=p[j]，则next[j+1]=k+1</li>
</ol>
<p>例如<img src="/images/3343.jpg" alt=""><br>C为p[j]，E为p[j+1]，next[j]=2,则第一，第二个与第五，第六个相同，如果第三个和3七个相同，则最大相同长度就为3，即p[k]=p[j]</p>
<p>2.如果p[k]!=p[j],则递归找p[next[k]]是否等于p[j]，p[next[next[k]]]是否等于p[j],直到找到或到了开头</p>
<p>对于第二种情况，也可以通过图来展示<br><img src="/images/3344.jpg" alt=""><br>现在p[j]!=p[k]，那么肯定要缩小范围，我么已经知道第一个与第二个是匹配的了，那么第五个第六个对应与第一个第二个匹配，但如果那里面没有前后缀的话，你减去一个就相当于破坏了结构（前缀从前往后，后缀也是从前往后，减去一个便要求这这个前缀串里面前几个要和后缀串里面后面几个匹配，因此要求next[k]就是为了里面要匹配，这样只需比较p[next[k]]和p[j]即可），假如中间就碰到了，那么next[j+1]=next[next[k]]+1,如果没碰到，那么next[j+1]=0（一朝回到解放前）</p>
<p>代码实现：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> GetNext(char* p,<span class="built_in">int</span> next[])  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">int</span> pLen = strlen(p);  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k;  </span><br><span class="line">            ++j;  </span><br><span class="line">            next[j] = k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配（最终代码）"><a href="#匹配（最终代码）" class="headerlink" title="匹配（最终代码）"></a>匹配（最终代码）</h3><p>匹配过程：</p>
<p>“假设现在文本串S匹配到 i 位置，模式串 P 匹配到 j 位置</p>
<p>如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符；</p>
<p>如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j] 位。</p>
<p>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。”</p>
<p>例 <img src="/images/3353.png" alt=""></p>
<p>例如此时i=10,j=6,此时文本串该位为空格，而匹配串为D，这时不匹配，就要让匹配串移动6-next[6]=4位，我令i=10,j=2,即匹配串为C,这就相当于让匹配位左移4位，而文本对应位不变，于是相当于匹配串右移4位（有种物理相对运动的既视感）</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      </span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      </span></span><br><span class="line">            <span class="comment">//next[j]即为j所对应的next值        </span></span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感到了代码的优美感有没有！</p>
<p>但是这样还可以优化</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>优化过后的<span class="keyword">next</span> 数组求法  </span><br><span class="line">void GetNextval(char* p, int <span class="keyword">next</span>[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int pLen = strlen(p);  </span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;  </span><br><span class="line">    int k = -<span class="number">1</span>;  </span><br><span class="line">    int j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">//</span>p[k]表示前缀，p[j]表示后缀    </span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k])  </span><br><span class="line">        &#123;  </span><br><span class="line">            ++j;  </span><br><span class="line">            ++k;  </span><br><span class="line">            <span class="regexp">//</span>较之前<span class="keyword">next</span>数组求法，改动在下面<span class="number">4</span>行  </span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])  </span><br><span class="line">                <span class="keyword">next</span>[j] = k;   <span class="regexp">//</span>之前只有这一行  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="regexp">//</span>因为不能出现p[j] = p[ <span class="keyword">next</span>[j ]]，所以当出现时需要继续递归，k = <span class="keyword">next</span>[k] = <span class="keyword">next</span>[<span class="keyword">next</span>[k]]  </span><br><span class="line">                <span class="keyword">next</span>[j] = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            k = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有点蒙，就先这样吧</p>
<p><a href="https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html" target="_blank" rel="noopener">参考文章（这篇文章真的太好了，生怕你不会）</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串之hash算法</title>
    <url>/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8Bhash%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="hash基础概念"><a href="#hash基础概念" class="headerlink" title="hash基础概念"></a>hash基础概念</h3><p>但在工程实践中，要查找的关键字往往都不是自然数，即使是自然数也有可能是很大的值。因此，只要我们提前把关键字转换为在固定较小范围内的自然数，就可以实现常数时间的查找。那么问题来了，如何实现该转换关系呢？这就是哈希函数所要完成的工作。</p>
<p>哈希函数：又称散列函数，是把一段有限二进制串（字符串，整数等）转换为自然数的一种函数。</p>
<p>哈希值：哈希函数输出的最终结果。</p>
<p>字符串哈希函数：输入是字符串的哈希函数。</p>
<p>注：实际上就是用一个函数将字符串转化为整数，然后尽可能使一个整数对应一个字符串</p>
<p>现在的哈希函数基本上都是满射，多个字符串会对应一个数字，这种情况佳作冲突，为了减小冲突，列举几种方法</p>
<p><img src="/images/%E5%9B%BE%E7%89%876.png" alt=""><br>这种方法就是用进制转换的观念，一般用128,但这样十分容易超int型的范围，因此要想办法减小范围，可以用一个较大的数去摸，这时又出现了冲突的问题，那可以用两个数同时去摸，这样用两个数表示一个字符串冲突的几率便大大降低</p>
<p>BKDRHash算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BKDR Hash Function</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);<span class="comment">//ox7FFFFFFF代表int型最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;是与运算符，<a href="https://blog.csdn.net/ssdjdk/article/details/90199634" target="_blank" rel="noopener">详细看这</a></p>
<p>关于 <a href="https://blog.csdn.net/MyLinChi/article/details/79509455" target="_blank" rel="noopener">BKDRHash算法可以看</a></p>
<p>最好用unsigned int 类型，<a href="https://www.cnblogs.com/lailailai/p/4030151.html" target="_blank" rel="noopener">这样相当于每次hash操作都取了一次模</a></p>
<p>APhash算法</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">// AP Hash Function</span><br><span class="line">unsigned int APHash(<span class="name">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int hash = 0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    for (i=0; *str<span class="comment">; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if ((<span class="name">i</span> &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= ((<span class="name">hash</span> &lt;&lt; <span class="number">7</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">3</span>))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= (~((<span class="name">hash</span> &lt;&lt; <span class="number">11</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">5</span>)))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return (<span class="name">hash</span> &amp; <span class="number">0</span>x7FFFFFFF)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/MyLinChi/article/details/79508112" target="_blank" rel="noopener">这篇博客讲的很详细</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/01/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h3><p>无后效性是一个问题可以用动态规划求解的标志之一，理解无后效性对求解动态规划类题目非常重要</p>
<p>概念：某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响（某度上找的定义）</p>
<p>理解：无后效性指的是之前做过的事现在还可以继续去做，这便是前一阶段做的事对后一阶段无影响。如果前面做过了后面便不能去做或者做的事受限这便是有后效性</p>
<p>例：<a href="https://blog.csdn.net/qq_30137611/article/details/77655707" target="_blank" rel="noopener">这篇博客讲的很清楚</a></p>
<h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p><a href="https://xinhecuican.github.io/2020/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">之前的一篇博客</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">struct Good&#123;</span><br><span class="line"><span class="code">    int w;</span></span><br><span class="line"><span class="code">    int v;</span></span><br><span class="line">&#125;goods[101];</span><br><span class="line">int dp[<span class="string">101</span>][<span class="symbol">1001</span>];</span><br><span class="line">int n,S;//n表示有n个物品，S表示背包的最大容积</span><br><span class="line">for (i = 1; i <span class="xml"><span class="tag">&lt;<span class="name">=</span> <span class="attr">n</span>; <span class="attr">i</span>++)</span></span></span><br><span class="line"><span class="xml">&#123;</span></span><br><span class="line"><span class="xml">    for (j = S; j &gt;</span>= goods[i].w; j--)</span><br><span class="line"><span class="code">        dp[j] = max(dp[j], dp[j - goods[i].w] + goods[i].v);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，之所将j初始化为S，逆序循环更新状态是为了保证在更新dp[j]时，dp[j-goods[i].w]的状态尚未因为本次更新而发生改变，即等价于由</p>
<p>dp[i-1][j-goods[i].w]转移得到dp[i][j]。保证了更新dp[j]时，dp[j-goods[i].w]是没有放入物品i时的数据dp[i-1][j-goods[i].w]。</p>
<p>实际上01背包问题同一种思路代码写法有两种，如果s从0开始遍历就不需要逆序，但是从大于w[i]开始就需要逆序</p>
<p>实际上这里的二维数组可以优化变为一维数组</p>
<p>dp[i][j] = max{dp[i-1][j-w[i]]+v[i]，dp[i-1][j]，这里的i与i-1实际上是第i个物体与第i-1个物体，而这个可以用数组下标直接代替，这样便可以用一维数组解决背包问题，但是一维数组与二维数组的区别是二维数组保存了前i个物品所可以获得的最大价值，而一维数组只能保存题目要求的s个物品的最大价值，因此用一维还是用二维因题目而异</p>
<p>dp[j] = max{dp[j]，dp[j-w[i]]+v[i]}。从这个方程中我们可以发现，有两个dp[j]，但是要区分开。等号左边的dp[j]是当前i的状态，右边中括号内的dp[j]是第i-1状态下的值。</p>
<p>所以为了保证状态的正确转移，我们需要先更新等号左边中的dp[j]（当前状态的dp[j]）。</p>
<p>代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,maxv;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;maxv;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">1001</span>],v[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxv;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=maxv;k&gt;=w[i];k--)<span class="comment">/*这里是因为当背包体积小于物品体积时不可能成立，相当于if(k&lt;w[i])&#123;dp[i][k]=dp[i-1][k];&#125;*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[k]=<span class="built_in">max</span>(dp[k],dp[k-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[maxv]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展问题</p>
<p>继续0-1背包问题，如果在上面的问题加上一个限制条件，所选择的物品必须恰好装满背包，否则输出-1。这时数组初始化为负无穷</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">int w<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int v<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int maxv;</span><br><span class="line">int n;</span><br><span class="line">int dp<span class="comment">[MAXSIZE]</span><span class="comment">[MAXSIZE]</span>;</span><br><span class="line"></span><br><span class="line">int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &gt; b)</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxv;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w<span class="comment">[i]</span> &gt;&gt; v<span class="comment">[i]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化，当容积为0时，即不能装入，最大价值即为0</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[0]</span> = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化为-1，表示没有装满</span><br><span class="line">    for (int i = 0; i &lt;= n; i++)</span><br><span class="line">    for (int j = 1; j &lt;= maxv; j++)</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[j]</span> = -1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = maxv; j &gt;= w<span class="comment">[i]</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1表示容积为j - w<span class="comment">[i]</span>时没有装满，所以当容积为j，装w<span class="comment">[i]</span>时一定不能装满</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt; dp<span class="comment">[i-1]</span><span class="comment">[j]</span>表示装入物品i时签好装满并且总价值比前i-1个物品的总价值要大</span><br><span class="line">            if (dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1 &amp;&amp; dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt;= dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>)</span><br><span class="line">                dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = w<span class="comment">[i]</span> - 1; j &gt;= 1; j--)</span><br><span class="line">            dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp<span class="comment">[n]</span><span class="comment">[maxv]</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它大致相同，现在dp[i][j]表示的是恰好装j空间时价值的最大值</p>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>题目：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for (i = 1; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (j = goods<span class="comment">[i]</span>.w; j &lt;= S; j++)</span><br><span class="line">        dp<span class="comment">[j]</span> = max(dp<span class="comment">[j]</span>, dp<span class="comment">[j - goods<span class="comment">[i]</span>.w]</span> + goods<span class="comment">[i]</span>.v);</span><br><span class="line">&#125;//不是很理解，但是先把模板记下吧</span><br></pre></td></tr></table></figure>
<p>这个代码和01背包代码十分相似，只有循环方向不同，为什么可以这样做呢？因为01背包要求每个物品只能选一次，因此根据这个式子，有可能会导致多选的就是dp[j - goods[i].w],如果从前往后循环，j-goods[i].w可能是已经选择了当前物品的情况</p>
<p><a href="https://pangyuworld.github.io/2019/04/03/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/#%E9%A2%98%E7%9B%AE%E7%B1%BB%E5%9E%8B-1" target="_blank" rel="noopener">可以去看</a></p>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>有N种物品和一个容量为V的背包。第 i 种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p>实际上可以转化为01背包，把每一种物品中多件拆开</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int k = n + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; <span class="built_in">i</span>++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (number[<span class="built_in">i</span>]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			w[k] = w[<span class="built_in">i</span>];</span><br><span class="line">			value[k] =value[<span class="built_in">i</span>];</span><br><span class="line">			k++;</span><br><span class="line">			number[<span class="built_in">i</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; <span class="built_in">i</span>++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (int <span class="built_in">j</span> = v; <span class="built_in">j</span> &gt;= w[<span class="built_in">i</span>]; <span class="built_in">j</span>--) &#123;</span><br><span class="line">			f[<span class="built_in">j</span>] = <span class="built_in">max</span>(f[<span class="built_in">j</span>], f[<span class="built_in">j</span> - w[<span class="built_in">i</span>]] + value[<span class="built_in">i</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样可能导致时间复杂度过高，可以考虑采用二进制思想，每一个数例如7可以用二进制来表示，而这样我们就可以把它拆为3个数，7二进制为111，所以可以拆为100,010,001，这样我们就只需要储存3个数，降低了时间复杂度。但是假如不是正好的话<br>例如13 ，二进制为1101，则可以分解为0110,0001,0010,0100（如果最好不足2^i，则取x-2^i-1)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> num[maxn][<span class="number">2</span>], dp[maxn];</span><br><span class="line"><span class="built_in">int</span> N, V, c, w, n, tot;</span><br><span class="line">memset(dp, <span class="number">0</span>, sizeof dp);</span><br><span class="line">cin &gt;&gt; V &gt;&gt; N; tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; c &gt;&gt; w &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">1</span>; k &lt; n; k&lt;&lt;=<span class="number">1</span>)<span class="comment">//左移求下一个所需二进制数 </span></span><br><span class="line">	&#123;</span><br><span class="line">		num[tot][<span class="number">0</span>] = k*c;</span><br><span class="line">		num[tot++][<span class="number">1</span>] = k*w;<span class="comment">//注意这时我们把若干物体看为1个物体，它的总重量也要变</span></span><br><span class="line">		n -= k;</span><br><span class="line">	&#125;</span><br><span class="line">	num[tot][<span class="number">0</span>] = n*c;</span><br><span class="line">	num[tot++][<span class="number">1</span>] = n*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; tot; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = V; j &gt;= num[i][<span class="number">0</span>]; --j)</span><br><span class="line">		dp[j] = max(dp[j], dp[j-num[i][<span class="number">0</span>]]+num[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索和广度优先搜索</title>
    <url>/2020/01/14/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>基本思想：它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念</p>
<p>例<img src="/images/%E5%9B%BE%E7%89%871.png" alt=""></p>
<p>V0-&gt;V1-&gt;V4-&gt;V3-&gt;V5-&gt;V6,先从v0到V1，再从V1到V4，发现到了终点，就退回到V1继续寻找</p>
<p>代码</p>
<p>注意恢复初始状态十分重要，在一种情况走不了的情况下它可以使其恢复初始状态试下一条路</p>
<p><img src="/images/%E5%9B%BE%E7%89%872.png" alt=""></p>
<p>例题：<img src="/images/%E5%9B%BE%E7%89%873.png" alt=""></p>
<p>遍历连通图，能否从v0到v6</p>
<p>答案<img src="/images/%E5%9B%BE%E7%89%874.png" alt=""></p>
<p>说明，重要的便是模板，先判断当前情况是否满足，如果满足则退出，不满足则遍历所有情况，如果某一位置到了头便会返回false，然后返回到分叉点，搜索下一步（遍历作用在这），而最后一定要回到初始状态，因为别的搜索也可能用</p>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">广度优先搜索是最简便的图的搜索算法之一，别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中</span><br></pre></td></tr></table></figure>
<p>模板<br><img src="/images/%E5%9B%BE%E7%89%875.png" alt=""></p>
<p>说明：从某一个起始节点开始，看是否满足，如果不满足， 遍历所有可能的情况，这里便是tt，如果tt存在，那么就把它送入队列中，之后继续遍历可能情况，这里需要两个数组，一个数组是用来确定这点是否已经走过，另外一个数组是用来记录步数的。<a href="https://blog.csdn.net/freezhanacmore/article/details/8168265" target="_blank" rel="noopener">另外，有些题可能会导致数组超过范围，这时就要写一个判断条件排除掉越界的</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>scanf printf</title>
    <url>/2020/01/13/scanf-printf/</url>
    <content><![CDATA[<h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>格式：scanf(const char *format, …)</p>
<p>format – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。</p>
<p>format 说明符形式为:</p>
<p>[=%[*][width][modifiers]type=]</p>
<p><code>*</code>这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。</p>
<p>width    这指定了在当前读取操作中读取的最大字符数。</p>
<p>modifiers    为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）</p>
<p>type    一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格</p>
<p>| %a、%A|读入一个浮点值(仅 C99 有效)|float*|<br>| :——————————————-|<br>| %c     | 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。|    char *<br>|%d    |十进制整数：数字前面的 + 或 - 号是可选的。|    int *<br>|%e、%E、%f、%F、%g、%G    |浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4    |float *<br>|%i|    读入十进制，八进制，十六进制整数 。|    int *<br>|%o    |八进制整数。|    int *<br>|%s    |字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。|    char *<br>|%u    |无符号的十进制整数。|    unsigned int *</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>用%c 读数组时注意它不会读入换行符，因此每次用完之后要用getchar()<br>，而%s就不用担心这个问题</p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>格式 printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p>
<p>声明 printf(const char *format, …)</p>
<p>|格式字符|    意义<br>|————————-|<br>|d|    以十进制形式输出带符号整数(正数不输出符号)<br>|o    |以八进制形式输出无符号整数(不输出前缀0)<br>|x,X    |以十六进制形式输出无符号整数(不输出前缀Ox)<br>|u    |以十进制形式输出无符号整数<br>|f|    以小数形式输出单、双精度实数<br>|e,E    |以指数形式输出单、双精度实数<br>|g,G    |以%f或%e中较短的输出宽度输出单、双精度实数<br>|c|    输出单个字符<br>|s    |输出字符串<br>|p|    输出指针地址<br>|lu    |32位无符号整数<br>|llu|    64位无符号整数</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2020/01/13/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h3><p>队列是一种线性结构，有队头（front）队尾（rear）两个指针，每次拉进来一个元素会让队尾加一，而每次删除一个元素会让队头加一，这是一种先进先出的结构。</p>
<p>队列特殊情况判断</p>
<p>空队列 front=rear</p>
<p>满队列 rear-front=N（N指的是开的数组的大小）</p>
<p>POP 从队头删元素</p>
<p>push 拉元素到队尾</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">duilie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> front ,rear;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        front=rear=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front)==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear-front==N<span class="number">-1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(full())<span class="comment">//如果满了就不能拖进去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[++rear]=key;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>上面一种队列并不是真的有n个空间，如果pop了元素那空间就要减小，这样便浪费了许多空间，而用模运算组成一个循环可以使空间充分利用</p>
<p>特殊情况判断</p>
<p>空 ： front=rear</p>
<p>满 ：（ rear+1）% N=front</p>
<p>代码实现</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const <span class="built_in">int</span> Queue_Size=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">typedef <span class="keyword">struct</span> circlQueue</span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> *elem;</span><br><span class="line">       <span class="built_in">int</span> rear;</span><br><span class="line">       <span class="built_in">int</span> front;</span><br><span class="line">       <span class="built_in">int</span> queueSize;</span><br><span class="line">&#125;circlQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">void init<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem=<span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[Q<span class="identifier">ueue_Size</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;<span class="comment">//首尾指针相等说明队列为空。</span></span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=Queue_Size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*销毁队列*/</span></span><br><span class="line">void destroy<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       delete <span class="literal">[]</span><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*求队列的长度*/</span></span><br><span class="line"><span class="built_in">int</span>  length<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">int</span> length;</span><br><span class="line">       length=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear-<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;<span class="comment">/*一般情况下，rear在front的上方，此种算法是用于</span></span><br><span class="line"><span class="comment">  rear已到front的下方，即已出现假溢出的情况。*/</span></span><br><span class="line">       return length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*入队列*/</span></span><br><span class="line">void enter<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q,<span class="params">char</span> <span class="params">x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span>(((<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)<span class="comment">//判断栈满的情况</span></span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue OverFlow!"</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">rear</span>]</span>=x;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%Queue_Size;<span class="comment">//尾指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="built_in">char</span> output<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> e;</span><br><span class="line">       <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)</span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue Empty"</span>;</span><br><span class="line">       e=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">front</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;;<span class="comment">//头指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">       return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「hackerain」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/hackerain/article/details/5934240</span></span><br></pre></td></tr></table></figure>

<h3 id="队列的函数"><a href="#队列的函数" class="headerlink" title="队列的函数"></a>队列的函数</h3><p>push()：脱元素到队尾</p>
<p>pop()删队首元素</p>
<p>size()</p>
<p>front()返回队首元素</p>
<p>back()返回队尾元素</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>front无法使用迭代器，因为queue在物理地址上不连续，所以queue无法遍历，想要遍历只能不停top POP，这样会销毁队列</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>HDU 1387 </li>
</ul>
<p>Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.<br>In a team queue each element belongs to a team. If an element enters the queue, it first searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.</p>
<p>Your task is to write a program that simulates such a team queue.</p>
<p>Input</p>
<p>The input will contain one or more test cases. Each test case begins with the number of teams t (1&lt;=t&lt;=1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0 - 999999. A team may consist of up to 1000 elements.</p>
<p>Finally, a list of commands follows. There are three different kinds of commands:</p>
<p>ENQUEUE x - enter element x into the team queue<br>DEQUEUE - process the first element and remove it from the queue<br>STOP - end of test case<br>The input will be terminated by a value of 0 for t.</p>
<p>Output</p>
<p>For each test case, first print a line saying “Scenario #k”, where k is the number of the test case. Then, for each DEQUEUE command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Sample Input</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line"><span class="number">3</span> <span class="number">201</span> <span class="number">202</span> <span class="number">203</span></span><br><span class="line">ENQUEUE <span class="number">101</span></span><br><span class="line">ENQUEUE <span class="number">201</span></span><br><span class="line">ENQUEUE <span class="number">102</span></span><br><span class="line">ENQUEUE <span class="number">202</span></span><br><span class="line">ENQUEUE <span class="number">103</span></span><br><span class="line">ENQUEUE <span class="number">203</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">259001</span> <span class="number">259002</span> <span class="number">259003</span> <span class="number">259004</span> <span class="number">259005</span></span><br><span class="line"><span class="number">6</span> <span class="number">260001</span> <span class="number">260002</span> <span class="number">260003</span> <span class="number">260004</span> <span class="number">260005</span> <span class="number">260006</span></span><br><span class="line">ENQUEUE <span class="number">259001</span></span><br><span class="line">ENQUEUE <span class="number">260001</span></span><br><span class="line">ENQUEUE <span class="number">259002</span></span><br><span class="line">ENQUEUE <span class="number">259003</span></span><br><span class="line">ENQUEUE <span class="number">259004</span></span><br><span class="line">ENQUEUE <span class="number">259005</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">ENQUEUE <span class="number">260002</span></span><br><span class="line">ENQUEUE <span class="number">260003</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">1</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">201</span></span><br><span class="line"><span class="number">202</span></span><br><span class="line"><span class="number">203</span></span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">2</span></span><br><span class="line"><span class="number">259001</span></span><br><span class="line"><span class="number">259002</span></span><br><span class="line"><span class="number">259003</span></span><br><span class="line"><span class="number">259004</span></span><br><span class="line"><span class="number">259005</span></span><br><span class="line"><span class="number">260001</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/01/13/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>归并排序运用了分治的思想，先将数组二分成一个元素（一个元素时看为有序），然后将这些元素不断合并，每合并一次排一次序，最后就可以得到有序的数组。</p>
<p>比如说一个序列:12 ,23,1,44,233,10,9,8。我们先分成两段：12 ,23,1,44 和 233,10,9,8，<br>发现还能再分成4段：12 ,23 和 1,44——233,10 和 9,8。<br>再分成8段：12–23–1–44 和233–10–9–8。<br>这时候开始把子序列进行排序合并，一个元素就是有序的。所以不用排序。<br>合并成2个一组排序得到：12，23—-1，44—10，233—8，9。<br>再合并成4个一组排序得到：1，12，23，44—8，9，10，233。<br>最后合并得到最终结果：1，8，9，10，12，23，44，233。</p>
<p>合并过程看代码</p>
<p>链接：<a href="https://www.jianshu.com/p/b50a6034eb90" target="_blank" rel="noopener">https://www.jianshu.com/p/b50a6034eb90</a></p>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/images/1024555-20161218163120151-452283750.png" alt=""></p>
<p>这个图片蓝色部分就是拆的过程，而绿的部分为并的过程</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paixu</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> mid,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span><span class="comment">//这是合并过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1=first,l2=mid+<span class="number">1</span>,r1=mid,r2=last;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1&amp;&amp;l2&lt;=r2)<span class="comment">//两部分都存在时看哪个小就加上哪个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l1]&lt;=a[l2])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1)<span class="comment">//第一部分有剩余就把第一部分剩下的全加上</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2&lt;=r2)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i+first]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xunhuan</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(first+last)/<span class="number">2</span>;</span><br><span class="line">        xunhuan(first,mid,a,temp);<span class="comment">//拆左边</span></span><br><span class="line">        xunhuan(mid+<span class="number">1</span>,last,a,temp);<span class="comment">//拆右边</span></span><br><span class="line">        paixu(first,mid,last,a,temp);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[last-first];<span class="comment">//建一个临时数组，合并时用</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="comment">//判断是否传入空数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xunhuan(first,last,a,p);</span><br><span class="line">    <span class="keyword">delete</span> [] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/2020/01/13/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<h3 id="前缀和概念"><a href="#前缀和概念" class="headerlink" title="前缀和概念"></a>前缀和概念</h3><p>前缀和指的是用另一个数组b[n]来保存a[n]中前n项的和</p>
<p>例如，b[0]=a[0],b[1]=a[0]+a[1],…</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="求数组某一区间长度数字的和"><a href="#求数组某一区间长度数字的和" class="headerlink" title="求数组某一区间长度数字的和"></a>求数组某一区间长度数字的和</h4><p>如果我给你一串长度为n的数列a1,a2,a3……an,再给出m个询问，每次询问给出L，R两个数，要求给出区间[L,R]里的数的和，一般可能是从L到R遍历一次，但这样很花时间，有了前缀和之后可以直接b[R]-b[L]就得到L到R的和</p>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分就是将数列中的每一项分别与前一项数做差</p>
<p>一个序列1 2 5 4 7 3，差分后得到1 1 3 -1 3 -4 -3</p>
<p>这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0）<br>差分序列最后比原序列多一个数（相当于0减最后一个数）</p>
<p>例 给你一串长度为n的数列a1,a2,a3……an，要求对a[L]~a[R]进行m次操作：</p>
<p>操作一：将a[L]~a[R]内的元素都加上P</p>
<p>操作二：将a[L]~a[R]内的元素都减去P</p>
<p>最后再给出一个询问求a[L]-a[R]内的元素之和？</p>
<p>如果用一般做法就是遍历加减，时间复杂度高，现在可以直接让b[L] 加上P，再让b[R+1]减去P，这样因为b[L+1]=b[L]+a[L+1]，所以L到R上每一项都会加P，而b[R+1]减去P是为了对后面的数不产生影响</p>
<p>如果有多次修改操作，可以先将每次修改保存到一个数组中，然后求前缀和时再加上<br>    #include&lt;bits/stdc++.h&gt;<br>    using namespace std;<br>    const int maxn=1e5+9;<br>    int a[maxn],b[maxn];<br>    int main(){<br>     int i,j,k,n,m,p;<br>     cin&gt;&gt;n&gt;&gt;m;<br>     for(i=1;i&lt;=n;i++){<br>        cin&gt;&gt;a[i];<br>     }<br>     for(i=1;i&lt;=m;i++){<br>        int L,R,t;<br>        cin&gt;&gt;t&gt;&gt;L&gt;&gt;R&gt;&gt;p;<br>        if(t==1){<br>            b[L]+=p;b[R+1]-=p; //仔细想想为什么b[R+1]要减去p<br>        }<br>        else{<br>            b[L]-=p;b[R+1]+=p;//这是减去p<br>        }<br>    }<br>    int add=0;<br>    for(i=1;i&lt;=n;i++){<br>        add+=b[i];<br>        a[i]+=a[i-1]+add;//这是求前缀和数组，并且add是把需要加p的地方加上<br>    }<br>    int x,y;<br>    cin&gt;&gt;x&gt;&gt;y;<br>    cout&lt;&lt;a[y]-a[x-1]&lt;&lt;endl;<br>}</p>
<h4 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4><p>1、差分序列求前缀和可得原序列</p>
<p>2、将原序列区间[L,R]中的元素全部+1，可以转化操作为差分序列L处+1，R+1处-1</p>
<p>3、按照性质2得到，每次修改原序列一个区间+1，那么每次差分序列修改处增加的和减少的相同</p>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>二维前缀和对应的是二维数组</p>
<p><img src="/images/20180817161822690.png" alt=""></p>
<p>b[2][4]表示的是b[1][1]+b[1][2]+b[1][3]+b[1][4]+b[2][1]+b[2][2]+b[2][3]</p>
<p>因此可以先加上b[1][4]+b[2][3]，这时重复了b[1][3]，再减去</p>
<p>因此公式<br>a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1]，因为这样，二维前缀和最好从一开始，0处全赋值为0</p>
<p>这时想知道从(x1,y1)到(x2,y2)的和要a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]</p>
<p>例如，求(3,3)到(4,4)的值，实际上是a[3][3]+a[3][4]+a[4][3]+a[4][4]</p>
<h3 id="二维差分（不是很清楚）"><a href="#二维差分（不是很清楚）" class="headerlink" title="二维差分（不是很清楚）"></a>二维差分（不是很清楚）</h3><p>和一维差分的第四个问题类似，让（x1,y1)和（x2,y2）矩形内的数都加上x</p>
<p>b[x1][y1]+=x; b[x2+1][y2+1]+=x;</p>
<p>b[x1][y2+1]-=x; b[x2+1][y1]-=x;</p>
<p> 参考博客<a href="https://blog.csdn.net/k_r_forever/article/details/81775899" target="_blank" rel="noopener">https://blog.csdn.net/k_r_forever/article/details/81775899</a></p>
<p> <a href="https://blog.csdn.net/Healer66/article/details/87201014" target="_blank" rel="noopener">https://blog.csdn.net/Healer66/article/details/87201014</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>结构体</title>
    <url>/2020/01/12/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<p>在c++中，结构体与类类似，都有个体域和成员函数，不同是class中默认的成员访问权限是private的，而struct中则是public的。 (2)class继承默认是private继承，而从struct继承默认是public继承。</p>
<p>定义：</p>
<pre><code> struct tag 
{
  member-list
}variable-list;</code></pre><p>注：struct为结构体关键字；<br>   tag为结构体的标志；<br>   member-list为结构体成员变量及成员函数列表，其必须列出其所有成员；<br>   variable-list为此结构体声明的变量；</p>
<p>tag相当于class中的类名，而variable-list相当于class中创建的对象</p>
<p>另外，如果想多创建几个对象，只需要<code>tag 变量名</code>即可</p>
<p>在c++中，可以直接用<code>variable-list+变量名</code>创建对象</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>memset</title>
    <url>/2020/01/11/memset/</url>
    <content><![CDATA[<p>memset(标识符，填充数据,大小)</p>
<p>memset是一个字节一个字节填充的，所以一般只能填充0或-1因为这个一个字节和四个字节相同</p>
]]></content>
  </entry>
  <entry>
    <title>快速输入</title>
    <url>/2020/01/11/%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5/</url>
    <content><![CDATA[<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="attribute">x</span>=0,f=1;</span><br><span class="line">    char <span class="attribute">ch</span>=getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span> (<span class="attribute">ch</span>=='-') <span class="attribute">f</span>=-1;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;<span class="attribute">x</span>=x*10+ch-'0';ch=getchar();&#125;</span><br><span class="line">    return x<span class="number">*f</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个快速输入只适合int类型，另外如果参加比赛，最好不要用cin，cout，速度较慢<br>用scanf，printf更好</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>qsort</title>
    <url>/2020/01/11/qsort/</url>
    <content><![CDATA[<p>自带的快排函数</p>
<p>qsortvoid qsort(void <em>base, size_t nitems, size_t size, int (*compar)(const void *, const void</em>))</p>
<p>参数</p>
<p>base– 指向要排序的数组的第一个元素的指针。<br>nitems– 由 base 指向的数组中元素的个数。<br>size– 数组中每个元素的大小，以字节为单位。<br>compar– 用来比较两个元素的函数，即函数指针（回调函数）</p>
<p>回调函数：</p>
<p>回调函数就是一个通过函数指针调用的函数。如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。 [2]<br>compar参数<br>compar参数指向一个比较两个元素的函数。比较函数的原型应该像下面这样。注意两个形参必须是const void *型，同时在调用compar 函数（compar实质为函数指针，这里称它所指向的函数也为compar）时，传入的实参也必须转换成const void *型。在compar函数内部会将const void *型转换成实际类型。<br>int compar(const void *p1, const void *p2);</p>
<p>如果compar返回值小于0（&lt; 0），那么p1所指向元素会被排在p2所指向元素的左面；<br>　　如果compar返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定；<br>　　如果compar返回值大于0（&gt; 0），那么p1所指向元素会被排在p2所指向元素的右面。</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>pair</title>
    <url>/2020/01/11/pair/</url>
    <content><![CDATA[<p>pair实际上是一个结构体，它可以把两种类型结合起来使用,定义在<code>&lt;utility&gt;</code>中</p>
<p>定义：pair&lt;类型A,类型B&gt; 标识符</p>
<p>操作 pa.first 表示类型A pa.second 表示类型B</p>
<p>注意不能用-> 操作符，虽然我也不知道为什么

]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器支持的运算</title>
    <url>/2020/01/11/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>之前写搜狗在线测试题目的时候，曾经想遍历一个set遍历。当时是这样写的。</p>
<p>set<int>::iterator b = a.begin()+1</p>
<p>后来发现程序报错。究其原因是，set迭代器不支持加减数操作。<br>查看了一下维基百科，下面是有关说明。</p>
<p>1.所有迭代器都应该实现自增算符：iter++,++iter</p>
<p>2.Bidirectional迭代器：是在前向迭代器的基础上，多了单步向后遍历的能力。也就是–iter,iter–。</p>
<p>3.Random Access迭代器：在双向迭代器基础上，具有直接访问各数据元素的能力。随机迭代器增加了“迭代器算术运算”：</p>
<p>iter+=i 迭代器递增i位</p>
<p>iter-=i 迭代器递减i位</p>
<p>iter+i 加i位后的迭代器</p>
<p>iter-i 减i位后的迭代器</p>
<p>iter[i] 加i位后的迭代器的解引用</p>
<p>iter&lt;iter1 如果迭代器iter的位置在iter1前，返回true，否则返回false</p>
<p>iter&lt;=iter1 如果iter的位置在iter1的前面或同一位置时返回true，否则返回false</p>
<p>iter&gt;iter1 如果迭代器iter的位置在iter1后，返回true，否则返回false</p>
<p>iter&gt;=iter1 如果iter的位置在iter1的后面或同一位置时返回true，否则返回false</p>
<p>4.在STL定义的容器中，string，vector与deque提供了随机访问迭代器，list、set、multiset、map、multimap提供了双向迭代器。</p>
<p>————————————————</p>
<p>版权声明：本文为CSDN博主「ShenYounger」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wusecaiyun/article/details/49563197" target="_blank" rel="noopener">https://blog.csdn.net/wusecaiyun/article/details/49563197</a></p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>vector</title>
    <url>/2020/01/11/vector/</url>
    <content><![CDATA[<h3 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h3><p>vector&lt;数据类型&gt; 标识符</p>
<h3 id="vector的函数"><a href="#vector的函数" class="headerlink" title="vector的函数"></a>vector的函数</h3><p>begin()返回开头元素的迭代器</p>
<p>end()同理</p>
<p>front() 返回开头元素的引用</p>
<p>back() 返回末尾元素的引用</p>
<p>size()返回vector内元素的数量</p>
<p>erase(迭代器) 删除一个元素</p>
<p>clear() 清空</p>
<p>insert(迭代器，a) 把a插入迭代器后</p>
<p><strong>例</strong>vector中现在有1 2 3 三个元素，vec.insert(vec.begin()+2,4)得到1 2 4 3</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>reverse(vec.begin(),vec.end()) <strong>(头文件<code>&lt;algorithm&gt;</code>)</strong></p>
<p>实际上不一定是begin到end，也可以begin()+1到、、、，只需要用迭代器就行了

<p>sort排序，也要用<code>&lt;algorithm&gt;</code>默认升序</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> <span class="constructor">Comp(<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">a</span>,<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序。</p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><pre><code>vector&lt;vector&lt;数据类型&gt; &gt; vec[3];//3行
vector&lt;数据类型&gt; veci;
for(int i=0;i&lt;3;i++)
{
   for(int k=0;k&lt;4;k++)
   {
      veci.push_back();
   }
   vec.push_back(veci);
}//四列</code></pre>]]></content>
  </entry>
  <entry>
    <title>prioity_queue</title>
    <url>/2020/01/11/prioity-queue/</url>
    <content><![CDATA[<h3 id="prioity-queue"><a href="#prioity-queue" class="headerlink" title="prioity_queue"></a>prioity_queue</h3><p>实际上是一个大顶堆，定义在<code>&lt;queue&gt;</code>中</p>
<p><code>prioity_queue&lt;int&gt; qu</code>为大顶堆</p>
<p><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qu;</code>为小顶堆</p>
<p>.push()</p>
<p>.pop()取出元素，但不返回值</p>
<p>.top()不取出元素，返回值</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>set</title>
    <url>/2020/01/11/set/</url>
    <content><![CDATA[<h3 id="set之iterator"><a href="#set之iterator" class="headerlink" title="set之iterator"></a>set之iterator</h3><p>定义：set::iterator iter</p>
<p>运用：*iter</p>
<p>遍历 for(iter=set.begin();iter!=set.end();iter++)</p>
<p>还可以直接用auto it=set.begin() (auto是自动匹配类型)</p>
<p><strong>注意</strong><br>iterator只能用++，–运算符。不能*（iter-1），另外还要注意iter++后自身会改变</p>
<p>例：set中有0,2,4，iter指向2，现在cout&lt;&lt;<em>iter&lt;&lt;” “&lt;&lt;</em>(iter–)&lt;&lt;endl;</p>
<p>输出0,2，先执行iter–，我也不知道为什么</p>
<h3 id="set之lower-bound"><a href="#set之lower-bound" class="headerlink" title="set之lower_bound()"></a>set之lower_bound()</h3><p>lower_bound()返回从first开始的第一个大于或等于val的元素的地址。如果所有元素都小于val，则返回last的地址，所以必须要</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">iter=st.lower_bound(一个数字)</span><br></pre></td></tr></table></figure>

<p>upper_bound()返回最后一个大于等于val的元素的地址</p>
<h3 id="set基础"><a href="#set基础" class="headerlink" title="set基础"></a>set基础</h3><p>定义：set&lt;数据类型&gt; 标识符 ，set中元素都唯一</p>
<p>set实际上运用了红黑树。另外，set中元素会自动排序</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>begin()，返回的是开头元素迭代器</p>
<p>end()</p>
<p>clear()</p>
<p>empty()</p>
<p>size()</p>
<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p> count(数据)判断某个值是否在set中</p>
<ul>
<li><p>erase(iterator) 删去迭代器所指向的值</p>
</li>
<li><p>erase(iteratora,iteratorb)删去a，b之间的值</p>
</li>
<li><p>erase(数据)删去该数据</p>
</li>
<li><p>set删除是不会检查任何错误的，使用时小心</p>
</li>
</ul>
<p>find(数据)返回指定元素的迭代器，没有则返回最后一个元素的迭代器</p>
<p>当set中没有元素的时候，*s.end()=0</p>
<p>insert(某一个值),将一个值插入set中，<strong>注意</strong>这是唯一的将元素弄到set中的方法，并且重复插入无效</p>
<h6 id="判断insert插入是否成功的方法（具体可看"><a href="#判断insert插入是否成功的方法（具体可看" class="headerlink" title="判断insert插入是否成功的方法（具体可看)"></a>判断insert插入是否成功的方法（<a href="https://blog.csdn.net/liyuqian199695/article/details/49100543" target="_blank" rel="noopener">具体可看</a>)</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typedef pair&lt;iterator, bool&gt; _Pairib;</span></span><br><span class="line">	pair&lt;<span class="built_in">set</span>&lt;Student,FuncStudent&gt;::iterator,<span class="keyword">bool</span>&gt; pair1=set1.insert(s1);</span><br><span class="line">	<span class="keyword">if</span>(pair1.second==<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入s1成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入s1失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>&amp;&amp;与||小提示</title>
    <url>/2020/01/07/%E4%B8%8E-%E5%B0%8F%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<h4 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h4><p>&amp;&amp;运算符从左自由依次判断 ，如果判断有一个为假则停止判断</p>
<h4 id=""><a href="#" class="headerlink" title="||"></a>||</h4><p>同理如果判断有一个为真则停止判断</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
    int a=0,b=1,c;
    c = (a != b) || (++a == b++);
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;
    return 0;
}</code></pre><p>输出为0 1因为前面一个为真，直接退出判断</p>
]]></content>
  </entry>
  <entry>
    <title>字符数组</title>
    <url>/2020/01/07/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="前方高能"><a href="#前方高能" class="headerlink" title="前方高能"></a>前方高能</h3><pre><code>char a[4]={&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;};
cout&lt;&lt;a&lt;&lt;endl;</code></pre><p>这将输出什么呢，是<code>abcd</code>，实际上是<code>abcdPpB</code></p>
<p>这就有点神奇</p>
<h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>char +标识符+[]，注意字符数组的最后一定会有’\0’，</p>
<p>例如<code>char[]=&quot;abcd&quot;,这就是一个合法的赋值，但是char[4]=&quot;abcd&quot;是不合法的因为带双引号的为字符串，赋值给字符数组时编译器会自动加上&#39;\0&#39;这时需要5个空间</code></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为本来是要加上’\0’的，但是这时位子不够了，编译器只好帮它扩扩容，也就是说这是字符数组（其实现在已经不是字符数组了）长度已经不是4了，编译器会为后面几个位子附上值（不是随机的，我也有点不清楚，这样解释先），因此后面会多输出一些。但是如果开始就把长度设为5，这时’\0’就有位子放了，也就不会多出后面那些奇奇怪怪的字符</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>next主题出现404的一个解决方法</title>
    <url>/2020/01/07/next%E4%B8%BB%E9%A2%98%E5%87%BA%E7%8E%B0404%E7%9A%84%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在<code>主题配置文件中</code></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">home:</span> /|| home</span><br><span class="line"></span><br><span class="line"><span class="symbol">about:</span> <span class="meta-keyword">/about/</span>|| user</span><br><span class="line"></span><br><span class="line"><span class="symbol">tags:</span> <span class="meta-keyword">/tags/</span>|| tags</span><br><span class="line"></span><br><span class="line"><span class="symbol">categories:</span> <span class="meta-keyword">/categories/</span>|| th</span><br><span class="line"></span><br><span class="line"><span class="symbol">archives:</span> <span class="meta-keyword">/archives/</span>|| archive</span><br><span class="line"></span><br><span class="line"><span class="meta">#schedule: /schedule/|| calendar</span></span><br><span class="line"><span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">#commonweal: /404/|| heartbeat</span></span><br></pre></td></tr></table></figure>
  <p>注意/||，原来是/ ||，不要中间那个空格，亲测有效]]></content>
      <categories>
        <category>next</category>
      </categories>
  </entry>
  <entry>
    <title>文件输入输出</title>
    <url>/2020/01/07/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h4 id="文件输入in"><a href="#文件输入in" class="headerlink" title="文件输入in"></a>文件输入in</h4><p>文件输入指的是从文件_输入_给程序，对应的有in，get，read，seekg等

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">seekg和seekp中有三个定位基址，分别是cur（当前）beg（开始），end（末尾）&lt;p&gt;</span><br><span class="line">例如 seekg（<span class="number">100</span>，ios：：beg）；seekg（<span class="number">2</span>*sizeof(Student)) student是一个类</span><br></pre></td></tr></table></figure>

<h4 id="文件输出out"><a href="#文件输出out" class="headerlink" title="文件输出out"></a>文件输出out</h4><p>文件输出指的是从程序<code>输出</code>给文件，对应的有out，put，write，seekp等</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>二分搜索</title>
    <url>/2020/01/07/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="（主要是怕自己忘记了）"><a href="#（主要是怕自己忘记了）" class="headerlink" title="（主要是怕自己忘记了）"></a>（主要是怕自己忘记了）<p></h1><p>  一个要点，用二分时要先排序<p></p>
<pre><code>int erfen(int arr[],int key,int n)
    {
        int low=0,high=n-1;
        while(low&lt;=high)
        {
            int mid=(low+high)/2;
            if(arr[mid]&lt;key)
            {
                low=mid+1;
            }
            if(arr[mid]==key)
            {
                return mid;
            }
            if(arr[mid]&gt;key)
            {
                high=mid-1;
            }
        }
        return -mid-1;
     }</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>合法的字符常量</title>
    <url>/2020/01/07/%E5%90%88%E6%B3%95%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<p>用英文单引号括起来的一个字符，例如’a’,’ ‘等等。空格也是一个字符常量</p>
<p>注意<p>
  1.转义字符也属于字符常量，例如'\t','\n'等，但是'\97'不算]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>字符常量</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/01/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>步骤：<br>1.先从数列中取出一个数作为基准数。</p>
<p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p>
<p>3．再对左右区间重复第二步，直到各区间只有一个数。</p>
<p>例 6 1 2 7 9 3 4 5 10 8 进行排序<p><br> 1 以6为基准数，先从右边找比6小的数，我们用一个变量j一步步向左移动，好在移动三次后我<br> 们找到了5，j为7。现在再让另一个变量i向右移动去找比6大的数，当i为3时找到了7.现在再让5<br> 和7互换，得到了6 1 2 5 9 3 4 7 10 8,。在让j向左移动，找到了4，i向右找到了9，再让两个数<br> 互换，j再向左到3，此时i向左也到3，两者相遇，便让3和6互换，第一次结束<br> （想想原因）<p><br> 2 现在分为两部分，左边全比6小，右边全比6大，为3 1 2 5 4 6 9 7 10 8<br> 再在3 1 2 5 4 中用同样的方法搜索一次得到2 1 3 5 4,再在2 1 中搜索得到1 2<br> 然后在5 4 中搜索得到4 5，左边排序完成，右边用同样的方法排序就可得到答案</p>
<p> 不说了，上代码</p>
<pre><code>void sort(int a[],int l,int r)
{
  if(l&lt;r)//l大于等于r时这一段排序结束
  {
      int i=l,j=r,x=a[l];
      while(i&lt;j)
      {
          while(i&lt;j&amp;&amp;a[j]&gt;=x)
          {
              j--;
          }
          while(i&lt;j&amp;&amp;a[i]&lt;=x)
          {
              i++;
          }
          swap(a[i],a[j]);
      }
      swap(a[l],a[i]);
      sort(a,l,i-1);
      sort(a,i+1,r);
 }
}</code></pre><p>  引用 转载请标明出处，原文地址：<a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="noopener">http://blog.csdn.net/morewindows/article/details/6684558</a><br>         csdn 我见过最通俗易懂的快速排序过程讲解，转自《坐在马桶上看算法：快速排序》</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划背包问题</title>
    <url>/2020/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="第一类背包问题"><a href="#第一类背包问题" class="headerlink" title="第一类背包问题"></a>第一类背包问题</h3><p>问题，有N件物品和一个容量为V的背包。第i件物品的大小是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p>
<p><strong>思路</strong> 可以用一个二维数组a[i][j]，表示把前i个物体放入一个容量为j的容器中所获得的最大价值，而a[i][j]=max(a[i-1][j],a[i-1][j-c[i]]+w[i])</p>
<p>这个式子表示到底是不装第i个物品价值大还是花去c[i]的空间装获得w[i]的价值所得的总价值最大，</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">n 	w v    <span class="number">1</span>   <span class="number">2</span>  <span class="number">3</span>	  <span class="number">4</span>	  <span class="number">5</span>	  <span class="number">6</span>	  <span class="number">7</span>	  <span class="number">8</span>	  <span class="number">9</span>	  <span class="number">10</span></span><br><span class="line">a	<span class="number">2</span>	<span class="number">6</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">12</span>	<span class="number">12</span>	<span class="number">15</span>	<span class="number">15</span>	<span class="number">15</span></span><br><span class="line">b	<span class="number">2</span>	<span class="number">3</span>	<span class="number">0</span>	<span class="number">3</span>	<span class="number">3</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">10</span>	<span class="number">11</span></span><br><span class="line">c	<span class="number">6</span>	<span class="number">5</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">10</span>	<span class="number">11</span></span><br><span class="line">d	<span class="number">5</span>	<span class="number">4</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">10</span>	<span class="number">10</span></span><br><span class="line">e	<span class="number">4</span>	<span class="number">6</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>为了叙述方便，用e2单元格表示e行2列的单元格，这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了。</p>
<p>对于d2单元格，表示只有物品e，d时,承重为2的背包,所能装入的最大价值，仍然是0，因为物品e,d都不是这个背包能装的。</p>
<p>上代码</p>
<p>————————————————<br>版权声明：本文为CSDN博主「从杰」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/mu399/article/details/7722810" target="_blank" rel="noopener">https://blog.csdn.net/mu399/article/details/7722810</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>线性筛</title>
    <url>/2020/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<p>埃氏筛中有重复，例如6,2与3都筛了一次，效率低<br>线性筛定理，（口语不准确）一个数i乘以小于等于它的最小素因数的素数所得到的合数之间没有重复</p>
<pre><code>#define N 10000
int flag[N+1],prime[N+1],pnum;
/*
flag[n] 表示n是否是素数，1是素数，0不是
prime   中是所有的素数按从小到大排列、
pnum  表示素数的个数
*/
void CreatePrime(){
    pnum=0;//初始化没有素数
    //先将所有数看做素数，然后开始筛选
    for(int i=0; i&lt;=N; i++){
        flag[i]=1;
    }
    //遍历筛去所有最大因数是i的合数
    for(int i=2; i&lt;=N; i++){
        if(flag[i]==1){
        //把素数记录下来
            p[pnum++]=i;
        }
        //遍历已知素数表中比i的最小素因数小的素数，并筛去合数
        for(int j=0; j&lt;pnum &amp;&amp; p[j]*i&lt;=N; j++){
        //筛去合数
            flag[p[j]*i]=0;
            if(i%p[j]==0)
            //找到i的最小素因数，找到了就终止
                break;
        }
    }</code></pre><p>————————————————<br>版权声明：本文为CSDN博主「太上绝情」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/bjrxyz/article/details/8125913" target="_blank" rel="noopener">https://blog.csdn.net/bjrxyz/article/details/8125913</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>埃氏筛</title>
    <url>/2020/01/04/%E5%9F%83%E6%B0%8F%E7%AD%9B/</url>
    <content><![CDATA[<p>在筛质数时，我们会发现，筛去2后，2的倍数4、6、8等一定不是素数;筛去3后，3的倍数6、9、12等一定不是倍数。简单模拟这个过程如下</p>
<pre><code>const int MAXN = 1000000；  
void Prime()  
{  
    for (int i=0; i&lt;MAXN; i++) prime[i]=1;  //先把每个数都定义为质数
    prime[0]=prime[1]=0;  
    for (int i=2; i&lt;MAXN; i++)  
    {  
        if (!prime[i]) continue;  
        for (int j=i*2; j&lt;MAXN; j+=i) prime[j] = 0;  //将i的倍数标记为合数
    }  
}</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>组合</title>
    <url>/2020/01/03/%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>本程序的思路是开一个数组，其下标表示1到n个数，数组元素的值为1表示其代表的数被选中，为0则没选中。</p>
<p>首先初始化，将数组前n个元素置1，表示第一个组合为前n个数。</p>
<p>然后从左到右扫描数组元素值的“10”组合，找到第一个“10”组合后将其变为“01”组合，同时将其左边的所有“1”全部移动到数组的最左端。</p>
<p>当第一个“1”移动到数组的n-m的位置，即n个“1”全部移动到最右端时，就得到了最后一个组合。</p>
<p>例如求5中选3的组合：</p>
<p>1 1 1 0 0 //1,2,3</p>
<p>1 1 0 1 0 //1,2,4</p>
<p>1 0 1 1 0 //1,3,4</p>
<p>0 1 1 1 0 //2,3,4</p>
<p>1 1 0 0 1 //1,2,5</p>
<p>1 0 1 0 1 //1,3,5</p>
<p>0 1 1 0 1 //2,3,5</p>
<p>1 0 0 1 1 //1,4,5</p>
<p>0 1 0 1 1 //2,4,5</p>
<p>0 0 1 1 1 //3,4,5<br>————————————————<br>版权声明：本文为CSDN博主「文如王勃三生慧」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/hf19931101/article/details/79452799" target="_blank" rel="noopener">https://blog.csdn.net/hf19931101/article/details/79452799</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>string大小写字母转换</title>
    <url>/2020/01/01/%E2%80%9Dstring%E7%B1%BB%E5%AD%97%E7%AC%A6%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E2%80%9C/</url>
    <content><![CDATA[<p>在algorithm库中有transform函数<br>transform(str.begin(),str.end(),str.begin(),::toupper)<br>注意transform有四个输入参数<br>1：str.begin()字符串的起始地址；<br>2：str.end()字符串的终止地址；<br>3：str.begin()是转换之后，输出到原str字符串的起始地址；<br>4：转换操作，可以选择toupper，tolower。</p>
]]></content>
      <categories>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>“凸包”</title>
    <url>/2019/12/31/%E2%80%9C%E5%87%B8%E5%8C%85%E2%80%9D/</url>
    <content><![CDATA[<p>凸包就是把平面中所有点都包进去的凸多边形，当然多边形上的点也是题目中给出的点</p>
<p>分治法<br>  1 首先，横坐标最小p1和最大pn的点一定是凸包上的点<br>  2上包，即离p1pn最远的点，记pmax<br>  3再把pmax与p1连接，求左侧的上包，重复上述过程即可求解<img src="/images/20150530094927274" alt=""></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>神奇的逗号运算符</title>
    <url>/2019/12/05/%E7%A5%9E%E5%A5%87%E7%9A%84%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>   cout&lt;&lt;(a,c),此时只会输出c的内容，但是a中的内容也会被计算，例如a=5,b=6,c=7  cout&lt;&lt;(（d=a+b),c) 输出为7，d=11</p>
]]></content>
  </entry>
</search>
