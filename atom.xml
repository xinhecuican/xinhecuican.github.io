<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinhecuican&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-07-10T08:35:52.526Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>星河璀璨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红黑树</title>
    <link href="http://xinhecuican.github.io/post/f89cb603.html"/>
    <id>http://xinhecuican.github.io/post/f89cb603.html</id>
    <published>2020-07-08T06:50:00.000Z</published>
    <updated>2020-07-10T08:35:52.526Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 10 2020 16:36:08 GMT+0800 (中国标准时间) --><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>红黑树是一颗二叉搜索树，并且在每个节点上增加一个变量来储存颜色，可以是红或者是黑。红黑树保证了没有一条路径会比其他路径长两倍。</p><p>每个节点有五个属性：color、key、left、right、p(parent)。</p><p>红黑树满足以下性质：</p><ul><li>根节点是黑色</li><li>每个叶结点是黑色的。</li><li>如果一个节点是红色，则两个子节点是黑色</li><li>对于每个节点，从这个节点到所有后代节点的简单路径上，均包含相同数目的黑色节点。</li></ul><p>在叶结点中不存在值，可以用一个哨兵节点来代指叶结点。哨兵节点颜色为黑，其他值任意，之后一旦到叶结点就连接到哨兵，这样可以减少空间占用。</p><p>从某一节点出发（不包含这个节点）的任意一条简单路径上黑色节点的个数叫这个点的黑高。定义红黑树的黑高是根节点的黑高。</p><p>可以证明，节点数为n的红黑树高度至多为2lg(n+1).</p><h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p>插入和删除可能会改变红黑树的性质，这个时候就需要通过旋转来恢复红黑树的性质。</p><p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%911.jpg" alt></p><p>左旋的过程是把y的左边给x，然后x变为y的左儿子。右旋可以类比</p><p>左旋函数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void left_rotate(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//t是根节点</span></span><br><span class="line">    <span class="function"><span class="title">node</span>* y = x-&gt;</span>right;</span><br><span class="line">    <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">right</span> = y-&gt;</span>left;</span><br><span class="line">    <span class="function"><span class="title">if</span>(y-&gt;</span><span class="function"><span class="title">left</span> != NULL)//设置y-&gt;</span>left的父辈节点</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span>p = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">p</span> = x-&gt;</span>p;<span class="comment">//设置y的父辈节点</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(x-&gt;</span><span class="function"><span class="title">p</span> == NULL)//如果x-&gt;</span>p为NULL，说明它是根节点</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">t</span>-&gt;</span>root = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(x == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)<span class="comment">//这是设置原来x的父辈的连接</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right == y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">y</span>-&gt;</span>left = x;</span><br><span class="line">    <span class="function"><span class="title">x</span>-&gt;</span>p = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>我们可以先找到插入位置（用二叉搜索树的方法），然后将这个点着色为红。为了保证性质，我们还要用一个函数对节点重新着色并旋转。</p><p>调整函数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void fixup(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">while</span>(x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> == red)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(x-&gt;</span><span class="function"><span class="title">p</span> == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">node</span>* y = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">if</span>(y-&gt;</span><span class="built_in">color</span> == red)<span class="comment">//情况1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">y</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">                <span class="function"><span class="title">x</span> = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">else</span> <span class="keyword">if</span>(x == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right)<span class="comment">//情况2</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">x</span> = x-&gt;</span>p;</span><br><span class="line">                left_rotate(t, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = black;<span class="comment">//情况3</span></span><br><span class="line">            <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">            <span class="function"><span class="title">right_rotate</span>(t, x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>p);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//和上面一样，就是把左右换一下</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">root</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>因为插入的是红色的节点，所以所有路径黑色节点数目相同这个性质不可能破坏。</p><p>这里可能被破坏的是根节点必须是黑色和红节点儿子必须是黑色两个性质。所以要从这两个性质着手去解决。</p><p>上面这个函数每次while都要保持下面性质：</p><ul><li>x是红节点</li><li>如果x-&gt;p是根节点，那么x-&gt;p是黑节点</li><li>如果性质被破坏，只可能是上面两条。如果是第一条，那么x是根节点并且是红节点，如果是第二条，那么它是红并且它的父亲是红。</li></ul><p>上面三种情况区别是叔节点颜色不同。在所有情况中，相同的地方是x-&gt;p-&gt;p一定是黑色，因为x-&gt;p一定是红色。</p><p><strong>情况1：叔节点是红色</strong></p><p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%912.jpg" alt></p><p>如图，左边是最开始的情况，白色代表红色。我们就可以把A和D图成黑色，然后C变成红色，这样每条路径黑色节点数目仍没变，但是此时C变成了红节点，可能和C的父亲有冲突，所以我们要把指针移动到C点</p><p><strong>情况2，情况3： 叔节点是黑色并且x是左孩子/右孩子</strong></p><p>情况2是x为右孩子。</p><p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%913.png" alt></p><p>情况2可以通过一个左旋变成情况3，此时x是左孩子。</p><p>此时把D和A都是红色。再让C一个右旋就让D到了上面（开始进行了一次左旋D到了A上面）然后让D为黑色，A和C为红色就可以了。并且这个时候循环也会结束，因为</p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>首先要基于基础的搜索二叉树删除操作，即如果删除节点是叶结点，直接删除，如果删除节点只有一个子节点，那么删除这个节点后还要让它的父节点连接这个节点的子节点，如果有两个子节点，那么要让它的前驱（或后继）来替代他。并且它的前驱的右子节点连接它的父节点。</p><p>总的函数过程为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">transplant(node* t, node* u, node* v)<span class="comment">//删u节点操作，用v替代</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(u-&gt;</span>p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">t</span>-&gt;</span>root = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(u == u-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">u</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">u</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">v</span>-&gt;</span><span class="function"><span class="title">p</span> = u-&gt;</span>p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixup(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">while</span>(x != t-&gt;</span><span class="function"><span class="title">root</span> &amp;&amp; x-&gt;</span><span class="built_in">color</span> == black)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(x == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">node</span>* w = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">if</span>(w-&gt;</span><span class="built_in">color</span> == red)<span class="comment">//情况1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">                <span class="function"><span class="title">left_rotate</span>(t, x-&gt;</span>p);</span><br><span class="line">                <span class="function"><span class="title">w</span> = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span>(w-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="function"><span class="title">color</span> == black &amp;&amp; w-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="built_in">color</span> == black)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="built_in">color</span> = red;<span class="comment">//情况2</span></span><br><span class="line">                <span class="function"><span class="title">x</span> = x-&gt;</span>p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">else</span> <span class="keyword">if</span>(w-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="built_in">color</span> == black)<span class="comment">//情况3</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">                right_rotate(t, w);</span><br><span class="line">                <span class="function"><span class="title">w</span> = w-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">color</span> = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span>;<span class="comment">//情况4</span></span><br><span class="line">            <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">            <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">            <span class="function"><span class="title">left_rotate</span>(t, x-&gt;</span>p);</span><br><span class="line">            <span class="function"><span class="title">x</span> = t-&gt;</span>root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//就是左右交换一下</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="title">x</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">delete(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//y-&gt;original-&gt;color保存的是y发生改变之前的颜色</span></span><br><span class="line">    node* z;</span><br><span class="line">    node *y = x;</span><br><span class="line">    <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">original</span>-&gt;</span><span class="function"><span class="title">color</span> = y-&gt;</span><span class="built_in">color</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span>(x-&gt;</span>left == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">z</span> = x-&gt;</span>left;</span><br><span class="line">        <span class="function"><span class="title">transplant</span>(t, x, x-&gt;</span>right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(x-&gt;</span>right == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">z</span> = x-&gt;</span>right;</span><br><span class="line">        <span class="function"><span class="title">transplant</span>(t, x, x-&gt;</span>left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果两个子树都不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">y</span> = minimum(x-&gt;</span>right);<span class="comment">//找到x的后继</span></span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">original</span>-&gt;</span><span class="function"><span class="title">color</span> = y-&gt;</span><span class="built_in">color</span>;</span><br><span class="line">        <span class="function"><span class="title">z</span> = y-&gt;</span>right;</span><br><span class="line">        <span class="function"><span class="title">if</span>(y-&gt;</span>p == x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">z</span>-&gt;</span>p = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">transplant</span>(t, y, y-&gt;</span>right);</span><br><span class="line">            <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">right</span> = x-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span>p = y;</span><br><span class="line">        &#125;</span><br><span class="line">        transplant(t, x, y);</span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">left</span> = x-&gt;</span>left;</span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">color</span> = x-&gt;</span><span class="built_in">color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span>(y-&gt;</span><span class="function"><span class="title">original</span>-&gt;</span><span class="built_in">color</span> == black)</span><br><span class="line">    &#123;</span><br><span class="line">        fixup(t, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>保持y是要被删除的元素,因此如果y最初的颜色是黑色就可能改变性质。而z保存的是y的原始位置。</p><p>在fixup中，while循环总目标是把额外的黑色沿着树往上提。</p><p>while节点退出条件：</p><ul><li>x指向红黑节点（两种颜色）。然后再最后再将颜色变成单独的颜色。</li><li>x指向根节点</li><li>执行适当的旋转和重新着色，退出循环。</li></ul><p>在循环中，x总是指向双重黑色节点（双重黑色就是假设z位置处额外有一个黑色，之后y删除会移走一个黑色然后性质就符合了，但是多了一个黑色会导致开开始路径黑色数目就不同，所以要把这个双重黑色的节点放到根节点处，这样就不会有影响了，红黑色就是z处原来是红色。另外这是为了理解说的，和书上的不同）。</p><p>如果x是双重黑色，那么w（x的兄弟）不可能是NULL，因为这会导致两边黑色不相等。</p><p><strong>情况1： x的兄弟w是红色的</strong><br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%915.jpg" alt></p><p>它的目的是把兄弟节点变成黑色。先把父亲节点和兄弟节点的颜色设置好，然后进行旋转。会把情况变成情况2或3</p><p><strong>情况2： w黑色，并且w的两个子节点是黑色</strong></p><p>这个时候可以从w上去除一层黑色，也就是x变成单黑然后w变成红色，然后x到父亲节点（一定是红色），也就是说这个时候去掉了黑色但是性质不满足了（有两个红色），所以跳出循环后还要加一个把x变成黑色</p><p><strong>情况3： w黑色，w左孩子红色，右孩子黑色</strong></p><p>通过这种变换，会把情况变成情况4.</p><p><strong>情况4： w黑色，w右孩子红色</strong></p><p>这种情况也是可以去掉黑色的。然后把x设置成根是为了退出循环。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 10 2020 16:36:08 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h1&gt;&lt;p&gt;红黑树是一颗二叉
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 爬取</title>
    <link href="http://xinhecuican.github.io/post/3de4bc69.html"/>
    <id>http://xinhecuican.github.io/post/3de4bc69.html</id>
    <published>2020-07-01T12:16:00.000Z</published>
    <updated>2020-07-10T02:50:05.332Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 10 2020 16:36:08 GMT+0800 (中国标准时间) --><h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1><p>requests用来爬取网站上的信息。有七个主要方法</p><ul><li>r = requests.get(url， params， ** kwargs): url是你想爬取网站的url。通过get构造了一个向服务器请求资源的Request对象。返回一个包含服务器资源的Response对象。</li><li>head(): 获取网页头部信息</li><li>post(url, data, json, kwargs): 在后面添加数据。默认如果是列表等会存储到form字段下，如果是字符串会存在data字段下</li><li>put(): 覆盖网页某一字段数据。例如上传字符串会把data字段覆盖</li><li>patch(): 删改某一位置信息（和put的区别是put必须全部删除，patch只需要修改需要改的部分）</li><li>delete(): 删除url处的资源</li><li>request(method, url, ** kwargs): method有七种，分别是’GET’,’OPTIONS’等，注意其中delete是小写。</li></ul><p>kwargs参数（get,put, patch要比request少params，head,delete相同，post11个）：</p><ul><li>params： 输入参数</li></ul><p>例子 <img src="/images/python%E7%88%AC%E5%8F%963.PNG" alt></p><ul><li>data： 提交资源，一般用用字典的形式</li><li>json： 可以作为request的内容</li><li>headers： http头字段</li><li>cookies：</li><li>auth： http认证功能</li><li>files： 传输文件时使用</li><li>timeout： 设定的超时时间</li><li>proxies： 设定访问代理服务器</li><li>allow_redirects: 默认是True。重定向开关</li><li>stream： 是否对获取内容立即下载。默认立即下载</li><li>verify： 认证SSL证书字段</li><li>cert： 保存本地ssl路径字段</li></ul><p>Response对象属性：</p><ul><li>status_code: 200表示成功，404表示失败（不是200就是失败）</li><li>text： 爬取内容的字符串形式。</li><li>encoding： 猜测的编码形式。这是从服务器的charset字段获得的。如果服务器中没有charset字段，那么会返回ISO-8859-1</li><li>apparent_encoding: 备选编码形式.它是根据内容分析的（可能这个更加准确）</li><li>content： 爬取内容的二进制形式</li><li>request: response对应的request对象</li></ul><h2 id="爬取模板"><a href="#爬取模板" class="headerlink" title="爬取模板"></a>爬取模板</h2><p>requests异常种类：<img src="/images/python%E7%88%AC%E5%8F%961.PNG" alt></p><p>模板：<img src="/images/python%E7%88%AC%E5%8F%962.PNG" alt></p><p>有些网页会拒绝爬虫的爬取，这个时候我们可以通过更改头部信息让我们看上去是浏览器爬取。模板为：</p><p><img src="/images/python%E7%88%AC%E5%8F%964.PNG" alt></p><p>想要运用爬虫使用搜索引擎。首先要知道搜索引擎的接口，百度的接口是<code>http://www.baidu.com/s?wd=keyword</code>.360的接口是 <code>http://www.so.com/s?q=keyword</code>。其中keyword就是我们要搜索的内容。所以我们只需要在搜索时让url加上wd或q字段即可。</p><p>模板：<img src="/images/python%E7%88%AC%E5%8F%966.PNG" alt></p><p>获取图片要用二进制读取的方式，模板为<img src="/images/python%E7%88%AC%E5%8F%967.PNG" alt></p><p>ip138是一个用来查询ip内容的网站。它的接口是<code>&quot;http://m.ip138.com/ip.asp?ip=...&quot;</code>于是我们可以通过这个接口去访问ip地址的内容。</p><p>模板：<br><img src="/images/python%E7%88%AC%E5%8F%968.PNG" alt></p><h1 id="beautifulsoup4"><a href="#beautifulsoup4" class="headerlink" title="beautifulsoup4"></a>beautifulsoup4</h1><p>beautifulsoup4可以用来解析html和xml。</p><p>导入： import bs4或from bs4 import Beautifulsoup</p><p>基本元素：</p><ul><li>Tag： 标签，如<code>&lt;&gt;&lt;/&gt;</code></li><li>Name: 标签的名字，如<code>&lt;p&gt;&lt;/p&gt;</code>中的p</li><li>Attribute： 标签属性，如<code>&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt;</code> 中的src和alt。它是一个字典类型，可以用<code>&lt;tag&gt;.attrs</code>访问</li><li>NavigableString: 两个标签之间的字符串。用<code>&lt;tag&gt;.string</code>访问</li><li>Comment： 标签中间字符串的注释</li></ul><p>一些函数：</p><ul><li>prettify(): 在标签之间添加换行符，让html文本易读。</li><li>find_all(name, attrs, recursive, string, ** kwargs); 查找所有标签，返回列表，它有一种简写形式,标签(…)，因为它十分常用。name是标签名字。attrs是对某一属性值的检索（如果某个标签有这个属性返回的还是这个标签）。recursive是是否对所有子孙进行搜索，默认是True。string是检索两个标签之间的字符串。</li><li>find(),find_parents(),find_parent(),find_next_siblings(),find_next_sibling,find_preivous_siblings,find_previous_sibling(): 这些方法的参数和使用方法相同。其中find()只返回第一个结果并且是字符串类型。</li></ul><p>解析器: <img src="/images/python%E7%88%AC%E5%8F%969.PNG" alt></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">"F:/html/test.html"</span>, <span class="keyword">encoding</span>=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    soup = BeautifulSoup(f, <span class="string">"html.parser"</span>) <span class="comment"># soup代指这个文档，算作一种标签</span></span><br></pre></td></tr></table></figure></div><h2 id="标签树的遍历"><a href="#标签树的遍历" class="headerlink" title="标签树的遍历"></a>标签树的遍历</h2><p>任何html文档都可以看成是一个标签树，树的根节点就是</p><html>，因此我们可以从根节点出发得到整个标签树。</html><p></p><p>可以通过soup.html获得html标签。然后标签有如下属性：</p><ul><li>contents。子节点列表。\n也在列表中</li><li>children。子节点迭代类型，用于循环遍历儿子节点</li><li>descendants。包括所有的子孙节点，用于循环遍历</li><li>parent。 父亲标签</li><li>parents。 所有前辈</li><li>next_sibling: 返回html文本顺序的下一个平行标签(也就是父亲节点相同）。navigable_string也在列表中</li><li>previous_sibling： 返回html文本顺序的上一个平行标签</li><li>next_siblings</li><li>previous_siblings</li></ul><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><img src="/images/python%E7%88%AC%E5%8F%9610.PNG" alt><br><img src="/images/python%E7%88%AC%E5%8F%9611.PNG" alt></p><p>例如： 0-99表示 [1-9]?/d</p><p>python使用rowstring类型来表达正则表达式，即r’…’。这种String不会出现转义现象</p><p>函数：</p><ul><li>re.compile(pattern, flags=0): 把正则表达式编译成对象，便于多次使用。形成对象之后就可以使用下面的六个方法，都是相对的少了pattern参数</li></ul><p><img src="/images/python%E7%88%AC%E5%8F%9612.PNG" alt></p><ul><li>search(pattern, string, flags=0): pattern是正则表达式字符串后者原生字符串。因为原生字符串有些字符要转义，比较麻烦。String是要搜寻的文本，flags是控制标记</li><li>match匹配的字符串必须是从字符串开头开始。例如r3，如果我们用match搜寻数字，会返回空，因为数字不是从开头开始的。</li><li>split(pattern, string, maxsplit=0, flags=0): maxsplit是最大分割数，多余的部分将作为最后一个元素输出。split函数会去掉匹配上的部分，然后剩下的部分用一个列表输出，maxsplit就是最多去掉多少个匹配的</li><li>sub(pattern, repl, string, count=0, flags=0): repl是替换字符串，count是替换次数</li></ul><p><img src="/images/python%E7%88%AC%E5%8F%9613.PNG" alt>这是flags常用标记</p><p>如果没有匹配上，会返回一个空指针</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 10 2020 16:36:08 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;requests&quot;&gt;&lt;a href=&quot;#requests&quot; class=&quot;headerlink&quot; title=&quot;requests&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://xinhecuican.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>java 图片操作</title>
    <link href="http://xinhecuican.github.io/post/3319ed9a.html"/>
    <id>http://xinhecuican.github.io/post/3319ed9a.html</id>
    <published>2020-06-11T01:12:00.000Z</published>
    <updated>2020-06-11T02:41:29.119Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jun 11 2020 10:41:29 GMT+0800 (中国标准时间) --><h1 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h1><p><strong>通过Toolkit</strong></p><p>可以通过Toolkit工具从本地，网络或内存获取图片</p><ul><li>Image Toolkit.getDefaultToolkit().getImage(String filename)</li><li>Image Toolkit.getDefaultToolkit().getImage(URL url)</li><li>Image Toolkit.getDefaultToolkit().createImage(byte[] imageData)</li></ul><p><strong>通过ImageIO</strong></p><p>方法：</p><ul><li>BufferedImage ImageIO.read(File input)</li><li>ImageIO.read(URL input)</li><li>ImageIO.read(InputStream input)</li></ul><p>一般用这种方法</p><p><strong>ImageIO常用方法</strong></p><ul><li>int getWidth()： 获取图片宽度</li><li>int getHeight()</li><li>int getWidth(ImageObserver observer)</li><li>int getHeight(ImageObserver observer)</li><li>setRGB(int x, int y, int rgb)： 设置图片在(x, y)处像素</li><li>getRGB(int x, int y)： 获取像素</li><li>setRGB(int startX, int startY, int w, int h, int[] rgbArray, int offset, int scansize)：startx,starty是左上角，w和h是宽和高，offset是rgbarray偏移量。scansize是每一行在数组内长度，一般取w。</li><li>int[] getRGB(int startX, int startY, int w, int h, int[] rgbArray, int offset, int scansize)</li><li>BufferedImage getSubimage (int x, int y, int w, int h)： 剪裁图片</li><li>Image getScaledInstance(int width, int height, int hints)：图片缩放，生成的是Image，如果想变成BufferedImage，可以创建一个同样大小的BufferedImage，然后绘制进去。hints是缩放算法，取值如下：<ul><li>SCALE_AREA_AVERAGING: 使用 Area Averaging 图像缩放算法;</li><li>SCALE_DEFAULT: 使用默认的图像缩放算法;</li><li>SCALE_FAST: 选择一种图像缩放算法，在这种缩放算法中，缩放速度比缩放平滑度具有更高的优先级;</li><li>SCALE_REPLICATE: 使用 ReplicateScaleFilter 类中包含的图像缩放 算法;</li><li>SCALE_SMOOTH: 选择图像平滑度比缩放速度具有更高优先级的图像缩放算法。</li></ul></li></ul><p>在图片上绘制文字等</p><ul><li>Graphics2D createGraphics()： 创建绘制图片的画布</li><li>Graphics getGraphics()： 获得画布</li></ul><h1 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h1><ul><li>ImageIO.write(RenderedImage im, String formatName, File output)：RenderedImage可以是BufferedImage，format是图片格式，例如”jpg”等。output是输出文件</li><li>ImageIO.write(RenderedImage im, String formatName, OutputStream output)：这里的output是输出位置，可以输出到内存或文件中。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span><br><span class="line">        <span class="comment">// 获取屏幕尺寸</span></span><br><span class="line">        Dimension screenSize = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.get<span class="constructor">ScreenSize()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建需要截取的矩形区域</span></span><br><span class="line">        Rectangle rect = <span class="keyword">new</span> <span class="constructor">Rectangle(0, 0, <span class="params">screenSize</span>.<span class="params">width</span>, <span class="params">screenSize</span>.<span class="params">height</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截屏操作</span></span><br><span class="line">        BufferedImage bufImage = <span class="keyword">new</span> <span class="constructor">Robot()</span>.create<span class="constructor">ScreenCapture(<span class="params">rect</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存截取的图片</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>write(bufImage, <span class="string">"PNG"</span>, <span class="keyword">new</span> <span class="constructor">File(<span class="string">"capture.png"</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jun 11 2020 10:41:29 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;读取图片&quot;&gt;&lt;a href=&quot;#读取图片&quot; class=&quot;headerlink&quot; title=&quot;读取图片&quot;&gt;&lt;/a&gt;读取图片&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>swing JTree</title>
    <link href="http://xinhecuican.github.io/post/455a4c92.html"/>
    <id>http://xinhecuican.github.io/post/455a4c92.html</id>
    <published>2020-06-09T03:04:00.000Z</published>
    <updated>2020-06-10T02:50:49.321Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jun 10 2020 14:55:31 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>树图形就像文件目录。由TreeNode表示节点，用TreePath表示这个节点的路径。</p><p>创建时，先创建根节点，然后创建子节点连接，类似于树的链式表示。</p><p>TreeNode 是一个接口，创建节点对象时，通常使用已实现该接口的的 DefaultMutableTreeNode 类。</p><h1 id="DefaultMutableTreeNode"><a href="#DefaultMutableTreeNode" class="headerlink" title="DefaultMutableTreeNode"></a>DefaultMutableTreeNode</h1><p>表示一个节点，可以进行增查改删等操作。</p><p>构造方法：</p><ul><li>DefaultMutableTreeNode(Object userObject, boolean allowsChildren)：userObject是用户对象（节点名称），allowsChildren是是否允许拥有子节点</li></ul><p>方法：</p><ul><li>add()： 添加子节点</li><li>insert(MutableTreeNode newChild, int childIndex) ： 在指定位置插入子节点</li><li>getPreviousSibling()： 获得这个节点的前一个兄弟节点</li><li>getNextSibling()</li><li>getFirstChild()</li><li></li><li>remove(int childIndex)： 移除子节点</li><li>remove(MutableTreeNode aChild);</li><li>removeAll()</li><li>getChildCount()：获得子节点数量</li><li>getLeafCount()： 获得叶子结点数量</li><li>TreeNode getChildAt(int index)： 获取指定位置子节点</li><li>TreeNode getChildAfter(TreeNode aChild)： 获取子节点之后子节点</li><li>TreeNode getChildBefore(TreeNode aChild)</li><li>boolean isNodeChild(TreeNode aNode)： 判断是否是aNode是否是这个节点子节点</li><li>TreeNode getParent()： 获得父节点，没有返回null</li><li>boolean isRoot()： 是否是根节点</li><li>boolean isLeaf()</li><li>int getLevel()： 返回这个节点的层数，如果是根节点就是0</li><li>TreeNode[] getPath()： 返回从根结点到这个节点的路径，第一个节点是根节点</li><li>Enumeration children()： 遍历子节点（不包括孙子节点）</li><li>Enumeration breadthFirstEnumeration()： 遍历树（广度遍历）</li><li>Enumeration depthFirstEnumeration()： 深度遍历</li><li>setUserObject(Object userObject)</li><li>Object getUserObject(): 获得节点名称</li></ul><h1 id="TreePath"><a href="#TreePath" class="headerlink" title="TreePath"></a>TreePath</h1><p>一般使用方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode[] pathNodes = <span class="keyword">node</span>.<span class="title">getPath</span>();</span><br><span class="line">TreePath treePath = new TreePath(pathNodes);</span><br></pre></td></tr></table></figure></div><ul><li>treePath.getPathCount(): 获得节点数量</li><li>treePath.getPath()： 获得路径上的节点</li><li>treePath.getParentPath()： 获得这个节点上一个节点路径</li><li>treePath.isDescendant(TreePath aTreePath)： 判断aTreePath是否包含这个路径（判断aTreePath节点是否是子孙辈节点）</li></ul><h1 id="JTree"><a href="#JTree" class="headerlink" title="JTree"></a>JTree</h1><p>JTree负责把构造好的树显示出来。</p><p>构造方法：</p><ul><li>JTree(TreeNode root)： 由根节点就可以显示整个树</li><li>TreeModel treeModel = new DefaultTreeModel(TreeNode root)：构建一个树模型. 然后JTree(treeModel)</li></ul><p>方法：</p><ul><li>TreePath getPathForRow(int row)： 获得行索引。但是这个行索引实惠变化的，它不包括没有展开的。</li><li>int getRowForPath(TreePath path)： 根据路径获得行索引</li><li>int getRowForLocation(int x, int y)： 获得这个位置处的节点，可以和鼠标监听器一起使用。</li><li>TreePath getPathForLocation(int x, int y)</li><li>expandRow(int row)： 展开节点</li><li>expandPath(TreePath path)</li><li>collapseRow(int row)： 折叠节点</li><li>collapsePath(TreePath path)</li><li>isExpanded(int row)： 节点是否处于展开状态</li><li>isExpanded(TreePath path)</li><li>setSelectionRow(int row)： 设置当前选中的节点</li><li>setSelectionRow(int[] row)</li><li>setSelectionPath(TreePath path)</li><li>setSelectionPath(TreePath[] path): 多选</li><li>int[] getSelectionRows()： 获取当前选中的节点</li><li>TreePath getSelectionPath()</li><li>TreePath[] getSelectionPaths()</li><li>setRootVisible(boolean rootVisible)： 是否显示根节点（默认显示）</li><li>setShowsRootHandles(boolean newValue)： 是否显示根节点句柄（默认不显示）</li><li>setEditable(boolean flag)</li></ul><p>设置节点样式：</p><p>首先创建节点渲染器<code>DefaultTreeCellRenderer render = new DefaultTreeCellRenderer()</code></p><ul><li>render.setOpenIcon(Icon newIcon)： 设置节点展开时图标</li><li>render.setClosedIcon(Icon newIcon)：</li><li>render.setLeafIcon(Icon newIcon)： 叶子节点显示图标</li><li>render.setFont(Font font)</li><li>ender.setTextSelectionColor(Color newColor)：选中时颜色</li><li>render.setTextNonSelectionColor(Color newColor)</li><li>render.setBackgroundSelectionColor(Color newColor)： 选中时背景颜色</li><li>render.setBackgroundNonSelectionColor(Color newColor)</li></ul><p>之后设置节点渲染器<code>jTree.setCellRenderer(render)</code></p><p>监听器：</p><ul><li>addTreeExpansionListener： 节点展开/折叠监听器</li><li>addTreeWillExpandListener： 功能和上面相同，但是先执行</li><li>addTreeSelectionListener： 节点被选中监听器</li><li>tree.getModel().addTreeModelListener： 节点增删改监听器</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Tree</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="constructor">Tree(String <span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> <span class="constructor">JFrame(<span class="params">name</span>)</span>;</span><br><span class="line">        frame.pack<span class="literal">()</span>;</span><br><span class="line">        frame.set<span class="constructor">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class="line">        frame.set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        DefaultMutableTreeNode treeroot = <span class="keyword">new</span> <span class="constructor">DefaultMutableTreeNode()</span>;</span><br><span class="line">        Object<span class="literal">[]</span> treename = <span class="keyword">new</span> Object<span class="literal">[]</span>&#123;<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"H"</span>&#125;;</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;treename.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            treeroot.add(<span class="keyword">new</span> <span class="constructor">DefaultMutableTreeNode(<span class="params">treename</span>[<span class="params">i</span>])</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        Object<span class="literal">[]</span> C_treename = <span class="keyword">new</span> Object<span class="literal">[]</span>&#123;<span class="string">"user"</span>, <span class="string">"program"</span>, <span class="string">"data"</span>&#125;;</span><br><span class="line">        DefaultMutableTreeNode C_treenode = (DefaultMutableTreeNode) treeroot.get<span class="constructor">ChildAt(0)</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="module-access"><span class="module"><span class="identifier">C_treename</span>.</span></span>length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">C_treenode</span>.</span></span>add(<span class="keyword">new</span> <span class="constructor">DefaultMutableTreeNode(C_treename[<span class="params">i</span>])</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        JTree tree = <span class="keyword">new</span> <span class="constructor">JTree(<span class="params">treeroot</span>)</span>;</span><br><span class="line">        tree.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line">        tree.set<span class="constructor">RootVisible(<span class="params">false</span>)</span>;</span><br><span class="line">        tree.set<span class="constructor">ShowsRootHandles(<span class="params">true</span>)</span>;</span><br><span class="line">        frame.add(tree);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E7%BB%84%E4%BB%B69.PNG" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jun 10 2020 14:55:31 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;p&gt;树图形就像文件目
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>swing 表格</title>
    <link href="http://xinhecuican.github.io/post/ade8c6d6.html"/>
    <id>http://xinhecuican.github.io/post/ade8c6d6.html</id>
    <published>2020-06-09T01:08:00.000Z</published>
    <updated>2020-06-09T03:04:01.394Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jun 10 2020 09:08:35 GMT+0800 (中国标准时间) --><p><a href="https://blog.csdn.net/xietansheng/article/details/78079806" target="_blank" rel="external nofollow noopener noreferrer">学习自</a></p><h1 id="基础表格"><a href="#基础表格" class="headerlink" title="基础表格"></a>基础表格</h1><p>JTable用来编辑二维表格。注意添加到容器时表头和内容要分开添加。表头获取是table.getTableHeader()。</p><p>构造方法：</p><ul><li>JTable(int numRows, int numColumns)</li><li>JTable(Object[][] rowData, Object[] columnNames)：columnnames是表头名称</li><li>JTable(TableModel dm)： 用表格模型创建表格</li></ul><p>方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setFont</span><span class="params">(Font f)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//被选中字体颜色</span></span><br><span class="line"><span class="function"><span class="title">setSelectionForeground</span><span class="params">(Color selectionForeground)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setForeground</span><span class="params">(Color fg)</span></span><span class="comment">//字体颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setSelectionBackground</span><span class="params">(Color selectionBackground)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//网格颜色</span></span><br><span class="line"><span class="function"><span class="title">setGridColor</span><span class="params">(Color gridColor)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否显示网格</span></span><br><span class="line"><span class="function"><span class="title">setShowGrid</span><span class="params">(boolean showGrid)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//水平网格是否显示</span></span><br><span class="line"><span class="function"><span class="title">setShowHorizontalLines</span><span class="params">(boolean showHorizontalLines)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setShowVerticalLines</span><span class="params">(boolean showVerticalLines)</span></span></span><br></pre></td></tr></table></figure></div><ul><li>JTableHeader getTableHeader(): 获取表头</li><li>jTableHeader.setFont(Font font);： 设置表头颜色</li><li>jTableHeader.setForeground(Color fg)</li><li>jTableHeader.setResizingAllowed(boolean resizingAllowed)：时候可以拖动调整列大小</li><li>jTableHeader.setReorderingAllowed(boolean reorderingAllowed)： 是否可以拖动进行重新排序</li><li>setRowHeight(int rowHeight)： 行高</li><li>setRowHeight(int row, int rowHeight)： 指定行行高</li><li>setAutoResizeMode(int mode)改变列宽的操作<ul><li>JTable.AUTO_RESIZE_ALL_COLUMNS 在所有的调整大小操作中，按比例调整所有的列。</li><li>JTable.AUTO_RESIZE_LAST_COLUMN 在所有的调整大小操作中，只对最后一列进行调整。</li><li>JTable.AUTO_RESIZE_NEXT_COLUMN 在 UI 中调整了一个列时，对其下一列进行相反方向的调整。</li><li>JTable.AUTO_RESIZE_OFF 不自动调整列的宽度；使用滚动条</li><li>JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS 在 UI 调整中，更改后续列以保持总宽度不变；此为默认行为。</li></ul></li><li>TableColumn jTable.getColumnModel().getColumn(int columnIndex)：获取某列进行操作</li><li>tableColumn.setWidth(int width);</li><li>tableColumn.setPreferredWidth(int preferredWidth);</li><li>tableColumn.setMinWidth(int minWidth);</li><li>tableColumn.setMaxWidth(int maxWidth);</li><li>tableColumn.sizeWidthToFit()： 设置列宽使其符合单元格宽度</li><li>tableColumn.setResizable(boolean isResizable)： 是否允许手动改变列宽</li><li>tableColumn.setHeaderValue(Object headerValue)： 设置该列表头名称</li><li>jTable.getModel().setValueAt(Object aValue, int rowIndex, int columnIndex)： 设置某个位置数据</li><li>Object jTable.getModel().getValueAt(int rowIndex, int columnIndex)：得到某个位置数据</li></ul><h1 id="表格模型"><a href="#表格模型" class="headerlink" title="表格模型"></a>表格模型</h1><p>TableModel中储存了表格的一系列信息，实际上导入JTable中的数据自动变成TableModel。</p><p>TableModel中的方法：</p><ul><li>getRowCount()： 获取行数</li><li>getColumnCount()： 获取列数</li><li>String getColumnName(int columnIndex)：获取指定列的表头名称</li><li>Class&lt;?&gt; getColumnClass(int columnIndex)： 获取列中所有数据</li><li>isCellEditable(int rowIndex, int columnIndex)：单元格是否可编辑</li><li>Object getValueAt(int rowIndex, int columnIndex)： 获取单元格</li><li>setValueAt(Object aValue, int rowIndex, int columnIndex)： 获取单元格值</li></ul><p>监听器：</p><ul><li>tableModel.addTableModelListener(TableModelListener l)： 添加表格模型监听，表格的数据维护，对数据的监听。</li><li>tableModel.removeTableModelListener(TableModelListener l)：去除表格模型监听</li></ul><h1 id="ListSelectionModel-表格选择器"><a href="#ListSelectionModel-表格选择器" class="headerlink" title="ListSelectionModel 表格选择器"></a>ListSelectionModel 表格选择器</h1><p>它可以让用户以不同模式选中表格。</p><ul><li>table.setCellSelectionEnabled(boolean cellSelectionEnabled)：设置表格可以被选择</li><li>table.getSelectionModel()： 获得选择器</li><li>selectionModel.setSelectionMode(int selectionMode)：设置选择模式<ul><li>ListSelectionModel.MULTIPLE_INTERVAL_SELECTION 一次选择一个或多个连续的索引范围（默认）</li><li>ListSelectionModel.SINGLE_INTERVAL_SELECTION 一次选择一个连续的索引范围</li><li>ListSelectionModel.SINGLE_SELECTION 一次只能选择一个列表索引</li></ul></li></ul><p>监听器：</p><p>addListSelectionListener： 在选中状态改变时调用</p><h1 id="TableCellRenderer-单元格的渲染器"><a href="#TableCellRenderer-单元格的渲染器" class="headerlink" title="TableCellRenderer 单元格的渲染器"></a>TableCellRenderer 单元格的渲染器</h1><p>可以自己创建一个表格渲染器。然后TableColumn有setCellRenderer(renderer)。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="keyword">class</span> MyTableCellRenderer extends DefaultTableCellRenderer &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回默认的表单元格渲染器，此方法在父类中已实现，直接调用父类方法返回，在返回前做相关参数的设置即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        @Override</span><br><span class="line">        public Component get<span class="constructor">TableCellRendererComponent(JTable <span class="params">table</span>, Object <span class="params">value</span>, <span class="params">boolean</span> <span class="params">isSelected</span>, <span class="params">boolean</span> <span class="params">hasFocus</span>, <span class="params">int</span> <span class="params">row</span>, <span class="params">int</span> <span class="params">column</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数行背景设置为白色，奇数行背景设置为灰色</span></span><br><span class="line">            <span class="keyword">if</span> (row % <span class="number">2</span><span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                set<span class="constructor">Background(Color.WHITE)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set<span class="constructor">Background(Color.LIGHT_GRAY)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一列的内容水平居中对齐，最后一列的内容水平右对齐，其他列的内容水平左对齐</span></span><br><span class="line">            <span class="keyword">if</span> (column<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                set<span class="constructor">HorizontalAlignment(SwingConstants.CENTER)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (column<span class="operator"> == </span>(table.get<span class="constructor">ColumnCount()</span> - <span class="number">1</span>)) &#123;</span><br><span class="line">                set<span class="constructor">HorizontalAlignment(SwingConstants.RIGHT)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set<span class="constructor">HorizontalAlignment(SwingConstants.LEFT)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置提示文本，当鼠标移动到当前(row, column)所在单元格时显示的提示文本</span></span><br><span class="line">            set<span class="constructor">ToolTipText(<span class="string">"提示的内容: "</span> + <span class="params">row</span> + <span class="string">", "</span> + <span class="params">column</span>)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PS: 多个单元格使用同一渲染器时，需要自定义的属性，必须每次都设置，否则将自动沿用上一次的设置。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 单元格渲染器为表格单元格提供具体的显示，实现了单元格渲染器的 DefaultTableCellRenderer 继承自</span></span><br><span class="line"><span class="comment">             * 一个标准的组件类 JLabel，因此 JLabel 中相应的 API 在该渲染器实现类中都可以使用。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * super.getTableCellRendererComponent(...) 返回的实际上是当前对象（this），即 JLabel 实例，</span></span><br><span class="line"><span class="comment">             * 也就是以 JLabel 的形式显示单元格。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果需要自定义单元格的显示形式（比如显示成按钮、复选框、内嵌表格等），可以在此自己创建一个标准组件</span></span><br><span class="line"><span class="comment">             * 实例返回。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用父类的该方法完成渲染器的其他设置</span></span><br><span class="line">            return super.get<span class="constructor">TableCellRendererComponent(<span class="params">table</span>, <span class="params">value</span>, <span class="params">isSelected</span>, <span class="params">hasFocus</span>, <span class="params">row</span>, <span class="params">column</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h1 id="TableCellEditor-数据编辑器"><a href="#TableCellEditor-数据编辑器" class="headerlink" title="TableCellEditor 数据编辑器"></a>TableCellEditor 数据编辑器</h1><p>数据编辑器可以在表格中加入textfield，JComboBox等组件。实际一般使用默认的实现类DefaultCellEditor</p><p>tableColumn.setCellEditor(cellEditor)设置表格编辑器</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASPECTJ"><figure class="iseeu highlight /aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCellEditor</span> <span class="keyword">extends</span> <span class="title">DefaultCellEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCellEditor</span><span class="params">(JTextField textField)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(textField);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCellEditor</span><span class="params">(JCheckBox checkBox)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(checkBox);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCellEditor</span><span class="params">(JComboBox comboBox)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(comboBox);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">stopCellEditing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 获取当前单元格的编辑器组件</span></span><br><span class="line">            Component comp = getComponent();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前单元格编辑器输入的值</span></span><br><span class="line">            Object obj = getCellEditorValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前单元格编辑器输入的值不是数字，则返回 false（表示数据非法，不允许设置，无法保存）</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span> || !obj.toString().matches(<span class="string">"[0-9]*"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 数据非法时，设置编辑器组件内的内容颜色为红色</span></span><br><span class="line">                comp.setForeground(Color.RED);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据合法时，设置编辑器组件内的内容颜色为黑色</span></span><br><span class="line">            comp.setForeground(Color.BLACK);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合法数据交给父类处理</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">stopCellEditing</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h1 id="RowSorter-排序器"><a href="#RowSorter-排序器" class="headerlink" title="RowSorter 排序器"></a>RowSorter 排序器</h1><p>创建： <code>RowSorter&lt;TableModel&gt; rowSorter = new TableRowSorter&lt;TableModel&gt;(tableModel)</code></p><p>TableRowSroter是RowSorter的实现类。</p><p>使用 <code>table.setRowSorter(rowSorter)</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jun 10 2020 09:08:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xietansheng/article/details/78079806&quot; target
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>swing面板和其他组件</title>
    <link href="http://xinhecuican.github.io/post/ae8362df.html"/>
    <id>http://xinhecuican.github.io/post/ae8362df.html</id>
    <published>2020-06-06T07:05:00.000Z</published>
    <updated>2020-06-11T02:51:22.887Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jun 11 2020 10:51:23 GMT+0800 (中国标准时间) --><p><a href="https://blog.csdn.net/xietansheng/article/details/72814492" target="_blank" rel="external nofollow noopener noreferrer">学习自</a></p><h1 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h1><h2 id="JPanel"><a href="#JPanel" class="headerlink" title="JPanel"></a>JPanel</h2><p>可以在大布局里设计另一种布局</p><h2 id="JScrollPane-滚动面板"><a href="#JScrollPane-滚动面板" class="headerlink" title="JScrollPane 滚动面板"></a>JScrollPane 滚动面板</h2><p>它可以显示在文本较多的时候显示水平或垂直滚动条。如JTextArea或JTextField（水平滚动）或JList等可以使用滚动面板</p><p>JScrollPane内有一个ViewPort（视口），表示JScrollPane的显示区域，视口内包含一个需要滚动的组件。</p><p>构造方法：</p><ul><li>JScrollPane(Component view, int vsbPolicy, int hsbPolicy): view是需要加入视口的组件，vsb和hsb是水平和垂直滚动策略。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">策略取值</span><br><span class="line">ScrollPaneConstants<span class="selector-class">.VERTICAL_SCROLLBAR_AS_NEEDED</span>    <span class="comment">// 需要时显示（默认）</span></span><br><span class="line">ScrollPaneConstants<span class="selector-class">.VERTICAL_SCROLLBAR_NEVER</span>        <span class="comment">// 从不显示</span></span><br><span class="line">ScrollPaneConstants<span class="selector-class">.VERTICAL_SCROLLBAR_ALWAYS</span>       <span class="comment">// 总是显示</span></span><br><span class="line">水平就是把VERTICAL改成HORIZONAL</span><br></pre></td></tr></table></figure></div><p>方法：</p><ul><li>setViewportView(Component view)： 设置滚动条内组件(最好不要用add，容易出问题)</li><li>setVerticalScrollBarPolicy(int policy)： 垂直滚动条显示策略</li><li>setHorizontalScrollBarPolicy(int policy)： 水平滚动条显示策略</li><li>setWheelScrollingEnabled(boolean handleWheel)：是否响应鼠标，默认响应</li></ul><h2 id="JSplitPane-分隔面板"><a href="#JSplitPane-分隔面板" class="headerlink" title="JSplitPane 分隔面板"></a>JSplitPane 分隔面板</h2><p>分隔面板可以分隔两个组件。组件位置可以是上下或者左右。并且两个组件的分割线可以拉伸。</p><p>构造方法：</p><ul><li>JSplitPane(int orientation, boolean continuousLayout, Component leftComponent, Component rightComponent)： orientation是分割方向，可以取JSplitPane.HORIZONTAL_SPLIT或JSplitPane.VERTICAL_SPLIT。continuousLayout是拖动分割线时是否重绘组件。如果是false，那么拖动完了才会重绘。后面两个参数时两个组件</li></ul><p>方法：</p><ul><li>setOrientation(int orientation)：设置分割方向</li><li>setLeftComponent(Component comp)：设置左边/上面组件</li><li>setRightComponent(Component comp)</li><li>setContinuousLayout(boolean continuousLayout)</li><li>setOneTouchExpandable(boolean newValue)： 分隔条上快速折叠/展开组件小按钮</li><li>setDividerSize(int newSize)： 分隔条宽度</li><li>setDividerLocation(int location)：分隔条位置，相对于左边/上面的像素值</li><li>setDividerLocation(double proportionalLocation)： 这个是在0到1间取值，也是位置。</li></ul><h2 id="JTabbedPane-选项卡面板"><a href="#JTabbedPane-选项卡面板" class="headerlink" title="JTabbedPane 选项卡面板"></a>JTabbedPane 选项卡面板</h2><p>可以通过点击在组件之间进行切换。</p><p>构造方法：</p><ul><li>JTabbedPane(int tabPlacement, int tabLayoutPolicy)： 选项卡标题的位置, 值为 JTabbedPane.TOP、JTabbedPane.BOTTOM、JTabbedPane.LEFT 或 JTabbedPane.RIGHT, 默认为 TOP。tabLayoutPolicy是选项放不下时放置选项策略。有JTabbedPane.WRAP_TAB_LAYOUT 或 JTabbedPane.SCROLL_TAB_LAYOUT。</li></ul><p>方法：</p><ul><li>void addTab(String title, Icon icon, Component component, String tip)：添加选项，tip是焦点在选项卡时显示的文本。</li><li>insertTab(String title, Icon icon, Component component, String tip, int index)： 指定位置插入选项卡</li><li>removeTabAt(int index)：移除选项卡</li><li>remove(int index)</li><li>remove(Component component)</li><li>removeAll()</li><li>setSelectedIndex(int index)： 设置选中的选项卡</li><li>getSelectedIndex()： 获得选中的选项卡索引</li><li>Component getSelectedComponent()： 获得选项卡组件</li><li>setTitleAt(int index, String title)： 设置选项卡标题</li><li>setIconAt(int index, Icon icon)： 设置选项卡图标</li><li>setEnabledAt(int index, boolean enabled)： 设置选项是否可用</li><li>setComponentAt(int index, Component component)：设置组件</li><li>getTabCount()： 获得选项卡数量</li><li>setTabComponentAt(int index, Component titleComponent)：把一个组件放到标题位置（其他是标题位置就是标题，组件在下面）</li></ul><p>监听器： <code>addChangeListener(ChangeListener l)</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        JTabbedPane tabbedPane = <span class="keyword">new</span> <span class="constructor">JTabbedPane()</span>;</span><br><span class="line">        JTextArea textArea = <span class="keyword">new</span> <span class="constructor">JTextArea(20, 20)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectionColor(Color.RED)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectedTextColor(Color.YELLOW)</span>;</span><br><span class="line">        textArea.set<span class="constructor">CaretColor(Color.BLUE)</span>;</span><br><span class="line">        textArea.set<span class="constructor">LineWrap(<span class="params">true</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Font(<span class="params">new</span> Font(<span class="params">null</span>, Font.PLAIN, 20)</span>);</span><br><span class="line">        textArea.set<span class="constructor">WrapStyleWord(<span class="params">true</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        tabbedPane.add<span class="constructor">Tab(<span class="string">"text"</span>, <span class="params">textArea</span>)</span>;</span><br><span class="line">        tabbedPane.add<span class="constructor">Tab(<span class="string">"try"</span>, <span class="params">new</span> JButton(<span class="string">"ha"</span>)</span>);</span><br><span class="line">        tabbedPane.add<span class="constructor">Tab(<span class="string">"picture"</span>, <span class="params">new</span> ImageIcon(<span class="string">"F:\\hexo\\wodeboke\\source\\images\\pasted-0.png"</span>)</span>, <span class="keyword">new</span> <span class="constructor">JPasswordField(10)</span>);</span><br><span class="line">        add(tabbedPane);</span><br><span class="line"></span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">        set<span class="constructor">Size(100, 200)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">"Hello"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E9%9D%A2%E6%9D%BF1.PNG" alt></p><h2 id="JLayerPane-层级面板"><a href="#JLayerPane-层级面板" class="headerlink" title="JLayerPane 层级面板"></a>JLayerPane 层级面板</h2><p>层级面板允许组件重叠出现，并且把组件分成若干层。层取值-1到n-1</p><p>每一层组件位置可以设置编号，编号决定前后。层之间编号越大在前面，层中编号越大越接近底部。</p><p>加入层的组件必须要设置位置和大小（width和height），否则不予显示</p><p>构造方法：</p><ul><li>JLayerPane()</li></ul><p>方法：</p><ul><li>add(Component comp, Object layer, int position):因为layer是object，说明不能直接用整型，而是要用Integer类。</li><li>add(Component comp, Object layer)</li><li>setLayer(Component c, int layer, int position)</li><li>setLayer(Component c, int layer)</li><li>moveToFront(Component c): 把组件移到最顶端的位置</li><li>moveToBack(Component c)</li><li>setPosition(Component c, int position)：设置组件所在层</li></ul><h1 id="JDialog和JOptionPane"><a href="#JDialog和JOptionPane" class="headerlink" title="JDialog和JOptionPane"></a>JDialog和JOptionPane</h1><p>JOpintionPane是已经实现好的JDialog，以静态方法的形式提供调用。</p><p>JOpintionPane提供的调用：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>showMessageDialog</td><td>消息对话框，向用户展示一个消息，没有返回值。</td></tr><tr><td>showConfirmDialog</td><td>确认对话框，询问一个问题是否执行。</td></tr><tr><td>showInputDialog</td><td>输入对话框，要求用户提供某些输入。</td></tr><tr><td>showOptionDialog</td><td>选项对话框，上述三项的大统一，自定义按钮文本，询问用户需要点击哪个按钮。</td></tr></tbody></table><p>静态方法中的参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">(1)</span> <span class="attr">parentComponent:</span> <span class="string">对话框的父级组件，决定对话框显示的位置，对话框的显示会尽量紧靠组件的中心，如果传</span> <span class="literal">null</span><span class="string">，则显示在屏幕的中心。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(2)</span> <span class="attr">title:</span> <span class="string">对话框标题。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(3)</span> <span class="attr">message:</span> <span class="string">消息内容。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(4)</span> <span class="attr">messageType:</span> <span class="string">消息类型，主要是提供默认的对话框图标。可能的值为：</span></span><br><span class="line"></span><br><span class="line"><span class="string">JOptionPane.PLAIN_MESSAGE</span> <span class="string">简单消息（不使用图标）</span></span><br><span class="line"><span class="string">JOptionPane.INFORMATION_MESSAGE</span> <span class="string">信息消息（默认）</span></span><br><span class="line"><span class="string">JOptionPane.QUESTION_MESSAGE</span> <span class="string">问题消息</span></span><br><span class="line"><span class="string">JOptionPane.WARNING_MESSAGE</span> <span class="string">警告消息</span></span><br><span class="line"><span class="string">JOptionPane.ERROR_MESSAGE</span> <span class="string">错误消息</span></span><br><span class="line"><span class="string">(5)</span> <span class="attr">icon:</span> <span class="string">自定义的对话框图标，如果传</span> <span class="literal">null</span><span class="string">，则图标类型由</span> <span class="string">messageType</span> <span class="string">决定。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(6)</span> <span class="attr">optionType:</span> <span class="string">选项按钮的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(7)</span> <span class="string">options、initialValue:</span> <span class="string">自定义的选项按钮（如果穿</span> <span class="literal">null</span><span class="string">，则选项按钮由</span> <span class="string">optionType</span> <span class="string">决定），以及默认选中的选项按钮。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(8)</span> <span class="string">selectionValues、initialSelectionValue:</span> <span class="string">提供的输入选项，以及默认选中的选项。</span></span><br></pre></td></tr></table></figure></div><p>但是不是每种选项都拥有所有参数,下面是每个方法最多的选项</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> showMessageDialog(Component parentComponent, </span><br><span class="line">                              <span class="built_in">Object</span> message, </span><br><span class="line">                              <span class="built_in">String</span> title, </span><br><span class="line">                              <span class="built_in">int</span> messageType, </span><br><span class="line">                              Icon icon)</span><br><span class="line">                              </span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> showConfirmDialog(Component parentComponent, </span><br><span class="line">                             <span class="built_in">Object</span> message, </span><br><span class="line">                             <span class="built_in">String</span> title, </span><br><span class="line">                             <span class="built_in">int</span> optionType, </span><br><span class="line">                             <span class="built_in">int</span> messageType, </span><br><span class="line">                             Icon icon)</span><br><span class="line">                             </span><br><span class="line"><span class="keyword">static</span> <span class="built_in">Object</span> showInputDialog(Component parentComponent, </span><br><span class="line">                              <span class="built_in">Object</span> message, </span><br><span class="line">                              <span class="built_in">String</span> title, </span><br><span class="line">                              <span class="built_in">int</span> messageType, </span><br><span class="line">                              Icon icon, </span><br><span class="line">                              <span class="built_in">Object</span>[] selectionValues, </span><br><span class="line">                              <span class="built_in">Object</span> initialSelectionValue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> showOptionDialog(Component parentComponent, </span><br><span class="line">                            <span class="built_in">Object</span> message, </span><br><span class="line">                            <span class="built_in">String</span> title, </span><br><span class="line">                            <span class="built_in">int</span> optionType, </span><br><span class="line">                            <span class="built_in">int</span> messageType, </span><br><span class="line">                            Icon icon, </span><br><span class="line">                            <span class="built_in">Object</span>[] options, </span><br><span class="line">                            <span class="built_in">Object</span> initialValue)</span><br></pre></td></tr></table></figure></div><p>其中showconfirmDialog的messageType参数可以是JOptionPane.YES_OPTION（是）或JOptionPane.NO_OPTION（否）或JOptionPane.CANCEL_OPTION（取消）或JOptionPane.CLOSED_OPTION（关闭）。也可以是JOptionPane.YES_NO_CANCEL_OPTION;等组合选项。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">public</span> Calculate(String <span class="type">name</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        super(<span class="type">name</span>);</span><br><span class="line">        JButton Button2 = <span class="built_in">new</span> JButton("show message");</span><br><span class="line">        Button2.addActionListener(<span class="built_in">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                showMessageDialog(<span class="keyword">null</span>, "message", "Hello", QUESTION_MESSAGE, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        JButton button = <span class="built_in">new</span> JButton("show input");</span><br><span class="line">        button.addActionListener(<span class="built_in">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                String[] <span class="keyword">select</span> = <span class="built_in">new</span> String[]&#123;"水果", "食物"&#125;;</span><br><span class="line">                <span class="keyword">Object</span> input = showInputDialog(</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        "input something",</span><br><span class="line">                        "Hello",</span><br><span class="line">                        WARNING_MESSAGE</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">input</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        JButton button1 = <span class="built_in">new</span> JButton("total");</span><br><span class="line">        button1.addActionListener(<span class="built_in">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                String[] <span class="keyword">select</span> = <span class="built_in">new</span> String[]&#123;"水果", "食物"&#125;;</span><br><span class="line">                <span class="type">int</span> o = showOptionDialog(</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        "please select one",</span><br><span class="line">                        "Hello",</span><br><span class="line">                        YES_NO_CANCEL_OPTION,</span><br><span class="line">                        PLAIN_MESSAGE,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">select</span>,</span><br><span class="line">                        <span class="keyword">select</span>[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">select</span>[o]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Box</span> vBox = <span class="type">Box</span>.createVerticalBox();</span><br><span class="line">        vBox.<span class="keyword">add</span>(button);</span><br><span class="line">        vBox.<span class="keyword">add</span>(Button2);</span><br><span class="line">        vBox.<span class="keyword">add</span>(button1);</span><br><span class="line">        <span class="keyword">add</span>(vBox);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">        pack();</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">new</span> Calculate("Hello");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E9%9D%A2%E6%9D%BF2.PNG" alt><br><img src="/images/swing%E9%9D%A2%E6%9D%BF3.PNG" alt><br><img src="/images/swing%E9%9D%A2%E6%9D%BF4.PNG" alt></p><p>注意：showOptionDialog如果后面没有Object[]，那么下面的选项是YES_NO_CANCEL_OPTION。并且它的返回值是一个int型，如果点了叉那么返回值是-1.</p><p>showInputDialog返回值是输入的信息，</p><h1 id="JFileChooser-文件选择器"><a href="#JFileChooser-文件选择器" class="headerlink" title="JFileChooser 文件选择器"></a>JFileChooser 文件选择器</h1><p>可以用来打开和保存文件。</p><p>构造方法：</p><ul><li>JFileChooser(File currentDirectory)：打开文件时默认显示的文件夹。可以使用绝对目录</li></ul><p>方法：</p><ul><li>setCurrentDirectory(File dir)： 设置当前文件夹</li><li>setFileSelectionMode(int mode)：有三种模式。JFileChooser.FILES_ONLY: 只能选文件 或 JFileChooser.DIRECTORIES_ONLY: 只能选文件夹 或 JFileChooser.FILES_AND_DIRECTORIES: 文件和文件夹都可以选。</li><li>setMultiSelectionEnabled(boolean b)：是否可以选多个（默认不允许）</li><li>addChoosableFileFilter(FileFilter filter)： 添加文件类型选择。例如<code>fileChooser.setFileFilter(new FileNameExtensionFilter(&quot;image(*.jpg, *.png, *.gif)&quot;, &quot;jpg&quot;, &quot;png&quot;, &quot;gif&quot;));</code>前面是描述，后面是选择类型。</li><li>setFileFilter(FileFilter filter)： 设置默认使用的过滤器</li><li>setSelectedFile(File file)： 设置默认被选中的文件</li><li>setSelectedFiles(File[] selectedFiles)</li><li>showOpenDialog(Component parent)： 打开对话框（线程会被阻塞），parent是父组件，设置会让对话框显示在父组件中心，如果是null显示在屏幕中心。返回值有JFileChooser.CANCEL_OPTION: 点击了取消或关闭 或 JFileChooser.APPROVE_OPTION: 点击了确认或保存 或 JFileChooser.ERROR_OPTION: 出现错误</li><li>File getSelectedFile()： 获得选择的文件</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> File files;</span><br><span class="line">    <span class="keyword">private</span> FileReader fileReader;</span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">name</span>)</span> throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        JFileChooser fileChooser = <span class="keyword">new</span> <span class="constructor">JFileChooser(<span class="string">"F:\\系统设置\\Desktop\\我的文档"</span>)</span>;</span><br><span class="line">        fileChooser.add<span class="constructor">ChoosableFileFilter(<span class="params">new</span> FileNameExtensionFilter(<span class="string">"*.zip"</span>,<span class="string">"zip"</span>)</span>);</span><br><span class="line">        fileChooser.add<span class="constructor">ChoosableFileFilter(<span class="params">new</span> FileNameExtensionFilter(<span class="string">"*.txt"</span>, <span class="string">"txt"</span>)</span>);</span><br><span class="line">        fileChooser.set<span class="constructor">FileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES)</span>;</span><br><span class="line">        fileChooser.set<span class="constructor">MultiSelectionEnabled(<span class="params">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">        JButton button = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">"open to copy"</span>)</span>;</span><br><span class="line">        JTextArea textArea = <span class="keyword">new</span> <span class="constructor">JTextArea( 40, 40)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectedTextColor(Color.YELLOW)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectionColor(Color.RED)</span>;</span><br><span class="line">        textArea.set<span class="constructor">CaretColor(Color.BLUE)</span>;</span><br><span class="line">        textArea.set<span class="constructor">WrapStyleWord(<span class="params">false</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Font(<span class="params">new</span> Font(<span class="params">null</span>, Font.PLAIN, 20)</span>);</span><br><span class="line">        textArea.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        JTextField textField = <span class="keyword">new</span> <span class="constructor">JTextField(<span class="string">"The content of the file will show here"</span>)</span>;</span><br><span class="line">        textField.set<span class="constructor">Editable(<span class="params">false</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Foreground(Color.RED)</span>;</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="constructor">JPanel()</span>;</span><br><span class="line">        panel.set<span class="constructor">Layout(<span class="params">new</span> BorderLayout()</span>);</span><br><span class="line">        JPanel panel1 = <span class="keyword">new</span> <span class="constructor">JPanel()</span>;</span><br><span class="line">        panel1.set<span class="constructor">Layout(<span class="params">new</span> BorderLayout()</span>);</span><br><span class="line">        panel1.add(button, BorderLayout.NORTH);</span><br><span class="line">        panel1.add(textField, BorderLayout.CENTER);</span><br><span class="line">        panel.add(panel1, BorderLayout.NORTH);</span><br><span class="line">        panel.add(textArea, BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line">        button.add<span class="constructor">ActionListener(<span class="params">new</span> ActionListener()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fileChooser.show<span class="constructor">OpenDialog(<span class="params">panel</span>)</span><span class="operator"> == </span>JFileChooser.APPROVE_OPTION)</span><br><span class="line">                &#123;</span><br><span class="line">                    files = fileChooser.get<span class="constructor">SelectedFile()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(fileChooser.show<span class="constructor">OpenDialog(<span class="params">panel</span>)</span><span class="operator"> == </span>JFileChooser.ERROR_OPTION)</span><br><span class="line">                &#123;</span><br><span class="line">                    show<span class="constructor">MessageDialog(<span class="params">fileChooser</span>, <span class="string">"something wrong"</span>, <span class="string">"hello"</span>, ERROR_MESSAGE, <span class="params">null</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fileReader = <span class="keyword">new</span> <span class="constructor">FileReader(<span class="params">files</span>)</span>;</span><br><span class="line">                    <span class="built_in">int</span> c;</span><br><span class="line">                    <span class="keyword">while</span>((c=fileReader.read<span class="literal">()</span>) != -<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        textArea.append(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of((<span class="params">char</span>)</span> c));</span><br><span class="line">                    &#125;</span><br><span class="line">                    fileReader.close<span class="literal">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        add(panel);</span><br><span class="line"></span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">        pack<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">"hello"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E5%9B%BE%E5%BD%A25.PNG" alt></p><p>如果想使用系统的ui可以用java.awt.FileDialog</p><h1 id="JColorChooser-颜色选择器"><a href="#JColorChooser-颜色选择器" class="headerlink" title="JColorChooser 颜色选择器"></a>JColorChooser 颜色选择器</h1><p>提供一个让用户选择颜色的对话框。</p><p>构造方法：</p><ul><li>public static Color showDialog(Component component, String title, Color initialColor)： 这是JColorChooser的静态方法。Component是父组件，title标题。</li></ul><h1 id="JMenuBar-菜单"><a href="#JMenuBar-菜单" class="headerlink" title="JMenuBar 菜单"></a>JMenuBar 菜单</h1><p>把菜单添加到JFrame后，会在顶部出现。菜单有三种：</p><ul><li>JMenu： 菜单栏上的菜单</li><li>JMenuBar： 菜单栏</li><li>JMenuItem, JCheckBoxMenuItem, JRadioButtonMenuItem： 子菜单，表示子菜单\带复选框的子菜单\带单选按钮的子菜单。</li></ul><p>JMenu、JCheckBoxMenuItem、JRadioButtonMenuItem 均继承自 JMenuItem。</p><p>JMenuItem的构造方法：</p><ul><li>JMenuItem(String title, Icon icon)： icon是菜单显示的图标</li></ul><p>把JMenuBar添加到JFrame是用setJmenuBar()方法</p><p>JMenuItem常用方法：</p><ul><li>setIcon(Icon defaultIcon)</li><li>setText(String text)</li><li>setMnemonic(int mnemonic): 设置快捷键助记符。也就是在标题后面会加一个下划线或其他标识然后再加上这个字母。它是用来提示你按下那个键触发快捷键的。例如： menuItem.setMnemonic(KeyEvent.VK_N);</li><li>setAccelerator(KeyStroke keyStroke)： 设置快捷键。例如：menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N, ActionEvent.ALT_MASK));</li><li>setActionCommand(String actionCommand)：设置菜单项的Action名称。如果多个菜单项使用同一个监听器就可以用这个方法设置名字用来辨别到底是哪一个触发了。</li></ul><p>监听器： addActionListener(ActionListener l)</p><p>JCheckBoxMenuItem、JRadioButtonMenuItem 常用方法:：</p><p>其实就是JCheckBoxButton类似的方法.它的监听器是addChangeListener(ChangeListener l)</p><p>JMenu常用方法：</p><ul><li>JMenuItem add(JMenuItem menuItem)： 添加一个子菜单到JMenu中</li><li>addSeparator()： 添加一个子菜单分界线</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Menu(<span class="keyword">String</span> name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JMenuBar menuBar = <span class="keyword">new</span> <span class="type">JMenuBar</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一级菜单</span></span><br><span class="line">        JMenu menu_File = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">"file"</span>);</span><br><span class="line">        JMenu menu_Edit = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">"edit"</span>);</span><br><span class="line">        JMenu menu_about = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">"about"</span>);</span><br><span class="line">        <span class="comment">//menu_File.setMnemonic(KeyEvent.VK_N);</span></span><br><span class="line">        <span class="comment">//menu_File.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N, ActionEvent.ALT_MASK));</span></span><br><span class="line">        menuBar.add(menu_about);</span><br><span class="line">        menuBar.add(menu_Edit);</span><br><span class="line">        menuBar.add(menu_File);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//file子菜单</span></span><br><span class="line">        JMenuItem File_open = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"open"</span>);</span><br><span class="line">        JMenuItem file_save = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"save"</span>);</span><br><span class="line">        JMenuItem file_new <span class="type"></span>= <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"new"</span>);</span><br><span class="line">        JMenuItem file_close = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"close"</span>);</span><br><span class="line">        menu_File.add(file_new<span class="type"></span>);</span><br><span class="line">        menu_File.add(file_save);</span><br><span class="line">        menu_File.add(File_open);</span><br><span class="line">        menu_File.addSeparator();</span><br><span class="line">        menu_File.add(file_close);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//edit子菜单</span></span><br><span class="line">        JMenuItem edit_paste = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"paste"</span>);</span><br><span class="line">        JMenuItem edit_cut= <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"cut"</span>);</span><br><span class="line">        JMenuItem edit_copy = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"copy"</span>);</span><br><span class="line">        menu_Edit.add(edit_copy);</span><br><span class="line">        menu_about.add(edit_cut);</span><br><span class="line">        menu_about.add(edit_paste);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//about子菜单</span></span><br><span class="line">        JMenuItem about_author = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"author"</span>);</span><br><span class="line">        JMenu menu_about_conference = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">"conference"</span>);</span><br><span class="line">        menu_about.add(about_author);</span><br><span class="line">        menu_about.add(menu_about_conference);</span><br><span class="line"></span><br><span class="line">        JMenuItem conference_link1 = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"first"</span>);</span><br><span class="line">        JMenuItem conference_link2 = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"second"</span>);</span><br><span class="line">        menu_about_conference.add(conference_link1);</span><br><span class="line">        menu_about_conference.add(conference_link2);</span><br><span class="line">        setJMenuBar(menuBar);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Menu</span>(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E9%9D%A2%E6%9D%BF7.PNG" alt></p><h1 id="JToolBar-工具栏"><a href="#JToolBar-工具栏" class="headerlink" title="JToolBar 工具栏"></a>JToolBar 工具栏</h1><p>工具栏显示了一些常用组件。它支持拖动，为了确保可以拖动，可以把它加入到BorderLayout的任意一边，并且不要再其他四边中加入子级</p><p>构造方法：</p><ul><li>JToolBar(String name, int orientation)： orientation是工具栏方向，可以取SwingConstants.HORIZONTAL或SwingConstants.VERTICAL，默认水平</li></ul><p>方法：</p><ul><li>Component add(Component comp)：添加组件到工具栏</li><li>addSeparator()：添加分割线</li><li>addSeparator(Dimension size)</li><li>Component getComponentAtIndex(int index)：获取指定位置组件（包括分隔符）</li><li>setFloatable(boolean b)：工具栏是否可以拖动</li><li>setOrientation(int o)</li><li>setMargin(Insets m)： 设置内边距</li><li>setBorderPainted(boolean b)： 是否绘制边框</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">tool</span> <span class="title">extends</span> <span class="title">JFrame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">tool</span>(<span class="params">String name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line"></span><br><span class="line">        JToolBar toolBar = <span class="keyword">new</span> JToolBar();</span><br><span class="line">        toolBar.setFloatable(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">add</span>(toolBar, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">        JButton button_next_music = <span class="keyword">new</span> JButton(<span class="string">"next"</span>, <span class="keyword">new</span> ImageIcon(<span class="string">"D:\\截图\\next.png"</span>));</span><br><span class="line">        JButton button_pause_music = <span class="keyword">new</span> JButton(<span class="string">"pause"</span>, <span class="keyword">new</span> ImageIcon(<span class="string">"D:\\截图\\pause.png"</span>));</span><br><span class="line">        JButton button_previous_music = <span class="keyword">new</span> JButton(<span class="string">"previous"</span>, <span class="keyword">new</span> ImageIcon(<span class="string">"D:\\截图\\previous.png"</span>));</span><br><span class="line">        toolBar.<span class="keyword">add</span>(button_previous_music);</span><br><span class="line">        toolBar.addSeparator();</span><br><span class="line">        toolBar.<span class="keyword">add</span>(button_pause_music);</span><br><span class="line">        toolBar.addSeparator();</span><br><span class="line">        toolBar.<span class="keyword">add</span>(button_next_music);</span><br><span class="line">        button_next_music.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span>(<span class="params">ActionEvent actionEvent</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"next music"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button_pause_music.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span>(<span class="params">ActionEvent actionEvent</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"pause"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button_previous_music.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span>(<span class="params">ActionEvent actionEvent</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"previous music"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">new</span> tool(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E9%9D%A2%E6%9D%BF8.PNG" alt>把它拖到左上角又可以固定。</p><h1 id="JPopupMenu-右键菜单"><a href="#JPopupMenu-右键菜单" class="headerlink" title="JPopupMenu 右键菜单"></a>JPopupMenu 右键菜单</h1><p>这个挺熟悉的，又叫弹出式菜单。它的使用和JToolBar类似。</p><h1 id="JInternalFrame-内部窗口"><a href="#JInternalFrame-内部窗口" class="headerlink" title="JInternalFrame 内部窗口"></a>JInternalFrame 内部窗口</h1><p>内部窗口是在JFrame内部显示一个完整的子窗口。</p><p>在实际使用中，通常将 JInternalFrame 添加到 JDesktopPane 中，由其来维护和显示 JInternalFrame。</p><p>方法等和JFrame类似</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JInternalFrame createInternalFrame() &#123;</span><br><span class="line">        <span class="comment">// 创建一个内部窗口</span></span><br><span class="line">        JInternalFrame internalFrame = <span class="keyword">new</span> <span class="type">JInternalFrame</span>(</span><br><span class="line">                <span class="string">"内部窗口"</span>,  <span class="comment">// title</span></span><br><span class="line">                <span class="literal">true</span>,       <span class="comment">// resizable</span></span><br><span class="line">                <span class="literal">true</span>,       <span class="comment">// closable</span></span><br><span class="line">                <span class="literal">true</span>,       <span class="comment">// maximizable</span></span><br><span class="line">                <span class="literal">true</span>        <span class="comment">// iconifiable</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置窗口的宽高</span></span><br><span class="line">        internalFrame.setSize(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 设置窗口的显示位置</span></span><br><span class="line">        internalFrame.setLocation(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 内部窗口的关闭按钮动作默认就是销毁窗口，所有不用设置</span></span><br><span class="line">        <span class="comment">// internalFrame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建内容面板</span></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="type">JPanel</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加组件到面板</span></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="type">JLabel</span>(<span class="string">"Label001"</span>));</span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="type">JButton</span>(<span class="string">"JButton001"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置内部窗口的内容面板</span></span><br><span class="line">        internalFrame.setContentPane(panel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 对于内部窗口，还可以不需要手动设置内容面板，直接把窗口当做普通面板使用，</span></span><br><span class="line"><span class="comment">         * 即直接设置布局，然后通过 add 添加组件，如下代码:</span></span><br><span class="line"><span class="comment">         *     internalFrame.setLayout(new FlowLayout());</span></span><br><span class="line"><span class="comment">         *     internalFrame.add(new JLabel("Label001"));</span></span><br><span class="line"><span class="comment">         *     internalFrame.add(new JButton("JButton001"));</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示内部窗口</span></span><br><span class="line">        internalFrame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> internalFrame;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h1 id="DeskTop"><a href="#DeskTop" class="headerlink" title="DeskTop"></a>DeskTop</h1><p>DeskTop可以让java程序启动本机上注册的程序。一般程序有</p><ul><li>打开浏览器</li><li>打开邮件</li><li>打开文件</li></ul><p>方法：</p><ul><li>static boolean isDesktopSupported()： 当前平台是否支持此类</li><li>static Desktop getDesktop()： 获得DeskTop实例</li><li>browse(URI uri)： 启用默认浏览器显示URI</li><li>open(File file)： 启用默认应用程序打开文件</li><li>edit(File file)： 启用默认编辑器编辑文件</li><li>print(File file)： 打印</li><li>mail()： 启用邮件管理</li><li>mail(URI mailtoURI)： 启用邮件管理并填充URI</li><li>isSupported(Desktop.Action action)： 查看当前平台是否支持上述操作。取值是DeskTop.Action.xxx xxx是上面操作的大写</li></ul><h1 id="系统剪切板"><a href="#系统剪切板" class="headerlink" title="系统剪切板"></a>系统剪切板</h1><p>获得系统剪切板：</p><p><code>Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();</code></p><p>使用：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><figcaption><span>class Main &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 把文本设置到剪贴板（复制）</span><br><span class="line">        setClipboardString(&quot;Hello System Clipboard!&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从剪贴板中获取文本（粘贴）</span><br><span class="line">        String text &#x3D; getClipboardString();</span><br><span class="line">        System.out.println(&quot;text: &quot; + text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 把文本设置到剪贴板（复制）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void setClipboardString(String text) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取系统剪贴板</span><br><span class="line">        Clipboard clipboard &#x3D; Toolkit.getDefaultToolkit().getSystemClipboard();</span><br><span class="line">        &#x2F;&#x2F; 封装文本内容</span><br><span class="line">        Transferable trans &#x3D; new StringSelection(text);</span><br><span class="line">        &#x2F;&#x2F; 把文本内容设置到系统剪贴板</span><br><span class="line">        clipboard.setContents(trans, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从剪贴板中获取文本（粘贴）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getClipboardString() &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取系统剪贴板</span><br><span class="line">        Clipboard clipboard &#x3D; Toolkit.getDefaultToolkit().getSystemClipboard();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取剪贴板中的内容</span><br><span class="line">        Transferable trans &#x3D; clipboard.getContents(null);</span><br><span class="line"></span><br><span class="line">        if (trans !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断剪贴板中的内容是否支持文本</span><br><span class="line">            if (trans.isDataFlavorSupported(DataFlavor.stringFlavor)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取剪贴板中的文本内容</span><br><span class="line">                    String text &#x3D; (String) trans.getTransferData(DataFlavor.stringFlavor);</span><br><span class="line">                    return text;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jun 11 2020 10:51:23 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xietansheng/article/details/72814492&quot; target
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Swing组件</title>
    <link href="http://xinhecuican.github.io/post/604b49d0.html"/>
    <id>http://xinhecuican.github.io/post/604b49d0.html</id>
    <published>2020-06-04T02:37:00.000Z</published>
    <updated>2020-07-08T09:09:34.235Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 09 2020 08:11:43 GMT+0800 (中国标准时间) --><h1 id="Border边框"><a href="#Border边框" class="headerlink" title="Border边框"></a>Border边框</h1><p>边框创建与设置</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Border border = <span class="module-access"><span class="module"><span class="identifier">BorderFactory</span>.</span></span>create<span class="constructor">XxxxBorder(<span class="operator">...</span>)</span>;</span><br><span class="line">jComponent.set<span class="constructor">Border(<span class="params">border</span>)</span>;<span class="comment">//设置边框</span></span><br></pre></td></tr></table></figure></div><p><strong>BorderFactory中的边框</strong></p><p>使用BorderFactory中的静态方法创建边框</p><ul><li><p>createEmptyBorder()： 空边框</p></li><li><p>createEmptyBorder(int top, int left, int bottom, int right)：</p></li><li><p>createLineBorder(Color color)： 线边框。color是线的颜色</p></li><li><p>createLineBorder(Color color, int thickness, boolean rounded)： thickness是线宽，rounded是是否有圆角</p></li><li><p>createTitledBorder(Border border, String title, int titleJustification, int titlePosition, Font titleFont, Color titleColor)：标题边框。border是要加标题的边框，title是标题内容。titleFont是标题字体，color是标题颜色。</p><ul><li>titleJustification有以下取值</li><li>TitledBorder.LEFT</li><li>TitledBorder.CENTER</li><li>TitledBorder.RIGHT</li><li>TitledBorder.LEADING</li><li>TitledBorder.TRAILING</li><li>TitledBorder.DEFAULT_JUSTIFICATION (leading)</li><li>titleposition是标题在边框位置。有以下取值</li><li>TitledBorder.ABOVE_TOP</li><li>TitledBorder.TOP（位于顶线上）</li><li>TitledBorder.BELOW_TOP</li><li>TitledBorder.ABOVE_BOTTOM</li><li>TitledBorder.BOTTOM（位于底线上）</li><li>TitledBorder.BELOW_BOTTOM</li><li>TitledBorder.DEFAULT_POSITION（顶部）</li></ul></li></ul><p>还有许多其他边框</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GAMS"><figure class="iseeu highlight /gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斜面边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createBevelBorder(...);</span><br><span class="line"><span class="comment">// 虚线边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createDashedBorder(...);</span><br><span class="line"><span class="comment">// “浮雕化”边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createEtchedBorder(...);</span><br><span class="line"><span class="comment">// 凹入斜面边缘的边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createLoweredBevelBorder(...);</span><br><span class="line"><span class="comment">// 具有凸出斜面边缘的边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createRaisedBevelBorder(...);</span><br><span class="line"><span class="comment">// 凸起软斜面</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createRaisedSoftBevelBorder(...);</span><br><span class="line"><span class="comment">// 合成边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> CompoundBorder createCompoundBorder(...);</span><br><span class="line"><span class="comment">// 类似衬边的边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> MatteBorder createMatteBorder(...);</span><br><span class="line"><span class="comment">// 共享斜面边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createSharedBevel(...)</span><br><span class="line"><span class="comment">// 软斜面边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createSoftBevelBorder(...);</span><br><span class="line"><span class="comment">// 画笔边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createStrokeBorder(...);</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E7%BB%84%E4%BB%B610.PNG" alt><br><a href="https://blog.csdn.net/xietansheng/article/details/78389211" target="_blank" rel="external nofollow noopener noreferrer">学习自</a></p><h1 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h1><p>所有的按钮都继承与AbstractButton。按钮有：普通按钮（JButton）、触发器按钮（JToggleButton）、复选框（JCheckBox）、单选按钮（JRadioButton）、箭头按钮（BasicArrowButton）和菜单项（JMenuItem）等。</p><p>方法：</p><ul><li>void setEnabled(boolean enable)： 设置这个按钮是否可用</li><li>setRolloverEnabled(boolean enable): 设置是否要产生翻转</li><li>setContentAreaFilled(): 是否要绘制父类内容。设置这个是让按钮周围不会有界限。</li><li>setFocusPainted(): 时候绘制焦点</li><li>setBorderPainted(): 是否绘制边框</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    JButton button;</span><br><span class="line">    JToggleButton togglebutton;</span><br><span class="line">    JCheckBox checkbox;</span><br><span class="line">    JRadioButton radiobutton;</span><br><span class="line">    BasicArrowButton arrowbutton;</span><br><span class="line">    JMenuItem menuitem;</span><br><span class="line">    <span class="keyword">public</span> Calculate(<span class="keyword">String</span> title)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">        setLayout(<span class="keyword">new</span> <span class="type">FlowLayout</span>());</span><br><span class="line">        button = <span class="keyword">new</span> <span class="type">JButton</span>(<span class="string">"button"</span>);</span><br><span class="line">        togglebutton = <span class="keyword">new</span> <span class="type">JToggleButton</span>(<span class="string">"togglebutton"</span>);</span><br><span class="line">        checkbox = <span class="keyword">new</span> <span class="type">JCheckBox</span>(<span class="string">"checkbox"</span>);</span><br><span class="line">        radiobutton = <span class="keyword">new</span> <span class="type">JRadioButton</span>(<span class="string">"radiobutton"</span>);</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="type">JPanel</span>();</span><br><span class="line">        panel.setBorder(<span class="keyword">new</span> <span class="type">TitledBorder</span>(<span class="string">"arrow"</span>));</span><br><span class="line">        arrowbutton = <span class="keyword">new</span> <span class="type">BasicArrowButton</span>(BasicArrowButton.NORTH);</span><br><span class="line">        panel.add(arrowbutton);</span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="type">BasicArrowButton</span>(BasicArrowButton.RIGHT));</span><br><span class="line">        menuitem = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"menuitem"</span>);</span><br><span class="line">        add(button);</span><br><span class="line">        add(togglebutton);</span><br><span class="line">        add(checkbox);</span><br><span class="line">        add(radiobutton);</span><br><span class="line">        add(panel);</span><br><span class="line">        add(menuitem);</span><br><span class="line">        pack();</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Calculate</span>(<span class="string">"Calculate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing.PNG" alt></p><p>注意togglebutton有两种状态，按下和弹出，普通按钮按下就会立刻弹出，但是toggle按下就变成按下状态，需要再按一下才会变成弹出状态。</p><p>可以设置选中或者未选中<code>setSelected(boolean)</code>。也可以通过<code>isSelected()</code>查看是否被选中</p><p>在按钮中可以显示图标，ImageIcon类表示图标。有以下设置图标的方法：</p><ul><li>setIcon(Icon icon): 设置有效状态下的图标</li><li>setRolloverIcon(Icon icon): 设置鼠标移动到对应区域显示图标</li><li>setPressedIcon(Icon icon): 设置按下按钮时显示的图标</li><li>setDisabledIcon(Icon icon): 设置无效状态下的图标</li><li>setBorderPainted(boolean b)： 是否绘制边框</li></ul><p><strong>监听器</strong></p><p>JButton</p><ul><li>void addActionListener(ActionListener listener)</li><li>void removeActionListener(ActionListener listener)：移除监听器</li></ul><p>JRadioButton</p><ul><li>void addChangeListener(ChangeListener l)//状态改变监听器</li></ul><h2 id="JRadioButton-JCheckBox-JtoggleButton"><a href="#JRadioButton-JCheckBox-JtoggleButton" class="headerlink" title="JRadioButton/JCheckBox/JtoggleButton"></a>JRadioButton/JCheckBox/JtoggleButton</h2><p>从上面我们可以看出，这三者就是图形有所不同，大致功能还是相同的。</p><p>构造方法：</p><ul><li>JRadioButton(String text, boolean selected): selected确定开始的状态<br>例：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculate</span> <span class="title">extends</span> <span class="title">JFrame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JRadioButton button;</span><br><span class="line">    <span class="keyword">private</span> JRadioButton button2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculate</span>(<span class="params">String text</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        button = <span class="keyword">new</span> JRadioButton(<span class="string">"男"</span>);</span><br><span class="line">        button2 = <span class="keyword">new</span> JRadioButton(<span class="string">"女"</span>);</span><br><span class="line">        ButtonGroup <span class="keyword">group</span> = <span class="keyword">new</span> ButtonGroup();</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span>(<span class="params">ActionEvent actionEvent</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">if</span>(button.isSelected())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"button has been selected"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"Button hasn't been selected"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button.setSelected(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">group</span>.<span class="keyword">add</span>(button);</span><br><span class="line">        <span class="keyword">group</span>.<span class="keyword">add</span>(button2);</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line">        panel.<span class="keyword">add</span>(button);</span><br><span class="line">        panel.<span class="keyword">add</span>(button2);</span><br><span class="line">        <span class="keyword">add</span>(panel);</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">new</span> Calculate(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里有个问题，使用actionListener的话只会显示button has been selected.因为点击另外一个按钮时button按钮会自动关闭，而actionListener不检查，只有当按下button时才会输出。</p><p>如果用ChangeListener的话当鼠标移动到这两个按钮上面的时候就会输出，点击时又会输出，这样可能会使输出过于庞杂。</p><h2 id="按钮组"><a href="#按钮组" class="headerlink" title="按钮组"></a>按钮组</h2><p>当有多个单选按钮时，可以把他们加入到一个按钮组中。这个歌时候一次最多只能选择按钮组中一个按钮。</p><p>创建：</p><ul><li>ButtonGroup b = new ButtonGroup();</li></ul><p>把按钮添加到按钮组中用add。</p><h1 id="JTextField文本框"><a href="#JTextField文本框" class="headerlink" title="JTextField文本框"></a>JTextField文本框</h1><p>JTextField与PlainDocument关联，后者保存前者的文档。当用户向文本框中输入文本时，AWT线程会自动调用PlainDocument的insertString()方法，把用户输入的文本存到PlainDocument中。</p><p>文本框只能储存一行文本，不能多行。</p><p>构造方法：</p><ul><li>JTextField(String text): 显示默认文本</li><li>JTextField(int col): 设定首选列数，如果是零，就是默认列数。</li></ul><p>方法：</p><ul><li>String getText(): 获得文本</li><li>setCaretColor(Color c): 设置光标颜色</li><li>setSelectionColor(Color c): 设置选中背景颜色</li><li>setSelectedTextColor(Color c): 设置选中文本颜色</li><li>setDisabledTextColor(Color c): 设置不可用时文本颜色</li><li>setHorizontalAlignment(int alignment): 设置文本对齐方式</li><li>setEditable(boolean b): 设置文本框是否可以编辑</li><li>boolean isFocusOwner()： 查看当前组件是否拥有焦点</li><li>setSelectionStart(int selectionStart)：设置光标开始位置</li><li>setSelectionEnd(int selectionEnd)： 设置光标结束位置</li><li>copy(): 复制选中文本</li><li>cut(): 剪切选中文本</li><li>paste(): 将复制/剪切得到的文本复制到文本框</li></ul><p><strong>监听器</strong></p><p>void addFocusListener(FocusListener listener)： 焦点事件监听器</p><p>textField.getDocument().addDocumentListener(DocumentListener listener)：文本框内文本改变监听器</p><p>void addKeyListener(KeyListener listener)：按键监听器</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JTextField field;</span><br><span class="line">    <span class="keyword">private</span> JTextField log;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">text</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(text);</span><br><span class="line">        log = <span class="keyword">new</span> <span class="constructor">JTextField()</span>;</span><br><span class="line">        field = <span class="keyword">new</span> <span class="constructor">JTextField(8)</span>;</span><br><span class="line">        field.set<span class="constructor">Font(<span class="params">new</span> Font(<span class="params">null</span>, Font.PLAIN, 20)</span>);</span><br><span class="line"></span><br><span class="line">        field.set<span class="constructor">CaretColor(Color.BLUE)</span>;</span><br><span class="line">        field.set<span class="constructor">SelectionColor(Color.BLACK)</span>;</span><br><span class="line">        field.set<span class="constructor">SelectedTextColor(Color.GREEN)</span>;</span><br><span class="line">        field.set<span class="constructor">DisabledTextColor(Color.RED)</span>;</span><br><span class="line"></span><br><span class="line">        field.set<span class="constructor">HorizontalAlignment(SwingConstants.RIGHT)</span>;</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="constructor">JPanel()</span>;</span><br><span class="line">        JButton button_copy = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">"copy"</span>)</span>;</span><br><span class="line">        JButton button_paste = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">"paste"</span>)</span>;</span><br><span class="line">        JButton button_cut = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">"cut"</span>)</span>;</span><br><span class="line">        JToggleButton button_enabled = <span class="keyword">new</span> <span class="constructor">JToggleButton(<span class="string">"edit disable"</span>)</span>;</span><br><span class="line"></span><br><span class="line">        button_copy.add<span class="constructor">ActionListener(<span class="params">new</span> <span class="params">actioncopy</span>()</span>);</span><br><span class="line">        button_cut.add<span class="constructor">ActionListener(<span class="params">new</span> <span class="params">actioncut</span>()</span>);</span><br><span class="line">        button_paste.add<span class="constructor">ActionListener(<span class="params">new</span> <span class="params">actionpaste</span>()</span>);</span><br><span class="line">        button_enabled.add<span class="constructor">ActionListener(<span class="params">new</span> ActionListener()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(field.is<span class="constructor">Editable()</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    button_enabled.set<span class="constructor">Text(<span class="string">"edit enable"</span>)</span>;</span><br><span class="line">                    field.set<span class="constructor">Editable(<span class="params">false</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    button_enabled.set<span class="constructor">Text(<span class="string">"edit disable"</span>)</span>;</span><br><span class="line">                    field.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        panel.add(button_copy);</span><br><span class="line">        panel.add(button_cut);</span><br><span class="line">        panel.add(button_paste);</span><br><span class="line">        panel.add(button_enabled);</span><br><span class="line"></span><br><span class="line">        field.add<span class="constructor">FocusListener(<span class="params">new</span> FocusAdapter()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void focus<span class="constructor">Gained(FocusEvent <span class="params">e</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                super.focus<span class="constructor">Gained(<span class="params">e</span>)</span>;</span><br><span class="line">                log.set<span class="constructor">Text(<span class="string">"your focus is in the text field"</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        field.add<span class="constructor">FocusListener(<span class="params">new</span> FocusAdapter()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void focus<span class="constructor">Lost(FocusEvent <span class="params">e</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                super.focus<span class="constructor">Lost(<span class="params">e</span>)</span>;</span><br><span class="line">                log.set<span class="constructor">Text(<span class="string">"yout focus is out of the text field"</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        add(panel, BorderLayout.NORTH);</span><br><span class="line">        add(log, BorderLayout.SOUTH);</span><br><span class="line">        add(field, BorderLayout.CENTER);</span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        pack<span class="literal">()</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">class</span> actioncopy implements ActionListener</span><br><span class="line">    &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            field.copy<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">class</span> actioncut implements  ActionListener</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            field.cut<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">class</span> actionpaste implements ActionListener</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            field.paste<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">"Hello"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing3.PNG" alt></p><h1 id="JLabel标签"><a href="#JLabel标签" class="headerlink" title="JLabel标签"></a>JLabel标签</h1><p>标签主要用于展示文本和图片。</p><p>构造方法：</p><ul><li>JLabel()</li><li>JLabel(String text, int horizontalAlignment): text是文本，horizontalAlignment是对齐方式</li><li>JLabel(Icon Image): 图片</li><li>上面三种可以组合，也就是说可以同时显示图片和文本</li></ul><p>方法：</p><ul><li>setText(String text)</li><li>setIcon(Icon icon)</li></ul><p>// 设置文本相对于图片的位置（文本默认在图片右边垂直居中）</p><ul><li>void setHorizontalTextPosition(int textPosition)</li><li>void setVerticalTextPosition(int textPosition)</li></ul><p>// 设置标签内容（在标签内）的对其方式（默认左对齐并垂直居中）</p><ul><li>void setHorizontalAlignment(int alignment)</li><li>void setVerticalAlignment(int alignment)</li><li>setIconTextGap(int gap): 设置文本和图片之间的间隙</li></ul><p>构造方法中的图片还可以直接填URL从网络中获取。此外，Icon一般用的是ImageIcon</p><p>image实例创建</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一: 通过 java.awt.Toolkit 工具类来读取本地、网络 或 内存中 的 图片（支持 GIF、JPEG 或 PNG）</span></span><br><span class="line">Image image = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.get<span class="constructor">Image(String <span class="params">filename</span>)</span>;</span><br><span class="line">Image image = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.get<span class="constructor">Image(URL <span class="params">url</span>)</span>;</span><br><span class="line">Image image = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.create<span class="constructor">Image(<span class="params">byte</span>[] <span class="params">imageData</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二: 通过 javax.imageio.ImageIO 工具类读取本地、网络 或 内存中 的 图片（BufferedImage 继承自 Image）</span></span><br><span class="line">BufferedImage bufImage = <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>read(File input);</span><br><span class="line">BufferedImage bufImage = <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>read(URL input);</span><br><span class="line">BufferedImage bufImage = <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>read(InputStream input);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PS_01: 图片宽高: BufferedImage 可以通过 bufImage.getWidth() 和 bufImage.getHeight() 方法直接获取图片的宽高;</span></span><br><span class="line"><span class="comment"> *                 Image 获取宽高需要另外传入一个 ImageObserver 参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PS_02: 图片裁剪: BufferedImage 通过 bufImage.getSubimage(int x, int y, int w, int h) 方法可以截取图片的</span></span><br><span class="line"><span class="comment"> *                 任意一部分，返回一个新的 BufferedImage 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PS_03: 图片缩放: Image 通过 image.getScaledInstance(int width, int height, int hints) 方法可以对图片进行</span></span><br><span class="line"><span class="comment"> *                 缩放，返回新的一个 Image 实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/xietansheng/article/details/74362076" target="_blank" rel="external nofollow noopener noreferrer">几乎照搬</a></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JLabel label ;</span><br><span class="line">    <span class="keyword">public</span> Calculate(<span class="keyword">String</span> text, <span class="keyword">String</span> image)</span><br><span class="line">    &#123;</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="type">JPanel</span>();</span><br><span class="line">        label = <span class="keyword">new</span> <span class="type">JLabel</span>(image);</span><br><span class="line">        label.setFont(<span class="keyword">new</span> <span class="type">Font</span>(<span class="literal">null</span>, Font.PLAIN, <span class="number">25</span>));</span><br><span class="line">        JLabel label2 = <span class="keyword">new</span> <span class="type">JLabel</span>();</span><br><span class="line">        label2.setIcon(<span class="keyword">new</span> <span class="type">ImageIcon</span>(<span class="string">"D:\\截图\\捕获.PNG"</span>));</span><br><span class="line">        label2.setText(<span class="string">"only an image"</span>);</span><br><span class="line">        label2.setHorizontalTextPosition(SwingConstants.CENTER);</span><br><span class="line">        label2.setVerticalTextPosition(SwingConstants.BOTTOM);</span><br><span class="line">        panel.add(label);</span><br><span class="line">        panel.add(label2);</span><br><span class="line">        add(panel);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        pack();</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Calculate</span>(<span class="string">"Hello"</span>, <span class="string">"This is an image"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing2.PNG" alt></p><h1 id="JPasswordField-密码框"><a href="#JPasswordField-密码框" class="headerlink" title="JPasswordField 密码框"></a>JPasswordField 密码框</h1><p>JPasswordField的构造方法和JTextField相同。</p><p>方法：</p><ul><li>char[] getpassword(): 获取输入的密码</li><li>setEchoChar(char c)： 设置默认显示的字符</li><li>setEditable()</li><li>setEnabled()</li></ul><p>常用的监听器和JTextField相同。</p><p><img src="/images/swing5.PNG" alt></p><p>密码框的特点就是输入字符不可见</p><h1 id="JTextArea-文本区域"><a href="#JTextArea-文本区域" class="headerlink" title="JTextArea 文本区域"></a>JTextArea 文本区域</h1><p>文本区域可以编辑多行文本。</p><p>构造方法：</p><ul><li>JTextArea(String text, int rows, int cols): 默认显示多少行多少列</li></ul><p>方法：</p><ul><li>setLineWrap(boolean b): 设置是否自动换行， 默认是false</li><li>setWrapStyleWord(boolean word)： 设置换行方式，如果是true，就在单词边界换行。如果是false，就在字符边界换行（也就是说到了上限就一定换行）</li><li>append(String str): 追加字符串到文末</li><li>replaceRange（String str, int start, int end): 替换文本</li><li>getLineCount()： 获取行数</li><li>getLineEndOfOffset(int line): 获取某一行行尾在文中偏移量</li><li>getLineOfOffset(int line)</li><li>setCaretColor(Color c)</li><li>setSelectionColor(Color c)</li><li>void setMinimum(int min)</li><li>void setMaximum(int max)</li><li>void setValue(int n)</li><li>setSelectedTextColor(Color c)</li><li>setDisabledTextColor(Color c)</li></ul><p>大致方法和监听器和JTextField相同</p><h1 id="JComboBox-下拉列表"><a href="#JComboBox-下拉列表" class="headerlink" title="JComboBox 下拉列表"></a>JComboBox 下拉列表</h1><p>下拉列表中选项内容由ComboBoxModel 实例来维护。</p><p>构造方法：</p><ul><li>JComboBox(ComboBoxModel model)</li><li>JComboBox(Object[] items)</li><li>JComboBox(Vector&lt;?&gt; items)</li></ul><p>ComboBoxModel 实例可以直接创建，也可以通过把 数组 或 集合 传递到 JComboBox 中间接创建。</p><p>常用方法：</p><ul><li>setSelectedIndex(int index)： 设置选中索引</li><li>getSelectedIndex(): 获得当前选中的索引</li><li>Object getSelectedItem()： 获得当前选中的数据项</li><li>setModel(ComboBoxModel&lt;?&gt; model)： 设置当前模型</li><li>ComboBoxModel&lt;?&gt; getModel()： 获得模型。再通过 model.getElementAt(int index) 和 model.getSize() 获得索引和选项数量</li><li>setEditable(boolean flag)： 设置是否可以编辑，默认false。如果设置成true，那么用户自己可以自行输入值。</li></ul><p>监听器：</p><ul><li>addItemListener(ItemListener listener)：选项选中状态改变</li></ul><p><img src="/images/swing6.PNG" alt></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">comboBox.add<span class="constructor">ItemListener(<span class="params">new</span> ItemListener()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void item<span class="constructor">StateChanged(ItemEvent <span class="params">e</span>)</span> &#123;</span><br><span class="line">                <span class="comment">// 只处理选中的状态</span></span><br><span class="line">                <span class="keyword">if</span> (e.get<span class="constructor">StateChange()</span><span class="operator"> == </span>ItemEvent.SELECTED) &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"选中: "</span> + comboBox.get<span class="constructor">SelectedIndex()</span> + <span class="string">" = "</span> + comboBox.get<span class="constructor">SelectedItem()</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></div><h1 id="JList-列表框"><a href="#JList-列表框" class="headerlink" title="JList 列表框"></a>JList 列表框</h1><p>列表框和下拉列表不同之处在于列表框一次把所有选项都显示并且可以多选（按ctrl），而下拉列表一次只能选择一个。同样内容有ListModel维护。</p><p>构造方法大致和JComboBox相同</p><p>方法：</p><ul><li>setListData(Object[] listData)： 设置列表元素</li><li>setListData(Vector&lt;?&gt; listData)</li><li>setModel(ListModel&lt;?&gt; model)</li><li>setSelectionMode(int selectionMode)：设置选择模式，有三种模式，单选，可间断多选，可连续多选。ListSelectionModel.MULTIPLE_INTERVAL_SELECTION，等。</li><li>setSelectedIndex(int index)： 设置某个选项被选中</li><li>setSelectedIndices(int[] indices)</li><li>getSelectedIndex()： 获得第一个被选中的索引</li><li>int[] getSelectedIndices()： 获得所有被选中的索引</li><li>setForeground(Color fg)： 未选中时字体颜色</li><li>setSelectionForeground(Color selectionForeground)：选中选项字体颜色</li><li>setSelectionBackground(Color selectionBackground)：选中条颜色</li></ul><p>监听器： addListSelectionListener(ListSelectionListener listener)。选项选中状态改变监听器</p><h1 id="JPrograssBar-进度条"><a href="#JPrograssBar-进度条" class="headerlink" title="JPrograssBar 进度条"></a>JPrograssBar 进度条</h1><p>当进度未知的时候，可以设置成不确定模式，不确定模式下也会持续显示动画。当确定就可以转换成确定模式。</p><p>构造方法：</p><ul><li><p>JPrograssBar(int orient, int min, int max): 进度条当前值，最大值，最小值。这些参量可以减少</p></li><li><p>void setMinimum(int min)</p></li><li><p>void setMaximum(int max)</p></li><li><p>void setValue(int n)：设置当前进度值</p></li><li><p>getValue()</p></li><li><p>getPercentComplete()： 获得当前进度百分比</p></li><li><p>setStringPainted(boolean b)： 是否以百分比显示文本</p></li><li><p>setIndeterminate(boolean newValue)： 是否设置成不确定模式</p></li><li><p>setOrientation(int newOrientation)： SwingConstants.VERTICAL 或 SwingConstants.HORIZONTAL</p></li><li><p>setMajorTickSpacing(int n)： 设置主刻度线间隔</p></li><li><p>setMinorTickSpacing(int n)： 设置主标记线内次标记线间隔</p></li><li><p>setPaintTicks(boolean b)： 是否绘制刻度线</p></li><li><p>setInverted(boolean b)： 是否让刻度值从大到小</p></li><li><p>setSnapToTicks(boolean b)： 是否让滑块对齐刻度。true滑块只能取刻度值</p></li><li><p>setLabelTable(Dictionary&lt;Integer, JComponent&gt; labels)：绘制特定的标签代替刻度值</p></li><li><p>setPaintTrack(boolean b)： 是否绘制滑道</p></li></ul><p>监听器：<code>addChangeListener(ChangeListener l)</code>: 进度改变监听器</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="title">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">String</span> <span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        super(<span class="built_in">text</span>);</span><br><span class="line">        JProgressBar progressBar = <span class="keyword">new</span> JProgressBar(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        progressBar.setValue(<span class="number">0</span>);</span><br><span class="line">        progressBar.setStringPainted(<span class="literal">true</span>);</span><br><span class="line">        progressBar.setIndeterminate(<span class="literal">false</span>);</span><br><span class="line">        progressBar.setOrientation(SwingConstants.HORIZONTAL);</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(<span class="literal">true</span>);</span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()</span><br><span class="line">            &#123;</span><br><span class="line">                progressBar.setValue(progressBar.getValue() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        timer.schedule(task, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">        add(progressBar);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Calculate(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里就可以解释为什么进度条为什么忽快忽慢的了。当某一部分任务完成的时候就会设置进度条向前进。</p><h1 id="JSlider"><a href="#JSlider" class="headerlink" title="JSlider"></a>JSlider</h1><p>通过滑块来选择不同的值。当鼠标焦点移到滑块上时，也可以通过上下左右移动滑块。</p><p>构造方法 ：</p><ul><li>JSlider(int orientation): 滑块方向，有SwingConstants.HORIZONAL和SwingConstants.VERTICAL.</li><li>JSlider(int min, int max): 滑块初始值可以是min到max中间任意一个值。</li><li>JSlider(int orientation, int min, int max, int value)</li></ul><p>方法：</p><ul><li>void setMinimum(int min)</li><li>void setMaximum(int max)</li><li>void setValue(int n)</li><li>setMajorTickSpacing(int n)： 设置主刻度线间隔</li><li>setMinorTickSpacing(int n)： 设置主标记线内次标记线间隔</li><li>setPaintTicks(boolean b)： 是否绘制刻度线</li><li>setPaintLabels(boolean b): 是否绘制标签</li><li>setInverted(boolean b)： 是否让刻度值从大到小</li><li>setSnapToTicks(boolean b)： 是否让滑块对齐刻度。true滑块只能取刻度值</li><li>setLabelTable(Dictionary&lt;Integer, JComponent&gt; labels)：绘制特定的标签代替刻度值。Integer是刻度值，JComponent可以使JLabel等。</li><li>setPaintTrack(boolean b)： 是否绘制滑道</li><li>setOrientation(int orientation)： 方向</li></ul><p>监听器：<code>addChangeListener(ChangeListener l)</code>: 滑道值改变监听</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">text</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(text);</span><br><span class="line">        JTextField textField = <span class="keyword">new</span> <span class="constructor">JTextField()</span>;</span><br><span class="line">        JSlider slider = <span class="keyword">new</span> <span class="constructor">JSlider(0, 20)</span>;</span><br><span class="line"></span><br><span class="line">        slider.set<span class="constructor">MajorTickSpacing(5)</span>;</span><br><span class="line">        slider.set<span class="constructor">MajorTickSpacing(1)</span>;</span><br><span class="line">        slider.set<span class="constructor">Orientation(SwingConstants.HORIZONTAL)</span>;</span><br><span class="line">        slider.set<span class="constructor">PaintLabels(<span class="params">true</span>)</span>;</span><br><span class="line">        slider.set<span class="constructor">PaintTrack(<span class="params">true</span>)</span>;</span><br><span class="line">        slider.set<span class="constructor">PaintTicks(<span class="params">true</span>)</span>;</span><br><span class="line">        slider.set<span class="constructor">SnapToTicks(<span class="params">true</span>)</span>;</span><br><span class="line">        Hashtable&lt;Integer, JComponent&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;Integer, JComponent&gt;<span class="literal">()</span>;</span><br><span class="line">        hashtable.put(<span class="number">0</span>, <span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">"Start"</span>)</span>);      <span class="comment">//  0  刻度位置，显示 "Start"</span></span><br><span class="line">        hashtable.put(<span class="number">10</span>, <span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">"Middle"</span>)</span>);    <span class="comment">//  10 刻度位置，显示 "Middle"</span></span><br><span class="line">        hashtable.put(<span class="number">20</span>, <span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">"End"</span>)</span>);       <span class="comment">//  20 刻度位置，显示 "End"</span></span><br><span class="line">        slider.set<span class="constructor">LabelTable(<span class="params">hashtable</span>)</span>;</span><br><span class="line">        slider.add<span class="constructor">ChangeListener(<span class="params">new</span> ChangeListener()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void state<span class="constructor">Changed(ChangeEvent <span class="params">changeEvent</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                textField.set<span class="constructor">Text(<span class="string">"now is "</span> + <span class="params">slider</span>.<span class="params">getValue</span>()</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        add(slider);</span><br><span class="line">        add(textField, BorderLayout.SOUTH);</span><br><span class="line"></span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">        pack<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">"Hello"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="Robot-模拟鼠标，键盘输入"><a href="#Robot-模拟鼠标，键盘输入" class="headerlink" title="Robot 模拟鼠标，键盘输入"></a>Robot 模拟鼠标，键盘输入</h1><p>这个类主要是为了方便自动测试</p><p>构造方法：</p><ul><li>Robot(GraphicsDevice screen)： 给指定屏幕创建一个对象</li><li>Robot(): 给默认屏幕创建一个对象</li></ul><p>方法：</p><ul><li>mouseMove(int x, int y)： 把鼠标移动到某个位置</li><li>mousePress(int buttons)： 按下某个键。有InputEvent.BUTTON1_MASK （鼠标左键）和InputEvent.BUTTON2_MASK （鼠标中键）和 InputEvent.BUTTON3_MASK （鼠标右键）</li><li>mouseRelease(int buttons)</li><li>mouseWheel(int wheelAmt)：旋转滚轮</li></ul><p>键盘输入：</p><ul><li>keyPress(int keycode)： keycode定义在KeyEvent.VK_xxx中</li><li>keyRelease(int keycode)</li></ul><p>屏幕相关：</p><ul><li>Color getPixelColor(int x, int y)： 获得像素颜色</li><li>BufferedImage createScreenCapture(Rectangle screenRect)： 截屏</li></ul><p>控制：</p><ul><li>delay(int ms)： 睡眠指定时间</li><li>waitForIdle()： 在当前队列中时间完成之前一直等待</li><li>setAutoWaitForIdle(boolean isOn)： 生成一个事件之后是否自动调用waitForIdle</li><li>boolean isAutoWaitForIdle()： 设置为true，按次序执行</li><li>setAutoDelay(int ms)： 每个事件完成后自动等待ms秒。</li><li>int getAutoDelay()</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">一般测试步骤</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws AWTException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Robot 实例</span></span><br><span class="line">        Robot robot = <span class="keyword">new</span> Robot();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行完一个事件后再执行下一个</span></span><br><span class="line">        robot.setAutoWaitForIdle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动鼠标到指定屏幕坐标</span></span><br><span class="line">        robot.mouseMove(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按下鼠标左键</span></span><br><span class="line">        robot.mousePress(InputEvent.BUTTON1_MASK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延时100毫秒</span></span><br><span class="line">        robot.<span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放鼠标左键（按下后必须要释放, 一次点击操作包含了按下和释放）</span></span><br><span class="line">        robot.mouseRelease(InputEvent.BUTTON1_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 09 2020 08:11:43 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;Border边框&quot;&gt;&lt;a href=&quot;#Border边框&quot; class=&quot;headerlink&quot; title=&quot;Border边框&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 图形界面</title>
    <link href="http://xinhecuican.github.io/post/2170659a.html"/>
    <id>http://xinhecuican.github.io/post/2170659a.html</id>
    <published>2020-06-01T12:31:00.000Z</published>
    <updated>2020-06-12T01:19:35.046Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 08:33:10 GMT+0800 (中国标准时间) --><h1 id="AWT-和-Swing"><a href="#AWT-和-Swing" class="headerlink" title="AWT 和 Swing"></a>AWT 和 Swing</h1><p>GUI基本类在java.awt包中，这个包也称为抽象窗口工具包（Abstract Window Toolkit，AWT）。</p><p>java.awt包中有一个抽象类Component，它是除菜单类外所有类的父类，他有如下所有组件都有的方法</p><ul><li>getBackground(): 返回背景色</li><li>getGraphics(): 返回组件用的画笔</li><li>getHeight(): 返回组件高度</li><li>getLocation(): 获得组件位置</li><li>getSize(): 获得组件大小</li><li>getWidth(): 获得组件宽度</li><li>getX(): 获得组件x值</li><li>getY():</li><li>isVisible(): 组件是否可见</li><li>setBackGround(): 设置背景色</li><li>setBackGrounds(int x, int y, int width, int height): 设置位置及大小</li><li>setEnabled(boolean b): 设置组件是否可用</li><li>setFont(Font f): 设置字体</li><li>setForground(Color c): 设置前景色</li><li>setLocation(int x, int y): 设置组件位置</li><li>setSize(int width, int height): 设置组件宽高</li><li>setSize(Dimension d): 设置组件大小</li><li>setVisible(boolean b): 设置组件是否可见</li></ul><p>Container表示容器，继承了Component类。容器用来存放别的组件。有两种容器</p><ul><li>Window(窗口)： 他有两个子类，Frame(窗体）和Dialog（对话框）。Frame带有标题，并且可以自动调整大小，Dialog可以被移动，但不能改变大小</li><li>Panel（面板）： 他不能单独存在，只能存在于其他容器（如Window或其子类）。他有一个子类Applet，Applet可以在web中运行。</li></ul><p>为了使java创建的图形界面能够跨平台，引入了Swing组件。这些组件位于javax.swing包中。接下来主要讲swing。</p><p>多数Swing的父类是JComponent(除了JFrame和JDialog外其他都继承了这个）。</p><p>JComponent的一些方法</p><ul><li>setFont(Font font): 设置字体</li><li>setForeground(Color c): 设置字体颜色</li><li>setToolTipText(String text): 设置鼠标移动到上面的时候显示的文本</li><li>setBackGround(Color c)</li><li>setOpaque(boolean isOpaque)： 设置组件是否不透明，JLabel默认是透明。不透明才可以显示背景。</li><li>setLocationRelativeTo(Component c)： 设置窗口相对于指定组件的位置。当为null时，设置为中间。中点可以使用 GraphicsEnvironment.getCenterPoint 确定。</li><li>isFocusOwner(): 判断这个组件是否拥有焦点</li></ul><p>JFrame一些方法：</p><ul><li>setIconImage(Image image)</li><li>setResizable(boolean resizable)：窗口是否可以放大缩小</li><li>setLocation(int x, int y)： 位置</li><li>setBounds(int x, int y, int width, int height)： 设置大小和宽高</li><li>Point getLocationOnScreen()： 获得位置</li><li>dispose()： 销毁窗口。如果再次使用setVisiable()会重构组件</li></ul><h1 id="创建界面基本步骤"><a href="#创建界面基本步骤" class="headerlink" title="创建界面基本步骤"></a>创建界面基本步骤</h1><p>JFrame有一个构造方法JFrame(String title)。创建一个title位标题的JFrame对象，但是创建后它是不可见的，必须要经过下列步骤才可以可见：</p><ul><li>调用setSize(int width, int height): 设置JFrame大小，或者调用peck()自动确定大小。</li><li>调用setVisible(true): 使JFrame可见</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JFrame frame = <span class="keyword">new</span> JFrame(<span class="string">"Hello"</span>);</span><br><span class="line">    jframe.setSize(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    jframe.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>每个JFrame都会有内容面板(contentpane)，加入JFrame容器的组件实际上都是加入这个面板中</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Container content = jframe.getContentPane()<span class="comment">;</span></span><br><span class="line">content.add(jButton)<span class="comment">;//加入按钮组件</span></span><br></pre></td></tr></table></figure></div><p>add()方法直接向与之关联的内容面板加入组件，所以可以直接<code>jframe.add(jButton)</code>.</p><p>JFrame的setContentPane(Container content)用来重新设置面板。</p><p>JFrame的setDefaultCloseOperation(int operation)用来设置如何相应关闭操作<br>operation可以有以下操作</p><ul><li>JFrame.DO_NOTHING_ON_CLOSE: 什么也不做</li><li>JFrame.HIDE_ON_CLOSE: 隐藏窗体，这是默认选项</li><li>JFrame.DISPOSE_ON_CLOSE: 销毁窗体</li><li>JFrame.EXIT_ON_CLOSE: 结束程序</li></ul><h1 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h1><p>JFrame的默认布局管理器是BorderLayout，JPanel默认布局管理器是FlowLayout。</p><p>可以通过setLayout(Layout layout)设置布局。也可以通过setLayout(null)取消布局管理器，但是接下来要自己去管理布局，并且现在每个操作系统不同。</p><h2 id="FlowLayout-流式布局管理器"><a href="#FlowLayout-流式布局管理器" class="headerlink" title="FlowLayout 流式布局管理器"></a>FlowLayout 流式布局管理器</h2><p>他按照组件先后顺序从左到右放到容器中，到达边界时，会放置到下一行。</p><p>当容器被缩放时，组件位置可能变化，但是组件大小不会改变</p><p>构造方法：</p><ul><li>FlowLayout()</li><li>FlowLayout(int align)</li><li>FlowLayout(int align, int hgap, int vgap):align设置对齐方式，可以有FlowLayout.LEFT,FlowLayout.RIGHT, FlowLayout.CENTER. hgap和vgap设置组件间水平和垂直间隙</li></ul><h2 id="BorderLayout（边界布局管理器）"><a href="#BorderLayout（边界布局管理器）" class="headerlink" title="BorderLayout（边界布局管理器）"></a>BorderLayout（边界布局管理器）</h2><p>他把容器分成五个区域：东西南北中。</p><ul><li>它的东和西组件保持最佳宽度，高度拉伸至和所在区域一样高。南北保持最佳高度，宽度和这个区域一样宽。中间和这个区域一样大。</li><li>窗口垂直拉伸时，东西中拉伸，当窗口垂直拉伸时，南北中拉伸。</li><li>窗口缩放时，组件相对位置不变，但是组件大小改变</li><li>如果某个区域组件添加不止一个，只有最后一个是可见的。</li></ul><p>构造方法：</p><ul><li>BorderLayout()</li><li>BorderLayout(int hgap, int vgap)</li></ul><p>添加组件： void add(Component comp, Object constraints)。其中constraints是区域，可以是BorderLayout.NORTH,BorderLayout.SOUTH，BorderLayout.EAST,BorderLayout.WEST,BorderLayout.CENTER. 默认是中</p><p>还可以直接用字符串设置区域。但是首字母必须大写，其他必须小写。<code>f.add(new JButton(&quot;b1&quot;), &quot;North&quot;)</code></p><h2 id="GridLayout-网格布局管理器）"><a href="#GridLayout-网格布局管理器）" class="headerlink" title="GridLayout(网格布局管理器）"></a>GridLayout(网格布局管理器）</h2><p>他把容器分成许多行和列，添加组件时首先防止到左上角网格中，然后从左到右放置其他组件。</p><ul><li>组件相对位置不会随缩放而改变，但是组件大小会改变。</li><li>他总是忽略组件最佳大小，所有组件宽度相同，高度也相同</li></ul><p>构造方法：</p><ul><li>GridLayout()</li><li>GridLayout(int rows, int cols)</li><li>GirdLayout(int rows, int cols, int hgap, int vgap)</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculater</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JPanel panel;</span><br><span class="line">    <span class="keyword">private</span> JLabel label;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span>[] name = &#123;<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"+"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"-"</span>,<span class="string">"1"</span>,<span class="string">"2"</span></span><br><span class="line">    ,<span class="string">"3"</span>,<span class="string">"*"</span>,<span class="string">"0"</span>,<span class="string">"."</span>,<span class="string">"="</span>,<span class="string">"/"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> JButton[] buttons = <span class="keyword">new</span> <span class="type">JButton</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">public</span> Calculater(<span class="keyword">String</span> title)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">    &#125;</span><br><span class="line">    label = <span class="keyword">new</span> <span class="type">JLabel</span>(<span class="string">"    "</span>);</span><br><span class="line">    panel = <span class="keyword">new</span> <span class="type">panel</span>();</span><br><span class="line">    panel.setLayout(<span class="keyword">new</span> <span class="type">GridLayout</span>(<span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line">    add(label, BorderLayout.NORTH);</span><br><span class="line">    add(panel, BorderLayout.CENTER);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;buttons.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buttons[i] = <span class="keyword">new</span> <span class="type">JButton</span>(name[i]);</span><br><span class="line">        panel.add(buttons[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    pack();</span><br><span class="line">    setVisible();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Calculater</span>(<span class="string">"Calculater"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这是一个计算器的图形界面，可以看到外面采用了BorderLayout，里面面板采用了GridLayout。</p><h2 id="CardLayout"><a href="#CardLayout" class="headerlink" title="CardLayout"></a>CardLayout</h2><p>他将界面看成一系列的卡片，任何时候只有一张卡片可见。</p><p>构造方法：</p><ul><li>CardLayout()</li><li>CardLayout(int hgap, int vgap)</li></ul><p>添加组件 void add(Component comp, Object constraints)。其中constraints实际上是一个字符串，表示卡片的名字。默认显示第一张卡片，可以采用show(Container parent, String name)指定显示哪一张卡片。parent指定容器</p><h2 id="GridBagLayout（网格包-布局管理器）"><a href="#GridBagLayout（网格包-布局管理器）" class="headerlink" title="GridBagLayout（网格包 布局管理器）"></a>GridBagLayout（网格包 布局管理器）</h2><p>创建步骤：</p><ul><li>创建GridBagLayout，并启用<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GridBagLayout layout = <span class="keyword">new</span> <span class="constructor">GridBagLayout()</span>;</span><br><span class="line">container.set<span class="constructor">Layout(<span class="params">layout</span>)</span>;</span><br></pre></td></tr></table></figure></div></li><li>创建一个GridBagConstraints对象<code>GridBagConstraints constraints = new GridBagConstraints();</code></li><li>配置a的各种属性<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="INI"><figure class="iseeu highlight /ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">constraints.gridx</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">constraints.gridy</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">constraints.gridwidth</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">constraints.gridwidth</span> = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></div></li><li>设置布局信息<code>lyout.setConstraints(component1, constraints)</code></li><li>加入容器<code>container.add(component1)</code></li></ul><p>其中GridBagConstraints只需要设置一个，然后重复设置里面属性即可。</p><p>这种布局器最为自由，可以完全自己配置，但是首先要画一个草图先规划好各个组件的坐标。</p><p>GridBagConstraints的属性：</p><ul><li>gridx和gridy： 左上角横纵坐标。最左边是（0，0）。默认值是RELATIVE，即最新添加元素后面</li><li>gridwidth，gridheight： 宽和高。默认值是1</li><li>fill： 当某组件显示区域大于他所要求大小时使用。可以设置如下取值<ul><li>GridBagConstraints.NONE: 默认，不改变组件大小</li><li>GridBagConstraints.HORIZONTAL: 填充水平方向，不改变水平大小</li><li>GridBagConstraints.VERTICAL: 填充垂直方向</li><li>GridBagConstraints.BOTH: 水平垂直都扩大以适应大小</li></ul></li><li>ipadx，ipady： 指定内部填充大小，即最小尺寸下还要加多少。宽度和高度都至少要加ipadx/ipady</li><li>insets: 指定外部填充大小。组件和区域边界之间最小区域大小，例如<code>a.insets = new Insets(1, 1, 1, 1);//上左下右边距</code></li><li>anchor: 当组件小于区域的时候使用。决定了在区域中的位置，有GridBagContraints.CENTER,等九个区域（包括NORTHEAST等角上区域）</li><li>weightx，weighty： 水平重量和垂直重量。他们决定拉伸时谁将占据空白区域。注意每一行或每一列至少要有一个占据重量，不然拉伸时组件大小将不会发生改变，从而导致周围空白。</li></ul><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>每一个可以触发的事件都是事件源，每一种事件都会有相应的监听器，监听器负责接受和处理这些事件。一个事件源可以触发多种事件，事件源可以使按钮，键盘，鼠标等，他们可以产生时间如按键，按按钮，点击然后触发事件处理。</p><h2 id="事件处理的实现"><a href="#事件处理的实现" class="headerlink" title="事件处理的实现"></a>事件处理的实现</h2><p>每个具体的事件都是某个事件类的实例，事件类有： ActionEvent，ItemEvent，MouseEvent，KeyEvent，FocusEvent，WindowEvent等。每个事件类对应一个事件监听接口，如ActionEvent对应ActionListener。</p><p>如果程序需要处理某种事件，就需要实现这些接口。</p><p><strong>用内部类实现接口</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> ButtonCounter extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JButton button = <span class="keyword">new</span> <span class="constructor">JFrame(<span class="string">"1"</span>)</span>;</span><br><span class="line">    public <span class="constructor">ButtonCounter(String <span class="params">title</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(title);</span><br><span class="line">        <span class="comment">//注册监视器</span></span><br><span class="line">        button.add<span class="constructor">ActionListener(<span class="params">new</span> ActionListener()</span>&#123;</span><br><span class="line">            public void action<span class="constructor">Performed(ActionEvent <span class="params">evt</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> count = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">button</span>.<span class="params">getText</span>()</span>);</span><br><span class="line">                button.set<span class="constructor">Text(<span class="params">new</span> Integer(<span class="operator">++</span><span class="params">count</span>)</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add(button);</span><br><span class="line">        set<span class="constructor">Size(100, 100)</span>;</span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>使用容器类实现接口</strong></p><p>可以用容器类实现多个监听接口。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> FrmaeCounter extends JFrame implements ActionListener</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JButton button = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">"1"</span>)</span>;</span><br><span class="line">    public <span class="constructor">FrameCounter(String <span class="params">title</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(title);</span><br><span class="line">        <span class="comment">//注册监听器</span></span><br><span class="line">        button.add<span class="constructor">ActionListener(<span class="params">this</span>)</span>;</span><br><span class="line">        add(button);</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class="line">        set<span class="constructor">Szie(100, 100)</span>;</span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void action<span class="constructor">Performed(ActionEvent <span class="params">evt</span>)</span><span class="comment">//实现接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">button</span>.<span class="params">getText</span>()</span>);</span><br><span class="line">        button.set<span class="constructor">Text(<span class="params">new</span> Integer(<span class="operator">++</span><span class="params">count</span>)</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>它可以让按钮中的数字按一次就加一</p><p><strong>定义顶层类实现接口</strong></p><p>创建一个专门用来处理事件的类，优点是可以使处理时间的代码和创建GUI的代码分离，缺点是监听类无法直接访问事件源，必须通过事件类的getSource()方法获得事件源。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="class"><span class="keyword">class</span> <span class="title">OuterCounter</span> <span class="title">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> JButton button = <span class="keyword">new</span> JButton(<span class="string">"1"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterCounter</span><span class="params">(<span class="keyword">String</span> title)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        super(title);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> MyListener(<span class="number">2</span>));<span class="comment">//创建监听器</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="title">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">step</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyListener</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">step</span> = <span class="built_in">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent evt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JButton button = (JButton)evt.getSource();<span class="comment">//获得事件源</span></span><br><span class="line">        <span class="keyword">int</span> count = Integer.<span class="built_in">parseInt</span>(button.getText());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当有动作（按按钮）产生时，会产生ActionEvent让Mylistener处理，如果是在一个类里，我们可以直接使用这个事件源（按钮），但是如果是其他类，就需要ActionEvent的getSource()来获得事件源（谁产生的设个事件）。</p><p><strong>事件适配器</strong></p><p>如果实现监听街口，就必须实现里面所有的方法。MouseListener有五个方法：mousePressed(),mouseReleased(),mouseEntered(),mouseExited(),<br>mouseClicked();在实际应用中，往往用不到这么多方法，因此可以使用适配器，适配器中实现了所有方法，但是都是空。例如MouseListener适配器类就是MouseAdapter</p><h2 id="事件源，时间和监听器之间的关系"><a href="#事件源，时间和监听器之间的关系" class="headerlink" title="事件源，时间和监听器之间的关系"></a>事件源，时间和监听器之间的关系</h2><h3 id="事件和监听接口"><a href="#事件和监听接口" class="headerlink" title="事件和监听接口"></a>事件和监听接口</h3><table><thead><tr><th>事件</th><th>监听接口</th><th>抽象方法</th></tr></thead><tbody><tr><td>Action</td><td>ActionListener</td><td>actioPerformed(ActionEvent evt)</td></tr><tr><td>ItemEvent</td><td>ItemListener</td><td>itemStateChanged(ItemEvent)</td></tr><tr><td>MouseEvent</td><td>MouseMotionListener</td><td>mouseDargged(MouseEvent)/mouseMoved(MouseEvent)</td></tr><tr><td>MouseEvent</td><td>MouseListener</td><td>mousePressed()/mouseReleased()/mouseEntered()/ mouseExited()/mouseClicked()</td></tr><tr><td>KeyEvent</td><td>KeyListener</td><td>keyPressed()/keyReleased()/keyTyped()</td></tr><tr><td>FocusEvent</td><td>FocusListener</td><td>focusGained()/foucusLost()</td></tr><tr><td>AdjustmentEvent</td><td>AdjustmentListener</td><td>adjustmentValueChanged()</td></tr><tr><td>ComponentEvent</td><td>ComponentListneer</td><td>componentMoved()/ componentResized()/componentShown()</td></tr><tr><td>WindowEvent</td><td>WinodwListener</td><td>windowClosing()/windowOpened()/ windowIconified()/windowDeiconfied()/ windowclosed() /windowActivated()/windowDeativated()</td></tr><tr><td>ContainerEvent</td><td>ContainerListener</td><td>componentAdded()/componentRemoved()</td></tr><tr><td>Textevent</td><td>TextListener</td><td>textValueChanged()</td></tr></tbody></table><p>MouseListener和MouseMotionListener都是监听MouseEvent。MouseMotionListener监听和鼠标移动相关事件。他们有以下方法</p><ul><li>mouseMoved(): 用户未按下鼠标直接移动时调用此方法</li><li>mouseDragged(): 按下鼠标并拖动</li><li>mouseClicked(): 单击鼠标</li><li>mosuePressed(): 按下鼠标</li><li>mouseReleased(): 释放鼠标</li><li>mouseExited(): 退出组件区域</li><li>mouseEntered(): 进入组件区域</li></ul><p><strong>组件及监听接口</strong></p><p>组件可以通过addxxxlistener方法注册监听器（监听器就是上面第二列）。</p><p><strong>适配器</strong></p><table><thead><tr><th>监听接口</th><th>监听器</th></tr></thead><tbody><tr><td>ComponentListener</td><td>ComponentAdapter</td></tr><tr><td>FocusListener</td><td>FocusAdapter</td></tr><tr><td>KeyListener</td><td>KeyAdapter</td></tr><tr><td>MouseListener</td><td>MouseAdapter</td></tr><tr><td>MouseMotionListener</td><td>MouseMotionAdapter</td></tr><tr><td>ContainerListener</td><td>ContainerAdapter</td></tr><tr><td>WindowListener</td><td>有</td></tr><tr><td>ItemListener</td><td>没有</td></tr><tr><td>ActionListener</td><td>没有</td></tr><tr><td>InputMethodListener</td><td>没有</td></tr></tbody></table><p>基本上有多个抽象方法的都有适配器</p><h1 id="AWT绘图"><a href="#AWT绘图" class="headerlink" title="AWT绘图"></a>AWT绘图</h1><p>在component中有两个和绘图有关方法：</p><ul><li>paint(Graphics g): 绘制组件外观</li><li>repaint(): 调用paint(),刷新组件的外观（对于awt组件来说调用repaint前还要调用update方法）</li></ul><p>在下列情况中，会调用paint：</p><ul><li>第一次显示在屏幕上时</li><li>组件大小发生变化时</li><li>调用repaint</li></ul><p>JComponent覆盖了paint，并将会话任务委托给三个protected的方法：</p><ul><li>paintComponent(): 画当前组件，</li><li>paintBorder(): 画边界</li><li>paintChildren(): 如果这个组件时容器，则画容器包含的组件</li></ul><p>JComponent会议组件背景色覆盖整个区域，所以如果画了图形想清除的话只需要调用super.paintComponent().</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorChange</span> <span class="keyword">extends</span> <span class="title">JPanel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Color color = Color.RED;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> times;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorChange</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"change color"</span>);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                color = (color==Color.RED) ? Color.GREEN : Color.RED;</span><br><span class="line">                repaint();<span class="comment">//刷新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add(button);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.paintComponent(g);<span class="comment">//清空画板</span></span><br><span class="line">        g.setColor(color);</span><br><span class="line">        g.fillReet(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);<span class="comment">//画矩形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame(<span class="string">"Hello"</span>);</span><br><span class="line">        frame.setContentPane(<span class="keyword">new</span> ColorChanger());</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面就重写了paintComponent方法，然后repaint()调用的就是重写后的方法。</p><h2 id="Graphics"><a href="#Graphics" class="headerlink" title="Graphics"></a>Graphics</h2><p>Graphics代表画笔，提供了各种绘制图形的方法：</p><ul><li>drawLine(int x1, int y1, int x2, int y2): 画一条直线</li><li>drawString(String string, int left, int bottom): 写字符串</li><li>drawImage(Image image, int left, int top, ImageObserver observer):画一个图片</li><li>drawRect(int left, int top, int width, int height): 画一个矩形</li><li>drawOval(int x, int y, int width, int height):画一个椭圆</li><li>fillRect(int left, int top, int width, int height): 填充矩形</li><li>fillOval(int x, int y, int width, int height): 填充一个椭圆</li></ul><p>其中left，top是左上角坐标。</p><p>如果没有调用Graphics的setColor()方法,将以前景色填充</p><p>使用完之后要用dispose()进行销毁</p><p>drawString(String str, int x, int y)将用当前画笔颜色和字体，将str显示.字符的左下角是(x,y)</p><h2 id="Graphics2D"><a href="#Graphics2D" class="headerlink" title="Graphics2D"></a>Graphics2D</h2><p>方法：</p><ul><li>setStroke(Stroke s)； 获得画笔的特性</li><li>draw(Shape shape): 滑参数指定的图形</li><li>fill(Shape shape): 填充参数指定的图形</li><li>translate(int x, int y)： 平移</li><li>rotate(double theta, double originX, double originY)：旋转</li><li>scale(double sx, double sy)： 缩放</li></ul><p>一般使用BasicStroke类。构造方法是<code>BasicStroke(float width, int cap, int join, float miterlimit, float[] dash, float_phase)</code>：</p><ul><li>width：笔画宽度，此宽度必须大于或等于0.0f。如果将宽度设置为0.0f，则将笔画设置为当前设备的默认宽度</li><li>cap：线端点的装饰</li><li>join：应用在路径线段交汇处的装饰</li><li>miterlimit：斜接处的裁剪限制。该参数值必须大于或等于1.0f</li><li>dash：表示虚线模式的数组</li><li>dash phase：开始虚线模式的偏移量</li></ul><p>他还有一些绘制图形的类</p><ul><li>java.awt.geom.Line2D: 画直线</li><li>java.awt.geom.Ellipse2D: 画椭圆</li><li>java.awt.geom.Rectangle2D: 画矩形</li></ul><p>上面这些画图形的都是抽象类，他们都有两个子类：Double和Float。例如LineD.Double。</p><p>上面这些实现类的构造方法和前面说的draw大致相似。</p><p>还可以利用java.awt.Toolkit的getScreenSize()来获得屏幕大小，从而设定JFrame大小。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>虚拟机中会创建一个专门的awt线程处理窗口，但是需要我们专门添加，添加代码<code>SwingUtilities.invokeLater(Runnable doRun)</code></p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处处于 主线程，提交任务到 事件调度线程 创建窗口</span></span><br><span class="line">        SwingUtilities.invokeLater(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                        <span class="comment">// 此处处于 事件调度线程</span></span><br><span class="line">                        createGUI();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>上面的线程只是用来创建窗口，绘图等不耗时的工作。<a href="https://blog.csdn.net/xietansheng/article/details/78389265" target="_blank" rel="external nofollow noopener noreferrer">详细可看</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 08:33:10 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;AWT-和-Swing&quot;&gt;&lt;a href=&quot;#AWT-和-Swing&quot; class=&quot;headerlink&quot; title=&quot;AWT 和 Sw
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 常用类</title>
    <link href="http://xinhecuican.github.io/post/85b4e13b.html"/>
    <id>http://xinhecuican.github.io/post/85b4e13b.html</id>
    <published>2020-05-29T11:14:00.000Z</published>
    <updated>2020-06-01T12:41:48.237Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 01 2020 20:41:48 GMT+0800 (中国标准时间) --><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Object是所有java类共同的祖先。如果没有用extends，那么这个类将直接继承Object类。</p><p>Object类有一个默认构造方法，构造子类实例时，都会优先使用这个构造方法。</p><p><code>public Object(){}</code></p><p>方法：</p><ul><li>equals(Object obj): 比较两个对象是否相等，只有当两个变量引用一个实例时才会为真。</li><li>notify()</li><li>notifyAll()</li><li>wait()</li><li>hashCode(): 返回对象哈希码。</li><li>toString(): 返回当前对象字符串表示。如果println方法参数时Object，那么先会调用toString()</li><li>finalize(): 垃圾回收时先调用这个方法</li><li>getClass(): 返回运行时类。java引用变量有两种类型，编译时类型和运行时类型。运行时类型就是引用的实例。</li></ul><h1 id="String-和-StringBuffer"><a href="#String-和-StringBuffer" class="headerlink" title="String 和 StringBuffer"></a>String 和 StringBuffer</h1><p>String是不可变类，里面字符串永远不会改变(也就是平常用双引号括起来的那些),StringBuffer是可变类</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>构造方法：</p><ul><li>String()</li><li>String(String value):</li><li>String(char[] value): 会把字符数组转换成字符串</li><li>String(byte[] bytes): 会用本地默认编码把字节数组变成字符串</li><li>String(byte[] bytes, String charsetName): 根据charsetName指定的编码，构造字符串。</li></ul><p>方法：</p><ul><li>length()</li><li>char charAt(int index): 返回index上的字符</li><li>getChars(int srcBegin, int srcEnd, char[] dst, int dstbegin): 从当前字符串复制字符到dst中，srcBegin开始取字符，到srcEnd-1结束</li><li>equals(object str): 判断两个字符串是否相等</li><li>equalsIgnoreCase()： 忽略大小写</li><li>int compareTo(String str): 比较字符串大小</li><li>indexOf()和lastIndexOf(): 在字符串中检索特定字符或字符串，indexOf()从开始位置查找，另一个从后面开始查找<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str.index<span class="constructor">Of('<span class="params">e</span>')</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str.index<span class="constructor">Of(<span class="string">"ea"</span>, 2)</span>); <span class="comment">//从2开始</span></span><br></pre></td></tr></table></figure></div></li><li>concat(String str): 把str加载末尾</li><li>substring(): 返回子串，参数中可以有开始和结束位置</li><li>String[] split(String regex): 根据参数把字符串分成几个子串，例如根据空格分隔</li><li>replaceAll(String regex, String replacement): 把原来字符串中regrex换成replacement。replaceFirst()只替换第一个</li><li>trim(): 把字符串首尾空格删除</li><li>String valueOf(): 把基本类型转换成String类型。</li><li>toUpperCast()/toLowerCast(): 把字符串变成大小写</li></ul><h3 id="“hello”-和-new-String-“hello”-区别"><a href="#“hello”-和-new-String-“hello”-区别" class="headerlink" title="“hello” 和 new String(“hello”)区别"></a>“hello” 和 new String(“hello”)区别</h3><p>第一种： String s1 = “hello”</p><p>第二种： String s2 = new String(“hello”)</p><p>第一种方式hello是立即数，Java虚拟机只会分配一次内存（在data节中）。第二种方式是建立一个对象，每次新建一个对象都会重新分配一次内存。所以用第一种方式赋相同值给两个变量用equal()比较时true，而而第二种不是。</p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>构造方法：</p><ul><li>StringBuffer()</li><li>StringBuffer(int length)</li><li>StringBuffer(String str)：缓冲区初始字符串是str，并且提供16字节的额外缓冲区</li></ul><p>方法：</p><ul><li>length()</li><li>append(): 向缓冲区内添加字符串</li><li>toString(): 返回缓冲区内字符串</li><li>charAt(int index)</li><li>setCharAt(int index, char c): 在index处放c</li><li>getChars(int Begin, int end, char[] dst, int dstBegin):</li><li>subString()</li><li>insert(int offset, String str): 在offset位置插入字符串（字符串首位置在offset处）</li></ul><h2 id="String和StringBuffer区别"><a href="#String和StringBuffer区别" class="headerlink" title="String和StringBuffer区别"></a>String和StringBuffer区别</h2><p>String是不可变类。即使看上去提供了replaceAll()的修改方法实际上它是创建了一个新的字符串。而StringBuffer是在自身基础上进行修改。</p><p>String覆盖了equals()方法。</p><p>String对象可以用+号进行拼接，而StringBuffer不可以</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>就是用一些特殊字符来代替多个字符进行匹配</p><table><thead><tr><th>特殊字符</th><th>作用</th></tr></thead><tbody><tr><td>.</td><td>任意字符</td></tr><tr><td>[…]</td><td>匹配中括号中所有数据，例如[abc]可以匹配a或b或c</td></tr><tr><td>[^…]</td><td>匹配除括号数据外的任意数据</td></tr><tr><td>\s</td><td>空白符（空格，tab，换行，换页，回车）</td></tr><tr><td>\S</td><td>非空白符</td></tr><tr><td>\d</td><td>任意数字</td></tr><tr><td>\D</td><td>任意非数字</td></tr><tr><td>\w</td><td>大小写字母和数字</td></tr><tr><td>\W</td><td>除了大小写和数字外的字符</td></tr></tbody></table><p><a href="https://xinhecuican.github.io/post/26477.html">更多可以看这里</a></p><h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><p>String类的静态方法format()用于创建格式化字符串</p><ul><li>String format(String format, Object… args)</li><li>String format(Locale locale, String format, Object… args): locale指定语言</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(String.format(Locale.CHINESE, "%tc", <span class="type">date</span>));</span><br></pre></td></tr></table></figure></div><h2 id="日期，时间格式化"><a href="#日期，时间格式化" class="headerlink" title="日期，时间格式化"></a>日期，时间格式化</h2><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>%tb</td><td>月份简称，8月</td></tr><tr><td>%dB</td><td>全称</td></tr><tr><td>%ta</td><td>星期几</td></tr><tr><td>%tA</td><td>星期几全称</td></tr><tr><td>%ty</td><td>2位年份，如20</td></tr><tr><td>%tY</td><td>4位年份，如2020</td></tr><tr><td>%tm</td><td>月份，08</td></tr><tr><td>%te</td><td>一月中第几天</td></tr><tr><td>%tj</td><td>一年中第几天</td></tr><tr><td>%tc</td><td>具体时间和日期</td></tr><tr><td>%tF</td><td>年-月-日，四位年</td></tr><tr><td>%tD</td><td>年/月/日，两位年</td></tr><tr><td><strong>时间</strong></td><td></td></tr><tr><td>%tH</td><td>24时制（00-23）</td></tr><tr><td>%tI</td><td>十二小时（01-12）</td></tr><tr><td>%tk</td><td>24时（0-23）</td></tr><tr><td>%tl</td><td>12时（0-12）</td></tr><tr><td>%tM</td><td>分钟</td></tr><tr><td>%tS</td><td>秒</td></tr><tr><td>%tL</td><td>毫秒</td></tr><tr><td>%tN</td><td>微秒</td></tr><tr><td>%tp</td><td>上午下午标记</td></tr><tr><td>%tz</td><td>时区偏移量</td></tr><tr><td>%tZ</td><td>时区缩写</td></tr></tbody></table><h2 id="常规类型"><a href="#常规类型" class="headerlink" title="常规类型"></a>常规类型</h2><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>%b</td><td>布尔类型</td></tr><tr><td>%B</td><td>大写</td></tr><tr><td>%h,%H</td><td>哈希码</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%S</td><td>大写字符串</td></tr><tr><td>%c</td><td>字符</td></tr><tr><td>%C</td><td>大写</td></tr><tr><td>%d</td><td>十进制整数</td></tr><tr><td>%o</td><td>八进制</td></tr><tr><td>%x</td><td>十六进制</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%e</td><td>科学记数法表示的十进制</td></tr><tr><td>%n</td><td>换行</td></tr></tbody></table><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Stirng</span>.</span></span>format(<span class="string">"hi%s"</span>, <span class="string">"小红"</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"%c%n"</span>, <span class="character">'A'</span>);</span><br></pre></td></tr></table></figure></div><p>使用大致和c语言类似。</p><table><thead><tr><th>转换符号</th><th>含义</th></tr></thead><tbody><tr><td>转换符号</td><td>它是在%后面字符前面的,例如”%+d”</td></tr><tr><td>+</td><td>为数字添加正负号</td></tr><tr><td>-</td><td>左对齐</td></tr><tr><td>0</td><td>数字前补零，例如 “%04d” 表示如果数字不满四位前面要补零</td></tr><tr><td>(</td><td>添加括号，例如(“%(d”, 99) ,输出 (99)</td></tr><tr><td>#</td><td>如果是十六或十进制前面添加0x或0,如果是浮点数添加小数点</td></tr></tbody></table><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>每个基本类型都有一个包装类。包装类就是对应基本类型然后首字母大写（int,char除外）。例如int Integer float Float.char是Character</p><p>构造方法：</p><p>都可以用字符串作为参数来构造。Boolean类型可以用”true”或”false”。</p><p>除了Character和Boolean外其他类都是继承于Number类。</p><p>Number类方法如下：</p><ul><li><p>byteValue(): 返回Number对象的byte类型</p></li><li><p>intValue():</p></li><li><p>longValue()</p></li><li><p>shortValue()</p></li><li><p>doubleValue()</p></li><li><p>floatValue()</p></li><li><p>包装类都覆盖了toString()方法</p></li><li><p>都有parsexxx(String str)静态方法，可以把字符串转化成相应数据。例如parseint(“123”)</p></li></ul><h3 id="包装类自动装箱和拆箱"><a href="#包装类自动装箱和拆箱" class="headerlink" title="包装类自动装箱和拆箱"></a>包装类自动装箱和拆箱</h3><p>就是在基本类型和包装类之间进行转换。可以直接用基本类型赋值给包装类，也可以直接用包装类赋值给基本类型。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EBNF"><figure class="iseeu highlight /ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Integer a</span> = 3;</span><br><span class="line"><span class="attribute">int b</span> = new Integer(4);</span><br></pre></td></tr></table></figure></div><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>Math类里面基本上都是静态方法，并且他的构造方法时private，不能有实例。而且是final类型，不能有子类。</p><p>方法：</p><ul><li>abs()</li><li>ceil(): 向上取整</li><li>floor(): 向下取整</li><li>max()</li><li>min()</li><li>random(): 返回0到1间double类型的随机数。包括0，不包括1</li><li>round(): 四舍五入整数</li><li>sin()</li><li>cos()</li><li>tan()</li><li>exp(): 根号x</li><li>sqrt(): x的平方</li><li>pow(): 幂运算</li></ul><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>和Math类似</p><p>方法：</p><ul><li>nextInt(): 返回一个int型随机数，随机数大于等于0</li><li>nextInt(int n): n是随机数最大值</li><li>nextLong()</li><li>nextFloat()</li><li>nextDouble()</li><li>nextBoolean()</li></ul><h2 id="处理时间类"><a href="#处理时间类" class="headerlink" title="处理时间类"></a>处理时间类</h2><p><strong>Date</strong></p><p>Date类以毫秒方法日期。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.prtinln(<span class="type">date</span>);</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Sun Aug21 <span class="number">17</span>:<span class="number">32</span>:<span class="number">05</span> CST <span class="number">2016</span></span><br></pre></td></tr></table></figure></div><p><strong>DateFormat</strong></p><p>它可以定制日期格式</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LASSO"><figure class="iseeu highlight /lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>();</span><br><span class="line">SimpleDateFormat f = <span class="literal">new</span> SimpleDateFormat(<span class="string">"yyyy-MMMM-dd-EEEE"</span>);</span><br><span class="line">这些都是表示显示几位的年月日的.E是星期</span><br></pre></td></tr></table></figure></div><h2 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger BigDecimal"></a>BigInteger BigDecimal</h2><p>BigInteger可以接受任意位的整数运算。他有add(BigInteger b),subtract(BigInteger b) multiply(BigInteger b) divide(BigInteger b)等方法来进行四则运算</p><p>BigDecimal可以进行精确的浮点数运算。对于加减乘都是准确的，对于除法可以指定小数位和舍入模式。</p><p>divide(BigDeciaml b, int scale, RoundingMode more)more是舍入模式。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 01 2020 20:41:48 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://xinhecuican.github.io/post/a444b428.html"/>
    <id>http://xinhecuican.github.io/post/a444b428.html</id>
    <published>2020-05-25T05:32:00.000Z</published>
    <updated>2020-06-29T06:35:44.518Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 29 2020 14:35:44 GMT+0800 (中国标准时间) --><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>稳定？不稳定： 稳定指的是两个相同的元素排序完成之后在表中相对位置不变。</p><h2 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h2><p>当插入第i个时，前i-1个已经排好了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        tag = a[i];</span><br><span class="line">        <span class="built_in">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i<span class="number">-1</span>; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k]&gt;tag)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">                temp = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[k+<span class="number">1</span>] = tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>默认第一个已经排好，从第二个开始从后往前排，如果第k个数比要比较的数大就把这个数往后排。</p><p>复杂度： n^2</p><h2 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h2><p>折半排序基于前面的直接插入，不同的是它通过二分找插入位置。然后再移动</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    tag = a[i];</span><br><span class="line">    <span class="built_in">int</span> low=<span class="number">0</span>, high=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;tag)</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//high+1是插入位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=i<span class="number">-1</span>; k&gt;=high+<span class="number">1</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    a[high+<span class="number">1</span>] = tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度 n^2</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>思想： 把序列按gap划分成若干个子序列。例如有6个元素，gap是3，那么第0个和第3个是一个序列，第1个和第4个是一个序列。之后在每个子序列中直接插入。然后折半缩小gap。</p><p>第一个gap一般取n/2。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> gap = n/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(gap != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=gap; i&lt;n; i++)<span class="comment">//从gap开始是因为直接插入排序中默认第一个已经排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        tag = a[i];</span><br><span class="line">        <span class="built_in">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i-gap; k&gt;=<span class="number">0</span>; k-=gap)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k]&gt;tag)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k+tag] = a[k];</span><br><span class="line">                temp = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[temp+tag] = tag;</span><br><span class="line">    &#125;</span><br><span class="line">    gap /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度：n(longn)^2。但这是一种不稳定的排序</p><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><p>起泡排序是过程是逐个比较，比较出最小的放到第一个，然后放到第二个。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> flag=<span class="number">0</span>,exchange=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag&lt;n<span class="number">-1</span> &amp;&amp; exchange==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    exchange = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n<span class="number">-1</span>; i&gt;flag; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a[i<span class="number">-1</span>] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            a[i] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            a[i<span class="number">-1</span>] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            exchange = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这一步后小的在前面，然后下一次又是把i-1和i-2比，如果i-1小，又跑到前面</span></span><br><span class="line">        <span class="comment">//这样第i-1个一直是最小的（相对于它后面的元素）</span></span><br><span class="line">    &#125;</span><br><span class="line">    flag++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度 n^2</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><a href="https://xinhecuican.github.io/post/11306.html">以前的一篇</a></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><p>这个就不多说了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> min = <span class="number">2147483647</span>;</span><br><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=i+<span class="number">1</span>; k&lt;n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[k]&lt;min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = a[k];</span><br><span class="line">            tag = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap（a[i], a[tag]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是完全二叉树产生的数组。然后建立一个父节点比子节点大/小的数组。父节点比子节点大的叫大顶堆，父节点比子节点小的叫小顶堆。</p><p>假设父节点是i，那么两个子节点分别是i<em>2和i</em>2+1。下标要从1开始</p><p>过程，以小顶堆为例</p><ul><li>初始化，首先构造一个大顶堆，过程是用这个节点和它的父节点进行比较，如果小就交换位置，然后再和新位置的父节点进行比较。先拿第一个数和第二个数进行比较，如果第一个数比第二个数小那个交换位置。然后第三个数和第一个数比较。此外，还可以从小到大直接建</li></ul><p>之后第4个数是插入到第二个数上的，就拿第四个数和第二个数比较，如果第四个数比第二个数小就把第二个数往上提，之后再和第一个数进行比较。然后依此类推。</p><p><img src="/images/%E6%8E%92%E5%BA%8F.png" alt></p><ul><li>把第一个元素和最后一个元素进行交换，然后对前n-1个元素进行处理。开始我们建立的是大顶堆，现在我们把最大的放到后面就变成小顶堆了。并且这时不仅满足小顶堆，还满足左儿子一定比右儿子小。</li></ul><p><img src="/images/%E6%8E%92%E5%BA%8F2.png" alt></p><ul><li>之后就是用根节点左右儿子中比较大的节点和根节点进行比较。然后如果比根节点大就进行换位。然后再在新位置和新的子节点进行比较。完成之后又把根节点放到最后。之后就重复第二步和第三步。（不画图了，难死我了）</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据上面自己写的，拿过几个数据代过，如果想看更标准的可以看下面模板(饶命)</span></span><br><span class="line"><span class="built_in">void</span> Heap(<span class="built_in">int</span> *a, <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> now = i;</span><br><span class="line">        <span class="keyword">while</span>((now&lt;&lt;<span class="number">1</span>) &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> largest ;</span><br><span class="line">            <span class="built_in">int</span> l = now &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> r = (now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span> == n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[l] &gt; a[now])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">int</span> temp = a[l];</span><br><span class="line">                    a[l] = a[now];</span><br><span class="line">                    a[now] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[l] &gt; a[r])</span><br><span class="line">            &#123;</span><br><span class="line">                largest = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                largest = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[largest] &gt; a[now])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = a[largest];</span><br><span class="line">                a[largest] = a[now];</span><br><span class="line">                a[now] = temp;</span><br><span class="line">                now = largest;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//初始化</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">1</span>] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        a[i] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((now&lt;&lt;<span class="number">1</span>) &lt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> big;</span><br><span class="line">            <span class="keyword">if</span>((now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span> == i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = now&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[now] &lt; a[temp])</span><br><span class="line">                &#123;</span><br><span class="line">                    a[now] = a[temp] ^ a[now];</span><br><span class="line">                    a[temp] = a[temp] ^ a[now];</span><br><span class="line">                    a[now] = a[temp] ^ a[now];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//只有左节点</span></span><br><span class="line">            <span class="keyword">if</span>(a[now&lt;&lt;<span class="number">1</span>] &lt; a[(now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                big = (now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                big = now&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[big] &gt; a[now])</span><br><span class="line">            &#123;</span><br><span class="line">                a[big] = a[big] ^ a[now];</span><br><span class="line">                a[now] = a[big] ^ a[now];</span><br><span class="line">                a[big] = a[big] ^ a[now];</span><br><span class="line">                now = big;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>模板</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆长度</span></span><br><span class="line"><span class="built_in">int</span> heapsize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//大顶堆化</span></span><br><span class="line"><span class="built_in">void</span> MAX_HEAPIFY(<span class="built_in">int</span> A[], <span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> l = <span class="number">2</span> * i;<span class="comment">//把 i 的左儿子 下标 赋给l</span></span><br><span class="line"><span class="built_in">int</span> r = <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//把 i 的左儿子 下标 赋给r</span></span><br><span class="line"><span class="built_in">int</span> largest;<span class="comment">//3个里面最大的下标</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (l &lt;= heapsize &amp;&amp; A[l]&gt;A[i])</span><br><span class="line">largest = l;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">largest = i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (r &lt;= heapsize &amp;&amp; A[r]&gt;A[largest])</span><br><span class="line">largest = r;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (largest != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换 A[largest] 和 A[i]</span></span><br><span class="line"><span class="built_in">int</span> tmp = A[largest];</span><br><span class="line">A[largest] = A[i];</span><br><span class="line">A[i] = tmp;</span><br><span class="line"> </span><br><span class="line">MAX_HEAPIFY(A, largest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="built_in">void</span> BUILD_MAX_HEAP(<span class="built_in">int</span> A[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = (<span class="built_in">int</span>)(heapsize / <span class="number">2</span>); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">MAX_HEAPIFY(A, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">printf(<span class="string">"%d "</span>, A[j]);</span><br><span class="line">printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="built_in">void</span> HEAPSORT(<span class="built_in">int</span> A[])</span><br><span class="line">&#123;</span><br><span class="line">BUILD_MAX_HEAP(A);<span class="comment">//ok</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="built_in">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (i = heapsize; i &gt;= <span class="number">2</span>; i--)<span class="comment">//A[1] 必定是最大的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换 A[1] 和 A[i]</span></span><br><span class="line">tmp = A[<span class="number">1</span>];</span><br><span class="line">A[<span class="number">1</span>] = A[i];</span><br><span class="line">A[i] = tmp;</span><br><span class="line"> </span><br><span class="line">heapsize--;</span><br><span class="line">MAX_HEAPIFY(A, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> A[<span class="number">11</span>] = &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//ok</span></span><br><span class="line"><span class="built_in">int</span> n = sizeof(A) / sizeof(<span class="built_in">int</span>) - <span class="number">1</span>;</span><br><span class="line">heapsize = n;</span><br><span class="line"> </span><br><span class="line">HEAPSORT(A);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">printf(<span class="string">"%d "</span>, A[i]);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度： nlogn.但是不稳定</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><a href="https://xinhecuican.github.io/post/63711.html">以前博客</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 29 2020 14:35:44 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>java I/O</title>
    <link href="http://xinhecuican.github.io/post/5be7e977.html"/>
    <id>http://xinhecuican.github.io/post/5be7e977.html</id>
    <published>2020-05-24T10:21:00.000Z</published>
    <updated>2020-06-07T06:45:14.328Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 08 2020 10:32:14 GMT+0800 (中国标准时间) --><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java.io.InputStream代表字节输入流，java.io.OutputStream代表输出流。他们都是抽象类，InputStream中有以下方法：</p><ul><li>int read():读入一个字节，并且转化成unsigned int型整数</li><li>int read(byte[] b): 从输入流中读取若干字节，保存在b数组中。如果到了输入流的结尾，返回1</li><li>int read(byte[] b, int off, int len): 如上，这里只是多了在b数组中的开始位置和读取数目</li><li>void close()： 关闭输入流。如果不关闭的话其他需要这个文件的就无法读取这个文件信息。类似于打开了一个应用程序再打开就说有一个实例正在运行。</li><li>int available(): 放回从输入流中读取字节数目</li><li>skip(long n): 从输入流中跳过n个字节</li><li>boolean markSupported(),void mark(int readLimit), void reset(): 如果想要重复读入数据，就先用markSupported()判断这个流是否支持重复读入数据，如果支持，通过mark在当前位置开始设置readLimit字节的标记，然后用reset()可以使输入流定位到做标记的起始位置，然后通过read()就可以重复读数据了。</li></ul><p>OutputStream中方法：</p><ul><li>void write(): 输出一个字节</li><li>void write(byte[] b): 同上</li><li>void write(byte[] b, int off, int len): 同上</li><li>void close()</li><li>void flush(): OutputStream本身的flush()不执行操作。但是如果是一些有缓冲区机制的实现类就有用了。在有缓冲区的输出流中，一般都是先把输出存在缓冲区中，等到了一定大小才会输出，<strong>这个方法的作用是强制输出缓冲区中数据</strong>。</li></ul><p>设置缓冲区的原因是输出并不是直接输出到屏幕中间要经历一系列的过程，耗时比较长，如果先存到缓冲区然后一次性输出就可以减少时间。</p><h1 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h1><h2 id="ByteArrayInputStream-字节数组输入流"><a href="#ByteArrayInputStream-字节数组输入流" class="headerlink" title="ByteArrayInputStream,字节数组输入流"></a>ByteArrayInputStream,字节数组输入流</h2><p>这个类从字节数组读取数据，可能会想直接用字符数组不就行了吗，为什么还要弄一个输入流类。ByteArrayInputStream实际上是一个<a href="https://xinhecuican.github.io/post/5951da65.html">适配器</a></p><p>构造方法：</p><p>ByteArrayInputStream(byte[] buf)</p><p>ByteArrayInputStream(byte[] buf, int offset, int length)</p><p>使用就是用上面的方法</p><h2 id="FileInputStream文件输入流"><a href="#FileInputStream文件输入流" class="headerlink" title="FileInputStream文件输入流"></a>FileInputStream文件输入流</h2><p>构造方法：</p><p>FileInputStream(File file)</p><p>FileInputStream(String name):通过name指定路径</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamTester</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span>((data=in.<span class="built_in">read</span>()) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(data+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果文件很大，为了提高读取效率，可以利用一个缓冲区。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        final <span class="keyword">int</span> SIZE = <span class="number">1024</span>;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FIleOutputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">        <span class="keyword">int</span> len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        <span class="keyword">while</span>(len != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out.<span class="built_in">write</span>(buff, <span class="number">0</span>, len);</span><br><span class="line">            len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">        out.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果要打开的文件和这个类在同一文件夹下，可以用Class类的个体ResourceAsStream()方法,<strong>这时可以用相对路径</strong>。例如：</p><p><code>InputStream in = UseBuffer.getClass().getResourceAsStream(&quot;test.txt&quot;);</code></p><h2 id="PipedInputStream管道输入流"><a href="#PipedInputStream管道输入流" class="headerlink" title="PipedInputStream管道输入流"></a>PipedInputStream管道输入流</h2><p>管道输入流是从管道输出流中读取数据的。一般是一个线程从管道中输出，然后另外一个接受。使用管道的优点是如果管道中没有数据就会阻塞，有数据才会恢复运行，这样就可以对产生的数据进行处理。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Sender extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PipedOnputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getPipedOutputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-127</span>; i&lt;=<span class="number">128</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                out.<span class="built_in">write</span>(i);</span><br><span class="line">                <span class="built_in">yield</span>();<span class="comment">//让步给sender处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            out.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="title">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">private</span> PipedInputStream in;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span><span class="params">(Sender sender)</span><span class="keyword">throw</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//通过这个构造方法确定了两者的关系</span></span><br><span class="line">            in = <span class="keyword">new</span> PipedInputStream(sender.getPepedOutputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data;</span><br><span class="line">            <span class="keyword">while</span>((data=in.<span class="built_in">read</span>()) != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(data):</span><br><span class="line">            &#125;</span><br><span class="line">            in.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h2 id="SequenceInputStream-顺序输入流"><a href="#SequenceInputStream-顺序输入流" class="headerlink" title="SequenceInputStream 顺序输入流"></a>SequenceInputStream 顺序输入流</h2><p>它可以把几个输入流混合到一起输入。</p><p>构造方法：</p><p>SequenceInputStream(Enumeration e): e是枚举类型，包含若干个输入流</p><p>SequenceInputStream(InputStream s1, InputStream s2):只合并两个</p><p>它关闭的时候只需要关闭SequenceInputStream就会一次关闭所有的输入流。</p><h2 id="装饰器设计模式"><a href="#装饰器设计模式" class="headerlink" title="装饰器设计模式"></a>装饰器设计模式</h2><p>假设有一个类要子类实现三种方法，并且有的子类只需要实现一个，有的要实现多个，那么就要2^3-1个子类，数量过多。我们可以采用装饰器思想减少子类数目。</p><p>装饰器也是一个子类。这个子类的特殊之处在于他实现了某一个方法并且它内部封装了父类的实例。它的构造方法是：<code>decorate(Base base)</code></p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">B </span><span class="keyword">extends </span>A</span><br><span class="line"></span><br><span class="line"><span class="keyword">B </span><span class="keyword">b </span>= new <span class="keyword">B();</span></span><br><span class="line"><span class="keyword">decorate1 </span>dec1 = new decorate1(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec1.method1();</span></span><br><span class="line"><span class="keyword">decorate2 </span>dec2 = new decorate2(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec2.method2();</span></span><br></pre></td></tr></table></figure></div><h2 id="FilterInputStream-过滤输入流"><a href="#FilterInputStream-过滤输入流" class="headerlink" title="FilterInputStream 过滤输入流"></a>FilterInputStream 过滤输入流</h2><p>过滤输入流其实就是一个装饰器</p><p><strong>种类</strong></p><table><thead><tr><th>过滤输入流</th><th>描述</th></tr></thead><tbody><tr><td>DataInputStream</td><td>与DataOutputStream搭配使用，按照和平台无关的方式从流中读取基本类型（int，char，long等）</td></tr><tr><td>BufferedInputStream</td><td>利用缓冲区提高效率</td></tr><tr><td>PushbackInputStream</td><td>把督导的一个字节压回缓冲区中，编译器用</td></tr></tbody></table><p>这些都是FileterInputStream的子类,并且也是装饰器。</p><h3 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h3><p>它的不同方法可以按不同编码读取数据，并且都是以read开头：</p><ul><li>readByte()</li><li>readLong()</li><li>readFloat()</li><li>readUTF(): 从输入流中读取若干字节，并转化成UTF-8编码字符串</li></ul><p>UTF-8如果是ascii就只用一个字节，如果是其他字符就用两个或两个以上字节。</p><p>DataInputStream应该和DataOutputStream配套使用。只有配套使用才会保证数据的正确性（因为这里的UTF-8是java本土化的UTF-8,本来的UTF-8好像是稳定3个字节的）。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileOutputStream out1 = <span class="keyword">new</span> <span class="type">FileOutputStream</span>();</span><br><span class="line">        BufferedOutputStream out2 = <span class="keyword">new</span> <span class="type">BufferedOutputStream</span>(out1);</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> <span class="type">DataOutputStream</span>(out2);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><p>BufferedInputStream覆盖了读数据的行为，它利用缓冲区提高读取的效率。</p><p>构造方法：</p><ul><li>BufferedInputStream(InputStream in)</li><li>BufferedInputStream(InputStream in, int size):size指定缓冲区大小</li></ul><p>当数据源是文件时，可以用BufferedInputStream装饰数据流，然后再进行其他操作可以提高效率。</p><h3 id="PushbackInputStream"><a href="#PushbackInputStream" class="headerlink" title="PushbackInputStream"></a>PushbackInputStream</h3><p>它有一个后推缓冲区，用于存放已经读入的字节。</p><h1 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h1><p>输出流种类和输入流大致类似，sequenceInputStream对应的没有了，多了ObjectOutputStream。</p><p>ByteArrayOutputStream是把信息输出到字节数组中。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ByteArrayOutputStream <span class="keyword">out</span> = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">out</span>.write(<span class="string">"你好"</span>.getBytes(<span class="string">"UTF-8"</span>);<span class="comment">//String的getBytes可以放回制定类型的编码</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">out</span>.toByteArray();<span class="comment">//获得字符数组的方法</span></span><br><span class="line">        <span class="keyword">out</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>先用write把要输入的数据输入到输出流中，然后通过toByteArray方法输出到字节数组中。</p><p><strong>文件输出流</strong></p><p>前面大致类似，多了一种构造方法<code>FileOutputStream(String name, boolean append)</code></p><p>其中append是为了确定是不是要在末尾追加数据。</p><h2 id="FilterOutputStream-过滤输出流"><a href="#FilterOutputStream-过滤输出流" class="headerlink" title="FilterOutputStream 过滤输出流"></a>FilterOutputStream 过滤输出流</h2><p>同样有DataOutputStream和BufferedOutputStream，大致和输入流类似，多了一种PrintStream类</p><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><p>PrintStream和DataOutputStream类似，都可以输出格式化数据。他有如下方法。</p><ul><li>print(int i): 输出一个int</li><li>print(float i):</li><li>print(String i):</li><li>println(int i): 输出int型数据和换行符</li><li>println(float f):</li><li>println(String s):</li></ul><p>前面提到过，DataOutputStream和DataInputStream最好匹配使用是因为他们使用了特殊化的UTF-8编码。而PrintStream使用的是普通的UTF-8编码。</p><p>PrintStream的print()没有抛出IOException，但是他有checkError()判断写数据是否成功，如果返回true，则代表出现了错误。</p><p>PrintStream自带缓冲区。但是这和BufferedInputStream提供的缓冲区还有所不同。后者只有缓冲区满的时候才会输出，前者可以由用户决定数据量多少的时候输出。当然，默认还是满的时候输出。PrintStream还提供了一个自动化的输出方案：</p><ul><li>PrintStream(OutputStream out, boolean autoFlash)。当满足以下情况就会自动输出<ul><li>输出一个字节数组</li><li>输出一个换行符，即执行print(“\n”)或println()<h1 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader/Writer"></a>Reader/Writer</h1></li></ul></li></ul><p>InputStream和OutputStream处理的是字节，但是在很多场合要处理的是字符（java中字符时2字节）。Reader和Writer就是处理这些的。</p><p>java中字符时Unicode编码，但是文本文件中不一定是Unidcode编码，还有可能是UTF-8，GBK甚至ascii，因此如何处理不同类型编码就是一个难点。</p><p>String的getBytes(String encode)返回特定类型的编码，encode参数指定编码类型。如果不带参数就使用本地操作系统默认编码。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获得本地编码</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">"file.encoding"</span>)</span>);</span><br><span class="line">或：</span><br><span class="line">Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(cs);</span><br></pre></td></tr></table></figure></div><p>Reader类可以把其他类型的编码转换成java所使用的编码。Writer可以把Unicode转换成其他类型的编码。</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>Reader和InputStream类的种类大致类似.</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>CharArrayReader</td><td>把字符数组转换成Reader，从字符数组中读取字符</td></tr><tr><td>BufferedReader</td><td>装饰器，提供缓冲区。同时他的readLine()方法还可以读入一个字符串</td></tr><tr><td>LineNumberReader</td><td>提供缓冲区。并且可以跟踪字符输入流中中的行号</td></tr><tr><td>StringReader</td><td>把字符串转成Reader（数据源是字符串，和CharArrayReader类似），从字符串中读字符</td></tr><tr><td>PipedReader</td><td>连接PipedWriter</td></tr><tr><td>FilterReader</td><td>扩展其他Reader功能</td></tr><tr><td>InputStreamReader</td><td>把InputStream转换成Reader，可以指定数据源编码</td></tr><tr><td>FileReader</td><td></td></tr></tbody></table><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>构造方法：</p><ul><li>InputStreamReader(InputStream in): 按照本地的字符编码解读输入流中的字符</li><li>InputStreamReader(InputStream in, String charsetName): 按照charsetName指定的方式读取输入流中的字符</li></ul><p>这里的read读出来的不是一个字节而是一个字符</p><p>一些常用的方法：</p><ul><li>readLine(),一次读入一行</li><li>readFile(String fileName, String charsetName):从文件中读取字符串，并输出到控制台中</li><li>copyFile(String from, String charsetFrom, String to, String charsetTo): 把原文件复制到目标文件中，可以指定文件编码</li></ul><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>Writer和OutputStream大致类似，也有PrintWriter,区别是PrintStream只能用系统本地编码，而PrintWriter可以使用任意编码。PrintWriter构造方法：</p><ul><li>PrintWriter(Writer writer, boolean autoFlush)</li><li>PrintWriter(OutputStream out, boolean autoFlush)</li></ul><h1 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h1><p>在System类中，有三个静态变量：</p><ul><li>System.in: 代表标准输入流。默认输入时键盘</li><li>System.out: 是PrintStream类型（所以方法和PrintStream一样）。</li><li>System.err: 代表错误输出流，默认输出时输出到控制台。</li></ul><h2 id="对标准输入输出包装"><a href="#对标准输入输出包装" class="headerlink" title="对标准输入输出包装"></a>对标准输入输出包装</h2><p>可以利用到前面所学的只是对标准输入输出进行包装。System.in是InputStream类型，可以先用InputStreamReader变成Reader，然后在用BufferedReader装饰。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> <span class="constructor">InputStreamReader(System.<span class="params">in</span>)</span>;</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> <span class="constructor">BufferedReader(<span class="params">reader</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>重定向方法：</p><ul><li>setIn(InputStream, in): 对标准输入重定向</li><li>setOut(printStream out):</li><li>setErr(PrintStream out):</li></ul><p>这些方法时System的静态方法，所以写的时候是System.setIn()</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void redirect(InputStream <span class="keyword">in</span>, PrintStream out, PrintStream err)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">In(<span class="params">in</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Out(<span class="params">out</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Err(<span class="params">err</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String<span class="literal">[]</span> args)throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    InputStream stdin = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span><span class="keyword">in</span>;</span><br><span class="line">    PrintStream stdout = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out;</span><br><span class="line">    PrintStream stderr = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>err;</span><br><span class="line">    InputStream <span class="keyword">in</span> = <span class="keyword">new</span> <span class="constructor">BufferedInputStream(<span class="string">"D:\\temp.txt"</span>)</span>;</span><br><span class="line">    PrintStream out = <span class="keyword">new</span> <span class="constructor">BufferedOutputStream(<span class="string">"D:\\tempout.txt"</span>)</span>;</span><br><span class="line">    redirect(<span class="keyword">in</span>, out, stderr);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="RandomAccessFile-随机访问文件"><a href="#RandomAccessFile-随机访问文件" class="headerlink" title="RandomAccessFile 随机访问文件"></a>RandomAccessFile 随机访问文件</h1><p>随机访问文件就是可以从文件任意位置读写数据，他有如下定位方法：</p><ul><li>getFilePointer(): 返回当前位置</li><li>seeek(long pos): 设置位置，与未见开头相距pos</li><li>skipBytes(int n): 从当前开始跳过n个字节</li><li>length(): 返回文件包含的字节数</li></ul><p>RandomAccessFile实现了DataInput和DataOutput接口，可以读取格式化数据；</p><ul><li>RandomAccessFile(File file, String mode)</li><li>RandomAccessFile(String name, String mode):name指定路径</li></ul><p>其中mode是访问模式，可以有”r”和”rw”。表示只读和读写，但是”w”是非法的。</p><h1 id="新-I-O库"><a href="#新-I-O库" class="headerlink" title="新 I/O库"></a>新 I/O库</h1><p>这些类位于java.nio包中，nio是newio。他映入了四个数据类型</p><ul><li>Buffer： 缓冲区</li><li>Charset： 把Unicode和其他类型相互转换</li><li>Channel： 数据传送通道，把Buffer内容输出或读入到Buffer</li><li>Selector： 支持异步I/O操作，也叫非阻塞I/O操作</li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>缓冲区有两个作用：</p><ul><li>减少读取次数</li><li>和<a href="https://xinhecuican.github.io/post/7d1c86da.html">高速缓存</a>有关，这一段内存一直被重用。</li></ul><p>层次：<br><img src="/images/java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.jpg" alt></p><p>他有以下属性：</p><ul><li>容量</li><li>极限： 表示当前所使用缓冲区大小.极限可以修改</li><li>位置： 表示<strong>下一个</strong>读写单元位置</li></ul><p>他有如下设置属性方法：</p><ul><li>clear(): 把极限设置成容量，并且把位置变成0</li><li>flip(): 把极限设置成位置，然后把位置变成0</li><li>rewind(): 不改变极限，把位置变成0</li></ul><p>Buffer类是一个抽象类，他有8个具体类。最基本的是ByteBuffer类，他没有公开构造方法，但是有静态工厂。</p><ul><li>allocate(int capacity):</li><li>directAllocate(int capacity): 返回一个直接缓冲区。直接缓冲区速度较快，但是分配所需时间较多，所以一般只在所需空间较大并且长期使用的情况下才会用它。</li></ul><p>除了boolean类型之外，其他类型都有缓冲区（感觉和c的allocate有点类似），例如LongBuffer。此外，还有一种MappedByteBuffer，这是ByteBuffer的子类。它可以把缓冲区和文件某个区域直接映射（输出）。</p><p>共用方法：</p><ul><li>get(): 从当前位置读一个单元，然后位置加*ex位置读一个单元</li><li>put(): 向当前位置写入一个数据，然后位置加1</li><li>put(int index):</li></ul><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel用来连接缓冲区和数据源。它是一个接口，有两个方法：</p><ul><li>close(): 关闭通道</li><li>isOpen(): 判断通道是否打开</li></ul><p>通道会在创建时被打开，一旦被关闭就不能再次打开。</p><p>子接口ReadableByteChannel声明了read(ByteBuffer dst),把数据源数据读入到缓冲区中。WritableByteChannel声明了write(ByteBuffer src)，这个把src缓冲区中的数据输出。</p><p>ByteChannel扩展了上面说的两个接口，可以同时读写</p><p>ScatteringByteChannel扩展了ReadableByteChannel，可以分散读取数据。分散读取是指可以一次把数据放到多个缓冲区中。</p><p>GatheringByteChannel接口扩展了WritableByteChannel,可以把多个缓冲区中的数据一次性输出。他的wirte(ByteBuffer[] srcs)用来输出数据。</p><p><strong>这些方法都是缓冲区没满就继续读入</strong></p><p>FileChannel是Channel的实现类，他实现了ByteChannel，ScatteringByteChannel，GatheringByteChannel接口。支持上面所有操作。但是他没有公开构造方法，但是FileInputStream，FileOutputStream，RandomAccessFile类中提供了getChannel()方法，返回相应的FileChannel对象。</p><h2 id="Charset"><a href="#Charset" class="headerlink" title="Charset"></a>Charset</h2><p>Charset类每个实例代表特定的字符编码类型。他有以下用于编码转换的方法：</p><ul><li>ByteBuffer encode(String str): 把str转换成当前编码</li><li>ByteBuffer encode(CharBuffer cb): 把cb指定的字符缓冲区变成当前编码</li><li>CharBuffer decode(ByteBuffer bb): 把bb指定的ByteBuffer变成Unicode编码</li></ul><p>Charset有一个defaultCharset(): 返回代表本地平台编码的Charset对象。</p><h2 id="FileChannel读写文件"><a href="#FileChannel读写文件" class="headerlink" title="FileChannel读写文件"></a>FileChannel读写文件</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">&#123;</span><br><span class="line">    final <span class="built_in">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    FileChannel fc = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">"你好"</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//向文件末尾添加</span></span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">RandomAccessFile(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.position(fc.size<span class="literal">()</span>);<span class="comment">//定位到文件末尾</span></span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">"朋友"</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    </span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    ByteBuffer buff = <span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>allocate(BSIZE);</span><br><span class="line">    fc.read(buff);</span><br><span class="line">    buff.flip<span class="literal">()</span>;</span><br><span class="line">    Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(cs.decode(buff));</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><strong>控制缓冲区</strong></p><p>前面说的clear(),flip，rewind看似没用，但是它可以方便我们读入输出数据</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">buff </span>= <span class="keyword">ByteBuffer.allocate(BSIZE);</span></span><br><span class="line"><span class="keyword">while(in.read(buff) </span>!= -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">buff.flip();</span></span><br><span class="line"><span class="keyword"> </span>   out.write(<span class="keyword">buff);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">buff.clear();</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这段代码前面的flip是为了保证只操作当前数据，而clear()是为了保证接受尽可能多的数据。</p><p><strong>字符编码转换</strong></p><p>CharBuffer存放的数据单元室Unicode字符，ByteBuffer中的asCharBuffer()可以把Byte中数据转换成Unicode字符，并且存放在CharBuffer中。</p><h2 id="缓冲区视图"><a href="#缓冲区视图" class="headerlink" title="缓冲区视图"></a>缓冲区视图</h2><p>ByteBuffer类提供了asCharBuffer(),asIntBuffer(),和asFloatBuffer()来生成视图。通过视图，可以读取或写入各种类型的数据。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span>(bb.hasRemaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    bb.rewind();</span><br><span class="line">    CharBuffer cb = bb.asCharBuffer();</span><br><span class="line">    cb.<span class="built_in">put</span>(<span class="string">"你好"</span>);</span><br><span class="line">    whlie(bb.hasremaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h2><p>用于创建和修改那些因为太大而不能放入内存的文件。</p><p>FIleChannel类提供了获得MappedByteBuffer的map方法：</p><ul><li>MappedByteBuffer map(FIleChannel.MapMode mode, long position, long size)</li></ul><p>position是文件映射起始位置，size是映射区域大小，mode是模式，有三种：</p><ul><li>MapMode.READ_ONLY</li><li>READ_WRITE</li><li>MapMode.PRIVATE: 对MappedByteBuffer的修改不会保存到文件中，且其他程序不可见。</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">0x8000000</span>;</span><br><span class="line">    MappedByteBuffer mb = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D:\\test.txt"</span>,<span class="string">"rw"</span>).getChannel()</span><br><span class="line">    .<span class="built_in">map</span>(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, capacity);</span><br><span class="line">    mb.flip();</span><br><span class="line">    System.out.<span class="built_in">println</span>(Charset.forName(<span class="string">"GBK"</span>).decode(mb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h2><p>他允许程序同步访问作为共享资源的文件，但是可能发生同一时间多个线程同时访问的情况，甚至还有可能要和其他进程竞争。所以java中的文件锁是其他线程可见的。</p><p>FileChannel的tryLock()或Lock()用于锁定文件，如果成功放回FileLock对象，如果不成功就立刻返回null。lock()是阻塞式的，如果没有获得线程就会进入阻塞状态。</p><p>也可以部分加锁</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br><span class="line">lock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br></pre></td></tr></table></figure></div><p>上面的shared如果为true表示共享锁，如果是false是排他锁。</p><ul><li>共享锁，如果一个线程获得了共享锁，那么其他线程还可以获得共享锁，但是不能获得排他锁</li><li>排他锁，如果一个县城获得了排他锁，那么其他线程不可以获得共享锁或排他锁。</li></ul><p>可以用FileLock的isShared()判断锁的类型，如果是true，则是共享锁。release()用于释放文件锁。</p><h1 id="自动释放资源"><a href="#自动释放资源" class="headerlink" title="自动释放资源"></a>自动释放资源</h1><p>因为和c++中的delete一样，经常会忘了close(),所以从JDK7开始，绝大多数I/O类都实现了AutoCloseable接口。他会在一定条件下自动关闭：</p><ul><li>定义在try块中，退出try块时会自动调用close()(无论是正常出去还是非正常退出）。</li></ul><h1 id="用File来查看，创建，删除文件目录"><a href="#用File来查看，创建，删除文件目录" class="headerlink" title="用File来查看，创建，删除文件目录"></a>用File来查看，创建，删除文件目录</h1><p>File表示真实系统中的一个文件，他有如下构造方法：</p><ul><li>File(String pathname):</li><li>File(String parent, String child):parent表示根路径，child表示子路径。</li><li>File(File parent, String child)</li></ul><p>一般来说，如果只要处理一个文件，那么使用第一种构造方法，否则就用后面几种。</p><p>还提供管理文件方法：</p><ul><li>boolean canRead().测试程序是否能对进行读操作</li><li>boolean canWrite()</li><li>boolean delete():删除文件，如果删除的是目录并且目录中有东西就不能删除</li><li>boolean exists():看这个文件时候存在</li><li>String getAbsolutePath():获取文件绝对目录</li><li>String getChanonicalPath(): 获取真正的路径，没有<code>.</code>和<code>..</code></li><li>String getName()</li><li>String getParent()</li><li>String getPath(): 相对目录</li><li>String[] list(): 返回当前目录下所有文件列表</li><li>File[] listFiles().返回目录下的所有文件和目录的File对象</li><li>boolean mkdir(): 创建目录</li><li>boolean createNewFile(): 如果FIle表示文件且在当前目录下不存在，就创建</li></ul><h2 id="操作目录树"><a href="#操作目录树" class="headerlink" title="操作目录树"></a>操作目录树</h2><p>Files类： 有移动文件的move(),复制文件的copy()，搜索目录树的find().此外newDirectoryStream()回创建一个目录流，程序可以通过这个目录流遍历整个目录，用walkFileTree()遍历。</p><p>Path接口： 表示一个路径。</p><p>Paths类： 提供创建Path的静态方法，他的get(String first, String… more)返回一个Path对象，这个对象以first为根路径，以more为子路径.例如：<code>Paths.get(&quot;/root&quot;, &quot;dir1&quot;, &quot;dir2&quot;)</code>返回路径<code>/root/dir1/dir2</code>.</p><p><strong>查看zip</strong></p><p>可以通过FileSystems的newFileSystem()创建表示zip文件的FileSystem对象。然后可以用walkFileTree()遍历zip中所有文件。</p><p>其中walkFileTree可以查看官方文档。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 08 2020 10:32:14 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;java.io.
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Lambda</title>
    <link href="http://xinhecuican.github.io/post/d431fab4.html"/>
    <id>http://xinhecuican.github.io/post/d431fab4.html</id>
    <published>2020-05-22T10:02:00.000Z</published>
    <updated>2020-06-01T12:31:38.182Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 01 2020 20:31:38 GMT+0800 (中国标准时间) --><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names.<span class="keyword">forEach</span>((<span class="type">name</span>)-&gt;<span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span>));</span><br><span class="line">names.<span class="keyword">forEach</span>(<span class="keyword">System</span>.<span class="keyword">out</span>::println);//可以通过这种方式直接调用println</span><br></pre></td></tr></table></figure></div><p>基本语法； <code>(Type1 param1,Type2 param2,...)-&gt;{statment1, statment2... return statmentM;}</code></p><p>一般来讲，这个其实是接口或抽象类的简化。但是不是所有的类都可以使用Lambda的。</p><p>只有声明了函数式接口：<code>public @interface FunctionalInterface</code>才可以被Lambda赋值。这个就是可以简写的原因。通过函数式接口可以直接定位到这个类的某一个函数，然后就可以省略函数名等一系列要素.</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(String <span class="type">name</span>)-&gt;&#123;</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span>);</span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></div><p>这个是基础型，还有许多简化型：</p><ul><li>参数类型可以省略。例如上面可以把String省略，因为一般编译器都可以判断出来</li><li>当参数只有一个时，可以省略小括号（但是私以为还是写上的好，为了统一）</li><li>只有一条语句时，可以省略大括号。并且如果return没有返回值，也可以省略。也就是最前面第一个例子的写法。</li><li>也可以只包含一个普通表达式。语法：<code>(Type val1,Type val2...)-&gt;(expression)</code>。例如：<code>(int a, int b)-&gt;(a*b+2)</code></li></ul><h1 id="用Lambda代替内部类"><a href="#用Lambda代替内部类" class="headerlink" title="用Lambda代替内部类"></a>用Lambda代替内部类</h1><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(()</span>-&gt;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"Hello world!"</span>)).start<span class="literal">()</span>;<span class="comment">//方法1</span></span><br><span class="line"></span><br><span class="line">Runnable race = <span class="literal">()</span>-&gt;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"Hello world!"</span>);<span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(<span class="params">race</span>)</span>.start<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></div><p>上面这个例子完整写法是：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">       <span class="keyword">new</span> Runnable()</span><br><span class="line">       &#123;    <span class="comment">//这是一个Runnable的匿名类</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.<span class="built_in">println</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="comment">//匿名类定义结束</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>至于匿名内部类，<a href="https://xinhecuican.github.io/post/348d4e04.html">可以参考</a></p><p>省去new和类名/接口名。并且直接实现run方法。此外()代表的是接口内部方法的参数，因为run()没有参数，所以这里也不写</p><h1 id="forEach-和排序"><a href="#forEach-和排序" class="headerlink" title="forEach()和排序"></a>forEach()和排序</h1><p>forEach定义： forEach(Consumer&lt;? super T&gt; action);</p><p>其中action实例必须实现Comsumer接口的accept(T t)方法。action指定具体的行为。</p><p>从jdk5开始，集合都实现了Iterable接口。也就是可以使用forEach()</p><p>例如：<code>names.forEach((name)-&gt;System.out.println(name+&quot;,&quot;));</code></p><p>上面的Lambda表达式相当于Consumer的匿名对象。</p><p><strong>排序</strong><br>实际上就是简化了Comparator接口或者其他有关排序接口的写法。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Comparator</span>&lt;<span class="keyword">String&gt; </span>sortByName = (<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>)-&gt;(<span class="built_in">s1</span>.compareTo(<span class="built_in">s2</span>))<span class="comment">;</span></span><br><span class="line"><span class="symbol">Collections.sort</span>(names,sortByName)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="symbol">Collections.sort</span>(names,(<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>)-&gt;(<span class="built_in">s1</span>.compareTo(<span class="built_in">s2</span>)))<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><h1 id="和streamapi联合"><a href="#和streamapi联合" class="headerlink" title="和streamapi联合"></a>和streamapi联合</h1><p>Stream接口是JDK8开始提供的，它可以充当Java集合的适配器。</p><p>方法：</p><ul><li>filter(Predicate&lt;? super T&gt; predivate); 返回包含符合条件元素的流</li><li>forEach(Consumer&lt;? super T&gt; action); 遍历集合中的元素</li><li>limit(long maxSize): 返回maxSize个数的元素</li><li>max(Comparator&lt;? super T&gt; comparator): 根据规则返回最大的元素</li><li>min(Comparator&lt;? super T&gt; comparator)</li><li>sorted(): 对集合中的元素自然排序</li><li>sorted(Comparator&lt;? super T&gt;</li><li>mapToInt(ToIntFunction&lt;? super T&gt; comparator)： 返回一个intStream型对象</li><li>mapToLong(ToLongFunction&lt;? super T&gt; mapper)</li><li>toArray(): 返回包含集合所有元素的对象数组</li></ul><h1 id="Lambda表达式变量作用域"><a href="#Lambda表达式变量作用域" class="headerlink" title="Lambda表达式变量作用域"></a>Lambda表达式变量作用域</h1><p>Lambda可以访问外部类的所有变量。还可以使用this，这里this引用的是外部类。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">String</span>[] data = &#123;<span class="string">"Tom"</span>, <span class="string">"Mike"</span>, <span class="string">"Mary"</span>&#125;;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; names = Arrays.asList(data);</span><br><span class="line">        <span class="keyword">char</span> var2 = <span class="string">','</span>;</span><br><span class="line">        names.forEach((name)-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            var1++;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="keyword">this</span>.var1+<span class="string">":"</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> A().test();</span><br><span class="line">    |</span><br><span class="line">|</span><br></pre></td></tr></table></figure></div><p>但是要注意一点，只能使用final修饰或者程序中不会改变的局部变量。这个类似于匿名内部类（实际上Lambda有匿名内部类的功能）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 01 2020 20:31:38 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 泛型</title>
    <link href="http://xinhecuican.github.io/post/70263071.html"/>
    <id>http://xinhecuican.github.io/post/70263071.html</id>
    <published>2020-05-21T10:37:00.000Z</published>
    <updated>2020-05-21T12:43:04.923Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu May 21 2020 20:49:10 GMT+0800 (中国标准时间) --><h1 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h1><p>由父类转给子类时允许的，但是会抛出ClassCastException。这种异常是运行时异常，编译期不会检查，这就加大了检查的难度。为了解决这个问题，从jdk5开始引入了泛型。泛型可以把ClassCastException转换成编译时类型不兼容错误。</p><p>泛型符号是&lt;&gt;,里面可以使任意一种类（不能是int等基础类型，可以是Integer).</p><p>例如： <code>Set&lt;Object&gt; set = new HashSet&lt;Object&gt;();//实例中的类型必须要和前面相同</code></p><h1 id="泛型类，数组，接口，方法"><a href="#泛型类，数组，接口，方法" class="headerlink" title="泛型类，数组，接口，方法"></a>泛型类，数组，接口，方法</h1><p><strong>泛型类</strong></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bag</span><span class="params">(T content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Bag&lt;<span class="keyword">String</span>&gt; bag = <span class="keyword">new</span> Bag&lt;<span class="keyword">String</span>&gt;(<span class="string">"mybook"</span>);</span><br><span class="line">        Integer content1 = bag.<span class="built_in">get</span>();<span class="comment">//出错</span></span><br><span class="line">        <span class="keyword">String</span> content2 = bag.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这和c++中的模板十分类似。同样泛型参数可以有许多个，例如：<code>public class A&lt;str,inte,dou&gt;{...}</code></p><p><strong>注意</strong> 如果没有传入泛型实参的话，泛型变量可以使任何类型。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> <span class="constructor">Generic(<span class="string">"111111"</span>)</span>;</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> <span class="constructor">Generic(4444)</span>;</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> <span class="constructor">Generic(55.55)</span>;</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> <span class="constructor">Generic(<span class="params">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.get<span class="constructor">Key()</span>);</span><br></pre></td></tr></table></figure></div><p><strong>泛型接口</strong></p><p>泛型接口和泛型类类似，但是它的实现类如果实现的是泛型接口，那么它的实现类也要是泛型。例如：</p><p><code>public class A&lt;T&gt; implements B&lt;T&gt;</code></p><p>如果<code>public class A implements B&lt;T&gt;</code>会报错</p><p>但是如果实现的是一个确定类型的接口，那么前面就不是必须加</p><p><code>public class A implements B&lt;Integer&gt;</code>可以</p><p><strong>数组</strong></p><p>以前我们都是 int[], double[],现在我们把前面的类型变成泛型。例如<code>T[]</code>。</p><p>这里要注意一点，不能使用泛型创建实例。例如<code>T[] content = new T[10];</code>是错误的。</p><p><strong>方法</strong></p><p>在普通类和泛型类中都可以定义泛型方法。泛型方法只需要在方法头部定义泛型符号就可以了，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    Integer[] b = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    a.printArray(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>感觉泛型方法很方便，直接传入参数就可以了，不用管类型。但是这样势必会增大时间开销。</p><h1 id="extends限定类型参数"><a href="#extends限定类型参数" class="headerlink" title="extends限定类型参数"></a>extends限定类型参数</h1><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> 类名&gt; 必须要是这个类或者子类</span><br><span class="line">&lt;T <span class="keyword">extends</span> 接口名&gt;</span><br></pre></td></tr></table></figure></div><h1 id="使用？通配符"><a href="#使用？通配符" class="headerlink" title="使用？通配符"></a>使用？通配符</h1><p>前面已经说过，实例中泛型类型必须要和定义时泛型类型相同。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; s1 =  <span class="keyword">new</span> HashSet&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; s2 = <span class="keyword">new</span> HashSet&lt;<span class="built_in">Integer</span>&gt;();//报错</span><br></pre></td></tr></table></figure></div><p>为了防止上述错误，可以使用通配符？，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; listInteger = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        listInteger.add(<span class="number">11</span>);</span><br><span class="line">        <span class="built_in">print</span>(listInteger);</span><br><span class="line">        printNew(listInteger);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Collection&lt;Object&gt; collection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj: collection)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNew</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj: collection)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>print会出现问题，因为只能接受Object的泛型类型，后面一个就可以。</p><p>还可以和extends结合。例如：</p><p><code>TreeSet&lt;? extends Number&gt; x = new TreeSet&lt;Integer&gt;();//可以，Integer是Number的子类</code></p><p>这个和前面说的区别是前面是在定义时决定的，这个是在具体写代码时决定的，个人认为这种更为灵活。</p><p>还有super，后面类型只能是前面类型的父类或者他自己。例如：<code>TreeSet&lt;? super Integer&gt; x = new TreeSet&lt;Number&gt;();</code></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>看上去不同的泛型类型导致了不同的类。例如<code>A&lt;Integer&gt;</code>和<code>A&lt;String&gt;</code>是不同的类，但是实际上泛型的类型在编译时期已经赋给内部的变量了，这个时候泛型被擦除了，所以实际上创建实例时还是调用了方法区中的A。</li><li>因为上一条，所以不允许出现名字相同只有泛型类型不同的重载，例如：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"String"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;Integer&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Integer"</span>);</span><br><span class="line">&#125;</span><br><span class="line">会报错</span><br></pre></td></tr></table></figure></div></li><li>不能对确切的泛型使用instanceof符号，例如：<code>Collection cs = new ArrayList&lt;String&gt;(); cs instanceof Collection&lt;String&gt;; 报错</code></li></ul><p>但是如果后面使用通配符就可以，<code>cs instanceof Collection&lt;?&gt;通过</code></p><ul><li>不能使用泛型类型进行强制类型转换，例如：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection cs = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = (ArrayList&lt;<span class="keyword">String</span>&gt;)cs;<span class="comment">//会警告并且运行时容易出现异常</span></span><br></pre></td></tr></table></figure></div></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu May 21 2020 20:49:10 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;发展过程&quot;&gt;&lt;a href=&quot;#发展过程&quot; class=&quot;headerlink&quot; title=&quot;发展过程&quot;&gt;&lt;/a&gt;发展过程&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 集合，列表，队列，映射</title>
    <link href="http://xinhecuican.github.io/post/d5381517.html"/>
    <id>http://xinhecuican.github.io/post/d5381517.html</id>
    <published>2020-05-16T10:30:00.000Z</published>
    <updated>2020-06-01T12:59:39.883Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 01 2020 20:59:40 GMT+0800 (中国标准时间) --><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>Set（集），集合中对象不以特定方式排序（有的实现类可以），没有重复元素</li><li>List(列表），按照索引排序，可以有重复对象。List和数组类似。</li><li>Queue（队列），先进先出</li><li>Map（映射）： 有键值对。没有重复键对象，可以有重复值对象</li></ul><p>定义：</p><p><code>Set&lt;String&gt; set = new HashSet&lt;String&gt;();</code></p><h2 id="Collection-和-Interator接口"><a href="#Collection-和-Interator接口" class="headerlink" title="Collection 和 Interator接口"></a>Collection 和 Interator接口</h2><p>Collection声明了上面这些数据结构（不包含map）通用的方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean add(Object o)</td><td>加入对象</td></tr><tr><td>void clear()</td><td>删除所有对象</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否有特定对象</td></tr><tr><td>boolean isEmpty()</td><td></td></tr><tr><td>Iterator iterator()</td><td>返回一个Iterator对象（<a href="https://xinhecuican.github.io/post/37318.html">迭代器</a>）</td></tr><tr><td>boolean remove(Object o)</td><td></td></tr><tr><td>int size()</td><td>返回数目</td></tr><tr><td>Object[] toArray()<t>T[]toArray(T[] a)</t></td><td>返回一个数组，包含集合中所有元素</td></tr></tbody></table><p>Set接口，List接口，Queue接口都继承了Collection接口。</p><p>Inerator接口定义了如下方法：</p><ul><li>hasNext()：判断集合中的元素是否遍历完毕，如果没有返回true</li><li>next(): 返回下一个元素。例如iter.next()是让iter这个迭代器进一位</li><li>remove(): 删除由next()返回的元素</li></ul><p>如果先用iterator()得到一个Iterator对象后，又用Collection的其他方法，再用next()可能会抛出ConcurrentModifcationException异常。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LISP"><figure class="iseeu highlight /lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; a = new HashSet&lt;Integer&gt;()<span class="comment">;</span></span><br><span class="line">for(<span class="name">int</span> i=0<span class="comment">; i&lt;10; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    a.add(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;Integer&gt; iter = a.iterator()<span class="comment">;</span></span><br><span class="line">while(<span class="name">iter</span>.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="name">iter</span>.next())<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="添加基本类型数据"><a href="#添加基本类型数据" class="headerlink" title="添加基本类型数据"></a>添加基本类型数据</h2><p>实际上集合中只能存放对象。但是经常可以看到list.add(2)之类的操作。实际上在添加的时候已经隐式转换成Integer对象了。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>set本身是不排序的。但是它的实现类TreeSet具有排序功能。</p><h2 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h2><p>当添加一个新的元素时，首先要检查这个对象是否已经存在于集合中。如果存在就不添加。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> Set&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">String</span> s1 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">String</span> s2 = s1;</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(s1);</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(s2);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">set</span>.<span class="built_in">size</span>());</span><br><span class="line">结果放回<span class="number">1</span></span><br></pre></td></tr></table></figure></div><h2 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h2><p>HashSet使用哈希算法存放集合中对象。具有良好的查找和存取性能。</p><p>前面说过在Object类中有hashCode()方法返回哈希值，而这个有使用hash算法存储的，所以判断两个对象是否相等还可以<code>customer1.hashCode() == customer2.hashCode();</code></p><p>如果一个类覆盖了equals()方法，那么就应该实现hashCode()方法，保证党两个对象相等时，hashcode相同。</p><h2 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h2><p>TreeSet类实现了SortedSet接口，可以对集合中对象排序。TreeSet支持两种排序方法：自然排序和客户化排序。默认使用自然排序。</p><p><strong>自然排序</strong></p><p>TreeSet实现了Comparable接口的compareTo(Object o)方法比较集合中对象大小。如果返回值大于0，代表这个值大于o。<strong>只有实现了Comparable接口的对象才可以使用TreeSet进行排序</strong>。compareTo方法最好要从小到大进行排序，以便和其他的进行匹配。</p><p>下面列举了一些实现了Comparable接口的类</p><table><thead><tr><th>类</th><th>排序</th></tr></thead><tbody><tr><td>BigDecimal BigInteger Byte Double Float Integer Long Short</td><td>按数字大小</td></tr><tr><td>Character</td><td>按字符 Unicode值</td></tr><tr><td>String</td><td>按字符串中Unicode值</td></tr></tbody></table><p>如果是自己定义的类，首先要实现Comparable接口。并且最好也是通过返回值大于零小于零来判断谁大谁小的。</p><p>注意，如果把一个对象加入TreeSet并且修改它的属性TreeSet是不会重新排序的。所以适合排序的是不可变类。</p><p><strong>客户化排序</strong></p><p>客户化排序可以降序排序。首先实现java.util.Comparator<t>接口。Comparator有个compare(T x, T y)方法用于比较两个对象的大小，如果返回值大于0，表示x&gt;y。</t></p><p>如果想实现降序排序，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">CustomerComparator</span> <span class="symbol">implements</span> <span class="symbol">Comparator</span>&lt;<span class="symbol">Customer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> compare(Customer c1, Customer c2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c1,getName().compareTo(c2.getName())&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c1.getName().compareTo(c2.getName())&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Set&lt;Customer&gt; <span class="keyword">set</span> = new TreeSet&lt;Customer&gt;(new CustomerComparator());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Set有个构造方法 Set(Comparator comparaotr)可以使用Comparator来确定升序还是降序。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>list的实现类有：</p><ul><li>ArrayList： ArrayList代表长度可变数组。ArrayList实现了RandomAccess接口，这个接口不包含任何方法，仅仅表示有良好的随机访问性能。</li><li>LinkedList： 链式结构。LinkedList不仅仅可以做数组，还可以做堆栈，队列，双向队列。</li></ul><h2 id="访问元素和排序"><a href="#访问元素和排序" class="headerlink" title="访问元素和排序"></a>访问元素和排序</h2><p>list中get(int index)方法可以返回集合中索引位置的数。List中的iterator()和Set中的iterator()一样，也可以用来遍历。</p><p>此外，还可以用foreach来遍历</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LESS"><figure class="iseeu highlight /less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">for</span>(Integer <span class="attribute">i</span>: list)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.print</span>(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>至于排序，只能对集合中的对象按索引进行排序，如果想用其他方式，可以实现collections类和Comparator接口。Collections类中的sort方法可以用来排序</p><ul><li>sort(List list) 对List对象进行自然排序</li><li>sort(List list, Comparator comparator)进行客户化排序</li></ul><h2 id="ListIterator-接口"><a href="#ListIterator-接口" class="headerlink" title="ListIterator 接口"></a>ListIterator 接口</h2><p>List中listIterator()返回一个ListIterator对象，这个对象继承了Iterator接口，此外还有一些独有的方法</p><ul><li>add() 向列表中插入一个元素</li><li>hasNext() 判断列表中是否还有下一个元素</li><li>hasPrevious(): 判断列表中是否还有上一个元素</li><li>next(): 返回下一个元素</li><li>previous(): 返回上一个元素</li></ul><p>![](/images/java 集合，列表，队列，映射.jpg)</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue提供了add()和offer()两种方法来从队尾加元素，如果是add队满就会抛出IllegalStateException，如果是offer()会返回false。</p><p>删除也有两种，一种是remove()，一种是poll()。如果是remove，队空后会跑出NoSuchElementException，如果是poll，空了会返回null</p><p>获取元素，一种是element(),一种是peek().如果不成功（队空），那么会出现和删除队空同样的情况。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deque是一个接口</p><p>从头或尾添加元素</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addFirst</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="function"><span class="title">addLast</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">offerFirst</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">offerLast</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br></pre></td></tr></table></figure></div><p>如果队满，都会抛出IlllegalStateException.后两种方法返回false</p><p>删除</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">E</span> <span class="function"><span class="title">removeFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">removeLast</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">pollFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">pollLast</span>()</span></span><br></pre></td></tr></table></figure></div><p>和前面队空判断一样</p><p>获取</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">E</span> <span class="function"><span class="title">getFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">getLast</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">peekFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">peekLast</span>()</span></span><br></pre></td></tr></table></figure></div><p>就是把上面的queue加了个first和last</p><p>LinkedList和ArrayList都实现了Deque接口，</p><h2 id="PriorityQueue-优先队列"><a href="#PriorityQueue-优先队列" class="headerlink" title="PriorityQueue 优先队列"></a>PriorityQueue 优先队列</h2><p>优先队列使用堆进行排序。并且因为要排序，所以想用优先队列要首先实现Comparable接口。</p><p>这里的remove总会首先删除最小的元素。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>定义： Map&lt;type1, type2&gt; map = new HashMap&lt;type1, type2&gt;();</p><p>其中type1是键类型，type2是值类型。</p><p>Map叫映射，就是给出键返回值。可以使用get(Object key)得到值。通过put(Object key, Object value)插入键值对。</p><p>Map的键不允许有重复，但是值可以有重复。</p><p>Map有两种常用实现，HashMap和TreeMap，HashMap用哈希算法来存取键对象，有良好的取性能。为了保证能正常工作，也要确保通过equals()比较为true时，两个对象返回哈希码相同。</p><p>TreeMap实现了SortedMap接口，可以对键进行排序。如果想进行客户化排序，可以调用TreeMap(Comparator comparator)构造函数。</p><p>Map的keySet()返回所有键对象的集合。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; <span class="keyword">set</span> = map.entrySet();<span class="comment">//注意</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iter = <span class="keyword">set</span>.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>=<span class="number">0</span></span><br><span class="line"><span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>=<span class="number">2</span></span><br><span class="line"><span class="number">3</span>=<span class="number">3</span></span><br><span class="line"><span class="number">4</span>=<span class="number">4</span></span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">6</span>=<span class="number">6</span></span><br><span class="line"><span class="number">7</span>=<span class="number">7</span></span><br><span class="line"><span class="number">8</span>=<span class="number">8</span></span><br><span class="line"><span class="number">9</span>=<span class="number">9</span></span><br></pre></td></tr></table></figure></div><p>set内的类型是Map.Entry,可以使用getKey()返回键，使用getValue()返回值。</p><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>适用于List的方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STATA"><figure class="iseeu highlight /stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span>(<span class="keyword">List</span> dest, <span class="keyword">List</span> src): 把一个<span class="keyword">list</span>复制到另一个<span class="keyword">list</span>中</span><br><span class="line">fill(<span class="keyword">List</span> <span class="keyword">list</span>,Object o) 想列表中填充元素</span><br><span class="line"><span class="keyword">sort</span>(<span class="keyword">List</span> <span class="keyword">list</span>) 排序</span><br><span class="line">binarySearch(<span class="keyword">List</span> <span class="keyword">list</span>, Object key) 如果有序就可以用这个</span><br><span class="line">shuffle(<span class="keyword">List</span> <span class="keyword">list</span>): 对<span class="keyword">List</span>中元素随机排列</span><br></pre></td></tr></table></figure></div><p>适用于Map或Collection的：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> max(Collection coll):返回集合中最大的元素</span><br><span class="line"><span class="built_in">Object</span> max(Collection coll, Comparator comp):采用指定规则进行比较，返回最大元素</span><br><span class="line"><span class="built_in">Object</span> min(Collection coll)</span><br><span class="line"><span class="built_in">Object</span> min(Collection coll, Comparator comp)</span><br><span class="line"><span class="built_in">Set</span> singleton(<span class="built_in">Object</span> o): 返回一个不可变的<span class="built_in">Set</span></span><br><span class="line"><span class="built_in">List</span> singletonList(<span class="built_in">Object</span> o) 返回不可改变的<span class="built_in">List</span></span><br><span class="line"><span class="built_in">Map</span> singletonMap（<span class="built_in">Object</span> key, <span class="built_in">Object</span> value):</span><br><span class="line">Collection synchronizedCollection(Collection c): 在原来的基础上，返回支持同步的集合</span><br><span class="line"><span class="built_in">Map</span> synchronizedMap(<span class="built_in">Map</span> m)</span><br><span class="line"><span class="built_in">Set</span> ...</span><br><span class="line"><span class="built_in">List</span> ...</span><br><span class="line">Collection unmodifiableCollection(Collection c): 在原来结合的基础上，返回不可改变的集合视图</span><br><span class="line">其他三个相同</span><br></pre></td></tr></table></figure></div><p>前面的singleton是指这个集合中只有一个元素，并且不允许修改</p><p>而后面的unmodifiable是返回这个集合，但是如果原集合修改，这个集合也会跟着修改。不允许修改指的是不允许修改这个集合视图</p><p><strong>线程安全的集合</strong></p><p>在平常情况下集合的实现类都没有同步锁机制，这样可以加快速度。但是当有多个线程同时操作一个锁的时候就需要同步机制了。一种方式就是在可能导致问题的代码块用synchronized，另一种就是上面讲的方法。</p><h1 id="集合批量操作"><a href="#集合批量操作" class="headerlink" title="集合批量操作"></a>集合批量操作</h1><p>前面说的都是一次处理一个元素，如果要处理多个元素，可以采用Collection中的方法：</p><ul><li>boolean retainAll(Collection&lt;?&gt; c)修改集合，保留在c中的元素并删去其他元素</li><li>boolean removeAll(Collection&lt;?&gt; c)删去集合中c的元素。</li><li>boolean addAll(Collection&lt;? extends E&gt; c): 把c中元素加入到当前集合中</li><li>boolean containsAll(Collection&lt;?&gt; c): 判断当前集合是否全部包含c</li></ul><h1 id="其他集合类"><a href="#其他集合类" class="headerlink" title="其他集合类"></a>其他集合类</h1><p>Properties是一种特殊的Map类。他可以用load()从输入流中读取键和值。例如；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties ps = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span><br><span class="line">InputStream <span class="keyword">in</span> = <span class="module-access"><span class="module"><span class="identifier">PropertiesTester</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ResourceAsStream(<span class="string">"myapp.properties"</span>)</span>;</span><br><span class="line">ps.load(<span class="keyword">in</span>);</span><br><span class="line"><span class="keyword">in</span>.close<span class="literal">()</span>;</span><br><span class="line">print(ps);</span><br><span class="line">ps=<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Properties()</span>;</span><br><span class="line">print(ps);</span><br></pre></td></tr></table></figure></div><p>可以使用System.getProperties()返回一个Propertiese对象。这个对象中包含一系列系统属性。</p><p>BitSet表示一组boolean数据集合。类似于boolean[]数组。最小初始容量是64位，可以通过BitSet(int bits)设置初始容量。如果达到了初始容量会自动增加。</p><p>BitSet中有以下方法：</p><ul><li>set(int index) 把index位置的元素设置成true</li><li>clear(int index) 把index位置的元素设false</li><li>get(int index): 获得index位置的元素值</li><li>and(BitSet bs): 与bs进行与运算，结果保存在当前BitSet中</li><li>or(Bitset bs)</li><li>xor(BitSet bs)</li></ul><p>BitSet在c++中是返回二进制信息，在这里也可以有这个作用。可以自己建立byteToBitSet()计算出byte类型的二进制位，其他类型类似。printBitSet()打印BitSet二进制信息。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte </span>a = <span class="number">125</span>;</span><br><span class="line"><span class="keyword">short </span><span class="keyword">b </span>= -<span class="number">125</span>;</span><br><span class="line">int c = -<span class="number">125</span>;</span><br><span class="line">long d = <span class="number">125</span>;</span><br><span class="line">printBitSet(<span class="keyword">byteToBitSet(a), </span><span class="keyword">BYTE_SIZE);</span></span><br><span class="line"><span class="keyword">printBitSet(shortToBitSet(b), </span><span class="keyword">SHORT_SIZE);</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure></div><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>位置： java.lang.Enum。这个类是抽象类</p><p>此外，还提供了关键字enum。例如 public enum Gender{FEMALE, MALE}</p><p>Enum类有如下非抽象方法（一般直接使用enum就可以了，也有这些)：</p><ul><li>intcompareTo(E o) 比较当前常量与指定对象的顺序</li><li>Class<e>getDeclaringClass()返回当前类型的class对象</e></li><li>String name() 返回当前枚举常量的名称。例如调用Gender.FEMALE的name()方法，会返回FEMALE</li><li>intordinal() 返回当前枚举常量在声明时的位置</li><li>toString() 返回枚举常量的名称</li><li><code>static&lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)</code>返回制定枚举类型和名称返回的枚举常量</li><li>static Enum[] values() 以数组的方式返回所有的枚举常量</li><li>range(from， to)用来迭代</li></ul><p>range用法例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">for(WeekDayEnum</span> <span class="string">day : EnumSet.range(WeekDayEnum.Mon, WeekDayEnum.Fri)) &#123; </span></span><br><span class="line">    <span class="meta">System.out.println(day);</span> <span class="string"></span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">输出</span></span><br><span class="line"><span class="attr">Mon</span> <span class="string"></span></span><br><span class="line"><span class="attr">Tue</span> <span class="string"></span></span><br><span class="line"><span class="attr">Wed</span> <span class="string"></span></span><br><span class="line"><span class="attr">Thu</span> <span class="string"></span></span><br><span class="line"><span class="attr">Fri</span></span><br></pre></td></tr></table></figure></div><p>枚举类型最大的作用就是可以用于switch，相当于扩充了switch的范围。</p><h2 id="枚举类型构造方法"><a href="#枚举类型构造方法" class="headerlink" title="枚举类型构造方法"></a>枚举类型构造方法</h2><p>这个构造方法时private，或friendly类型的，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Gender</span><br><span class="line">&#123;</span><br><span class="line">    MALE(<span class="string">"男性"</span>),</span><br><span class="line">    FEMALE(<span class="string">"女性"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> description;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Gender</span><span class="params">(<span class="keyword">String</span> description)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Gender g = Gender.valueOf(<span class="string">"FEMALE"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (g)<span class="comment">//必须要是实例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.<span class="built_in">println</span>(g.getDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.<span class="built_in">println</span>(g.getDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意前面定义时的符号，如果是基础类型，那么最后一个不用跟任何符号，如果不是，那么最后一个必须要封号。并且前面只能是逗号</p><p>enum是构造对象时产生的，因此看起来相同的两个类型实际上比较时也可能不相同。</p><h2 id="EnumSet和EnumMap"><a href="#EnumSet和EnumMap" class="headerlink" title="EnumSet和EnumMap"></a>EnumSet和EnumMap</h2><p>前面一个把枚举转化成集合，它的静态allOf()方法把枚举类所有常量实例存放到一个EnumSet类型的集合中，然后放回这个集合。</p><p>EnumMap转换成映射，它的EnumMap(Class<k>keyType)来指定具体的枚举类型。枚举常量以key的方式存到Map中。例如：</k></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EnumSet&lt;WeekDayEnum&gt; <span class="built_in">subset</span> = EnumSet.of(WeekDayEnum.Mon, WeekDayEnum.Wed); </span><br><span class="line">     <span class="keyword">for</span> (WeekDayEnum <span class="built_in">day</span> : <span class="built_in">subset</span>) &#123; </span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="built_in">day</span>);  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 01 2020 20:59:40 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;Set
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 数组</title>
    <link href="http://xinhecuican.github.io/post/325cdbf2.html"/>
    <id>http://xinhecuican.github.io/post/325cdbf2.html</id>
    <published>2020-05-14T11:54:00.000Z</published>
    <updated>2020-05-18T12:01:44.506Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>可以这样声明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] scores<span class="comment">;</span></span><br><span class="line">String[] names<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>也可以这样声明</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int scores[]<span class="comment">;</span></span><br><span class="line">String names[]<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>二维更为古怪</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-attr">[]</span><span class="selector-tag">x</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-tag">x</span><span class="selector-attr">[]</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">x</span><span class="selector-attr">[]</span><span class="selector-attr">[]</span>;</span><br></pre></td></tr></table></figure></div><p>这里注意一点，声明时不能往括号中加东西，会报错。例如：<code>int x[1];//报错</code></p><p>java中推荐吧括号放到前面，可能int[]也成了一个对象？</p><h2 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h2><p>创建数组对象语法和c++中创建动态数组类似。</p><p><code>int[] scores = new int[100];</code></p><p>上面这个代码首先要在堆中分配空间，然后把里面的数据初始化。</p><p>括号中的数字可以使常量，也可以是变量，甚至可以是0(表示里面没有数据).</p><h2 id="访问数组的元素和长度"><a href="#访问数组的元素和长度" class="headerlink" title="访问数组的元素和长度"></a>访问数组的元素和长度</h2><p>和c++一样，下标索引。如果越界，会抛出ArrayIndexOutOfBoundsException异常</p><p>所有数组都有length属性，表示数组的长度: <code>public final length</code>.</p><p>所以我们可以直接输出这一属性，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x<span class="literal">[]</span> = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="number">40</span>]</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.length); <span class="comment">//输出length</span></span><br></pre></td></tr></table></figure></div><p>如果是对象数组，那么数组中的元素时对象的引用，因此当我们不使用数组的时候最好把值赋null触发垃圾回收机制。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> sb = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">String</span> sbs[] = <span class="keyword">new</span> <span class="built_in">String</span>[](sb,<span class="keyword">null</span>);</span><br><span class="line">...</span><br><span class="line">sbs[<span class="number">0</span>] = <span class="keyword">null</span>;<span class="comment">//清除数组对象的引用</span></span><br><span class="line">sbs = <span class="keyword">null</span>;<span class="comment">//清除数组引用</span></span><br></pre></td></tr></table></figure></div><h2 id="多维数组和不规则数组"><a href="#多维数组和不规则数组" class="headerlink" title="多维数组和不规则数组"></a>多维数组和不规则数组</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[<span class="string"></span>][<span class="symbol"></span>] rooms = new String[<span class="string">2</span>][<span class="symbol"></span>];</span><br><span class="line">rooms[<span class="string">0</span>] = new String[]("Tom","Mike");</span><br><span class="line">rooms[<span class="string">1</span>] = new String[]("Mary");</span><br></pre></td></tr></table></figure></div><p>可以用不等长数组是因为每一行都是一个数组元素，都有自己的length变量</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;rooms.<span class="built_in">length</span>; <span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">0</span>; k&lt;rooms[<span class="built_in">i</span>].<span class="built_in">length</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(rooms[<span class="built_in">i</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>第一个循环的length是rooms引用多少个数组，rooms[]指的是每个数组的长度。</p><p>要注意只有最后一个括号可以不加数字，我的理解是只有最后一层才是真正的数组对象，才有length，同时，前面不确定就不知道要开多少个数组对象。</p><h2 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h2><p>在c++中数组是不能作为返回值的，因为c++中数组是一个指针，而又不能像其他指针一样确定它的大小。而在java中数组是一个对象，可以返回它的引用。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>平常我们想找某一个值都是通过遍历数组得到的，我们也可以用值通过某种映射关系得到在数组中的位置。这就是哈希表</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>%<span class="number">10</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个例子中value就是值，返回的是下标。但是这时如果超过十就会出现重复，这叫做哈希冲突。我们可以设计更复杂的映射来处理哈希冲突。</p><p>判断重复的条件是 object1.equals(boject2)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    private</span> Object value;</span><br><span class="line">    private <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(Object</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getValue()</span><br><span class="line">    &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">Node</span> <span class="title">getNext</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNext(<span class="keyword">Node</span> <span class="title">next</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyhashSet</span><br><span class="line">&#123;</span><br><span class="line">    private <span class="keyword">Node</span><span class="title">[] array</span>;</span><br><span class="line">    private int size = <span class="number">0</span>;//数组元素数目</span><br><span class="line">    public MyHashSet(int length)</span><br><span class="line">    &#123;</span><br><span class="line">        array = new <span class="keyword">Node</span><span class="title">[length</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    public int size()</span><br><span class="line">    &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int hash(Object o)//哈希算法</span><br><span class="line">    &#123;</span><br><span class="line">        int h = o.hashCode();//Object类中有这个方法</span><br><span class="line">        h += ~(h <span class="tag">&lt;&lt; 9);</span></span><br><span class="line"><span class="tag">        h ^= (h &gt;</span>&gt;&gt; <span class="number">14</span>);</span><br><span class="line">        h += (h <span class="tag">&lt;&lt; 4);</span></span><br><span class="line"><span class="tag">        h ^= (h &gt;</span>&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int indexFor(int hashCode)</span><br><span class="line">    &#123;</span><br><span class="line">        return hashCode &amp; (array.length-<span class="number">1</span>);//返回索引</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void add(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">newNode</span> = new <span class="keyword">Node</span><span class="title">(value</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array(index);</span><br><span class="line">        if(<span class="keyword">node</span> <span class="title">== null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            array(index) = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        else//处理哈希冲突</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">Node</span> <span class="title">nextNode</span>;</span><br><span class="line">            while(!<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value) &amp;&amp;</span><br><span class="line">            (nextnode = <span class="keyword">node</span>.<span class="title">getNext</span>()) != null)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= nextNode</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //不允许加入重复元素</span><br><span class="line">            if(!<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">node</span>.<span class="title">setNext</span>(newNode);</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //测试是否有这个对象</span><br><span class="line">    public boolean contains(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array[index];</span><br><span class="line">        while(<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; !<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">node</span> <span class="title">= node</span>.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">!=null</span> &amp;&amp; <span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean remove(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array[index];</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">!=null</span> &amp;&amp; <span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            array[index] = <span class="keyword">node</span>.<span class="title">getNext</span>();</span><br><span class="line">            size--;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">Node</span> <span class="title">lastNode</span> = null;</span><br><span class="line">        while(<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; !<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            lastNode.setNext(<span class="keyword">node</span>.<span class="title">getNext</span>());</span><br><span class="line">            size--;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object[] getAll()</span><br><span class="line">    &#123;</span><br><span class="line">        Object[] values = new Object[size];</span><br><span class="line">        int index = <span class="number">0</span>;</span><br><span class="line">        for(<span class="keyword">Node</span> node:<span class="title"> array</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            while(<span class="keyword">node</span> <span class="title">!= null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                values[index++] = <span class="keyword">node</span>.<span class="title">getValue</span>();</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= node</span>.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p>java.util.Arrays类，有一系列操作数组的方法。这是一个私有类</p><p>静态方法：</p><ul><li>equals(): 比较两个数组是否相同</li><li>fill(): 向数组中填充数据</li><li>sort(): 把数组升序排列</li><li>parallelSort(): 开启多个线程，以并发的方式对数组中元素进行排序，提高效率</li><li>asList()把一个数组变成List</li></ul><p>例： Arrays.sort(a);</p><h1 id="用-…-声明数目可变参数"><a href="#用-…-声明数目可变参数" class="headerlink" title="用 … 声明数目可变参数"></a>用 … 声明数目可变参数</h1><p>可以用int… a代替 int[] a;这种模式下如果输入立即数可以转化成数组类型：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>... datas)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//可以直接输入数据</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure></div><p>但是必须要放在参数列表的最后一位</p><p>```<br>pubilc void max(int… data, String p)//错误，int… 必须放在最后<br>{<br>…<br>}</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;声明&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟内存</title>
    <link href="http://xinhecuican.github.io/post/f79e4123.html"/>
    <id>http://xinhecuican.github.io/post/f79e4123.html</id>
    <published>2020-05-12T05:37:00.000Z</published>
    <updated>2020-05-19T06:30:23.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 14:30:29 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>我们在生成程序的时候，会发现每个程序的起始地址都是一样的，那么这种一样的地址怎么赋给实际的物理地址上的呢？这就要依靠虚拟内存机制了。</p><p>虚拟内存着力于解决进程间内存分配的问题，并且它还有一个作用是使进程之间相互隔绝。例如不小心产生了一个野指针指向了其他内存的位置，但是实际上却不会破坏其他程序而只会破坏自己的程序，这是因为虚拟内存限制了每个程序所使用的空间，如果超出限制就会报错。</p><p>程序中所使用的空间叫做虚拟空间，一共有2的n次方。而系统上有一个物理地址空间。虚拟内存做的其实是把虚拟空间上的内存地址映射到物理空间上。在cpu中，有一个叫MMU的部件专门做虚拟地址和物理地址转化。</p><h1 id="虚拟内存的组织形式"><a href="#虚拟内存的组织形式" class="headerlink" title="虚拟内存的组织形式"></a>虚拟内存的组织形式</h1><p>虚拟内存中的内存其实是按页进行划分的。这类似与磁盘中的扇区概念，即使那个扇区中只有一个字节的数据，取数据时也是把一个扇区全取出来。</p><p>虚拟内存页的大小一般是4kb到2mb之间。而物理内存也是按页进行分块，并且块的大小和虚拟内存页的大小相同。</p><p>其实把程序加载到内存时也不是一股脑直接加载的，而是一块一块逐个加载，并且如果内存满了还有块替换策略，这实质上是把内存当做一级缓存使用。</p><p>虚拟页有三种情况：</p><ul><li>未分配的， 这部分内存就是虚拟内存预留出来的部分，例如malloc使用的空间，各个段之间预留出来的空间等。</li><li>缓存的， 就是加载到内存中的</li><li>未缓存的，是程序的组成部分但是还没有加载到缓存中。</li></ul><p>由于磁盘访问速度过慢（比SRAM小100000倍），所以我们要尽可能的降低未命中率。第一个办法就是增大每一块的大小（所以才会有一块甚至到2mb，有的小程序都没这么大）。第二个办法是全相连。全相连可以极大降低冲突不命中概率。第三个是使用复杂的块替换策略，这和缓存不同，因为缓存和内存之间速度也就十倍差距，所以块替换策略越简单越好，但是内存与磁盘间不命中惩罚太大，大到情愿花一些时间来找那个最不可能被替换掉。最后是使用回写策略。 <a href="https://xinhecuican.github.io/post/7d1c86da.html">缓存</a></p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>页表是存放于物理内存中的，页表中中的内容代表虚拟内存中这片地址是否被使用，如果被使用，还要存放实际的物理地址。</p><p>页表的大小是由虚拟内存大小和页大小决定的。假设虚拟内存大小矢2的n次方，页大小矢2的p次方，那么页表就有2的n-p次方条。这实际上是一种以空间换时间的策略。每个进程都有一个页表。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt></p><p>上图中左边就是页表，右下角代表磁盘。页表中灰色代表未缓存，未缓存的地址就指向磁盘。而白色代表未分配，地址直接是NULL。如果我们访问0，因为0是未缓存并且内存已满，所以要替换一块下来，假设替换第四块，那么就要把页表中三的地址给改为内存中的物理地址并且把4的地址改为磁盘中的地址。</p><p>所以当我们访问内存时，如果访问到未加载的地址，那么会触发<a href="https://xinhecuican.github.io/post/28877bf.html#more">故障异常</a>,故障异常就会把磁盘中的内存加载进来并且重新执行这条指令。</p><p>如果我们加载到页表地址是NULL的地方，那么就会抛出segmentation fault。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.PNG" alt></p><p>通过页表，我们可以让物理内存彼此分离。并且还可以让两个进程数据共享，这也使动态库可能实现。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.PNG" alt></p><p>虚拟内存还提供了安全保护机制</p><p>这个是比较完整的页表，其中多了一些权限位。后面三个是读写和执行标志位，如果读的时候没有权限，那么就会抛出保护异常，这种异常一般都会终止程序。</p><p>第一个是模式标志位。有些操作系统专有的指令用户不能执行，有些专用寄存器用户不能访问。例如关机的指令即使用户特意编写也不会执行，因为它没有权限。</p><p>操作系统下的内存空间普通用户是没有办法去访问的。如果想调用操作系统的函数，可以使用陷阱异常，产生陷阱异常时，会转到特权模式。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>首先虚拟地址的低p位是页内偏移，因为虚拟内存页的大小和实际内存页的大小相同，所以二者偏移量相同。虚拟地址高n-p位是页号。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%984.PNG" alt></p><p>这张图表示了大致过程。cpu发出虚拟地址，mmu把地址解析成两部分。然后从内存中取出对应页号的地址（cpu中有页的基地址寄存器，页地址是根据页号*每页的大小+基地址得出）。然后mmu又根据取回来的页决定是否要去取内容。如果取，那么这个页中包含了物理页号，然后根据物理页号和偏移量得出实际地址。</p><p>如果标志位是0，那么还要到磁盘中去取出对应页放到内存中并且更新页表。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%985.PNG" alt></p><p>虚拟内存最大的问题就是显著增加了访问时间，本来只要访问一遍的现在要访问两遍。所以在mmu中又加了tlb寄存器专门用来存放页表。现在访问页表不用找内存了，直接找这个寄存器就可以了。如果没有找到再去内存中找并且更新tlb。</p><p>但是现代cpu都是多进程的。每个进程都有自己独立的页表，即使对应的内存相同可能标志位不同，也就是说每次更换进程都要把tlb清空一遍。一种解决办法是传给tlb页号的同时也传递一个进程信息，tlb也储存一个进程信息。</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>假设虚拟内存大小是2的48次方，每页大小矢4kb，每个页表项8字节，那么页表大小矢2的39次方也就是512G。这在现实中显然是不可能实现的，所以要想办法把页表压缩。</p><p>我们很容易想到的一个办法是那些未分配的虚拟内存就不要建立页表项了，但是这样会带来一个问题。原来我们在查找页表的时候都是直接寻址，这是因为假设页表中每一项都存在，现在我们有一些项缺失了，直接根据页号查表的方法也就不行了，只有一个个比对，这样有增大了时间消耗。</p><p>我们可以建立一个多级页表，外层页表每一个页表项缓存的比较大，例如2mb甚至4Gb等，然后这一项中的内容不是物理页号，而是下一级页表的地址，之后下一级页表比上一级小，到最后一级就存储物理页号。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.jpg" alt></p><p>如上图，最外面一层就占着最高位，然后依次递减。这是因为一旦最外层选中了就说明最高几位是那几号，那么就不用管了。</p><p>这样看起来好像是用空间并没有减少，因为到最后一层还是要建立，并且中间几层还要额外消耗空间。实际上如果某个缓存块是未分配的，那么就不会建立下一级页表了。而外面几层页表锁包含的比较大，这样一下就可以排除几百个G的未分配空间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先补充一下前面tlb结构。tlb也是一个缓存并且是组相联结构，这就代表着传递信息中必须要包含组号，然后剩余的是标志位。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.jpg" alt></p><p>上图中tlbi就是组号，前面的是标志位。mmu传给tlb的只有vpn。</p><p>先是cpu发出虚拟内存地址，然后mmu开始解析，解析处vpn传给tlb，如果tlb解析成功那么再传给mmu物理页号并与vpo合成成物理地址。之后在把物理地址发给缓存。按缓存的方式处理。</p><p>如果tlb未命中，那么会到内存系统（包括缓存）中用页表基地址寄存器（CR3）找到最外层的页表然后一层层解析找到物理页号，然后把页号发给mmu的同时缓存那一片区域给tlb。</p><p>如果内存系统中也没有命中（未缓存或者未分配），那么就出触发缺页异常，通过缺页异常判断是未分配还是未缓存还是其他情况。</p><p>缺页异常时判断与一个链表有关。我们知道虚拟内存时分为若干个段的，每个段都有起始地址和终止地址还有一些权限标志位，这个链表就是存放这些信息。当2发生缺页异常时，会判断这个地址是否是在这些段中，如果不在，那么直接抛出Segmentation Fault。如果在那么判断标志位，如果判断不成功会抛出保护异常，如果判断成功了然后再去磁盘中取数据。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 14:30:29 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;p&gt;我们在生成程序的
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="http://xinhecuican.github.io/post/28877bf.html"/>
    <id>http://xinhecuican.github.io/post/28877bf.html</id>
    <published>2020-05-11T23:44:00.000Z</published>
    <updated>2020-05-24T10:52:12.473Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 25 2020 13:31:40 GMT+0800 (中国标准时间) --><h3 id="产生过程"><a href="#产生过程" class="headerlink" title="产生过程"></a>产生过程</h3><p>当程序运行时，可能会产生异常，当cpu检测到这些时间发生时，就会通过异常表跳转到异常处理程序，然后进行处理。</p><p>异常表示常驻于内存中的，每个异常都有一个异常号，事件发送的是异常号，之后根据异常号找到异常表中的对应项再跳转过去。异常表的首地址存放在一个特殊的寄存器中。</p><p>当一场处理结束之后，可能会跳转到下一条语句，可能跳转到当前语句，也可能终止程序。</p><p>要注意，这里讲的异常是系统提供的异常，要把用户程序中设定的异常区分开。</p><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是用来和外部设备进行交互的，例如网卡，usb和磁盘。</p><p>每当这些设备有操作完成时，都会发给cpu一个信号叫cpu去取数据（cpu上有一个特殊的引脚专门去接受这些数据）。之后cpu就会执行中断程序然后去取数据。</p><p>一个显著的例子就是scanf，cpu不可能一到scanf就停止运行，肯定还要继续做各种各样的事。他只是调用了scanf函数给标准输入发出信号，有数据来了就告诉我。之后标准输入输入完成之后并不是直接存到内存中，而是先存到一个缓存中（例如键盘有usb缓存），然后告诉cpu要读数据，cpu才会执行中断去读数据。</p><p>执行中断程序之前，首先要把所有寄存器的值都保护好，之后才去执行。</p><h4 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h4><p>陷阱又叫系统调用。它是一种故意的中断，是执行一条指令的结果。执行完后回到下一条指令。</p><p>这是用户向系统请求服务，例如读文件，打开文件，创建文件，终止进程等。</p><p>系统提供了syscall n 指令专门用来调用这些功能。当这条指令执行时，会中断当前线程然后跳到内核中执行相应的代码，执行完成之后又会返回。</p><h4 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h4><p>故障是有可能修复的异常，这种异常执行完成之后会跳转到当前语句再执行一次。</p><p>一种典型的故障是缺页异常，缺页异常是虚拟内存的东西（现在还没学，就不瞎比比了）。</p><h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>终止是不可恢复的错误，通常是硬件错误，例如突然缺少什么信息等等。一般这种异常都会直接调用abort终止程序。</p><p><img src="/images/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon May 25 2020 13:31:40 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;产生过程&quot;&gt;&lt;a href=&quot;#产生过程&quot; class=&quot;headerlink&quot; title=&quot;产生过程&quot;&gt;&lt;/a&gt;产生过程&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>查找</title>
    <link href="http://xinhecuican.github.io/post/33cb1151.html"/>
    <id>http://xinhecuican.github.io/post/33cb1151.html</id>
    <published>2020-05-10T07:00:00.000Z</published>
    <updated>2020-05-18T06:08:10.150Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --><h3 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>就是一个个找，过程不必多少。</p><p>如果查找每个元素概率相等，那么查找第n个元素只需要一次，第n-1需要两次…。所以平均查找次数是 1+2+…+n / n = （n+1)/2</p><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>其实就是二分查找,<a href="https://xinhecuican.github.io/post/41829.html">代码</a></p><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>分块查找就是每个找出每个块中最大的元素然后单独建一个表，之后就可以先查找这个表然后根据表来查找。大致意思就是这样，<a href="https://blog.csdn.net/To_Be_IT_1/article/details/25333253" target="_blank" rel="external nofollow noopener noreferrer">具体代码</a></p><h3 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h3><h4 id="二叉排序树（查找树）"><a href="#二叉排序树（查找树）" class="headerlink" title="二叉排序树（查找树）"></a>二叉排序树（查找树）</h4><p>二叉查找树特点是左儿子都比父亲小，右儿子都比父亲大。</p><p><img src="/images/%E6%9F%A5%E6%89%BE.PNG" alt></p><p>上面就不是二叉排序树，因为66比50还要大。</p><p>用链表进行存储。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    node</span> *lchild;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*rchild</span>;</span><br><span class="line">    int val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>二叉树的查找算法：</p><ol><li>如果二叉树是空，那么直接返回</li><li>如果该节点的val正好是要查找的数，则查找成功</li><li>如果大，那么去右边找</li><li>如果小，去坐标找</li></ol><p><strong>插入</strong></p><p>先要进行查找，如果查找不成功才会插入。</p><p>插入过程最好单独写一个函数，因为使用递归。如果要插入的点比当前点大，那么就去右边，反之就去左边。知道这个点是空为止，把要插入的点插入到这个空的点中。</p><p><strong>删除</strong></p><p>如果要删除的点是叶结点，那么直接把这个点变成空（因为父亲节点的儿子指针就指向这个节点，现在把这个节点变成空，那么儿子指针就指向空）</p><p>如果要删除的节点只有左子树或者右子树，那么让父亲对应指针指向那个子树就可以了。所以最好把父亲节点也用一个变量存储。</p><p>如果要删除的节点左右子树都有，就用它的前驱替代，然后删除前驱。</p><p><img src="/images/%E6%9F%A5%E6%89%BE2.PNG" alt></p><p>左边是删除前，右边是删除后。</p><p><img src="/images/%E6%9F%A5%E6%89%BE3.PNG" alt></p><p>前面一段代码是找前驱，前驱是s，而q是s的父亲，如果p==q说明p的左孩子就是s并且没有没有其他分支</p><p>效率 2logn</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树的特点是左右子树深度之差小于等于1.</p><p><strong>构造方法</strong></p><p>加入一个代表深度差的标记bf，如果左边比右边深为正，右边比左边深为负。例如：</p><p><img src="/images/%E6%9F%A5%E6%89%BE4.PNG" alt></p><p>上面的数字就是bf值。这个例子中是失去平衡的右子树的右子树导致的，也就是右右，可以向左旋转。让5做8的左节点，8连接根节点，19连接右节点。</p><p>如果是左左，那么向右旋转。</p><p>如果是左右，那么先左旋再右旋。</p><p>如果是右左，那么先右旋再左旋。</p><p>那么现在就知道如果不平衡应该怎么做了。但是插入时怎么判断平不平衡呢？</p><p>如果是空树，那么把这个点做根节点。</p><p>否则就按照二叉排序树的方法进行插入，插入完成之后又从底部递归。如果最终插入到右边就让父亲-1，如果插入到左边就让父亲加一。如果父亲&gt;=2就找左儿子，如果左儿子是1那么就是左左的情况，那么右旋，反之先左旋再右旋。如果&lt;=-2也是同样的方法。</p><p><img src="/images/%E6%9F%A5%E6%89%BE5.PNG" alt></p><p><img src="/images/%E6%9F%A5%E6%89%BE6.PNG" alt></p><p>注意，左旋和右旋是以根节点为基准的。在左左或右右的情况中，根节点是最上面那个点p，右旋就是把p和lc互换。但是在左右和右左的情况中不是这样。</p><p>如果是左右的情况，先以第二层的点作为根，右旋就是第二层的点和第三层的点换一下位置，顺便把原来第三层的左儿子挂到原来第二层的右儿子上（因为原来第三层的点变成第二层，右儿子没有了）。</p><p><img src="/images/%E6%9F%A5%E6%89%BE7.PNG" alt></p><p>最后除此之外还要注意左右或右左的情况中旋转之后的bf值会不同。</p><p><img src="/images/%E6%9F%A5%E6%89%BE8.PNG" alt><br><img src="/images/%E6%9F%A5%E6%89%BE9.PNG" alt><br><img src="/images/%E6%9F%A5%E6%89%BE10.PNG" alt></p><p>可以通过c点来区分</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>一种多路平衡查找树</p><p>每个节点至多m个儿子，如果根节点不是叶子节点，那么<strong>最少2棵</strong>子树。根节点之外的非叶子节点都<strong>至少有 m/2</strong>个子树。</p><p>非终端节点包含n, A0, k1, A1, k1, A2…其中k是关键字，且k&lt;k+1.n是关键字的数目</p><p>所有叶子节点都在同一层次且是空指针。</p><p><img src="/images/%E6%9F%A5%E6%89%BE11.PNG" alt></p><p>从上图中可以看出，对于每一个节点还是符合左边小右边大的规律的。</p><p>结构：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> keynum;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*parent</span>;</span><br><span class="line">    int key[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*p</span>[m+<span class="number">1</span>];</span><br><span class="line">    int *record[m+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">struct result</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*pt</span>;</span><br><span class="line">    int i;//节点中关键字序号</span><br><span class="line">    int success;//是否找到</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>查找</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="NIX"><figure class="iseeu highlight /nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">result search(node *head, int key)</span><br><span class="line">&#123;</span><br><span class="line">    node *<span class="attr">p</span> = head;</span><br><span class="line">    mode *q;</span><br><span class="line">    int <span class="attr">found</span> = <span class="number">0</span>;</span><br><span class="line">    while(p &amp;&amp; !found)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">n</span> = p-&gt;keynum;</span><br><span class="line">        int <span class="attr">i</span> = search(p, key);//这个函数是找第一个大于等于key的</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; p-&gt;key[i] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">found</span> = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">q</span> = p;</span><br><span class="line">            <span class="attr">p</span> = p-&gt;p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(found != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result a.<span class="attr">pt</span> = p;</span><br><span class="line">        a.<span class="attr">i</span> = i;</span><br><span class="line">        a.<span class="attr">success</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result a.<span class="attr">pt</span> = q;//因为没找到最后一定会到<span class="literal">null</span>，所以返回它父亲</span><br><span class="line">        a.<span class="attr">i</span> = i;</span><br><span class="line">        a.<span class="attr">success</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>插入</strong></p><p>节点插入首先是查找，前面查找的时候已经返回了他应该在的位置。但是如果插入后超过了上限那么还要把中间节点提到上面去（主要讲三叉）。同时让左右两边的做往上提节点的左右两边。</p><p><img src="/images/%E6%9F%A5%E6%89%BE12.PNG" alt><br>上面是插入85</p><p>算法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void insert(node *head, int key, node *<span class="built_in">in</span>, int position)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//in是要插入的节点，例如上面就是g节点</span></span><br><span class="line">    <span class="comment">//position是插入位置，也可以先用一次查找</span></span><br><span class="line">    int x = key；</span><br><span class="line">    node *ap = NULL;</span><br><span class="line">    int finish = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &amp;&amp; !finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(int k=position; k&lt;<span class="built_in">in</span>-&gt;</span>keynum-<span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">in</span>-&gt;</span><span class="function"><span class="title">key</span>[k+1] = <span class="built_in">in</span>-&gt;</span>key[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">for</span>(int i=position+1; i&lt;<span class="built_in">in</span>-&gt;</span>keynum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">in</span>-&gt;</span><span class="function"><span class="title">p</span>[i+1] = <span class="built_in">in</span>-&gt;</span>p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">in</span>-&gt;</span>key[position] = x;</span><br><span class="line">        <span class="function"><span class="title">in</span>-&gt;</span>keynum++;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="built_in">in</span>-&gt;</span>keynum &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            finish = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要把数往上提</span></span><br><span class="line">            int temp = (m%<span class="number">2</span>==<span class="number">0</span>) ? m/<span class="number">2</span> : m/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="title">x</span> = <span class="built_in">in</span>-&gt;</span>key[temp];</span><br><span class="line">            <span class="comment">//分裂</span></span><br><span class="line">            <span class="function"><span class="title">ap</span> = <span class="built_in">in</span>-&gt;</span>parent;</span><br><span class="line">            <span class="function"><span class="title">for</span>(int i=0; i&lt;ap-&gt;</span>keynum-<span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span>(ap-&gt;</span>key[i] &lt; x)</span><br><span class="line">                &#123;</span><br><span class="line">                    position = x;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//search</span></span><br><span class="line">            <span class="function"><span class="title">for</span>(int i=position+1; i&lt;ap-&gt;</span>keynum; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">ap</span>-&gt;</span><span class="function"><span class="title">p</span>[i+1] = ap-&gt;</span>p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            node *left = new node;<span class="comment">//拆分后左边节点</span></span><br><span class="line">            node *right = new node;<span class="comment">//拆封后右边节点</span></span><br><span class="line">            <span class="comment">//拆分具体过程就不写了，一系列的赋值</span></span><br><span class="line">            <span class="function"><span class="title">ap</span>-&gt;</span>p[position] = left;</span><br><span class="line">            <span class="function"><span class="title">ap</span>-&gt;</span>p[position+<span class="number">1</span>] = right;</span><br><span class="line">            <span class="built_in">in</span> = ap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">head</span>-&gt;</span>keynum++;</span><br><span class="line">        <span class="function"><span class="title">head</span>-&gt;</span>key[<span class="number">0</span>] = key;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这是自己写的并且没有验证，只有借鉴作用</span><br></pre></td></tr></table></figure></div><p><strong>删除</strong></p><ul><li>如果删除这个值后节点的key数大于 m/2-1（此时分支数是m/2)。那么只需要删除对应部分，其他不变。</li><li>如果删除节点后key=m/2-1<ol><li>如果它父亲左边或者右边Key数大于m/2-1，那么先把左边最大（右边最小）提到上面，再把那个值放下来<img src="/images/%E6%9F%A5%E6%89%BE13.PNG" alt></li><li>如果左右两边正好都等于m/2-1，那么把左边右边合并并且把这个值也放下来<img src="/images/%E6%9F%A5%E6%89%BE14.PNG" alt></li><li>不会有小于m/2-1的了，不符合定义</li></ol></li><li>如果删除后<strong>双亲</strong>key值小于m/2-1,层层向上合并（不清楚具体过程）</li></ul><p><strong>B+树</strong></p><p>b+树key和q一样多，并且子节点中包含父节点中的信息。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>基本思想：建立要存的数和存的位置之间的映射关系（最理想的情况是一一映射），此后在查找元素时，只需要用hash函数就可以找到再表中的位置。</p><p>哈希函数就是将值转化成存的位置的函数。</p><p>举个例子： 比如哈希函数是 x%10-1,那么可以输入x就可以得到元素在表中的位置。</p><p>但是这里有个问题，例如11的哈希值和1的哈希值相同，那么存的位置也相同，这显然是不允许的，这叫做哈希冲突。判断哈希函数优劣就是哈希冲突越少越好。</p><p><a href="https://xinhecuican.github.io/post/11491.html">字符串哈希</a></p><h5 id="直接定值法"><a href="#直接定值法" class="headerlink" title="直接定值法"></a>直接定值法</h5><p>hash(key) = key 或 hash(key) = a * key + b</p><p>这种方法仅适合哈希表和取值范围一样大的情况（如果取值到十亿我就呵呵）</p><h5 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h5><p>这是利用所选数字中的一些规律来的。例如某一串数字最高若干位都相同，只有一两位不同，那么我们就可以只取一两位</p><h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><p>就是先把数字平方然后再取中间几位，它的目的是扩大差别从而缩小冲突几率。适用于每一位都有高概率的重复数字。</p><h5 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h5><p>将关键字分成若干块然后叠加。可以直接分成若干块叠加。也可以正的加一块然后把数倒过来加一块，这种方法使用于位数多的情况。</p><h5 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h5><p>hash(key) = key % p;//p是不大于表长且不大于最大值的素数</p><h5 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h5><p>hash(key) = random(key);//这是伪随机数</p><h5 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h5><p><strong>开放地址法</strong></p><p>把冲突的地址求一个地址序列：h0,h1…</p><p>h(i) = (h(key) + d(i) ) mod m // m是表长</p><p>d(i) = c + i c可以随便取</p><p>或d(i) = (-1)^(i-1) * (i/2)^2 //这里的i/2是向上取整也就是1/2=1</p><p>或d(i)=random(i)//伪随机数</p><p>或d(i) = i*h2(key)</p><p>注意，这里的d(i)要保证完备性，也就是要保证s(m-1)个h(i)均不相同并且要覆盖到所有地址。那么就要求</p><ol><li>表长要是 4*k+3</li><li>m与d(i)没有公因子</li></ol><p><strong>链地址法</strong></p><p>把哈希值相同的记录在一个链表里。其实就是构建一个链表，如果不冲突就只有一个值，冲突就往后面加。</p><p><strong>再哈希法</strong></p><p>发生冲突时，选用另外一个哈希函数，直到不冲突。</p><p><strong>建立公共溢出区</strong></p><p>一旦发生冲突，就把有冲突的数据都填充到溢出表。</p><h5 id="哈希表查找"><a href="#哈希表查找" class="headerlink" title="哈希表查找"></a>哈希表查找</h5><p>就是先计算处hash(key)，如果找到直接填充，如果发现冲突就在通过冲突处理方法进行查找</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;静态查找&quot;&gt;&lt;a href=&quot;#静态查找&quot; class=&quot;headerlink&quot; title=&quot;静态查找&quot;&gt;&lt;/a&gt;静态查找&lt;/h3&gt;&lt;h4
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>java 多线程</title>
    <link href="http://xinhecuican.github.io/post/f8648a1d.html"/>
    <id>http://xinhecuican.github.io/post/f8648a1d.html</id>
    <published>2020-05-04T11:40:00.000Z</published>
    <updated>2020-05-14T11:56:46.436Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 15 2020 17:23:19 GMT+0800 (中国标准时间) --><h3 id="java线程运行机制"><a href="#java线程运行机制" class="headerlink" title="java线程运行机制"></a>java线程运行机制</h3><p>java虚拟机中，执行程序是由线程完成的，每个线程都有独立的程序计数器（PC或rip<br>)和栈</p><p>栈中有三个区，局部变量区，操作数栈和栈数据区。</p><p>操作数栈是线程的工作区，用来存放运算过程产生的临时变量（怎么有种寄存器的感觉）。</p><p>栈数据区为线程执行指令提供相关信息，例如定位到堆区和方法区的特定数据（类成员变量），正常退出方法等（存放地址信息）。</p><p>每次java虚拟机启动一个虚拟机进程时，虚拟机都会创建一个主线程。该线程从main开始执行。</p><p>例如在一个类中定义了一个实例变量a,然后再main函数中调用了这个类的成员函数A()，这个函数会让成员变量加一。首先进入这个方法，然后发现a++;就去栈数据区取出a的地址，之后定位到堆区取出a进行操作。</p><ul><li>方法区存放了字节码</li><li>堆区存放了线程所需要长时间保存的数据（类）</li><li>栈区存放了临时数据，栈帧和跳转到其他区域地址。</li></ul><h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>我们现在免费有了一个主线程，如果我们还想要创建其他线程的话，有两种方式。</p><ul><li>扩展java.lang.Thread类</li><li>实现Runnable接口</li></ul><p>要注意一点，创建了线程并启动之后会有自己的栈区，堆区，方法区，也就是说可以把它看成一个新的程序，里面的变量都是最原始的，不要认为主线程中操作的变量还有用。但是有些时候也可以使用主线程的对象</p><p><strong>一个线程只可以被启动一次</strong>。</p><h4 id="扩展java-lang-Thread类"><a href="#扩展java-lang-Thread类" class="headerlink" title="扩展java.lang.Thread类"></a>扩展java.lang.Thread类</h4><p>thread是线程，它的最主要的两个方法是：</p><ul><li>run(): 包含线程运行时执行的代码（相当于main方法）</li><li>start()： 用于启动线程，不需要覆盖</li></ul><p>start方法用来确定什么时候开始执行，可以在别的main函数中执行，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Machine</span> <span class="symbol">extends</span> <span class="symbol">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">50</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Machine machine = new Machine();</span><br><span class="line">        machine.start(); <span class="comment">//启动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>注意</strong>，调用了start并不是指立刻执行这个线程，而是让这个线程进入就绪状态，如果想让这个线程执行可以使用yield。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>java不允许一个类继承多个类，所以一旦继承了Thread类，那么就不能继承其他类。所以说接口这时就体现出优越性了。定义如下：</p><p><code>public void run();</code></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    [</span></span><br><span class="line"><span class="function">        Machine machine </span>= <span class="keyword">new</span> Machine();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> thread(machine);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Thread构造方法中有Runnable接口的，这个时候Thread就掌管了run方法，只要使用start就可以启动。</p><h4 id="主线程和用户自定义线程并发运行"><a href="#主线程和用户自定义线程并发运行" class="headerlink" title="主线程和用户自定义线程并发运行"></a>主线程和用户自定义线程并发运行</h4><p>并发运行指的是一个线程没有结束另一个线程开始执行，上面举的例子都是并发运行。</p><p>Thread中的currentThread()静态方法返回当前线程的引用，getname()返回当前线程的名字，main方法名字是main，用户创建的线程根据顺序从Thread-0，Thread-1一直往后排，可以用setName()设置名字。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line">相当于</span><br><span class="line">Thread thread = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">String name = thread.get<span class="constructor">Name()</span>;</span><br></pre></td></tr></table></figure></div><p>为了让每个线程轮流获得cpu，可以使用sleep(time)放弃cpu并睡眠若干时间。</p><h4 id="多个线程共享一个对象的实例变量"><a href="#多个线程共享一个对象的实例变量" class="headerlink" title="多个线程共享一个对象的实例变量"></a>多个线程共享一个对象的实例变量</h4><p>例：</p><ul><li>方法内部局部变量不共享</li></ul><p>这是因为这些数据都是动态在栈中分配的，每个线程都有自己的堆栈。</p><ul><li>成员变量，如果是指向同一个对象就共享</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Analy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Num i=<span class="keyword">new</span> Num(<span class="number">0</span>);    <span class="comment">//新建对象，准备传递给线程</span></span><br><span class="line">        <span class="keyword">new</span> OwnThread(i).start();    <span class="comment">//新建线程，并启动</span></span><br><span class="line">        <span class="keyword">new</span> OwnThread(i).start();    <span class="comment">//新建线程，并启动</span></span><br><span class="line">        System.out.println(<span class="string">"主线程中i的值变为了："</span>+i.i);    <span class="comment">//获取目前对象i的数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OwnThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Num id;    <span class="comment">//申明对象，默认null，就是没有指向任何实体</span></span><br><span class="line">    <span class="keyword">int</span> sno;    <span class="comment">//申明int变量。因为系统默认初始化为0，所以应该是定义一个int变量</span></span><br><span class="line">    OwnThread(Num id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sno=id.i;    <span class="comment">//保存id.i的数值，到线程私有变量sno</span></span><br><span class="line">                id.i++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">","</span>+sno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span>    //定义一个类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Num(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序中主函数定义了Num对象的实例i，定义线程是传递到了Thread0和Thread1这样三个变量就共享了一个Num对象的实例。而线程Thread0和线程Thread1又有自己的私有变量sno，可以用来保存某一时刻的共享变量的数值。</p><p>(1)Java中判断对象是否为同一个对象使用地址判断的。地址相同就是同一个对象，上面的三个就是同一个对象。</p><p>(2)如果把上面的例子中共享的对象实例用基本数据类型替换是不行的。因为基本数据类型程序会自动的用默认值初始化，也就是申明和定义时一起的。此时在main函数中定义线程，传递的基本数据类型参数，只能是初始化线程中的另一个对象，而不是同一个对象。</p><p>也就是说，只有类才可以共享，并且用同一个实例启动多个线程的时候这个实例是共享的，并且也只有这个实例时共享的，如果在线程中创建的新实例也不是共享的。</p><p><a href="https://www.cnblogs.com/xudong-bupt/archive/2013/05/22/3087864.html" target="_blank" rel="external nofollow noopener noreferrer">这里来自这篇博客</a></p><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><p><strong>新建状态</strong></p><p>也就是只有new没有start状态。</p><p><strong>就绪状态</strong></p><p>调用了start方法后，就进入了就绪状态。虚拟机会为他创建栈和rip，这个线程在运行池中等待cpu使用权。</p><p><strong>运行状态</strong></p><p>就是得到了cpu使用权，如果是多个cpu，那么可以同时运行多个线程。</p><p><strong>阻塞状态</strong></p><p>阻塞状态优先级比就绪状态低，阻塞状态过去后首先进入就绪状态然后进入运行状态。</p><ul><li><p>如果调用了某个对象的wait()方法，那么会进入这个对象等待池中。</p></li><li><p>如果试图获得某个对象的同步锁（后面说）但是被其他线程使用时，会把这个线程放到这个对象的锁池中。</p></li><li><p>调用sleep。</p></li><li><p><em>死亡状态*</em></p><p>当退出了run后，进入死亡状态。前面已经提到过一个线程不能呗start两次。可以用Thread的isAlive()方法判断这个线程是否活着。如果处于新建状态时，也是false。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3></li></ul><p>线程调度就是确定cpu的使用权在那个线程手上，cpu通常只有一个。有两种调度模型：分时调度和抢占型调度。</p><p>分时型调度就是让每个线程都执行一定时间。</p><p>抢占型是java虚拟机采用的方式。它是将所有线程规定一个优先级，优先让优先级高的线程运行，如果优先级都相同，那么随机选取一个线程。一旦抢到cpu，那么它将会一直运行直到被迫停止运行。</p><p>被迫停止运行的可能：</p><ul><li>虚拟机让当前线程放弃cpu。</li><li>当前线程进入阻塞状态</li><li>线程运行结束</li></ul><p>不同操作系统对抢占型的实现不同，有的是会一直让这个线程运行，有的是一段时间后停止运行。</p><h4 id="调整优先级"><a href="#调整优先级" class="headerlink" title="调整优先级"></a>调整优先级</h4><p>可以使用Thread的setPriority(int)和getPriority()设置优先级，可以使用currentThread().setPriority(?)设置等级。</p><p>三个静态常量：</p><ul><li>MAX_PRIORITY 10级，最高等级</li><li>MIN_PRIORITY 1,最低等级</li><li>NORM_PRIORITY 5, 默认等级</li></ul><p>如果将主线程优先级更改然后再创建其他线程，那么其他线程优先级也会更改。被创建者的默认优先级和创建者优先级保持相同。</p><p>注意，上面三个静态常量在不同操作系统中是不同的，例如windows只有七个优先级，所以最好只使用上面三种优先级。</p><h4 id="Thread-sleep-线程睡眠"><a href="#Thread-sleep-线程睡眠" class="headerlink" title="Thread.sleep()线程睡眠"></a>Thread.sleep()线程睡眠</h4><p>如果使用sleep方法，那么他会放弃cpu进入阻塞状态。sleep后面的数据是以毫秒做单位。完成之后也不是立刻重新开始执行，而是先进入就绪状态，如果没人和它抢cpu就开始执行。</p><p>例如： sleep(100);表示阻塞100毫秒</p><p>可以使用sleep让两个线程比较同步的执行。例如每个线程都会调用sleep(100)，那么第一个线程调用睡眠后第二个线程开始执行，如果执行时间小于100ms那么第二个线程执行完后第一个线程仍在睡眠，如果大于100ms第一个线程会立刻开始执行。因为它已经睡了100ms进入就绪状态了（同样也是只有两个线程的情况）。</p><p>可以使用sleep.interrupt()中断睡眠</p><p>如果线程在睡眠时被中断，那么就会抛出InterruptedException，程序跳到异常处理代码块。</p><h4 id="Thread-yield-线程让步"><a href="#Thread-yield-线程让步" class="headerlink" title="Thread.yield()线程让步"></a>Thread.yield()线程让步</h4><p>执行yield后，如果有相同或者更高优先级的线程在就绪状态，那么将会把当前线程放入运行池中并让优先级高的线程执行。</p><h4 id="join-等待其他线程结束"><a href="#join-等待其他线程结束" class="headerlink" title="join()等待其他线程结束"></a>join()等待其他线程结束</h4><p>当前线程可以调用另一个线程的join()方法，直到另一个线程结束这个线程才会又开始执行（进入就绪状态）。</p><p>如果加了参数，那么类似于sleep()将会休眠若干时间，不同的是join是给指定的线程执行。</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>例如垃圾回收线程，只有当前台所有线程都停止之后，后台线程才会结束生命周期。</p><p>主线程默认是前台线程，前台线程创建的线程默认也是前台线程。</p><p>可以调用Thread的setDaemon(true)方法，把线程设置成后台线程。可以用isDaemon()判断是否是后台线程。</p><p>只有在线程启动前（使用start())之前才可以设置成后台。并且后台创建的线程还是后台线程。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>java.util包中提供了定时器Timer，TimerTask类表示定时器执行的一项任务。例；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> usetimer;</span><br><span class="line">improt java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.start();<span class="comment">//想自定义start必须要先用父类的start</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(ture);<span class="comment">//把Timer关联的线程设为后台线程</span></span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;<span class="comment">//匿名类，便于设置定时任务</span></span><br><span class="line">        timer.schedule(task, <span class="number">10</span>, <span class="number">50</span>);<span class="comment">//设置定时任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">":"</span>+a++);</span><br><span class="line">        &#125;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>TimerTask类是一个抽象类，它实现了RUnnable接口。start()中匿名类继承了TimerTask类。</p><p>TImer(boolean isDaemon)可以把相关联的线程设置成后台线程。如果是true就是后台</p><p>schedule(TimerTask task, long delay, long period)用来设置定时任务。所以前面的匿名类就是用来启动定时任务的。delay是推迟多少毫秒之后执行，period是每次执行任务的间隔。其中delay只在第一次运行时有效。</p><p>还可以不要period参数，表示只执行一次。例如,timer.schedule(task, 10);</p><p>同一个定时器可以执行多个任务。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>有时候线程的抢占可能导致问题。例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//共享</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a+=i;</span><br><span class="line">            Thread.<span class="built_in">yield</span>();<span class="comment">//让给其他线程执行</span></span><br><span class="line">            a-=i;</span><br><span class="line">            System.out.<span class="built_in">println</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Mahcine();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(machine);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(machine);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个程序本来是要一直输出零的，但是因为让给了t2执行，所以会输出1 2 2 3 …。这样就和原来的逻辑不符。</p><p>逻辑紧密相关的一组操作叫做原子操作，为了防止原子操作被打断，就提出了线程同步思想。</p><h4 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h4><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">String</span> goods = <span class="built_in">buffer</span>[<span class="built_in">point</span>];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样就设置了this对象的锁。</p><ul><li>如果这个锁被其他线程占用，那么就会把该线程加入锁池中，进入阻塞状态</li><li>如果没有线程占用，那么他就会占用并执行代码块。</li></ul><p>也可以这样写；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized <span class="keyword">String</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意，在同步代码块中同样也可以使用sleep和yield，同样也是把cpu给其他线程。只是如果其他线程正好碰到了同步代码块那么又要将控制权归还，</p><p>synchronized不会被继承，也就是说哪怕父类中写了synchronized如果子类没写也不是同步的。</p><p>同步代码块中应包含尽量少的操作，因为操作多了可能一线程要在这里工作很久，其他线程就会都进入锁池中无法工作，这样会给一些需要即时反应的线程带来麻烦</p><h4 id="释放对象的锁"><a href="#释放对象的锁" class="headerlink" title="释放对象的锁"></a>释放对象的锁</h4><p>释放锁的情况：</p><ul><li>执行完同步代码块，会释放锁</li><li>线程异常终止时</li><li>执行了锁所属对象的wait()方法，这个线程会释放锁，并进入等待吃</li></ul><p>但是使用sleep或yield只会放弃cpu，并不会释放锁。还有suspend方法</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁指的是a在等b锁释放，b在等a锁释放，这样就永运无法释放，最为关键的是虚拟机并不会检查这类问题，所以只有程序员自己注意。</p><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>线程通信就是一个线程告诉另外一个线程某个信息，通过配合完成某件事。</p><p>java.lang.Object类中有两个用于线程通信的方法：</p><ul><li>wait() 释放对象的锁，然后把该线程放入等待池中，等待其他线程把它唤醒</li><li>notify() 唤醒在等待池中的线程。随机选取等待池中的线程，并加入锁池中。</li></ul><p>进入等待池后，锁和cpu全部放弃。如果使用notify也只是进入锁池，还要和其他线程争夺锁。</p><p>notifyAll() 唤醒所有在等待池中的线程。</p><p>注意：wait()方法必须放在一个循环中。因为在调用notify后并不是立刻可以得到执行，而是先要获得该对象的锁和cpu执行权限才可以运行。这个时候可能其他线程又将状态改变了，这时又要重新运行。</p><p><strong>要注意的是想要唤醒等待池中的线程首先自己要掌握这个锁</strong>，也就是说必须在同步代码块中写notify，不然会报IllegalMonitorStateException错误。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public synchronized String pop<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    this.notify<span class="constructor">All()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(point<span class="operator"> == </span>-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.ptintln(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">":wait"</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            this.wait<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="params">e</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面例子中，首先point是-1就要让一个线程处理，现在point是-1，然后一个线程调用wait()进入等待池，之后另一个线程操作了这个方法唤醒了该线程，但是这个时候线程并没有执行，而是先让其他的线程执行了一会才开始执行。但是其他线程执行过程中又把point变成-1了，这个时候处理线程已经结束，就会出现问题。</p><p>此外，<strong>wait必须写在synchronized中，不然运行时会报错。</strong></p><h3 id="中断阻塞"><a href="#中断阻塞" class="headerlink" title="中断阻塞"></a>中断阻塞</h3><p>当线程A处于阻塞状态的时候，B调用A的interrupt()方法，那么A会发送一个InterruptedExecption。</p><p>实际上interrupt方法如果处理处于阻塞状态的线程（如wait，sleep，join等）才会抛出异常，实际上它是把一个中断线程的标志位设为true，因为处于阻塞状态，所以抛出异常，仅此而已。决定是否退出线程还是由我们自己决定的，如果我们在catch块中没有退出，那么还是会继续运行。</p><p>如果interrput一个正在处于运行的线程，那么只会把标志位设置成true，不会做其他事。</p><p>可以通过isinterrupt来看标志位是否变成true</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Timer timer = <span class="keyword">new</span> Timer(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread = Thread.currentThread();</span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">publc <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"has waited for 3s"</span>);</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                timer.schedule(timerTask, <span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(InterruptException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(thread.getName);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a++;</span><br><span class="line">            System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段程序作用是如果a&gt;3，那么就把线程放入等待池，如果等待时间超过三秒，那么就抛出InterruptException信号从而中断线程。</p><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><ul><li>start() 启动线程</li><li>suspend() 使线程暂停</li><li>resume() 使暂停的线程恢复运行</li><li>stop() 终止线程</li></ul><p>但是其实后面三种已经被废弃了，但是可以通过编程实现同样的功能</p><h4 id="用编程方式控制线程"><a href="#用编程方式控制线程" class="headerlink" title="用编程方式控制线程"></a>用编程方式控制线程</h4><p>可以设置一个标志变量来表示现在的状态，假设标志变量有三个值。</p><ul><li>SUSP， 暂停状态</li><li>STOP， 终止状态</li><li>RUN， 运行状态</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUSP = <span class="number">1</span>;<span class="comment">//设置静态变量的话所有类都可以看到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUN = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> state = RUN;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">if</span>(state == RUN)</span><br><span class="line">        &#123;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">checkState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(state == SUSP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"wait"</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(state == STOP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过上面的两个方法，就可以对线程进行控制，但注意这种控制不是实时的，也就是说即使执行了setState也不会立刻进入暂停状态，而是machine先获得cpu，开始执行checkState方法时才会进入暂停状态。</p><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>ThreadGroup类表示线程组，他可以对一组线程集中管理。用户创建的线程都属于某个线程组。</p><p>指定线程组： <code>Thread(ThreadGroup group, String name)</code></p><p>如果线程A创建线程B且创建时没有指定线程组，那么会自动加入A的线程组中。一旦线程<strong>加入线程组，就不能退出</strong>。</p><p>用户创建的线程组都有父线程组，默认情况下，如果A创建了一个新线程组，那么A所在的线程组就是父亲线程组。</p><p>指定父亲线程组： <code>ThreadGroup(ThreadGroup parent, String name)</code></p><p>可以使用activeCount()返回当前活着的线程，enumerate(Thread[] tarray)把或者的线程复制到tarray中。</p><h3 id="处理线程未捕获的异常"><a href="#处理线程未捕获的异常" class="headerlink" title="处理线程未捕获的异常"></a>处理线程未捕获的异常</h3><p>如果线程没有捕获异常，那么虚拟机会找UncaughtExceptionHandler实例（这东西是个接口）。并且调用它的uncaughtException(Thread t, Throwable e)方法</p><p>设置异常处理类：</p><p><code>setDefaultUncaughtExcpetionHandler(Thread.UncaughtExceptionHandler eh)</code><br><code>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code></p><p>第一个是设置默认异常处理器（静态方法），第二个是设置当前异常处理器（实例方法）。</p><p>ThreadGroup线程组实现了这个接口。每次出现未捕获异常时，先找当前线程的异常处理器，如果没找到就用线程组的异常处理器。</p><p>并且线程组的异常处理器还不是直接调用。如果这个线程有父线程，那么就调用父线程的。如果没有父线程，那么如果自己实现了这个接口，那么就用。如果没有，那么就打印调用堆栈的异常信息。</p><h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><p>这个类用来存放线程的局部变量。这些局部变量是每个线程独有的，不会共享。</p><p>主要有三个方法：</p><p><code>public T get(): 返回当前线程局部变量 protected T initialValue(): 返回局部变量初始值 public void set(T value): 设置局部变量</code></p><p>其中initialValue()只会在第一次调用get()或set()时才会被使用，并且只会执行一次。</p><h3 id="concurrent并发包"><a href="#concurrent并发包" class="headerlink" title="concurrent并发包"></a>concurrent并发包</h3><p>在编写多线程程序时，既要考虑并发，又要防止死锁，还要考虑性能，难度很大。为了降低难度，增加了java.util.concurrent包。下面是包含的类和接口</p><h4 id="Lock外部锁"><a href="#Lock外部锁" class="headerlink" title="Lock外部锁"></a>Lock外部锁</h4><p>这个主要用于线程同步。这是由类提供的锁，区别于对象的锁（可以叫内部锁）。他有几个方法。</p><ul><li><p>lock() 获得当前线程的锁，如果被占用，那么进入阻塞状态。这和内部锁是一样的</p></li><li><p>tryLock() 试图获得当前线程的锁（看看现在锁是不是有人用），如果被占用，就返回false，否则返回true。</p></li><li><p>tryLock(long time, TimeUnit unit)，如果超过了设置时间没有获得锁，放回false。例如 tryLock(50L, TimeUnit.SECONDS)表示时间限制50s</p></li><li><p>unlock() 释放线程锁占用的锁。</p><p>Lock接口有一个实现类ReentrantLock，构造方法ReentrantLock(boolean fair).fair如果是真，那么会采用公平策略。公平策略是指让阻塞时间长的更有可能获得锁。这是以性能作为代价的。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();<span class="comment">//创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>外部锁可以用来弥补内部所的一些不足，我们可以直接用lock，unlock而不使用synchronized。</p><h4 id="Condition-线程通信接口"><a href="#Condition-线程通信接口" class="headerlink" title="Condition 线程通信接口"></a>Condition 线程通信接口</h4><p>java.lang.concurrent.locks.Conditon用于线程通信。Lock接口的newCondition()方法返回Condition的实例。</p><p>方法：</p></li><li><p>await() 和wait()相似</p></li><li><p>await(long time, TimeUnit unit):和上面类似，如果超过时间线程没有被唤醒，返回false。</p></li><li><p>signal()： 和notify()类似。</p></li><li><p>signalAll()：和notifyAll()类似</p><h4 id="Callable和Feture"><a href="#Callable和Feture" class="headerlink" title="Callable和Feture"></a>Callable和Feture</h4><p>这两个是用来做异步计算的。Runnable接口的返回值是void，如果其他线程需要这个线程的返回值怎么办呢？这个可以通过共享变量来实现，但是共享变量需要共享类，这又可能导致问题。所以这两个接口就是解决这类麻烦。</p><p>Callable接口：和Runnable接口类似，Runnable中的run()相当于Callable中的call()。但是call可以有泛型的返回值。此外，这个不能作为Thread类的参数。</p><p>Future接口： 保存运算结果，以下参数</p></li></ul><ul><li>get()：返回异步运算的结果。如果结果没有出来，当前线程就会被阻塞直到运算结束。</li><li>get(long timeout, TimeUnit unit): 和第一个类似。只是如果超出时间还没有得到结果就会抛出TimeoutException。</li><li>cancel(boolean mayInterrupt): 取消该运算，如果运算没有开始，就立刻取消。如果已经开始，如果mayInterrrupt为true，那么也取消。</li><li>isCancelled()：判断运算时候被取消</li><li>isDone()：判断运算是否已经完成。</li></ul><p>FutureTask：这是一个适配器，同时实现Runnable和Future接口。还关联了一个Callable实例。FutureTask可以作为Thread类的参数。FutureTask类的构造函数可以带Callable的参数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LASSO"><figure class="iseeu highlight /lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Callable myComputation = <span class="literal">new</span> <span class="params">...</span></span><br><span class="line">FutureTask&lt;<span class="built_in">Integer</span>&gt; task = <span class="literal">new</span> FutureTask&lt;<span class="built_in">Integer</span>&gt;(myComputation);<span class="comment">//Integer是返回值</span></span><br></pre></td></tr></table></figure></div><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Machine implements Callable&lt;<span class="type">Integer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">Integer</span> <span class="keyword">call</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            catch(<span class="keyword">Exception</span> e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(Stirng[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FutureTask&lt;<span class="type">Integer</span>&gt; task = <span class="built_in">new</span> FutureTask&lt;<span class="type">Integer</span>&gt;(<span class="built_in">new</span> Machine());</span><br><span class="line">        Thread thread = <span class="built_in">new</span> Thread(task);</span><br><span class="line">        threadMachine.<span class="keyword">start</span>();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("从1到100的和"+task.<span class="keyword">get</span>());//调用<span class="keyword">get</span>返回值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="通过线程池管理多个线程"><a href="#通过线程池管理多个线程" class="headerlink" title="通过线程池管理多个线程"></a>通过线程池管理多个线程</h4><p><img src="/images/java%E7%BA%BF%E7%A8%8B.jpg" alt></p><p>Executor表示线程池，execute方法用来执行command的run()中指定的任务，线程会调度空闲的线程来执行该任务。到底什么时候执行，这是由cpu决定的。</p><ul><li>shutdown(): 预备关闭线程池。如果有任务提交上去，那么要等这些任务执行完后，才会关闭线程池，并且拒绝新任务的入内。</li><li>shutdownNow(): 终止已经开始的任务，立刻关闭线程池</li><li>isTermination(): 判断线程池是否关闭，如果关闭返回true</li><li>awaitTermination(): 等待线程池关闭。</li></ul><p>submit(Callable<t>task)和submit(Runnable task)和execute(Runnable command)类似，但是这个支持异步运算。他们都会返回异步运算结果的Future对象。</t></p><p>Excutors中静态方法：</p><ul><li>newCachedThreadPool(): 创建有缓存的线程池，有任务才创建新线程，空闲的线程停留60s。</li><li>newFixedThreadPool(int nThreads): 创建有固定数目线程的线程池，空闲线程一直保留</li><li>newSingleThreadExecution(): 创建只有一个县城的线程池。这个与newFixedThreadPool(1)不同之处在于这个终止就终止了，Fixed的终止了还会创建一个新的。</li><li>newScheduledThreadPool(int corePoolSize): 线程池会按时间计划创建任务。corePoolsize是线程<strong>最小</strong>数目。</li><li>newSingleThreadScheduledExecutor(): 创建只有一个线程的线程池，这个线程池按计划进行任务。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Machine</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Machine(i));</span><br><span class="line">        &#125;</span><br><span class="line">        service.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里创建了5个线程给线程池，然后线程池中两个空白线程接到任务开始工作，工作完这两个线程后又执行下面两个线程，直到执行完5个线程。然后执行shutdown()关闭线程池。</p><h4 id="BlockingQueue-阻塞队列"><a href="#BlockingQueue-阻塞队列" class="headerlink" title="BlockingQueue 阻塞队列"></a>BlockingQueue 阻塞队列</h4><p>java.util.concurrent.BlockingQueue接口继承了java.util.Queue接口。BlockingQueue接口为多个线程同时操作一个队列提供了方案。</p><table><thead><tr><th>操作</th><th>抛出异常</th><th>放回特定值</th><th>线程阻塞</th><th>超时</th></tr></thead><tbody><tr><td>添加元素</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>删除元素</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>读取元素</td><td>element()</td><td>peek()</td><td>无</td><td>无</td></tr></tbody></table><p>前面两个是队列的，后面两个是阻塞队列的。这个具体等到队列那里再说。这里先把几个BlockingQueue的实现类列一下：</p><ul><li>LinkedBlockingQueue类： 默认情况下，LinkedBlockingQueue的容量是没有上限的，也可以指定大小，这是基于链表的队列</li><li>ArrayBlockingQueue类： ArrayBlockingQueue(int capacity, boolean fair)可以设定容量，并且可以选择是否采用公平策略。这是基于数组的队列。</li><li>PriorityBlockingQueue：这是优先队列（堆）</li><li>DelayQueue: 这个队列中存放的是延期元素。这些元素必须实现java.util.concurrent.Delayed接口。只有延期满的元素才可以被取出或者删除。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri May 15 2020 17:23:19 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;java线程运行机制&quot;&gt;&lt;a href=&quot;#java线程运行机制&quot; class=&quot;headerlink&quot; title=&quot;java线程运行机制
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>c 文件操作</title>
    <link href="http://xinhecuican.github.io/post/e0f8cb74.html"/>
    <id>http://xinhecuican.github.io/post/e0f8cb74.html</id>
    <published>2020-04-29T12:20:00.000Z</published>
    <updated>2020-04-30T00:23:59.687Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>文件总的来说其实就只有两个操作，打开（关闭）和读写。本文也围绕这两个方面展开</p><p><strong>文件格式</strong></p><p>文件一般由三部分组成：路径，文件名，后缀。</p><p>例：<code>&quot;E:\\ch10.doc&quot;或者&quot;E:/ch10.doc&quot;</code></p><p>之所以要两个\是因为在c语言中\作为转义字符。</p><p><strong>流</strong></p><p>流按方向分为：输入流和输出流。从文件获取数据的流称为输入流，向文件输出数据称为输出流。</p><p>例如，从键盘输入数据然后把该数据输出到屏幕上的过程，相当于从一个文件输入流（与键盘相关）中输入（读取）数据，然后通过另外一个文件输出流（与显示器相关）把获取的数据输出（写入）到文件（显示器）上。</p><p><strong>换行符</strong></p><p>在Linux系统中，换行符是0x0a（LF）。因为c是在unix上发展起来的，所以访问Linux文件时，不需要转换，直接可以访问。</p><p>在windows系统中使用0x0d(CR ‘\r’） 和 0x0a(LF ‘\n’)合起来作为换行符。所以把windows下文件给c程序还要先把CR-LF转换成LF</p><p><strong>缓冲文件系统</strong></p><p>缓冲文件系统：系统自动为每个打开的文件在内存开辟一块缓冲区，缓冲区的大小一般由系统决定。当程序向文件中输出（写入）数据时，程序先把数据输出到缓冲区，待缓冲区满或数据输出完成后，再把数据从缓冲区输出到文件；当程序从文件输入(读取)数据时，先把数据输入到缓冲区，待缓冲区满或数据输人完成后，再把数据从缓冲区逐个输入到程序。</p><p>c语言就是用的缓冲文件系统。其实这和vim有点像。</p><p>ANSI C 为正在使用的每个文件分配一个文件信息区，该信息区中包含文件描述信息、 该文件所使用的缓冲区大小及缓冲区位置、该文件当前读写到的位置等基本信息。这些信息保存在一个结构体类型变量中，该结构体类型为 FILE 在 stdio.h 头文件中定义，不允许用户改变。</p><h3 id="文件打开和关闭"><a href="#文件打开和关闭" class="headerlink" title="文件打开和关闭"></a>文件打开和关闭</h3><p>文件指针 file* 用来引用一个文件。</p><p><strong>打开</strong></p><p>原型：<code>FILE * fopen(char *filename, char *mode);</code></p><p>filename指的是文件名，可以包括路径。</p><p>mode是打开方式。下面列举了一些打开方式</p><table><thead><tr><th>模式</th><th>含 义</th><th>说 明</th></tr></thead><tbody><tr><td>r</td><td>只读</td><td>文件必须存在，否则打开失败</td></tr><tr><td>w</td><td>只写</td><td>若文件存在，则清除原文件内容后写入；否则，新建文件后写入</td></tr><tr><td>a</td><td>追加只写</td><td>若文件存在，则位置指针移到文件末尾，在文件尾部追加写人，故该方式不 删除原文件数据；若文件不存在，则打开失败</td></tr><tr><td>r+</td><td>读写</td><td>文件必须存在。在只读 r 的基础上加 ‘+’ 表示增加可写的功能。下同</td></tr><tr><td>w+</td><td>读写</td><td>新建一个文件，先向该文件中写人数据，然后可从该文件中读取数据</td></tr><tr><td>a+</td><td>读写</td><td>在” a”模式的基础上，增加可读功能</td></tr><tr><td>rb</td><td>二进制读</td><td>功能同模式”r”，区别：b表示以二进制模式打开。下同</td></tr><tr><td>wb</td><td>二进制写</td><td>功能同模式“w”。二进制模式</td></tr><tr><td>ab</td><td>二进制追加</td><td>功能同模式”a”。二进制模式</td></tr><tr><td>rb+</td><td>二进制读写</td><td>功能同模式”r+”。二进制模式</td></tr><tr><td>wb+</td><td>二进制读写</td><td>功能同模式”w+”。二进制模式</td></tr><tr><td>ab+</td><td>二进制读写</td><td>功能同模式”a+”。二进制模式</td></tr></tbody></table><p>按照mode 规定的方式，打开由pname指定的文件。若找不到由pname指定的相应文件，就按以下方式之一处理：</p><p>（1） 此时如mode 规定按写方式打开文件，就按由pname指定的名字建立一个新文件；<br>（2） 此时如mode 规定按读方式打开文件，就会产生一个错误。</p><p>例： fopen(“example.txt”, “rw”);</p><p>如果返回失败，那么将返回NULL。</p><p><strong>关闭</strong></p><p>int fclose(FILE *fp);</p><p>如果关闭不正常，返回-1（EOF).</p><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="按字符输入输出"><a href="#按字符输入输出" class="headerlink" title="按字符输入输出"></a>按字符输入输出</h4><p>原型：<code>int fgetc (FILE *fp);</code></p><p>作用：一次读入一个字符。如果读入出现问题，返回-1(EOF)</p><p>注意：由于 fgetc 是以 unsigned char 的形式从文件中输入（读取）一个字节，并在该字节前面补充若干 0 字节，使之扩展为该系统中的一个 int 型数并返回，而非直接返回 char 型。当输入失败时返回文本文件结束标志 EOF 即 -1，也是整数。故返回类型应为 int 型，而非 char 型。</p><p>也就是说最好不要用char类型去接收字符而使用unsigned_char，这样在碰到特殊字符就不会出现错误。</p><p>由于在 C 语言中把除磁盘文件外的输入输出设备也当成文件处理，故从键盘输入字符不仅可以使用宏 getchar() 实现，也可以使用 <strong>fgetc (stdin)</strong> 实现。其中，stdin 指向标准输入设备—键盘所对应的文件。stdin 不需要人工调用函数 fopen 打开和 fclose 关闭。</p><p><strong>按字符输出</strong></p><p>原型： <code>int fputc (int c, FILE *fp);</code></p><p>向fp文件中输出字符c。如果想输出到屏幕，可以<code>fputc(c, stdout)</code></p><p>对一个文件进行读写操作时，经常会把一个文件中读写位置重新调整到文件的开始处，可以使用函数 rewind 实现。</p><p>原型: <code>void rewind (FILE *fp);</code></p><p>作用：把<strong>读写</strong>位置跳到函数开头。</p><h4 id="按字符串输入输出"><a href="#按字符串输入输出" class="headerlink" title="按字符串输入输出"></a>按字符串输入输出</h4><p><strong>输入</strong></p><p>原型： <code>char * fgets (char *s, int size, FILE * fp);</code></p><p>作用： 从文件中读取长度为size（到了末尾会终止）的字符串，并且自动加入’\0’后输出，遇到空格不会终止。</p><p><strong>输出</strong></p><p>原型： <code>int fputs (const char *str, FILE *fp);</code></p><p>作用：把str输出到文件中。</p><h4 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h4><p>这个与scanf和printf类似，只是目标变成了文件。</p><p><strong>输入</strong></p><p>原型： <code>int fscanf (文件指针，格式控制串，输入地址表列);</code></p><p>作用：从文件中输入到格式化字符串中，遇到空格会终止输入。</p><p>返回值：返回整型，输入成功时，返回输入的数据个数；输入失败，或已读取到文件结尾处，返回 EOF(-1)</p><p>例： fscanf (fp,”%d,%d”, &amp;a, &amp;b); //两个%d之间也必须用逗号隔开</p><p><strong>输出</strong></p><p>int fprintf (文件指针，格式控制串，输出表列)；</p><p>作用： 把格式字符串中的数据输出到文件中。</p><h4 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h4><p><strong>输入</strong></p><p>原型：<code>unsigned fread (void *buf, unsigned size, unsigned count, FILE* fp);</code></p><p>作用：从 fp 指向的文件中读取 count 个数据块，每个数据块的大小为 size。把读取到的数据块存放到 buf 指针指向的内存空间中。</p><p>返回值：返回实际读取的数据块（非字节）个数，如果该值比 count 小，则说明已读到文件尾或有错误产生。这时一般采用函数 feof 及 ferror 来辅助判断。</p><p><strong>输出</strong></p><p>原型：<code>unsigned fwrite (const void *buf,unsigned size,unsigned count,FILE* fp);</code></p><p>作用： 把buf中count个大小为size的数据块写到文件中</p><p><strong>文件检查</strong></p><p>原型： <code>int feof (FILE * fp);</code></p><p>作用：检查是否到了文佳末尾，如果到了，返回非0</p><h4 id="随机读写"><a href="#随机读写" class="headerlink" title="随机读写"></a>随机读写</h4><p>随机读写就是不是在文件开头而是制定一个位置开始读写。首先要把文件指针移到对应位置，然后开始读写。</p><p>原型： <code>int fseek(FILE *fp, long offset, int origin);</code></p><p>作用：把fp读写指针设置到origin+offset的位置上，origin是起始位置。offset是偏移量。</p><p>起始位置有三种快捷的设置。分别是：</p><ul><li>SEEK_SET:文件开头，即第一个有效数据的起始位置。</li><li>SEEK_CUR：当前位置。</li><li>SEEK_END:文件结尾，即最后一个有效数据之后的位置。注意：此处并不能读取到最后一个有效数据，必须前移一个数据块所占的字节数，使该文件流的读写指针到达最后一个有效数据块的起始位置处。</li></ul><p>可以通过<code>long ftell (FILE *fp);</code>获得当前指针对于文件开始位置的偏移量</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;文件总的来说其实
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
