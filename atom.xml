<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-02-02T06:14:09.213Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>int指令</title>
    <link href="http://xinhecuican.github.io/2020/02/02/int%E6%8C%87%E4%BB%A4/"/>
    <id>http://xinhecuican.github.io/2020/02/02/int%E6%8C%87%E4%BB%A4/</id>
    <published>2020-02-02T01:52:00.000Z</published>
    <updated>2020-02-02T06:14:09.213Z</updated>
    
    <content type="html"><![CDATA[<p>格式： int n，n为中断类型码</p><p>在程序中可以采用int指令调用任何一个中断处理程序</p><p>例如： int 0 ，就会调用除法溢出的处理程序</p><p>所以说，int指令最终的功能与call指令类似，都是调用一段程序</p><p>例 用中断程序实现循环</p><p>要想实现循环，需要知道两个量，第一个是循环次数，第二个是跳转位移。循环次数用cx来保存，跳转位移用bx来保存</p><p>而为了实现loop指令，中断例程需要实现两个功能</p><ol><li>dec cx</li><li>cx=0，则顺序执行，否则，跳转</li></ol><p>代码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ...安装</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bx</span>,offset s-offset se</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span></span><br><span class="line"><span class="symbol"> s:</span> <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="string">'!'</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">7ch</span>；这时<span class="built_in">ip</span>指向下一条指令即se标号</span><br><span class="line"><span class="symbol">se:</span> <span class="keyword">nop</span></span><br><span class="line"><span class="symbol">lp:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">dec</span> <span class="built_in">cx</span> <span class="comment">;cx--</span></span><br><span class="line">   <span class="keyword">jcxz</span> lpret</span><br><span class="line">   <span class="keyword">add</span> [<span class="built_in">bp</span>+<span class="number">2</span>],<span class="built_in">bx</span>//因为入栈顺序为标志寄存器，<span class="built_in">cs</span>，<span class="built_in">ip</span>，而<span class="keyword">add</span>是与后两个字节<span class="keyword">add</span></span><br><span class="line"><span class="symbol">ipret:</span> <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">     <span class="keyword">iret</span> //没到<span class="built_in">cx</span>=<span class="number">0</span>时也会终止，但这时<span class="built_in">ip</span>就不会回到s标号处</span><br></pre></td></tr></table></figure><h3 id="blos-和-dos中断例程安装过程"><a href="#blos-和-dos中断例程安装过程" class="headerlink" title="blos 和 dos中断例程安装过程"></a>blos 和 dos中断例程安装过程</h3><ol><li><p>开机后，cs：ip初始化为0ffff：0 ，这里有一条跳转指令，自动跳转到blos中的硬件系统检测和安装程序</p></li><li><p>初始化程序将建立blos所支持的中断向量，即把blos提供的中断例程载入中断向量表中</p></li><li><p>硬件检测完之后，调用int 19h进行操作系统的引导，从此把计算机给操作系统控制</p><h3 id="blos中断例程的应用"><a href="#blos中断例程的应用" class="headerlink" title="blos中断例程的应用"></a>blos中断例程的应用</h3><p>int 10h 中断例程是blos提供的，包含多个与屏幕输出有关的子程序</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span></span><br></pre></td></tr></table></figure><p>ah=2表示调用10h中的2号子程序，功能为设置光标的位置，</p><p>bh=0，dh=5，dl=12 设置光标到第0页，第5行，第12列</p><p>mov ah ，9 表示调用第9号子程序，功能为在光标位置显示字符，可以提供显示字符的各种属性</p></li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">9</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="string">'a'</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">11001010b</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span>//字符重复次数</span><br><span class="line">    <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="dos中断例程的应用"><a href="#dos中断例程的应用" class="headerlink" title="dos中断例程的应用"></a>dos中断例程的应用</h3><p>int 21h就是dos的中断例程，</p><p>我们一直使用的是int 21h中的4ch功能，即程序返回功能</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">4ch</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure><p>ah=4ch表示调用21h中的4ch号子程序</p><p>21h 中的光标位置显示字符功能</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ds:</span><span class="built_in">dx</span> 指向字符串</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>，<span class="number">9</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure><p>调用第九号子程序</p><p>dh中放行号，dl中放列号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;格式： int n，n为中断类型码&lt;/p&gt;
&lt;p&gt;在程序中可以采用int指令调用任何一个中断处理程序&lt;/p&gt;
&lt;p&gt;例如： int 0 ，就会调用除法溢出的处理程序&lt;/p&gt;
&lt;p&gt;所以说，int指令最终的功能与call指令类似，都是调用一段程序&lt;/p&gt;
&lt;p&gt;例 用中断程序
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>内中断</title>
    <link href="http://xinhecuican.github.io/2020/02/01/%E5%86%85%E4%B8%AD%E6%96%AD/"/>
    <id>http://xinhecuican.github.io/2020/02/01/%E5%86%85%E4%B8%AD%E6%96%AD/</id>
    <published>2020-02-01T01:01:00.000Z</published>
    <updated>2020-02-02T02:25:37.508Z</updated>
    
    <content type="html"><![CDATA[<p>一般cpu都有一种能力，就是接受cpu内部或外部发来的信号，停止当前程序而取执行其他的程序。这种信息叫做中断信息，中断信息指的是cpu接受到这种信息后立刻处理这个信息。接受到这个信息后cpu会交给专门的程序去处理，叫做中断处理程序</p><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>内中断指的是中断信息来自cpu内部。当cpu接受到相应几种情况时，会产生相应的中断信息</p><ol><li>除法错误 例如 ，div除法溢出</li><li>单步执行</li><li>执行into指令</li><li>执行int 指令</li></ol><p>我们先不需要了解具体含义。为了更方便的知道到底属于那种中断信息，8086cpu用了一个字节的中断类型码来确定。</p><ol><li>除法错误 0</li><li>单步执行 1</li><li>执行into指令 4</li><li>int： int n ，n就是中断类型码</li></ol><p>cpu根据cs:ip知道程序的入口，所以中断类型码中必定有cs:ip的信息，可cpu如何根据8位的类型吗知道程序的入口呢？</p><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>cpu通过中断类型码找到中断向量表，而中断向量表中就保存着程序的入口。中断向量表在内存中保存。中断内存表位于0000:0000 到 0000:03ff 1024个字节中</p><h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>找到cs：ip的过程叫做中断过程。</p><p>cpu收到中断信息后，要对中断信息进行处理。但是完成中断程序之后还要返回，就像call和ret一样。所以总过程如下</p><ol><li>获得中断类型码</li><li>标志寄存器的值入栈（因为中断过程会改变标志寄存器的值）</li><li>设置标志寄存器第8位和第九位的值为0</li><li>cs入栈</li><li>ip入栈</li><li>设置cs：ip</li></ol><p>更简洁的说明</p><ol><li>获得 中断类型码 n</li><li>pushf</li><li>tf=0 if=0</li><li>push cs</li><li>push ip</li><li>ip=n<em>4，cs=n</em>4+2</li></ol><h3 id="iret指令"><a href="#iret指令" class="headerlink" title="iret指令"></a>iret指令</h3><p>中断处理程序用iret进行返回</p><p>内容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><p>这个正好与进栈顺序相反</p><h3 id="除法错误中断的处理"><a href="#除法错误中断的处理" class="headerlink" title="除法错误中断的处理"></a>除法错误中断的处理</h3><p>cpu如果产生除法溢出错误，将会产生中断类型码为0的中断信息。引发中断过程。然后中断处理程序会返回 divide overflow 再返回到主程序中</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span> do0安装程序</span><br><span class="line">     设置中断向量表</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00h</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol"> do0:</span> 显示字符串“overflow！”</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意：do0也要返回</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>用movsb指令，将do0的代码送入0:200处</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> 设置<span class="built_in">es</span>:<span class="built_in">di</span>指向目的地址</span><br><span class="line">     设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向源地址</span><br><span class="line">     设置传输长度</span><br><span class="line">     设置传输方向为正</span><br><span class="line">     <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line">     </span><br><span class="line">     设置中断表</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>我们如何知道do0代码长度？</p><p>可以用编译器来知道do0的长度</p><p><code>mov cx,offset do0end-offset do0</code></p><p>“-”是编译器识别的符号，编译器可以用它来做两个常数的减法</p><p>例如 mov ax,(5+3)*5/10 被编译器识别为 mov ax，4</p><h3 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h3><p>do0的主要任务是显示字符串</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0:</span> 设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向字符串</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">9</span></span><br><span class="line"><span class="symbol">  s:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">do0end:</span><span class="keyword">nop</span></span><br></pre></td></tr></table></figure><p>这个程序看起来对，实际上有问题，因为程序执行完后内存立刻被释放，其中保存的内容也可能被其他的程序覆盖。正确的程序如下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="symbol">do0:</span> <span class="keyword">jmp</span> short do0start</span><br><span class="line">   <span class="built_in">db</span> <span class="string">"overflow!"</span></span><br><span class="line"><span class="symbol">do0start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">202h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">9</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span>//用<span class="keyword">iret</span>也可以，用的话表示还会返回主程序中</span><br><span class="line"><span class="symbol">do0end:</span> <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h3><p>现在do0的入口为 0:200 ,写入中断向量表的0号表项中。使do0成为0号中断处理程序<br>0号表项地址为0:0 ，其中0:0存放偏移地址，0:2存放段地址。程序如下</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>cpu执行完一条指令后，如果检测到tf=1，则产生单步中断，单步中断类型码为1，过程如下</p><ol><li>获得中断类型码</li><li>标志寄存器入栈，tf if设置为0</li><li>cs，ip入栈</li><li>ip=1<em>4 cs=1</em>4+2</li></ol><p>cpu为什么要提供单步中断呢？在debug的t命令中，为什么执行完一条 指令后，能够实时的反映寄存器的状态？这便是cpu单步中断导致可以一条条指令执行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般cpu都有一种能力，就是接受cpu内部或外部发来的信号，停止当前程序而取执行其他的程序。这种信息叫做中断信息，中断信息指的是cpu接受到这种信息后立刻处理这个信息。接受到这个信息后cpu会交给专门的程序去处理，叫做中断处理程序&lt;/p&gt;
&lt;h3 id=&quot;内中断&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>df标志和传送指令</title>
    <link href="http://xinhecuican.github.io/2020/01/31/df%E6%A0%87%E5%BF%97%E5%92%8C%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4/"/>
    <id>http://xinhecuican.github.io/2020/01/31/df%E6%A0%87%E5%BF%97%E5%92%8C%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4/</id>
    <published>2020-01-31T02:21:00.000Z</published>
    <updated>2020-01-31T02:45:01.009Z</updated>
    
    <content type="html"><![CDATA[<p>flag第十位是df，方向标志位，在串处理指令中，控制每次操作后si，di的增减</p><p>df=0，每次操作后都是si，di增</p><p>df=1，减</p><h4 id="串传送指令"><a href="#串传送指令" class="headerlink" title="串传送指令"></a>串传送指令</h4><h5 id="movsb"><a href="#movsb" class="headerlink" title="movsb"></a>movsb</h5><p>格式： movsb</p><p>功能：</p><ol><li>es<em>16+di=ds</em>16+si</li><li>如果df=0，则 si=si+1，di=di+1，等于一相反</li></ol><p>汇编语言描述</p><ol><li>mov se:[di],byte ptr ds:[si] （汇编不支持这样的指令）</li><li>如果df=0 inc si inc di else dec si dec di</li></ol><p>movsb的功能是将ds：si中的数据传到 es：di中</p><h5 id="movsw"><a href="#movsw" class="headerlink" title="movsw"></a>movsw</h5><p>格式 movsw</p><p>这个是按字来传送，si和di+2或-2</p><h5 id="rep"><a href="#rep" class="headerlink" title="rep"></a>rep</h5><p>rep movsb</p><p>相当于</p><pre><code>s: movsb  loop s</code></pre><p>rep的作用是根据cx的值，重复执行后面的串传送指令</p><h4 id="df-设置指令"><a href="#df-设置指令" class="headerlink" title="df 设置指令"></a>df 设置指令</h4><p>cld 指令： 将df设置为0<br>std指令： 将df设置为1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;flag第十位是df，方向标志位，在串处理指令中，控制每次操作后si，di的增减&lt;/p&gt;
&lt;p&gt;df=0，每次操作后都是si，di增&lt;/p&gt;
&lt;p&gt;df=1，减&lt;/p&gt;
&lt;h4 id=&quot;串传送指令&quot;&gt;&lt;a href=&quot;#串传送指令&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>检测比较结果的条件转移指令</title>
    <link href="http://xinhecuican.github.io/2020/01/31/%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%8C%87%E4%BB%A4/"/>
    <id>http://xinhecuican.github.io/2020/01/31/%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%8C%87%E4%BB%A4/</id>
    <published>2020-01-31T01:37:00.000Z</published>
    <updated>2020-01-31T02:21:09.462Z</updated>
    
    <content type="html"><![CDATA[<p>转移是指它可以修改ip，条件指在某种特定情况下才会修改</p><p>例如 jcxz就是一个条件转移指令，只有在cx=0的情况下才会跳转</p><p>下列转移指令都是根据cmp指令进行的转移</p><h3 id="无符号数情况下的转移"><a href="#无符号数情况下的转移" class="headerlink" title="无符号数情况下的转移"></a>无符号数情况下的转移</h3><p>|指令|含义|检测的标志位|<br>|—-|<br>|je|等于则转移|zf=1|<br>|jne|不等于则转移|zf=0|<br>|jb|小于则转移|cf=1|<br>|jnb|大于等于则转移|cf=0|<br>|ja|高于则转移|cf=0且zf=0|<br>|jna|不高于则转移|cf=1或zf=1|</p><p>记忆方法：第一个字母都是j，代表jump</p><p>e：equal</p><p>ne：not equal</p><p>b：below</p><p>a：above </p><p>不一定要在前面是cmp指令，例如</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">je</span> s</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="symbol">s:</span> <span class="keyword">inc</span> <span class="built_in">ax</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转移是指它可以修改ip，条件指在某种特定情况下才会修改&lt;/p&gt;
&lt;p&gt;例如 jcxz就是一个条件转移指令，只有在cx=0的情况下才会跳转&lt;/p&gt;
&lt;p&gt;下列转移指令都是根据cmp指令进行的转移&lt;/p&gt;
&lt;h3 id=&quot;无符号数情况下的转移&quot;&gt;&lt;a href=&quot;#无符号数情况
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>标志寄存器</title>
    <link href="http://xinhecuican.github.io/2020/01/29/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://xinhecuican.github.io/2020/01/29/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</id>
    <published>2020-01-29T02:48:00.000Z</published>
    <updated>2020-01-31T02:51:47.480Z</updated>
    
    <content type="html"><![CDATA[<p>标志寄存器16位中只有9位有特殊作用</p><p>|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|<br>|———————————-|<br>|CF|0 |PF|0 |AF| 0|ZF|SF|IF|DF|OF|0 | 0|0 | 0| 0|</p><h4 id="ZF"><a href="#ZF" class="headerlink" title="ZF"></a>ZF</h4><p>ZF含义是执行完指令后结果是否为0，为0,ZF=1，不为0,ZF=0</p><p>例如 </p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,<span class="number">1</span> ;ZF=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">ax</span>,1 </span>;ZF=<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="PF"><a href="#PF" class="headerlink" title="PF"></a>PF</h4><p>奇偶标志位，它记录相关指令执行后，其结果的所有bit为中1的个数是否为偶数，如果1的个数为偶数，pf=1,反之则为0</p><h4 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h4><p>符号标志位，看结果是否为负，如果为负，则SF=1</p><h4 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h4><p>进位标志位，一般情况下，对无符号数运算时，它记录了超过最高位的值</p><p>例如 ，add 255,255 这时已经超过最高位了，我们已经知道，超过最高位的数据都会被丢失，实际上它被保存在CF中，但只会保存一位</p><p>做减法时，还有可能发生错位，例如，两个8位数据，-4+5，将产生错位。错位后，相当于计算 252+5，超过255，因此会记录，因为无符号数中负数就是255-该值。<strong>小的减大的时会产生借位</strong></p><h4 id="OF"><a href="#OF" class="headerlink" title="OF"></a>OF</h4><p>溢出标志位，在有符号数运算时，可能会产生溢出，即小于最小值或大于最大值，如果超出，就会让OF=1</p><h4 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h4><p>adc是带进位加法指令，它利用了CF位上记录的进位值</p><p>格式 adc 对象1，对象2</p><p>功能 对象1=对象1+对象2+CF</p><p>例</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行后ax=4，adc执行时，相当于计算 ax+1+CF=2+1+1=4</p><p>这个指令有什么意义呢？实际上加法都可以分为两步操作，第一步是低位相加，第二步是高位相加再加上低位的进位，用汇编语言可以表示为</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="keyword">adc</span> <span class="number">ah</span>,<span class="number">bh</span></span><br></pre></td></tr></table></figure><p>这样我们就可以对更大的数据进行运算</p><p>例：计算1EF0001000H+2010001EF0H,结果放在ax（最高16位），bx，cx中<br>计算分三步</p><ol><li>先将低16位相加，完成后，CF记录本次进位值</li><li>再将中16位与CF相加，完成后，CF记录本次相加进位值</li><li>最后将高16位与CF相加<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">001eh</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0f000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">cx</span>,<span class="number">1ef0h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">0020h</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h4><p>带借位减法指令</p><p>格式 sbb 对象1，对象2</p><p>功能： 对象1=对象1-对象2-CF</p><h4 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h4><p>比较指令，相当于减法指令，但是不保存结果，只对标志寄存器产生影响</p><p>格式： cmp 对象1，对象2</p><p>功能： 对象1-对象2，但并不保存结果，对寄存器产生影响</p><p>例：</p><p>cmp ax，bx</p><ol><li><p>ax=bx，则ax-bx=0，zf=1</p></li><li><p>ax！=bx，则zf=0</p></li><li><p>ax&lt;bx, 将产生借位，cf=1</p></li><li><p>ax&gt;=bx, cf=0</p></li><li><p>ax&gt;bx  ,不产生借位结果又不为0，所以zf=0，cf=0</p></li><li><p>ax&lt;=bx,可能产生借位结果也可能为0，所以zf=1或cf=1</p></li></ol><p>这是无符号位的，还有有符号位的</p><p>同理 </p><ol><li>ax=bx，则zf=1</li><li>ax！=bx，zf=0</li></ol><p>但是这时就不能简单的用sf来判断了，因为sf只是符号标志位，它记录了计算结果的正负，但它并不能判断溢出。所以我们同时还要运用寄存器of来判断溢出</p><p>例： sf=1，of=0. of=0，说明没有溢出，直接用sf判断即可，sf=1说明ax&lt;bx</p><p>sf=1,of=1.这样就说明有溢出，<strong>因此说明是由于溢出导致结果为负，所以真正的结果必然为正</strong>，所以ax&gt;bx</p><p>sf=0,,of=1. 有溢出，ah&lt;bh</p><h4 id="标志寄存器在debug中的表示"><a href="#标志寄存器在debug中的表示" class="headerlink" title="标志寄存器在debug中的表示"></a>标志寄存器在debug中的表示</h4><p>|标志| 值为1的标记| 值为0的标记|<br>|—————-|<br>|of|ov|nv|<br>|sf|ng|pl|<br>|zf|zr|nz|<br>|pf|pe|po|<br>|cf|cy|nc|<br>|df|dn|up|</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标志寄存器16位中只有9位有特殊作用&lt;/p&gt;
&lt;p&gt;|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|&lt;br&gt;|———————————-|&lt;br&gt;|CF|0 |PF|0 |AF| 0|ZF|SF|IF|DF|OF|0 | 0|0 | 0| 0|&lt;
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编语言写函数</title>
    <link href="http://xinhecuican.github.io/2020/01/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%86%99%E5%87%BD%E6%95%B0/"/>
    <id>http://xinhecuican.github.io/2020/01/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%86%99%E5%87%BD%E6%95%B0/</id>
    <published>2020-01-28T01:10:00.000Z</published>
    <updated>2020-01-28T02:40:56.293Z</updated>
    
    <content type="html"><![CDATA[<p>例,计算data段第一行的三次方，并储存到第二行上</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">    <span class="built_in">dd</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span></span><br><span class="line"><span class="symbol">  s:</span> <span class="keyword">mov</span> <span class="built_in">bx</span>,[<span class="built_in">si</span>]</span><br><span class="line">    <span class="keyword">call</span> cube</span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">di</span>].<span class="number">2</span>,<span class="built_in">dx</span> ；这个的含义是[<span class="built_in">di</span>]的第二个字节</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">4</span></span><br><span class="line">    <span class="keyword">loop</span> s</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">cube:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"> code ends</span><br><span class="line"> end start</span><br></pre></td></tr></table></figure><p> 这个程序函数是cube，注意想要跳转就用call，想要返回就用ret。这时返回值存在ax和dx中，参数在bx中，可如果有多个参数，寄存器不够时，可以用栈来传递参数</p><h3 id="用栈传递参数"><a href="#用栈传递参数" class="headerlink" title="用栈传递参数"></a>用栈传递参数</h3><p> 例：计算（a-b）^3，a，b为字型数据<br> 参数 进入子程序时，栈顶存放ip，后面依次存放a，b<br> 结果：（dx：ax）=(a-b)^3<br> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">difcube:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">4</span>] <span class="comment">;将a的值送入栈中</span></span><br><span class="line">      <span class="keyword">sub</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">6</span>] ；减去b的值</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">ret</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><br> ret n的含义为，pop ip add sp，n</p><p> 而ret 4 的原因是此时栈中有2个数据，要想把栈清空，要移动四个单位（字型）。而push bp ，pop bp 是为了保证bp中的数据没有改变</p><h3 id="寄存器冲突问题"><a href="#寄存器冲突问题" class="headerlink" title="寄存器冲突问题"></a>寄存器冲突问题</h3><p> 例 将data段中的字母变为大写，以0结尾<br> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">   <span class="built_in">db</span> <span class="string">'fafdsfs'</span>,<span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">call</span> capital</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">5</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">capital:</span> <span class="keyword">mov</span> <span class="built_in">cl</span>,,[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">jcxz</span> ok</span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">jmp</span> short capital</span><br><span class="line"><span class="symbol">    ok:</span><span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><br>这个程序实际上是有问题的，因为进行一次capital后，cx的值一定为0，直接退出主程序的循环</p><p>要解决这个问题，有两种方案</p><ol><li>找另一个没有使用的寄存器</li><li>不要使用会发生冲突的寄存器</li></ol><p>这样实际上是不可能的，例如cx，循环便一定会冲突</p><p>解决方案就是，在进入函数前把所用到寄存器的内容保存起来，结束函数在进行使用</p><p>由此我们可以得到子程序设计的标准</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子程序开始： 子程序中使用的寄存器入栈</span><br><span class="line">         子程序内容</span><br><span class="line">         子程序所使用寄存器出栈</span><br><span class="line">         返回 （<span class="keyword">ret</span> ，<span class="keyword">retf</span>）</span><br></pre></td></tr></table></figure><p> 这里要注意一个问题，当把寄存器内容入栈后，sp会发生改变，如果子程序中也要使用栈要注意地址的变化</p><p> 同时还要注意入账和出栈的顺序<br> 例<br> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">capital:</span> <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">      <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">cx</span></span><br></pre></td></tr></table></figure><br> 后进先出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;例,计算data段第一行的三次方，并储存到第二行上&lt;/p&gt;
&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>mul指令</title>
    <link href="http://xinhecuican.github.io/2020/01/27/mul%E6%8C%87%E4%BB%A4/"/>
    <id>http://xinhecuican.github.io/2020/01/27/mul%E6%8C%87%E4%BB%A4/</id>
    <published>2020-01-27T03:34:00.000Z</published>
    <updated>2020-01-27T05:08:54.404Z</updated>
    
    <content type="html"><![CDATA[<p>两个相乘的数：</p><p>如果是8位，那么一个默认在al中，另一个在8位寄存器或内存字节单元中，如果是16位，一个在ax中，另一个在16位寄存器或内存字单元中</p><p>结果： 如果是8位，结果默认在ax中，如果是16位，高位默认在dx中，低位在ax中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两个相乘的数：&lt;/p&gt;
&lt;p&gt;如果是8位，那么一个默认在al中，另一个在8位寄存器或内存字节单元中，如果是16位，一个在ax中，另一个在16位寄存器或内存字单元中&lt;/p&gt;
&lt;p&gt;结果： 如果是8位，结果默认在ax中，如果是16位，高位默认在dx中，低位在ax中&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>call指令</title>
    <link href="http://xinhecuican.github.io/2020/01/27/call%E6%8C%87%E4%BB%A4/"/>
    <id>http://xinhecuican.github.io/2020/01/27/call%E6%8C%87%E4%BB%A4/</id>
    <published>2020-01-27T02:10:00.000Z</published>
    <updated>2020-01-27T02:37:16.077Z</updated>
    
    <content type="html"><![CDATA[<p>操作</p><ol><li>将当前的ip或cs压入栈中</li><li>转移</li></ol><p>这里的转移与jmp相同，也有位移和内存两种方式</p><h3 id="根据位移"><a href="#根据位移" class="headerlink" title="根据位移"></a>根据位移</h3><p>call 标号（将ip压入栈中后，转移到标号处进行指令）<br>过程：</p><ol><li>sp+=2，ss*16+sp=ip</li><li>ip=ip+16位位移</li></ol><p>16位位移=标号处地址-call指令后第一个字节的地址</p><p>相当于 push ip，jmp near ptr 标号</p><h3 id="根据目的地址"><a href="#根据目的地址" class="headerlink" title="根据目的地址"></a>根据目的地址</h3><p>call far ptr 实现段间转移</p><p>操作： </p><ol><li>sp-=2</li><li>ss*16+sp=cs</li><li>sp-=2</li><li>ss*16+sp=ip</li><li>cs=标号所在段地址，ip=；标号所在偏移地址</li></ol><p>段内转移一般是根据位移，段间转移一般是根据地址</p><p>如果地址在寄存器中， call reg，ip被修改</p><p>如果地址在内存中</p><p>1 call word ptr 内存地址</p><p>这种是段内转移，相当于 push ip，jmp word ptr</p><p>2 call dword ptr 内存地址</p><p>段间转移 例</p><p>call dword ptr ds：[0] ，这样ds:[0]和ds:[1]是ip ，ds:[2]和ds:[3]是cs</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将当前的ip或cs压入栈中&lt;/li&gt;
&lt;li&gt;转移&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里的转移与jmp相同，也有位移和内存两种方式&lt;/p&gt;
&lt;h3 id=&quot;根据位移&quot;&gt;&lt;a href=&quot;#根据位移&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>ret 和 retf</title>
    <link href="http://xinhecuican.github.io/2020/01/27/ret-%E5%92%8C-retf/"/>
    <id>http://xinhecuican.github.io/2020/01/27/ret-%E5%92%8C-retf/</id>
    <published>2020-01-27T01:59:00.000Z</published>
    <updated>2020-01-27T02:08:25.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h3><p>ret指令用栈中的数据，修改ip中的内容，从而实现近转移</p><p>过程：</p><ol><li><p>ip=ss*16+sp</p></li><li><p>sp+=2</p></li></ol><p>相当于 pop ip</p><h3 id="retf"><a href="#retf" class="headerlink" title="retf"></a>retf</h3><p>修改cs和ip 的内容，实现远转移<br>过程</p><ol><li>ip=ss*16+sp</li><li>sp+=2</li><li>cs=ss*16+sp</li><li>sp+=2</li></ol><p>相当于 pop ip ，pop cs</p><p>例</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ss</span>:stack</span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这条指令相当于把ip变为0，指向第一条指令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ret&quot;&gt;&lt;a href=&quot;#ret&quot; class=&quot;headerlink&quot; title=&quot;ret&quot;&gt;&lt;/a&gt;ret&lt;/h3&gt;&lt;p&gt;ret指令用栈中的数据，修改ip中的内容，从而实现近转移&lt;/p&gt;
&lt;p&gt;过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ip=ss*16+s
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>jmp进行跳转</title>
    <link href="http://xinhecuican.github.io/2020/01/26/jmp%E8%BF%9B%E8%A1%8C%E8%B7%B3%E8%BD%AC/"/>
    <id>http://xinhecuican.github.io/2020/01/26/jmp%E8%BF%9B%E8%A1%8C%E8%B7%B3%E8%BD%AC/</id>
    <published>2020-01-26T01:52:00.000Z</published>
    <updated>2020-01-26T05:56:20.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="根据位移进行的转移"><a href="#根据位移进行的转移" class="headerlink" title="根据位移进行的转移"></a>根据位移进行的转移</h3><p>用jmp进行跳转时，会发现一个奇怪的问题，无论它要跳转到哪里，它的机器码始终不变，为EB03，那么它到底是怎么告诉cpu修改ip地址的呢？</p><p>先回忆一下cpu读取指令的过程</p><ol><li>cs=076a ip=0006，cs：ip指向eb03</li><li>读取指令码eb03到指令缓冲器</li><li>ip=ip+指令长度=0008h，cs：ip指向下一条指令</li><li>cpu执行指令缓冲器中的指令eb03</li><li>执行完缓冲器中的指令后，ip被修改+</li></ol><p>jmp指令并不需要转移的目的地址，但是它是凭借什么转移的呢？这里有个03，正好跳过三个字节之后就是要转移的地址。原来jmp指令只需知道当前指令的下一个指令（因为执行完这条指令后ip会增加）与要跳转的指令的位移就可以了</p><p>jmp short 标号 功能是 ip=ip+8位位移（一字节）</p><p>jmp near ptr 标号 是16位</p><p>jmp far ptr 标号 是段间转移，可以修改cs</p><p>还可以直接 jmp 寄存器1：寄存器2</p><h3 id="根据内存进行的转移"><a href="#根据内存进行的转移" class="headerlink" title="根据内存进行的转移"></a>根据内存进行的转移</h3><p>转移地址再内存中的转移有两种格式</p><ol><li>jmp word  ptr（段内转移）</li></ol><p>例 jmp word ptr ds：[0]</p><p>jmp word ptr [bx]</p><p>2.jmp dword ptr (段间转移）后面接两个字，第一个是偏移地址，第二个是段地址</p><p>例 jmp dword ptr ds：[0],0 完成后段地址为0</p><p>注意</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">nop</span></span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">di</span>,offset s</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">si</span>,offset s2</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">cs</span>:[<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="symbol">   s0:</span> <span class="keyword">jmp</span> short s</span><br><span class="line"><span class="symbol">   s1:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">       <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">   s2:</span> <span class="keyword">jmp</span> short s1</span><br><span class="line">       <span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这个程序奇怪之处在于运行到mov cs：[di],ax后 s处会变为jmp 0000，这里就要记住jmp传递的是偏移地址，也就是说，jmp short s1这个指令并不是真的跳到s1处，而是往前跳8个字节</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;根据位移进行的转移&quot;&gt;&lt;a href=&quot;#根据位移进行的转移&quot; class=&quot;headerlink&quot; title=&quot;根据位移进行的转移&quot;&gt;&lt;/a&gt;根据位移进行的转移&lt;/h3&gt;&lt;p&gt;用jmp进行跳转时，会发现一个奇怪的问题，无论它要跳转到哪里，它的机器码始终不变，为
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>操作符offset</title>
    <link href="http://xinhecuican.github.io/2020/01/26/%E6%93%8D%E4%BD%9C%E7%AC%A6offset/"/>
    <id>http://xinhecuican.github.io/2020/01/26/%E6%93%8D%E4%BD%9C%E7%AC%A6offset/</id>
    <published>2020-01-26T01:15:00.000Z</published>
    <updated>2020-01-26T01:50:28.925Z</updated>
    
    <content type="html"><![CDATA[<p>offset是由编译器处理的符号，它的功能是获得标号的偏移地址</p><p>例</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset start//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">0</span></span><br><span class="line"><span class="symbol">   s:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,offset s//相当于<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">3</span></span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><p>上面的程序中offset获得了start和s的偏移地址0和3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;offset是由编译器处理的符号，它的功能是获得标号的偏移地址&lt;/p&gt;
&lt;p&gt;例&lt;/p&gt;
&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>dup</title>
    <link href="http://xinhecuican.github.io/2020/01/24/dup/"/>
    <id>http://xinhecuican.github.io/2020/01/24/dup/</id>
    <published>2020-01-24T02:51:00.000Z</published>
    <updated>2020-01-24T02:54:30.430Z</updated>
    
    <content type="html"><![CDATA[<p>dup用来处理重复数据</p><p>例：db 3 dup (0) 这个意思是定义了三个0的字节型数据</p><p>db 3 dup （0,1,2) 定义了九个数据</p><p>db 3 dup (‘abc’,’ABC’)定义18个数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dup用来处理重复数据&lt;/p&gt;
&lt;p&gt;例：db 3 dup (0) 这个意思是定义了三个0的字节型数据&lt;/p&gt;
&lt;p&gt;db 3 dup （0,1,2) 定义了九个数据&lt;/p&gt;
&lt;p&gt;db 3 dup (‘abc’,’ABC’)定义18个数据&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>dd</title>
    <link href="http://xinhecuican.github.io/2020/01/24/dd/"/>
    <id>http://xinhecuican.github.io/2020/01/24/dd/</id>
    <published>2020-01-24T02:48:00.000Z</published>
    <updated>2020-01-24T02:51:23.831Z</updated>
    
    <content type="html"><![CDATA[<p>dd是用来定义双字型</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> segment</span></span><br><span class="line">    dd <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> ends</span></span><br></pre></td></tr></table></figure><p>要注意dd要占两个字，db一个字节，dw一个字</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dd是用来定义双字型&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编语言数据位置的表达</title>
    <link href="http://xinhecuican.github.io/2020/01/24/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE/"/>
    <id>http://xinhecuican.github.io/2020/01/24/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE/</id>
    <published>2020-01-24T02:08:00.000Z</published>
    <updated>2020-01-24T02:34:56.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h3><p>其实就是idata，这种数据执行前在cpu的指令缓冲器中，在汇编指令中直接给出</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>指令要处理的数据在寄存器中，在汇编指令中给出相应寄存器名</p><h3 id="段地址（SA）和偏移地址（EA"><a href="#段地址（SA）和偏移地址（EA" class="headerlink" title="段地址（SA）和偏移地址（EA)"></a>段地址（SA）和偏移地址（EA)</h3><p>这些数据在内存中，在汇编指令中可以用[x]的方式给出</p><h2 id="指令要处理数据有多长"><a href="#指令要处理数据有多长" class="headerlink" title="指令要处理数据有多长"></a>指令要处理数据有多长</h2><p>用寄存器的ax或al可以很方便的说明数据长度，但是如果是内存之间的传递可以用<br>x ptr 的方式确定是字型传递还是字节性传递</p><p>例： mov word ptr ds:[0],1</p><p>mov byte ptr ds:[0],1</p><p>另外，push操作无需指明，因为push只对字进行操作</p><h2 id="结构体的汇编表达"><a href="#结构体的汇编表达" class="headerlink" title="结构体的汇编表达"></a>结构体的汇编表达</h2><p>一般来说，我们可以用[bx+idata+si]的方式来表达结构体中的数据，用bx定位整个结构体，用idata定义某一个数据项，用si确定数据项中的一个元素</p><p>可以简写为 [bx].idata,[bx].idata[si]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;立即数&quot;&gt;&lt;a href=&quot;#立即数&quot; class=&quot;headerlink&quot; title=&quot;立即数&quot;&gt;&lt;/a&gt;立即数&lt;/h3&gt;&lt;p&gt;其实就是idata，这种数据执行前在cpu的指令缓冲器中，在汇编指令中直接给出&lt;/p&gt;
&lt;h3 id=&quot;寄存器&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编中的多层循环</title>
    <link href="http://xinhecuican.github.io/2020/01/24/%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/"/>
    <id>http://xinhecuican.github.io/2020/01/24/%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-01-24T01:19:00.000Z</published>
    <updated>2020-01-24T01:30:55.173Z</updated>
    
    <content type="html"><![CDATA[<p>因为唯一的用于统计循环次数的寄存器就是cx，所以有多层循环的时候就会碰到循环次数难以记录的问题，以下是一种解决办法</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span>//用另一个寄存器来存<span class="built_in">cx</span>的次数</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol"> s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>+<span class="built_in">bx</span>]</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">si</span>+<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">   <span class="keyword">loop</span> s</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>//这里把<span class="built_in">cx</span>次数取出来减一次</span><br><span class="line">   <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure><p> 但是寄存器的数量是有限的，如果多次循环可能会导致寄存器不够用，因此可以先在数据段定义一个字型数据，然后直接把循环次数放到里面<br> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> </span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol">  s0:</span> <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">cx</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2</span></span><br><span class="line"><span class="symbol">  s:</span>  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">loop</span> s</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">     <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure><br> 此外，还可以定义一个栈，直接用push，pop命令把cx值取出存入</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为唯一的用于统计循环次数的寄存器就是cx，所以有多层循环的时候就会碰到循环次数难以记录的问题，以下是一种解决办法&lt;/p&gt;
&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>si和di</title>
    <link href="http://xinhecuican.github.io/2020/01/24/si%E5%92%8Cdi/"/>
    <id>http://xinhecuican.github.io/2020/01/24/si%E5%92%8Cdi/</id>
    <published>2020-01-24T00:32:00.000Z</published>
    <updated>2020-01-24T02:07:08.985Z</updated>
    
    <content type="html"><![CDATA[<p>si和di在8086cpu中的功能与bx类似，si与di不能分为两个8位寄存器来使用</p><p>也就是说  ds：[si]是可以的</p><p>如果不用这些寄存器直接写的话就会出现之前所说的编译器和exe对程序的不同处理</p><p>例   mov ax,[si]在exe中就是 ds：[si]，但是如果是 mov，ax,[1]在exe中就是把ax中的数据放入1中</p><p>甚至可以直接用[bx+si]的方式或[bx+si+idata]的方式来指明内存地址</p><h3 id="不同寻址方式的比较"><a href="#不同寻址方式的比较" class="headerlink" title="不同寻址方式的比较"></a>不同寻址方式的比较</h3><p>[idata]用于一个常量的寻址，直接定位一个内存单元</p><p>[bx]用于一个变量来表示内存地址，间接定位内存单元</p><p>只有bx,bp,di,si具有寻址能力，例如ds:[dx]等都是错误的</p><p>并且这几个寄存器间组合还有要求，只有bx+si,bx+di,bp+si,bp+di这四种情况是正确的</p><p>只要使用bp，它的段寄存器默认为ss</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;si和di在8086cpu中的功能与bx类似，si与di不能分为两个8位寄存器来使用&lt;/p&gt;
&lt;p&gt;也就是说  ds：[si]是可以的&lt;/p&gt;
&lt;p&gt;如果不用这些寄存器直接写的话就会出现之前所说的编译器和exe对程序的不同处理&lt;/p&gt;
&lt;p&gt;例   mov ax,[si]在
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>字符形式 的数据</title>
    <link href="http://xinhecuican.github.io/2020/01/23/%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F-%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://xinhecuican.github.io/2020/01/23/%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F-%E7%9A%84%E6%95%B0%E6%8D%AE/</id>
    <published>2020-01-23T03:44:00.000Z</published>
    <updated>2020-01-24T00:25:28.844Z</updated>
    
    <content type="html"><![CDATA[<p>首先要知道asc11码</p><p>形式： db ‘…’</p><p>无论多少个单词都只需要单引号</p><p>例 db‘unix’</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先要知道asc11码&lt;/p&gt;
&lt;p&gt;形式： db ‘…’&lt;/p&gt;
&lt;p&gt;无论多少个单词都只需要单引号&lt;/p&gt;
&lt;p&gt;例 db‘unix’&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>将不同代码放入不同段中</title>
    <link href="http://xinhecuican.github.io/2020/01/23/%E5%B0%86%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E6%AE%B5%E4%B8%AD/"/>
    <id>http://xinhecuican.github.io/2020/01/23/%E5%B0%86%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E6%AE%B5%E4%B8%AD/</id>
    <published>2020-01-23T01:42:00.000Z</published>
    <updated>2020-01-23T01:59:49.183Z</updated>
    
    <content type="html"><![CDATA[<p>举个栗子</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code <span class="built_in">ds</span>:data <span class="built_in">ss</span>:stack</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0345h</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">20h</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span> //<span class="built_in">ds</span>:<span class="built_in">bx</span>指向data中第一个内存单元</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s0:</span><span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s0</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"> code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>看了这个就差不多了，前面定义的时候要注意不同段对应不同的寄存器，而后面要注意各个段有独自的segment与ends，而且从start开始要把各个段寄存器赋值，以备后面使用（mov ax，data）<strong>注意</strong> mov ds，data是错误的，8086cpu不允许直接把一个数值送入段寄存器中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;举个栗子&lt;/p&gt;
&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>在代码段中使用栈</title>
    <link href="http://xinhecuican.github.io/2020/01/23/%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88/"/>
    <id>http://xinhecuican.github.io/2020/01/23/%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88/</id>
    <published>2020-01-23T01:03:00.000Z</published>
    <updated>2020-01-23T01:33:37.472Z</updated>
    
    <content type="html"><![CDATA[<p>实际上栈是我们人为定义的一段内存空间，所以先要用dw来申请</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>  //申请<span class="number">6</span>个字的内存空间，栈是由高内存地址到低内存地址，所以栈顶为<span class="built_in">cs</span>：<span class="number">Ch</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">Ch</span></span><br></pre></td></tr></table></figure><p>ss，sp就是前面所说的栈的指针</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实际上栈是我们人为定义的一段内存空间，所以先要用dw来申请&lt;/p&gt;
&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>dw</title>
    <link href="http://xinhecuican.github.io/2020/01/23/dw/"/>
    <id>http://xinhecuican.github.io/2020/01/23/dw/</id>
    <published>2020-01-23T00:48:00.000Z</published>
    <updated>2020-01-23T01:19:10.873Z</updated>
    
    <content type="html"><![CDATA[<p>dw即define word，定义字型数据。例如，dw 0123h,0456h,0789h.这样就定义了几个字型数据，那这些数据都在哪里呢，他们的段地址都是从cs开始的，而偏移地址从0开始，也就是说，0123h的偏移地址是0,0456h的偏移地址是2,0789h的偏移地址是6。</p><p>但是这样会带来一个问题，因为前十六个字节是dw所定义的字型数据，所以这样可能使程序的入口出现问题，所以可以</p><pre><code>assume cs:codesgcodesg segmentdw 0123h,0456h,0789hstart: mov bx,0mov ax,0mov cx,8s: add ax,cs:[bx]add bx,2loop smov ax,4c00hint 21hcodesg endsend start</code></pre><p>这里就是加上了一个标号start，这个标号的意思就是确定程序的入口，而最后在end这里还要来一个start，因为end的作用除了确定程序在哪里终止之外，还有一个作用是告诉编译器程序在哪里开始（因为这时一个伪指令）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dw即define word，定义字型数据。例如，dw 0123h,0456h,0789h.这样就定义了几个字型数据，那这些数据都在哪里呢，他们的段地址都是从cs开始的，而偏移地址从0开始，也就是说，0123h的偏移地址是0,0456h的偏移地址是2,0789h的偏移地址是
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
</feed>
