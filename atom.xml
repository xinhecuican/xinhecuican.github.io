<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinhecuican&#39;s Blog</title>
  
  <subtitle>浏览器网页搜索挺好用的，站内搜索说不定有惊喜哟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-06-01T03:25:40.795Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>星河璀璨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java 常用类</title>
    <link href="http://xinhecuican.github.io/post/85b4e13b.html"/>
    <id>http://xinhecuican.github.io/post/85b4e13b.html</id>
    <published>2020-05-29T11:14:00.000Z</published>
    <updated>2020-06-01T03:25:40.795Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 01 2020 11:25:46 GMT+0800 (中国标准时间) --><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Object是所有java类共同的祖先。如果没有用extends，那么这个类将直接继承Object类。</p><p>Object类有一个默认构造方法，构造子类实例时，都会优先使用这个构造方法。</p><p><code>public Object(){}</code></p><p>方法：</p><ul><li>equals(Object obj): 比较两个对象是否相等，只有当两个变量引用一个实例时才会为真。</li><li>notify()</li><li>notifyAll()</li><li>wait()</li><li>hashCode(): 返回对象哈希码。</li><li>toString(): 返回当前对象字符串表示。如果println方法参数时Object，那么先会调用toString()</li><li>finalize(): 垃圾回收时先调用这个方法</li></ul><h1 id="String-和-StringBuffer"><a href="#String-和-StringBuffer" class="headerlink" title="String 和 StringBuffer"></a>String 和 StringBuffer</h1><p>String是不可变类，里面字符串永远不会改变(也就是平常用双引号括起来的那些),StringBuffer是可变类</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>构造方法：</p><ul><li>String()</li><li>String(String value):</li><li>String(char[] value): 会把字符数组转换成字符串</li><li>String(byte[] bytes): 会用本地默认编码把字节数组变成字符串</li><li>String(byte[] bytes, String charsetName): 根据charsetName指定的编码，构造字符串。</li></ul><p>方法：</p><ul><li>length()</li><li>char charAt(int index): 返回index上的字符</li><li>getChars(int srcBegin, int srcEnd, char[] dst, int dstbegin): 从当前字符串复制字符到dst中，srcBegin开始取字符，到srcEnd-1结束</li><li>equals(object str): 判断两个字符串是否相等</li><li>equalsIgnoreCase()： 忽略大小写</li><li>int compareTo(String str): 比较字符串大小</li><li>indexOf()和lastIndexOf(): 在字符串中检索特定字符或字符串，indexOf()从开始位置查找，另一个从后面开始查找<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str.index<span class="constructor">Of('<span class="params">e</span>')</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str.index<span class="constructor">Of(<span class="string">"ea"</span>, 2)</span>); <span class="comment">//从2开始</span></span><br></pre></td></tr></table></figure></div></li><li>concat(String str): 把str加载末尾</li><li>substring(): 返回子串，参数中可以有开始和结束位置</li><li>String[] split(String regex): 根据参数把字符串分成几个子串，例如根据空格分隔</li><li>replaceAll(String regex, String replacement): 把原来字符串中regrex换成replacement。replaceFirst()只替换第一个</li><li>trim(): 把字符串首尾空格删除</li><li>String valueOf(): 把基本类型转换成String类型。</li><li>toUpperCast()/toLowerCast(): 把字符串变成大小写</li></ul><h3 id="“hello”-和-new-String-“hello”-区别"><a href="#“hello”-和-new-String-“hello”-区别" class="headerlink" title="“hello” 和 new String(“hello”)区别"></a>“hello” 和 new String(“hello”)区别</h3><p>第一种： String s1 = “hello”</p><p>第二种： String s2 = new String(“hello”)</p><p>第一种方式hello是立即数，Java虚拟机只会分配一次内存（在data节中）。第二种方式是建立一个对象，每次新建一个对象都会重新分配一次内存。所以用第一种方式赋相同值给两个变量用equal()比较时true，而而第二种不是。</p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>构造方法：</p><ul><li>StringBuffer()</li><li>StringBuffer(int length)</li><li>StringBuffer(String str)：缓冲区初始字符串是str，并且提供16字节的额外缓冲区</li></ul><p>方法：</p><ul><li>length()</li><li>append(): 向缓冲区内添加字符串</li><li>toString(): 返回缓冲区内字符串</li><li>charAt(int index)</li><li>setCharAt(int index, char c): 在index处放c</li><li>getChars(int Begin, int end, char[] dst, int dstBegin):</li><li>subString()</li><li>insert(int offset, String str): 在offset位置插入字符串（字符串首位置在offset处）</li></ul><h2 id="String和StringBuffer区别"><a href="#String和StringBuffer区别" class="headerlink" title="String和StringBuffer区别"></a>String和StringBuffer区别</h2><p>String是不可变类。即使看上去提供了replaceAll()的修改方法实际上它是创建了一个新的字符串。而StringBuffer是在自身基础上进行修改。</p><p>String覆盖了equals()方法。</p><p>String对象可以用+号进行拼接，而StringBuffer不可以</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>就是用一些特殊字符来代替多个字符进行匹配</p><table><thead><tr><th>特殊字符</th><th>作用</th></tr></thead><tbody><tr><td>.</td><td>任意字符</td></tr><tr><td>[…]</td><td>匹配中括号中所有数据，例如[abc]可以匹配a或b或c</td></tr><tr><td>[^…]</td><td>匹配除括号数据外的任意数据</td></tr><tr><td>\s</td><td>空白符（空格，tab，换行，换页，回车）</td></tr><tr><td>\S</td><td>非空白符</td></tr><tr><td>\d</td><td>任意数字</td></tr><tr><td>\D</td><td>任意非数字</td></tr><tr><td>\w</td><td>大小写字母和数字</td></tr><tr><td>\W</td><td>除了大小写和数字外的字符</td></tr></tbody></table><p><a href="https://xinhecuican.github.io/post/26477.html">更多可以看这里</a></p><h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><p>String类的静态方法format()用于创建格式化字符串</p><ul><li>String format(String format, Object… args)</li><li>String format(Locale locale, String format, Object… args): locale指定语言</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(String.format(Locale.CHINESE, "%tc", <span class="type">date</span>));</span><br></pre></td></tr></table></figure></div><h2 id="日期，时间格式化"><a href="#日期，时间格式化" class="headerlink" title="日期，时间格式化"></a>日期，时间格式化</h2><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>%tb</td><td>月份简称，8月</td></tr><tr><td>%dB</td><td>全称</td></tr><tr><td>%ta</td><td>星期几</td></tr><tr><td>%tA</td><td>星期几全称</td></tr><tr><td>%ty</td><td>2位年份，如20</td></tr><tr><td>%tY</td><td>4位年份，如2020</td></tr><tr><td>%tm</td><td>月份，08</td></tr><tr><td>%te</td><td>一月中第几天</td></tr><tr><td>%tj</td><td>一年中第几天</td></tr><tr><td>%tc</td><td>具体时间和日期</td></tr><tr><td>%tF</td><td>年-月-日，四位年</td></tr><tr><td>%tD</td><td>年/月/日，两位年</td></tr><tr><td><strong>时间</strong></td><td></td></tr><tr><td>%tH</td><td>24时制（00-23）</td></tr><tr><td>%tI</td><td>十二小时（01-12）</td></tr><tr><td>%tk</td><td>24时（0-23）</td></tr><tr><td>%tl</td><td>12时（0-12）</td></tr><tr><td>%tM</td><td>分钟</td></tr><tr><td>%tS</td><td>秒</td></tr><tr><td>%tL</td><td>毫秒</td></tr><tr><td>%tN</td><td>微秒</td></tr><tr><td>%tp</td><td>上午下午标记</td></tr><tr><td>%tz</td><td>时区偏移量</td></tr><tr><td>%tZ</td><td>时区缩写</td></tr></tbody></table><h2 id="常规类型"><a href="#常规类型" class="headerlink" title="常规类型"></a>常规类型</h2><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>%b</td><td>布尔类型</td></tr><tr><td>%B</td><td>大写</td></tr><tr><td>%h,%H</td><td>哈希码</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%S</td><td>大写字符串</td></tr><tr><td>%c</td><td>字符</td></tr><tr><td>%C</td><td>大写</td></tr><tr><td>%d</td><td>十进制整数</td></tr><tr><td>%o</td><td>八进制</td></tr><tr><td>%x</td><td>十六进制</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%e</td><td>科学记数法表示的十进制</td></tr><tr><td>%n</td><td>换行</td></tr></tbody></table><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Stirng</span>.</span></span>format(<span class="string">"hi%s"</span>, <span class="string">"小红"</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"%c%n"</span>, <span class="character">'A'</span>);</span><br></pre></td></tr></table></figure></div><p>使用大致和c语言类似。</p><table><thead><tr><th>转换符号</th><th>含义</th></tr></thead><tbody><tr><td>转换符号</td><td>它是在%后面字符前面的,例如”%+d”</td></tr><tr><td>+</td><td>为数字添加正负号</td></tr><tr><td>-</td><td>左对齐</td></tr><tr><td>0</td><td>数字前补零，例如 “%04d” 表示如果数字不满四位前面要补零</td></tr><tr><td>(</td><td>添加括号，例如(“%(d”, 99) ,输出 (99)</td></tr><tr><td>#</td><td>如果是十六或十进制前面添加0x或0,如果是浮点数添加小数点</td></tr></tbody></table><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>每个基本类型都有一个包装类。包装类就是对应基本类型然后首字母大写（int,char除外）。例如int Integer float Float.char是Character</p><p>构造方法：</p><p>都可以用字符串作为参数来构造。Boolean类型可以用”true”或”false”。</p><p>除了Character和Boolean外其他类都是继承于Number类。</p><p>Number类方法如下：</p><ul><li><p>byteValue(): 返回Number对象的byte类型</p></li><li><p>intValue():</p></li><li><p>longValue()</p></li><li><p>shortValue()</p></li><li><p>doubleValue()</p></li><li><p>floatValue()</p></li><li><p>包装类都覆盖了toString()方法</p></li><li><p>都有parsexxx(String str)静态方法，可以把字符串转化成相应数据。例如parseint(“123”)</p></li></ul><h3 id="包装类自动装箱和拆箱"><a href="#包装类自动装箱和拆箱" class="headerlink" title="包装类自动装箱和拆箱"></a>包装类自动装箱和拆箱</h3><p>就是在基本类型和包装类之间进行转换。可以直接用基本类型赋值给包装类，也可以直接用包装类赋值给基本类型。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EBNF"><figure class="iseeu highlight /ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Integer a</span> = 3;</span><br><span class="line"><span class="attribute">int b</span> = new Integer(4);</span><br></pre></td></tr></table></figure></div><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>Math类里面基本上都是静态方法，并且他的构造方法时private，不能有实例。而且是final类型，不能有子类。</p><p>方法：</p><ul><li>abs()</li><li>ceil(): 向上取整</li><li>floor(): 向下取整</li><li>max()</li><li>min()</li><li>random(): 返回0到1间double类型的随机数。包括0，不包括1</li><li>round(): 四舍五入整数</li><li>sin()</li><li>cos()</li><li>tan()</li><li>exp(): 根号x</li><li>sqrt(): x的平方</li><li>pow(): 幂运算</li></ul><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>和Math类似</p><p>方法：</p><ul><li>nextInt(): 返回一个int型随机数，随机数大于等于0</li><li>nextInt(int n): n是随机数最大值</li><li>nextLong()</li><li>nextFloat()</li><li>nextDouble()</li><li>nextBoolean()</li></ul><h2 id="处理时间类"><a href="#处理时间类" class="headerlink" title="处理时间类"></a>处理时间类</h2><p><strong>Date</strong></p><p>Date类以毫秒方法日期。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.prtinln(<span class="type">date</span>);</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Sun Aug21 <span class="number">17</span>:<span class="number">32</span>:<span class="number">05</span> CST <span class="number">2016</span></span><br></pre></td></tr></table></figure></div><p><strong>DateFormat</strong></p><p>它可以定制日期格式</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LASSO"><figure class="iseeu highlight /lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>();</span><br><span class="line">SimpleDateFormat f = <span class="literal">new</span> SimpleDateFormat(<span class="string">"yyyy-MMMM-dd-EEEE"</span>);</span><br><span class="line">这些都是表示显示几位的年月日的.E是星期</span><br></pre></td></tr></table></figure></div><h2 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger BigDecimal"></a>BigInteger BigDecimal</h2><p>BigInteger可以接受任意位的整数运算。他有add(BigInteger b),subtract(BigInteger b) multiply(BigInteger b) divide(BigInteger b)等方法来进行四则运算</p><p>BigDecimal可以进行精确的浮点数运算。对于加减乘都是准确的，对于除法可以指定小数位和舍入模式。</p><p>divide(BigDeciaml b, int scale, RoundingMode more)more是舍入模式。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 01 2020 11:25:46 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://xinhecuican.github.io/post/a444b428.html"/>
    <id>http://xinhecuican.github.io/post/a444b428.html</id>
    <published>2020-05-25T05:32:00.000Z</published>
    <updated>2020-05-27T11:56:12.964Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 27 2020 19:56:46 GMT+0800 (中国标准时间) --><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>稳定？不稳定： 稳定指的是两个相同的元素排序完成之后在表中相对位置不变。</p><h2 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h2><p>当插入第i个时，前i-1个已经排好了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        tag = a[i];</span><br><span class="line">        <span class="built_in">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i<span class="number">-1</span>; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k]&gt;tag)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">                temp = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[k+<span class="number">1</span>] = tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>默认第一个已经排好，从第二个开始从后往前排，如果第k个数比要比较的数大就把这个数往后排。</p><p>复杂度： n^2</p><h2 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h2><p>折半排序基于前面的直接插入，不同的是它通过二分找插入位置。然后再移动</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    tag = a[i];</span><br><span class="line">    <span class="built_in">int</span> low=<span class="number">0</span>, high=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;tag)</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//high+1是插入位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=i<span class="number">-1</span>; k&gt;=high+<span class="number">1</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    a[high+<span class="number">1</span>] = tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度 n^2</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>思想： 把序列按gap划分成若干个子序列。例如有6个元素，gap是3，那么第0个和第3个是一个序列，第1个和第4个是一个序列。之后在每个子序列中直接插入。然后折半缩小gap。</p><p>第一个gap一般取n/2。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> gap = n/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(gap != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=gap; i&lt;n; i++)<span class="comment">//从gap开始是因为直接插入排序中默认第一个已经排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        tag = a[i];</span><br><span class="line">        <span class="built_in">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i-gap; k&gt;=<span class="number">0</span>; k-=gap)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k]&gt;tag)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k+tag] = a[k];</span><br><span class="line">                temp = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[temp+tag] = tag;</span><br><span class="line">    &#125;</span><br><span class="line">    gap /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度：n(longn)^2。但这是一种不稳定的排序</p><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><p>起泡排序是过程是逐个比较，比较出最小的放到第一个，然后放到第二个。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> flag=<span class="number">0</span>,exchange=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag&lt;n<span class="number">-1</span> &amp;&amp; exchange==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    exchange = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n<span class="number">-1</span>; i&gt;flag; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a[i<span class="number">-1</span>] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            a[i] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            a[i<span class="number">-1</span>] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            exchange = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这一步后小的在前面，然后下一次又是把i-1和i-2比，如果i-1小，又跑到前面</span></span><br><span class="line">        <span class="comment">//这样第i-1个一直是最小的（相对于它后面的元素）</span></span><br><span class="line">    &#125;</span><br><span class="line">    flag++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度 n^2</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><a href="https://xinhecuican.github.io/post/11306.html">以前的一篇</a></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><p>这个就不多说了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> min = <span class="number">2147483647</span>;</span><br><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=i+<span class="number">1</span>; k&lt;n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[k]&lt;min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = a[k];</span><br><span class="line">            tag = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap（a[i], a[tag]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是完全二叉树产生的数组。然后建立一个父节点比子节点大/小的数组。父节点比子节点大的叫大顶堆，父节点比子节点小的叫小顶堆。</p><p>假设父节点是i，那么两个子节点分别是i<em>2和i</em>2+1。下标要从1开始</p><p>过程，以小顶堆为例</p><ul><li>初始化，首先构造一个大顶堆，过程是用这个节点和它的父节点进行比较，如果小就交换位置，然后再和新位置的父节点进行比较。先拿第一个数和第二个数进行比较，如果第一个数比第二个数小那个交换位置。然后第三个数和第一个数比较。此外，还可以从小到大直接建</li></ul><p>之后第4个数是插入到第二个数上的，就拿第四个数和第二个数比较，如果第四个数比第二个数小就把第二个数往上提，之后再和第一个数进行比较。然后依此类推。</p><p><img src="/images/%E6%8E%92%E5%BA%8F.png" alt></p><ul><li>把第一个元素和最后一个元素进行交换，然后对前n-1个元素进行处理。开始我们建立的是大顶堆，现在我们把最大的放到后面就变成小顶堆了。并且这时不仅满足小顶堆，还满足左儿子一定比右儿子小。</li></ul><p><img src="/images/%E6%8E%92%E5%BA%8F2.png" alt></p><ul><li>之后就是用根节点左右儿子中比较大的节点和根节点进行比较。然后如果比根节点大就进行换位。然后再在新位置和新的子节点进行比较。完成之后又把根节点放到最后。之后就重复第二步和第三步。（不画图了，难死我了）</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据上面自己写的，拿过几个数据代过，如果想看更标准的可以看下面模板(饶命)</span></span><br><span class="line"><span class="built_in">void</span> Heap(<span class="built_in">int</span> *a, <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> now = i;</span><br><span class="line">        <span class="keyword">while</span>((now&lt;&lt;<span class="number">1</span>) &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> largest ;</span><br><span class="line">            <span class="built_in">int</span> l = now &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> r = (now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span> == n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[l] &gt; a[now])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">int</span> temp = a[l];</span><br><span class="line">                    a[l] = a[now];</span><br><span class="line">                    a[now] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[l] &gt; a[r])</span><br><span class="line">            &#123;</span><br><span class="line">                largest = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                largest = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[largest] &gt; a[now])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = a[largest];</span><br><span class="line">                a[largest] = a[now];</span><br><span class="line">                a[now] = temp;</span><br><span class="line">                now = largest;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//初始化</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">1</span>] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        a[i] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((now&lt;&lt;<span class="number">1</span>) &lt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> big;</span><br><span class="line">            <span class="keyword">if</span>((now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span> == i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = now&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[now] &lt; a[temp])</span><br><span class="line">                &#123;</span><br><span class="line">                    a[now] = a[temp] ^ a[now];</span><br><span class="line">                    a[temp] = a[temp] ^ a[now];</span><br><span class="line">                    a[now] = a[temp] ^ a[now];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//只有左节点</span></span><br><span class="line">            <span class="keyword">if</span>(a[now&lt;&lt;<span class="number">1</span>] &lt; a[(now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                big = (now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                big = now&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[big] &gt; a[now])</span><br><span class="line">            &#123;</span><br><span class="line">                a[big] = a[big] ^ a[now];</span><br><span class="line">                a[now] = a[big] ^ a[now];</span><br><span class="line">                a[big] = a[big] ^ a[now];</span><br><span class="line">                now = big;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>模板</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆长度</span></span><br><span class="line"><span class="built_in">int</span> heapsize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//大顶堆化</span></span><br><span class="line"><span class="built_in">void</span> MAX_HEAPIFY(<span class="built_in">int</span> A[], <span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> l = <span class="number">2</span> * i;<span class="comment">//把 i 的左儿子 下标 赋给l</span></span><br><span class="line"><span class="built_in">int</span> r = <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//把 i 的左儿子 下标 赋给r</span></span><br><span class="line"><span class="built_in">int</span> largest;<span class="comment">//3个里面最大的下标</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (l &lt;= heapsize &amp;&amp; A[l]&gt;A[i])</span><br><span class="line">largest = l;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">largest = i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (r &lt;= heapsize &amp;&amp; A[r]&gt;A[largest])</span><br><span class="line">largest = r;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (largest != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换 A[largest] 和 A[i]</span></span><br><span class="line"><span class="built_in">int</span> tmp = A[largest];</span><br><span class="line">A[largest] = A[i];</span><br><span class="line">A[i] = tmp;</span><br><span class="line"> </span><br><span class="line">MAX_HEAPIFY(A, largest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="built_in">void</span> BUILD_MAX_HEAP(<span class="built_in">int</span> A[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = (<span class="built_in">int</span>)(heapsize / <span class="number">2</span>); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">MAX_HEAPIFY(A, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">printf(<span class="string">"%d "</span>, A[j]);</span><br><span class="line">printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="built_in">void</span> HEAPSORT(<span class="built_in">int</span> A[])</span><br><span class="line">&#123;</span><br><span class="line">BUILD_MAX_HEAP(A);<span class="comment">//ok</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="built_in">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (i = heapsize; i &gt;= <span class="number">2</span>; i--)<span class="comment">//A[1] 必定是最大的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换 A[1] 和 A[i]</span></span><br><span class="line">tmp = A[<span class="number">1</span>];</span><br><span class="line">A[<span class="number">1</span>] = A[i];</span><br><span class="line">A[i] = tmp;</span><br><span class="line"> </span><br><span class="line">heapsize--;</span><br><span class="line">MAX_HEAPIFY(A, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> A[<span class="number">11</span>] = &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//ok</span></span><br><span class="line"><span class="built_in">int</span> n = sizeof(A) / sizeof(<span class="built_in">int</span>) - <span class="number">1</span>;</span><br><span class="line">heapsize = n;</span><br><span class="line"> </span><br><span class="line">HEAPSORT(A);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">printf(<span class="string">"%d "</span>, A[i]);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度： nlogn.但是不稳定</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><a href="https://xinhecuican.github.io/post/63711.html">以前博客</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 27 2020 19:56:46 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>java I/O</title>
    <link href="http://xinhecuican.github.io/post/5be7e977.html"/>
    <id>http://xinhecuican.github.io/post/5be7e977.html</id>
    <published>2020-05-24T10:21:00.000Z</published>
    <updated>2020-05-29T11:13:10.914Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 19:13:11 GMT+0800 (中国标准时间) --><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java.io.InputStream代表字节输入流，java.io.OutputStream代表输出流。他们都是抽象类，InputStream中有以下方法：</p><ul><li>int read():读入一个字节，并且转化成unsigned int型整数</li><li>int read(byte[] b): 从输入流中读取若干字节，保存在b数组中。如果到了输入流的结尾，返回1</li><li>int read(byte[] b, int off, int len): 如上，这里只是多了在b数组中的开始位置和读取数目</li><li>void close()： 关闭输入流。如果不关闭的话其他需要这个文件的就无法读取这个文件信息。类似于打开了一个应用程序再打开就说有一个实例正在运行。</li><li>int available(): 放回从输入流中读取字节数目</li><li>skip(long n): 从输入流中跳过n个字节</li><li>boolean markSupported(),void mark(int readLimit), void reset(): 如果想要重复读入数据，就先用markSupported()判断这个流是否支持重复读入数据，如果支持，通过mark在当前位置开始设置readLimit字节的标记，然后用reset()可以使输入流定位到做标记的起始位置，然后通过read()就可以重复读数据了。</li></ul><p>OutputStream中方法：</p><ul><li>void write(): 输出一个字节</li><li>void write(byte[] b): 同上</li><li>void write(byte[] b, int off, int len): 同上</li><li>void close()</li><li>void flush(): OutputStream本身的flush()不执行操作。但是如果是一些有缓冲区机制的实现类就有用了。在有缓冲区的输出流中，一般都是先把输出存在缓冲区中，等到了一定大小才会输出，<strong>这个方法的作用是强制输出缓冲区中数据</strong>。</li></ul><p>设置缓冲区的原因是输出并不是直接输出到屏幕中间要经历一系列的过程，耗时比较长，如果先存到缓冲区然后一次性输出就可以减少时间。</p><h1 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h1><h2 id="ByteArrayInputStream-字节数组输入流"><a href="#ByteArrayInputStream-字节数组输入流" class="headerlink" title="ByteArrayInputStream,字节数组输入流"></a>ByteArrayInputStream,字节数组输入流</h2><p>这个类从字节数组读取数据，可能会想直接用字符数组不就行了吗，为什么还要弄一个输入流类。ByteArrayInputStream实际上是一个<a href="https://xinhecuican.github.io/post/5951da65.html">适配器</a></p><p>构造方法：</p><p>ByteArrayInputStream(byte[] buf)</p><p>ByteArrayInputStream(byte[] buf, int offset, int length)</p><p>使用就是用上面的方法</p><h2 id="FileInputStream文件输入流"><a href="#FileInputStream文件输入流" class="headerlink" title="FileInputStream文件输入流"></a>FileInputStream文件输入流</h2><p>构造方法：</p><p>FileInputStream(File file)</p><p>FileInputStream(String name):通过name指定路径</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamTester</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span>((data=in.<span class="built_in">read</span>()) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(data+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果文件很大，为了提高读取效率，可以利用一个缓冲区。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        final <span class="keyword">int</span> SIZE = <span class="number">1024</span>;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FIleOutputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">        <span class="keyword">int</span> len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        <span class="keyword">while</span>(len != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out.<span class="built_in">write</span>(buff, <span class="number">0</span>, len);</span><br><span class="line">            len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">        out.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果要打开的文件和这个类在同一文件夹下，可以用Class类的个体ResourceAsStream()方法,<strong>这时可以用相对路径</strong>。例如：</p><p><code>InputStream in = UseBuffer.getClass().getResourceAsStream(&quot;test.txt&quot;);</code></p><h2 id="PipedInputStream管道输入流"><a href="#PipedInputStream管道输入流" class="headerlink" title="PipedInputStream管道输入流"></a>PipedInputStream管道输入流</h2><p>管道输入流是从管道输出流中读取数据的。一般是一个线程从管道中输出，然后另外一个接受。使用管道的优点是如果管道中没有数据就会阻塞，有数据才会恢复运行，这样就可以对产生的数据进行处理。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Sender extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PipedOnputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getPipedOutputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-127</span>; i&lt;=<span class="number">128</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                out.<span class="built_in">write</span>(i);</span><br><span class="line">                <span class="built_in">yield</span>();<span class="comment">//让步给sender处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            out.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="title">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">private</span> PipedInputStream in;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span><span class="params">(Sender sender)</span><span class="keyword">throw</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//通过这个构造方法确定了两者的关系</span></span><br><span class="line">            in = <span class="keyword">new</span> PipedInputStream(sender.getPepedOutputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data;</span><br><span class="line">            <span class="keyword">while</span>((data=in.<span class="built_in">read</span>()) != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(data):</span><br><span class="line">            &#125;</span><br><span class="line">            in.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h2 id="SequenceInputStream-顺序输入流"><a href="#SequenceInputStream-顺序输入流" class="headerlink" title="SequenceInputStream 顺序输入流"></a>SequenceInputStream 顺序输入流</h2><p>它可以把几个输入流混合到一起输入。</p><p>构造方法：</p><p>SequenceInputStream(Enumeration e): e是枚举类型，包含若干个输入流</p><p>SequenceInputStream(InputStream s1, InputStream s2):只合并两个</p><p>它关闭的时候只需要关闭SequenceInputStream就会一次关闭所有的输入流。</p><h2 id="装饰器设计模式"><a href="#装饰器设计模式" class="headerlink" title="装饰器设计模式"></a>装饰器设计模式</h2><p>假设有一个类要子类实现三种方法，并且有的子类只需要实现一个，有的要实现多个，那么就要2^3-1个子类，数量过多。我们可以采用装饰器思想减少子类数目。</p><p>装饰器也是一个子类。这个子类的特殊之处在于他实现了某一个方法并且它内部封装了父类的实例。它的构造方法是：<code>decorate(Base base)</code></p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">B </span><span class="keyword">extends </span>A</span><br><span class="line"></span><br><span class="line"><span class="keyword">B </span><span class="keyword">b </span>= new <span class="keyword">B();</span></span><br><span class="line"><span class="keyword">decorate1 </span>dec1 = new decorate1(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec1.method1();</span></span><br><span class="line"><span class="keyword">decorate2 </span>dec2 = new decorate2(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec2.method2();</span></span><br></pre></td></tr></table></figure></div><h2 id="FilterInputStream-过滤输入流"><a href="#FilterInputStream-过滤输入流" class="headerlink" title="FilterInputStream 过滤输入流"></a>FilterInputStream 过滤输入流</h2><p>过滤输入流其实就是一个装饰器</p><p><strong>种类</strong></p><table><thead><tr><th>过滤输入流</th><th>描述</th></tr></thead><tbody><tr><td>DataInputStream</td><td>与DataOutputStream搭配使用，按照和平台无关的方式从流中读取基本类型（int，char，long等）</td></tr><tr><td>BufferedInputStream</td><td>利用缓冲区提高效率</td></tr><tr><td>PushbackInputStream</td><td>把督导的一个字节压回缓冲区中，编译器用</td></tr></tbody></table><p>这些都是FileterInputStream的子类,并且也是装饰器。</p><h3 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h3><p>它的不同方法可以按不同编码读取数据，并且都是以read开头：</p><ul><li>readByte()</li><li>readLong()</li><li>readFloat()</li><li>readUTF(): 从输入流中读取若干字节，并转化成UTF-8编码字符串</li></ul><p>UTF-8如果是ascii就只用一个字节，如果是其他字符就用两个或两个以上字节。</p><p>DataInputStream应该和DataOutputStream配套使用。只有配套使用才会保证数据的正确性（因为这里的UTF-8是java本土化的UTF-8,本来的UTF-8好像是稳定3个字节的）。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileOutputStream out1 = <span class="keyword">new</span> <span class="type">FileOutputStream</span>();</span><br><span class="line">        BufferedOutputStream out2 = <span class="keyword">new</span> <span class="type">BufferedOutputStream</span>(out1);</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> <span class="type">DataOutputStream</span>(out2);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><p>BufferedInputStream覆盖了读数据的行为，它利用缓冲区提高读取的效率。</p><p>构造方法：</p><ul><li>BufferedInputStream(InputStream in)</li><li>BufferedInputStream(InputStream in, int size):size指定缓冲区大小</li></ul><p>当数据源是文件时，可以用BufferedInputStream装饰数据流，然后再进行其他操作可以提高效率。</p><h3 id="PushbackInputStream"><a href="#PushbackInputStream" class="headerlink" title="PushbackInputStream"></a>PushbackInputStream</h3><p>它有一个后推缓冲区，用于存放已经读入的字节。</p><h1 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h1><p>输出流种类和输入流大致类似，sequenceInputStream对应的没有了，多了ObjectOutputStream。</p><p>ByteArrayOutputStream是把信息输出到字节数组中。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ByteArrayOutputStream <span class="keyword">out</span> = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">out</span>.write(<span class="string">"你好"</span>.getBytes(<span class="string">"UTF-8"</span>);<span class="comment">//String的getBytes可以放回制定类型的编码</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">out</span>.toByteArray();<span class="comment">//获得字符数组的方法</span></span><br><span class="line">        <span class="keyword">out</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>先用write把要输入的数据输入到输出流中，然后通过toByteArray方法输出到字节数组中。</p><p><strong>文件输出流</strong></p><p>前面大致类似，多了一种构造方法<code>FileOutputStream(String name, boolean append)</code></p><p>其中append是为了确定是不是要在末尾追加数据。</p><h2 id="FilterOutputStream-过滤输出流"><a href="#FilterOutputStream-过滤输出流" class="headerlink" title="FilterOutputStream 过滤输出流"></a>FilterOutputStream 过滤输出流</h2><p>同样有DataOutputStream和BufferedOutputStream，大致和输入流类似，多了一种PrintStream类</p><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><p>PrintStream和DataOutputStream类似，都可以输出格式化数据。他有如下方法。</p><ul><li>print(int i): 输出一个int</li><li>print(float i):</li><li>print(String i):</li><li>println(int i): 输出int型数据和换行符</li><li>println(float f):</li><li>println(String s):</li></ul><p>前面提到过，DataOutputStream和DataInputStream最好匹配使用是因为他们使用了特殊化的UTF-8编码。而PrintStream使用的是普通的UTF-8编码。</p><p>PrintStream的print()没有抛出IOException，但是他有checkError()判断写数据是否成功，如果返回true，则代表出现了错误。</p><p>PrintStream自带缓冲区。但是这和BufferedInputStream提供的缓冲区还有所不同。后者只有缓冲区满的时候才会输出，前者可以由用户决定数据量多少的时候输出。当然，默认还是满的时候输出。PrintStream还提供了一个自动化的输出方案：</p><ul><li>PrintStream(OutputStream out, boolean autoFlash)。当满足以下情况就会自动输出<ul><li>输出一个字节数组</li><li>输出一个换行符，即执行print(“\n”)或println()<h1 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader/Writer"></a>Reader/Writer</h1></li></ul></li></ul><p>InputStream和OutputStream处理的是字节，但是在很多场合要处理的是字符（java中字符时2字节）。Reader和Writer就是处理这些的。</p><p>java中字符时Unicode编码，但是文本文件中不一定是Unidcode编码，还有可能是UTF-8，GBK甚至ascii，因此如何处理不同类型编码就是一个难点。</p><p>String的getBytes(String encode)返回特定类型的编码，encode参数指定编码类型。如果不带参数就使用本地操作系统默认编码。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获得本地编码</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">"file.encoding"</span>)</span>);</span><br><span class="line">或：</span><br><span class="line">Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(cs);</span><br></pre></td></tr></table></figure></div><p>Reader类可以把其他类型的编码转换成java所使用的编码。Writer可以把Unicode转换成其他类型的编码。</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>Reader和InputStream类的种类大致类似.</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>CharArrayReader</td><td>把字符数组转换成Reader，从字符数组中读取字符</td></tr><tr><td>BufferedReader</td><td>装饰器，提供缓冲区。同时他的readLine()方法还可以读入一个字符串</td></tr><tr><td>LineNumberReader</td><td>提供缓冲区。并且可以跟踪字符输入流中中的行号</td></tr><tr><td>StringReader</td><td>把字符串转成Reader（数据源是字符串，和CharArrayReader类似），从字符串中读字符</td></tr><tr><td>PipedReader</td><td>连接PipedWriter</td></tr><tr><td>FilterReader</td><td>扩展其他Reader功能</td></tr><tr><td>InputStreamReader</td><td>把InputStream转换成Reader，可以指定数据源编码</td></tr><tr><td>FileReader</td><td></td></tr></tbody></table><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>构造方法：</p><ul><li>InputStreamReader(InputStream in): 按照本地的字符编码解读输入流中的字符</li><li>InputStreamReader(InputStream in, String charsetName): 按照charsetName指定的方式读取输入流中的字符</li></ul><p>这里的read读出来的不是一个字节而是一个字符</p><p>一些常用的方法：</p><ul><li>readLine(),一次读入一行</li><li>readFile(String fileName, String charsetName):从文件中读取字符串，并输出到控制台中</li><li>copyFile(String from, String charsetFrom, String to, String charsetTo): 把原文件复制到目标文件中，可以指定文件编码</li></ul><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>Writer和OutputStream大致类似，也有PrintWriter,区别是PrintStream只能用系统本地编码，而PrintWriter可以使用任意编码。PrintWriter构造方法：</p><ul><li>PrintWriter(Writer writer, boolean autoFlush)</li><li>PrintWriter(OutputStream out, boolean autoFlush)</li></ul><h1 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h1><p>在System类中，有三个静态变量：</p><ul><li>System.in: 代表标准输入流。默认输入时键盘</li><li>System.out: 是PrintStream类型（所以方法和PrintStream一样）。</li><li>System.err: 代表错误输出流，默认输出时输出到控制台。</li></ul><h2 id="对标准输入输出包装"><a href="#对标准输入输出包装" class="headerlink" title="对标准输入输出包装"></a>对标准输入输出包装</h2><p>可以利用到前面所学的只是对标准输入输出进行包装。System.in是InputStream类型，可以先用InputStreamReader变成Reader，然后在用BufferedReader装饰。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> <span class="constructor">InputStreamReader(System.<span class="params">in</span>)</span>;</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> <span class="constructor">BufferedReader(<span class="params">reader</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>重定向方法：</p><ul><li>setIn(InputStream, in): 对标准输入重定向</li><li>setOut(printStream out):</li><li>setErr(PrintStream out):</li></ul><p>这些方法时System的静态方法，所以写的时候是System.setIn()</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void redirect(InputStream <span class="keyword">in</span>, PrintStream out, PrintStream err)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">In(<span class="params">in</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Out(<span class="params">out</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Err(<span class="params">err</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String<span class="literal">[]</span> args)throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    InputStream stdin = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span><span class="keyword">in</span>;<span class="comment">//重定向之后标准输入就变了，所以最好先保存</span></span><br><span class="line">    PrintStream stdout = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out;</span><br><span class="line">    PrintStream stderr = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>err;</span><br><span class="line">    InputStream <span class="keyword">in</span> = <span class="keyword">new</span> <span class="constructor">BufferedInputStream(<span class="string">"D:\\temp.txt"</span>)</span>;</span><br><span class="line">    PrintStream out = <span class="keyword">new</span> <span class="constructor">BufferedOutputStream(<span class="string">"D:\\tempout.txt"</span>)</span>;</span><br><span class="line">    redirect(<span class="keyword">in</span>, out, stderr);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="RandomAccessFile-随机访问文件"><a href="#RandomAccessFile-随机访问文件" class="headerlink" title="RandomAccessFile 随机访问文件"></a>RandomAccessFile 随机访问文件</h1><p>随机访问文件就是可以从文件任意位置读写数据，他有如下定位方法：</p><ul><li>getFilePointer(): 返回当前位置</li><li>seeek(long pos): 设置位置，与未见开头相距pos</li><li>skipBytes(int n): 从当前开始跳过n个字节</li><li>length(): 返回文件包含的字节数</li></ul><p>RandomAccessFile实现了DataInput和DataOutput接口，可以读取格式化数据；</p><ul><li>RandomAccessFile(File file, String mode)</li><li>RandomAccessFile(String name, String mode):name指定路径</li></ul><p>其中mode是访问模式，可以有”r”和”rw”。表示只读和读写，但是”w”是非法的。</p><h1 id="新-I-O库"><a href="#新-I-O库" class="headerlink" title="新 I/O库"></a>新 I/O库</h1><p>这些类位于java.nio包中，nio是newio。他映入了四个数据类型</p><ul><li>Buffer： 缓冲区</li><li>Charset： 把Unicode和其他类型相互转换</li><li>Channel： 数据传送通道，把Buffer内容输出或读入到Buffer</li><li>Selector： 支持异步I/O操作，也叫非阻塞I/O操作</li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>缓冲区有两个作用：</p><ul><li>减少读取次数</li><li>和<a href="https://xinhecuican.github.io/post/7d1c86da.html">高速缓存</a>有关，这一段内存一直被重用。</li></ul><p>层次：<br><img src="/images/java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.jpg" alt></p><p>他有以下属性：</p><ul><li>容量</li><li>极限： 表示当前所使用缓冲区大小.极限可以修改</li><li>位置： 表示<strong>下一个</strong>读写单元位置</li></ul><p>他有如下设置属性方法：</p><ul><li>clear(): 把极限设置成容量，并且把位置变成0</li><li>flip(): 把极限设置成位置，然后把位置变成0</li><li>rewind(): 不改变极限，把位置变成0</li></ul><p>Buffer类是一个抽象类，他有8个具体类。最基本的是ByteBuffer类，他没有公开构造方法，但是有静态工厂。</p><ul><li>allocate(int capacity):</li><li>directAllocate(int capacity): 返回一个直接缓冲区。直接缓冲区速度较快，但是分配所需时间较多，所以一般只在所需空间较大并且长期使用的情况下才会用它。</li></ul><p>除了boolean类型之外，其他类型都有缓冲区（感觉和c的allocate有点类似），例如LongBuffer。此外，还有一种MappedByteBuffer，这是ByteBuffer的子类。它可以把缓冲区和文件某个区域直接映射（输出）。</p><p>共用方法：</p><ul><li>get(): 从当前位置读一个单元，然后位置加*ex位置读一个单元</li><li>put(): 向当前位置写入一个数据，然后位置加1</li><li>put(int index):</li></ul><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel用来连接缓冲区和数据源。它是一个接口，有两个方法：</p><ul><li>close(): 关闭通道</li><li>isOpen(): 判断通道是否打开</li></ul><p>通道会在创建时被打开，一旦被关闭就不能再次打开。</p><p>子接口ReadableByteChannel声明了read(ByteBuffer dst),把数据源数据读入到缓冲区中。WritableByteChannel声明了write(ByteBuffer src)，这个把src缓冲区中的数据输出。</p><p>ByteChannel扩展了上面说的两个接口，可以同时读写</p><p>ScatteringByteChannel扩展了ReadableByteChannel，可以分散读取数据。分散读取是指可以一次把数据放到多个缓冲区中。</p><p>GatheringByteChannel接口扩展了WritableByteChannel,可以把多个缓冲区中的数据一次性输出。他的wirte(ByteBuffer[] srcs)用来输出数据。</p><p><strong>这些方法都是缓冲区没满就继续读入</strong></p><p>FileChannel是Channel的实现类，他实现了ByteChannel，ScatteringByteChannel，GatheringByteChannel接口。支持上面所有操作。但是他没有公开构造方法，但是FileInputStream，FileOutputStream，RandomAccessFile类中提供了getChannel()方法，返回相应的FileChannel对象。</p><h2 id="Charset"><a href="#Charset" class="headerlink" title="Charset"></a>Charset</h2><p>Charset类每个实例代表特定的字符编码类型。他有以下用于编码转换的方法：</p><ul><li>ByteBuffer encode(String str): 把str转换成当前编码</li><li>ByteBuffer encode(CharBuffer cb): 把cb指定的字符缓冲区变成当前编码</li><li>CharBuffer decode(ByteBuffer bb): 把bb指定的ByteBuffer变成Unicode编码</li></ul><p>Charset有一个defaultCharset(): 返回代表本地平台编码的Charset对象。</p><h2 id="FileChannel读写文件"><a href="#FileChannel读写文件" class="headerlink" title="FileChannel读写文件"></a>FileChannel读写文件</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">&#123;</span><br><span class="line">    final <span class="built_in">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    FileChannel fc = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">"你好"</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//向文件末尾添加</span></span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">RandomAccessFile(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.position(fc.size<span class="literal">()</span>);<span class="comment">//定位到文件末尾</span></span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">"朋友"</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    </span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    ByteBuffer buff = <span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>allocate(BSIZE);</span><br><span class="line">    fc.read(buff);</span><br><span class="line">    buff.flip<span class="literal">()</span>;</span><br><span class="line">    Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line">    S</span><br><span class="line">    ystem.out.println(cs.decode(buff));</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><strong>控制缓冲区</strong></p><p>前面说的clear(),flip，rewind看似没用，但是它可以方便我们读入输出数据</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">buff </span>= <span class="keyword">ByteBuffer.allocate(BSIZE);</span></span><br><span class="line"><span class="keyword">while(in.read(buff) </span>!= -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">buff.flip();</span></span><br><span class="line"><span class="keyword"> </span>   out.write(<span class="keyword">buff);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">buff.clear();</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这段代码前面的flip是为了保证只操作当前数据，而clear()是为了保证接受尽可能多的数据。</p><p><strong>字符编码转换</strong></p><p>CharBuffer存放的数据单元室Unicode字符，ByteBuffer中的asCharBuffer()可以把Byte中数据转换成Unicode字符，并且存放在CharBuffer中。</p><h2 id="缓冲区视图"><a href="#缓冲区视图" class="headerlink" title="缓冲区视图"></a>缓冲区视图</h2><p>ByteBuffer类提供了asCharBuffer(),asIntBuffer(),和asFloatBuffer()来生成视图。通过视图，可以读取或写入各种类型的数据。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span>(bb.hasRemaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    bb.rewind();</span><br><span class="line">    CharBuffer cb = bb.asCharBuffer();</span><br><span class="line">    cb.<span class="built_in">put</span>(<span class="string">"你好"</span>);</span><br><span class="line">    whlie(bb.hasremaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h2><p>用于创建和修改那些因为太大而不能放入内存的文件。</p><p>FIleChannel类提供了获得MappedByteBuffer的map方法：</p><ul><li>MappedByteBuffer map(FIleChannel.MapMode mode, long position, long size)</li></ul><p>position是文件映射起始位置，size是映射区域大小，mode是模式，有三种：</p><ul><li>MapMode.READ_ONLY</li><li>READ_WRITE</li><li>MapMode.PRIVATE: 对MappedByteBuffer的修改不会保存到文件中，且其他程序不可见。</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">0x8000000</span>;</span><br><span class="line">    MappedByteBuffer mb = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D:\\test.txt"</span>,<span class="string">"rw"</span>).getChannel()</span><br><span class="line">    .<span class="built_in">map</span>(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, capacity);</span><br><span class="line">    mb.flip();</span><br><span class="line">    System.out.<span class="built_in">println</span>(Charset.forName(<span class="string">"GBK"</span>).decode(mb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h2><p>他允许程序同步访问作为共享资源的文件，但是可能发生同一时间多个线程同时访问的情况，甚至还有可能要和其他进程竞争。所以java中的文件锁是其他线程可见的。</p><p>FileChannel的tryLock()或Lock()用于锁定文件，如果成功放回FileLock对象，如果不成功就立刻返回null。lock()是阻塞式的，如果没有获得线程就会进入阻塞状态。</p><p>也可以部分加锁</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br><span class="line">lock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br></pre></td></tr></table></figure></div><p>上面的shared如果为true表示共享锁，如果是false是排他锁。</p><ul><li>共享锁，如果一个线程获得了共享锁，那么其他线程还可以获得共享锁，但是不能获得排他锁</li><li>排他锁，如果一个县城获得了排他锁，那么其他线程不可以获得共享锁或排他锁。</li></ul><p>可以用FileLock的isShared()判断锁的类型，如果是true，则是共享锁。release()用于释放文件锁。</p><h1 id="自动释放资源"><a href="#自动释放资源" class="headerlink" title="自动释放资源"></a>自动释放资源</h1><p>因为和c++中的delete一样，经常会忘了close(),所以从JDK7开始，绝大多数I/O类都实现了AutoCloseable接口。他会在一定条件下自动关闭：</p><ul><li>定义在try块中，退出try块时会自动调用close()(无论是正常出去还是非正常退出）。</li></ul><h1 id="用File来查看，创建，删除文件目录"><a href="#用File来查看，创建，删除文件目录" class="headerlink" title="用File来查看，创建，删除文件目录"></a>用File来查看，创建，删除文件目录</h1><p>File表示真实系统中的一个文件，他有如下构造方法：</p><ul><li>File(String pathname):</li><li>File(String parent, String child):parent表示根路径，child表示子路径。</li><li>File(File parent, String child)</li></ul><p>一般来说，如果只要处理一个文件，那么使用第一种构造方法，否则就用后面几种。</p><p>还提供管理文件方法：</p><ul><li>boolean canRead().测试程序是否能对进行读操作</li><li>boolean canWrite()</li><li>boolean delete():删除文件，如果删除的是目录并且目录中有东西就不能删除</li><li>boolean exists():看这个文件时候存在</li><li>String getAbsolutePath():获取文件绝对目录</li><li>String getChanonicalPath(): 获取真正的路径，没有<code>.</code>和<code>..</code></li><li>String getName()</li><li>String getParent()</li><li>String getPath(): 相对目录</li><li>String[] list(): 返回当前目录下所有文件列表</li><li>File[] listFiles().返回目录下的所有文件和目录的File对象</li><li>boolean mkdir(): 创建目录</li><li>boolean createNewFile(): 如果FIle表示文件且在当前目录下不存在，就创建</li></ul><h2 id="操作目录树"><a href="#操作目录树" class="headerlink" title="操作目录树"></a>操作目录树</h2><p>Files类： 有移动文件的move(),复制文件的copy()，搜索目录树的find().此外newDirectoryStream()回创建一个目录流，程序可以通过这个目录流遍历整个目录，用walkFileTree()遍历。</p><p>Path接口： 表示一个路径。</p><p>Paths类： 提供创建Path的静态方法，他的get(String first, String… more)返回一个Path对象，这个对象以first为根路径，以more为子路径.例如：<code>Paths.get(&quot;/root&quot;, &quot;dir1&quot;, &quot;dir2&quot;)</code>返回路径<code>/root/dir1/dir2</code>.</p><p><strong>查看zip</strong></p><p>可以通过FileSystems的newFileSystem()创建表示zip文件的FileSystem对象。然后可以用walkFileTree()遍历zip中所有文件。</p><p>其中walkFileTree可以查看官方文档。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri May 29 2020 19:13:11 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;java.io.
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Lambda</title>
    <link href="http://xinhecuican.github.io/post/d431fab4.html"/>
    <id>http://xinhecuican.github.io/post/d431fab4.html</id>
    <published>2020-05-22T10:02:00.000Z</published>
    <updated>2020-05-31T12:03:03.102Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 31 2020 20:03:03 GMT+0800 (中国标准时间) --><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names.<span class="keyword">forEach</span>((<span class="type">name</span>)-&gt;<span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span>));</span><br><span class="line">names.<span class="keyword">forEach</span>(<span class="keyword">System</span>.<span class="keyword">out</span>::println);//可以通过这种方式直接调用println</span><br></pre></td></tr></table></figure></div><p>基本语法； <code>(Type1 param1,Type2 param2,...)-&gt;{statment1, statment2... return statmentM;}</code></p><p>一般来讲，这个其实是接口或抽象类的简化。但是不是所有的类都可以使用Lambda的。</p><p>只有声明了函数式接口：<code>public @interface FunctionalInterface</code>才可以被Lambda赋值。这个就是可以简写的原因。通过函数式接口可以直接定位到这个类的某一个函数，然后就可以省略函数名等一系列要素.</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(String <span class="type">name</span>)-&gt;&#123;</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span>);</span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></div><p>这个是基础型，还有许多简化型：</p><ul><li>参数类型可以省略。例如上面可以把String省略，因为一般编译器都可以判断出来</li><li>当参数只有一个时，可以省略小括号（但是私以为还是写上的好，为了统一）</li><li>只有一条语句时，可以省略大括号。并且如果return没有返回值，也可以省略。也就是最前面第一个例子的写法。</li><li>也可以只包含一个普通表达式。语法：<code>(Type val1,Type val2...)-&gt;(expression)</code>。例如：<code>(int a, int b)-&gt;(a*b+2)</code></li></ul><h1 id="用Lambda代替内部类"><a href="#用Lambda代替内部类" class="headerlink" title="用Lambda代替内部类"></a>用Lambda代替内部类</h1><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(()</span>-&gt;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"Hello world!"</span>)).start<span class="literal">()</span>;<span class="comment">//方法1</span></span><br><span class="line"></span><br><span class="line">Runnable race = <span class="literal">()</span>-&gt;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"Hello world!"</span>);<span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(<span class="params">race</span>)</span>.start<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></div><p>上面这个例子完整写法是：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">       <span class="keyword">new</span> Runnable()</span><br><span class="line">       &#123;    <span class="comment">//这是一个Runnable的匿名类</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.<span class="built_in">println</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="comment">//匿名类定义结束</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>至于匿名内部类，<a href="https://xinhecuican.github.io/post/348d4e04.html">可以参考</a></p><p>省去new和类名/接口名。并且直接实现run方法。此外()代表的是接口内部方法的参数，因为run()没有参数，所以这里也不写</p><h1 id="forEach-和排序"><a href="#forEach-和排序" class="headerlink" title="forEach()和排序"></a>forEach()和排序</h1><p>forEach定义： forEach(Consumer&lt;? super T&gt; action);</p><p>其中action实例必须实现Comsumer接口的accept(T t)方法。action指定具体的行为。</p><p>从jdk5开始，集合都实现了Iterable接口。也就是可以使用forEach()</p><p>例如：<code>names.forEach((name)-&gt;System.out.println(name+&quot;,&quot;));</code></p><p>上面的Lambda表达式相当于Consumer的匿名对象。</p><p><strong>排序</strong><br>实际上就是简化了Comparator接口或者其他有关排序接口的写法。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Comparator</span>&lt;<span class="keyword">String&gt; </span>sortByName = (<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>)-&gt;(<span class="built_in">s1</span>.compareTo(<span class="built_in">s2</span>))<span class="comment">;</span></span><br><span class="line"><span class="symbol">Collections.sort</span>(names,sortByName)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="symbol">Collections.sort</span>(names,(<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>)-&gt;(<span class="built_in">s1</span>.compareTo(<span class="built_in">s2</span>)))<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><h1 id="和streamapi联合"><a href="#和streamapi联合" class="headerlink" title="和streamapi联合"></a>和streamapi联合</h1><h1 id="Lambda表达式变量作用域"><a href="#Lambda表达式变量作用域" class="headerlink" title="Lambda表达式变量作用域"></a>Lambda表达式变量作用域</h1><p>Lambda可以访问外部类的所有变量。还可以使用this，这里this引用的是外部类。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">String</span>[] data = &#123;<span class="string">"Tom"</span>, <span class="string">"Mike"</span>, <span class="string">"Mary"</span>&#125;;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; names = Arrays.asList(data);</span><br><span class="line">        <span class="keyword">char</span> var2 = <span class="string">','</span>;</span><br><span class="line">        names.forEach((name)-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            var1++;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="keyword">this</span>.var1+<span class="string">":"</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> A().test();</span><br><span class="line">    |</span><br><span class="line">|</span><br></pre></td></tr></table></figure></div><p>但是要注意一点，只能使用final修饰或者程序中不会改变的局部变量。这个类似于匿名内部类（实际上Lambda有匿名内部类的功能）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 31 2020 20:03:03 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 泛型</title>
    <link href="http://xinhecuican.github.io/post/70263071.html"/>
    <id>http://xinhecuican.github.io/post/70263071.html</id>
    <published>2020-05-21T10:37:00.000Z</published>
    <updated>2020-05-21T12:43:04.923Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu May 21 2020 20:49:10 GMT+0800 (中国标准时间) --><h1 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h1><p>由父类转给子类时允许的，但是会抛出ClassCastException。这种异常是运行时异常，编译期不会检查，这就加大了检查的难度。为了解决这个问题，从jdk5开始引入了泛型。泛型可以把ClassCastException转换成编译时类型不兼容错误。</p><p>泛型符号是&lt;&gt;,里面可以使任意一种类（不能是int等基础类型，可以是Integer).</p><p>例如： <code>Set&lt;Object&gt; set = new HashSet&lt;Object&gt;();//实例中的类型必须要和前面相同</code></p><h1 id="泛型类，数组，接口，方法"><a href="#泛型类，数组，接口，方法" class="headerlink" title="泛型类，数组，接口，方法"></a>泛型类，数组，接口，方法</h1><p><strong>泛型类</strong></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bag</span><span class="params">(T content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Bag&lt;<span class="keyword">String</span>&gt; bag = <span class="keyword">new</span> Bag&lt;<span class="keyword">String</span>&gt;(<span class="string">"mybook"</span>);</span><br><span class="line">        Integer content1 = bag.<span class="built_in">get</span>();<span class="comment">//出错</span></span><br><span class="line">        <span class="keyword">String</span> content2 = bag.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这和c++中的模板十分类似。同样泛型参数可以有许多个，例如：<code>public class A&lt;str,inte,dou&gt;{...}</code></p><p><strong>注意</strong> 如果没有传入泛型实参的话，泛型变量可以使任何类型。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> <span class="constructor">Generic(<span class="string">"111111"</span>)</span>;</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> <span class="constructor">Generic(4444)</span>;</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> <span class="constructor">Generic(55.55)</span>;</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> <span class="constructor">Generic(<span class="params">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.get<span class="constructor">Key()</span>);</span><br></pre></td></tr></table></figure></div><p><strong>泛型接口</strong></p><p>泛型接口和泛型类类似，但是它的实现类如果实现的是泛型接口，那么它的实现类也要是泛型。例如：</p><p><code>public class A&lt;T&gt; implements B&lt;T&gt;</code></p><p>如果<code>public class A implements B&lt;T&gt;</code>会报错</p><p>但是如果实现的是一个确定类型的接口，那么前面就不是必须加</p><p><code>public class A implements B&lt;Integer&gt;</code>可以</p><p><strong>数组</strong></p><p>以前我们都是 int[], double[],现在我们把前面的类型变成泛型。例如<code>T[]</code>。</p><p>这里要注意一点，不能使用泛型创建实例。例如<code>T[] content = new T[10];</code>是错误的。</p><p><strong>方法</strong></p><p>在普通类和泛型类中都可以定义泛型方法。泛型方法只需要在方法头部定义泛型符号就可以了，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    Integer[] b = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    a.printArray(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>感觉泛型方法很方便，直接传入参数就可以了，不用管类型。但是这样势必会增大时间开销。</p><h1 id="extends限定类型参数"><a href="#extends限定类型参数" class="headerlink" title="extends限定类型参数"></a>extends限定类型参数</h1><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> 类名&gt; 必须要是这个类或者子类</span><br><span class="line">&lt;T <span class="keyword">extends</span> 接口名&gt;</span><br></pre></td></tr></table></figure></div><h1 id="使用？通配符"><a href="#使用？通配符" class="headerlink" title="使用？通配符"></a>使用？通配符</h1><p>前面已经说过，实例中泛型类型必须要和定义时泛型类型相同。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; s1 =  <span class="keyword">new</span> HashSet&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; s2 = <span class="keyword">new</span> HashSet&lt;<span class="built_in">Integer</span>&gt;();//报错</span><br></pre></td></tr></table></figure></div><p>为了防止上述错误，可以使用通配符？，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; listInteger = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        listInteger.add(<span class="number">11</span>);</span><br><span class="line">        <span class="built_in">print</span>(listInteger);</span><br><span class="line">        printNew(listInteger);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Collection&lt;Object&gt; collection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj: collection)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNew</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj: collection)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>print会出现问题，因为只能接受Object的泛型类型，后面一个就可以。</p><p>还可以和extends结合。例如：</p><p><code>TreeSet&lt;? extends Number&gt; x = new TreeSet&lt;Integer&gt;();//可以，Integer是Number的子类</code></p><p>这个和前面说的区别是前面是在定义时决定的，这个是在具体写代码时决定的，个人认为这种更为灵活。</p><p>还有super，后面类型只能是前面类型的父类或者他自己。例如：<code>TreeSet&lt;? super Integer&gt; x = new TreeSet&lt;Number&gt;();</code></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>看上去不同的泛型类型导致了不同的类。例如<code>A&lt;Integer&gt;</code>和<code>A&lt;String&gt;</code>是不同的类，但是实际上泛型的类型在编译时期已经赋给内部的变量了，这个时候泛型被擦除了，所以实际上创建实例时还是调用了方法区中的A。</li><li>因为上一条，所以不允许出现名字相同只有泛型类型不同的重载，例如：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"String"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;Integer&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Integer"</span>);</span><br><span class="line">&#125;</span><br><span class="line">会报错</span><br></pre></td></tr></table></figure></div></li><li>不能对确切的泛型使用instanceof符号，例如：<code>Collection cs = new ArrayList&lt;String&gt;(); cs instanceof Collection&lt;String&gt;; 报错</code></li></ul><p>但是如果后面使用通配符就可以，<code>cs instanceof Collection&lt;?&gt;通过</code></p><ul><li>不能使用泛型类型进行强制类型转换，例如：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection cs = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = (ArrayList&lt;<span class="keyword">String</span>&gt;)cs;<span class="comment">//会警告并且运行时容易出现异常</span></span><br></pre></td></tr></table></figure></div></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu May 21 2020 20:49:10 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;发展过程&quot;&gt;&lt;a href=&quot;#发展过程&quot; class=&quot;headerlink&quot; title=&quot;发展过程&quot;&gt;&lt;/a&gt;发展过程&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 集合，列表，队列，映射</title>
    <link href="http://xinhecuican.github.io/post/d5381517.html"/>
    <id>http://xinhecuican.github.io/post/d5381517.html</id>
    <published>2020-05-16T10:30:00.000Z</published>
    <updated>2020-05-24T12:47:41.037Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 25 2020 13:31:40 GMT+0800 (中国标准时间) --><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>Set（集），集合中对象不以特定方式排序（有的实现类可以），没有重复元素</li><li>List(列表），按照索引排序，可以有重复对象。List和数组类似。</li><li>Queue（队列），先进先出</li><li>Map（映射）： 有键值对。没有重复键对象，可以有重复值对象</li></ul><p>定义：</p><p><code>Set&lt;String&gt; set = new HashSet&lt;String&gt;();</code></p><h2 id="Collection-和-Interator接口"><a href="#Collection-和-Interator接口" class="headerlink" title="Collection 和 Interator接口"></a>Collection 和 Interator接口</h2><p>Collection声明了上面这些数据结构（不包含map）通用的方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean add(Object o)</td><td>加入对象</td></tr><tr><td>void clear()</td><td>删除所有对象</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否有特定对象</td></tr><tr><td>boolean isEmpty()</td><td></td></tr><tr><td>Iterator iterator()</td><td>返回一个Iterator对象（<a href="https://xinhecuican.github.io/post/37318.html">迭代器</a>）</td></tr><tr><td>boolean remove(Object o)</td><td></td></tr><tr><td>int size()</td><td>返回数目</td></tr><tr><td>Object[] toArray()<t>T[]toArray(T[] a)</t></td><td>返回一个数组，包含集合中所有元素</td></tr></tbody></table><p>Set接口，List接口，Queue接口都继承了Collection接口。</p><p>Inerator接口定义了如下方法：</p><ul><li>hasNext()：判断集合中的元素是否遍历完毕，如果没有返回true</li><li>next(): 返回下一个元素。例如iter.next()是让iter这个迭代器进一位</li><li>remove(): 删除由next()返回的元素</li></ul><p>如果先用iterator()得到一个Iterator对象后，又用Collection的其他方法，再用next()可能会抛出ConcurrentModifcationException异常。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LISP"><figure class="iseeu highlight /lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; a = new HashSet&lt;Integer&gt;()<span class="comment">;</span></span><br><span class="line">for(<span class="name">int</span> i=0<span class="comment">; i&lt;10; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    a.add(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;Integer&gt; iter = a.iterator()<span class="comment">;</span></span><br><span class="line">while(<span class="name">iter</span>.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="name">iter</span>.next())<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="添加基本类型数据"><a href="#添加基本类型数据" class="headerlink" title="添加基本类型数据"></a>添加基本类型数据</h2><p>实际上集合中只能存放对象。但是经常可以看到list.add(2)之类的操作。实际上在添加的时候已经隐式转换成Integer对象了。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>set本身是不排序的。但是它的实现类TreeSet具有排序功能。</p><h2 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h2><p>当添加一个新的元素时，首先要检查这个对象是否已经存在于集合中。如果存在就不添加。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> Set&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">String</span> s1 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">String</span> s2 = s1;</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(s1);</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(s2);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">set</span>.<span class="built_in">size</span>());</span><br><span class="line">结果放回<span class="number">1</span></span><br></pre></td></tr></table></figure></div><h2 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h2><p>HashSet使用哈希算法存放集合中对象。具有良好的查找和存取性能。</p><p>前面说过在Object类中有hashCode()方法返回哈希值，而这个有使用hash算法存储的，所以判断两个对象是否相等还可以<code>customer1.hashCode() == customer2.hashCode();</code></p><p>如果一个类覆盖了equals()方法，那么就应该实现hashCode()方法，保证党两个对象相等时，hashcode相同。</p><h2 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h2><p>TreeSet类实现了SortedSet接口，可以对集合中对象排序。TreeSet支持两种排序方法：自然排序和客户化排序。默认使用自然排序。</p><p><strong>自然排序</strong></p><p>TreeSet实现了Comparable接口的compareTo(Object o)方法比较集合中对象大小。如果返回值大于0，代表这个值大于o。<strong>只有实现了Comparable接口的对象才可以使用TreeSet进行排序</strong>。compareTo方法最好要从小到大进行排序，以便和其他的进行匹配。</p><p>下面列举了一些实现了Comparable接口的类</p><table><thead><tr><th>类</th><th>排序</th></tr></thead><tbody><tr><td>BigDecimal BigInteger Byte Double Float Integer Long Short</td><td>按数字大小</td></tr><tr><td>Character</td><td>按字符 Unicode值</td></tr><tr><td>String</td><td>按字符串中Unicode值</td></tr></tbody></table><p>如果是自己定义的类，首先要实现Comparable接口。并且最好也是通过返回值大于零小于零来判断谁大谁小的。</p><p>注意，如果把一个对象加入TreeSet并且修改它的属性TreeSet是不会重新排序的。所以适合排序的是不可变类。</p><p><strong>客户化排序</strong></p><p>客户化排序可以降序排序。首先实现java.util.Comparator<t>接口。Comparator有个compare(T x, T y)方法用于比较两个对象的大小，如果返回值大于0，表示x&gt;y。</t></p><p>如果想实现降序排序，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">CustomerComparator</span> <span class="symbol">implements</span> <span class="symbol">Comparator</span>&lt;<span class="symbol">Customer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> compare(Customer c1, Customer c2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c1,getName().compareTo(c2.getName())&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c1.getName().compareTo(c2.getName())&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Set&lt;Customer&gt; <span class="keyword">set</span> = new TreeSet&lt;Customer&gt;(new CustomerComparator());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Set有个构造方法 Set(Comparator comparaotr)可以使用Comparator来确定升序还是降序。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>list的实现类有：</p><ul><li>ArrayList： ArrayList代表长度可变数组。ArrayList实现了RandomAccess接口，这个接口不包含任何方法，仅仅表示有良好的随机访问性能。</li><li>LinkedList： 链式结构。LinkedList不仅仅可以做数组，还可以做堆栈，队列，双向队列。</li></ul><h2 id="访问元素和排序"><a href="#访问元素和排序" class="headerlink" title="访问元素和排序"></a>访问元素和排序</h2><p>list中get(int index)方法可以返回集合中索引位置的数。List中的iterator()和Set中的iterator()一样，也可以用来遍历。</p><p>此外，还可以用foreach来遍历</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LESS"><figure class="iseeu highlight /less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">for</span>(Integer <span class="attribute">i</span>: list)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.print</span>(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>至于排序，只能对集合中的对象按索引进行排序，如果想用其他方式，可以实现collections类和Comparator接口。Collections类中的sort方法可以用来排序</p><ul><li>sort(List list) 对List对象进行自然排序</li><li>sort(List list, Comparator comparator)进行客户化排序</li></ul><h2 id="ListIterator-接口"><a href="#ListIterator-接口" class="headerlink" title="ListIterator 接口"></a>ListIterator 接口</h2><p>List中listIterator()返回一个ListIterator对象，这个对象继承了Iterator接口，此外还有一些独有的方法</p><ul><li>add() 向列表中插入一个元素</li><li>hasNext() 判断列表中是否还有下一个元素</li><li>hasPrevious(): 判断列表中是否还有上一个元素</li><li>next(): 返回下一个元素</li><li>previous(): 返回上一个元素</li></ul><p>![](/images/java 集合，列表，队列，映射.jpg)</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue提供了add()和offer()两种方法来从队尾加元素，如果是add队满就会抛出IllegalStateException，如果是offer()会返回false。</p><p>删除也有两种，一种是remove()，一种是poll()。如果是remove，队空后会跑出NoSuchElementException，如果是poll，空了会返回null</p><p>获取元素，一种是element(),一种是peek().如果不成功（队空），那么会出现和删除队空同样的情况。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deque是一个接口</p><p>从头或尾添加元素</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addFirst</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="function"><span class="title">addLast</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">offerFirst</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">offerLast</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br></pre></td></tr></table></figure></div><p>如果队满，都会抛出IlllegalStateException.后两种方法返回false</p><p>删除</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">E</span> <span class="function"><span class="title">removeFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">removeLast</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">pollFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">pollLast</span>()</span></span><br></pre></td></tr></table></figure></div><p>和前面队空判断一样</p><p>获取</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">E</span> <span class="function"><span class="title">getFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">getLast</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">peekFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">peekLast</span>()</span></span><br></pre></td></tr></table></figure></div><p>就是把上面的queue加了个first和last</p><p>LinkedList和ArrayList都实现了Deque接口，</p><h2 id="PriorityQueue-优先队列"><a href="#PriorityQueue-优先队列" class="headerlink" title="PriorityQueue 优先队列"></a>PriorityQueue 优先队列</h2><p>优先队列使用堆进行排序。并且因为要排序，所以想用优先队列要首先实现Comparable接口。</p><p>这里的remove总会首先删除最小的元素。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>定义： Map&lt;type1, type2&gt; map = new HashMap&lt;type1, type2&gt;();</p><p>其中type1是键类型，type2是值类型。</p><p>Map叫映射，就是给出键返回值。可以使用get(Object key)得到值。通过put(Object key, Object value)插入键值对。</p><p>Map的键不允许有重复，但是值可以有重复。</p><p>Map有两种常用实现，HashMap和TreeMap，HashMap用哈希算法来存取键对象，有良好的取性能。为了保证能正常工作，也要确保通过equals()比较为true时，两个对象返回哈希码相同。</p><p>TreeMap实现了SortedMap接口，可以对键进行排序。如果想进行客户化排序，可以调用TreeMap(Comparator comparator)构造函数。</p><p>Map的keySet()返回所有键对象的集合。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; <span class="keyword">set</span> = map.entrySet();<span class="comment">//注意</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iter = <span class="keyword">set</span>.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>=<span class="number">0</span></span><br><span class="line"><span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>=<span class="number">2</span></span><br><span class="line"><span class="number">3</span>=<span class="number">3</span></span><br><span class="line"><span class="number">4</span>=<span class="number">4</span></span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">6</span>=<span class="number">6</span></span><br><span class="line"><span class="number">7</span>=<span class="number">7</span></span><br><span class="line"><span class="number">8</span>=<span class="number">8</span></span><br><span class="line"><span class="number">9</span>=<span class="number">9</span></span><br></pre></td></tr></table></figure></div><p>set内的类型是Map.Entry,可以使用getKey()返回键，使用getValue()返回值。</p><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>适用于List的方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STATA"><figure class="iseeu highlight /stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span>(<span class="keyword">List</span> dest, <span class="keyword">List</span> src): 把一个<span class="keyword">list</span>复制到另一个<span class="keyword">list</span>中</span><br><span class="line">fill(<span class="keyword">List</span> <span class="keyword">list</span>,Object o) 想列表中填充元素</span><br><span class="line"><span class="keyword">sort</span>(<span class="keyword">List</span> <span class="keyword">list</span>) 排序</span><br><span class="line">binarySearch(<span class="keyword">List</span> <span class="keyword">list</span>, Object key) 如果有序就可以用这个</span><br><span class="line">shuffle(<span class="keyword">List</span> <span class="keyword">list</span>): 对<span class="keyword">List</span>中元素随机排列</span><br></pre></td></tr></table></figure></div><p>适用于Map或Collection的：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> max(Collection coll):返回集合中最大的元素</span><br><span class="line"><span class="built_in">Object</span> max(Collection coll, Comparator comp):采用指定规则进行比较，返回最大元素</span><br><span class="line"><span class="built_in">Object</span> min(Collection coll)</span><br><span class="line"><span class="built_in">Object</span> min(Collection coll, Comparator comp)</span><br><span class="line"><span class="built_in">Set</span> singleton(<span class="built_in">Object</span> o): 返回一个不可变的<span class="built_in">Set</span></span><br><span class="line"><span class="built_in">List</span> singletonList(<span class="built_in">Object</span> o) 返回不可改变的<span class="built_in">List</span></span><br><span class="line"><span class="built_in">Map</span> singletonMap（<span class="built_in">Object</span> key, <span class="built_in">Object</span> value):</span><br><span class="line">Collection synchronizedCollection(Collection c): 在原来的基础上，返回支持同步的集合</span><br><span class="line"><span class="built_in">Map</span> synchronizedMap(<span class="built_in">Map</span> m)</span><br><span class="line"><span class="built_in">Set</span> ...</span><br><span class="line"><span class="built_in">List</span> ...</span><br><span class="line">Collection unmodifiableCollection(Collection c): 在原来结合的基础上，返回不可改变的集合视图</span><br><span class="line">其他三个相同</span><br></pre></td></tr></table></figure></div><p>前面的singleton是指这个集合中只有一个元素，并且不允许修改</p><p>而后面的unmodifiable是返回这个集合，但是如果原集合修改，这个集合也会跟着修改。不允许修改指的是不允许修改这个集合视图</p><p><strong>线程安全的集合</strong></p><p>在平常情况下集合的实现类都没有同步锁机制，这样可以加快速度。但是当有多个线程同时操作一个锁的时候就需要同步机制了。一种方式就是在可能导致问题的代码块用synchronized，另一种就是上面讲的方法。</p><h1 id="集合批量操作"><a href="#集合批量操作" class="headerlink" title="集合批量操作"></a>集合批量操作</h1><p>前面说的都是一次处理一个元素，如果要处理多个元素，可以采用Collection中的方法：</p><ul><li>boolean retainAll(Collection&lt;?&gt; c)修改集合，保留在c中的元素并删去其他元素</li><li>boolean removeAll(Collection&lt;?&gt; c)删去集合中c的元素。</li><li>boolean addAll(Collection&lt;? extends E&gt; c): 把c中元素加入到当前集合中</li><li>boolean containsAll(Collection&lt;?&gt; c): 判断当前集合是否全部包含c</li></ul><h1 id="其他集合类"><a href="#其他集合类" class="headerlink" title="其他集合类"></a>其他集合类</h1><p>Properties是一种特殊的Map类。他可以用load()从输入流中读取键和值。例如；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties ps = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span><br><span class="line">InputStream <span class="keyword">in</span> = <span class="module-access"><span class="module"><span class="identifier">PropertiesTester</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ResourceAsStream(<span class="string">"myapp.properties"</span>)</span>;</span><br><span class="line">ps.load(<span class="keyword">in</span>);</span><br><span class="line"><span class="keyword">in</span>.close<span class="literal">()</span>;</span><br><span class="line">print(ps);</span><br><span class="line">ps=<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Properties()</span>;</span><br><span class="line">print(ps);</span><br></pre></td></tr></table></figure></div><p>可以使用System.getProperties()返回一个Propertiese对象。这个对象中包含一系列系统属性。</p><p>BitSet表示一组boolean数据集合。类似于boolean[]数组。最小初始容量是64位，可以通过BitSet(int bits)设置初始容量。如果达到了初始容量会自动增加。</p><p>BitSet中有以下方法：</p><ul><li>set(int index) 把index位置的元素设置成true</li><li>clear(int index) 把index位置的元素设false</li><li>get(int index): 获得index位置的元素值</li><li>and(BitSet bs): 与bs进行与运算，结果保存在当前BitSet中</li><li>or(Bitset bs)</li><li>xor(BitSet bs)</li></ul><p>BitSet在c++中是返回二进制信息，在这里也可以有这个作用。可以自己建立byteToBitSet()计算出byte类型的二进制位，其他类型类似。printBitSet()打印BitSet二进制信息。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte </span>a = <span class="number">125</span>;</span><br><span class="line"><span class="keyword">short </span><span class="keyword">b </span>= -<span class="number">125</span>;</span><br><span class="line">int c = -<span class="number">125</span>;</span><br><span class="line">long d = <span class="number">125</span>;</span><br><span class="line">printBitSet(<span class="keyword">byteToBitSet(a), </span><span class="keyword">BYTE_SIZE);</span></span><br><span class="line"><span class="keyword">printBitSet(shortToBitSet(b), </span><span class="keyword">SHORT_SIZE);</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure></div><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>位置： java.lang.Enum。这个类是抽象类</p><p>此外，还提供了关键字enum。例如 public enum Gender{FEMALE, MALE}</p><p>Enum类有如下非抽象方法（一般直接使用enum就可以了，也有这些)：</p><ul><li>intcompareTo(E o) 比较当前常量与指定对象的顺序</li><li>Class<e>getDeclaringClass()返回当前类型的class对象</e></li><li>String name() 返回当前枚举常量的名称。例如调用Gender.FEMALE的name()方法，会返回FEMALE</li><li>intordinal() 返回当前枚举常量在声明时的位置</li><li>toString() 返回枚举常量的名称</li><li><code>static&lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)</code>返回制定枚举类型和名称返回的枚举常量</li><li>static Enum[] values() 以数组的方式返回所有的枚举常量</li><li>range(from， to)用来迭代</li></ul><p>range用法例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">for(WeekDayEnum</span> <span class="string">day : EnumSet.range(WeekDayEnum.Mon, WeekDayEnum.Fri)) &#123; </span></span><br><span class="line">    <span class="meta">System.out.println(day);</span> <span class="string"></span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">输出</span></span><br><span class="line"><span class="attr">Mon</span> <span class="string"></span></span><br><span class="line"><span class="attr">Tue</span> <span class="string"></span></span><br><span class="line"><span class="attr">Wed</span> <span class="string"></span></span><br><span class="line"><span class="attr">Thu</span> <span class="string"></span></span><br><span class="line"><span class="attr">Fri</span></span><br></pre></td></tr></table></figure></div><p>枚举类型最大的作用就是可以用于switch，相当于扩充了switch的范围。</p><h2 id="枚举类型构造方法"><a href="#枚举类型构造方法" class="headerlink" title="枚举类型构造方法"></a>枚举类型构造方法</h2><p>这个构造方法时private，或friendly类型的，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Gender</span><br><span class="line">&#123;</span><br><span class="line">    MALE(<span class="string">"男性"</span>),</span><br><span class="line">    FEMALE(<span class="string">"女性"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> description;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Gender</span><span class="params">(<span class="keyword">String</span> description)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Gender g = Gender.valueOf(<span class="string">"FEMALE"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (g)<span class="comment">//必须要是实例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.<span class="built_in">println</span>(g.getDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.<span class="built_in">println</span>(g.getDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意前面定义时的符号，如果是基础类型，那么最后一个不用跟任何符号，如果不是，那么最后一个必须要封号。并且前面只能是逗号</p><p>enum是构造对象时产生的，因此看起来相同的两个类型实际上比较时也可能不相同。</p><h2 id="EnumSet和EnumMap"><a href="#EnumSet和EnumMap" class="headerlink" title="EnumSet和EnumMap"></a>EnumSet和EnumMap</h2><p>前面一个把枚举转化成集合，它的静态allOf()方法把枚举类所有常量实例存放到一个EnumSet类型的集合中，然后放回这个集合。</p><p>EnumMap转换成映射，它的EnumMap(Class<k>keyType)来指定具体的枚举类型。枚举常量以key的方式存到Map中。例如：</k></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EnumSet&lt;WeekDayEnum&gt; <span class="built_in">subset</span> = EnumSet.of(WeekDayEnum.Mon, WeekDayEnum.Wed); </span><br><span class="line">     <span class="keyword">for</span> (WeekDayEnum <span class="built_in">day</span> : <span class="built_in">subset</span>) &#123; </span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="built_in">day</span>);  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon May 25 2020 13:31:40 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;Set
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java 数组</title>
    <link href="http://xinhecuican.github.io/post/325cdbf2.html"/>
    <id>http://xinhecuican.github.io/post/325cdbf2.html</id>
    <published>2020-05-14T11:54:00.000Z</published>
    <updated>2020-05-18T12:01:44.506Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>可以这样声明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] scores<span class="comment">;</span></span><br><span class="line">String[] names<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>也可以这样声明</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int scores[]<span class="comment">;</span></span><br><span class="line">String names[]<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>二维更为古怪</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-attr">[]</span><span class="selector-tag">x</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-tag">x</span><span class="selector-attr">[]</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">x</span><span class="selector-attr">[]</span><span class="selector-attr">[]</span>;</span><br></pre></td></tr></table></figure></div><p>这里注意一点，声明时不能往括号中加东西，会报错。例如：<code>int x[1];//报错</code></p><p>java中推荐吧括号放到前面，可能int[]也成了一个对象？</p><h2 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h2><p>创建数组对象语法和c++中创建动态数组类似。</p><p><code>int[] scores = new int[100];</code></p><p>上面这个代码首先要在堆中分配空间，然后把里面的数据初始化。</p><p>括号中的数字可以使常量，也可以是变量，甚至可以是0(表示里面没有数据).</p><h2 id="访问数组的元素和长度"><a href="#访问数组的元素和长度" class="headerlink" title="访问数组的元素和长度"></a>访问数组的元素和长度</h2><p>和c++一样，下标索引。如果越界，会抛出ArrayIndexOutOfBoundsException异常</p><p>所有数组都有length属性，表示数组的长度: <code>public final length</code>.</p><p>所以我们可以直接输出这一属性，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x<span class="literal">[]</span> = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="number">40</span>]</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.length); <span class="comment">//输出length</span></span><br></pre></td></tr></table></figure></div><p>如果是对象数组，那么数组中的元素时对象的引用，因此当我们不使用数组的时候最好把值赋null触发垃圾回收机制。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> sb = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">String</span> sbs[] = <span class="keyword">new</span> <span class="built_in">String</span>[](sb,<span class="keyword">null</span>);</span><br><span class="line">...</span><br><span class="line">sbs[<span class="number">0</span>] = <span class="keyword">null</span>;<span class="comment">//清除数组对象的引用</span></span><br><span class="line">sbs = <span class="keyword">null</span>;<span class="comment">//清除数组引用</span></span><br></pre></td></tr></table></figure></div><h2 id="多维数组和不规则数组"><a href="#多维数组和不规则数组" class="headerlink" title="多维数组和不规则数组"></a>多维数组和不规则数组</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[<span class="string"></span>][<span class="symbol"></span>] rooms = new String[<span class="string">2</span>][<span class="symbol"></span>];</span><br><span class="line">rooms[<span class="string">0</span>] = new String[]("Tom","Mike");</span><br><span class="line">rooms[<span class="string">1</span>] = new String[]("Mary");</span><br></pre></td></tr></table></figure></div><p>可以用不等长数组是因为每一行都是一个数组元素，都有自己的length变量</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;rooms.<span class="built_in">length</span>; <span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">0</span>; k&lt;rooms[<span class="built_in">i</span>].<span class="built_in">length</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(rooms[<span class="built_in">i</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>第一个循环的length是rooms引用多少个数组，rooms[]指的是每个数组的长度。</p><p>要注意只有最后一个括号可以不加数字，我的理解是只有最后一层才是真正的数组对象，才有length，同时，前面不确定就不知道要开多少个数组对象。</p><h2 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h2><p>在c++中数组是不能作为返回值的，因为c++中数组是一个指针，而又不能像其他指针一样确定它的大小。而在java中数组是一个对象，可以返回它的引用。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>平常我们想找某一个值都是通过遍历数组得到的，我们也可以用值通过某种映射关系得到在数组中的位置。这就是哈希表</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>%<span class="number">10</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个例子中value就是值，返回的是下标。但是这时如果超过十就会出现重复，这叫做哈希冲突。我们可以设计更复杂的映射来处理哈希冲突。</p><p>判断重复的条件是 object1.equals(boject2)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    private</span> Object value;</span><br><span class="line">    private <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(Object</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getValue()</span><br><span class="line">    &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">Node</span> <span class="title">getNext</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNext(<span class="keyword">Node</span> <span class="title">next</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyhashSet</span><br><span class="line">&#123;</span><br><span class="line">    private <span class="keyword">Node</span><span class="title">[] array</span>;</span><br><span class="line">    private int size = <span class="number">0</span>;//数组元素数目</span><br><span class="line">    public MyHashSet(int length)</span><br><span class="line">    &#123;</span><br><span class="line">        array = new <span class="keyword">Node</span><span class="title">[length</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    public int size()</span><br><span class="line">    &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int hash(Object o)//哈希算法</span><br><span class="line">    &#123;</span><br><span class="line">        int h = o.hashCode();//Object类中有这个方法</span><br><span class="line">        h += ~(h <span class="tag">&lt;&lt; 9);</span></span><br><span class="line"><span class="tag">        h ^= (h &gt;</span>&gt;&gt; <span class="number">14</span>);</span><br><span class="line">        h += (h <span class="tag">&lt;&lt; 4);</span></span><br><span class="line"><span class="tag">        h ^= (h &gt;</span>&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int indexFor(int hashCode)</span><br><span class="line">    &#123;</span><br><span class="line">        return hashCode &amp; (array.length-<span class="number">1</span>);//返回索引</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void add(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">newNode</span> = new <span class="keyword">Node</span><span class="title">(value</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array(index);</span><br><span class="line">        if(<span class="keyword">node</span> <span class="title">== null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            array(index) = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        else//处理哈希冲突</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">Node</span> <span class="title">nextNode</span>;</span><br><span class="line">            while(!<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value) &amp;&amp;</span><br><span class="line">            (nextnode = <span class="keyword">node</span>.<span class="title">getNext</span>()) != null)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= nextNode</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //不允许加入重复元素</span><br><span class="line">            if(!<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">node</span>.<span class="title">setNext</span>(newNode);</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //测试是否有这个对象</span><br><span class="line">    public boolean contains(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array[index];</span><br><span class="line">        while(<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; !<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">node</span> <span class="title">= node</span>.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">!=null</span> &amp;&amp; <span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean remove(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array[index];</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">!=null</span> &amp;&amp; <span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            array[index] = <span class="keyword">node</span>.<span class="title">getNext</span>();</span><br><span class="line">            size--;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">Node</span> <span class="title">lastNode</span> = null;</span><br><span class="line">        while(<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; !<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            lastNode.setNext(<span class="keyword">node</span>.<span class="title">getNext</span>());</span><br><span class="line">            size--;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object[] getAll()</span><br><span class="line">    &#123;</span><br><span class="line">        Object[] values = new Object[size];</span><br><span class="line">        int index = <span class="number">0</span>;</span><br><span class="line">        for(<span class="keyword">Node</span> node:<span class="title"> array</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            while(<span class="keyword">node</span> <span class="title">!= null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                values[index++] = <span class="keyword">node</span>.<span class="title">getValue</span>();</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= node</span>.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p>java.util.Arrays类，有一系列操作数组的方法。这是一个私有类</p><p>静态方法：</p><ul><li>equals(): 比较两个数组是否相同</li><li>fill(): 向数组中填充数据</li><li>sort(): 把数组升序排列</li><li>parallelSort(): 开启多个线程，以并发的方式对数组中元素进行排序，提高效率</li><li>asList()把一个数组变成List</li></ul><p>例： Arrays.sort(a);</p><h1 id="用-…-声明数目可变参数"><a href="#用-…-声明数目可变参数" class="headerlink" title="用 … 声明数目可变参数"></a>用 … 声明数目可变参数</h1><p>可以用int… a代替 int[] a;这种模式下如果输入立即数可以转化成数组类型：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>... datas)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//可以直接输入数据</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure></div><p>但是必须要放在参数列表的最后一位</p><p>```<br>pubilc void max(int… data, String p)//错误，int… 必须放在最后<br>{<br>…<br>}</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;声明&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟内存</title>
    <link href="http://xinhecuican.github.io/post/f79e4123.html"/>
    <id>http://xinhecuican.github.io/post/f79e4123.html</id>
    <published>2020-05-12T05:37:00.000Z</published>
    <updated>2020-05-19T06:30:23.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 14:30:29 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>我们在生成程序的时候，会发现每个程序的起始地址都是一样的，那么这种一样的地址怎么赋给实际的物理地址上的呢？这就要依靠虚拟内存机制了。</p><p>虚拟内存着力于解决进程间内存分配的问题，并且它还有一个作用是使进程之间相互隔绝。例如不小心产生了一个野指针指向了其他内存的位置，但是实际上却不会破坏其他程序而只会破坏自己的程序，这是因为虚拟内存限制了每个程序所使用的空间，如果超出限制就会报错。</p><p>程序中所使用的空间叫做虚拟空间，一共有2的n次方。而系统上有一个物理地址空间。虚拟内存做的其实是把虚拟空间上的内存地址映射到物理空间上。在cpu中，有一个叫MMU的部件专门做虚拟地址和物理地址转化。</p><h1 id="虚拟内存的组织形式"><a href="#虚拟内存的组织形式" class="headerlink" title="虚拟内存的组织形式"></a>虚拟内存的组织形式</h1><p>虚拟内存中的内存其实是按页进行划分的。这类似与磁盘中的扇区概念，即使那个扇区中只有一个字节的数据，取数据时也是把一个扇区全取出来。</p><p>虚拟内存页的大小一般是4kb到2mb之间。而物理内存也是按页进行分块，并且块的大小和虚拟内存页的大小相同。</p><p>其实把程序加载到内存时也不是一股脑直接加载的，而是一块一块逐个加载，并且如果内存满了还有块替换策略，这实质上是把内存当做一级缓存使用。</p><p>虚拟页有三种情况：</p><ul><li>未分配的， 这部分内存就是虚拟内存预留出来的部分，例如malloc使用的空间，各个段之间预留出来的空间等。</li><li>缓存的， 就是加载到内存中的</li><li>未缓存的，是程序的组成部分但是还没有加载到缓存中。</li></ul><p>由于磁盘访问速度过慢（比SRAM小100000倍），所以我们要尽可能的降低未命中率。第一个办法就是增大每一块的大小（所以才会有一块甚至到2mb，有的小程序都没这么大）。第二个办法是全相连。全相连可以极大降低冲突不命中概率。第三个是使用复杂的块替换策略，这和缓存不同，因为缓存和内存之间速度也就十倍差距，所以块替换策略越简单越好，但是内存与磁盘间不命中惩罚太大，大到情愿花一些时间来找那个最不可能被替换掉。最后是使用回写策略。 <a href="https://xinhecuican.github.io/post/7d1c86da.html">缓存</a></p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>页表是存放于物理内存中的，页表中中的内容代表虚拟内存中这片地址是否被使用，如果被使用，还要存放实际的物理地址。</p><p>页表的大小是由虚拟内存大小和页大小决定的。假设虚拟内存大小矢2的n次方，页大小矢2的p次方，那么页表就有2的n-p次方条。这实际上是一种以空间换时间的策略。每个进程都有一个页表。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt></p><p>上图中左边就是页表，右下角代表磁盘。页表中灰色代表未缓存，未缓存的地址就指向磁盘。而白色代表未分配，地址直接是NULL。如果我们访问0，因为0是未缓存并且内存已满，所以要替换一块下来，假设替换第四块，那么就要把页表中三的地址给改为内存中的物理地址并且把4的地址改为磁盘中的地址。</p><p>所以当我们访问内存时，如果访问到未加载的地址，那么会触发<a href="https://xinhecuican.github.io/post/28877bf.html#more">故障异常</a>,故障异常就会把磁盘中的内存加载进来并且重新执行这条指令。</p><p>如果我们加载到页表地址是NULL的地方，那么就会抛出segmentation fault。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.PNG" alt></p><p>通过页表，我们可以让物理内存彼此分离。并且还可以让两个进程数据共享，这也使动态库可能实现。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.PNG" alt></p><p>虚拟内存还提供了安全保护机制</p><p>这个是比较完整的页表，其中多了一些权限位。后面三个是读写和执行标志位，如果读的时候没有权限，那么就会抛出保护异常，这种异常一般都会终止程序。</p><p>第一个是模式标志位。有些操作系统专有的指令用户不能执行，有些专用寄存器用户不能访问。例如关机的指令即使用户特意编写也不会执行，因为它没有权限。</p><p>操作系统下的内存空间普通用户是没有办法去访问的。如果想调用操作系统的函数，可以使用陷阱异常，产生陷阱异常时，会转到特权模式。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>首先虚拟地址的低p位是页内偏移，因为虚拟内存页的大小和实际内存页的大小相同，所以二者偏移量相同。虚拟地址高n-p位是页号。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%984.PNG" alt></p><p>这张图表示了大致过程。cpu发出虚拟地址，mmu把地址解析成两部分。然后从内存中取出对应页号的地址（cpu中有页的基地址寄存器，页地址是根据页号*每页的大小+基地址得出）。然后mmu又根据取回来的页决定是否要去取内容。如果取，那么这个页中包含了物理页号，然后根据物理页号和偏移量得出实际地址。</p><p>如果标志位是0，那么还要到磁盘中去取出对应页放到内存中并且更新页表。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%985.PNG" alt></p><p>虚拟内存最大的问题就是显著增加了访问时间，本来只要访问一遍的现在要访问两遍。所以在mmu中又加了tlb寄存器专门用来存放页表。现在访问页表不用找内存了，直接找这个寄存器就可以了。如果没有找到再去内存中找并且更新tlb。</p><p>但是现代cpu都是多进程的。每个进程都有自己独立的页表，即使对应的内存相同可能标志位不同，也就是说每次更换进程都要把tlb清空一遍。一种解决办法是传给tlb页号的同时也传递一个进程信息，tlb也储存一个进程信息。</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>假设虚拟内存大小是2的48次方，每页大小矢4kb，每个页表项8字节，那么页表大小矢2的39次方也就是512G。这在现实中显然是不可能实现的，所以要想办法把页表压缩。</p><p>我们很容易想到的一个办法是那些未分配的虚拟内存就不要建立页表项了，但是这样会带来一个问题。原来我们在查找页表的时候都是直接寻址，这是因为假设页表中每一项都存在，现在我们有一些项缺失了，直接根据页号查表的方法也就不行了，只有一个个比对，这样有增大了时间消耗。</p><p>我们可以建立一个多级页表，外层页表每一个页表项缓存的比较大，例如2mb甚至4Gb等，然后这一项中的内容不是物理页号，而是下一级页表的地址，之后下一级页表比上一级小，到最后一级就存储物理页号。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.jpg" alt></p><p>如上图，最外面一层就占着最高位，然后依次递减。这是因为一旦最外层选中了就说明最高几位是那几号，那么就不用管了。</p><p>这样看起来好像是用空间并没有减少，因为到最后一层还是要建立，并且中间几层还要额外消耗空间。实际上如果某个缓存块是未分配的，那么就不会建立下一级页表了。而外面几层页表锁包含的比较大，这样一下就可以排除几百个G的未分配空间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先补充一下前面tlb结构。tlb也是一个缓存并且是组相联结构，这就代表着传递信息中必须要包含组号，然后剩余的是标志位。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.jpg" alt></p><p>上图中tlbi就是组号，前面的是标志位。mmu传给tlb的只有vpn。</p><p>先是cpu发出虚拟内存地址，然后mmu开始解析，解析处vpn传给tlb，如果tlb解析成功那么再传给mmu物理页号并与vpo合成成物理地址。之后在把物理地址发给缓存。按缓存的方式处理。</p><p>如果tlb未命中，那么会到内存系统（包括缓存）中用页表基地址寄存器（CR3）找到最外层的页表然后一层层解析找到物理页号，然后把页号发给mmu的同时缓存那一片区域给tlb。</p><p>如果内存系统中也没有命中（未缓存或者未分配），那么就出触发缺页异常，通过缺页异常判断是未分配还是未缓存还是其他情况。</p><p>缺页异常时判断与一个链表有关。我们知道虚拟内存时分为若干个段的，每个段都有起始地址和终止地址还有一些权限标志位，这个链表就是存放这些信息。当2发生缺页异常时，会判断这个地址是否是在这些段中，如果不在，那么直接抛出Segmentation Fault。如果在那么判断标志位，如果判断不成功会抛出保护异常，如果判断成功了然后再去磁盘中取数据。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 14:30:29 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;p&gt;我们在生成程序的
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="http://xinhecuican.github.io/post/28877bf.html"/>
    <id>http://xinhecuican.github.io/post/28877bf.html</id>
    <published>2020-05-11T23:44:00.000Z</published>
    <updated>2020-05-24T10:52:12.473Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 25 2020 13:31:40 GMT+0800 (中国标准时间) --><h3 id="产生过程"><a href="#产生过程" class="headerlink" title="产生过程"></a>产生过程</h3><p>当程序运行时，可能会产生异常，当cpu检测到这些时间发生时，就会通过异常表跳转到异常处理程序，然后进行处理。</p><p>异常表示常驻于内存中的，每个异常都有一个异常号，事件发送的是异常号，之后根据异常号找到异常表中的对应项再跳转过去。异常表的首地址存放在一个特殊的寄存器中。</p><p>当一场处理结束之后，可能会跳转到下一条语句，可能跳转到当前语句，也可能终止程序。</p><p>要注意，这里讲的异常是系统提供的异常，要把用户程序中设定的异常区分开。</p><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是用来和外部设备进行交互的，例如网卡，usb和磁盘。</p><p>每当这些设备有操作完成时，都会发给cpu一个信号叫cpu去取数据（cpu上有一个特殊的引脚专门去接受这些数据）。之后cpu就会执行中断程序然后去取数据。</p><p>一个显著的例子就是scanf，cpu不可能一到scanf就停止运行，肯定还要继续做各种各样的事。他只是调用了scanf函数给标准输入发出信号，有数据来了就告诉我。之后标准输入输入完成之后并不是直接存到内存中，而是先存到一个缓存中（例如键盘有usb缓存），然后告诉cpu要读数据，cpu才会执行中断去读数据。</p><p>执行中断程序之前，首先要把所有寄存器的值都保护好，之后才去执行。</p><h4 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h4><p>陷阱又叫系统调用。它是一种故意的中断，是执行一条指令的结果。执行完后回到下一条指令。</p><p>这是用户向系统请求服务，例如读文件，打开文件，创建文件，终止进程等。</p><p>系统提供了syscall n 指令专门用来调用这些功能。当这条指令执行时，会中断当前线程然后跳到内核中执行相应的代码，执行完成之后又会返回。</p><h4 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h4><p>故障是有可能修复的异常，这种异常执行完成之后会跳转到当前语句再执行一次。</p><p>一种典型的故障是缺页异常，缺页异常是虚拟内存的东西（现在还没学，就不瞎比比了）。</p><h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>终止是不可恢复的错误，通常是硬件错误，例如突然缺少什么信息等等。一般这种异常都会直接调用abort终止程序。</p><p><img src="/images/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon May 25 2020 13:31:40 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;产生过程&quot;&gt;&lt;a href=&quot;#产生过程&quot; class=&quot;headerlink&quot; title=&quot;产生过程&quot;&gt;&lt;/a&gt;产生过程&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>查找</title>
    <link href="http://xinhecuican.github.io/post/33cb1151.html"/>
    <id>http://xinhecuican.github.io/post/33cb1151.html</id>
    <published>2020-05-10T07:00:00.000Z</published>
    <updated>2020-05-18T06:08:10.150Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --><h3 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>就是一个个找，过程不必多少。</p><p>如果查找每个元素概率相等，那么查找第n个元素只需要一次，第n-1需要两次…。所以平均查找次数是 1+2+…+n / n = （n+1)/2</p><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>其实就是二分查找,<a href="https://xinhecuican.github.io/post/41829.html">代码</a></p><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>分块查找就是每个找出每个块中最大的元素然后单独建一个表，之后就可以先查找这个表然后根据表来查找。大致意思就是这样，<a href="https://blog.csdn.net/To_Be_IT_1/article/details/25333253" target="_blank" rel="external nofollow noopener noreferrer">具体代码</a></p><h3 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h3><h4 id="二叉排序树（查找树）"><a href="#二叉排序树（查找树）" class="headerlink" title="二叉排序树（查找树）"></a>二叉排序树（查找树）</h4><p>二叉查找树特点是左儿子都比父亲小，右儿子都比父亲大。</p><p><img src="/images/%E6%9F%A5%E6%89%BE.PNG" alt></p><p>上面就不是二叉排序树，因为66比50还要大。</p><p>用链表进行存储。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    node</span> *lchild;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*rchild</span>;</span><br><span class="line">    int val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>二叉树的查找算法：</p><ol><li>如果二叉树是空，那么直接返回</li><li>如果该节点的val正好是要查找的数，则查找成功</li><li>如果大，那么去右边找</li><li>如果小，去坐标找</li></ol><p><strong>插入</strong></p><p>先要进行查找，如果查找不成功才会插入。</p><p>插入过程最好单独写一个函数，因为使用递归。如果要插入的点比当前点大，那么就去右边，反之就去左边。知道这个点是空为止，把要插入的点插入到这个空的点中。</p><p><strong>删除</strong></p><p>如果要删除的点是叶结点，那么直接把这个点变成空（因为父亲节点的儿子指针就指向这个节点，现在把这个节点变成空，那么儿子指针就指向空）</p><p>如果要删除的节点只有左子树或者右子树，那么让父亲对应指针指向那个子树就可以了。所以最好把父亲节点也用一个变量存储。</p><p>如果要删除的节点左右子树都有，就用它的前驱替代，然后删除前驱。</p><p><img src="/images/%E6%9F%A5%E6%89%BE2.PNG" alt></p><p>左边是删除前，右边是删除后。</p><p><img src="/images/%E6%9F%A5%E6%89%BE3.PNG" alt></p><p>前面一段代码是找前驱，前驱是s，而q是s的父亲，如果p==q说明p的左孩子就是s并且没有没有其他分支</p><p>效率 2logn</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树的特点是左右子树深度之差小于等于1.</p><p><strong>构造方法</strong></p><p>加入一个代表深度差的标记bf，如果左边比右边深为正，右边比左边深为负。例如：</p><p><img src="/images/%E6%9F%A5%E6%89%BE4.PNG" alt></p><p>上面的数字就是bf值。这个例子中是失去平衡的右子树的右子树导致的，也就是右右，可以向左旋转。让5做8的左节点，8连接根节点，19连接右节点。</p><p>如果是左左，那么向右旋转。</p><p>如果是左右，那么先左旋再右旋。</p><p>如果是右左，那么先右旋再左旋。</p><p>那么现在就知道如果不平衡应该怎么做了。但是插入时怎么判断平不平衡呢？</p><p>如果是空树，那么把这个点做根节点。</p><p>否则就按照二叉排序树的方法进行插入，插入完成之后又从底部递归。如果最终插入到右边就让父亲-1，如果插入到左边就让父亲加一。如果父亲&gt;=2就找左儿子，如果左儿子是1那么就是左左的情况，那么右旋，反之先左旋再右旋。如果&lt;=-2也是同样的方法。</p><p><img src="/images/%E6%9F%A5%E6%89%BE5.PNG" alt></p><p><img src="/images/%E6%9F%A5%E6%89%BE6.PNG" alt></p><p>注意，左旋和右旋是以根节点为基准的。在左左或右右的情况中，根节点是最上面那个点p，右旋就是把p和lc互换。但是在左右和右左的情况中不是这样。</p><p>如果是左右的情况，先以第二层的点作为根，右旋就是第二层的点和第三层的点换一下位置，顺便把原来第三层的左儿子挂到原来第二层的右儿子上（因为原来第三层的点变成第二层，右儿子没有了）。</p><p><img src="/images/%E6%9F%A5%E6%89%BE7.PNG" alt></p><p>最后除此之外还要注意左右或右左的情况中旋转之后的bf值会不同。</p><p><img src="/images/%E6%9F%A5%E6%89%BE8.PNG" alt><br><img src="/images/%E6%9F%A5%E6%89%BE9.PNG" alt><br><img src="/images/%E6%9F%A5%E6%89%BE10.PNG" alt></p><p>可以通过c点来区分</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>一种多路平衡查找树</p><p>每个节点至多m个儿子，如果根节点不是叶子节点，那么<strong>最少2棵</strong>子树。根节点之外的非叶子节点都<strong>至少有 m/2</strong>个子树。</p><p>非终端节点包含n, A0, k1, A1, k1, A2…其中k是关键字，且k&lt;k+1.n是关键字的数目</p><p>所有叶子节点都在同一层次且是空指针。</p><p><img src="/images/%E6%9F%A5%E6%89%BE11.PNG" alt></p><p>从上图中可以看出，对于每一个节点还是符合左边小右边大的规律的。</p><p>结构：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> keynum;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*parent</span>;</span><br><span class="line">    int key[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*p</span>[m+<span class="number">1</span>];</span><br><span class="line">    int *record[m+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">struct result</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*pt</span>;</span><br><span class="line">    int i;//节点中关键字序号</span><br><span class="line">    int success;//是否找到</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>查找</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="NIX"><figure class="iseeu highlight /nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">result search(node *head, int key)</span><br><span class="line">&#123;</span><br><span class="line">    node *<span class="attr">p</span> = head;</span><br><span class="line">    mode *q;</span><br><span class="line">    int <span class="attr">found</span> = <span class="number">0</span>;</span><br><span class="line">    while(p &amp;&amp; !found)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">n</span> = p-&gt;keynum;</span><br><span class="line">        int <span class="attr">i</span> = search(p, key);//这个函数是找第一个大于等于key的</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; p-&gt;key[i] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">found</span> = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">q</span> = p;</span><br><span class="line">            <span class="attr">p</span> = p-&gt;p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(found != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result a.<span class="attr">pt</span> = p;</span><br><span class="line">        a.<span class="attr">i</span> = i;</span><br><span class="line">        a.<span class="attr">success</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result a.<span class="attr">pt</span> = q;//因为没找到最后一定会到<span class="literal">null</span>，所以返回它父亲</span><br><span class="line">        a.<span class="attr">i</span> = i;</span><br><span class="line">        a.<span class="attr">success</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>插入</strong></p><p>节点插入首先是查找，前面查找的时候已经返回了他应该在的位置。但是如果插入后超过了上限那么还要把中间节点提到上面去（主要讲三叉）。同时让左右两边的做往上提节点的左右两边。</p><p><img src="/images/%E6%9F%A5%E6%89%BE12.PNG" alt><br>上面是插入85</p><p>算法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void insert(node *head, int key, node *<span class="built_in">in</span>, int position)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//in是要插入的节点，例如上面就是g节点</span></span><br><span class="line">    <span class="comment">//position是插入位置，也可以先用一次查找</span></span><br><span class="line">    int x = key；</span><br><span class="line">    node *ap = NULL;</span><br><span class="line">    int finish = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &amp;&amp; !finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(int k=position; k&lt;<span class="built_in">in</span>-&gt;</span>keynum-<span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">in</span>-&gt;</span><span class="function"><span class="title">key</span>[k+1] = <span class="built_in">in</span>-&gt;</span>key[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">for</span>(int i=position+1; i&lt;<span class="built_in">in</span>-&gt;</span>keynum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">in</span>-&gt;</span><span class="function"><span class="title">p</span>[i+1] = <span class="built_in">in</span>-&gt;</span>p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">in</span>-&gt;</span>key[position] = x;</span><br><span class="line">        <span class="function"><span class="title">in</span>-&gt;</span>keynum++;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="built_in">in</span>-&gt;</span>keynum &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            finish = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要把数往上提</span></span><br><span class="line">            int temp = (m%<span class="number">2</span>==<span class="number">0</span>) ? m/<span class="number">2</span> : m/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="title">x</span> = <span class="built_in">in</span>-&gt;</span>key[temp];</span><br><span class="line">            <span class="comment">//分裂</span></span><br><span class="line">            <span class="function"><span class="title">ap</span> = <span class="built_in">in</span>-&gt;</span>parent;</span><br><span class="line">            <span class="function"><span class="title">for</span>(int i=0; i&lt;ap-&gt;</span>keynum-<span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span>(ap-&gt;</span>key[i] &lt; x)</span><br><span class="line">                &#123;</span><br><span class="line">                    position = x;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//search</span></span><br><span class="line">            <span class="function"><span class="title">for</span>(int i=position+1; i&lt;ap-&gt;</span>keynum; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">ap</span>-&gt;</span><span class="function"><span class="title">p</span>[i+1] = ap-&gt;</span>p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            node *left = new node;<span class="comment">//拆分后左边节点</span></span><br><span class="line">            node *right = new node;<span class="comment">//拆封后右边节点</span></span><br><span class="line">            <span class="comment">//拆分具体过程就不写了，一系列的赋值</span></span><br><span class="line">            <span class="function"><span class="title">ap</span>-&gt;</span>p[position] = left;</span><br><span class="line">            <span class="function"><span class="title">ap</span>-&gt;</span>p[position+<span class="number">1</span>] = right;</span><br><span class="line">            <span class="built_in">in</span> = ap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">head</span>-&gt;</span>keynum++;</span><br><span class="line">        <span class="function"><span class="title">head</span>-&gt;</span>key[<span class="number">0</span>] = key;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这是自己写的并且没有验证，只有借鉴作用</span><br></pre></td></tr></table></figure></div><p><strong>删除</strong></p><ul><li>如果删除这个值后节点的key数大于 m/2-1（此时分支数是m/2)。那么只需要删除对应部分，其他不变。</li><li>如果删除节点后key=m/2-1<ol><li>如果它父亲左边或者右边Key数大于m/2-1，那么先把左边最大（右边最小）提到上面，再把那个值放下来<img src="/images/%E6%9F%A5%E6%89%BE13.PNG" alt></li><li>如果左右两边正好都等于m/2-1，那么把左边右边合并并且把这个值也放下来<img src="/images/%E6%9F%A5%E6%89%BE14.PNG" alt></li><li>不会有小于m/2-1的了，不符合定义</li></ol></li><li>如果删除后<strong>双亲</strong>key值小于m/2-1,层层向上合并（不清楚具体过程）</li></ul><p><strong>B+树</strong></p><p>b+树key和q一样多，并且子节点中包含父节点中的信息。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>基本思想：建立要存的数和存的位置之间的映射关系（最理想的情况是一一映射），此后在查找元素时，只需要用hash函数就可以找到再表中的位置。</p><p>哈希函数就是将值转化成存的位置的函数。</p><p>举个例子： 比如哈希函数是 x%10-1,那么可以输入x就可以得到元素在表中的位置。</p><p>但是这里有个问题，例如11的哈希值和1的哈希值相同，那么存的位置也相同，这显然是不允许的，这叫做哈希冲突。判断哈希函数优劣就是哈希冲突越少越好。</p><p><a href="https://xinhecuican.github.io/post/11491.html">字符串哈希</a></p><h5 id="直接定值法"><a href="#直接定值法" class="headerlink" title="直接定值法"></a>直接定值法</h5><p>hash(key) = key 或 hash(key) = a * key + b</p><p>这种方法仅适合哈希表和取值范围一样大的情况（如果取值到十亿我就呵呵）</p><h5 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h5><p>这是利用所选数字中的一些规律来的。例如某一串数字最高若干位都相同，只有一两位不同，那么我们就可以只取一两位</p><h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><p>就是先把数字平方然后再取中间几位，它的目的是扩大差别从而缩小冲突几率。适用于每一位都有高概率的重复数字。</p><h5 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h5><p>将关键字分成若干块然后叠加。可以直接分成若干块叠加。也可以正的加一块然后把数倒过来加一块，这种方法使用于位数多的情况。</p><h5 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h5><p>hash(key) = key % p;//p是不大于表长且不大于最大值的素数</p><h5 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h5><p>hash(key) = random(key);//这是伪随机数</p><h5 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h5><p><strong>开放地址法</strong></p><p>把冲突的地址求一个地址序列：h0,h1…</p><p>h(i) = (h(key) + d(i) ) mod m // m是表长</p><p>d(i) = c + i c可以随便取</p><p>或d(i) = (-1)^(i-1) * (i/2)^2 //这里的i/2是向上取整也就是1/2=1</p><p>或d(i)=random(i)//伪随机数</p><p>或d(i) = i*h2(key)</p><p>注意，这里的d(i)要保证完备性，也就是要保证s(m-1)个h(i)均不相同并且要覆盖到所有地址。那么就要求</p><ol><li>表长要是 4*k+3</li><li>m与d(i)没有公因子</li></ol><p><strong>链地址法</strong></p><p>把哈希值相同的记录在一个链表里。其实就是构建一个链表，如果不冲突就只有一个值，冲突就往后面加。</p><p><strong>再哈希法</strong></p><p>发生冲突时，选用另外一个哈希函数，直到不冲突。</p><p><strong>建立公共溢出区</strong></p><p>一旦发生冲突，就把有冲突的数据都填充到溢出表。</p><h5 id="哈希表查找"><a href="#哈希表查找" class="headerlink" title="哈希表查找"></a>哈希表查找</h5><p>就是先计算处hash(key)，如果找到直接填充，如果发现冲突就在通过冲突处理方法进行查找</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;静态查找&quot;&gt;&lt;a href=&quot;#静态查找&quot; class=&quot;headerlink&quot; title=&quot;静态查找&quot;&gt;&lt;/a&gt;静态查找&lt;/h3&gt;&lt;h4
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>java 多线程</title>
    <link href="http://xinhecuican.github.io/post/f8648a1d.html"/>
    <id>http://xinhecuican.github.io/post/f8648a1d.html</id>
    <published>2020-05-04T11:40:00.000Z</published>
    <updated>2020-05-14T11:56:46.436Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 15 2020 17:23:19 GMT+0800 (中国标准时间) --><h3 id="java线程运行机制"><a href="#java线程运行机制" class="headerlink" title="java线程运行机制"></a>java线程运行机制</h3><p>java虚拟机中，执行程序是由线程完成的，每个线程都有独立的程序计数器（PC或rip<br>)和栈</p><p>栈中有三个区，局部变量区，操作数栈和栈数据区。</p><p>操作数栈是线程的工作区，用来存放运算过程产生的临时变量（怎么有种寄存器的感觉）。</p><p>栈数据区为线程执行指令提供相关信息，例如定位到堆区和方法区的特定数据（类成员变量），正常退出方法等（存放地址信息）。</p><p>每次java虚拟机启动一个虚拟机进程时，虚拟机都会创建一个主线程。该线程从main开始执行。</p><p>例如在一个类中定义了一个实例变量a,然后再main函数中调用了这个类的成员函数A()，这个函数会让成员变量加一。首先进入这个方法，然后发现a++;就去栈数据区取出a的地址，之后定位到堆区取出a进行操作。</p><ul><li>方法区存放了字节码</li><li>堆区存放了线程所需要长时间保存的数据（类）</li><li>栈区存放了临时数据，栈帧和跳转到其他区域地址。</li></ul><h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>我们现在免费有了一个主线程，如果我们还想要创建其他线程的话，有两种方式。</p><ul><li>扩展java.lang.Thread类</li><li>实现Runnable接口</li></ul><p>要注意一点，创建了线程并启动之后会有自己的栈区，堆区，方法区，也就是说可以把它看成一个新的程序，里面的变量都是最原始的，不要认为主线程中操作的变量还有用。但是有些时候也可以使用主线程的对象</p><p><strong>一个线程只可以被启动一次</strong>。</p><h4 id="扩展java-lang-Thread类"><a href="#扩展java-lang-Thread类" class="headerlink" title="扩展java.lang.Thread类"></a>扩展java.lang.Thread类</h4><p>thread是线程，它的最主要的两个方法是：</p><ul><li>run(): 包含线程运行时执行的代码（相当于main方法）</li><li>start()： 用于启动线程，不需要覆盖</li></ul><p>start方法用来确定什么时候开始执行，可以在别的main函数中执行，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Machine</span> <span class="symbol">extends</span> <span class="symbol">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">50</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Machine machine = new Machine();</span><br><span class="line">        machine.start(); <span class="comment">//启动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>注意</strong>，调用了start并不是指立刻执行这个线程，而是让这个线程进入就绪状态，如果想让这个线程执行可以使用yield。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>java不允许一个类继承多个类，所以一旦继承了Thread类，那么就不能继承其他类。所以说接口这时就体现出优越性了。定义如下：</p><p><code>public void run();</code></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    [</span></span><br><span class="line"><span class="function">        Machine machine </span>= <span class="keyword">new</span> Machine();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> thread(machine);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Thread构造方法中有Runnable接口的，这个时候Thread就掌管了run方法，只要使用start就可以启动。</p><h4 id="主线程和用户自定义线程并发运行"><a href="#主线程和用户自定义线程并发运行" class="headerlink" title="主线程和用户自定义线程并发运行"></a>主线程和用户自定义线程并发运行</h4><p>并发运行指的是一个线程没有结束另一个线程开始执行，上面举的例子都是并发运行。</p><p>Thread中的currentThread()静态方法返回当前线程的引用，getname()返回当前线程的名字，main方法名字是main，用户创建的线程根据顺序从Thread-0，Thread-1一直往后排，可以用setName()设置名字。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line">相当于</span><br><span class="line">Thread thread = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">String name = thread.get<span class="constructor">Name()</span>;</span><br></pre></td></tr></table></figure></div><p>为了让每个线程轮流获得cpu，可以使用sleep(time)放弃cpu并睡眠若干时间。</p><h4 id="多个线程共享一个对象的实例变量"><a href="#多个线程共享一个对象的实例变量" class="headerlink" title="多个线程共享一个对象的实例变量"></a>多个线程共享一个对象的实例变量</h4><p>例：</p><ul><li>方法内部局部变量不共享</li></ul><p>这是因为这些数据都是动态在栈中分配的，每个线程都有自己的堆栈。</p><ul><li>成员变量，如果是指向同一个对象就共享</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Analy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Num i=<span class="keyword">new</span> Num(<span class="number">0</span>);    <span class="comment">//新建对象，准备传递给线程</span></span><br><span class="line">        <span class="keyword">new</span> OwnThread(i).start();    <span class="comment">//新建线程，并启动</span></span><br><span class="line">        <span class="keyword">new</span> OwnThread(i).start();    <span class="comment">//新建线程，并启动</span></span><br><span class="line">        System.out.println(<span class="string">"主线程中i的值变为了："</span>+i.i);    <span class="comment">//获取目前对象i的数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OwnThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Num id;    <span class="comment">//申明对象，默认null，就是没有指向任何实体</span></span><br><span class="line">    <span class="keyword">int</span> sno;    <span class="comment">//申明int变量。因为系统默认初始化为0，所以应该是定义一个int变量</span></span><br><span class="line">    OwnThread(Num id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sno=id.i;    <span class="comment">//保存id.i的数值，到线程私有变量sno</span></span><br><span class="line">                id.i++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">","</span>+sno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span>    //定义一个类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Num(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序中主函数定义了Num对象的实例i，定义线程是传递到了Thread0和Thread1这样三个变量就共享了一个Num对象的实例。而线程Thread0和线程Thread1又有自己的私有变量sno，可以用来保存某一时刻的共享变量的数值。</p><p>(1)Java中判断对象是否为同一个对象使用地址判断的。地址相同就是同一个对象，上面的三个就是同一个对象。</p><p>(2)如果把上面的例子中共享的对象实例用基本数据类型替换是不行的。因为基本数据类型程序会自动的用默认值初始化，也就是申明和定义时一起的。此时在main函数中定义线程，传递的基本数据类型参数，只能是初始化线程中的另一个对象，而不是同一个对象。</p><p>也就是说，只有类才可以共享，并且用同一个实例启动多个线程的时候这个实例是共享的，并且也只有这个实例时共享的，如果在线程中创建的新实例也不是共享的。</p><p><a href="https://www.cnblogs.com/xudong-bupt/archive/2013/05/22/3087864.html" target="_blank" rel="external nofollow noopener noreferrer">这里来自这篇博客</a></p><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><p><strong>新建状态</strong></p><p>也就是只有new没有start状态。</p><p><strong>就绪状态</strong></p><p>调用了start方法后，就进入了就绪状态。虚拟机会为他创建栈和rip，这个线程在运行池中等待cpu使用权。</p><p><strong>运行状态</strong></p><p>就是得到了cpu使用权，如果是多个cpu，那么可以同时运行多个线程。</p><p><strong>阻塞状态</strong></p><p>阻塞状态优先级比就绪状态低，阻塞状态过去后首先进入就绪状态然后进入运行状态。</p><ul><li><p>如果调用了某个对象的wait()方法，那么会进入这个对象等待池中。</p></li><li><p>如果试图获得某个对象的同步锁（后面说）但是被其他线程使用时，会把这个线程放到这个对象的锁池中。</p></li><li><p>调用sleep。</p></li><li><p><em>死亡状态*</em></p><p>当退出了run后，进入死亡状态。前面已经提到过一个线程不能呗start两次。可以用Thread的isAlive()方法判断这个线程是否活着。如果处于新建状态时，也是false。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3></li></ul><p>线程调度就是确定cpu的使用权在那个线程手上，cpu通常只有一个。有两种调度模型：分时调度和抢占型调度。</p><p>分时型调度就是让每个线程都执行一定时间。</p><p>抢占型是java虚拟机采用的方式。它是将所有线程规定一个优先级，优先让优先级高的线程运行，如果优先级都相同，那么随机选取一个线程。一旦抢到cpu，那么它将会一直运行直到被迫停止运行。</p><p>被迫停止运行的可能：</p><ul><li>虚拟机让当前线程放弃cpu。</li><li>当前线程进入阻塞状态</li><li>线程运行结束</li></ul><p>不同操作系统对抢占型的实现不同，有的是会一直让这个线程运行，有的是一段时间后停止运行。</p><h4 id="调整优先级"><a href="#调整优先级" class="headerlink" title="调整优先级"></a>调整优先级</h4><p>可以使用Thread的setPriority(int)和getPriority()设置优先级，可以使用currentThread().setPriority(?)设置等级。</p><p>三个静态常量：</p><ul><li>MAX_PRIORITY 10级，最高等级</li><li>MIN_PRIORITY 1,最低等级</li><li>NORM_PRIORITY 5, 默认等级</li></ul><p>如果将主线程优先级更改然后再创建其他线程，那么其他线程优先级也会更改。被创建者的默认优先级和创建者优先级保持相同。</p><p>注意，上面三个静态常量在不同操作系统中是不同的，例如windows只有七个优先级，所以最好只使用上面三种优先级。</p><h4 id="Thread-sleep-线程睡眠"><a href="#Thread-sleep-线程睡眠" class="headerlink" title="Thread.sleep()线程睡眠"></a>Thread.sleep()线程睡眠</h4><p>如果使用sleep方法，那么他会放弃cpu进入阻塞状态。sleep后面的数据是以毫秒做单位。完成之后也不是立刻重新开始执行，而是先进入就绪状态，如果没人和它抢cpu就开始执行。</p><p>例如： sleep(100);表示阻塞100毫秒</p><p>可以使用sleep让两个线程比较同步的执行。例如每个线程都会调用sleep(100)，那么第一个线程调用睡眠后第二个线程开始执行，如果执行时间小于100ms那么第二个线程执行完后第一个线程仍在睡眠，如果大于100ms第一个线程会立刻开始执行。因为它已经睡了100ms进入就绪状态了（同样也是只有两个线程的情况）。</p><p>可以使用sleep.interrupt()中断睡眠</p><p>如果线程在睡眠时被中断，那么就会抛出InterruptedException，程序跳到异常处理代码块。</p><h4 id="Thread-yield-线程让步"><a href="#Thread-yield-线程让步" class="headerlink" title="Thread.yield()线程让步"></a>Thread.yield()线程让步</h4><p>执行yield后，如果有相同或者更高优先级的线程在就绪状态，那么将会把当前线程放入运行池中并让优先级高的线程执行。</p><h4 id="join-等待其他线程结束"><a href="#join-等待其他线程结束" class="headerlink" title="join()等待其他线程结束"></a>join()等待其他线程结束</h4><p>当前线程可以调用另一个线程的join()方法，直到另一个线程结束这个线程才会又开始执行（进入就绪状态）。</p><p>如果加了参数，那么类似于sleep()将会休眠若干时间，不同的是join是给指定的线程执行。</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>例如垃圾回收线程，只有当前台所有线程都停止之后，后台线程才会结束生命周期。</p><p>主线程默认是前台线程，前台线程创建的线程默认也是前台线程。</p><p>可以调用Thread的setDaemon(true)方法，把线程设置成后台线程。可以用isDaemon()判断是否是后台线程。</p><p>只有在线程启动前（使用start())之前才可以设置成后台。并且后台创建的线程还是后台线程。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>java.util包中提供了定时器Timer，TimerTask类表示定时器执行的一项任务。例；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> usetimer;</span><br><span class="line">improt java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.start();<span class="comment">//想自定义start必须要先用父类的start</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(ture);<span class="comment">//把Timer关联的线程设为后台线程</span></span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;<span class="comment">//匿名类，便于设置定时任务</span></span><br><span class="line">        timer.schedule(task, <span class="number">10</span>, <span class="number">50</span>);<span class="comment">//设置定时任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">":"</span>+a++);</span><br><span class="line">        &#125;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>TimerTask类是一个抽象类，它实现了RUnnable接口。start()中匿名类继承了TimerTask类。</p><p>TImer(boolean isDaemon)可以把相关联的线程设置成后台线程。如果是true就是后台</p><p>schedule(TimerTask task, long delay, long period)用来设置定时任务。所以前面的匿名类就是用来启动定时任务的。delay是推迟多少毫秒之后执行，period是每次执行任务的间隔。其中delay只在第一次运行时有效。</p><p>还可以不要period参数，表示只执行一次。例如,timer.schedule(task, 10);</p><p>同一个定时器可以执行多个任务。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>有时候线程的抢占可能导致问题。例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//共享</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a+=i;</span><br><span class="line">            Thread.<span class="built_in">yield</span>();<span class="comment">//让给其他线程执行</span></span><br><span class="line">            a-=i;</span><br><span class="line">            System.out.<span class="built_in">println</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Mahcine();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(machine);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(machine);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个程序本来是要一直输出零的，但是因为让给了t2执行，所以会输出1 2 2 3 …。这样就和原来的逻辑不符。</p><p>逻辑紧密相关的一组操作叫做原子操作，为了防止原子操作被打断，就提出了线程同步思想。</p><h4 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h4><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">String</span> goods = <span class="built_in">buffer</span>[<span class="built_in">point</span>];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样就设置了this对象的锁。</p><ul><li>如果这个锁被其他线程占用，那么就会把该线程加入锁池中，进入阻塞状态</li><li>如果没有线程占用，那么他就会占用并执行代码块。</li></ul><p>也可以这样写；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized <span class="keyword">String</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意，在同步代码块中同样也可以使用sleep和yield，同样也是把cpu给其他线程。只是如果其他线程正好碰到了同步代码块那么又要将控制权归还，</p><p>synchronized不会被继承，也就是说哪怕父类中写了synchronized如果子类没写也不是同步的。</p><p>同步代码块中应包含尽量少的操作，因为操作多了可能一线程要在这里工作很久，其他线程就会都进入锁池中无法工作，这样会给一些需要即时反应的线程带来麻烦</p><h4 id="释放对象的锁"><a href="#释放对象的锁" class="headerlink" title="释放对象的锁"></a>释放对象的锁</h4><p>释放锁的情况：</p><ul><li>执行完同步代码块，会释放锁</li><li>线程异常终止时</li><li>执行了锁所属对象的wait()方法，这个线程会释放锁，并进入等待吃</li></ul><p>但是使用sleep或yield只会放弃cpu，并不会释放锁。还有suspend方法</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁指的是a在等b锁释放，b在等a锁释放，这样就永运无法释放，最为关键的是虚拟机并不会检查这类问题，所以只有程序员自己注意。</p><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>线程通信就是一个线程告诉另外一个线程某个信息，通过配合完成某件事。</p><p>java.lang.Object类中有两个用于线程通信的方法：</p><ul><li>wait() 释放对象的锁，然后把该线程放入等待池中，等待其他线程把它唤醒</li><li>notify() 唤醒在等待池中的线程。随机选取等待池中的线程，并加入锁池中。</li></ul><p>进入等待池后，锁和cpu全部放弃。如果使用notify也只是进入锁池，还要和其他线程争夺锁。</p><p>notifyAll() 唤醒所有在等待池中的线程。</p><p>注意：wait()方法必须放在一个循环中。因为在调用notify后并不是立刻可以得到执行，而是先要获得该对象的锁和cpu执行权限才可以运行。这个时候可能其他线程又将状态改变了，这时又要重新运行。</p><p><strong>要注意的是想要唤醒等待池中的线程首先自己要掌握这个锁</strong>，也就是说必须在同步代码块中写notify，不然会报IllegalMonitorStateException错误。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public synchronized String pop<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    this.notify<span class="constructor">All()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(point<span class="operator"> == </span>-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.ptintln(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">":wait"</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            this.wait<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="params">e</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面例子中，首先point是-1就要让一个线程处理，现在point是-1，然后一个线程调用wait()进入等待池，之后另一个线程操作了这个方法唤醒了该线程，但是这个时候线程并没有执行，而是先让其他的线程执行了一会才开始执行。但是其他线程执行过程中又把point变成-1了，这个时候处理线程已经结束，就会出现问题。</p><p>此外，<strong>wait必须写在synchronized中，不然运行时会报错。</strong></p><h3 id="中断阻塞"><a href="#中断阻塞" class="headerlink" title="中断阻塞"></a>中断阻塞</h3><p>当线程A处于阻塞状态的时候，B调用A的interrupt()方法，那么A会发送一个InterruptedExecption。</p><p>实际上interrupt方法如果处理处于阻塞状态的线程（如wait，sleep，join等）才会抛出异常，实际上它是把一个中断线程的标志位设为true，因为处于阻塞状态，所以抛出异常，仅此而已。决定是否退出线程还是由我们自己决定的，如果我们在catch块中没有退出，那么还是会继续运行。</p><p>如果interrput一个正在处于运行的线程，那么只会把标志位设置成true，不会做其他事。</p><p>可以通过isinterrupt来看标志位是否变成true</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Timer timer = <span class="keyword">new</span> Timer(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread = Thread.currentThread();</span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">publc <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"has waited for 3s"</span>);</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                timer.schedule(timerTask, <span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(InterruptException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(thread.getName);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a++;</span><br><span class="line">            System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段程序作用是如果a&gt;3，那么就把线程放入等待池，如果等待时间超过三秒，那么就抛出InterruptException信号从而中断线程。</p><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><ul><li>start() 启动线程</li><li>suspend() 使线程暂停</li><li>resume() 使暂停的线程恢复运行</li><li>stop() 终止线程</li></ul><p>但是其实后面三种已经被废弃了，但是可以通过编程实现同样的功能</p><h4 id="用编程方式控制线程"><a href="#用编程方式控制线程" class="headerlink" title="用编程方式控制线程"></a>用编程方式控制线程</h4><p>可以设置一个标志变量来表示现在的状态，假设标志变量有三个值。</p><ul><li>SUSP， 暂停状态</li><li>STOP， 终止状态</li><li>RUN， 运行状态</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUSP = <span class="number">1</span>;<span class="comment">//设置静态变量的话所有类都可以看到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUN = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> state = RUN;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">if</span>(state == RUN)</span><br><span class="line">        &#123;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">checkState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(state == SUSP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"wait"</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(state == STOP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过上面的两个方法，就可以对线程进行控制，但注意这种控制不是实时的，也就是说即使执行了setState也不会立刻进入暂停状态，而是machine先获得cpu，开始执行checkState方法时才会进入暂停状态。</p><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>ThreadGroup类表示线程组，他可以对一组线程集中管理。用户创建的线程都属于某个线程组。</p><p>指定线程组： <code>Thread(ThreadGroup group, String name)</code></p><p>如果线程A创建线程B且创建时没有指定线程组，那么会自动加入A的线程组中。一旦线程<strong>加入线程组，就不能退出</strong>。</p><p>用户创建的线程组都有父线程组，默认情况下，如果A创建了一个新线程组，那么A所在的线程组就是父亲线程组。</p><p>指定父亲线程组： <code>ThreadGroup(ThreadGroup parent, String name)</code></p><p>可以使用activeCount()返回当前活着的线程，enumerate(Thread[] tarray)把或者的线程复制到tarray中。</p><h3 id="处理线程未捕获的异常"><a href="#处理线程未捕获的异常" class="headerlink" title="处理线程未捕获的异常"></a>处理线程未捕获的异常</h3><p>如果线程没有捕获异常，那么虚拟机会找UncaughtExceptionHandler实例（这东西是个接口）。并且调用它的uncaughtException(Thread t, Throwable e)方法</p><p>设置异常处理类：</p><p><code>setDefaultUncaughtExcpetionHandler(Thread.UncaughtExceptionHandler eh)</code><br><code>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code></p><p>第一个是设置默认异常处理器（静态方法），第二个是设置当前异常处理器（实例方法）。</p><p>ThreadGroup线程组实现了这个接口。每次出现未捕获异常时，先找当前线程的异常处理器，如果没找到就用线程组的异常处理器。</p><p>并且线程组的异常处理器还不是直接调用。如果这个线程有父线程，那么就调用父线程的。如果没有父线程，那么如果自己实现了这个接口，那么就用。如果没有，那么就打印调用堆栈的异常信息。</p><h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><p>这个类用来存放线程的局部变量。这些局部变量是每个线程独有的，不会共享。</p><p>主要有三个方法：</p><p><code>public T get(): 返回当前线程局部变量 protected T initialValue(): 返回局部变量初始值 public void set(T value): 设置局部变量</code></p><p>其中initialValue()只会在第一次调用get()或set()时才会被使用，并且只会执行一次。</p><h3 id="concurrent并发包"><a href="#concurrent并发包" class="headerlink" title="concurrent并发包"></a>concurrent并发包</h3><p>在编写多线程程序时，既要考虑并发，又要防止死锁，还要考虑性能，难度很大。为了降低难度，增加了java.util.concurrent包。下面是包含的类和接口</p><h4 id="Lock外部锁"><a href="#Lock外部锁" class="headerlink" title="Lock外部锁"></a>Lock外部锁</h4><p>这个主要用于线程同步。这是由类提供的锁，区别于对象的锁（可以叫内部锁）。他有几个方法。</p><ul><li><p>lock() 获得当前线程的锁，如果被占用，那么进入阻塞状态。这和内部锁是一样的</p></li><li><p>tryLock() 试图获得当前线程的锁（看看现在锁是不是有人用），如果被占用，就返回false，否则返回true。</p></li><li><p>tryLock(long time, TimeUnit unit)，如果超过了设置时间没有获得锁，放回false。例如 tryLock(50L, TimeUnit.SECONDS)表示时间限制50s</p></li><li><p>unlock() 释放线程锁占用的锁。</p><p>Lock接口有一个实现类ReentrantLock，构造方法ReentrantLock(boolean fair).fair如果是真，那么会采用公平策略。公平策略是指让阻塞时间长的更有可能获得锁。这是以性能作为代价的。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();<span class="comment">//创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>外部锁可以用来弥补内部所的一些不足，我们可以直接用lock，unlock而不使用synchronized。</p><h4 id="Condition-线程通信接口"><a href="#Condition-线程通信接口" class="headerlink" title="Condition 线程通信接口"></a>Condition 线程通信接口</h4><p>java.lang.concurrent.locks.Conditon用于线程通信。Lock接口的newCondition()方法返回Condition的实例。</p><p>方法：</p></li><li><p>await() 和wait()相似</p></li><li><p>await(long time, TimeUnit unit):和上面类似，如果超过时间线程没有被唤醒，返回false。</p></li><li><p>signal()： 和notify()类似。</p></li><li><p>signalAll()：和notifyAll()类似</p><h4 id="Callable和Feture"><a href="#Callable和Feture" class="headerlink" title="Callable和Feture"></a>Callable和Feture</h4><p>这两个是用来做异步计算的。Runnable接口的返回值是void，如果其他线程需要这个线程的返回值怎么办呢？这个可以通过共享变量来实现，但是共享变量需要共享类，这又可能导致问题。所以这两个接口就是解决这类麻烦。</p><p>Callable接口：和Runnable接口类似，Runnable中的run()相当于Callable中的call()。但是call可以有泛型的返回值。此外，这个不能作为Thread类的参数。</p><p>Future接口： 保存运算结果，以下参数</p></li></ul><ul><li>get()：返回异步运算的结果。如果结果没有出来，当前线程就会被阻塞直到运算结束。</li><li>get(long timeout, TimeUnit unit): 和第一个类似。只是如果超出时间还没有得到结果就会抛出TimeoutException。</li><li>cancel(boolean mayInterrupt): 取消该运算，如果运算没有开始，就立刻取消。如果已经开始，如果mayInterrrupt为true，那么也取消。</li><li>isCancelled()：判断运算时候被取消</li><li>isDone()：判断运算是否已经完成。</li></ul><p>FutureTask：这是一个适配器，同时实现Runnable和Future接口。还关联了一个Callable实例。FutureTask可以作为Thread类的参数。FutureTask类的构造函数可以带Callable的参数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LASSO"><figure class="iseeu highlight /lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Callable myComputation = <span class="literal">new</span> <span class="params">...</span></span><br><span class="line">FutureTask&lt;<span class="built_in">Integer</span>&gt; task = <span class="literal">new</span> FutureTask&lt;<span class="built_in">Integer</span>&gt;(myComputation);<span class="comment">//Integer是返回值</span></span><br></pre></td></tr></table></figure></div><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Machine implements Callable&lt;<span class="type">Integer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">Integer</span> <span class="keyword">call</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            catch(<span class="keyword">Exception</span> e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(Stirng[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FutureTask&lt;<span class="type">Integer</span>&gt; task = <span class="built_in">new</span> FutureTask&lt;<span class="type">Integer</span>&gt;(<span class="built_in">new</span> Machine());</span><br><span class="line">        Thread thread = <span class="built_in">new</span> Thread(task);</span><br><span class="line">        threadMachine.<span class="keyword">start</span>();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("从1到100的和"+task.<span class="keyword">get</span>());//调用<span class="keyword">get</span>返回值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="通过线程池管理多个线程"><a href="#通过线程池管理多个线程" class="headerlink" title="通过线程池管理多个线程"></a>通过线程池管理多个线程</h4><p><img src="/images/java%E7%BA%BF%E7%A8%8B.jpg" alt></p><p>Executor表示线程池，execute方法用来执行command的run()中指定的任务，线程会调度空闲的线程来执行该任务。到底什么时候执行，这是由cpu决定的。</p><ul><li>shutdown(): 预备关闭线程池。如果有任务提交上去，那么要等这些任务执行完后，才会关闭线程池，并且拒绝新任务的入内。</li><li>shutdownNow(): 终止已经开始的任务，立刻关闭线程池</li><li>isTermination(): 判断线程池是否关闭，如果关闭返回true</li><li>awaitTermination(): 等待线程池关闭。</li></ul><p>submit(Callable<t>task)和submit(Runnable task)和execute(Runnable command)类似，但是这个支持异步运算。他们都会返回异步运算结果的Future对象。</t></p><p>Excutors中静态方法：</p><ul><li>newCachedThreadPool(): 创建有缓存的线程池，有任务才创建新线程，空闲的线程停留60s。</li><li>newFixedThreadPool(int nThreads): 创建有固定数目线程的线程池，空闲线程一直保留</li><li>newSingleThreadExecution(): 创建只有一个县城的线程池。这个与newFixedThreadPool(1)不同之处在于这个终止就终止了，Fixed的终止了还会创建一个新的。</li><li>newScheduledThreadPool(int corePoolSize): 线程池会按时间计划创建任务。corePoolsize是线程<strong>最小</strong>数目。</li><li>newSingleThreadScheduledExecutor(): 创建只有一个线程的线程池，这个线程池按计划进行任务。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Machine</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Machine(i));</span><br><span class="line">        &#125;</span><br><span class="line">        service.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里创建了5个线程给线程池，然后线程池中两个空白线程接到任务开始工作，工作完这两个线程后又执行下面两个线程，直到执行完5个线程。然后执行shutdown()关闭线程池。</p><h4 id="BlockingQueue-阻塞队列"><a href="#BlockingQueue-阻塞队列" class="headerlink" title="BlockingQueue 阻塞队列"></a>BlockingQueue 阻塞队列</h4><p>java.util.concurrent.BlockingQueue接口继承了java.util.Queue接口。BlockingQueue接口为多个线程同时操作一个队列提供了方案。</p><table><thead><tr><th>操作</th><th>抛出异常</th><th>放回特定值</th><th>线程阻塞</th><th>超时</th></tr></thead><tbody><tr><td>添加元素</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>删除元素</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>读取元素</td><td>element()</td><td>peek()</td><td>无</td><td>无</td></tr></tbody></table><p>前面两个是队列的，后面两个是阻塞队列的。这个具体等到队列那里再说。这里先把几个BlockingQueue的实现类列一下：</p><ul><li>LinkedBlockingQueue类： 默认情况下，LinkedBlockingQueue的容量是没有上限的，也可以指定大小，这是基于链表的队列</li><li>ArrayBlockingQueue类： ArrayBlockingQueue(int capacity, boolean fair)可以设定容量，并且可以选择是否采用公平策略。这是基于数组的队列。</li><li>PriorityBlockingQueue：这是优先队列（堆）</li><li>DelayQueue: 这个队列中存放的是延期元素。这些元素必须实现java.util.concurrent.Delayed接口。只有延期满的元素才可以被取出或者删除。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri May 15 2020 17:23:19 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;java线程运行机制&quot;&gt;&lt;a href=&quot;#java线程运行机制&quot; class=&quot;headerlink&quot; title=&quot;java线程运行机制
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>c 文件操作</title>
    <link href="http://xinhecuican.github.io/post/e0f8cb74.html"/>
    <id>http://xinhecuican.github.io/post/e0f8cb74.html</id>
    <published>2020-04-29T12:20:00.000Z</published>
    <updated>2020-04-30T00:23:59.687Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>文件总的来说其实就只有两个操作，打开（关闭）和读写。本文也围绕这两个方面展开</p><p><strong>文件格式</strong></p><p>文件一般由三部分组成：路径，文件名，后缀。</p><p>例：<code>&quot;E:\\ch10.doc&quot;或者&quot;E:/ch10.doc&quot;</code></p><p>之所以要两个\是因为在c语言中\作为转义字符。</p><p><strong>流</strong></p><p>流按方向分为：输入流和输出流。从文件获取数据的流称为输入流，向文件输出数据称为输出流。</p><p>例如，从键盘输入数据然后把该数据输出到屏幕上的过程，相当于从一个文件输入流（与键盘相关）中输入（读取）数据，然后通过另外一个文件输出流（与显示器相关）把获取的数据输出（写入）到文件（显示器）上。</p><p><strong>换行符</strong></p><p>在Linux系统中，换行符是0x0a（LF）。因为c是在unix上发展起来的，所以访问Linux文件时，不需要转换，直接可以访问。</p><p>在windows系统中使用0x0d(CR ‘\r’） 和 0x0a(LF ‘\n’)合起来作为换行符。所以把windows下文件给c程序还要先把CR-LF转换成LF</p><p><strong>缓冲文件系统</strong></p><p>缓冲文件系统：系统自动为每个打开的文件在内存开辟一块缓冲区，缓冲区的大小一般由系统决定。当程序向文件中输出（写入）数据时，程序先把数据输出到缓冲区，待缓冲区满或数据输出完成后，再把数据从缓冲区输出到文件；当程序从文件输入(读取)数据时，先把数据输入到缓冲区，待缓冲区满或数据输人完成后，再把数据从缓冲区逐个输入到程序。</p><p>c语言就是用的缓冲文件系统。其实这和vim有点像。</p><p>ANSI C 为正在使用的每个文件分配一个文件信息区，该信息区中包含文件描述信息、 该文件所使用的缓冲区大小及缓冲区位置、该文件当前读写到的位置等基本信息。这些信息保存在一个结构体类型变量中，该结构体类型为 FILE 在 stdio.h 头文件中定义，不允许用户改变。</p><h3 id="文件打开和关闭"><a href="#文件打开和关闭" class="headerlink" title="文件打开和关闭"></a>文件打开和关闭</h3><p>文件指针 file* 用来引用一个文件。</p><p><strong>打开</strong></p><p>原型：<code>FILE * fopen(char *filename, char *mode);</code></p><p>filename指的是文件名，可以包括路径。</p><p>mode是打开方式。下面列举了一些打开方式</p><table><thead><tr><th>模式</th><th>含 义</th><th>说 明</th></tr></thead><tbody><tr><td>r</td><td>只读</td><td>文件必须存在，否则打开失败</td></tr><tr><td>w</td><td>只写</td><td>若文件存在，则清除原文件内容后写入；否则，新建文件后写入</td></tr><tr><td>a</td><td>追加只写</td><td>若文件存在，则位置指针移到文件末尾，在文件尾部追加写人，故该方式不 删除原文件数据；若文件不存在，则打开失败</td></tr><tr><td>r+</td><td>读写</td><td>文件必须存在。在只读 r 的基础上加 ‘+’ 表示增加可写的功能。下同</td></tr><tr><td>w+</td><td>读写</td><td>新建一个文件，先向该文件中写人数据，然后可从该文件中读取数据</td></tr><tr><td>a+</td><td>读写</td><td>在” a”模式的基础上，增加可读功能</td></tr><tr><td>rb</td><td>二进制读</td><td>功能同模式”r”，区别：b表示以二进制模式打开。下同</td></tr><tr><td>wb</td><td>二进制写</td><td>功能同模式“w”。二进制模式</td></tr><tr><td>ab</td><td>二进制追加</td><td>功能同模式”a”。二进制模式</td></tr><tr><td>rb+</td><td>二进制读写</td><td>功能同模式”r+”。二进制模式</td></tr><tr><td>wb+</td><td>二进制读写</td><td>功能同模式”w+”。二进制模式</td></tr><tr><td>ab+</td><td>二进制读写</td><td>功能同模式”a+”。二进制模式</td></tr></tbody></table><p>按照mode 规定的方式，打开由pname指定的文件。若找不到由pname指定的相应文件，就按以下方式之一处理：</p><p>（1） 此时如mode 规定按写方式打开文件，就按由pname指定的名字建立一个新文件；<br>（2） 此时如mode 规定按读方式打开文件，就会产生一个错误。</p><p>例： fopen(“example.txt”, “rw”);</p><p>如果返回失败，那么将返回NULL。</p><p><strong>关闭</strong></p><p>int fclose(FILE *fp);</p><p>如果关闭不正常，返回-1（EOF).</p><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="按字符输入输出"><a href="#按字符输入输出" class="headerlink" title="按字符输入输出"></a>按字符输入输出</h4><p>原型：<code>int fgetc (FILE *fp);</code></p><p>作用：一次读入一个字符。如果读入出现问题，返回-1(EOF)</p><p>注意：由于 fgetc 是以 unsigned char 的形式从文件中输入（读取）一个字节，并在该字节前面补充若干 0 字节，使之扩展为该系统中的一个 int 型数并返回，而非直接返回 char 型。当输入失败时返回文本文件结束标志 EOF 即 -1，也是整数。故返回类型应为 int 型，而非 char 型。</p><p>也就是说最好不要用char类型去接收字符而使用unsigned_char，这样在碰到特殊字符就不会出现错误。</p><p>由于在 C 语言中把除磁盘文件外的输入输出设备也当成文件处理，故从键盘输入字符不仅可以使用宏 getchar() 实现，也可以使用 <strong>fgetc (stdin)</strong> 实现。其中，stdin 指向标准输入设备—键盘所对应的文件。stdin 不需要人工调用函数 fopen 打开和 fclose 关闭。</p><p><strong>按字符输出</strong></p><p>原型： <code>int fputc (int c, FILE *fp);</code></p><p>向fp文件中输出字符c。如果想输出到屏幕，可以<code>fputc(c, stdout)</code></p><p>对一个文件进行读写操作时，经常会把一个文件中读写位置重新调整到文件的开始处，可以使用函数 rewind 实现。</p><p>原型: <code>void rewind (FILE *fp);</code></p><p>作用：把<strong>读写</strong>位置跳到函数开头。</p><h4 id="按字符串输入输出"><a href="#按字符串输入输出" class="headerlink" title="按字符串输入输出"></a>按字符串输入输出</h4><p><strong>输入</strong></p><p>原型： <code>char * fgets (char *s, int size, FILE * fp);</code></p><p>作用： 从文件中读取长度为size（到了末尾会终止）的字符串，并且自动加入’\0’后输出，遇到空格不会终止。</p><p><strong>输出</strong></p><p>原型： <code>int fputs (const char *str, FILE *fp);</code></p><p>作用：把str输出到文件中。</p><h4 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h4><p>这个与scanf和printf类似，只是目标变成了文件。</p><p><strong>输入</strong></p><p>原型： <code>int fscanf (文件指针，格式控制串，输入地址表列);</code></p><p>作用：从文件中输入到格式化字符串中，遇到空格会终止输入。</p><p>返回值：返回整型，输入成功时，返回输入的数据个数；输入失败，或已读取到文件结尾处，返回 EOF(-1)</p><p>例： fscanf (fp,”%d,%d”, &amp;a, &amp;b); //两个%d之间也必须用逗号隔开</p><p><strong>输出</strong></p><p>int fprintf (文件指针，格式控制串，输出表列)；</p><p>作用： 把格式字符串中的数据输出到文件中。</p><h4 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h4><p><strong>输入</strong></p><p>原型：<code>unsigned fread (void *buf, unsigned size, unsigned count, FILE* fp);</code></p><p>作用：从 fp 指向的文件中读取 count 个数据块，每个数据块的大小为 size。把读取到的数据块存放到 buf 指针指向的内存空间中。</p><p>返回值：返回实际读取的数据块（非字节）个数，如果该值比 count 小，则说明已读到文件尾或有错误产生。这时一般采用函数 feof 及 ferror 来辅助判断。</p><p><strong>输出</strong></p><p>原型：<code>unsigned fwrite (const void *buf,unsigned size,unsigned count,FILE* fp);</code></p><p>作用： 把buf中count个大小为size的数据块写到文件中</p><p><strong>文件检查</strong></p><p>原型： <code>int feof (FILE * fp);</code></p><p>作用：检查是否到了文佳末尾，如果到了，返回非0</p><h4 id="随机读写"><a href="#随机读写" class="headerlink" title="随机读写"></a>随机读写</h4><p>随机读写就是不是在文件开头而是制定一个位置开始读写。首先要把文件指针移到对应位置，然后开始读写。</p><p>原型： <code>int fseek(FILE *fp, long offset, int origin);</code></p><p>作用：把fp读写指针设置到origin+offset的位置上，origin是起始位置。offset是偏移量。</p><p>起始位置有三种快捷的设置。分别是：</p><ul><li>SEEK_SET:文件开头，即第一个有效数据的起始位置。</li><li>SEEK_CUR：当前位置。</li><li>SEEK_END:文件结尾，即最后一个有效数据之后的位置。注意：此处并不能读取到最后一个有效数据，必须前移一个数据块所占的字节数，使该文件流的读写指针到达最后一个有效数据块的起始位置处。</li></ul><p>可以通过<code>long ftell (FILE *fp);</code>获得当前指针对于文件开始位置的偏移量</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;文件总的来说其实
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>java 内部类</title>
    <link href="http://xinhecuican.github.io/post/348d4e04.html"/>
    <id>http://xinhecuican.github.io/post/348d4e04.html</id>
    <published>2020-04-28T12:00:00.000Z</published>
    <updated>2020-05-23T11:43:08.300Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 23 2020 21:27:14 GMT+0800 (中国标准时间) --><p>内部类就是在类的内部又定义一个类。</p><h3 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h3><p>实例内部类就是没有static修饰的内部类。他有以下几点需要注意</p><ul><li>在创建内部类的实例时，外部类必须已经创立。例如：</li></ul><p><code>Outer.InnerTool tool = new Outer().newInnerTool();</code>这个语句相当于</p><p><code>Outer outer = new Outer(); Outer.InnerTool Tool = outer.new InnerTool();</code></p><ul><li><p>内部类也是在外部类的内部，可以访问外部类的任何级别的成员方法和成员变量。这是因为想要创建内部类，首先要创建外部类，这个时候可以看成内部类有外部类的引用。</p></li><li><p>一个外部类可以对应多个内部类，一个内部类对应一个外部类。外部类不能直接访问内部类的成员，必须要通过实例去访问。例如</p></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> b1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> b2 = <span class="number">2</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">C</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v1 = b1;<span class="comment">//不能直接访问内部类成员，错误</span></span><br><span class="line">        B.C c1 = <span class="keyword">new</span> C();<span class="comment">//错误</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();<span class="comment">//正确，因为在类内部相当于已经有实例</span></span><br><span class="line">        <span class="keyword">int</span> v2 = b.b1;<span class="comment">//正确，可以通过内部类实例直接访问</span></span><br><span class="line">        B.c c2 = b.<span class="keyword">new</span> C();<span class="comment">//正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>在内部类中不能定义静态成员。</li><li>如果内部类和外部类A有同名的成员。那么this代表外部，A.this代表内部</li><li>如果有两个内部类且一个定义成private，那么另一个类不能访问。因为两个是同级的，可以把两个内部类看成继承于同一个父类的类。并且如果想在一个内部类中使用另一个内部类，则必须用完整类名</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        A.B b = <span class="keyword">new</span> <span class="type">A</span>().<span class="keyword">new</span> <span class="type">B</span>();<span class="comment">//使用A.B而不能像前面一样直接使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类也是一种静态变量。但是这种类比较神奇，本来static是不能修饰类的，但是内部类的static和普通的静态变量有所不同。它可以创建实例，也就是说不局限于方法区，只是为了有特殊的权限而把static安上去而已。</p><p>静态变量可以直接创建，不必先创建外部类。例如<code>A.B b = new A.B();</code>。</p><p>正因为如此，所以静态内部类想访问外部类实例变量需要先创建实例。但是静态变量可以直接访问。</p><p>静态类的特点就是可以定义静态成员。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是在一个方法中定义的类，它的可见范围是这个方法。局部内部类不能使用访问权限修饰符（public等），其实本来就没有必要，只能在这个方法内了还要访问权限干什么。</p><p>局部类也不能包含静态成员。依我看这就是java中的struct（不知道java中有不）。</p><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>这种类的特殊之处就是没有名字，这种类实际上是内部类的简写形式（虽然也简单不到哪去），如果只需要创建一个内部类实例，就可以考虑匿名类。例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> A</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    A a = new A()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        void method()</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            System.out.println("from");</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line">        a<span class="function">.<span class="keyword">method</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>匿名类本身没有构造方法，但是他会调用父类的构造方法。匿名类和内部类的访问权限相同，也可以访问外部所有变量。</p><p>传递参数时要注意，如果传递的是外部类的参数，必须要加final。因为内部类和外部类编译时生成的是两个文件，也就是说可能是值传递。但是内部类和外部类按道理应该是同一个类，内部类改变了参数，外部类也要跟着改变。为了避免这种矛盾，干脆直接定义成final不可改变了。</p><p>语法： <code>new 类名/接口名(构造方法参数){内容}</code></p><p>匿名内部类实现接口（注意是实现），其实就是创造了一个类</p><h3 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h3><p>如果一个外部类继承了另一个外部类的内部类的实例，那么这个外部类会自动引用另一个外部类。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    pubilc <span class="keyword">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> print()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("a="+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Sample extends <span class="keyword">Outer</span>.<span class="keyword">Inner</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">public</span> Sample(<span class="keyword">Outer</span> o)</span><br><span class="line">   &#123;</span><br><span class="line">       o.super();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">public</span> static <span class="type">void</span> main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">Outer</span> outer1 = <span class="built_in">new</span> <span class="keyword">Outer</span>();</span><br><span class="line">       <span class="keyword">Outer</span>.<span class="keyword">Inner</span> <span class="keyword">inner</span> = outer1.<span class="built_in">new</span> <span class="keyword">Inner</span>();</span><br><span class="line">       Sample s1 = <span class="built_in">new</span> Sample(outer1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Sample必须要提供如上所述的构造函数。因为如果不提供，那么就不知道引用的是哪一个Outer。此外，Java虚拟机会自动使内部类的实例引用外部类的实例。例如上面inner实例会自动引用outer1实例。</p><h3 id="内部类用途"><a href="#内部类用途" class="headerlink" title="内部类用途"></a>内部类用途</h3><p>第一个作用就是封装。例如顶层类只有public和默认级别，而内部类四种级别都可以有。</p><p>第二个作用是访问外部类的属性。这个访问不代表创建一个内部类的实例就可以直接访问外部类的属性了，那反而是对封装的破坏，这里指的是在定义的时候可以随意使用外部类的属性。</p><p>第三个作用是<strong>回调</strong>。这个的含义是可以实现类和接口中同名的方法。例如两个接口或一个类一个接口中定义了重名的方法，那么可以让内部类实现接口然后外部覆盖方法。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span>//<span class="title">Base</span>调节速度，<span class="title">Adjustable</span>调节温度</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> speed)</span><span class="comment">//覆盖</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustTemperature</span><span class="params">(<span class="keyword">int</span> temperature)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Adjustable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> temperature)</span><span class="comment">//实现</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            adjustTemperature(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Adjustable <span class="title">getCallBackReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意这里内部类是通过调用外部类的方法来实现的，虽然应该也可以直接在内部类中实现，频繁的跳转反而会带来性能的降低。但是某些时候想使用外部类的private类型时可以使用这种方法。</p><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>对于每个内部类，java都会生成.class文件。</p><ul><li>成员内部类 外部类名字$内部类名字. 例： A$B.class</li><li>局部内部类 外部类名字$数字加内部类名字</li><li>匿名类 外部类名字$数字</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat May 23 2020 21:27:14 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;内部类就是在类的内部又定义一个类。&lt;/p&gt;&lt;h3 id=&quot;实例内部类&quot;&gt;&lt;a href=&quot;#实例内部类&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>链接</title>
    <link href="http://xinhecuican.github.io/post/4551c130.html"/>
    <id>http://xinhecuican.github.io/post/4551c130.html</id>
    <published>2020-04-28T07:15:00.000Z</published>
    <updated>2020-05-07T09:56:19.844Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>记得gcc编译器编译的步骤吗？预处理，编译，汇编，链接。首先前两步是为了生成.s的汇编文件，然后第三步就是生成机器码。但是如果第三步就已经完成了所有事为什么还要第四步呢？</p><p>首先我们要知道，编译时是各个文件独立编译的，也就是说这个时候如果分配了地址很可能发生这个函数的地址和另外一个文件中函数的地址相同的尴尬事情发生，为了避免这种事情，在编译到.o文件的时候一些其他文件要用的函数和变量使用一个符号来表示的，然后在链接阶段再来连连看把地址安上。</p><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p>目标文件有三种：</p><ul><li>可重定位目标文件，也就是汇编后形成的.o文件。可以和其他文件链接新城可执行文件</li><li>可执行目标文件，也就是可执行文件</li><li>共享目标文件，一种特殊的可重定向目标文件，可以在运行时重定向（动态链接）</li></ul><h4 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h4><p><img src="/images/elf.png" alt></p><p>上面是一个elf文件结构图，这是现在linux中目标文件格式。各种目标文件中都有类似的格式。</p><ol><li>ELF头，存放了一些基础信息，例如大端序还是小端序，文件类型等等。</li><li>.text节，已编译的机器代码。</li><li>.rodata。只读数据，例如printf中的格式串和跳转表</li><li>.data；以初始化全局和静态变量</li><li>.bss； 未初始化全局和静态变量</li><li>.symtab。符号表</li><li>rel.text； .text节位置列表。可执行文件中不存在，一般会省略</li><li>.rel.data； 同上</li><li>.line； 源程序中行号和.text节机器指令间的映射，可以使用-g选项启用它</li><li>…</li><li>节头部表； 存放每一节相对于elf开始位置的偏移量。</li></ol><h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><p>每个.o文件中都有一个符号表。总共有三种符号</p><ul><li>全局符号：由该文件定义并且能被其他模块引用的全局符号。全局符号表示非静态函数和全局变量</li><li>外部符号：有其他模块定义并且被该模块引用的符号。这些符号叫外部符号。对应其他模块（文件）的非静态函数和全局变量</li><li>局部符号。这是带static的函数和全局变量。这些符号在函数内部都可见，但是不能呗其他函数引用。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">符号表的构成：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Symbol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;<span class="comment">//在符号表中的字节偏移</span></span><br><span class="line">    <span class="keyword">char</span> type:<span class="number">4</span>,<span class="comment">//符号类型，是数据还是函数还是文件还是未定义</span></span><br><span class="line">       binding:<span class="number">4</span>;<span class="comment">//符号是本地（static）还是全局的</span></span><br><span class="line">    <span class="keyword">char</span> reserved;</span><br><span class="line">    <span class="keyword">short</span> section;</span><br><span class="line">    <span class="keyword">long</span> value;<span class="comment">//符号地址</span></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">size</span>;<span class="comment">//符号大小，对于函数是函数指令字节总个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>例：<img src="/images/%E7%AC%A6%E5%8F%B7%E8%A1%A8.webp" alt></p><p>其中ndx中的UND是undefine。</p><h3 id="静态链接完成的任务"><a href="#静态链接完成的任务" class="headerlink" title="静态链接完成的任务"></a>静态链接完成的任务</h3><p>静态链接就是编译时完成的链接，与之对应的运行时的链接。静态链接主要完成了两个任务，符号解析和重定位</p><h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><p>符号解析就是将上面的符号表一一对应起来，例如上面第二种符号就匹配其他文件的第一种符号。</p><p>但是这里还有一些问题，因为开始编译是各做各的，所以难免出现名字相同的情况，甚至一个文件中也有函数重载导致重名的情况。这是符号解析中的难题。</p><p>对于一个文件中的重载，gcc链接器会对这些符号进行重整。例如同样是A函数，可能通过链接器的重整一个符号名就成了A1，另外一个成了A2。</p><p>如果是全局（其他模块可见）的变量之间导致重名。有以下方法。</p><p>在编译时，编译器想汇编器输出每个全局符号，分成强弱两类。函数和以初始化的全局变量时强符号，未初始化全局变量时弱符号。</p><p>链接规则：</p><ol><li>不能出现同名的强符号</li><li>如果一个强符号，其他都是弱符号，那么其他弱符号都使用强符号地址</li><li>如果都是弱符号，那么随机选取一个弱符号，其他弱符号使用这个弱符号地址</li></ol><p>注意第二点和第三点，系统都只分配了一片内存空间，其他符号都是共用这片内存空间，这就可能导致一些奇奇怪怪的错误，例如数据莫名被修改。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sum.<span class="keyword">c</span></span><br><span class="line"></span><br><span class="line">int <span class="keyword">x</span><span class="comment">;</span></span><br><span class="line"><span class="comment">int y;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a.c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int x;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为x都是弱符号，所以随便选一个，然后让另一个共享内存空间，也就是在sum.c中进行更改会导致a.c中x的更改。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sum.c</span></span><br><span class="line"><span class="comment">int x;</span></span><br><span class="line"><span class="comment">int y;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a.c</span></span><br><span class="line"><span class="comment">double x;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这种问题更为严重，如果选到了a.c中的x，那么空间是8字节，而这时在sum.c中x和y是连到一起的也是8字节，这就意味着这次对a.c中x改变可能会导致y改变。</span></span><br></pre></td></tr></table></figure></div><p>上面这个问题在编译阶段很难发现，所以只有养成良好习惯，才可以减少这类问题。下面是几点建议。</p><ol><li>能不使用全局变量就不使用全局变量</li><li>使用全局变量记得初始化</li><li>确定要引用外部变量时用extern</li></ol><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>重定位有两步</p><ol><li>重定位节和符号定义：这一部分是把上面所说的每一个文件中的节。例如所有文件的.data节合成为一个节。之后就把内存地址赋给新的节，并且赋给每个符号。这时就有运行时的内存地址了。</li><li>重定位节的符号引用。</li></ol><h5 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h5><p>在重定位之前，符号并没有赋值，这个时候就有重定位条目确定我们要怎么把地址赋给每一个符号。</p><p>代码重定位条目存放在.rel.text中，数据重定位条目在.rel.data中。</p><p>重定位条目内容：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Rela</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> offset;<span class="comment">//相对于函数首地址的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> type:<span class="number">32</span>,<span class="comment">//类型</span></span><br><span class="line">        symbol:<span class="number">32</span>;<span class="comment">//对应的符号</span></span><br><span class="line">    <span class="keyword">long</span> addend; <span class="comment">//附加信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里只讲两种基本类型：R_X86_64_PC32(相对引用，32位），R_X86_64_32(绝对引用）。</p><p>这种重定位类型只支持小型代码模型，只能引用-2G到2G的范围。</p><p>下面讲怎么重定位。</p><p>如果是相对地址：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">refaddr = ADDR + <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>offset;<span class="comment">//ADDR是函数首地址，例如main函数首地址，offset是偏移量</span></span><br><span class="line"><span class="comment">//refaddr是需要修改内存的首地址，例如e8 00 00 00 00，后面四个零就是我们要填充的地址，那么refaddr是第一个00的地址</span></span><br><span class="line">*refptr(refaddr地址的内容) = <span class="constructor">ADDR(<span class="params">r</span>.<span class="params">symbol</span>)</span> + r.addend - refaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这一段就是计算相对跳转地址的，addr是对应符号的绝对地址，本来addr-refaddr就是相对跳转地址，但是注意这里的相对跳转地址是当前指令的，而我们要从下一条指令进行跳转，所以要加上一个addend，用下一个指令起始地址来减，所以这里的addend是-4，因为refaddr指向e8后面，加上4就是下一条指令，而因为是末地址减首地址所以addend是负数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绝对地址</span></span><br><span class="line"></span><br><span class="line">refaddr 同上;</span><br><span class="line">*refptr = <span class="constructor">ADDR(<span class="params">r</span>.<span class="params">symbol</span>)</span> + r.addend;</span><br><span class="line"><span class="comment">//这个相对简单，内容就是对应符号绝对地址嘛，但是这里也要加addend因为有可能是数组等因此还要加上数组的偏移量。</span></span><br></pre></td></tr></table></figure></div><h3 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h3><p>过去我们有两种选择进行连接，第一种是把一堆常用函数放到一个可重定向文件中，另一种是把所有常有函数都分开，然后一个个链接。第一种占用空间太大，可能为了一两个函数加了一两千个函数，第二中编译时太难写，所以使用了静态链接库。</p><p>静态链接库集合了上面两种方法，首先它是一个可重定向目标文件。但是不同在于他有一个符号表需要哪个函数就把那个函数链接进去，这样就兼顾上面二者的优点。</p><p>可以使用<code>gcc -static -o prog2c main2.c -L. -lvector</code>其中L是链接库的路径，l是库名，一般库开头都是lib所以lib可以省略，后缀名可以省略。</p><p>可以使用<code>ar rcs libvector.a addvec.o multvec.o</code>来创建静态库，libvector.a是库名</p><p>为了效率考虑，链接时从左向右每个文件只会扫描一次，这样就可能导致问题。例如，最右边的模块有外部符号（引用其他文件的），这时因为扫描已完毕，所以就会报错。</p><p>此外，对于一些常用函数如cout等，如果每个程序都复制一次，那么还是太浪费空间。</p><p>而且如果库函数有错误或者考虑不周需要修改，那么对于绝大多数程序来说都是一个灾难，因为大型程序重新编译一下可能会导致冲突等不可预料的后果。</p><p>为了解决这些问题，提出了动态链接</p><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>动态链接库指的是在程序加载或运行阶段进行链接。在程序开始时（程序不是从main开始，前面还有一段代码负责初始化）会启用动态链接器。</p><h4 id="pic数据引用"><a href="#pic数据引用" class="headerlink" title="pic数据引用"></a>pic数据引用</h4><p>GOT 全局偏移量表，这个表用来存全局变量的地址，在data段开始的地方，而静态链接的时候那些符号的跳转地址都是跳转到这个表中，然后在运行时这个跳转表才会真正赋予地址。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MEL"><figure class="iseeu highlight /mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov <span class="number">0x100010</span>(%rip), %rax</span><br><span class="line">addl $0x1, (%rax)</span><br><span class="line"></span><br><span class="line">第一行就是跳转到跳转表然后取出里面地址，然后第二段取出之歌地址中的值并加一</span><br></pre></td></tr></table></figure></div><p>PLT 过程链接表。举个例子</p><p><img src="/images/%E9%93%BE%E6%8E%A5.jpg" alt></p><p>这个例子是从右上角开始的，先调用函数到了PLT表，之后跳转到GOT[4]所指位置，第一次GOT[4]指向4005c6也就是下一条指令，第一次后GOT[4]就会变成函数地址。</p><p>4005c6是把addvec的ID拖入栈中，然后跳转到GOT[2]的位置同时把GOT[1]放到栈中，GOT[1]是解析函数用到的信息，GOT[2]是动态链接器地址。跳到GOT[2]后就根据栈中的内容链接函数并把GOT[4]的值变成函数首地址。</p><h3 id="库打桩技术"><a href="#库打桩技术" class="headerlink" title="库打桩技术"></a>库打桩技术</h3><p>总体来说库打桩是指自己写一个库然后先于系统库加载这时程序运行的就是你自己写的库了。</p><h4 id="链接时库打桩"><a href="#链接时库打桩" class="headerlink" title="链接时库打桩"></a>链接时库打桩</h4><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(ptr) myfree(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(%d)=%p\n"</span>, (<span class="keyword">int</span>)<span class="built_in">size</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"free(%p)\n"</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>通过上面就可以实现不使用库函数而使用自己的函数了。这个函数便于跟踪内存请求和释放情况。但是每个文件都要写太过麻烦。</p><p>也可以把这个单独写成一个文件，然后通过编译器<code>gcc -Wl ,--wrap,malloc -Wl,--wrap,free -o int1 int.0 mymalloc.o</code>进行链接</p><h4 id="运行时库打桩"><a href="#运行时库打桩" class="headerlink" title="运行时库打桩"></a>运行时库打桩</h4><p>运行时库打桩基于LD_PRELOAD环境变量。在这个变量路径下的库会先于系统库进行加载。</p><p><a href="https://blog.csdn.net/qq_18150497/article/details/78010331" target="_blank" rel="external nofollow noopener noreferrer">更多内容请看</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;记得gcc编译器
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>java 对象的生命周期</title>
    <link href="http://xinhecuican.github.io/post/53677394.html"/>
    <id>http://xinhecuican.github.io/post/53677394.html</id>
    <published>2020-04-27T03:43:00.000Z</published>
    <updated>2020-04-28T07:14:26.884Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><p>有四种显式创建的方式：</p><ul><li>new创建</li><li>运用反射，调用java.lang.Class或java.lang.reflect.Constructor类的newInstance()方法</li><li>调用对象的clone()方法</li><li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射创建</span></span><br><span class="line">Class objClass = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"Customer"</span>)</span>;</span><br><span class="line">Customer cl = (Customer)objClass.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line"><span class="comment">//通过克隆创建</span></span><br><span class="line">Customer c3 = (Customer)c2.clone<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></div><p>通过new或反射的方法创建的时候，都会调用构造方法。但是通过克隆创建不会执行构造方法。在Object类中就定义了clone()方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASPECTJ"><figure class="iseeu highlight /aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object clone()<span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Cloneable))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportException();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这种方式下如果对应类没有实现cloneable接口，那么clone（）方法会抛出异常。<strong>如果想用clone，那么必须要实现Cloneable接口</strong>。</p><p>clone会创建一个对象，对象的属性值相同，但是内存地址不同。</p><p><strong>隐式创建对象</strong></p><ul><li>输入main的参数都会转化成String对象</li><li>+号对String类型创建新对象</li><li>加载一个类时，会创建Class实例</li></ul><p><strong>创建对象步骤</strong></p><ol><li>给对象分配内存</li><li>将实例变量自动初始化成默认值</li><li>初始化对象。例如private int a = 1;在第二步赋值成0，在第三步中才会变成1.</li></ol><p>对于第三步，如果是通过clone的方法创建，那么将原来成员变量的值赋给新的成员变量。如果是用第四种方法，那么是通过输入流读入序列化数据。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法时负责初始化的，可以提供参数，也可以不提供，一般设置一个默认构造函数有好处。</p><ul><li>方法名要与类名相同</li><li>不声明返回类型</li><li>不能被static,final,synchronized,abstract,native修饰</li></ul><p><strong>重载构造方法</strong></p><p>这是为了满足多样化的需求。需要注意一点在一个构造方法中可以用this调用另一个构造方法。但是如果在一个构造方法中使用了this语句，那么它必须在第一行。</p><h4 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h4><p>其实和c++一样，在没有构造方法的时候会提供一个默认构造方法，如果写了一个构造方法那么系统就不会提供构造方法。但是最好要有一个不带参数的构造方法。</p><h4 id="子类调用父类构造方法"><a href="#子类调用父类构造方法" class="headerlink" title="子类调用父类构造方法"></a>子类调用父类构造方法</h4><p>父类构造方法不能被子类继承。在构造子类时，先执行祖先的构造方法，然后一次向下。这样可以确保子类从父类继承的东西可以被使用。可以用super(…)调用父类构造方法。如果没有用super显示构造，那么子类会用父类的默认构造方法。如果子类没有构造方法，将会出现编译错误</p><h4 id="构造方法的访问级别"><a href="#构造方法的访问级别" class="headerlink" title="构造方法的访问级别"></a>构造方法的访问级别</h4><p>这里主要将private的访问级别的意义。</p><p>当构造函数是private时，只有当前类可以访问它。这也代表不能有子类。所以只有一些特殊的场合才会使用它。</p><ol><li>只有静态方法，没有实例方法</li><li>禁止被继承。这个与final的区别就是private不允许其他类创建它的实例，而final可以。</li><li>这个类要把自己封装起来。</li></ol><h3 id="静态工厂办法"><a href="#静态工厂办法" class="headerlink" title="静态工厂办法"></a>静态工厂办法</h3><p>创建实例最常见的方法是用new调用类的构造方法。在这种情况下，可以创建任意多的实例。如果类想要进一步封装创建实例的细节，并控制实例数目，可以用静态工厂的方法。</p><p>静态工厂方法指的是在类中提供一个公有的静态方法，返回类的一个实例。</p><p>静态工厂实际上是一种普通的方法，但是它有平常创建实例时所不具有的灵活性。</p><p><strong>特点一</strong>： 可以有不同于类的名字，这样在重构构造方法时可以更清晰的说明其中的不同，使可读性增大。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Person get<span class="constructor">ManInstance(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">       return <span class="keyword">new</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>, SEX.<span class="params">man</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public static Person get<span class="constructor">WomanInstance(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">       return <span class="keyword">new</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>, SEX.<span class="params">woman</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>一般都喜欢把静态工厂取名为valueof或getInstance。</p><p><strong>特点二</strong>： 可以不创建新对象。重复利用原有对象</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> A init = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">getinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>特点三</strong>： 可以创建子类的实例</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public static <span class="type">A</span> getson()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Sub</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>因为静态工厂每次不一定创建新的实例，所以在一些特殊的场合有应用。</p><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>单例类就是只有一个实例的类，这种类只有一个实例。一般是系统中具有唯一性的组件才会使用。这种类一般要消耗很多内存，为了防止随便开然后爆内存，所以设置成单例类。</p><p>一种办法是提供public static final的静态常量，然后该常量引用唯一实例。在把构造方法定义成private类型。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Globalconfig</span><br><span class="line">&#123;</span><br><span class="line">    public static final GlobalConfig<span class="built_in"> INSTANCE </span>= new GlobalConfig();</span><br><span class="line">    private GlobalConfig();</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另一种办法就是把构造方法定义成private类型，然后提供构造工厂。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Globalconfig</span><br><span class="line">&#123;</span><br><span class="line">    public static final GlobalConfig<span class="built_in"> INSTANCE </span>= new GlobalConfig();</span><br><span class="line">    private GlobalConfig()&#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">    public static GlobalConfig getInstatnces()</span><br><span class="line">    &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>枚举类是实例数目有限的类。比如，表示性别的Gender类，他只会有两个类。</p><p>设计时，同样把构造方法定义成private，然后创建若干个public static final的静态变量。还可以提供静态工厂。另外如果想使用这些实例，直接用类名即可。</p><h4 id="不可变类和实例缓存"><a href="#不可变类和实例缓存" class="headerlink" title="不可变类和实例缓存"></a>不可变类和实例缓存</h4><p>不可变类指的是创建之后就不可以更改属性值，和final类似。例如Long类，String类。</p><p>创建不可变类时，要考虑一下内容：</p><ul><li>把属性定义成final类型</li><li>不对外公开的（private）set方法</li><li>public的get方法</li><li>在构造方法中初始化所有属性</li><li>覆盖Object类的equals()和hashCode()方法。</li></ul><p>对于不可变类，因为数据成员不会改变，所以在创建实例时，如果二者数据成员相同，那么可以共有一份空间，这样就减小了内存消耗。这叫做实例缓存。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(10)</span>;</span><br><span class="line">Integer b = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(10)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(a<span class="operator"> == </span>b);<span class="comment">//会打印true</span></span><br></pre></td></tr></table></figure></div><p>关于两个对象的等于，在<a href="https://xinhecuican.github.io/post/4b1879e3.html">前面一篇博客</a>中已有说明。</p><p>这就说明了两者共用了内存空间。那么我们应该如何实现实例缓存呢？</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> <span class="type">Name</span></span><br><span class="line">&#123;</span><br><span class="line">    private static final <span class="keyword">Set</span>&lt;SoftReference&lt;<span class="type">Name</span>&gt;&gt; names = <span class="built_in">new</span> HashSet&lt;SoftReference&lt;<span class="type">Name</span>&gt;&gt;();//实例缓存，存放<span class="type">Name</span>的软引用</span><br><span class="line">    <span class="built_in">public</span> sattic <span class="type">Name</span> valueOf(String firstname, Stirng lastname)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(SoftReference&lt;<span class="type">Name</span>&gt; <span class="keyword">ref</span>:names)//循环查看是否已经存在</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Name</span> <span class="type">name</span> = <span class="keyword">ref</span>.<span class="keyword">get</span>();//获得软引用的<span class="type">Name</span>对象</span><br><span class="line">            <span class="keyword">if</span>(<span class="type">name</span> != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; <span class="type">name</span>.firstname.equals(firstname)</span><br><span class="line">            &amp;&amp; <span class="type">name</span>.lastname.equals(lastname))</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果缓存中不存在<span class="type">Name</span>对象，就创建新对象，并加入到实例缓存</span><br><span class="line">            <span class="type">Name</span> <span class="type">name</span> = <span class="built_in">new</span> <span class="type">Name</span>(firstname, lastname);</span><br><span class="line">            names.<span class="keyword">add</span>(<span class="built_in">new</span> SoftReference&lt;<span class="type">Name</span>&gt;(<span class="type">name</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当然，实例缓存也需要消耗内存空间，如果对所有不可变类都使用，可能有的反而会减少内存。当有如下情况时，才会使用实例缓存。</p><ul><li>不可变类实例种类有限</li><li>需要频繁访问某些特定的实例。</li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>在c++中，内存回收是程序员自己负责，因为人难免犯错嘛，可能会导致一系列奇奇怪怪的错误。所以在java中，内存回收是java虚拟机做的。</p><p>只有对象不被任何变量引用时，它的内存才会被回收。当垃圾回收器回收内存时，会先调用该对象的finalize()方法，该方法可能使对象复活，导致垃圾回收器取消回收内存。</p><p>对垃圾回收器来说，程序由三种状态：</p><ol><li>可触及状态：只要还有引用变量引用对象，那么这个对象就处于可触及状态。</li><li>可复活状态： 当程序中没有引用2变量引用时，就进入了可复活状态，复活的关键是finalize方法，这个方法有可能使他复活</li><li>不可触及状态： 也就是调用了finalize状态并且没有复活之后。这种状态下虚拟机才会真正回收内存。</li></ol><h4 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h4><p>finalize()方法就是要销毁时执行的方法，如果finalize方法如果出现异常系统也不会报错而是直接清除。下面讲一下如何把它变成可触及状态。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ghost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Map&lt;<span class="keyword">String</span>, Ghost&gt; ghosts = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>,Ghost&gt;();</span><br><span class="line">    <span class="keyword">String</span> name ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ghost <span class="title">getInstance</span><span class="params">(<span class="keyword">String</span> name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Ghost ghost = ghost(name);</span><br><span class="line">        <span class="keyword">if</span>(ghost == null)</span><br><span class="line">        &#123;</span><br><span class="line">            ghost = <span class="keyword">new</span> Ghost(name);</span><br><span class="line">            ghosts.<span class="built_in">put</span>(name, ghost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ghost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ghosts.<span class="built_in">put</span>(name, <span class="keyword">this</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"execute finalize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个程序在将要被销毁时会调用finalize，之后就把这个对象有放回了Map中，又把这个对象复活了。</p><p>但是实际最好不要用finalize，因为这会扰乱正常的回收机制，导致永远无法回收。</p><p><strong>清除过期引用</strong></p><p>正常情况下，虚拟机都会很好的执行垃圾回收，但是在对象数组等线性结构中，如果只让指针减一，是无法进行垃圾回收的，因为这个数组仍保留对它的引用，但是这个被清除的数据已经无意义了，下面举个例子</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">Object</span>[] elements = <span class="keyword">new</span> <span class="keyword">Object</span>[capacity];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements[--<span class="built_in">size</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个方法的确没什么问题，也可以得到正确的执行，但是实际上size位置的引用并没有被清除，所以当你不断的增加然后开始不断的删除时，这个栈一直在占用大量的空间。所以要想办法除法java的回收机制</p><p>方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">Object</span> object = elements[--<span class="built_in">size</span>];</span><br><span class="line">    elements[<span class="built_in">size</span>] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="强引用，弱引用，软引用，虚引用"><a href="#强引用，弱引用，软引用，虚引用" class="headerlink" title="强引用，弱引用，软引用，虚引用"></a>强引用，弱引用，软引用，虚引用</h3><p>在早期的java中，并没有各种引用。这些引用代表的是清除的级别，如果空间不够了，那么先清除级别低的，这样对程序造成的影响就小。</p><p>在java.lang.ref包中，有Reference的抽象父类，下面有SoftReference,WeakReference,PhantomRefence，分别代表软引用，弱引用，虚引用。<br>ReferenceQueue表示引用队列，它可以和上面三种引用联合使用，以便跟踪虚拟机回收所引起的对象的活动(具体的现在不清楚）。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用就是普通的引用。如果一个类是强引用，那么除非没有变量引用它，虚拟机绝对不会回收它，甚至空间不足的时候虚拟机抛出OutOfMemoryError也不会回收。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>如果一个对象只有软引用，那么空间足够就会留着它，空间不足就会回收它。前面就有一个软引用的例子。</p><p>软引用可以和引用队列（ReferenceQueue）配合使用，如果软引用所引用的对象被回收，那么虚拟机就会把这个软引用加入到与之关联的引用队列中</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用比软引用更没人权。一旦垃圾回收器发现了弱引用，不管有没有内存，都会回收它。只是因为垃圾回收是一个优先级比较低的线程，所以不一定会很快发现弱引用。</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>弱引用都如此了，虚引用肯定更倒霉。同样也是一旦被发现分分钟清除的货。而且优先级比弱引用还要低。虚引用并不会决定对象生命周期。对象持有虚引用和没有引用一样，如果只有虚引用，还是会被清除。</p><p>弱引用<strong>必须</strong>要和引用队列一起使用。当回收一个对象时，如果发现它有虚引用，那么就会在回收对象之前，把这个虚引用对象加入引用队列中。</p><p>那么它的作用是什么？因为虚引用会被放到引用队列中，所以可以设一个虚引用，然后通过虚引用是否在引用队列中来判断这个对象时候要被回收。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">"hello"</span>);<span class="comment">//创建强引用</span></span><br><span class="line">ReferenceQueue&lt;<span class="keyword">String</span>&gt; rq = <span class="keyword">new</span> <span class="type">ReferenceQueue</span>&lt;<span class="keyword">String</span>&gt;();<span class="comment">//创建引用队列</span></span><br><span class="line">WeakReference&lt;<span class="keyword">String</span>&gt; wf = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;<span class="keyword">String</span>&gt;(str,rq);<span class="comment">//创建弱引用</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;创建对象的方式&quot;&gt;&lt;a href=&quot;#创建对象的方式&quot; class=&quot;headerlink&quot; title=&quot;创建对象的方式&quot;&gt;&lt;/a&gt;创建对
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="http://xinhecuican.github.io/post/50daec4.html"/>
    <id>http://xinhecuican.github.io/post/50daec4.html</id>
    <published>2020-04-26T11:54:00.000Z</published>
    <updated>2020-04-26T13:44:22.709Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="AOV网络"><a href="#AOV网络" class="headerlink" title="AOV网络"></a>AOV网络</h3><p>aov网络指的是用顶点表示活动的网络。讲个例子吧</p><p>例如学习课程有个前后顺序，前面一门课没有学完后面一门课动不了手。这样就可以用顶点表示课程，然后用有向箭头表示学习的次序，这样就是一种AOV网络。并且显然每个点都要走，因为每门课都要学。</p><p><img src="/images/%E7%BD%91%E7%BB%9C1.PNG" alt="后面这个数字代表先修课程"><br><img src="/images/%E7%BD%91%E7%BB%9C2.PNG" alt></p><p>检测有向环可以用对AOV网络构造拓扑序列。构造方法等会讲，如果有环，那么就会出现永远都有入度的情况，就说明有环。</p><p><strong>构造过程</strong></p><p>就拿上面一个图来说吧。必须先要学完c1，c2才可以学c3.学了c1又可以学c8，按照这样的顺序就可以得出学习顺序是C1C2C3C5C4C8C9C7C6。当然，还有许多其他的次序。</p><p>从中我们可以发现一个规律，假如每当我们学一门课就删去这些边，那么我们可以学习一个课程时入度一定为0.例如我们学完1和2后3入度就是0所以现在我们可以学了。如果入度不为0说明我们还有前置知识我们没有掌握，就不能学。</p><p>总结：找出入度为0的点，删去与之相邻的边，然后找新的入度为0的点，重复上述过程。</p><p>下面给出模板：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAXIMA"><figure class="iseeu highlight /maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    int val;//边权</span><br><span class="line">    int <span class="built_in">last</span>;</span><br><span class="line">    edge* next;</span><br><span class="line">&#125;;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int insum;//入度</span><br><span class="line">    edge* <span class="built_in">first</span>;</span><br><span class="line">&#125;;</span><br><span class="line">node nod[<span class="number">100</span>];//随便设的数字，也可以<span class="built_in">new</span>来构建</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nod[i].<span class="built_in">first</span> = NULL;</span><br><span class="line">        nod[i].insum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void addedge(int <span class="built_in">sum</span>, int <span class="built_in">first</span>, int <span class="built_in">last</span>)</span><br><span class="line">&#123;</span><br><span class="line">    //用后插法</span><br><span class="line">    edge* temp = <span class="built_in">new</span> edge;//needfree</span><br><span class="line">    temp-&gt;val = <span class="built_in">sum</span>;</span><br><span class="line">    temp-&gt;<span class="built_in">last</span> = <span class="built_in">last</span>;</span><br><span class="line">    temp-&gt;next = nod[<span class="built_in">first</span>].<span class="built_in">first</span>;</span><br><span class="line">    nod[<span class="built_in">first</span>].<span class="built_in">first</span> = temp;</span><br><span class="line">    nod[<span class="built_in">last</span>].insum++;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">sum</span>, <span class="built_in">first</span>, <span class="built_in">last</span>;</span><br><span class="line">    node* tempnode;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;<span class="built_in">sum</span>&gt;&gt;<span class="built_in">first</span>&gt;&gt;<span class="built_in">last</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addedge(<span class="built_in">sum</span>, <span class="built_in">first</span>, <span class="built_in">last</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node* aovstack = <span class="built_in">new</span> node;//needfree,链栈，用来存放入度为<span class="number">0</span>的节点</span><br><span class="line">    int <span class="built_in">time</span> = <span class="number">0</span>;//记录栈中有多少元素</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nod[i].insum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tempnode = nod[i];</span><br><span class="line">            tempnode-&gt;<span class="built_in">first</span> = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">            aovstack-&gt;<span class="built_in">first</span> = tempnode;</span><br><span class="line">            <span class="built_in">time</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">time</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">time</span>--;</span><br><span class="line">        tempnode = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">        node* temp = aovstack;</span><br><span class="line">        aovstack = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">        <span class="built_in">delete</span> temp;</span><br><span class="line">        edge* tempedge = tempnode-&gt;<span class="built_in">first</span>;</span><br><span class="line">        <span class="keyword">while</span>(tempedge != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--nod[tempedge-&gt;<span class="built_in">last</span>].insum == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">time</span>++;</span><br><span class="line">                tempnode = nod[tempedge-&gt;<span class="built_in">last</span>];</span><br><span class="line">                tempnode-&gt;<span class="built_in">first</span> = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">                aovstack-&gt;<span class="built_in">first</span> = tempnode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/******************</span></span><br><span class="line"><span class="comment">            *output...</span></span><br><span class="line"><span class="comment">            ***************/</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***************</span></span><br><span class="line"><span class="comment">    * delete...</span></span><br><span class="line"><span class="comment">    *******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="AOE网络"><a href="#AOE网络" class="headerlink" title="AOE网络"></a>AOE网络</h3><p>这个是用边表示活动，顶点表示事件。</p><p><img src="/images/%E7%BD%91%E7%BB%9C3.PNG" alt></p><p>这是一个AOE网络图，注意和上面类似这里每一条边都是要到的。我们要找的就是花费时间最长的那条路，因为那条路走完了所有活动才完成。那么这条路叫做关键路径，这条路径上的活动叫做关键活动。如果我们想缩短工期的时间，那么我们就要先缩短关键活动的时间。</p><p><strong>几个名词</strong></p><p>事件最早可能开始时间 ve(i)</p><p>事件最迟允许开始时间 vl(i)</p><p>活动最早可能开始时间 e[i]</p><p>活动最迟开始时间 l[i]</p><p><strong>所以关键活动就是 e[i] == l[i]</strong> ，因为最早时间和最晚时间相同说明耽误不得。</p><p><strong>求法</strong></p><p>代码比较简单，这里只讲一下思路。</p><p>同样使用邻接表。用四个数组分别表示上面四个名词。首先求前面两个。</p><p>事件最早时间这么多到那个点的路径中最晚的那个。例如上面的6点应该是40而不是30，因为只有最晚的那个完成了才能算真正到了那个点。</p><p>事件最晚开始时间要从后往前算。最后那个点的最晚开始时间我们一般是知道的，就是截至时间。然后往前面去减，如果有多条路径到那个点就选最小的。同样的道理因为所有边走完这件事才算做完了，如果你选大的相当于到最后那个点的所需时间少，结果这边走完了那个时间小的还没有走完。</p><p>举个例子：假设8点的截至时间是60，那么4点的截至时间应该是从8到7到5那一条。</p><p>活动最早开始时间是活动的起点的最早开始时间</p><p>活动的最晚开始时间是活动的终点的最晚开始时间减去这条边的权</p><p><img src="/images/aoe%E7%BD%91%E7%BB%9C.PNG" alt></p><p>从这个代码中我们看出每个顶点遍历就可以了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;AOV网络&quot;&gt;&lt;a href=&quot;#AOV网络&quot; class=&quot;headerlink&quot; title=&quot;AOV网络&quot;&gt;&lt;/a&gt;AOV网络&lt;/h3
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>java 类的生命周期</title>
    <link href="http://xinhecuican.github.io/post/61eaf19a.html"/>
    <id>http://xinhecuican.github.io/post/61eaf19a.html</id>
    <published>2020-04-26T03:33:00.000Z</published>
    <updated>2020-04-27T03:42:48.272Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="类的加载连接和初始化"><a href="#类的加载连接和初始化" class="headerlink" title="类的加载连接和初始化"></a>类的加载连接和初始化</h3><ol><li><p>加载： 查找并加载类的二进制数据</p></li><li><p>链接： 包括验证，准备和解析类的二进制数据</p><ul><li>验证： 确保加载类的正确性。</li><li>准备： 为类的静态变量分配内存，将其初始化为默认值（也就是0）</li><li>解析： 将类的符号引用<a href="符号引用就是在编译阶段，虚拟机并不知道所有引用类的地址（因为还没有加到内存中），就用一个符号表示地址。而直接引用就是真实的地址。">^1</a>变成直接引用</li></ul></li><li><p>初始化： 把类的静态变量赋予正确的初始值。</p></li></ol><h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><p>类的加载是指把类的.class文件中的二进制数据读入到内存中，把它存放在方法区中。然后再兑取川家一个java.lang.Class对象，用来封装类在方法区的数据结构。<strong>通俗的来讲就是把代码加载到内存中</strong>。</p><p>类的加载是由虚拟机自带的加载器来完成的，但是我们也可以自己去定义。用java.lang.ClassLoader类的子类的实例。</p><p>类加载器允许某个类将要被使用时预先加载它。如果预先加载过程中遇到了.class的错误。那么类加载器在首次主动使用这个类的时候报错（LinkageError)</p><h4 id="类的链接"><a href="#类的链接" class="headerlink" title="类的链接"></a>类的链接</h4><p><strong>类的验证</strong></p><p>类的验证主要验证一下内容：</p><ul><li>类文件格式， 看看后缀是否符合</li><li>语义检查 看看是否符合java语义（例如把一个String给int或final是否有子类）</li><li>字节码验证，字节码代表java方法。</li><li>二进制兼容验证。查看这个类引用的另一个类的方法的=在另一个类中是否存在。</li></ul><p><strong>类的准备</strong></p><p>为类的静态变量分配内存，并设置成0（boolean是false，char是’\u0000’)</p><p><strong>类的解析</strong></p><p>符号引用上面已经解释过了，其实也就是这个类引用的其他类或其他类的成员变量和方法等。因为这些类在编译阶段并没有加载，所以虚拟机也不知道要到哪里去找这些方法，所以先弄一个符号代表这个方法。</p><h4 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h4><p>静态变量的初始化有两种途径。（1） 声明时直接赋值 （2） 在静态代码块中初始化。</p><p>初始化并不是直接初始化。如果没有加载和链接，那么先加载和链接。如果父类没有初始化，那么先初始化父类。</p><p>虚拟机只有首次启用一个类的时候才会初始化它。也就是说，创建对象实例，或者访问使用静态变量，还有是某个正在初始化类的父类时都会初始化它。</p><p>此外，当final类型的静态变量，如果能直接计算出值，那么会当成常量，不会导致初始化。反之，会导致初始化。</p><h3 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h3><p>类加载和Linux进程生成类似，都是先有一个根加载器，然后其他类加载器只有一个父加载器。父加载器不是加载自己，而是加载子类，但是是子类请求父类加载自己。</p><p>有三类自带的加载器：</p><ul><li>根加载器，负责加载一些核心库，例如java.lang.*</li><li>扩展加载器，它的父加载器是根加载器。他从java.ext.dirs系统属性指定的目录中加载扩展。或者从JDK的jre\lib\ext中加载扩展</li><li>系统加载器：也叫应用类加载器。它的父加载器是扩展加载器。他从classpath环境变量或者子系统属性java.class.path中加载类，它是用户自定义加载器的默认父加载器。</li></ul><p><strong>类加载的过程</strong></p><p>例如要加载一个类，首先请求父类加载器代为加载，父类再向它的父类代为加载…。一直到根加载器，如果根加载器不能加载，那么就让扩展加载器加载，如果不能加载…。直到找到一个可以加载的。如果所有加载器都不能加载，那么返回ClassNotFoundException。</p><p>成功加载那个类的加载器叫定义类加载器。</p><p>这种机制是为了安全考虑，因为在这种严密的机制下，用户自定义的加载器不可能取代由父加载器完成的任务。</p><p>这里加载器并不一定是和类一样的父子关系。一对父子加载器可能是同一个类的两个实例。</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>每个类加载器都有自己的命名空间，命名空间由该加载器和所有父加载器所加载的类组成。在同一个命名空间中，不可能出现名字（包括包名）完全相同的两个类。不同的命名空间中就有可能出现。</p><h4 id="运行时包"><a href="#运行时包" class="headerlink" title="运行时包"></a>运行时包</h4><p>同一加载器加载的属于相同包的类组成了运行时包。包名相同不一定默认访问级别可以访问，必须要组成运行时包才可以访问默认访问级别。</p><h3 id="创建用户自定义加载器"><a href="#创建用户自定义加载器" class="headerlink" title="创建用户自定义加载器"></a>创建用户自定义加载器</h3><p>首先介绍自定义类的应用场景：</p><p>（1）加密：Java代码可以轻易的被反编译，如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用Java的ClassLoader去加载类了，这时就需要自定义ClassLoader在加载类的时候先解密类，然后再加载。</p><p>（2）从非标准的来源加载代码：如果你的字节码是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。</p><p>（3）以上两种情况在实际中的综合运用：比如你的应用需要通过网络来传输 Java 类的字节码，为了安全性，这些字节码经过了加密处理。这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出在Java虚拟机中运行的类。</p><p>要扩展自己的类加载器，只需扩展java.lang.Classloader类，瑞啊后覆盖findClass(String name)方法。该方法根据参数指定类的名字，返回对应Class对象的引用。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.<span class="keyword">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyClassLoader <span class="keyword">extends</span> ClassLoader</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyClassLoader()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> MyClassLoader(ClassLoader parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"D:/People.class"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(<span class="keyword">file</span>);</span><br><span class="line">            <span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</span></span><br><span class="line">            <span class="keyword">Class</span>&lt;?&gt; c = <span class="keyword">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(<span class="keyword">File</span> <span class="keyword">file</span>) <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里要读入.class的字节，因此要使用字节流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">file</span>);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.<span class="keyword">read</span>(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.<span class="keyword">write</span>(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/SEU_Calvin/article/details/52315125" target="_blank" rel="external nofollow noopener noreferrer">这段代码是扒下来的</a></p><h4 id="URLClassLoader加载类"><a href="#URLClassLoader加载类" class="headerlink" title="URLClassLoader加载类"></a>URLClassLoader加载类</h4><p>在java.net包中，提供了URLClassLoader类，它可以从网上下载类。可以直接使用这个类作为自定义加载器。</p><p>构造方法: <code>URLClassLoader(URL[] urls)//父加载器是系统加载器</code></p><p><code>URLClassLoader(URL[] urls, ClassLoader parent)//指定父加载器</code></p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>java自带类加载器所加载的类是永远不会被卸载的。而用户自定义的类加载器可以被卸载。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;类的加载连接和初始化&quot;&gt;&lt;a href=&quot;#类的加载连接和初始化&quot; class=&quot;headerlink&quot; title=&quot;类的加载连接和初始化
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 异常处理</title>
    <link href="http://xinhecuican.github.io/post/e058ffd8.html"/>
    <id>http://xinhecuican.github.io/post/e058ffd8.html</id>
    <published>2020-04-25T05:40:00.000Z</published>
    <updated>2020-04-26T03:18:26.332Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>有两种办法抛出异常：</p><ul><li>通过try-catch抛出，例如</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span> <span class="title">A</span><span class="params">(int money)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    try</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        if(--money&lt;=0)</span></span></span><br><span class="line"><span class="function"><span class="comment">        &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">            throw new SpecialException("Outof money");</span></span></span><br><span class="line"><span class="function"><span class="comment">        &#125;</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="title">catch</span><span class="params">(SpecialException e)</span></span></span><br><span class="line"><span class="function">    <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        处理异常</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><ul><li>在方法声明处声明抛出</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span> <span class="title">A</span><span class="params">(int money)</span><span class="title">throws</span> <span class="title">SpecialException</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    if(--money&lt;=0)</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        throw new SpecialException("Out of money");</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><p>每次抛出异常之后，都要找到catch块，如果在当前方法中没有找到，那么它将会弹出栈帧，到了上一级继续寻找知道找到。找到之后就执行catch块内容然后退出。</p><p>如果到最底部也没有找到catch块，那么就调用异常对象的printStackTrace()方法，打印异常信息。</p><p>如果该线程不是主线程，那么就会退出这一个线程，如果是主线程（main），那么就会退出程序。</p><p>抛出异常和处理异常最好在同一方法，不然对性能影响较大。</p><h4 id="finally-在任何情况下都要执行的代码"><a href="#finally-在任何情况下都要执行的代码" class="headerlink" title="finally 在任何情况下都要执行的代码"></a>finally 在任何情况下都要执行的代码</h4><p>因为异常处理会打断正常进程，所以可能会导致一些占用的资源不会被释放。在c++中就是动态内存分配的问题，在java中额例如关闭数据库链接，关闭输入流。</p><p>finally跟在catch后面，并且一定不能在前面。</p><h4 id="throws-抛出可能的异常"><a href="#throws-抛出可能的异常" class="headerlink" title="throws 抛出可能的异常"></a>throws 抛出可能的异常</h4><p>如果一个方法需要抛出异常，但没有能力解决异常，可以在方法头声明throws语句，在前面已经举过例子了。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>try后面可以有多个catch块，只能有至多一个finally块，也可以只跟finally块。</li><li>在try块中定义的变量，在catch和finally中不能访问。</li><li>每当try后面有多个catch时，会依次对catch块进行匹配，只需要匹配同一继承分支上的父类就会执行。例如， IOException是Exception的子类，如果抛出IOExpception且Exception的catch块在前那么就只会执行Exception。例：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code1;<span class="comment">//抛出FileNotfoundException</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLExceptio e)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"SOLException"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Exception"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"IOException"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个只会输出Exception，因为Exception和FileNotFoundException在还有IOException在同一继承分支上，每一次直接走Exception了，而不会走IOException。<strong>所以让子类的catch在前面，防止错误的catch</strong>。</p><ul><li>为了简化，可以用 | 分隔两个异常在一个catch块中进行处理。例如 catch( FileNotFoundException | InterruptedIOException e){…}</li><li>如果一个地方出现受检查异常，要么用throws，要么用try，不然会出现编译错误（这样也就方便些try了，不然写代码的时候还真不好说哪里有异常）。</li></ul><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p>正常流程是捕捉异常，执行catch，执行finally，退出。有两种退出方式</p><p>第一种使用System.exit(number);这种方法会直接退出程序，</p><p>第二种是return，退出本方法，这个时候如果有返回值还可以弄个返回值以便其他部分正常运行。finally执行于return之前。一般return是在catch中的，但是也可以在finally中，但是这样可能会导致问题。</p><ul><li>返回值覆盖，因为catch执行于return之前，所以如果要执行catch中的return，会先执行finally中的return，这个时候catch中的return就不会执行了。</li><li>丢失异常，如果在catch中抛出异常且finally中有return就可能发生异常丢失。这个时候catch中的异常就不会被抛出。此外，如果catch和finally中都抛出异常，那么catch中的异常将会丢失。</li></ul><p>为了解决丢失异常的问题，Throwable接口中有两个默认实现的方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> addSuppressed(Throwable exception)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Throwable[] getSuppressed()</span><br></pre></td></tr></table></figure></div><p>其中addSuppressed()方法就是把丢失的异常保存下来，getSuppressed就是返回所有保存下来的异常。当然，并不是系统自动添加，还要手动用这些方法去添加。</p><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p>java中用类来描述异常。所有异常的祖先是java.lang.Throwable类。它的实例就是具体的异常，可以通过throw抛出。它提供了一些常用方法，包括</p><ul><li>getMessage() 返回String类型的异常信息</li><li>printStackTrace() 打印跟踪方法调用栈获得的详细异常信息</li></ul><p>例如catch到这个异常后，可以<code>System.out.println(e.getMessage())</code>来输出异常信息。例如e里面的信息时Out of money（就是前面的），那么就会输出这个异常信息。</p><p>而如果用后面那个方法，将会说明哪个类，哪一行出现了异常。</p><p><img src="/images/20160603151809323" alt="异常类图"></p><ul><li>Error类，表示单靠程序本身无法恢复的严重错误，例如内存不足，或者栈溢出。</li><li>Exception类，表示程序可以处理的异常。出现这些异常时，可以进行处理而不退出程序。</li><li>IOException 输入输出时产生的异常。</li><li>ArithmeticException 数学异常。例如除以0</li><li>NullpointerException，空指针异常。当引用变量时null是，试图使用这个变量将会出现。</li><li>IndexOutOfBoundsException 下标越界异常</li><li>ClassCastException 类型转换异常，例如父类转子类</li><li>IllegalArgumentException 非法参数，例如 if(name==null)throw new IllegalArgumentException(“姓名不能为空”)。</li></ul><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>RuntimeException一个子树都可以叫运行时异常。这种异常特点是编译器不会检查他。例如上面说的数学异常。当这种异常出现的时候程序将异常终止。其他的都是受检查异常。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>可以通过继承来实现自定义异常。一般挂在Exception或RuntimeException上。</p><p>自定义异常要一般要写以下部分。</p><p>异常数据，异常原因（String类型），然后是一个带参数的构造函数。之后提供方法说明这个异常。</p><h4 id="异常转义异常链"><a href="#异常转义异常链" class="headerlink" title="异常转义异常链"></a>异常转义异常链</h4><p>原始的异常对于用户来说看不懂，这个时候我们就要抛出一些更人性化的异常。但是与此同时我们也要把原始异常保存易于我们排错。这个时候我们就可以在原始异常上进行扩展。扩展类的数据域中可以来一个Throwable的引用变量，然后在构造函数中把原始异常导入。这样就保存了原始异常。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Throwable</span> cause = <span class="literal">null</span>;</span><br><span class="line">    public <span class="type">BaseException</span>();</span><br><span class="line">    public <span class="type">BaseException</span>(<span class="type">Throwable</span> cause)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">BaseException</span>(<span class="type">String</span> msg, <span class="type">Throwable</span> cause)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div><h4 id="处理多样化异常"><a href="#处理多样化异常" class="headerlink" title="处理多样化异常"></a>处理多样化异常</h4><p>就是一次性抛出多个异常，这就需要先自定义一个异常类，收集多种异常然后一次性输出。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> int size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">List</span>&lt;<span class="type">Throwable</span>&gt;exceptions = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="type">Throwable</span>&gt;();</span><br><span class="line">    public void addExcpetion(<span class="type">BaseException</span> ex)</span><br><span class="line">    &#123;</span><br><span class="line">        exceptions.add(ex);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>记录日志的作用：监视代码中变量情况，周期性的记录到文件中供其他应用统计分析。承担继承开发环境中调试器作用。</p><p>要在程序中输出日志，最普通的办法是用println输出。比较好的做法是用一个日志操作类。</p><p>现在可以直接使用java.util.logging日志操作包。这个包中主要有四个类</p><ul><li>Logger类：生成日志，并对日志信息分级筛选，确定什么等级被输出，什么不输出。</li><li>Handler： 负责输出日志信息。它有两个子类：ConcoleHandler（输出到Dos控制台），FileHandler（输出到文件中）</li><li>Level类： 表示日志各个界别。</li></ul><h4 id="创建及设置级别"><a href="#创建及设置级别" class="headerlink" title="创建及设置级别"></a>创建及设置级别</h4><p>创建 <code>Logger mylogger = Logger.getLogger(&quot;mylogger&quot;);</code></p><p>getlogger就是用来创建对象的。如果mylogger存在，那么直接返回引用。</p><p>级别： SEVERE(严重）， WARNING(警告），INFO , CONFIG(确认），FINE（好），CONFIG,FINE,FINER,FINEST</p><p>默认情况下，只会输出最高三个级别的。可以使用Logger类的setLevel()来设置级别。例：<code>mylogger.setLevel(&quot;Level.FINE&quot;)//把日志设置成FINE级别</code>。这样设置FINE及以上级别都会被设置。还有Level.on开启所有级别和Level.off关闭所有级别。</p><p><code>mylogger.info(&quot;这是一条普通提示消息&quot;)</code>用级别的名字设置提示消息</p><h4 id="输出日志到文件"><a href="#输出日志到文件" class="headerlink" title="输出日志到文件"></a>输出日志到文件</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileHandler fileHandler = <span class="keyword">new</span> <span class="constructor">FileHandler(<span class="string">"C:\\test.log"</span>)</span>;</span><br><span class="line">fileHandler.set<span class="constructor">Level(Level.INFO)</span>;<span class="comment">//设定向文件中写日志的级别</span></span><br><span class="line">mylogger.add<span class="constructor">Handler(<span class="params">fileHandler</span>)</span>;<span class="comment">//将FileHandler与Logger关联</span></span><br></pre></td></tr></table></figure></div><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>语法： assert 条件表达式 或 assert 条件表达式 : 包含错误信息的表达式。</p><p>作用： 当条件表达式为false时，会抛出AssertError，这是一个错误。如果后面有包含错误信息的表达式，那么将会输出后面的内容</p><p>例如： assert b!=0 : ”b不能为0“；</p><p>启用断言需要-ea参数，而IDEA中默认是关闭的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;异常处理流程&quot;&gt;&lt;a href=&quot;#异常处理流程&quot; class=&quot;headerlink&quot; title=&quot;异常处理流程&quot;&gt;&lt;/a&gt;异常处理流程
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="http://xinhecuican.github.io/post/5951da65.html"/>
    <id>http://xinhecuican.github.io/post/5951da65.html</id>
    <published>2020-04-23T08:39:00.000Z</published>
    <updated>2020-04-29T06:54:03.005Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="接口的基本特征"><a href="#接口的基本特征" class="headerlink" title="接口的基本特征"></a>接口的基本特征</h3><p>在java中接口有两种意思</p><ul><li>第一种是概念性的接口，指的是封装的内容对外界提供的服务（一开始一听接口一定以为就是这个吧）</li><li>第二种是一种接口类型</li></ul><p>定义接口使用interface关键字，实现接口使用implement关键字。这个类似于父类和子类。</p><p>注意点：</p><ul><li>接口成员变量默认是public或static或final类型的，必须显示初始化。例如<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> b;</span><br><span class="line">    <span class="built_in">int</span> c = <span class="number">3</span>;<span class="comment">//正确，显式初始化表示定义同时要赋值，并且默认是上面三种类型</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure></div></li><li>方法默认是public abstract类型。JDK8开始才可以有默认方法和静态方法之前只能有抽象方法。默认方法用<strong>default关键字</strong>声明，可以有自己的实现，接口实现类可以直接访问默认方法，也可以覆盖它。静态方法可以在接口内部访问或者实现接口的类通过使用接口名字来访问。<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span>;<span class="comment">//默认是public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method3</span>(<span class="params"></span>)</span>;<span class="comment">//编译器默认是public的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span>(<span class="params"></span>)</span>;<span class="comment">//不可以，必须要有abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li>接口没有构造方法，不能够被实例化</li><li>接口可以继承于多个接口，但是不能实现接口。例如：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">&#125;</span><br><span class="line">public<span class="built_in"> interface </span>B</span><br><span class="line">&#123;&#125;</span><br><span class="line">public<span class="built_in"> interface </span>C extends A,B</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>与子类继承抽象父类相似，当类实现某个接口时，<strong>必须要重写接口中的所有抽象方法，否则这个类必须定义成抽象类</strong>。</li><li>不允许创建接口的实例，但允许创建接口类型的引用变量，该变量引用实现了接口的类的实例（也可以看成是子类的实例）</li><li>一个类只能够继承一个父类，但可以实现多个接口。例如：<br><code>public class A extends Base implement intera, interb{...}</code>。并且一个接口也可以由多个类来实现。</li></ul><p>接口可以在一定程度上弥补一个类只能有一个直接父类的遗憾，有利于扩展。</p><h3 id="接口模式"><a href="#接口模式" class="headerlink" title="接口模式"></a>接口模式</h3><h4 id="定制服务模式"><a href="#定制服务模式" class="headerlink" title="定制服务模式"></a>定制服务模式</h4><p>这种模式就是利用接口可以继承多个接口，把多个子功能整合到一起变成一个大的服务。例如一个套餐里面有流量服务，电话服务，语音服务等等。这些都是一个接口。之后整合成整个的套餐包含上述服务</p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>适配器就是用来做两个系统之间转换的。有两种方式实现转换。</p><p>第一种就是通过继承，继承源类的实例和目标类的接口。</p><p>第二种是通过组合，组合两种类的接口，然后实现。</p><p>例如，一个接口有add（a,b)函数，另一个有addone(a)函数，第二个函数不能作用是让a+1，但是它没有加法（假设）。这时我们设计一个接口，继承上面两个接口，这样我们就有办法用原接口的实现类从而实现加法完成第二个方法。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>这种适配器其实是一个类，因为接口中都是抽象函数，所以当你使用适配器的时候不得不实现所有功能-即使你只想实现一个。所以干脆实现了一种类，这个类实现了所有抽象方法，但是内容全是空。这样再用其他类继承这个类就可以一次实现一种了。</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理人其实就是中间人，代理类和代理人类似，这个类负责预处理一些消息，例如钱少于多少就直接拒绝。也负责向委托类传递信息。</p><h4 id="标识类型模式"><a href="#标识类型模式" class="headerlink" title="标识类型模式"></a>标识类型模式</h4><p>标识类型一般是标识某一类事物。例如事物，树，人物等等。使用这种接口而不是直接使用一个类的好处是便于同一管理。</p><h4 id="常量接口"><a href="#常量接口" class="headerlink" title="常量接口"></a>常量接口</h4><p>常量接口就是把一些常量放到一起。要使用的时候直接implements就可以了。</p><p>但是这种接口有一个弊端，就是破坏了封装性。为了解决这个问题，可以使用import static语句。import static允许直接访问另一个类的静态常量</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;接口的基本特征&quot;&gt;&lt;a href=&quot;#接口的基本特征&quot; class=&quot;headerlink&quot; title=&quot;接口的基本特征&quot;&gt;&lt;/a&gt;接口的
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 继承和多态</title>
    <link href="http://xinhecuican.github.io/post/17862176.html"/>
    <id>http://xinhecuican.github.io/post/17862176.html</id>
    <published>2020-04-22T09:00:00.000Z</published>
    <updated>2020-05-05T09:00:02.070Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>利用extends来进行继承，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以上表明Sub类继承Base类，具体继承还要分两种情况。</p><ul><li>如果在同一个包中，那么Sub继承了Base中的public，protected和默认访问级别的成员变量和方法</li><li>如果在不同的包中，不继承默认访问级别的成员变量和成员方法，其他和上一个相同。</li></ul><p>默认访问级别就是前面没有加任何关键字。</p><p>java不支持多继承，一个类只能继承于一个类，但是父类可以有多个子类，就像一棵树。下级继承会继承同一分支上所有的成员和方法。</p><p>java中有一个所有类的祖先叫object类，如果没有使用extends关键字那么会自动继承这个类。</p><h3 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h3><p>覆盖指的是父类中的函数在子类中重新写。要满足下列条件：</p><ul><li>子类方法名称，函数签名（包括参数位置）和返回类型都要和父类方法一致</li><li>在子类中，必须要先覆盖函数，才可以重写函数</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Base类中：</span><br><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Sub</span>类中：</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">int</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">这样会报错</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果<span class="title">Sub</span>类这样</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">int</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function">这样可以编译通过</span></span><br></pre></td></tr></table></figure></div><ul><li>子类方法不可以缩小父类的访问权限，如果父类的方法时private那么子类就不能写public</li><li>子类不能抛出比父类更多的异常</li><li>子类无法覆盖父类的静态方法，只能够隐藏。这两者的区别是覆盖的话父类可以使用子类的，子类也可以使用父类的。隐藏的话父类只能使用父类的，子类只能使用子类的。这是由于static定义的区域所决定的。<br>例：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package newpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------</span><br><span class="line">package newpackage;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newsec</span> <span class="title">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Sub"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Sub"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base a = <span class="keyword">new</span> newsec();</span><br><span class="line">        a.method();</span><br><span class="line">        a.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出时Base和Sub</span><br></pre></td></tr></table></figure></div><ul><li>可以扩大访问权限。并且如果是抽象类，子类可以只扩大访问范围而不做任何事.但是必须要实现它，不然只能让子类也定义成抽象类。</li></ul><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">父类定义类A()的抽象方法，子类可以这样</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">这也算实现</span><br></pre></td></tr></table></figure></div><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super和this一样都是指向一个对象，不同的是super指向父类，this指向自己。</p><p>使用场合：</p><ul><li>局部变量和类变量重名</li><li>子类覆盖了父类的方法或成员变量时，可以用这种方法使用父类的方法</li></ul><p>需要注意，如果父类成员变量和方法被定义成private，那么子类无论如何都无法访问他们。不能再静态方法区使用super关键字。</p><p>此外如果在父类第一行使用super()是调用父类构造函数</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是父类可以使用子类，子类也可以使用父类（自我理解）。下面讲具体使用规范。<br>儿子可以用爸爸一切公有的，而爸爸如果引用了自己的实例就不能用儿子的，只有引用了儿子的实例才可以使用儿子继承于爸爸的。</p><ul><li>对于一个引用类型变量，编译器按声明变量进行处理。例如</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Base </span>who = new <span class="keyword">Sub();</span></span><br><span class="line"><span class="keyword">who.subVar </span>= <span class="string">"123"</span>;</span><br><span class="line">这里编译会出错，无论后面引用了谁，who都是<span class="keyword">Base类，而父类不能直接使用子类的变量</span></span><br></pre></td></tr></table></figure></div><ul><li><p>编译器允许继承分支关系的类进行类型转换。对于向上转型（子类使用父类的），编译器会自动类型转换。对于向下转型则需要强制类型转换。在运行时，子类可以转换成父类，但是父类实际上无法转换成子类。因为父类有的子类一定有，子类有的父类却不一定有。</p></li><li><p>对于引用对象绑定，遵循如下规则</p><ol><li>对于实例方法和引用变量是由实际使用的对象进行绑定。这个是动态的，也就是说方法的实际输出是由实际类型所决定。例如 Base a = new Sub();输出时Sub的。如果这个时候Sub的子类b = a;那么输出还是Sub的。但是如果使用了子类中独有的方法会报错</li><li>静态方法和成员变量由前面定义的类型所决定，这属于静态绑定，在编译时期已经决定。无论引用了谁都不会改变。</li></ol></li></ul><h3 id="继承的使用"><a href="#继承的使用" class="headerlink" title="继承的使用"></a>继承的使用</h3><p>继承树的最上层一般是抽象层。并且继承树上有接口类型，那么尽可能的把应用变量声明成继承树上层的接口类型。因为实例可以是子类，向上转型不会出现问题，这样便于使用多个子类，如果想用子类独有的东西就把引用变量定义成子类。</p><p>继承关系会打破封装，因为上层类改变会使下层类也跟着改变。所以对上层类定义要谨慎。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><table><thead><tr><th>修饰符</th><th>类</th><th>成员方法</th><th>构造方法</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>abstract（抽象的）</td><td>有</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>static（静态的）</td><td>无</td><td>有</td><td>无</td><td>有</td><td>无</td></tr><tr><td>public</td><td>有</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>protected</td><td>无</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>private</td><td>无</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>synchronized（同步的）</td><td>无</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>native（本地的）</td><td>无</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>transient（暂时的）</td><td>无</td><td>无</td><td>无</td><td>有</td><td>无</td></tr><tr><td>volatile（易失的）</td><td>无</td><td>无</td><td>无</td><td>有</td><td>无</td></tr><tr><td>final（不可改变的）</td><td>有</td><td>有</td><td>无</td><td>有</td><td>有</td></tr></tbody></table><p>表中的类指的是顶层类，与内部类相对应（内部类是定义在类或方法中的类）。</p><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><p>访问控制指的是其他类或对象可以查看的东西。一共有四种访问级别</p><ul><li>public 所有都是可以给外部看的</li><li>protected 只对子类和一个包中的类公开</li><li>默认级别 没有修饰符 只对同一个包中的类公开，不对子类公开</li><li>private 不对外公开</li></ul><p>public&gt;protected&gt;默认&gt;private。public与其他不同是其他包也可以查看</p><p>顶层类只能是public或protected，不然会出现编译错误。</p><p>访问级别是对成员变量和类来说的，对局部变量没有意义，局部变量的访问范围就是方法内部。</p><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p>用abstract修饰的类表示抽象类，抽象类不允许实例化，也就是抽象类不允许创建实例</p><p>用abstract修饰的方法表示抽象方法，抽象方法内部没有内容，只有一个函数头。</p><p>注意，如果有抽象方法，这个类必须定义成抽象类。此外，没有抽象静态方法，abstract和static是互相矛盾的。</p><p>抽象类本身不可以实例化，但是可以创建一个抽象类的引用变量然后引用具体类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base a = <span class="keyword">new</span> <span class="type">Base</span>();<span class="comment">//不可以，因为Base是抽象类</span></span><br><span class="line">Base b = <span class="keyword">new</span> <span class="type">Sub</span>(); <span class="comment">//Sub是具体类</span></span><br></pre></td></tr></table></figure></div><p>抽象方法不可以用private修饰，因为抽象出来本来就是要让子类去实现的，private一下子类就无法使用了。</p><p>子类必须实现抽象类的所有抽象方法。</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final有不可改变的含义。</p><p>用final修饰的类不能被继承，没有子类</p><p>用final修饰的方法不能被覆盖</p><p>final修饰的变量表示常量，只能赋一次值</p><p>final不能用来修饰构造方法。</p><p>final修饰引用变量，这个变量不能只能引用一个实例，但是可以对这个实例进行修改。</p><p>不允许覆盖就是不能用相同的函数签名去重写这个函数</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul><li>static修饰的成员变量时静态变量，可以直接通过类名进行访问，并且所有实例共用一个静态变量</li><li>修饰成员方法表示静态方法，可以直接通过类名访问</li><li>修饰的程序代码块叫做静态代码块，加载类时会执行这些代码块</li></ul><p>静态变量只有一份备份，处于方法区，在加载类的时候随之加载。</p><p>注意，在静态方法中没办法用this，因为静态方法时所有类共有的，this表示的是某个特定的类。所以在main方法中不能用this和super，因为main是static的，如果想访问这个类的内容，可以先定义一个该类的引用变量。</p><p>如果直接访问了，编译器会报<strong>在静态方法内不允许访问非静态变量</strong>。</p><p>main函数必须是static的原因是只要加载了main所在的类main就被加载了，可以直接去执行，不然还要先创建一个类然后使用main方法。</p><p>类中可以包含一些静态代码块，这些代码块不存在与任何方法中，加载类时一次执行这些代码块。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"First Static code i="</span> + i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>static代码块和静态方法一样，不可以直接调用实例变量和实例方法，只用通过先引用之后才可以进行调用。</p><h5 id="static进行静态导入"><a href="#static进行静态导入" class="headerlink" title="static进行静态导入"></a>static进行静态导入</h5><p>静态导入类似于c++中的using namespace std;可以简写代码。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">import</span>.<span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out.<span class="built_in">println</span>(MIN_VALUE);<span class="comment">//原来是Integer.MIN_VALUE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>但是如果静态导入过多，可能会导致冲突，因此尽量导入的时候具体一点。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
</feed>
