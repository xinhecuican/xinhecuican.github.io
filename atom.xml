<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinhecuican&#39;s Blog</title>
  
  
  <link href="http://xinhecuican.github.io/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-12-06T10:02:11.615Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>星河璀璨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内联汇编</title>
    <link href="http://xinhecuican.github.io/post/51e63dcf.html"/>
    <id>http://xinhecuican.github.io/post/51e63dcf.html</id>
    <published>2020-12-06T08:49:00.000Z</published>
    <updated>2020-12-06T10:02:11.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><p>内联汇编是在c语言代码中插入一段汇编语言，这在一些特殊的场合如操作系统中经常使用。有些时候我们想加快速度或者进行某些特殊的操作就可以使用内联汇编。</p><h1 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h1><blockquote><p><strong>关键字</strong>： asm</p></blockquote><p>例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;movl %eax, %ebx&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，<strong>volatile</strong>的含义是告诉编译器这段代码不需要优化，原封不动的让他执行。</p><p>语法：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">asm(</span><br><span class="line">   汇编语言模板</span><br><span class="line">   : output operands <span class="regexp">/*可选*/</span></span><br><span class="line">   : input operands <span class="regexp">/*可选*/</span></span><br><span class="line">   : options     <span class="regexp">/*可选*/</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以只有output operands或只有input operands。但是如果有options，那么前面两个冒号都要打.</p><p>options表示我们最多使用哪些寄存器。</p><h2 id="汇编模板"><a class="markdownIt-Anchor" href="#汇编模板"></a> 汇编模板</h2><p>可以使用<a href="https://xinhecuican.github.io/post/1326.html">AT&amp;T语法</a>，也可以使用intel语法（没有测试过）。下面以AT&amp;T模板作为例子。</p><p>它的语法和和汇编语言完全类似，同样是寄存器用%，立即数用$, 内存访问用<code>()</code>。</p><p><strong>注意</strong>：</p><ul><li>如果有多行汇编语句，那么语句与语句之间要用\n\t分隔开</li><li>如果使用了%0,%1等标识，那么寄存器就需要用两个%%标识</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;movl %0, %%eax\n\t&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;pushl %%eax\n\t&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    :<span class="string">&quot;a&quot;</span>(a)</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="输出和输入部分"><a class="markdownIt-Anchor" href="#输出和输入部分"></a> 输出和输入部分</h2><p>他们的格式都是 <code>&quot;restriction&quot;(value)</code>，其中restriction表示这个变量要使用哪个寄存器或者表示内存或者是立即数。而value就是外带的变量。</p><p>如果是输出部分，在restricttion前还要加个等号。如 “=a”(output)</p><p>在定义了输入和输出部分之后，就可以把这些变量用于汇编语句中了。我们可以用%0,%1…%9表示变量。也就是说最多有是个输入输出部分。例如</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">input</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">output</span> = <span class="number">1</span>;</span><br><span class="line">asm volatile(</span><br><span class="line">    <span class="string">&quot;addl %1, %0&quot;</span></span><br><span class="line">    :<span class="string">&quot;=r&quot;</span>(<span class="keyword">output</span>)</span><br><span class="line">    :<span class="string">&quot;r&quot;</span>(<span class="keyword">input</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面就是一个简单的1+1并且把值赋到output中。output是第0个，input第第一个，所以%0表示output,%1表示input.</p><h2 id="限制"><a class="markdownIt-Anchor" href="#限制"></a> 限制</h2><p>输入输出部分前面的限制有很多，这里列举一些常用的</p><table><thead><tr><th>限制</th><th>作用</th></tr></thead><tbody><tr><td>a</td><td>表示 eax,ax,ah,al</td></tr><tr><td>b</td><td>表示 ebx, …</td></tr><tr><td>c</td><td>表示 ecx, …</td></tr><tr><td>d</td><td>表示 edx, …</td></tr><tr><td>S</td><td>表示 esi</td></tr><tr><td>D</td><td>表示 edi</td></tr><tr><td>r</td><td>指定任意一个寄存器</td></tr><tr><td>m</td><td>表示内存</td></tr><tr><td>p</td><td>表示操作数是一个指针</td></tr><tr><td>X</td><td>可以是任意类型</td></tr><tr><td>i</td><td>立即数</td></tr><tr><td>数字0,1,2,…</td><td>表示这个操作数和前面的某个操作数相同，一般在输入和输出在同一个变量时使用</td></tr><tr><td>f</td><td>浮点数</td></tr><tr><td>&amp;</td><td>避免使用同一个寄存器</td></tr></tbody></table><p>访问内存方式：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> input = <span class="number">0x7fffffc</span>;</span><br><span class="line">asm <span class="keyword">volatile</span>(</span><br><span class="line">    &quot;movl %%eax, (%0)&quot;</span><br><span class="line">    : &quot;r&quot;(<span class="keyword">input</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">input = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">asm <span class="keyword">volatile</span> (&quot;addl %1,%0&quot;:&quot;+r&quot;(result):&quot;m&quot;(<span class="keyword">input</span>));</span><br></pre></td></tr></table></figure><p>一个具体应用</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void (*handler)();</span><br><span class="line"><span class="function"><span class="title">handler</span> = myproc()-&gt;</span><span class="function"><span class="title">tf</span>-&gt;</span>handler;</span><br><span class="line">uint addr = (uint)*handler;</span><br><span class="line"><span class="function"><span class="title">myproc</span>()-&gt;</span><span class="function"><span class="title">tf</span>-&gt;</span>esp -= <span class="number">4</span>;</span><br><span class="line">asm volatile(</span><br><span class="line">    <span class="string">&quot;movl %0, (%1)\n\t&quot;</span></span><br><span class="line">    : <span class="string">&quot;r&quot;</span>(<span class="function"><span class="title">myproc</span>()-&gt;</span><span class="function"><span class="title">tf</span>-&gt;</span><span class="function"><span class="title">eip</span>), &quot;r&quot;(myproc()-&gt;</span><span class="function"><span class="title">tf</span>-&gt;</span>esp)</span><br><span class="line">);</span><br><span class="line"><span class="function"><span class="title">myproc</span>()-&gt;</span><span class="function"><span class="title">tf</span>-&gt;</span>eip = addr;</span><br><span class="line"></span><br><span class="line">这段代码的作用是位于内核态时跳转到某一个函数，并且结束之后返回，asm中就是将返回地址存入栈中。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="c++" scheme="http://xinhecuican.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="http://xinhecuican.github.io/post/1b9c8662.html"/>
    <id>http://xinhecuican.github.io/post/1b9c8662.html</id>
    <published>2020-11-23T23:40:00.000Z</published>
    <updated>2020-11-29T03:12:21.858Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="文件"><a class="markdownIt-Anchor" href="#文件"></a> 文件</h1><h2 id="文件的结构和类型"><a class="markdownIt-Anchor" href="#文件的结构和类型"></a> 文件的结构和类型</h2><p>文件在系统中其实就是一串二进制数，结尾有特殊的符号标识，而他的入口处由操作系统管理。</p><p>在linux系统中，文件的类型有目录文件，一般文件和特殊文件（如设备文件）等，这些文件在内容组织上各不相同，但是他们的基础构成还是上面说的。</p><h2 id="查找文件"><a class="markdownIt-Anchor" href="#查找文件"></a> 查找文件</h2><p>首先在linux中文件通过树形结构进行组织，在找到对应目录下的文件后就要打开文件了。linux目录中存放的i节点表，i节点中存放着一些文件的信息和文件的入口地址。</p><p><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F1.PNG" alt="" />如图就是一些文件的属性，操作系统会根据自身需要选取某些属性。</p><p><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2.PNG" alt="" />这个图中就是i节点的结构，注意Point to Block data就是在磁盘中的位置</p><h2 id="文件在磁盘中的储存"><a class="markdownIt-Anchor" href="#文件在磁盘中的储存"></a> 文件在磁盘中的储存</h2><ul><li>第一种方法时每个文件在磁盘中有固定的位置，当然这种方法是不可行的，因为这样必须事先分配好大小，如果达到了事先分配的最大值后就无法继续增大。</li><li>第二种方法是通过一个链表组织。这种方法中链表在磁盘的前几个字节，然后i节点指向入口地址。它的缺点是如果想访问后面的节点必须把前面节点都扫一遍，并且因为他在磁盘中占有了位置，所以现在磁盘中所能容纳的文件字节数减少了，需要重新考虑对齐的问题。</li><li>第三种方法是在i节点中增加15*4个字节。它是12+1+1+1的结构。低12字节保存第0到11块的入口地址（如果一块大小矢1k的话，那么0-12k地址内容可以通过低12字节访问）。而第12个字节保存到下一个链表的指针，这个链表大小就是一页大小，也就是说保存着从12k开始到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><mo>+</mo><mn>1024</mn><mo>∗</mo><mo stretchy="false">(</mo><mfrac><mn>1024</mn><mn>4</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">12+ 1024*(\frac{1024}{4})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>位置的数据。同样第13字节有两个页表，那么它保存着 1024 * 1024/4 * 1024/4大小的数据。以此类推,第二个图展示了它的结构</li></ul><p><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F3.PNG" alt="" /><br /><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F4.PNG" alt="" /></p><h1 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h1><p>不同的操作系统中有不同的文件系统。</p><ul><li>linux： minix, ext2, ext3, ext4, reiserFS, IBMJFS, xfxs</li><li>windows: FAT-16, FAT-32, FAT-12, exFat， NTFS</li></ul><p>不同的文件系统不一定兼容，下面以ext2作为例子来说明文件系统的结构。</p><p><strong>磁盘</strong>被分为若干块，它的大小可以是1024， 2048， 4096等等。磁盘块的大小是由操作系统决定的。</p><p><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F5.PNG" alt="" /></p><ul><li>超级块（superblock）是文件系统中的第一个块，其中存放着文件系统的一些信息如文件系统的根目录，挂载点，空闲块指针，空闲i节点指针。超级块坏了文件系统就坏了。</li></ul><blockquote><p>为了保证超级块坏的时候文件系统不至于崩溃，超级块一般由多个备份。</p></blockquote><ul><li>i节点和间接i节点表。这两个作用在上面说了</li><li>数据块（data Block)真正存储数据的块</li></ul><h2 id="空数据块位置"><a class="markdownIt-Anchor" href="#空数据块位置"></a> 空数据块位置</h2><p>每次操作系统想分配空间给一个文件时，首先要知道空的数据块在哪。</p><ul><li>一种办法是使用一个链表来维护空数据块，这种办法的问题是消耗太大</li><li>另一种办法是使用位图法，因为块是有编号的，如果对应位置是1表示不是空的。<img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F6.PNG" alt="" /></li></ul><h2 id="文件系统的创建和挂载"><a class="markdownIt-Anchor" href="#文件系统的创建和挂载"></a> 文件系统的创建和挂载</h2><p>可以使用<strong>mkfs</strong>命令进行文件系统的创建</p><blockquote><p><code>mkfs [-t type] [fs-options] &lt;device&gt; size</code></p></blockquote><p>例： mkfs -t ext4 /dev/sda6</p><p><strong>mount</strong>命令进行文件系统的挂载</p><p><a href="https://xinhecuican.github.io/post/35532.html">此命令可以看这篇文章中目录部分</a></p><p>例： mount /dev/lv100 /home/patsie</p><p><strong>注意</strong>：不同文件系统中i节点是不一样的，挂载时经历了一些转换过程，这时可以看到挂载进来的内容，但是该目录下原有内容被隐藏了，只有使用卸载命令<strong>umount</strong>才可以重新看到原有内容。</p><h1 id="磁盘及卷组管理"><a class="markdownIt-Anchor" href="#磁盘及卷组管理"></a> 磁盘及卷组管理</h1><p><a href="https://xinhecuican.github.io/post/7d1c86da.html">有关磁盘基础结构请看</a></p><p>首先磁盘分区有两种，分别是MBR和GPT（也就是C盘D盘之类的）</p><ul><li>MBR（Master Boot Record):<ul><li>位于第一个扇面</li><li>支持4个主分区，加上扩展分区最多也就支持32个分区</li><li>一个分区最大2T</li></ul></li><li>GPT（GUID Partition table):<ul><li>理论支持无限多个分区（实际上操作系统会限制）</li><li>最大支持18EB</li><li>需要操作系统支持和主板支持EFI/UEFI</li></ul></li></ul><p>直接磁盘分区有很多问题</p><ol><li>磁盘分区大小是固定的，很难改变（除非格式化）</li><li>受文件系统大小的限制（因为文件系统无法跨越设备，所以分区也不可以）</li><li>需要提前考虑大小</li></ol><p>LVM（逻辑卷管理）就是为了克服这些问题而产生的。他将物理设备分为若干物理卷，然后使用逻辑卷进行管理和分区。</p><blockquote><p>物理储存介质： 如磁盘等，在linux上是/dev/sda等设备文件<br />物理卷(PV): 相当于一个个磁盘分区，但是分区大小固定并且还有一些与LVM相关参数<br />卷组（VG）： 多个物理卷组成的储存池，也就是说可以让文件系统跨设备<br />逻辑卷（LV）： 从卷组中分出一些卷进行管理，可以在上面划分分区</p></blockquote><p><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F7.PNG" alt="" /></p><p><strong>一些linux命令</strong></p><ul><li>fdisk： 创建分区 例如 fdisk /dev/sda</li><li>pvcreate:创建物理卷</li><li>vgcreate: 创建卷组 例如： vgcreate vg0 /dev/sda6(sda6是一个物理卷）</li><li>vgextend: 扩展卷组 例如： vgextend vg0 /dev/sdb1</li><li>lvcreate: 创建逻辑卷 例如： lvcreate -L 10G -n lv0 /dev/vg0（名字是lv0，大小是10G）</li><li>mkfs： 创建文件系统，现在是在逻辑卷中创造</li><li>lvextend: 扩大逻辑卷</li><li>resize2fs： 扩大文件系统</li><li>umount： 卸载文件系统，为减小大小做准备。</li><li>lvreduce： 减小逻辑卷大小。<strong>首先要减小文件系统大小，使用resize2fs命令</strong></li></ul><p>这些命令基本按照顺序把文件系统创建和增删过程说了出来。</p><p>基本过程： 创建硬盘分区-&gt;创建逻辑卷-&gt;创建卷组-&gt;创建逻辑卷-&gt;创建文件系统</p><p>扩大物理卷-&gt;扩散卷组-&gt;扩大逻辑卷-&gt;扩大文件系统</p><p>减小文件系统-&gt;减小逻辑卷…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>抽样分布定理证明</title>
    <link href="http://xinhecuican.github.io/post/74e7fdff.html"/>
    <id>http://xinhecuican.github.io/post/74e7fdff.html</id>
    <published>2020-11-18T11:02:00.000Z</published>
    <updated>2020-12-03T01:44:02.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>定理 ：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mi>S</mi><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{(n-1)S^{2}}{\sigma^{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4539199999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10892em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><strong>证明</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mi>S</mi><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo>+</mo><mi>μ</mi><mo>−</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mfrac><mn>1</mn><msup><mi>σ</mi><mn>2</mn></msup></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mfrac><mn>1</mn><msup><mi>σ</mi><mn>2</mn></msup></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mfrac><mn>1</mn><msup><mi>σ</mi><mn>2</mn></msup></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mi>n</mi><mo stretchy="false">(</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mfrac><mn>1</mn><msup><mi>σ</mi><mn>2</mn></msup></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mi>n</mi><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac><mo>−</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac><mo>−</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><msup><mi>σ</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><msqrt><mi>n</mi></msqrt></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\frac{(n-1)S^2}{\sigma^2} =&amp; \sum_{k=1}^n\frac{(x_i-\overline{x})^2}{\sigma^2}\\    =&amp; \sum_{k=1}^n\frac{(x_i - \mu +\mu - \overline{x})^2}{\sigma^2}\\    =&amp;\frac{1}{\sigma^2} \sum_{i=1}^{n}(( x_i-\mu)^2 - 2(x_i-\mu )(\bar{x} - \mu) + (\bar{x}-\mu)^2)\\=&amp; \frac{1}{\sigma^2} \sum_{i=1}^{n}( x_i-\mu)^2 - 2(\bar{x} - \mu)\sum_{i=1}^{n}(x_i-\mu ) + \sum_{i=1}^{n}(\bar{x}-\mu)^2\\=&amp; \frac{1}{\sigma^2} \sum_{i=1}^{n}( x_i-\mu)^2 - 2(\bar{x} - \mu)n(\frac{1}{n}\sum_{i=1}^{n}x_i -\mu\times n)+ \sum_{i=1}^{n}(\bar{x}-\mu)^2\\=&amp; \frac{1}{\sigma^2} \sum_{i=1}^{n}( x_i-\mu)^2 - 2n(\bar{x} - \mu)^2+ \sum_{i=1}^{n}(\bar{x}-\mu)^2\\    =&amp; \sum_{k=1}^n\frac{(x_i - \mu)^2}{\sigma^2} -\sum_{k=1}^n\frac{(\overline{x}-\mu)^2}{\sigma^2}\\    =&amp; \sum_{k=1}^n\frac{(x_i - \mu)^2}{\sigma^2} - \frac{n(\overline{x}-\mu)^2 }{\sigma^2}\\    =&amp; \sum_{k=1}^n\frac{(x_i - \mu)^2}{\sigma^2} - \frac{(\overline{x}-\mu)^2}{\sigma^2 / \sqrt{n}}\\\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:29.18381399999999em;vertical-align:-14.341906999999996em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:14.841906999999997em;"><span style="top:-16.841906999999996em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span><span style="top:-13.588396999999997em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-10.334886999999998em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-7.105820999999999em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-3.8767549999999993em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-0.6476889999999995em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:2.581377em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:5.834886999999998em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:9.088396999999997em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:14.341906999999996em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:14.841906999999997em;"><span style="top:-16.841906999999996em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-13.588396999999997em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-10.334886999999998em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-7.105820999999999em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.8767549999999993em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-0.6476889999999995em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">ˉ</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:2.581377em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:5.834886999999998em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:9.088396999999997em;"><span class="pstrut" style="height:3.6513970000000002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.30972em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9402800000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:14.341906999999996em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><msup><mi>σ</mi><mn>2</mn></msup></mfrac><mo>∼</mo><msubsup><mi>X</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sum_{k=1}^n\frac{(x_i - \mu)^2}{\sigma^2} \sim X_{n}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9535100000000005em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><msup><mi>σ</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><msqrt><mi>n</mi></msqrt></mrow></mfrac><mo>∼</mo><msubsup><mi>X</mi><mn>1</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\frac{(\overline{x}-\mu)^2}{\sigma^2 / \sqrt{n}} \sim X_1^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.431388em;vertical-align:-0.9402800000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.30972em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9402800000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mi mathvariant="normal">与</mi><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">(x_i - \mu)^2 与 \overline{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">与</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>相互独立，所以根据卡方分布可加性可得服从于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">X_{n-1}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1205469999999997em;vertical-align:-0.30643899999999996em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-2.451892em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30643899999999996em;"><span></span></span></span></span></span></span></span></span></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;定理 ：&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;k</summary>
      
    
    
    
    <category term="数学" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="概率论" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>回溯法和分支限界法</title>
    <link href="http://xinhecuican.github.io/post/a50b8908.html"/>
    <id>http://xinhecuican.github.io/post/a50b8908.html</id>
    <published>2020-11-09T08:25:00.000Z</published>
    <updated>2020-11-18T06:00:10.608Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="回溯法"><a class="markdownIt-Anchor" href="#回溯法"></a> 回溯法</h1><h2 id="回溯法概念"><a class="markdownIt-Anchor" href="#回溯法概念"></a> 回溯法概念</h2><p>回溯法是一种能避免不必要搜索的穷举式算法，适用于一些解空间相当大的问题。</p><p>它经常呈现一种树形结构，先进入左节点，当到了底部或者条件不满足时返回父节点并进入右节点。一个典型的例子就是<a href="https://xinhecuican.github.io/post/37663.html">深度优先搜索</a></p><p>如果不加限制条件直接搜索的话复杂度将是2^n。因此我们需要添加一些限界函数来减小搜索量。</p><p>限界函数一般有两个，一个是用来限制左支的，叫显式约数条件。另一种是限制是否搜索右支的，叫隐式约束条件。</p><h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2><h3 id="01背包问题"><a class="markdownIt-Anchor" href="#01背包问题"></a> 01背包问题</h3><p><a href="https://xinhecuican.github.io/post/21624.html">01背包问题</a>最常见的办法是动态规划算法.这里介绍回溯法求解</p><ol><li>将物品按密度进行排序</li><li>设bestp是当前最好收益并初始化为负无穷</li><li>设bound = cp+r是效益值的上界。其中cp是这个节点的收益值，r是剩下所有物品的连续背包问题收益值（也就是说不满一件也可以装进去）</li><li>展开左子节点：<ul><li>如果$$cw+Wk &lt;= c$$, 则装入k,且cw += Wk, cp += pk Xk = 1(说明这个节点使用了）</li></ul></li><li>否则展开右节点：<ul><li>如果bound &lt;= bestp。则停止展开右子树（就算把剩余物品都放进去也抵不上它的收益）。否则就 xk = 0,然后继续搜索</li></ul></li></ol><p><img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%951.PNG" alt="" /></p><h3 id="货箱装船问题"><a class="markdownIt-Anchor" href="#货箱装船问题"></a> 货箱装船问题</h3><p><strong>问题</strong>：给定载重量为 c 的货船，找一种装船的方法，使得装载的货箱数目最多。</p><p><strong>分析</strong></p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">设<span class="keyword">cw</span>是已装载货物重量</span><br><span class="line"></span><br><span class="line">显式限界条件： 如果<span class="keyword">cw</span>+w(i) &gt; maxw 则杀死该左节点。</span><br><span class="line">隐式限界条件： 如果<span class="keyword">cw</span>+r &lt;= bestw，则停止展开右节点。r是剩余货物的重量。</span><br></pre></td></tr></table></figure><h1 id="分支限界法"><a class="markdownIt-Anchor" href="#分支限界法"></a> 分支限界法</h1><p>分支限界法也是一种穷举搜索算法。但是同样可以通过限界函数进行限界。一个典型例子就是广度优先搜索。</p><h2 id="旅行商问题"><a class="markdownIt-Anchor" href="#旅行商问题"></a> 旅行商问题</h2><p>首先说一下归约矩阵。</p><ul><li>行规约矩阵：找到每一行最小的数，然后让这一行都减去最小的数。</li><li>行规约数： 每一行最小的数求和</li><li>归约矩阵： 每一行做归约后每一列再做归约。归约数就是行规约数加上列归约数</li></ul><p>归约矩阵的性质：</p><ul><li>每一行每一列都必须有一个0</li><li>对于旅行商问题， 它的结果就是在归约矩阵中得到的结果加上归约数 W(f) = w’(f)+h</li></ul><p>例：<img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%92%8C%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%951.PNG" alt="" /><br /><img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%92%8C%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%952.PNG" alt="" /></p><p>其中q12表示A’矩阵中第一行第二列的点，表示我们要先从1到2.</p><p>之后的h’表示去掉这一行这一列和qji为无穷后的矩阵的归约值。因为我们到过这个节点之后这一行这一列都不会再有点了，所以可以去掉。另外如果不是导数第二个节点的话也不可能回到起点。</p><p>找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>的最小值后以这个点作为起始点除去这一行这一列进行下一步搜索。<br /><img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%92%8C%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%953.PNG" alt="" /></p><p>之后一直重复上述步骤直到搜索完成。</p><p>使用行规约矩阵的目的在于提前知道一些信息来进行分支限界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;回溯法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;</summary>
      
    
    
    
    <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>进程与线程</title>
    <link href="http://xinhecuican.github.io/post/eefe591f.html"/>
    <id>http://xinhecuican.github.io/post/eefe591f.html</id>
    <published>2020-10-23T10:36:00.000Z</published>
    <updated>2020-12-14T07:50:23.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>进程是正在运行的程序，它包含代码和执行状态（栈堆寄存器等）。而程序仅仅是一些静态的代码。一个程序可以生成多个进程（如记事本进程）。进程是资源分配最小单元</p><h1 id="linux系统进程"><a class="markdownIt-Anchor" href="#linux系统进程"></a> Linux系统进程</h1><p>Linux进程是采用进程树的方式。程序开始时创建一个零号进程，然后零号进程创建一号进程再由一号进程创建其他的进程。linux进程是一种树状结构，可以通过pstree命令查看进程树。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">sys/types.h：储存了一些宏定义如<span class="keyword">pid_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>fork():创建当前进程的子进程，并且子进程和当前进程完全相同。</p></blockquote><p>返回值：返回两个返回值，如果返回值是零，代表当前在子进程中。如果返回值&gt;0,代表在父进程中并且返回值是子进程pid，如果返回值&lt;0,代表出错。</p><p><strong>注意</strong>： 这里复制子进程是采用copy on right的方式，即开始子进程与父进程完全相同，只有当子父进程之间有差异时才会额外开辟空间储存差异。</p><p>例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is the child process\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is the parent process\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getpid(): 获得pid</p></blockquote><blockquote><p>exec家族， 用于在子进程中调用系统中有的函数</p></blockquote><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> execl(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> execv(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> execle(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> execve(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> execlp(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> execvp(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span><br><span class="line"></span><br><span class="line">其中有p的代表会自动在系统路径中搜索，例如</span><br><span class="line">execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot; -l&quot;</span>, <span class="literal">NULL</span>)会执行ls -l指令，如果没有p，则需要/bin/ls</span><br><span class="line"></span><br><span class="line">v代表传入一个数组，这个字符数组加起来就是命令，最后以<span class="literal">NULL</span>结尾</span><br><span class="line"></span><br><span class="line">e代表绝对地址</span><br></pre></td></tr></table></figure><blockquote><p>int wait(int *status)： 会阻塞当前进程，直到找到了僵尸子进程（死了的子进程），之后就彻底杀死子进程并返回进程号，失败会返回-1。status可以设置成NULL，</p></blockquote><blockquote><p>pid_t waitpid(pid_t pid,int *status,int options): pid是子进程进程号，表示只等待这一个子进程，其他子进程终止仍处于阻塞状态。</p></blockquote><p>options有：</p><ul><li>WNOHANG(wait no hung)： 即使没有子进程退出，它也会立即返回</li><li>Returns information about a child process stopped by SIGTTIN,<br />SIGTTOU, SIGSSTP, and SIGTSTOP signals.(返回子进程被某些信号而停止的信息）</li></ul><h2 id="进程的状态"><a class="markdownIt-Anchor" href="#进程的状态"></a> 进程的状态</h2><p>进程的状态一般可以分为三大类：运行，就绪，阻塞。</p><p><strong>运行</strong>状态是指正在cpu中执行指令的进程。</p><p><strong>就绪</strong> 是指获得了除cpu意外所有资源，正在等待cpu的进程</p><p><strong>阻塞</strong> 是指因为某些原因放弃争夺cpu的进程</p><h2 id="进程的调度"><a class="markdownIt-Anchor" href="#进程的调度"></a> 进程的调度</h2><h3 id="批处理系统中的调度"><a class="markdownIt-Anchor" href="#批处理系统中的调度"></a> 批处理系统中的调度</h3><p>批处理系统就是不具备交互性，单纯完成任务的系统。这种系统一般需要考虑提高cpu利用率（早期计算机使用批处理系统）。批处理系统中的任务一般相对固定，所以可以大致知道它所需要花费的时间。</p><h4 id="先来先服务"><a class="markdownIt-Anchor" href="#先来先服务"></a> 先来先服务</h4><p>指的是先来的任务先进行服务，这种方式最大的问题是单位时间内可以执行的任务数量比较低。如果一个任务时间很短而前面有一个需要大量时间的任务，那么他将不得不花很长的时间去等待。</p><h4 id="最短时间优先"><a class="markdownIt-Anchor" href="#最短时间优先"></a> 最短时间优先</h4><p>指的是时间短的进程先来服务。但是这种方式可能让时间长的进程一直无法执行（如果中间一直插入时间短的进程的话）</p><h4 id="高响应率优先"><a class="markdownIt-Anchor" href="#高响应率优先"></a> 高响应率优先</h4><p>这种方法考虑了等待时间的影响，是对最短时间优先的改进。</p><p>响应率 = 1 + 等待时间/完成任务需要时间</p><p>通过比较响应率，响应率高的先执行。</p><p>这种方法考虑了时间的影响，在时间短的进程先运行的同时不会让长进程无限制的等待。</p><h3 id="交互式系统中的调度"><a class="markdownIt-Anchor" href="#交互式系统中的调度"></a> 交互式系统中的调度</h3><p>交互式系统就是现在微机所使用的系统，在系统中需要运行的进程一般有很多，因此需要不停的将进程调入调出来让使用者感觉上进程是并行执行的。因此需要规定一个时间片避免进程无限制的执行。时间片到了会强制将当前进程调出然后从进程池中调入一个新的进程。在windows系统中时间片是15ms，linux系统中时间片是10ms</p><h4 id="轮转调度"><a class="markdownIt-Anchor" href="#轮转调度"></a> 轮转调度</h4><p>轮转调度是使用一个队列，运行完的进程放到队列的尾部，然后从队列的首部拉入一个进程执行。这种方法最大的问题是没有考虑到一些进程需要紧急执行（如火灾报警程序）</p><h4 id="优先级调度"><a class="markdownIt-Anchor" href="#优先级调度"></a> 优先级调度</h4><p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B1.PNG" alt="" /></p><p>如图，这是优先级调度的一种组织形式。数字低的是高优先级（windows或linux中），他会首先从高优先级查找，如果有待执行的程序就执行它。</p><p>在windows系统中，正常的优先级是80，低于80是高优先级，高于80是低优先级。如果高优先级较多，低优先级可能一直没有执行的机会。所以高优先级一般都是服务进程，在不需要服务的时候他们会阻塞，一旦有信号将他们唤醒他们便会优先执行。</p><p>有时还会对使用cpu时间长的程序进行惩罚。</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Priority</span> = base + nice + CPU_PENALTY</span><br><span class="line"><span class="attribute">CPU_PENALTY</span> = CPU_USAGE * R</span><br><span class="line"><span class="attribute">CPU_USAGE</span> = CPU_USAGE * D</span><br><span class="line"></span><br><span class="line"><span class="attribute">CPU_USAGE</span> 是CPU使用次数，每过<span class="number">1</span>s（或其他时间）就会执行第三条指令防止CPU_USAGE一直增大。而CPU_PENALTY就是根据CPU_USAGE得来的。</span><br><span class="line"></span><br><span class="line"><span class="attribute">nice</span>是我们可以设置的优先级，在linux中有个nice命令可以在程序运行前设置优先级，范围是-<span class="number">20</span>-<span class="number">19</span>，非root用户只能变大不能变小。renice可以在运行时设置优先级</span><br></pre></td></tr></table></figure><h1 id="竞争条件和信号量"><a class="markdownIt-Anchor" href="#竞争条件和信号量"></a> 竞争条件和信号量</h1><p>进程之间有两种关系，协同和竞争。而怎么防止两个进程同时使用一个东西或如何通知其他进程便是多进程中需要考虑的问题</p><h2 id="引例"><a class="markdownIt-Anchor" href="#引例"></a> 引例</h2><p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B2.PNG" alt="" /></p><p>这个队列是等待使用打印机的队列，out是即将被答应的文件。</p><p>我们可以假设这种情况，进程a刚刚访问in发现它是7但是这时时间片到了。它被迫退出cpu。此时进程b进入cpu发现in是7并且将文件放在7处。之后再回到a，a会把他的文件放在7处然后in++。这时b的文件就被覆盖掉了</p><h3 id="皮德森算法"><a class="markdownIt-Anchor" href="#皮德森算法"></a> 皮德森算法</h3><p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B3.PNG" alt="" /></p><p>我们可以考虑这种情况，a进程到了turn = process处停止，b进程一路往下到了while，发现a进程对他有兴趣而终止。</p><p>而如果a到了turn = process终止，b也到turn = process终止，那么此时因为turn被改变，所以while第一个条件不满足，进入临界区。</p><p>这种算法可以解决竞争条件，但是首先它是对两个进程来说的，多个进程不好扩展，另外每次都要写这两个函数非常麻烦。</p><h3 id="tsl信号法"><a class="markdownIt-Anchor" href="#tsl信号法"></a> TSL信号法</h3><p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B4.PNG" alt="" /></p><p>此方法使用了一条汇编指令TSL，这条指令执行了两个内容<code>mov lock, %register;mov $1, %lock ；</code>前面相当于读锁的内容，后面是更改锁的值</p><blockquote><p>这条指令和上面例子的区别是这是<strong>原子指令</strong>，也就是说要么都不做，要么必须做完，时钟中断不会产生干扰。</p></blockquote><h2 id="pv操作"><a class="markdownIt-Anchor" href="#pv操作"></a> PV操作</h2><p>更为常用的方法是使用pv操作，p就使信号量-1，v就使信号量+1.</p><p><strong>信号量可正可负</strong></p><p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B5.PNG" alt="" /></p><p>信号量可正可负代表有一个等待队列，信号量为负时代表有多少个进程正在等待。</p><p>**信号量只有1或0</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">P(Semaphore e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!s)</span><br><span class="line">    s--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(Semaphore e)</span><br><span class="line">&#123;</span><br><span class="line">    s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： pv操作是操作系统提供的，他也是原子操作。</p><h2 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h2><p><strong>生产者消费者问题</strong></p><p>有一个生产者和消费者并且有一个队列可以存放生产者生产的产品。</p><p>一个普通的办法是</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">#define N <span class="number">100</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> producer(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">TRUE</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        item = produce_item();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> == N)sleep();</span><br><span class="line">        insert_item(item);</span><br><span class="line">        <span class="keyword">count</span> = <span class="keyword">count</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> == <span class="number">1</span>)wakeup(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> consumer(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">TRUE</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep();</span><br><span class="line">        &#125;</span><br><span class="line">        item = remove_item();</span><br><span class="line">        <span class="keyword">count</span> -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> == N-<span class="number">1</span>)wakeup(producer);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法是有问题的。假如消费者先运行，发现count == 0，然后发生时钟中断，之后生产者生产一个物品并发送wakeup信号，但这个时候consumer并没有睡眠，所以这个信号是没有用的。之后consumer睡眠，然后生产者一直生产物品也进行睡眠。这就产生了死锁。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define N <span class="number">100</span></span><br><span class="line">semophore mutex = <span class="number">1</span>;</span><br><span class="line">semophore empty = N;</span><br><span class="line">semophore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">void producer(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        item = produce<span class="constructor">_item()</span>;</span><br><span class="line">        <span class="constructor">P(<span class="params">empty</span>)</span>;</span><br><span class="line">        <span class="constructor">P(<span class="params">mutex</span>)</span>;</span><br><span class="line">        insert<span class="constructor">_item(<span class="params">item</span>)</span>;</span><br><span class="line">        <span class="constructor">V(<span class="params">mutex</span>)</span>;</span><br><span class="line">        <span class="constructor">V(<span class="params">full</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">另外一个类似</span><br></pre></td></tr></table></figure><p>这里empty和full也可以变成一个信号量，但是P的逻辑需要更改。empty初始值是N，每次生产一个就会减一，当empty变成0也就是满的时候就会阻塞。</p><p><strong>哲学家就餐问题</strong></p><p>哲学家问题是五个哲学家五根筷子，有五盘面，每个哲学家从左边和右边各拿一个筷子就可以吃到面，问怎样才可以让所有哲学家都吃到面。</p><p>如果完全不加控制，可能会出现五个人同时拿起左边筷子又同时拿起右边筷子的情况，这样就会饿死。</p><p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B6.PNG" alt="" /><br /><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B7.PNG" alt="" /><br /><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B8.PNG" alt="" /></p><p>这里使用了信号量mutex保证同一时间只有一个人试图拿筷子</p><p><strong>读写问题</strong></p><p>读写问题是同一时间可以有多个读的，但是同一时间最多有一个写的，如果有人在读那么写的就要等待</p><p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B9.PNG" alt="" /><br /><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B10.PNG" alt="" /></p><p>这是读者优先的策略，还有写者优先和公平竞争。</p><p><strong>公平竞争</strong></p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/* 读者队列初始值为0，其他资源初始值为1*/</span></span><br><span class="line">int readCount = <span class="number">0</span>;</span><br><span class="line">semaphore keySignal = <span class="number">1</span>;</span><br><span class="line">semaphore OneSignal = <span class="number">1</span>;</span><br><span class="line">semaphore readCountSignal = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">reader()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(true)</span><br><span class="line">    &#123;</span><br><span class="line">      wait(keySignal);        <span class="regexp">//</span>申请令牌</span><br><span class="line">      wait(readCountSignal);  <span class="regexp">//</span>申请计数器资源</span><br><span class="line">      <span class="keyword">if</span>(!readCount)          <span class="regexp">//</span>为零则申请文件资源</span><br><span class="line">         wait(fileSrc);</span><br><span class="line">      readCount++;</span><br><span class="line">      signal(readCountSignal); <span class="regexp">//</span>释放计数器资源</span><br><span class="line">      signal(keySignale);      <span class="regexp">//</span>释放令牌</span><br><span class="line"> </span><br><span class="line">      ...</span><br><span class="line">      perform read operation  <span class="regexp">//</span>执行临界区代码</span><br><span class="line">      ...</span><br><span class="line">  </span><br><span class="line">      wait(readCountSignal);  <span class="regexp">//</span>申请计数器资源</span><br><span class="line">      readCount--;</span><br><span class="line">      <span class="keyword">if</span>(!readCount)                <span class="regexp">//</span>为零则释放文件资源</span><br><span class="line">         signal(fileSrc);</span><br><span class="line">    signal(readCountSignal); <span class="regexp">//</span>释放读者计数器资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">writer()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span>(true)</span><br><span class="line">     &#123;</span><br><span class="line">        wait(OneSignal);     <span class="regexp">//</span>申请令牌资源</span><br><span class="line">        wait(keySignal);     <span class="regexp">//</span>申请令牌</span><br><span class="line">        wait(fileSrc);       <span class="regexp">//</span>申请文件资源</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line">        perform write operation <span class="regexp">//</span>执行临界区代码</span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">        signal(fileSrc);   <span class="regexp">//</span>释放文件资源</span><br><span class="line">        signal(keysignal); <span class="regexp">//</span>释放令牌</span><br><span class="line">        signal(OneSignal); <span class="regexp">//</span>释放令牌资源</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的OneSignal是为了保证写的顺序，如果没有onesignal那么一旦多个写者被阻塞恢复时就是靠操作系统调度，加了onesignal保证一定是最先进来的最先执行。但是这也仅限于两个，如果有三个以上写者还是会让操作系统调度。</p><h2 id="进程间通讯"><a class="markdownIt-Anchor" href="#进程间通讯"></a> 进程间通讯</h2><ul><li>给进程发信号，但是信号只有63种并且有些还不能使用所以这种方法一般不使用。</li><li>使用进程间通讯的函数<img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B11.PNG" alt="" /></li></ul><p>这些是进程间通讯的信号量，和下面线程间通讯不同。</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/sem.h&gt;</span></span><br><span class="line">+int semget(key_t key, int nesms, int semflg);key是信号量键值，nesm是创建信号量数量， semflg如果是IPC_EXCL创建唯一一个信号量，如果键值已经存在，那么就会出错。而IPC_CRATE即使存在也不会出错.返回semid</span><br><span class="line">+int semctl(int semid, int semnum, int cmd, <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">arg</span>): 删除或调整信号量，具体使用看下面</span></span><br><span class="line">+int semop(int semid, <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> *<span class="title">sops</span>, <span class="title">size_t</span> <span class="title">nsops</span>):<span class="title">nsop</span>是操作信号量数目（一般是1），结构体结构看下面</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">int val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">unsigned short int *array;</span><br><span class="line">/*<span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *<span class="title">__buf</span>;</span>*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">struct sembuf &#123;</span></span><br><span class="line"><span class="regexp">short sem_num;</span></span><br><span class="line"><span class="regexp">short sem_op;</span></span><br><span class="line"><span class="regexp">short sem_flg;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">static void sem_del(semaphore sem_id)</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">    union semun sem_union;</span></span><br><span class="line"><span class="regexp">    if (semctl(sem_id, 0, IPC_RMID, sem_union) == -1)</span></span><br><span class="line"><span class="regexp">        fprintf(stderr, &quot;Failed to delete semaphore\n&quot;);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int sem_p(semaphore sem_id)</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">    struct sembuf sem_b;</span></span><br><span class="line"><span class="regexp">    sem_b.sem_num = 0;</span></span><br><span class="line"><span class="regexp">    sem_b.sem_op = -1; /</span>* P() *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    sem_b.sem_flg = SEM_UNDO;/</span><span class="regexp">/进程结束而信号量没释放时，会自动释放信号量</span></span><br><span class="line"><span class="regexp">    if (semop(sem_id, &amp;sem_b, 1) == -1) &#123;</span></span><br><span class="line"><span class="regexp">        fprintf(stderr, &quot;semaphore_p failed\n&quot;);</span></span><br><span class="line"><span class="regexp">        return(0);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    return(1);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int sem_v(semaphore sem_id)</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">    struct sembuf sem_b;</span></span><br><span class="line"><span class="regexp">    sem_b.sem_num = 0;</span></span><br><span class="line"><span class="regexp">    sem_b.sem_op = 1; /</span>* V() *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    sem_b.sem_flg = SEM_UNDO;</span></span><br><span class="line"><span class="regexp">    if (semop(sem_id, &amp;sem_b, 1) == -1) &#123;</span></span><br><span class="line"><span class="regexp">        fprintf(stderr, &quot;semaphore_v failed\n&quot;);</span></span><br><span class="line"><span class="regexp">        return(0);</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br><span class="line"><span class="regexp">   return(1);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h1><p>线程可以看成比较小的进程，有自己的状态（寄存器和参数等），也会有一些可以被多个线程共享的参数（全局变量）。线程使独立运行和独立调度最小单元。线程可以分为用户级线程和内核级线程和混合线程三种方式。</p><ul><li>用户级线程： 这种线程不需要内核参与调度。优点是切换快（和函数调用类似），可以在不支持内核级线程的操作系统中执行。但是有一个缺点就是有一个线程被阻塞，那么其余该进程线程也会被阻塞-<strong>在操作系统层面上只会看到一个进程</strong>。</li><li>内核级线程，由内核参与线程的调度。优点是一个线程被阻塞，那么其他的线程不会被阻塞，缺点是线程间切换所需时间多（要清空高速缓存等）</li></ul><p>现在操作系统一般使用内核级线程</p><h2 id="linux线程编程-c语言"><a class="markdownIt-Anchor" href="#linux线程编程-c语言"></a> linux线程编程 C语言</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">头文件&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">线程创建</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> pthread_create (pthread_t *__restrict __newthread,</span><br><span class="line">   <span class="keyword">const</span> pthread_attr_t *__restrict __attr,</span><br><span class="line">   <span class="keyword">void</span> *(*__start_routine) (<span class="keyword">void</span> *),</span><br><span class="line">   <span class="keyword">void</span> *__restrict __arg) </span><br><span class="line">第一个参数是指向这个线程的指针。第二个参数设置线程的属性，一般设置成<span class="literal">NULL</span>。第三个参数是这个线程运行时所运行的函数。第四个参数是运行时函数的参数。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span>* test(<span class="keyword">void</span>* args)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;this is the arguments-%s&quot;</span>, (<span class="keyword">char</span>*)args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t p;</span><br><span class="line">    pthread_create(&amp;p, <span class="literal">NULL</span>, test, <span class="string">&quot;arg1&quot;</span>);</span><br><span class="line">    pthread_join(p, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出： <span class="keyword">this</span> is the arguments-arg1</span><br></pre></td></tr></table></figure><ul><li><code>int pthread_join(pthread_t thread, void **retval);</code>.它的作用是让主线程等待某个线程结束再执行。retval是线程结束后的返回值，可以设置成NULL。</li></ul><p>需要使用pthread_join的原因是主线程结束这个程序就结束了，这时候其他线程不一定执行完成。</p><ul><li><p>线程信号量 头文件pthread.h</p><ul><li>pthread_mutex_t lock_put;//信号量创建</li><li>pthread_mutex_lock(&amp;lock_put);</li><li>pthread_mutex_unlock(&amp;lock_put);</li><li>pthread_mutex_init(&amp;lock_put, NULL);//初始化，后面一般是NULL,当然也可以是下列值<ul><li><p>PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。</p></li><li><p>PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。</p></li><li><p>PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。</p></li><li><p>PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。</p></li></ul></li></ul></li><li><p>线程信号量2 头文件semaphore.h</p><ul><li>int sem_init (sem_t *sem , int pshared, unsigned int value);初始化,pshared固定是0来表示线程间通讯<ul><li>value - 信号量 sem 的初始值。</li></ul></li><li>int sem_post(sem_t *sem); 加1</li><li>int sem_wait(sem_t *sem); 减1</li><li>int sem_destroy(sem_t *sem); 销毁</li></ul></li><li><p>屏障： 屏障是当不满足条件时阻塞线程，满足条件之后再一起释放</p><ul><li>pthread_cond_t   cond; 创建</li><li><code>int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr)</code>： 初始化，但是Linux中cond_attr并没有实现，所以直接NULL</li><li><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)</code>  : 等待,注意 还必须要有一个互斥量，只有拿到了互斥量才可以执行等待，并且与此同时会释放mutex。</li><li>pthread_cond_signal(): 激活一个等待线程</li><li>pthread_cond_broadcast()：激活所有等待线程，要注意激活后是从等待位置开始而不是从broadcast位置开始。</li></ul></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> t = bstate.round;</span><br><span class="line">    <span class="keyword">assert</span> (i<span class="operator"> == </span>t);</span><br><span class="line">    </span><br><span class="line">    pthread<span class="constructor">_mutex_lock(&amp;<span class="params">bstate</span>.<span class="params">barrier_mutex</span>)</span>;</span><br><span class="line">    bstate.nthread++;</span><br><span class="line">    <span class="keyword">if</span>(bstate.nthread &lt; nthread)<span class="comment">//没都到就待着</span></span><br><span class="line">    &#123;</span><br><span class="line">    pthread<span class="constructor">_cond_wait(&amp;<span class="params">bstate</span>.<span class="params">barrier_cond</span>, &amp;<span class="params">bstate</span>.<span class="params">barrier_mutex</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//到了就全部激活</span></span><br><span class="line">    &#123;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    bstate.round++;</span><br><span class="line">    pthread<span class="constructor">_cond_broadcast(&amp;<span class="params">bstate</span>.<span class="params">barrier_cond</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">bstate</span>.<span class="params">barrier_mutex</span>)</span>;</span><br><span class="line">    usleep(random<span class="literal">()</span> % <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="死锁问题"><a class="markdownIt-Anchor" href="#死锁问题"></a> 死锁问题</h1><p>死锁条件：</p><ul><li>互斥条件</li><li>保持和等待条件： 一个进程因请求而进入阻塞时，对自身已获得的资源不放。</li><li>无抢占条件（抢占就是在一定条件下可以抢夺这个资源，如CPU就是抢占条件）</li><li>循环等待条件： 形成首尾相接的环。如下</li></ul><p><img src="/images/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B12.PNG" alt="" /></p><p>如图，圆代表进程，方形代表资源，由方形指向圆代表这个进程有这个资源，由圆指向方形代表这个进程需要这个资源。如果形成环路就代表出现了死锁。</p><p>资源按需分配可以破坏循环等待条件。</p><p>死锁解决方法：</p><ul><li>忽略问题</li><li>检测复原，例如隔多少分钟产生一个备份，一旦死锁就让某个进程回到这个备份，相应资源也会被释放</li><li>杀死某个进程释放资源</li><li>动态避免通过小心的资源分配</li></ul><h2 id="银行家算法"><a class="markdownIt-Anchor" href="#银行家算法"></a> 银行家算法</h2><p>银行家算法是通过资源分配来避免（不是预防）死锁的。并且没有破坏死锁的任何一个条件</p><p><img src="/images/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B13.PNG" alt="" /></p><p>首先要知道总共有多少资源，已经分配了多少资源，总共还剩多少资源，还需要多少资源。</p><p>![](/images/进程与线程 14.PNG)</p><p><strong>现在还有(3, 2, 2)资源可以使用</strong></p><p>之后一旦有进程请求就先把资源给他。如果资源不够就不给，如果资源够就用剩下的资源进行安全状态检查。</p><p>安全状态检查就是看看现有资源可以分配给哪个进程，有就把资源给他然后回收这个进程资源（不用考虑其他进程还会申请资源）。然后用这些资源再进行分配，如果最后由进程分配不了则说明这个状态不安全。</p><ul><li>例如p4申请了(2, 1, 0)资源，先把资源给他，那么现在还有(1, 1, 2)资源可以使用，p4变成(2, 2, 1)先把资源给p3然后回收，那么p3完成，剩余资源变成（3, 2, 3)</li><li>把资源给p1, 剩余资源变成(5, 3, 3)</li><li>资源给p4，剩余资源变成（7， 4， 5）</li><li>之后就一步一步分配</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>分治法</title>
    <link href="http://xinhecuican.github.io/post/7f3bcd7f.html"/>
    <id>http://xinhecuican.github.io/post/7f3bcd7f.html</id>
    <published>2020-10-17T13:29:00.000Z</published>
    <updated>2020-11-25T06:47:08.561Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1><p>分治法是将大问题分解成若干个小问题，通过解决小问题解决大问题的方法。它和递归关系密切。</p><p>大致流程</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if(<span class="name">|P|</span> &lt;= n0) adhoc(<span class="name">p</span>)<span class="comment">;</span></span><br><span class="line">divide p into small k part<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">for(<span class="name">int</span> i=0<span class="comment">; i&lt;k; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">yi = divide-and-conquer(<span class="name">pi</span>)<span class="comment">;</span></span><br><span class="line">    //递归解决各个子问题</span><br><span class="line">&#125;</span><br><span class="line">return merge(<span class="name">y1</span>,y2,...yk)<span class="comment">; 合并子问题的解</span></span><br></pre></td></tr></table></figure><h1 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h1><h2 id="找伪币"><a class="markdownIt-Anchor" href="#找伪币"></a> 找伪币</h2><p>假如有十六个硬币，有一个是伪币，伪币比较轻，试用一个天平找出伪币</p><p>假如两两比较，最坏情况需要8次</p><p>如果使用分治法，需要四次。首先8个8个比较，然后在轻的一堆中比较。</p><h2 id="计算an"><a class="markdownIt-Anchor" href="#计算an"></a> 计算a^n</h2><p>如果使用 a * a * a…。那么复杂度是O(n).使用分治法，</p><p>a^n = a^(n/2) * a^(n/2) n%2 == 0</p><p>a^n = a^(n/2) * a^(n/2) * a n%2 == 1</p><blockquote><p>所以 T(n) = T(n/2) + 0(1)</p></blockquote><p>其中T(n/2)是计算a^(n/2)所需要的时间， O(1)是两个数相乘需要的时间。由<a href="https://xinhecuican.github.io/post/71038564.html#more">主定理</a>可得，复杂度是 O(logn)。</p><p>可以看到，通过分治法，有时我们可以减少一些重复运算。</p><h2 id="大整数乘法"><a class="markdownIt-Anchor" href="#大整数乘法"></a> 大整数乘法</h2><p>两个大整数乘法直接相乘复杂度是O(n^2)（注意这里指的是每个bit相乘）<img src="/images/%E5%88%86%E6%B2%BB%E6%B3%951.PNG" alt="" /></p><p>如果把它分成两个部分,如图所示，那么乘法就可以变成</p><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">(a* <span class="number">2</span>^(<span class="built_in">n</span>/<span class="number">2</span>) + b)(c * <span class="number">2</span>^(<span class="built_in">n</span>/<span class="number">2</span>) + d)</span><br><span class="line">= ac * <span class="number">2</span>^<span class="built_in">n</span> + (ad+bc) *<span class="number">2</span>^(<span class="built_in">n</span>/<span class="number">2</span>) + bd</span><br></pre></td></tr></table></figure><p>递推公式为 <code>T(n) = 4*T(n/2) + 0(n)</code>其中O(n)是ad和bc等两个分式相加的复杂度而不是计算2<sup>n的复杂度。得到的复杂度为O(n</sup>2)，没有改进。</p><p>但是如果写成 <code>ac * 2^n +((a+b)(c+d)-ac-bd) * 2^(n/2) + bd</code>则复杂度就变成了O(n^1.59)。</p><h2 id="中间的中间问题"><a class="markdownIt-Anchor" href="#中间的中间问题"></a> 中间的中间问题</h2><p><img src="/images/%E5%88%86%E6%B2%BB%E6%B3%952.PNG" alt="" /><br />如图，对这些数进行排序。我们可以把这些数分成5组，然后每组找中位数。然后在所有的中位数中寻找中位数（中位数的中位数）。再用找到的中位数的中位数进行排序。</p><p>提出这个方法是因为快速排序在最坏情况下复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，之所以可能是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是因为可能我们每次选的支点都可能是最小值。而这个算法就是为了避免这种情况。</p><p>我们已经找到中位数的中位数了（图中是10，多余的两个数可以不管）。也就是说在10这组前面有两组。因为前面每组都有三个数一定比10小。那么一定有3n/10个数比10小。</p><p>假设有n个数，找到n/5个中位数，又找中位数的中位数，那么一定有n/10个数比中位数小（n/5个中位数中有一半比他小）。因为中位数前面两个数字也一定比他小，所以总共是3n/10。</p><p>可以证明找中位数的中位数时间复杂度是O(n)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>复杂度</title>
    <link href="http://xinhecuican.github.io/post/71038564.html"/>
    <id>http://xinhecuican.github.io/post/71038564.html</id>
    <published>2020-10-02T05:52:00.000Z</published>
    <updated>2020-10-29T02:26:16.492Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="下界math-xmlnshttpwwww3org1998mathmathmlmiωmimath-上界o-紧界math-xmlnshttpwwww3org1998mathmathmlmiθmimath"><a class="markdownIt-Anchor" href="#下界math-xmlnshttpwwww3org1998mathmathmlmiωmimath-上界o-紧界math-xmlnshttpwwww3org1998mathmathmlmiθmimath"></a> 下界<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Ω</mi></math> 上界O 紧界<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Θ</mi></math></h1><p>这几个界都是由极限得来的。</p><p>上界： 对于 任意正常量c&gt;0,都存在No&gt;=n,使得 0&lt;=f(n)&lt;= cg(n).则可用 f(n) = O(g(n))表示。</p><p>g(n)一般使用简单的式子如 n nlogn, n^2,…</p><p>这个式子其实就是极限的表达形式，所以我们也可以用极限的形式表达：<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>i</mi><msubsup><mi>m</mi><mn>0</mn><mi>∞</mi></msubsup><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>/</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mo> </mo><mn>0</mn></math></p><p>下界： f(n)&gt;=cg(n) <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>i</mi><msubsup><mi>m</mi><mn>0</mn><mi>∞</mi></msubsup><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>/</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mo> </mo><mi>∞</mi></math></p><p>紧界： f(n)= cg(n)</p><h1 id="分析递归式的复杂度"><a class="markdownIt-Anchor" href="#分析递归式的复杂度"></a> 分析递归式的复杂度</h1><p>之所以递归式要单独拿出来分析是因为递归式很难从直观上去判断。例如 f(n) = f(n-1)+f(n-2).这个递归式如果要分析的话可以写成 f(n) = f(n-1) + f(n-2) + 1，最后一个1表示每一层需要进行的运算，因为这里只有一个加法运算，所以是加1.</p><h2 id="代入法求递归式"><a class="markdownIt-Anchor" href="#代入法求递归式"></a> 代入法求递归式</h2><p>代入法就是首先猜测复杂度，然后用归纳法证明。</p><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">例如： <span class="built_in">T</span>(<span class="built_in">n</span>) = <span class="number">4</span><span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">2</span>) + <span class="built_in">n</span></span><br><span class="line"></span><br><span class="line">假设 <span class="built_in">T</span>(<span class="built_in">n</span>) &lt;= cn^<span class="number">3</span></span><br><span class="line"></span><br><span class="line">当<span class="built_in">n</span> = <span class="number">1</span>时，可以找出一个足够大的c使，<span class="built_in">T</span>(<span class="number">1</span>) &lt;= c， 成立</span><br><span class="line">当<span class="built_in">n</span>= k 时， <span class="built_in">T</span>(k) &lt;= ck^<span class="number">3</span></span><br><span class="line">当<span class="built_in">n</span> = <span class="built_in">n</span>时， <span class="built_in">T</span>(<span class="built_in">n</span>) = <span class="number">4</span><span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">2</span>) + <span class="built_in">n</span> &lt;= <span class="number">1</span>/<span class="number">2</span> * c * <span class="built_in">n</span>^<span class="number">3</span> + <span class="built_in">n</span> &gt;= cn^<span class="number">3</span>，所以成立。</span><br><span class="line"></span><br><span class="line">如果 <span class="built_in">T</span>(<span class="built_in">n</span>) &lt;= cn^<span class="number">2</span></span><br><span class="line"></span><br><span class="line">当<span class="built_in">n</span>=<span class="built_in">n</span>时， <span class="built_in">T</span>(<span class="built_in">n</span>) &lt;= c * <span class="built_in">n</span>^<span class="number">2</span> +<span class="built_in">n</span> &gt;= cn^<span class="number">2</span>。 不成立</span><br><span class="line"></span><br><span class="line">遇到这种与结果十分接近的式子时可以减去一个低阶项。</span><br><span class="line"></span><br><span class="line">假设 <span class="built_in">T</span>(<span class="built_in">n</span>) &lt;= c （<span class="built_in">n</span>^<span class="number">2</span> - <span class="built_in">n</span>)</span><br><span class="line"></span><br><span class="line">当 <span class="built_in">n</span> = <span class="built_in">n</span> 时， <span class="built_in">T</span>(<span class="built_in">n</span>) &lt;= cn^<span class="number">2</span> - c/<span class="number">2</span>*<span class="built_in">n</span> +<span class="built_in">n</span> &lt;= cn^<span class="number">2</span>，成立</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="递归树法"><a class="markdownIt-Anchor" href="#递归树法"></a> 递归树法</h2><p>递归树法是通过作图分析<img src="/images/%E5%A4%8D%E6%9D%82%E5%BA%A61.jpg" alt="" /></p><p>例如 f(n) = 2 * f(n/2) + n. 那么第二层是由两个f(n/2)组合而成 每个f(n/2)都会加上n/2,所以第一层和第二层都加上n。</p><p>总共有多少层呢？ 可以看到最后要减小到f(1)，而每次乘1/2,也就是 n/(2^h) = 1,h=logn.所以复杂度是 O(nlogn)（层数乘上每层数目）</p><p>拿一个跟复杂的例子。 f(n) = f(n/3) + f(2n/3) + n.对于这种我们通常使用夹紧准则获得一个近似值。例如一直从左边高度是log3 n ,右边是 log3/2 n.而右边到最后每一层不是n。这些差异我们可以忽略大致得到复杂度是nlogn。然后在用归纳法证明</p><h2 id="主方法"><a class="markdownIt-Anchor" href="#主方法"></a> 主方法</h2><p>对于 T(n) = aT(n/b) + f(n)</p><ol><li><p>如果 f(n) = O(n^logb a-e).也就是n^logb a 比 f(n)大，那么T(n) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Θ</mi></math>（n^logb a)<br />这里e最好写出来</p></li><li><p>如果f(n) = n^logb a, 那么 T(n) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Θ</mi></math>(n^logb a lgn)</p></li><li><p>f(n) = O(n^logb a+e),还要满足存在c&lt;1和足够大的n af(n/b) &lt;= cf(n),则 T(n) = <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Θ</mi></math>(f(n))</p></li></ol><p>要注意，case1 和 case2之间有空隙，case2和case3之间有空隙。一个例子是</p><p><code>T(n) = 2T(n/2) + O(nlogn)</code></p><p>这个 n^(logb(a))的确比nlogn小，但是 nlogn/n = logn都渐进小于 n<sup>e（也就是n</sup>e/logn 取极限为0）,所以这是渐进大于而不是多项式大于，不能用case3.</p><p>主定理更为适用于多项式级别的比较，如果有logn和2^n有时候就会力不从心了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;下界math-xmlnshttpwwww3org1998mathm</summary>
      
    
    
    
    <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 过滤器</title>
    <link href="http://xinhecuican.github.io/post/97246020.html"/>
    <id>http://xinhecuican.github.io/post/97246020.html</id>
    <published>2020-10-01T01:40:00.000Z</published>
    <updated>2020-11-26T09:07:15.391Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中），但是在最前面的和在最后面的不一定是过滤器。</p><h3 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h3><h4 id="cat-复制"><a class="markdownIt-Anchor" href="#cat-复制"></a> cat 复制</h4><p>cat的用途就是把标准输入中的数据复制到标准输出中</p><p>应用：可以与重定向结合。cat &gt; data，这样从键盘中输入的数据将直接传到data文件中</p><p>此外还可以让文件内容显示在控制台上，有 cat &lt; data，标准输入变成了data文件，标准输出是屏幕。为了方便，直接cat 文件名也是可以的</p><p>此外，tail也有类似的功能，但是它只能显示最后的十行</p><p>另外一个应用就是把一个文件复制到另一个文件。例如，cat &lt; data &gt; newdata</p><h5 id="增强cat功能"><a class="markdownIt-Anchor" href="#增强cat功能"></a> 增强cat功能</h5><p>cat &lt; file…= cat file …</p><p>有三个点说明了可以同时输入多个文件，这样就为组合多个文件提供了途径</p><p>cat data1 data2 data3 &gt;file</p><p>后缀：</p><pre><code> -n 在每行后面加一个行号 -b 与-n一起使用，不要对空白行加行号 -s 将多个连续的空白行变成一个空白行</code></pre><h4 id="split-分为不同文件"><a class="markdownIt-Anchor" href="#split-分为不同文件"></a> split 分为不同文件</h4><p>语法 split [-d] [-a num] [-l lines] [file [prefix]]</p><p>作用： 将一个大文件分解成几个小文件。默认情况下，split将创建1000行长的空间</p><p>参数：</p><pre><code>-l 创建一个5000行的空间-d 将文件名改为从00开始编号-a 后面加数字，例如3表示从000开始，总共1000个文件名</code></pre><p>默认情况下，split创建的文件将以x开头，后面加aa，ab等</p><h4 id="tac-反转复制"><a class="markdownIt-Anchor" href="#tac-反转复制"></a> tac 反转复制</h4><p>相关过滤器： cat，rev</p><p>作用：和cat类似，但是在写入文件时把文件内容反转（tac是将cat反过来）。注意，这里的反过来并不是指从后往前倒着写，而是把行与行将顺序反过来。</p><h4 id="rev-反转字符顺序"><a class="markdownIt-Anchor" href="#rev-反转字符顺序"></a> rev 反转字符顺序</h4><p>相关过滤器： cat tac</p><p>作用： 将各行字符顺序反转</p><p>语法： rev [file…]</p><p>例如： 有一个文件data，里面有</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">abcde</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure><p>之后用rev后会变成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">54321</span><br><span class="line">edcba</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure><p>rev也是直接输出到标准输出上的，也就是说并不会对源文件造成改变，如果想输出到文件中，还要重定向一下</p><h4 id="headtail-从数据开头或者结尾读取"><a class="markdownIt-Anchor" href="#headtail-从数据开头或者结尾读取"></a> head，tail 从数据开头或者结尾读取</h4><p>语法： head/tail [-n lines]，lines是希望选择的数据行</p><p>默认情况下，head和tail都只会选择十行数据，用-n可以选择任意行数</p><p>例： calculate | tail -n 15</p><h4 id="colrm-删除数据列"><a class="markdownIt-Anchor" href="#colrm-删除数据列"></a> colrm 删除数据列</h4><p>相关过滤器： cut paste</p><p>colrm（“column remove&quot;)程序从标准输入中读取数据，删除指定数据列（也就是竖的删除），将剩余数据写入标准输出</p><p>语法： colrm [startcol [endcol]]，编号从1开始</p><p>例： colrm 14 30 &lt;students | less</p><h3 id="比较文件"><a class="markdownIt-Anchor" href="#比较文件"></a> 比较文件</h3><h4 id="cmp-比较两个任意文件"><a class="markdownIt-Anchor" href="#cmp-比较两个任意文件"></a> cmp 比较两个任意文件</h4><p>相关过滤器：comm diff sdiff</p><p>语法: cmp file1 file2</p><p>cmp程序逐字节的比较文件，查看两个文件是否相同。如果两个文件相同，那么不做任何处理，如果不同，将会返回第一个不同的行和列</p><h4 id="comm-比较有序文件"><a class="markdownIt-Anchor" href="#comm-比较有序文件"></a> comm 比较有序文件</h4><p>语法：comm [-123] file1 file2</p><p>comm程序一行一行的比较两个有序的文本间，程序输出三列，第一列输出只包含在第一个文件中的行，第二列输出只包含在第二个文件中的行，第三列输出两个文件中都有的行。</p><p>因为comm是逐行比较，所以在比较之前最好使用sort进行排序</p><p>参数： -1 -2 -3 取消第一二三列的输出</p><h4 id="diff-比较无序文件"><a class="markdownIt-Anchor" href="#diff-比较无序文件"></a> diff 比较无序文件</h4><p>语法： diff [-bBiqswy] [-c| -Clines | -u | -Ulines] file1 file2</p><p>lines是说明上下文关系的行号</p><p>输出： diff的输出有三个不同的单字符指示： c（change） d（delete） a（append）。这三个字符说明了要想让两个文件相同需要做哪些改变。</p><p>这三个字符左右两边都会有数字，代表着需要修改的行号。例如，3c3代表把左边文件中的第三行变成右边文件中的第三行。</p><p>diff要求改变时，就会给出每一个文件的实际行，第一个文件中的行用小于号标记，第二个文件中的行用大于号标记。两组行之间还会有横线分隔开</p><p>例如，第一个文件为</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">abcd</span><br><span class="line">asdf</span><br><span class="line"><span class="keyword">as</span> df</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>第二个文件为</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">a</span>     </span><br><span class="line"><span class="attribute">abcd</span></span><br><span class="line"><span class="attribute">asdf</span></span><br><span class="line"><span class="attribute">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">0a1</span><br><span class="line">&gt; a     </span><br><span class="line">3,4c4</span><br><span class="line">&lt; as df</span><br><span class="line">&lt; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">---</span><br><span class="line">&gt; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>a左边的数代表在左边数后面追加一行，例如0a1代表在第0行后面加上右边的第一行</p><p>d一般只需要管左边的数字，它的意思是删去左边的那一行</p><p>c表示3,4行和第三行有不同，分隔符上面是第一个文件，下面是第二个文件</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-i 忽略大小写区别</span></span><br><span class="line"><span class="deletion">-w（whitespace) 忽略所有空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别，就是把多个空白符看成一个</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行，</span></span><br><span class="line"><span class="deletion">-q 当两个文本不同时，忽略所有细节，只说两文本不同</span></span><br><span class="line"><span class="deletion">-s 会明确告诉两个文本相同</span></span><br><span class="line"><span class="deletion">-c 全文比较，+代表要增加，-代表要减少，！代表要替换</span></span><br><span class="line"><span class="deletion">-u 与-c类似，但是把两个文件混合在一起显示，两个重复行只输出一个</span></span><br><span class="line"><span class="deletion">-y 把两个文件并排输出</span></span><br></pre></td></tr></table></figure><h4 id="sdiff"><a class="markdownIt-Anchor" href="#sdiff"></a> sdiff</h4><p>语法： sdiff [-bBilsW] [-w columns] file1 file2</p><p>作用：与 diff -y 类似，并排比较<br />参数：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-l 当两个文件有共同行时，只显示左边的列</span></span><br><span class="line"><span class="deletion">-s 不显示两个文件中任何相同的行</span></span><br><span class="line"><span class="deletion">-w+数字 改变列的宽度</span></span><br><span class="line"><span class="deletion">-i 忽略大写和小写的区别</span></span><br><span class="line"><span class="deletion">-W 忽略所有的空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行</span></span><br></pre></td></tr></table></figure><h4 id="差分"><a class="markdownIt-Anchor" href="#差分"></a> 差分</h4><p>例如： diff game1_ver1.0.c game2_ver2.0.c &gt; game2_ver2.1</p><p>这个命令会把第一个文件和第二个文佳之间的差保存下来，这样可以节省空间，此外在日后不慎丢失文件时也有办法快速找回</p><h4 id="cut-抽取数据列"><a class="markdownIt-Anchor" href="#cut-抽取数据列"></a> cut 抽取数据列</h4><p>相关过滤器： colrm join paste</p><p>语法： cut -c list [file…]</p><p>list就是要抽取的数据列，各个列之间用逗号隔开，不能有空格，或者14-19表示从14列到19列</p><p>作用：抽取指定的列</p><p>这种按列切分遇到长度不同的数据时就显得无能为力，因此还有另一种抽取方式，抽取字段，即按照一定的定界符进行分割（如逗号，空格等）</p><p>参数：</p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">-c  list [file...] list表明抽取第几个字段</span><br><span class="line">-f  list [-d delimiter] [-s] [file...]  -d后面是定界符种类 -s（suppress 抑制）抛弃没有定界符的行。例如 cut -f <span class="number">1</span> -d <span class="string">&#x27;:&#x27;</span> ./temp</span><br></pre></td></tr></table></figure><h4 id="paste"><a class="markdownIt-Anchor" href="#paste"></a> paste</h4><p>语法： paste [-d char…] [file…]</p><p>其中char是用来做分隔符的字符，默认情况为一个制表符或者是空格</p><p>作用： 把几个文件组合成一个表格（组合数据列）</p><p>如果指定了不止一个定界符，那么将会轮流使用定界符</p><p>例如： paste -d ‘|%’ name phone ，这个指令中就有两个定界符</p><h3 id="统计和格式化"><a class="markdownIt-Anchor" href="#统计和格式化"></a> 统计和格式化</h3><h4 id="nl-创建行号"><a class="markdownIt-Anchor" href="#nl-创建行号"></a> nl 创建行号</h4><p>语法： nl [-v start] [-i increment] [-b a] [-n ln|rn|rz] [file…]</p><p>start是起始行号 ，increment是增量</p><p>作用：希望在一些数据中永久的插入行号，在输出中临时插入行号。一般状况下，插入的行号都是临时的，原始数据并不会发生改变，除非重定向输出到文件中。</p><p>默认情况下，不会对空行编号</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-v 改变起始编号，默认起始编号是1</span></span><br><span class="line"><span class="deletion">-i 改变增量，默认增量为1</span></span><br><span class="line"><span class="deletion">-b a 对所有行编号，包括空行</span></span><br><span class="line"><span class="deletion">-n ln 左对齐 rn 右对齐 rz 右对齐，有前导0</span></span><br></pre></td></tr></table></figure><h4 id="wcword-count统计行单词和字符的数量"><a class="markdownIt-Anchor" href="#wcword-count统计行单词和字符的数量"></a> wc（word count）统计行单词和字符的数量</h4><p>语法： wc [-clLw] [file…]</p><p>作用：统计行，单词，字符的数量。所统计的数据可以来自另一个程序或者是一个或多个文件</p><p>输出依次输出行，单词数，字符数 和文件名。如果不止一个文件，那么会为每一个文件显示一个输出，然后最后一行是一个总输出。</p><p>参数</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-l 统计行</span></span><br><span class="line"><span class="deletion">-w 统计单词</span></span><br><span class="line"><span class="deletion">-c 统计字符</span></span><br><span class="line"><span class="deletion">-L 该选项显示输入中最长行的长度</span></span><br></pre></td></tr></table></figure><p>此外，还可以用wc来统计某一目录中文件的数量，假设一个文件一行，用ls file | wc -l.</p><h4 id="制表符和空格"><a class="markdownIt-Anchor" href="#制表符和空格"></a> 制表符和空格</h4><p>在老式机器中，会在某些特定的为做一些机器标记，这些标记叫做制表位，如果按了制表位，那么机器会直接跳转到下一个制表位上，tab键与这个作用类似。一旦按了tab键，那么他将会自动跳转到下一个制表位。例如输入<code>A&lt;Tab&gt;BBBB&lt;Tab&gt;CCC</code>，实际上看起来中间有空格，实际上只有一个Tab</p><p>可视化制表符</p><p>第一种办法是在vi中，set list 那么制表符会转化成^I符号</p><h4 id="expand-将制表符转化成空格"><a class="markdownIt-Anchor" href="#expand-将制表符转化成空格"></a> expand 将制表符转化成空格</h4><p>语法： expand [-i] [-t size] [-t list] [file…]</p><p>其中size是固定宽度制表符的大小（默认为8)，list是制表位列表</p><p>作用：expand将输入文件中所有的制表符转化成空格，别切维持与原文本相同的对齐方式</p><p>-i 只转换开头的制表符，其他的制表符保持不变</p><h4 id="unexpand-将空格转化成制表符"><a class="markdownIt-Anchor" href="#unexpand-将空格转化成制表符"></a> unexpand 将空格转化成制表符</h4><p>语法： unexpand [-a] [-t size] [-t list] [file…]</p><p>其中size是制表符的大小（希望设置的），list是制表位列表</p><p>一般情况下，unexpand只转化第一行的空格，如果想要转换所有行的空格，那么需要-a选项</p><h4 id="fold-格式化行"><a class="markdownIt-Anchor" href="#fold-格式化行"></a> fold 格式化行</h4><p>相关过滤器： fmt ,pr</p><p>语法： fold [-s] [w witch] [file…]</p><p>其中witch是新行的宽度。</p><p>作用： 将长的行分割成短行。也就是把一行分成多行。其实就是在适当位置插入一个回车符</p><p>默认状态下，80个字符为一行。</p><p>-s选项是告诉程序不要分割单词，也就是说如果那个单词正好在要分割的位置，那么现在会先显示这个单词在转到下一行。</p><h4 id="fmt-格式化段落"><a class="markdownIt-Anchor" href="#fmt-格式化段落"></a> fmt 格式化段落</h4><p>语法： fmt [-su] [-w width] [file…]</p><p>作用：让各行连接在一起，并且不改变空白符。</p><p>当它读取文本时，假定段落由空行分隔。一个“段落”就是一个或多个连续的文本行，不包括空行。fmt根据下列规则读取一个段落</p><ul><li>行宽： 让每行尽可能的长，并且不超过指定的长度。默认情况下，每行最多75个字符</li><li>句子： 无论何时，尽可能在句子末尾分隔行。避免在句子的第一个单词之后或最后一个单词之前分隔行。</li><li>空白符： 保持单词及空行之间的所有缩进，空格。</li><li>制表符： 所有制表符转化成空格。并在最后输出时合适的位置插入制表符</li></ul><p>说起来复杂，其实就是让那些长短不一的段落尽量变得长。</p><p>例如</p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">As we all know,</span><br><span class="line"><span class="keyword">success </span>cones slowly and</span><br><span class="line">is due to a number of different factors all coming</span><br><span class="line">together</span><br><span class="line">over a period of years</span><br></pre></td></tr></table></figure><p>使用命令后</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">As</span> we <span class="keyword">all</span> know, <span class="type">real</span> success comes slowly <span class="keyword">and</span> <span class="keyword">is</span></span><br><span class="line">due <span class="keyword">to</span> a number <span class="keyword">of</span> different factors <span class="keyword">all</span> coming</span><br><span class="line">together <span class="keyword">over</span> a period <span class="keyword">of</span> years.</span><br></pre></td></tr></table></figure><p>此外，它是一段的作用，如果两行之间有个空行就把他们当成两段单独处理，互不影响</p><p>参数</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-u(uniform spacing 统一间距) 减少空格，每个单词之间最多只有一个空格，句子末尾最多只有两个空格。</span></span><br><span class="line"><span class="deletion">-w 设定宽度</span></span><br></pre></td></tr></table></figure><h4 id="pr-按页格式化文本"><a class="markdownIt-Anchor" href="#pr-按页格式化文本"></a> pr 按页格式化文本</h4><p>语法： pr [-dt] [+beg[:end]] [-h text] [-l n] [-o margin] [-W width] [file…]</p><p>作用： 按页格式化文件，以便于打印。</p><p>其中 beg是需要格式化的第一页，end是最后一页，text是标题，n是每页的行数，margin是左边缘的大小，width是输出的宽度。</p><p>默认情况下，pr是通过顶端插入一个标题，左边插入一个边缘，底部插入一个页尾来格式化文件。标题包括修改时间，文件名称和页号。</p><p>如果想查看效果，最好在less程序中</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-d 双倍行距文本（word中的）</span></span><br><span class="line"><span class="addition">+begin;end 从那页到哪页格式化</span></span><br><span class="line"><span class="deletion">-l 改变每页总行数</span></span><br><span class="line"><span class="deletion">-o 设置左边缘</span></span><br><span class="line"><span class="deletion">-W 改变每一行的字符数（默认是72）</span></span><br></pre></td></tr></table></figure><p>还可以按列格式化文本</p><p>语法： pr [-mt] [-columns] [-l lines] [-W width] [file…]</p><p>column是输出列的数量，lines是每页的行数，width是每行的字符数。这个选项不建议用，会截断字符。</p><h3 id="选取排序组合变换"><a class="markdownIt-Anchor" href="#选取排序组合变换"></a> 选取，排序，组合，变换</h3><h4 id="grep-选取特定模式的行"><a class="markdownIt-Anchor" href="#grep-选取特定模式的行"></a> grep 选取特定模式的行</h4><p>相关过滤器： look strings</p><p>语法： grep [-cilLnrsvwx] pattern [file…]</p><p>pattern是要搜索的格式</p><p>作用： 从标准输入或文件中读取数据，抽取所有包含特定模式的行，并写入标准输出。</p><p>这个模式可以是字符串标点符号等，但是如果是标号或者特殊字符时，最好用’'强引用，以防止歧义。</p><p>选项：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-c(count) 统计所抽取行的数量，但不显示行本身</span></span><br><span class="line"><span class="deletion">-i（ignore) 忽略大小写的区别</span></span><br><span class="line"><span class="deletion">-n 所选行在原文件中的位置</span></span><br><span class="line"><span class="deletion">-l（list），如果在不只一个文件中搜索，使用这个选项可以只把匹配的文件名列举出来，此时文件名也要输出多个</span></span><br><span class="line"><span class="deletion">-L 显示不包含该模式的文件名</span></span><br><span class="line"><span class="deletion">-v（reverse） 选取不包含模式的行</span></span><br><span class="line"><span class="deletion">-x 选取完全匹配的行</span></span><br><span class="line"><span class="deletion">-r（recursive递归） 搜索整个目录树</span></span><br></pre></td></tr></table></figure><h5 id="fgrepegrep-grep变体"><a class="markdownIt-Anchor" href="#fgrepegrep-grep变体"></a> fgrep，egrep grep变体</h5><p>fgrep，历史上使用，现在基本不用</p><p>egrep grep扩展版本，功能比grep强大，可以通过 grep -E的方式<br />-w 只匹配完整的单词，并且最好配合-l使用。</p><h4 id="look-选取以特定模式开头的行"><a class="markdownIt-Anchor" href="#look-选取以特定模式开头的行"></a> look 选取以特定模式开头的行</h4><p>格式： look [-df] pattern file…</p><p>作用： 搜索以字母顺序排列的数据，并查找所有以特定模式开头的行。然后输出这些行</p><p>look其实并不是一个过滤器，它只能从文件中读入，因此只能写于管道线的开头</p><p>-d 忽略标点和其他字符，本来是指搜索第一个单词</p><p>-f（fold同等） 忽略大写和小写的区别</p><h4 id="sort-排序"><a class="markdownIt-Anchor" href="#sort-排序"></a> sort 排序</h4><p>格式 sort [-dfnru] [-o outfile] [infile…]</p><p>作用： 排序数据和查看数据是否已经有序。他可以比较整行，也可以从每行中选取一部分进行比较。</p><p>sort可以重定向输出到另一个文件，但是不能输出到输入文件</p><p>例如： sort temp &gt; temp 是不可以的</p><p>但是可以使用-o选项，此时该文件中原有数据将会被保存，排序后的数据也会被追加到这个文件中</p><h5 id="-dfnr-控制数据排序的顺序"><a class="markdownIt-Anchor" href="#-dfnr-控制数据排序的顺序"></a> -dfnr 控制数据排序的顺序</h5><p>-d(dictionary) 只查看字母，数字和空白符，当确定有阻碍排序的因素（如标点符号等），可以使用这个选项。</p><p>-f（fold 等同）不区分大小写</p><p>-n（numeric 数字） 识别开头或者字段开头的数字，并按照数字进行排序</p><p>-r 反向排序</p><p>-u（unique 唯一） 对于相同行，只保留一行</p><h5 id="检测数据是否有序-c"><a class="markdownIt-Anchor" href="#检测数据是否有序-c"></a> 检测数据是否有序 -c</h5><p>-c（check） 不会排列数据，只会告诉数据是否有序，如果有序，将不会显示任何内容</p><h4 id="uniq-查找重复的行"><a class="markdownIt-Anchor" href="#uniq-查找重复的行"></a> uniq 查找重复的行</h4><p>语法： uniq [-cdu] [infile [outfile]</p><p>作用： 消除重复行，选取重复行，选取唯一行，统计重复行的数量。不加选项输出非重复行和只输出一次重复行</p><p>注意uniq的输入必须是有序的</p><p>-d 只查看重复行</p><p>-u 只查看非重复行</p><p>-c 统计重复行出现的次数</p><h4 id="join-合并两个文件的有序数据"><a class="markdownIt-Anchor" href="#join-合并两个文件的有序数据"></a> join 合并两个文件的有序数据</h4><p>相关过滤器： colrm cut paste</p><p>语法： join [-i] [-al|-vl] [-a2|-v2] [-l field1] [-2 field2] file1 file2</p><p>其中field是引用特定数段的数字</p><p>作用： 把两个文件中对应行合并到一起。但是这又和sort不同，sort是直接把两个文件拼接在一起，而join则是重复数据合并为一个输出。不重复数据直接输出。读取输入时，会忽略前导空白符。</p><p>不使用其他标号情况下，只会显示有匹配的连接字段（也就是两个文件对应行有相同字段），如果使用-a(all)选项，将会显示整个文件，后面要加a1或a2。a1代表把第一个文件中不匹配的内容也加上去。如果是v1，显示V1中不匹配的行</p><p>-1+sum 将第一个文件中的第sum个字段和第二个文件中的第一个字段进行匹配</p><h4 id="tsort-由偏序创建全序"><a class="markdownIt-Anchor" href="#tsort-由偏序创建全序"></a> tsort 由偏序创建全序</h4><p>语法： tsort file</p><p>作用：将一系列的事一件一件从头到尾输出</p><p>例如：两个单词第二个单词代表在第一个单词后要做的事</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">eat clean-<span class="keyword">dishes</span></span><br><span class="line"><span class="keyword">clean-dishes </span>watch-TV</span><br><span class="line"><span class="keyword">shop </span>cook</span><br><span class="line">cook eat</span><br></pre></td></tr></table></figure><p>在使用了tsort后，输出为</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">shop</span></span><br><span class="line"><span class="keyword">cook</span></span><br><span class="line"><span class="keyword">eat</span></span><br><span class="line"><span class="keyword">clean-dishes</span></span><br><span class="line"><span class="keyword">watch-TV</span></span><br></pre></td></tr></table></figure><h4 id="strings-在二进制文件中搜索字符串"><a class="markdownIt-Anchor" href="#strings-在二进制文件中搜索字符串"></a> strings 在二进制文件中搜索字符串</h4><p>语法： strings [-length] file…</p><p>在现代软件中基本都有这种功能，不再展开</p><h4 id="转换字符-tr"><a class="markdownIt-Anchor" href="#转换字符-tr"></a> 转换字符 tr</h4><p>语法： tr [-cds] [set1 [set2]]</p><p>set1是字符组</p><p>作用：可以将一个字符转化成另一个字符，例如将小写转化成大写，将制表符转化成空格，或者将0转化成x等。此外，还可以将多个字符变成一个字符，例如将多个空格转化成一个空格。最后，还可以删除指定字符，例如删除制表符。</p><p>例如： tr a A &lt; old tr a-z A-Z &lt; old</p><p>当需要替换的字符中出现由特殊意义的字符时，需要引用他们</p><p>还有几种特殊的缩写 [:lower:] 代表小写字母，[:upper:]代表大写字母，[:digit:]代表数字</p><p>tr还可以转换不可见字符</p><p>例如： tr ‘\n’ ‘\t’ &lt; old</p><p>参数：</p><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">s 多个字符变成一个字符 例如 tr -s <span class="string">&#x27; &#x27;</span> <span class="string">&#x27; &#x27;</span> &lt; old</span></span><br><span class="line"><span class="ruby">-d 删除指定字符</span></span><br><span class="line"><span class="ruby">-c 把没选上的字符变成另一个字符，例如 tr -c <span class="string">&#x27; \n&#x27;</span> x &lt; old，这个的意思就是除了空格和换行之外其他所有字符都变成x</span></span><br></pre></td></tr></table></figure><h4 id="sed-非交互式文本编辑"><a class="markdownIt-Anchor" href="#sed-非交互式文本编辑"></a> sed 非交互式文本编辑</h4><p>交互式文本编辑就是有一个窗口，例如gedit vi等。而非交互式则需要提前设计命令，然后将命令发给程序。</p><p>语法： sed [-i] command | -e command… [file…]</p><p>command是sed命令</p><p>作用： sed是一个标准的过滤器，可以对标准输入或者标准输出进行修改</p><p>sed从输入流中每次读取一行。然后执行下面三个步骤</p><ol><li>从输入流中读取一行</li><li>执行指定的命令，对该行进行必要的修改</li><li>将该行写入输出流中</li></ol><p>因为是修改标准输入或者标准输出，所以源文件不会被修改，如果要修改原文件，可以加上-i(in-place)选项，这个选项会将输出保存到一个临时文件，一但所有数据处理完，sed就会把临时文件复制到原文件中</p><h5 id="使用sed进行替换"><a class="markdownIt-Anchor" href="#使用sed进行替换"></a> 使用sed进行替换</h5><p>想要用sed对标准输入或输出的内容进行修改，可以采用 s命令</p><p>形式： /address|pattern/ s /search/replacement/[g]</p><p>address 是输入流中一个行或者多个行的地址，pattern是一个字符串，search是正则表达式，replacement是一个替换文本</p><p>例如 sed s/harley/Harley,这个例子意思就是把每一行的第一个harley改成Harley，如果想把所有都改了，那么在后面要加上一个g</p><p>如果只对一些行进行操作，可以用下列语法：</p><p>number[,number] /regex/</p><p>number是行号</p><p>例如： sed ‘5s/harley/Harley/g’ names</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中）</summary>
      
    
    
    
    <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>RNN及其拓展</title>
    <link href="http://xinhecuican.github.io/post/aa1eade8.html"/>
    <id>http://xinhecuican.github.io/post/aa1eade8.html</id>
    <published>2020-08-21T03:26:00.000Z</published>
    <updated>2020-10-19T13:59:13.555Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="rnn"><a class="markdownIt-Anchor" href="#rnn"></a> RNN</h1><p>RNN的特点是上一次输入会对下一次产生影响，相当于有了记忆功能，常用于自然语言处理。</p><p><img src="/images/RNN1.jpg" alt="" /></p><p>这是RNN的结构图，它与传统神经网络的区别是在隐藏层有了一个循环。</p><p><img src="/images/RNN2.jpg" alt="" /></p><p>这张图的含义是每一个时间点都可以有输出o，也可以没有。每一个时间点隐藏层输出作为下一个隐藏层的输入，也就是说该次训练对下一次训练会产生影响。</p><p>网上演示的时候隐藏层只有一层，这里就以一层为例。</p><p>隐藏层计算：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">z<span class="comment">(h)</span><span class="comment">(t)</span>=U⋅x<span class="comment">(t)</span>+W⋅s<span class="comment">(t−1)</span> <span class="attr">#s(t-1</span>)是前一刻隐藏层输出</span><br><span class="line">s<span class="comment">(t)</span>=fh<span class="comment">(z(h)</span><span class="comment">(t)</span>)</span><br></pre></td></tr></table></figure><p>s(t)是隐藏层输出， fh是激活函数，一般使用tanh或LeRu。</p><p>输出层使用softmax函数进行转换，然后损失函数使用交叉熵</p><p>Lt=−∑（N， i=0）yi(t)log(oi(t))</p><p>其中yi是真实值，oi是预测值</p><h2 id="bptt"><a class="markdownIt-Anchor" href="#bptt"></a> BPTT</h2><p>BPTT是RNN所使用的反向传播算法。它和传统反向传播算法的区别是它还要照顾到W（前一层到这一层的权重）</p><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C15.PNG" alt="" /></p><p>大体上还是使用这四个式子</p><p>δk(t) 表示t时刻损失函数对output layer 节点的输入zk(t)的导数（也就是求上面方程中第一个式子）。</p><p>δk(t) = o(t) - 1</p><p>所以∂Lt \ ∂V = (o(t) - 1) * s(t)</p><p>δk(h)(t) = [δ(o)(t) ⋅ Vk] ∙ [1 − sk(t)^2]</p><p>所以 ∂Lt \ ∂U = δ(h)(t) * x(t)</p><p>向w传播的 δ(h)(t−1)=[δ(h)(t)⋅W] ∙ <a href="%E8%BF%99%E9%87%8C%E5%8C%BA%E5%88%AB%E5%B0%B1%E6%98%AFs(t-1)%E5%92%8CW">1−s(t−1)^2</a></p><p>∂Lt \ ∂W = δ(h)(t) *  s(t-1)</p><h1 id="lstm"><a class="markdownIt-Anchor" href="#lstm"></a> LSTM</h1><p>RNN的缺陷是会出现梯度消失现象，因此无法保存长时间记忆。LSTM通过两条记忆途径使得可以保存长时间记忆。</p><p><img src="/images/RNN2.webp" alt="" /><br />这是LSTM的结构图，其中上面那一条线代表长时间记忆，下面那一条代表短时记忆。而保存在尝试记忆中的信息由几个门控制。</p><p><img src="/images/RNN3.webp" alt="" /></p><p>这是第一个门控忘记门，用来剔除不重要的信息。至于为什么能忘掉不重要信息，只能说这是神经网络自己决定的（没找到解释）。如果某一项为0代表舍弃，为1代表全部保留。</p><p>公式中<code>Wf⋅[ht−1,xt] = Wfh * h(t−1) + Wfx * xt</code>。wf可以看成是两个矩阵拼接而成，然后对应和输入相乘。</p><p><img src="/images/DNN4.webp" alt="" /></p><p>记忆门，这个门决定我们要记忆什么，迁前一部分是删去要舍弃的记忆，后面一部分是加上要记住的东西。注意Ct是tanh</p><p><img src="/images/DNN5.webp" alt="" />更新长期记忆。</p><p><img src="/images/DNN6.webp" alt="" /> 输出门。更新ht并输出</p><h2 id="反向更新"><a class="markdownIt-Anchor" href="#反向更新"></a> 反向更新</h2><p>首先确定更新内容。我们要更新四个b，四个w。其中w又要拆分成两部分，所以总共更新12个量。</p><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">δTo,<span class="built_in">t</span>=δTt⨀<span class="built_in">tanh</span>(ct)⨀ot⨀(<span class="number">1</span>−ot)</span><br><span class="line">δTf,<span class="built_in">t</span>=δTt⨀ot⨀(<span class="number">1</span>−<span class="built_in">tanh</span>(ct)<span class="number">2</span>)⨀ct−<span class="number">1</span>⨀ft⨀(<span class="number">1</span>−ft)</span><br><span class="line">δTi,<span class="built_in">t</span>=δTt⨀ot⨀(<span class="number">1</span>−<span class="built_in">tanh</span>(ct)<span class="number">2</span>)⨀ct^⨀it⨀(<span class="number">1</span>−it)</span><br><span class="line">δTc^,<span class="built_in">t</span>=δTt⨀ot⨀(<span class="number">1</span>−<span class="built_in">tanh</span>(ct)<span class="number">2</span>)⨀it⨀(<span class="number">1</span>−c^<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">yt=σ(Vht+by) // 当前状态输出</span><br><span class="line">δ<span class="built_in">t</span>=∂E \ ∂ht = Vσ`</span><br><span class="line"></span><br><span class="line">∂E \ ∂Woh,<span class="built_in">t</span> = δo,<span class="built_in">t</span> * h(<span class="built_in">t</span>−<span class="number">1</span>)</span><br><span class="line">其他三个 同理</span><br><span class="line"></span><br><span class="line">∂E \ ∂bo,<span class="built_in">t</span> = δo,<span class="built_in">t</span></span><br><span class="line">其他三个同理</span><br><span class="line"></span><br><span class="line">∂E \ ∂Wox = δo,<span class="built_in">t</span> * xt</span><br></pre></td></tr></table></figure><p><a href="https://ilewseu.github.io/2018/01/06/LSTM%E5%8F%82%E6%95%B0%E6%9B%B4%E6%96%B0%E6%8E%A8%E5%AF%BC/">反向更新具体过程可看</a></p><h1 id="gru"><a class="markdownIt-Anchor" href="#gru"></a> GRU</h1><p>GRU相比于LSTM所花的时间更短，但是达成的效果差不多。</p><p><img src="/images/RNN7.svg" alt="" />可以看到GRU只有一个参量要传递给下一个单元，并且需要更新的量也减少。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">Rt</span>=σ(Xt * Wxr+H(t−<span class="number">1</span>) * Whr+br)</span><br><span class="line"><span class="attr">Zt</span>=σ(Xt * Wxz+H(t−<span class="number">1</span>) * Whz+bz)</span><br></pre></td></tr></table></figure><p>这是重置门和更新门的计算公式，和LSTM计算方法相同，实际上GRU借鉴了LSTM的思想。</p><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">H~<span class="built_in">t</span>=<span class="built_in">tanh</span>(Xt * Wxh + (Rt ⊙ H(<span class="built_in">t</span>−<span class="number">1</span>)) * Whh + bh) #重置门指的是重置H(<span class="built_in">t</span>-<span class="number">1</span>)</span><br><span class="line">Ht=Zt ⊙ H(<span class="built_in">t</span>−<span class="number">1</span>) + (<span class="number">1</span>−Zt) ⊙ H~<span class="built_in">t</span></span><br><span class="line">最后的zt和<span class="number">1</span>-zt决定要记住新内容多还是老内容多，例如 zt=<span class="number">1</span>/<span class="number">3</span>, 那么老内容一次运行就只剩下<span class="number">1</span>/<span class="number">3</span>.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;rnn&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;</summary>
      
    
    
    
    <category term="机器学习" scheme="http://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>numpy</title>
    <link href="http://xinhecuican.github.io/post/fa288682.html"/>
    <id>http://xinhecuican.github.io/post/fa288682.html</id>
    <published>2020-08-03T01:30:00.000Z</published>
    <updated>2020-08-04T03:28:22.513Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>numpy用于矩阵计算，内置了大量矩阵计算的函数，并且速度也比列表快</p><p><strong>创建</strong></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy as np</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"><span class="string">    [2, 3]</span>,</span><br><span class="line"><span class="string">    [5, 8]</span>]</span><br><span class="line">c = np.<span class="built_in">array</span>(a)</span><br><span class="line">d = np.<span class="built_in">array</span>(b, <span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><p>通过array就把列表转化成了numpy的矩阵</p><ul><li>ones(shape, dtype): 这个是创建值全为1的矩阵，shape是矩阵的行和列数，dtype是矩阵数据类型。</li><li>zeros(shape, dtype): 创建全是零的矩阵</li><li>full(shape, constant_value, dtype): 创建指定数值的矩阵。其中constant_value是用来填充矩阵的值</li><li>eye(N): 创建单位矩阵，N是矩阵的维度</li><li>diag(v, k): 创建对角矩阵。v如果是一维则是创建对角矩阵，如果是二维是获取对角线上的元素。k=0表示获取主对角线上元素，k&gt;0则获取主对角线上方第k条对角线元素</li></ul><p><strong>创建随机数组</strong></p><ul><li>np.random.rand(shape): 创建一个值在0到1的随机数组。例如np.random.rand(10, 10, 3)是创建一个三维数组</li><li>uniform(low, high, shape): 创建一个值在low到high的随机数组</li><li>randint(low, high, shape): 创建一个值在low到high并且值是整数的随机数组</li><li>normal(loc, scale, shape): 给定均值，方差，维度的正态分布。</li></ul><p><strong>查看矩阵属性</strong></p><ul><li>size(): 获得矩阵元素个数</li><li>shape(): 获得矩阵的行和列，shape[0]是行，shape[1]是列.但是如果是一维数组那么shape[0]表示列数，没有shape[1]</li><li>ndim:  维数</li><li>dtype： 元素类型</li><li>T: 返回这个矩阵的转置</li></ul><p><strong>操作</strong></p><ul><li>np.copy(array): 复制矩阵</li><li>sort(a, axis): axis = 0是每行进行排序，1是每列进行排序，默认是对整个数组进行排序。a是用来排序的矩阵。如果是np.sort()那么原矩阵不改变。如果是array.sort()，原矩阵改变。</li><li>unique(a, return_index, retrun_inverse, return_counts, axis): 查找array中唯一元素。return_index是返回新列表中元素在旧列表出现第一个位置。return_counts是每个元素在原来矩阵中数量。return_inverse是返回一个索引数组，索引的是新列表元素位置。</li></ul><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="selector-tag">b</span> = np.diag(a)</span><br><span class="line">alpha, beta = np.unique(<span class="selector-tag">b</span>, return_counts=True)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(alpha)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(beta)</span></span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">20</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">a = [1, 2, 3, 4, 5]</span><br><span class="line">b = np.diag(a)</span><br><span class="line">alpha, beta = np.unique(b, return_inverse=True)</span><br><span class="line">print(alpha)</span><br><span class="line">print(beta)</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">[0<span class="number"> 1 </span>2<span class="number"> 3 </span>4 5]</span><br><span class="line">[1<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>2<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>3<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>4<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>5]</span><br></pre></td></tr></table></figure><ul><li>array.reshape(shape): 改变形状，但是元素个数不变，如果改变形状后元素数目和原来不同会报错。原数组改变</li><li>array.resize(shape): 改变形状,元素个数可变，不足补零。如果小于原来数目会输出None，采取逐个填充的方法。</li></ul><p><strong>计算</strong></p><ul><li><code>+</code>： 矩阵加法，让矩阵中每个元素都相加。例如a+5是矩阵中每个元素都加五。a+b是矩阵中对应元素相加</li><li><code>*</code>： 注意矩阵乘法是dot函数，这个是对应元素相乘</li><li>==: 矩阵中逐个元素进行比对，然后返回一个bool型矩阵，如果两个矩阵对应位置相同那么bool型矩阵对应位置就是True。</li><li>dot(): 矩阵相乘</li><li>delete(a, elements, axis): 矩阵删除行或列。elements是删除的行或列的序号</li><li>append()</li><li>insert()</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;numpy用于矩阵计算，内置了大量矩阵计算的函数，并且速度也比列表快&lt;/p&gt;</summary>
      
    
    
    
    <category term="机器学习" scheme="http://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>层次聚类</title>
    <link href="http://xinhecuican.github.io/post/2ba82a45.html"/>
    <id>http://xinhecuican.github.io/post/2ba82a45.html</id>
    <published>2020-07-30T02:34:00.000Z</published>
    <updated>2020-08-05T00:59:43.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>层次聚类（hierarchical clustering)就是不断把最近的类合并知道达到要求为止。这是一种树形结构</p><p>大致过程：</p><ol><li>初始化，每个实例看做一类</li><li>合并， 算出每两个类之间的距离，然后把距离最近的两个类合并成一个类</li><li>终止条件可以是最近两个类之间的距离</li></ol><p>计算两个类之间距离的方法</p><ol><li>SingleLinkage: 这种方法是以两个类中最短距离代表两个类之间的距离。但是这种方法可能出现链式反应，即抓到了一个离其他点十分近的点就抓到了一群点，但实际上分属两团</li><li>CompleteLinkage： 这种方法是找两个类中最长点距离</li><li>AverageLinkage： 这种方法是把两个类中所有点的距离求出来再求平均值，或者也可以取中值</li></ol><h1 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Code for hierarchical clustering, modified from </span></span><br><span class="line"><span class="string">Programming Collective Intelligence by Toby Segaran </span></span><br><span class="line"><span class="string">(O&#x27;Reilly Media 2007, page 33). </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cluster_node</span>:</span> <span class="comment"># 树节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,vec,left=<span class="literal">None</span>,right=<span class="literal">None</span>,distance=<span class="number">0.0</span>,<span class="built_in">id</span>=<span class="literal">None</span>,count=<span class="number">1</span></span>):</span></span><br><span class="line">        self.left=left</span><br><span class="line">        self.right=right</span><br><span class="line">        self.vec=vec</span><br><span class="line">        self.<span class="built_in">id</span>=<span class="built_in">id</span></span><br><span class="line">        self.distance=distance</span><br><span class="line">        self.count=count <span class="comment">#only used for weighted average </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L2dist</span>(<span class="params">v1,v2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(<span class="built_in">sum</span>((v1-v2)**<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L1dist</span>(<span class="params">v1,v2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">abs</span>(v1-v2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># def Chi2dist(v1,v2):</span></span><br><span class="line"><span class="comment">#     return sqrt(sum((v1-v2)**2))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hcluster</span>(<span class="params">features,distance=L2dist</span>):</span></span><br><span class="line">    <span class="comment">#cluster the rows of the &quot;features&quot; matrix</span></span><br><span class="line">    distances=&#123;&#125;</span><br><span class="line">    currentclustid=-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># clusters are initially just the individual rows</span></span><br><span class="line">    clust=[cluster_node(array(features[i]),<span class="built_in">id</span>=i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(features))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(clust)&gt;<span class="number">1</span>:</span><br><span class="line">        lowestpair=(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        closest=distance(clust[<span class="number">0</span>].vec,clust[<span class="number">1</span>].vec)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># loop through every pair looking for the smallest distance</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(clust)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(clust)):</span><br><span class="line">                <span class="comment"># distances is the cache of distance calculations</span></span><br><span class="line">                <span class="keyword">if</span> (clust[i].<span class="built_in">id</span>,clust[j].<span class="built_in">id</span>) <span class="keyword">not</span> <span class="keyword">in</span> distances: </span><br><span class="line">                    distances[(clust[i].<span class="built_in">id</span>,clust[j].<span class="built_in">id</span>)]=distance(clust[i].vec,clust[j].vec)</span><br><span class="line">        </span><br><span class="line">                d=distances[(clust[i].<span class="built_in">id</span>,clust[j].<span class="built_in">id</span>)]</span><br><span class="line">        </span><br><span class="line">                <span class="keyword">if</span> d&lt;closest:</span><br><span class="line">                    closest=d</span><br><span class="line">                    lowestpair=(i,j) <span class="comment"># 这里是使用第一种方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># calculate the average of the two clusters</span></span><br><span class="line">        mergevec=[(clust[lowestpair[<span class="number">0</span>]].vec[i]+clust[lowestpair[<span class="number">1</span>]].vec[i])/<span class="number">2.0</span> \</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(clust[<span class="number">0</span>].vec))]</span><br><span class="line">        <span class="comment"># 平均距离</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># create the new cluster</span></span><br><span class="line">        newcluster=cluster_node(array(mergevec),left=clust[lowestpair[<span class="number">0</span>]],</span><br><span class="line">                             right=clust[lowestpair[<span class="number">1</span>]],</span><br><span class="line">                             distance=closest,<span class="built_in">id</span>=currentclustid)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># cluster ids that weren&#x27;t in the original set are negative</span></span><br><span class="line">        currentclustid-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">del</span> clust[lowestpair[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">del</span> clust[lowestpair[<span class="number">0</span>]]</span><br><span class="line">        clust.append(newcluster)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clust[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_clusters</span>(<span class="params">clust,dist</span>):</span></span><br><span class="line">    <span class="comment"># extract list of sub-tree clusters from hcluster tree with distance&lt;dist</span></span><br><span class="line">    clusters = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> clust.distance&lt;dist:</span><br><span class="line">        <span class="comment"># we have found a cluster subtree</span></span><br><span class="line">        <span class="keyword">return</span> [clust] </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># check the right and left branches</span></span><br><span class="line">        cl = []</span><br><span class="line">        cr = []</span><br><span class="line">        <span class="keyword">if</span> clust.left!=<span class="literal">None</span>: </span><br><span class="line">            cl = extract_clusters(clust.left,dist=dist)</span><br><span class="line">        <span class="keyword">if</span> clust.right!=<span class="literal">None</span>: </span><br><span class="line">            cr = extract_clusters(clust.right,dist=dist)</span><br><span class="line">        <span class="keyword">return</span> cl+cr </span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cluster_elements</span>(<span class="params">clust</span>):</span></span><br><span class="line">    <span class="comment"># return ids for elements in a cluster sub-tree</span></span><br><span class="line">    <span class="keyword">if</span> clust.<span class="built_in">id</span>&gt;=<span class="number">0</span>:</span><br><span class="line">        <span class="comment"># positive id means that this is a leaf</span></span><br><span class="line">        <span class="keyword">return</span> [clust.<span class="built_in">id</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># check the right and left branches</span></span><br><span class="line">        cl = []</span><br><span class="line">        cr = []</span><br><span class="line">        <span class="keyword">if</span> clust.left!=<span class="literal">None</span>: </span><br><span class="line">            cl = get_cluster_elements(clust.left)</span><br><span class="line">        <span class="keyword">if</span> clust.right!=<span class="literal">None</span>: </span><br><span class="line">            cr = get_cluster_elements(clust.right)</span><br><span class="line">        <span class="keyword">return</span> cl+cr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printclust</span>(<span class="params">clust,labels=<span class="literal">None</span>,n=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="comment"># indent to make a hierarchy layout</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="built_in">print</span> <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">    <span class="keyword">if</span> clust.<span class="built_in">id</span>&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="comment"># negative id means that this is branch</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># positive id means that this is an endpoint</span></span><br><span class="line">        <span class="keyword">if</span> labels==<span class="literal">None</span>: <span class="built_in">print</span> clust.<span class="built_in">id</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="built_in">print</span> labels[clust.<span class="built_in">id</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># now print the right and left branches</span></span><br><span class="line">    <span class="keyword">if</span> clust.left!=<span class="literal">None</span>: printclust(clust.left,labels=labels,n=n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> clust.right!=<span class="literal">None</span>: printclust(clust.right,labels=labels,n=n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getheight</span>(<span class="params">clust</span>):</span></span><br><span class="line">    <span class="comment"># Is this an endpoint? Then the height is just 1</span></span><br><span class="line">    <span class="keyword">if</span> clust.left==<span class="literal">None</span> <span class="keyword">and</span> clust.right==<span class="literal">None</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Otherwise the height is the same of the heights of</span></span><br><span class="line">    <span class="comment"># each branch</span></span><br><span class="line">    <span class="keyword">return</span> getheight(clust.left)+getheight(clust.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getdepth</span>(<span class="params">clust</span>):</span></span><br><span class="line">    <span class="comment"># The distance of an endpoint is 0.0</span></span><br><span class="line">    <span class="keyword">if</span> clust.left==<span class="literal">None</span> <span class="keyword">and</span> clust.right==<span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># The distance of a branch is the greater of its two sides</span></span><br><span class="line">    <span class="comment"># plus its own distance</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(getdepth(clust.left),getdepth(clust.right))+clust.distance</span><br><span class="line">      </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="机器学习" scheme="http://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>K-means</title>
    <link href="http://xinhecuican.github.io/post/766f9b60.html"/>
    <id>http://xinhecuican.github.io/post/766f9b60.html</id>
    <published>2020-07-30T00:18:00.000Z</published>
    <updated>2020-07-30T02:34:24.883Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>k-means算法属于非监督学习，也就是事先不知道给的数据属于那一类，需要自己去分类。它的基本思想是把数据点密集的一群分成一类。</p><p>具体过程：</p><ol><li>随机选择k个类的初始中心</li><li>在c次迭代中，对任意一个样本，求到各中心点之间的距离，将该样本归类到最近中心的那个类</li><li>使用均值等方法更新中心点。</li><li>如果两次更新匪类相同也结束</li></ol><p>例如划分三个点(1, 1) (2, 3) (4, 6)是一类，那么新的中心点是((1+2+4)/3, (1+3+6)/3),不一定要在原有点上</p><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">import</span> numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function: K Means</span></span><br><span class="line"><span class="comment"># -------------</span></span><br><span class="line"><span class="comment"># K-Means is an algorithm that takes in a dataset and a constant</span></span><br><span class="line"><span class="comment"># k and returns k centroids (which define clusters of data in the</span></span><br><span class="line"><span class="comment"># dataset which are similar to one another).</span></span><br><span class="line"><span class="attribute">def</span> kmeans(X, k, maxIt): # maxIt是初始化次数</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">numPoints</span>, numDim = X.shape</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">dataSet</span> = np.zeros((numPoints, numDim + <span class="number">1</span>))</span><br><span class="line">    <span class="attribute">dataSet</span>[:, :-<span class="number">1</span>] = X # 初始化赋值</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize centroids randomly</span></span><br><span class="line">    <span class="attribute">centroids</span> = dataSet[np.random.randint(numPoints, size = k), :] # 随机选取中心点</span><br><span class="line">    <span class="comment">#centroids = dataSet[0:2, :]</span></span><br><span class="line">    <span class="comment">#Randomly assign labels to initial centorid</span></span><br><span class="line">    <span class="attribute">centroids</span>[:, -<span class="number">1</span>] = range(<span class="number">1</span>, k +<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize book keeping vars.</span></span><br><span class="line">    <span class="attribute">iterations</span> = <span class="number">0</span></span><br><span class="line">    <span class="attribute">oldCentroids</span> = None</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Run the main k-means algorithm</span></span><br><span class="line">    <span class="attribute">while</span> not shouldStop(oldCentroids, centroids, iterations, maxIt):</span><br><span class="line">        <span class="attribute">print</span> <span class="string">&quot;iteration: \n&quot;</span>, iterations</span><br><span class="line">        <span class="attribute">print</span> <span class="string">&quot;dataSet: \n&quot;</span>, dataSet</span><br><span class="line">        <span class="attribute">print</span> <span class="string">&quot;centroids: \n&quot;</span>, centroids</span><br><span class="line">        <span class="comment"># Save old centroids for convergence test. Book keeping.</span></span><br><span class="line">        <span class="attribute">oldCentroids</span> = np.copy(centroids)</span><br><span class="line">        <span class="attribute">iterations</span> += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Assign labels to each datapoint based on centroids</span></span><br><span class="line">        <span class="attribute">updateLabels</span>(dataSet, centroids)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Assign centroids based on datapoint labels</span></span><br><span class="line">        <span class="attribute">centroids</span> = getCentroids(dataSet, k)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># We can get the labels too by calling getLabels(dataSet, centroids)</span></span><br><span class="line">    <span class="attribute">return</span> dataSet</span><br><span class="line"><span class="comment"># Function: Should Stop</span></span><br><span class="line"><span class="comment"># -------------</span></span><br><span class="line"><span class="comment"># Returns True or False if k-means is done. K-means terminates either</span></span><br><span class="line"><span class="comment"># because it has run a maximum number of iterations OR the centroids</span></span><br><span class="line"><span class="comment"># stop changing.</span></span><br><span class="line"><span class="attribute">def</span> shouldStop(oldCentroids, centroids, iterations, maxIt):</span><br><span class="line">    <span class="attribute">if</span> iterations &gt; maxIt:</span><br><span class="line">        <span class="attribute">return</span> True</span><br><span class="line">    <span class="attribute">return</span> np.array_equal(oldCentroids, centroids)  </span><br><span class="line"><span class="comment"># Function: Get Labels</span></span><br><span class="line"><span class="comment"># -------------</span></span><br><span class="line"><span class="comment"># Update a label for each piece of data in the dataset. </span></span><br><span class="line"><span class="attribute">def</span> updateLabels(dataSet, centroids):</span><br><span class="line">    <span class="comment"># For each element in the dataset, chose the closest centroid. </span></span><br><span class="line">    <span class="comment"># Make that centroid the element&#x27;s label.</span></span><br><span class="line">    <span class="attribute">numPoints</span>, numDim = dataSet.shape</span><br><span class="line">    <span class="attribute">for</span> i in range(<span class="number">0</span>, numPoints):</span><br><span class="line">        <span class="attribute">dataSet</span>[i, -<span class="number">1</span>] = getLabelFromClosestCentroid(dataSet[i, :-<span class="number">1</span>], centroids)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="attribute">def</span> getLabelFromClosestCentroid(dataSetRow, centroids):</span><br><span class="line">    <span class="attribute">label</span> = centroids[<span class="number">0</span>, -<span class="number">1</span>];</span><br><span class="line">    <span class="attribute">minDist</span> = np.linalg.norm(dataSetRow - centroids[<span class="number">0</span>, :-<span class="number">1</span>])</span><br><span class="line">    <span class="attribute">for</span> i in range(<span class="number">1</span> , centroids.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="attribute">dist</span> = np.linalg.norm(dataSetRow - centroids[i, :-<span class="number">1</span>])</span><br><span class="line">        <span class="attribute">if</span> dist &lt; minDist:</span><br><span class="line">            <span class="attribute">minDist</span> = dist</span><br><span class="line">            <span class="attribute">label</span> = centroids[i, -<span class="number">1</span>]</span><br><span class="line">    <span class="attribute">print</span> <span class="string">&quot;minDist:&quot;</span>, minDist</span><br><span class="line">    <span class="attribute">return</span> label</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="comment"># Function: Get Centroids</span></span><br><span class="line"><span class="comment"># -------------</span></span><br><span class="line"><span class="comment"># Returns k random centroids, each of dimension n.</span></span><br><span class="line"><span class="attribute">def</span> getCentroids(dataSet, k): # 算出新的中心点</span><br><span class="line">    <span class="comment"># Each centroid is the geometric mean of the points that</span></span><br><span class="line">    <span class="comment"># have that centroid&#x27;s label. Important: If a centroid is empty (no points have</span></span><br><span class="line">    <span class="comment"># that centroid&#x27;s label) you should randomly re-initialize it.</span></span><br><span class="line">    <span class="attribute">result</span> = np.zeros((k, dataSet.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="attribute">for</span> i in range(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">        <span class="attribute">oneCluster</span> = dataSet[dataSet[:, -<span class="number">1</span>] == i, :-<span class="number">1</span>]</span><br><span class="line">        <span class="attribute">result</span>[i - <span class="number">1</span>, :-<span class="number">1</span>] = np.mean(oneCluster, axis = <span class="number">0</span>)</span><br><span class="line">        <span class="attribute">result</span>[i - <span class="number">1</span>, -<span class="number">1</span>] = i</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">return</span> result</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="attribute">x1</span> = np.array([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="attribute">x2</span> = np.array([<span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="attribute">x3</span> = np.array([<span class="number">4</span>, <span class="number">3</span>])</span><br><span class="line"><span class="attribute">x4</span> = np.array([<span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"><span class="attribute">testX</span> = np.vstack((x<span class="number">1</span>, x<span class="number">2</span>, x<span class="number">3</span>, x<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="attribute">result</span> = kmeans(testX, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"><span class="attribute">print</span> <span class="string">&quot;final result:&quot;</span></span><br><span class="line"><span class="attribute">print</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xinhecuican.github.io/post/2ae43b86.html"/>
    <id>http://xinhecuican.github.io/post/2ae43b86.html</id>
    <published>2020-07-29T02:11:49.000Z</published>
    <updated>2020-07-29T02:14:41.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="逻辑回归logistic-regression"><a class="markdownIt-Anchor" href="#逻辑回归logistic-regression"></a> 逻辑回归（logistic regression)</h1><p>非线性回归例子：<img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%921.PNG" alt="" />.这个例子中的关系不能很好的用线性关系进行模拟，所以我们要另外做曲线模拟它。</p><p><img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%A8%A1%E6%8B%9F2.PNG" alt="" />为了更好的处理，还需要用sigmoid函数平滑化。</p><p>sigmoid函数图像为 <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C7.PNG" alt="" /></p><p>所以预测函数为： <img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BB3.PNG" alt="" /></p><p><img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%924.jpg" alt="" /></p><p>我们要求解的问题可以转化成，求解一组参数使得J()最小化。求解方法时求偏导让导数为零。</p><p>当然上面这个方法求解过于复杂，我们也可以使用梯度下降的方法。非线性方程其实就是一个超平面，我们可以求偏导找出梯度，沿着梯度下降的方向不断走就可以找到最低点。</p><p>求解函数为  <img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%925.PNG" alt="" /></p><p>其中a是更新率（learning weight）</p><p>所以求完偏导的结果为：<img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%926.PNG" alt="" /></p><p>h(x) = theta * x(i)</p><p>这就是更新函数，我们呢需要重复更新直到收敛</p><h1 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genData</span>(<span class="params">numPoints,bias,variance</span>):</span></span><br><span class="line"><span class="comment"># 产生实验数据，其中numpoint是实验个数，bias是偏差，variance是方差</span></span><br><span class="line">    x = np.zeros(shape=(numPoints,<span class="number">2</span>))</span><br><span class="line">    y = np.zeros(shape=(numPoints))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,numPoints):</span><br><span class="line">        x[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        x[i][<span class="number">1</span>]=i</span><br><span class="line">        y[i]=(i+bias)+random.uniform(<span class="number">0</span>,<span class="number">1</span>)+variance</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span>(<span class="params">x,y,theta,alpha,m,numIterations</span>):</span></span><br><span class="line"><span class="comment"># alpha是学习率 \ theta是我们要求的，开始可以随意赋值 \ m是实例个数 \ numIterations是重复次数</span></span><br><span class="line">    xTran = np.transpose(x) <span class="comment"># 转置，为了好算</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numIterations):</span><br><span class="line">        hypothesis = np.dot(x,theta) <span class="comment"># dot是点积，算出h(x)。这个是一次全更新完</span></span><br><span class="line">        loss = hypothesis-y</span><br><span class="line">        cost = np.<span class="built_in">sum</span>(loss**<span class="number">2</span>)/(<span class="number">2</span>*m) <span class="comment"># 这个算法和上面讲的有所不同，相当于(h(x)-y(i)) * x(j)求和</span></span><br><span class="line">        gradient=np.dot(xTran,loss)/m</span><br><span class="line">        theta = theta-alpha*gradient</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;Iteration %d | cost :%f&quot;</span> %(i,cost))</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line">x,y = genData(<span class="number">100</span>, <span class="number">25</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;x:&quot;</span></span><br><span class="line"><span class="built_in">print</span> x</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;y:&quot;</span></span><br><span class="line"><span class="built_in">print</span> y</span><br><span class="line"></span><br><span class="line">m,n = np.shape(x)</span><br><span class="line">n_y = np.shape(y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;m:&quot;</span>+<span class="built_in">str</span>(m)+<span class="string">&quot; n:&quot;</span>+<span class="built_in">str</span>(n)+<span class="string">&quot; n_y:&quot;</span>+<span class="built_in">str</span>(n_y))</span><br><span class="line"></span><br><span class="line">numIterations = <span class="number">100000</span></span><br><span class="line">alpha = <span class="number">0.0005</span></span><br><span class="line">theta = np.ones(n)</span><br><span class="line">theta= gradientDescent(x, y, theta, alpha, m, numIterations)</span><br><span class="line">print(theta)</span><br></pre></td></tr></table></figure><h1 id="使用线性回归还是非线性回归"><a class="markdownIt-Anchor" href="#使用线性回归还是非线性回归"></a> 使用线性回归还是非线性回归</h1><p>在高中已经学过了，如果是一元线性回归的话会使用相关系数r来描述相关性，来决定是否使用线性回归。它的公式是<br /><img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%9210.png" alt="" /></p><p>如果是多元线性回归就要用<img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%9211.jpg" alt="" /></p><p>这个公式中第一个yi是估计值，也就是说先要把回归方程求出来再估计相关性。</p><p>但是R^2会受样本量影响，随样本量增大而增大，所以要一个小小的改进。</p><p><img src="/images/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%83%A1%E7%88%BD12.png" alt="" /></p><p>这个方程就是改进后的方程，先把开始的R^2算出来，然后带入，其中N是样本个数，P是维数（自变量个数）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;逻辑回归logistic-regression&quot;&gt;&lt;a class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线性回归</title>
    <link href="http://xinhecuican.github.io/post/40997091.html"/>
    <id>http://xinhecuican.github.io/post/40997091.html</id>
    <published>2020-07-26T00:39:00.000Z</published>
    <updated>2020-07-27T02:33:18.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><p>简单线性回归指的是只有一个x和一个y</p><p>用来描述自变量和因变量及偏差之间关系的模型叫做回归模型</p><p>简单线性回归的模型是：<img src="/images/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%921.png" alt="" /></p><p>b0是截距，b1是斜率，e是偏差。</p><p><strong>关于偏差</strong></p><ul><li>他是一个随机变量，均值是0</li><li>它的方差对于所有自变量x是相同的</li><li>它的值是独立的</li><li>它满足正太分布</li></ul><p>线性回归方程就是少了偏差，其他和基本模型是相同的。</p><p>我们现在给若干x和y，要解决的问题是找出最好的截距和斜率。</p><h1 id="线性回归的求解"><a class="markdownIt-Anchor" href="#线性回归的求解"></a> 线性回归的求解</h1><p>我们要找最能代表趋势的直线，实际上就是要找距离所有点最近的直线。</p><p><img src="/images/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%922.PNG" alt="" />我们就是要找一条直线使得这个值最小，其中y^i是用这条直线求出来的估计值，yi是这个点的值。</p><p><img src="/images/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%923.PNG" alt="" />求解这个问题的数学公式</p><h1 id="多元线性回归"><a class="markdownIt-Anchor" href="#多元线性回归"></a> 多元线性回归</h1><p>它与一元线性回归的区别就是有多个自变量</p><p><img src="/images/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%925.PNG" alt="" /> 具体模型求解过程涉及线代高数等内容，这里不再详解。</p><p>使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> genfromtxt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line">dataPath = <span class="string">r&quot;Delivery.csv&quot;</span></span><br><span class="line">deliveryData = genfromtxt(dataPath,delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;data&quot;</span></span><br><span class="line"><span class="built_in">print</span> deliveryData</span><br><span class="line"></span><br><span class="line">x= deliveryData[:,:-<span class="number">1</span>]</span><br><span class="line">y = deliveryData[:,-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> x</span><br><span class="line"><span class="built_in">print</span> y</span><br><span class="line"></span><br><span class="line">lr = linear_model.LinearRegression() <span class="comment"># 模型</span></span><br><span class="line">lr.fit(x, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> lr</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;coefficients:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> lr.coef_ <span class="comment"># 估计参数 b1,...</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;intercept:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> lr.intercept_ <span class="comment"># b0</span></span><br><span class="line"></span><br><span class="line">xPredict = [<span class="number">102</span>,<span class="number">6</span>]</span><br><span class="line">yPredict = lr.predict(xPredict)</span><br><span class="line">print(<span class="string">&quot;predict:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> yPredict</span><br></pre></td></tr></table></figure><p>如果是分类型变量，我们需要转化成01再来运算。</p><p>例如男女就是分类型变量。假设一个人是男的，那么可以让它的自变量变成10。如果是女则是01，这样把一个自变量变成多个自变量从而当成数据型变量进行计算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor</summary>
      
    
    
    
    <category term="机器学习" scheme="http://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>神经网络（NN）</title>
    <link href="http://xinhecuican.github.io/post/7ca31f7.html"/>
    <id>http://xinhecuican.github.io/post/7ca31f7.html</id>
    <published>2020-07-24T02:35:00.000Z</published>
    <updated>2020-08-23T03:25:10.604Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="多层向前神经网络"><a class="markdownIt-Anchor" href="#多层向前神经网络"></a> 多层向前神经网络</h1><p>该神经网络的层数大的有三层：输入层， 隐藏层（隐藏层可以有多层）， 输出层。</p><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C1.png" alt="" />该图是两层神经网络（输入层不算）</p><p>每层由单元组成（例如决策树算法中的一和零）。输入层就是传入一些特征向量。</p><p><strong>理解</strong>：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">下一层的神经元可以看成y，然后每个w可以看成k，那么其实就是一条直线。有些层次用来做 <span class="meta">&amp;&amp; 或 || 的操作，这样就可以用多条直线对区域进行划分.</span></span><br></pre></td></tr></table></figure><p>权重： 每两层有线进行连接，线上的数值就是权重，我们是通过特征向量和权重相乘求和再用非线性方程转化得到下一层的</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>. 设计神经网络结构</span><br><span class="line">     <span class="number">3</span>.<span class="number">1</span> 使用神经网络训练数据之前，必须确定神经网络的层数，以及每层单元的个数</span><br><span class="line">     <span class="number">3</span>.<span class="number">2</span> 特征向量在被传入输入层时通常被先标准化(<span class="keyword">normalize）到0和1之间 </span>（为了加速学习过程）</span><br><span class="line">     <span class="number">3</span>.<span class="number">3</span> 离散型变量可以被编码成每一个输入单元对应一个特征值可能赋的值</span><br><span class="line">          比如：特征值A可能取三个值（<span class="built_in">a0</span>, <span class="built_in">a1</span>, <span class="built_in">a2</span>), 可以使用<span class="number">3</span>个输入单元来代表A。</span><br><span class="line">                    如果A=<span class="built_in">a0</span>, 那么代表<span class="built_in">a0</span>的单元值就取<span class="number">1</span>, 其他取<span class="number">0</span>；</span><br><span class="line">                    如果A=<span class="built_in">a1</span>, 那么代表a1de单元值就取<span class="number">1</span>，其他取<span class="number">0</span>，以此类推</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>.<span class="number">4</span> 神经网络即可以用来做分类(classification）问题，也可以解决回归(regression)问题</span><br><span class="line">          <span class="number">3</span>.<span class="number">4</span>.<span class="number">1</span> 对于分类问题，如果是<span class="number">2</span>类，可以用一个输出单元表示（<span class="number">0</span>和<span class="number">1</span>分别代表<span class="number">2</span>类,例如黑和白，不是黑就是白，所以只需要输出一类）</span><br><span class="line">                   如果多于<span class="number">2</span>类，每一个类别用一个输出单元表示</span><br><span class="line">                   所以输入层的单元数量通常等于类别的数量</span><br><span class="line"></span><br><span class="line">          <span class="number">3</span>.<span class="number">4</span>.<span class="number">2</span> 没有明确的规则来设计最好有多少个隐藏层</span><br><span class="line">                    <span class="number">3</span>.<span class="number">4</span>.<span class="number">2</span>.<span class="number">1</span> 根据实验测试和误差，以及准确度来实验并改进</span><br></pre></td></tr></table></figure><p><strong>交叉验证方法</strong></p><p>这是一种验证正确率的方法。例如我们把样例集分成10份，第一次用第一份做测试集，其他做训练集，第二次用第二个做测试集，其他做训练集。这样做十次得到的正确率再求平均值。当然划分不一定是十份。</p><p><strong>神经网络训练大致过程</strong>： 先根据输入确定结果，通过预测结果和真实结果之间的误差反推更新权重。</p><p>开始的时候可以随机的在1到-1之间给权重</p><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C2.png" alt="" /></p><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C3.png" alt="" /></p><p>下面这个式子就是从下一层的计算公式，单元值乘以权重求和然后再加上偏向(oj)</p><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C4.png" alt="" /></p><p>前面到Bias的部分已经提到了，就是上面那个方程，最后还需要经过一个非线性函数（激活函数）。</p><p>激活函数：</p><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C5.png" alt="" /></p><p>其中Ij就是前面提到的函数。</p><p>之后反向更新权重：</p><p>对于输出层：<br /><img src="/images/pasted-10.png" alt="" />Tj是输出层标签真实值</p><p>对于隐藏层：<br /><img src="/images/pasted-11.png" alt="" />其中Errk是前面一层的误差</p><p>权重更新：</p><p><img src="/images/pasted-12.png" alt="" /></p><p>l是学习率（learning weight），这是我们手工设置的值，在零到一之间</p><p>偏向更新：<br /><img src="/images/pasted-13.png" alt="upload successful" /></p><p>终止条件：</p><ul><li>权重的更新低于某个阈值</li><li><pre><code>         预测的错误率低于某个阈值</code></pre></li><li><pre><code>         达到预设一定的循环次数</code></pre></li></ul><h2 id="梯度下降算法"><a class="markdownIt-Anchor" href="#梯度下降算法"></a> 梯度下降算法</h2><p>数学中梯度指的是函数关于各个偏导的一个向量，它的意义是指向上升最快的方向。因此负梯度就是下降最快的方向。</p><p>梯度下降算法的基本思想就是沿着梯度每次走一定距离，然后再次计算梯度，重复步骤直到走到最低点。这里的最低点是极值而不是最值</p><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C14.jpg" alt="" />以二维为例。如果让x在最低点左边。x-梯度（导数），那么x增大，朝着最低点靠近。如果在右边x-梯度，x减小，同样朝着最低点靠近。</p><p>我们是根据loss function来对神经网络进行调整的。而lossfunction的参数就是w和bias，因此可以对w和bias求偏导然后w- 偏导对w进行修正。</p><p><strong>随机梯度下降算法</strong>： 多次随机选取一些样本（mini-batch)，直到所有样例都被选取。</p><h2 id="反向更新"><a class="markdownIt-Anchor" href="#反向更新"></a> 反向更新</h2><p>反向更新利用了梯度下降算法。也就是使用 w = wi - (delta)w的方式进行更新。</p><p>(delta)w = L * 偏Cost / 偏w ， 所以我们的目标就是要求出偏导。</p><p>反向更新主要用到了四个式子。<br /><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C15.PNG" alt="" /></p><p>这几个式子都有证明，这里不详细描述。</p><ul><li>第三个和第四个式子就是偏导，我们看到其中的量可以通过第一个和第二个方程求出来。</li><li>第一个式子是对于输出层来说的。右边第一项指的是cost关于a（预测值）的偏导。这里cost的计算式为 (预测值-实际值)的平方求和再除以2n。因此偏导就是预测值减去实际值。后面一项是激活函数的导数。</li><li>第二个式子是对于其他层。</li></ul><p>这里还有另一种cost <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C16.PNG" alt="" /></p><p>它的偏导数为<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C17.PNG" alt="" /> <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C18.PNG" alt="" />.</p><p>这个偏导数好在偏导的大小由a-y决定。a-y其实就是error。 error大，下降就要快。</p><p><strong>推导过程</strong></p><p>其实反向更新就是求偏导 <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C27.png" alt="" /><br />这张图表示的是从输出反向推第一个权重，也就是上面的第一个式子。</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">net</span> = w * x + b</span><br><span class="line"><span class="keyword">out</span> = 1 / 1 + <span class="keyword">e</span>^(-<span class="keyword">net</span>)</span><br><span class="line">∂<span class="keyword">E</span> / ∂<span class="keyword">out</span> = target - <span class="keyword">out</span></span><br><span class="line">∂<span class="keyword">out</span> / ∂<span class="keyword">net</span> = <span class="keyword">net</span> * (1 - <span class="keyword">net</span>)</span><br><span class="line">∂<span class="keyword">net</span> / ∂w = x</span><br><span class="line">∂<span class="keyword">E</span> / ∂w = (target - <span class="keyword">out</span>) * <span class="keyword">net</span> * (1 - <span class="keyword">net</span>) * x</span><br></pre></td></tr></table></figure><p>再看另一个例子<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C28.png" alt="" />这里就可以解释为什么有个求和的过程了，到w不只有一条路，而这里多了两个偏导∂outh1 / ∂neth1 和 ∂neth1 / ∂w1.这里的数值和前面是一样的。</p><p>有一点和前面不同，前面是∂E / ∂w，这里是∂E / ∂outh1。所以前面最后乘了一个x而这里乘了一个w。</p><h2 id="非线性转化函数"><a class="markdownIt-Anchor" href="#非线性转化函数"></a> 非线性转化函数</h2><p>激活函数一般使用S型曲线（sigmoid）。一般是双曲函数(tanh)或逻辑函数。</p><p>广义上的sigmoid函数需要在-1到1之间变化并且平滑。</p><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C7.PNG" alt="" /></p><p><strong>双曲函数</strong>：</p><p>tanhx = sinhx/coshx =</p><p>sinhx = (e^x - e^(-x))/2 、 coshx = (e^x + e^(-x)) / 2</p><p>导数： <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C10.PNG" alt="" /></p><p>图像为：<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C8.PNG" alt="" /></p><p><strong>逻辑函数</strong></p><p>p(t) = 1/(1 + e^(-t))</p><p>导数： <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C11.PNG" alt="" /></p><p>图像为： <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C9.PNG" alt="" /></p><h2 id="减小overfitting"><a class="markdownIt-Anchor" href="#减小overfitting"></a> 减小overfitting</h2><ol><li><p>增加训练数据集</p></li><li><p>减神经网络的规模</p></li><li><p>regularization <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C21.PNG" alt="" />.这是一个例子，后面一项也可以应用于其他cost函数中。加了这一项后神经网络会倾向于学习较小的权重,更少可能受到局部噪音影响<br /><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C22.PNG" alt="" />w的更新也有变化<br /><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C23.PNG" alt="" /> nameda随着n的变化而变化，目的是不让比值太小从而使作用失效</p><p>另一种regularization函数 <img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C24.PNG" alt="" />它的偏导数为<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C25.PNG" alt="" />注意当w=0时，w不可导，所以直接使用没有regularization的。</p></li><li><ol start="3"><li>DropOut： 防止过拟合。具体方法时让需要dropout的层的百分之p的神经元关闭（即让需要关闭的神经元值为0）。然后多次随机剔除，最后再把权重除以p</li></ol></li><li><p><strong>softmax</strong></p></li></ol><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C19.PNG" alt="" /></p><p>这个函数有一些独特的性质。例如zj增大，那么对应输出增大，其他输出减小。并且同一层所有输出值的和一定是1，可以用来模拟概率。所以经常用在输出层当做概率</p><p>对应我们可以定义一个新的cost函数 Cost(p,q)=−∑xp(x)logq(x)， 其中p是真实值，q是估计值. 它的偏导为<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C20.PNG" alt="" />这个偏导和上面的cross-entropy类似。</p><h1 id="卷积神经网络"><a class="markdownIt-Anchor" href="#卷积神经网络"></a> 卷积神经网络</h1><p>卷积神经网络对隐藏层进行了细分，常用于对图像处理。</p><ul><li>input layer： 还需要对输入数据进行一些处理，如减去均值（只需要使用训练集上均值，测试集也是使用训练集均值）</li><li>卷积计算层（CONV layer）： 通过一个窗口进行移动然后再和w矩阵进行点乘过滤一些信息。有三个主要参数，深度，步长和填充值。深度指的是下一层神经元数目，步长指的是窗口一次移动的长度，填充值是为了防止移动超出范围在周围补的一圈零。</li></ul><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C6.PNG" alt="" />这里深度是2，步长是2，填充值是1.其中最右边绿色就是输出。它是通过左边蓝色的窗口和红色的w进行点乘然后相加得到的。有三层是因为输入一个32 * 32 * 3（RGB）的矩阵，然后通过运算可以得到输出矩阵。</p><ul><li>激励层： 将卷积层结果进行非线性映射，典型的激励函数是ReLu，sigmoid函数其实很少用了，因为在数据比较大的时候导数趋近于0，难以训练。</li></ul><p>ReLu方程式 y = max(0, x).也就是小于0时y=0，大于0时y=x。但是这个函数问题是小于0时导数=0，也无法训练。因此改进是小于0时y=0.01x</p><ul><li>池化层（pooling layer): 池化层一般夹在连续的卷积层中间，它是用来压缩数据量，减少过拟合。方法是max pooling。也是通过一个窗口，每次去窗口中的最大值形成一个矩阵。</li></ul><p><img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C12.PNG" alt="" />由原来的4 * 4矩阵变成2 * 2矩阵</p><ul><li>全连接层： 该层和前一层之间一般所有神经元都有权重连接，一般是放在神经网络尾部，是用来防止信息丢失太多的。</li></ul><p><strong>注意点</strong></p><ol><li><p>权重初始化： 使用高斯函数（正态分布）去随机初始化可以让权重随机化。也就是numpy.random.randn(in, out) / np.sqrt(in/2). in是输入层个数，out是输出层个数</p></li><li><p>Batch Normalization: 它是用来减少初始值依赖的，通常在全连接层之后。具体算法<img src="/images/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C13.PNG" alt="" />其中y和b是神经网络自己学习的。</p></li></ol><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><p>通过前面逻辑函数的导数可以得知，前面权重更新其实就是运用激活函数的导数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanh</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.tanh(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanh_deriv</span>(<span class="params">x</span>):</span> <span class="comment"># 导数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - np.tanh(x)*np.tanh(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_derivative</span>(<span class="params">x</span>):</span> <span class="comment"># 导数</span></span><br><span class="line">    <span class="keyword">return</span> logistic(x)*(<span class="number">1</span>-logistic(x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NeuralNetwork</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, layers, activation=<span class="string">&#x27;tanh&#x27;</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param layers: A list containing the number of units in each layer.</span></span><br><span class="line"><span class="string">        Should be at least two values</span></span><br><span class="line"><span class="string">        :param activation: The activation function to be used. Can be</span></span><br><span class="line"><span class="string">        &quot;logistic&quot; or &quot;tanh&quot;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># layers是一个列表，代表输入层，隐藏层和输出层，列表中每个数字代表隐藏层中单元的数目，列表长度代表总共有多少层</span></span><br><span class="line">        <span class="keyword">if</span> activation == <span class="string">&#x27;logistic&#x27;</span>:</span><br><span class="line">            self.activation = logistic</span><br><span class="line">            self.activation_deriv = logistic_derivative</span><br><span class="line">        <span class="keyword">elif</span> activation == <span class="string">&#x27;tanh&#x27;</span>:</span><br><span class="line">            self.activation = tanh</span><br><span class="line">            self.activation_deriv = tanh_deriv</span><br><span class="line"></span><br><span class="line">        self.weights = [] <span class="comment"># 初始化一个列表来装所有的weight，这后来是一个三重矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(layers) - <span class="number">1</span>): <span class="comment"># 随机初始化weight</span></span><br><span class="line">            self.weights.append((<span class="number">2</span>*np.random.random((layers[i - <span class="number">1</span>] + <span class="number">1</span>, layers[i] + <span class="number">1</span>))-<span class="number">1</span>)*<span class="number">0.25</span>) <span class="comment"># 生成一个layers[i-1]+1行，layer[i]+1列的范围在-0.25到0.25的矩阵</span></span><br><span class="line">            self.weights.append((<span class="number">2</span>*np.random.random((layers[i] + <span class="number">1</span>, layers[i + <span class="number">1</span>]))-<span class="number">1</span>)*<span class="number">0.25</span>) <span class="comment"># 第i层到第i+1层之间</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y, learning_rate=<span class="number">0.2</span>, epochs=<span class="number">10000</span></span>):</span></span><br><span class="line">    <span class="comment"># epochs是训练次数（循环次数）</span></span><br><span class="line">        X = np.atleast_2d(X)</span><br><span class="line">        temp = np.ones([X.shape[<span class="number">0</span>], X.shape[<span class="number">1</span>]+<span class="number">1</span>])<span class="comment"># 初始化一个矩阵，值全是一，行数和列数由参数提供</span></span><br><span class="line">        temp[:, <span class="number">0</span>:-<span class="number">1</span>] = X  <span class="comment"># adding the bias unit to the input layer</span></span><br><span class="line">        X = temp</span><br><span class="line">        y = np.array(y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">            i = np.random.randint(X.shape[<span class="number">0</span>])</span><br><span class="line">            a = [X[i]]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.weights)):  <span class="comment">#going forward network, for each layer</span></span><br><span class="line">                a.append(self.activation(np.dot(a[l], self.weights[l])))  <span class="comment">#Computer the node value for each layer (O_i) using activation function</span></span><br><span class="line">              <span class="comment">#正向所有更新</span></span><br><span class="line">            error = y[i] - a[-<span class="number">1</span>]  <span class="comment">#Computer the error at the top layer</span></span><br><span class="line">            deltas = [error * self.activation_deriv(a[-<span class="number">1</span>])] <span class="comment">#For output layer, Err calculation (delta is updated error)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#Staring backprobagation</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a) - <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>): <span class="comment"># we need to begin at the second to last layer</span></span><br><span class="line">                <span class="comment">#Compute the updated error (i,e, deltas) for each node going from top layer to input layer</span></span><br><span class="line"></span><br><span class="line">                deltas.append(deltas[-<span class="number">1</span>].dot(self.weights[l].T)*self.activation_deriv(a[l]))</span><br><span class="line">            deltas.reverse()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.weights)):</span><br><span class="line">                layer = np.atleast_2d(a[i])</span><br><span class="line">                delta = np.atleast_2d(deltas[i])</span><br><span class="line">                self.weights[i] += learning_rate * layer.T.dot(delta)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = np.array(x)</span><br><span class="line">        temp = np.ones(x.shape[<span class="number">0</span>]+<span class="number">1</span>)</span><br><span class="line">        temp[<span class="number">0</span>:-<span class="number">1</span>] = x</span><br><span class="line">        a = temp</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(self.weights)):</span><br><span class="line">            a = self.activation(np.dot(a, self.weights[l]))</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;多层向前神经网络&quot;&gt;&lt;a class=&quot;markdownIt-An</summary>
      
    
    
    
    <category term="机器学习" scheme="http://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>贪心与k-优化</title>
    <link href="http://xinhecuican.github.io/post/34811d5f.html"/>
    <id>http://xinhecuican.github.io/post/34811d5f.html</id>
    <published>2020-07-22T10:48:00.000Z</published>
    <updated>2020-12-13T06:05:26.497Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="引例"><a class="markdownIt-Anchor" href="#引例"></a> 引例</h1><p><strong>活动选择问题</strong></p><p>假设n个活动集合S，这些活动使用同一个资源。这个资源在某一时刻只能供一个活动使用，每个活动都有一个开始时间和一个结束时间。 我们想选出时间不重叠的数量最多的活动集（假设活动按照结束时间单调递增排序）。</p><p>这个问题可以写出最优解的表达式但是求解的时候比较麻烦。</p><p>我们是否可以这样考虑，我们每次都挑选最早结束的活动，这样就算有活动比他早开始，但是因为比他晚结束，所以同样是一个活动还是早结束的活动更优。</p><p>代码比较简单，就不打了</p><h1 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h1><p>性质： 我们通过局部最优解构造全局最优解。也就是我们可以考虑当前问题最优的选择，而不比考虑子问题的解。</p><p>如果一个问题最优解包含子问题最优解，称此问题有最优子结构性质。</p><p>每个小问题的解可由贪心选择获得，则称这个问题具有贪心选择性质。</p><h1 id="k-优化算法"><a class="markdownIt-Anchor" href="#k-优化算法"></a> k-优化算法</h1><blockquote><p>这里的k-优化是拿背包问题进行说明的，其他某些问题也可以使用。</p></blockquote><p>大致过程：</p><ul><li>首先按密度进行排序</li></ul><ol><li>先拿取k件物品，如果重量大于背包重量c，则放弃这个选择（具体请看下面例子）</li><li>对其余物品使用贪心算法</li><li>进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>次上述过程找出贪心最优解</li></ol><p>k-优化算法的优点是它将贪心算法与最优算法的偏差限定在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>k</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{k}{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.283439em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（如果没有这个限制可能会导致最优算法结果是100，而贪心算法结果是6的情况）</p><p>它的复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">n^{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>。每次贪心选择要O(n)复杂度，一共进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>次</p><p>例：</p><p><img src="/images/%E8%B4%AA%E5%BF%831.PNG" alt="" /></p><p>c=50, 如果使用2优化，我们可以</p><ul><li>先取1、2，对其他物品再使用贪心，可以得到1、2、4，价值为190</li><li>先取1、3， 可以得到1、3、4，价值为210</li><li>先取1、4， 可以得到1、2、4</li><li>先取1、5， 可以得到1、2、5， 价值为200</li><li>先取2、3 …</li></ul><h1 id="多机调度问题"><a class="markdownIt-Anchor" href="#多机调度问题"></a> 多机调度问题</h1><p>设有n个独立的作业{1, 2, …, n}, 由m台相同的机器进行加工处理。<br />作业i所需的处理时间为ti。现约定，每个作业均可在任何一台机<br />器上加工处理，但未完工前不允许终端处理。作业不能拆分成更<br />小的子作业。</p><p>求完成这些任务所需要的最短时间。</p><p>我们要想办法让分到m台机器上的时间尽可能平均，这样最后完成时间也会最短。因此我们可以按照时间排序，先把时间长的运行，之后再用时间短的进行填补<br /><img src="/images/%E8%B4%AA%E5%BF%832.PNG" alt="" /></p><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> machine[NR_MACHINE];</span><br><span class="line"><span class="built_in">int</span> get_min_time(<span class="built_in">int</span> <span class="built_in">time</span>[], <span class="built_in">int</span> <span class="built_in">n</span>, <span class="built_in">int</span> machine_num)</span><br><span class="line">&#123;</span><br><span class="line">quick_sort(<span class="built_in">time</span>, <span class="number">0</span>, <span class="built_in">n</span>-<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">if</span>(machine_num &gt;= <span class="built_in">n</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       return <span class="built_in">time</span>[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   priority_queue &lt;<span class="built_in">int</span>,vector&lt;<span class="built_in">int</span>&gt;,greater&lt;<span class="built_in">int</span>&gt; &gt; q;</span><br><span class="line">   for(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;machine_num; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       q.push(<span class="built_in">time</span>[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   for(<span class="built_in">int</span> i=machine_num; i&lt;<span class="built_in">n</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">int</span> temp = q.top();</span><br><span class="line">       q.pop();</span><br><span class="line">       q.push(temp+<span class="built_in">time</span>[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="primkruskal-dijkstra"><a class="markdownIt-Anchor" href="#primkruskal-dijkstra"></a> prim,kruskal, dijkstra</h1><p><a href="https://xinhecuican.github.io/post/15201.html">这三个算法可以看这</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;引例&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>支持向量机</title>
    <link href="http://xinhecuican.github.io/post/280b588e.html"/>
    <id>http://xinhecuican.github.io/post/280b588e.html</id>
    <published>2020-07-21T02:39:00.000Z</published>
    <updated>2020-08-05T00:59:34.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="引入"><a class="markdownIt-Anchor" href="#引入"></a> 引入</h1><p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA1.png" alt="" /></p><p>上图中黑色和白色的点分别代表一类事物，我们想用一条直线把这两类事物区分开，显而易见红线区分最好，那么为什么红线区分最好呢？</p><p>这里引入了一个概念，边际。边际指的是做一个超平面，使得两侧离的最近的点的距离。</p><p>如何选取使边际(margin)最大的超平面 (Max Margin Hyperplane)？</p><p>超平面到一侧最近点的距离等于到另一侧最近点的距离，两侧的两个超平面平行。</p><h1 id="选取最大超平面"><a class="markdownIt-Anchor" href="#选取最大超平面"></a> 选取最大超平面</h1><p>超平面可以定义为： W * X + b = 0</p><p>W是一个类似于权重的向量， X是我们给出的实例的特征向量， b是偏好</p><p>超平面方程也可以写成<img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA2.png" alt="" />这是二维的，b也就是w0.</p><p>上方的点满足大于零，下方的点小于零</p><p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA4.png" alt="" /></p><p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA3.png" alt="" /></p><p>H1就是上边界，也就是两个图中上面的这条线，至于为什么后面是1？这只是用来区分上边界还是下边界，可以通过w0进行调节。我们输入其实就是(x1,x2,…, yi)，yi就是类别标记</p><p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA5.png" alt="" />两个公式可以合并</p><p>在边界上的点叫做<strong>支持向量</strong></p><p>我们可以得出一个结论：<strong>分界的超平面和H1/H2之间的距离是1/||W||</strong>。</p><p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA6.png" alt="" />也就是先平方再开方</p><p>所以最大边界距离是2/||W||</p><p>所以我们要找2/||W||最大值，也就是找w的最小值。所以我们需要找的是：</p><p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA9.PNG" alt="" /></p><p>用1/2平方是因为好算</p><p>之后运用拉格朗日函数，KKT算法等得到了最大超平面方程</p><p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA10.PNG" alt="" />.其中a和b是通过计算过程得出，暂时不清楚具体情况</p><h1 id="python使用"><a class="markdownIt-Anchor" href="#python使用"></a> python使用</h1> <figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [[<span class="number">2</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]] <span class="comment"># 特征向量</span></span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>] <span class="comment"># yi</span></span><br><span class="line">clf = svm.SVC(kernel = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">clf.fit(x, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> clf</span><br><span class="line"></span><br><span class="line"><span class="comment"># get support vectors</span></span><br><span class="line"><span class="built_in">print</span> clf.support_vectors_</span><br><span class="line"></span><br><span class="line"><span class="comment"># get indices of support vectors</span></span><br><span class="line"><span class="built_in">print</span> clf.support_ <span class="comment"># 支持向量点的索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get number of support vectors for each class </span></span><br><span class="line"><span class="built_in">print</span> clf.n_support_ <span class="comment"># 每个类中有几个支持向量，yi所代表的类</span></span><br></pre></td></tr></table></figure><p>把结果画出来</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pylab as pl</span><br><span class="line"><span class="keyword">from</span> sklearn import svm</span><br><span class="line"></span><br><span class="line"><span class="comment"># we create 40 separable points</span></span><br><span class="line">X = np.r_[np.random.randn(20, 2) - [2, 2], np.random.randn(20, 2) + [2, 2]]</span><br><span class="line">Y = [0]<span class="number">*20</span> +[1]<span class="number">*20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fit the model</span></span><br><span class="line">clf = svm.SVC(<span class="attribute">kernel</span>=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">clf.fit(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get the separating hyperplane</span></span><br><span class="line">w = clf.coef_[0] # 获得w</span><br><span class="line">a = -w[0]/w[1] # 斜率</span><br><span class="line">xx = np.linspace(-5, 5)</span><br><span class="line">yy = a*xx - (clf.intercept_[0])/w[1] # 截距</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the parallels to the separating hyperplane that pass through the support vectors</span></span><br><span class="line">b = clf.support_vectors_[0]</span><br><span class="line">yy_down = a*xx + (b[1] - a<span class="number">*b</span>[0])</span><br><span class="line">b = clf.support_vectors_[-1]</span><br><span class="line">yy_up = a*xx + (b[1] - a<span class="number">*b</span>[0]) </span><br><span class="line"></span><br><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;w: &quot;</span>, w</span><br><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;a: &quot;</span>, a</span><br><span class="line"></span><br><span class="line"><span class="comment"># print &quot;xx: &quot;, xx</span></span><br><span class="line"><span class="comment"># print &quot;yy: &quot;, yy</span></span><br><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;support_vectors_: &quot;</span>, clf.support_vectors_</span><br><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;clf.coef_: &quot;</span>, clf.coef_</span><br><span class="line"></span><br><span class="line"><span class="comment"># switching to the generic n-dimensional parameterization of the hyperplan to the 2D-specific equation</span></span><br><span class="line"><span class="comment"># of a line y=a.x +b: the generic w_0x + w_1y +w_3=0 can be rewritten y = -(w_0/w_1) x + (w_3/w_1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the line, the points, and the nearest vectors to the plane</span></span><br><span class="line">pl.plot(xx, yy, <span class="string">&#x27;k-&#x27;</span>)</span><br><span class="line">pl.plot(xx, yy_down, <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line">pl.plot(xx, yy_up, <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pl.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1],</span><br><span class="line">          <span class="attribute">s</span>=80, <span class="attribute">facecolors</span>=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">pl.scatter(X[:, 0], X[:, 1], <span class="attribute">c</span>=Y, <span class="attribute">cmap</span>=pl.cm.Paired)</span><br><span class="line"></span><br><span class="line">pl.axis(<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">pl.show()</span><br></pre></td></tr></table></figure><h1 id="线性不可分的情况"><a class="markdownIt-Anchor" href="#线性不可分的情况"></a> 线性不可分的情况</h1><p>要解决线性不可分的情况首先要看一个例子。</p><p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA8.jpg" alt="" /></p><p>如图，左边明显不可分，但是投影到右边就可分了。因此解决线性不可分的基本思想就是投影到更高的维度。所以现在问题关键成了建立一个映射函数正确的映射到高维，然后找到超平面后再还原回原空间就可以找到超平面（其实现在超平面在原空间中是一个曲面）</p><p>核函数是为了把数据从低维到高维和减小运算量而使用的。</p><p><img src="/images/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA11.PNG" alt="" /></p><p>如果我们先解决多个类的问题，我们可以每次分成这个类和其他类，然后不断求解</p><h1 id="人脸识别例子"><a class="markdownIt-Anchor" href="#人脸识别例子"></a> 人脸识别例子</h1><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> RandomizedPCA</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(__doc__)</span><br><span class="line"></span><br><span class="line"># Display progress logs on stdout</span><br><span class="line">logging.basicConfig(level=logging.INFO, format=<span class="string">&#x27;%(asctime)s %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Download the data, <span class="keyword">if</span> not already on disk and load it <span class="keyword">as</span> numpy arrays</span><br><span class="line"></span><br><span class="line">lfw_people = fetch_lfw_people(min_faces_per_person=<span class="number">70</span>, resize=<span class="number">0.4</span>) #下载人脸</span><br><span class="line"></span><br><span class="line"># introspect the images arrays to find the shapes (for plotting)</span><br><span class="line">n_samples, h, w = lfw_people.images.shape</span><br><span class="line"></span><br><span class="line"># for machine learning we use the <span class="number">2</span> data directly (<span class="keyword">as</span> relative pixel</span><br><span class="line"># positions info is ignored by this model)</span><br><span class="line">X = lfw_people.data # 特征向量</span><br><span class="line">n_features = X.shape[<span class="number">1</span>] #有多少列</span><br><span class="line"></span><br><span class="line"># the label to predict is the id <span class="keyword">of</span> the person</span><br><span class="line">y = lfw_people.target # 类</span><br><span class="line">target_names = lfw_people.target_names # 所挑选的图片的人名</span><br><span class="line">n_classes = target_names.shape[<span class="number">0</span>] # 有多少行</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Total dataset size:&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;n_samples: %d&quot;</span> % n_samples)</span><br><span class="line">print(<span class="string">&quot;n_features: %d&quot;</span> % n_features)</span><br><span class="line">print(<span class="string">&quot;n_classes: %d&quot;</span> % n_classes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Split into a training set and a test set using a stratified k fold</span><br><span class="line"></span><br><span class="line"># split into a training and testing set</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X, y, test_size=<span class="number">0.25</span>)</span><br><span class="line"># train_test_split把实例分成训练集和测试集</span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Compute a PCA (eigenfaces) on the face dataset (treated <span class="keyword">as</span> unlabeled</span><br><span class="line"># dataset): unsupervised feature extraction / dimensionality reduction</span><br><span class="line">n_components = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Extracting the top %d eigenfaces from %d faces&quot;</span></span><br><span class="line">      % (n_components, X_train.shape[<span class="number">0</span>]))</span><br><span class="line">t0 = time()</span><br><span class="line">pca = RandomizedPCA(n_components=n_components, whiten=<span class="literal">True</span>).fit(X_train)</span><br><span class="line">print(<span class="string">&quot;done in %0.3fs&quot;</span> % (time() - t0)) # RandomizedPCA使用来降维的，因为这个维度抬高难以计算</span><br><span class="line"></span><br><span class="line">eigenfaces = pca.components_.reshape((n_components, h, w))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Projecting the input data on the eigenfaces orthonormal basis&quot;</span>)</span><br><span class="line">t0 = time()</span><br><span class="line">X_train_pca = pca.transform(X_train)</span><br><span class="line">X_test_pca = pca.transform(X_test)</span><br><span class="line">print(<span class="string">&quot;done in %0.3fs&quot;</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Train a SVM classification model</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Fitting the classifier to the training set&quot;</span>)</span><br><span class="line">t0 = time()</span><br><span class="line">param_grid = &#123;<span class="string">&#x27;C&#x27;</span>: [<span class="number">1e3</span>, <span class="number">5e3</span>, <span class="number">1e4</span>, <span class="number">5e4</span>, <span class="number">1e5</span>],</span><br><span class="line">              <span class="string">&#x27;gamma&#x27;</span>: [<span class="number">0.0001</span>, <span class="number">0.0005</span>, <span class="number">0.001</span>, <span class="number">0.005</span>, <span class="number">0.01</span>, <span class="number">0.1</span>], &#125;</span><br><span class="line">clf = GridSearchCV(SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, class_weight=<span class="string">&#x27;auto&#x27;</span>), param_grid)#核函数kernel， GridSearchCV是用来寻找最好的参数比例</span><br><span class="line">clf = clf.fit(X_train_pca, y_train)</span><br><span class="line">print(<span class="string">&quot;done in %0.3fs&quot;</span> % (time() - t0))</span><br><span class="line">print(<span class="string">&quot;Best estimator found by grid search:&quot;</span>)</span><br><span class="line">print(clf.best_estimator_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Quantitative evaluation <span class="keyword">of</span> the model quality on the test set</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Predicting people&#x27;s names on the test set&quot;</span>)</span><br><span class="line">t0 = time()</span><br><span class="line">y_pred = clf.predict(X_test_pca)</span><br><span class="line">print(<span class="string">&quot;done in %0.3fs&quot;</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line">print(classification_report(y_test, y_pred, target_names=target_names))</span><br><span class="line">print(confusion_matrix(y_test, y_pred, labels=range(n_classes)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################################################################</span><br><span class="line"># Qualitative evaluation <span class="keyword">of</span> the predictions using matplotlib</span><br><span class="line"></span><br><span class="line">def plot_gallery(images, titles, h, w, n_row=<span class="number">3</span>, n_col=<span class="number">4</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Helper function to plot a gallery of portraits&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">1.8</span> * n_col, <span class="number">2.4</span> * n_row))</span><br><span class="line">    plt.subplots_adjust(bottom=<span class="number">0</span>, left=<span class="number">.01</span>, right=<span class="number">.99</span>, top=<span class="number">.90</span>, hspace=<span class="number">.35</span>)</span><br><span class="line">    for i <span class="keyword">in</span> range(n_row * n_col):</span><br><span class="line">        plt.subplot(n_row, n_col, i + <span class="number">1</span>)</span><br><span class="line">        plt.imshow(images[i].reshape((h, w)), cmap=plt.cm.gray)</span><br><span class="line">        plt.title(titles[i], size=<span class="number">12</span>)</span><br><span class="line">        plt.xticks(())</span><br><span class="line">        plt.yticks(())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># plot the result <span class="keyword">of</span> the prediction on a portion <span class="keyword">of</span> the test set</span><br><span class="line"></span><br><span class="line">def title(y_pred, y_test, target_names, i):</span><br><span class="line">    pred_name = target_names[y_pred[i]].rsplit(<span class="string">&#x27; &#x27;</span>, <span class="number">1</span>)[<span class="number">-1</span>]</span><br><span class="line">    true_name = target_names[y_test[i]].rsplit(<span class="string">&#x27; &#x27;</span>, <span class="number">1</span>)[<span class="number">-1</span>]</span><br><span class="line">    return <span class="string">&#x27;predicted: %s\ntrue:      %s&#x27;</span> % (pred_name, true_name)</span><br><span class="line"></span><br><span class="line">prediction_titles = [title(y_pred, y_test, target_names, i)</span><br><span class="line">                     for i <span class="keyword">in</span> range(y_pred.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">plot_gallery(X_test, prediction_titles, h, w)</span><br><span class="line"></span><br><span class="line"># plot the gallery <span class="keyword">of</span> the most significative eigenfaces</span><br><span class="line"></span><br><span class="line">eigenface_titles = [<span class="string">&quot;eigenface %d&quot;</span> % i for i <span class="keyword">in</span> range(eigenfaces.shape[<span class="number">0</span>])]</span><br><span class="line">plot_gallery(eigenfaces, eigenface_titles, h, w)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;引入&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="机器学习" scheme="http://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>KNN算法</title>
    <link href="http://xinhecuican.github.io/post/94ceb2fd.html"/>
    <id>http://xinhecuican.github.io/post/94ceb2fd.html</id>
    <published>2020-07-21T00:26:00.000Z</published>
    <updated>2020-07-22T12:15:04.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="大致步骤"><a class="markdownIt-Anchor" href="#大致步骤"></a> 大致步骤</h1><p>KNN是最临近规则分类算法。</p><p>为了判断未知分类，我们需要用已知分类进行参照。</p><ol><li>选择参照物个数k。 k的取值一般都比较小，可以是1,3,5,7等数，通过实验得知哪个比较好就用哪个。一般用奇数，避免两边数目相同</li><li>选择最近的k个实例然后看他们都属于哪个类，让这个实例成为数目最多的实例。</li></ol><p><strong>距离衡量方法</strong></p><ol><li>EUclidean Distance方法。和距离公式类似，对应特征值相减平方再开根号。<img src="/images/KNN1.PNG" alt="" /></li></ol><p>例：</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">from</span> sklearn import neighbors</span><br><span class="line"><span class="attribute">from</span> sklearn import datasets # 这个库中自带一些有名的数据集</span><br><span class="line"></span><br><span class="line"><span class="attribute">knn</span> = neighbors.KNeighborsClassifier() # 创建分类器</span><br><span class="line"></span><br><span class="line"><span class="attribute">iris</span> = datasets.load_iris() # 导入数据集</span><br><span class="line"><span class="attribute">knn</span>.fit(iris.data, iris.target)</span><br><span class="line"><span class="attribute">predictedLabel</span> = knn.predict([[<span class="number">0</span>.<span class="number">1</span>, <span class="number">0</span>.<span class="number">2</span>, <span class="number">0</span>.<span class="number">3</span>, <span class="number">0</span>.<span class="number">4</span>]])</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;大致步骤&quot;&gt;&lt;a class=&quot;markdownIt-Anchor</summary>
      
    
    
    
    <category term="机器学习" scheme="http://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>决策树算法</title>
    <link href="http://xinhecuican.github.io/post/ef296a07.html"/>
    <id>http://xinhecuican.github.io/post/ef296a07.html</id>
    <published>2020-07-19T02:42:00.000Z</published>
    <updated>2020-07-19T10:51:38.863Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构"></a> 基本结构</h1><p>决策树是一个类似流程图的树形结构：其中，每个节点表示在一个属性上的测试。每个分支表示一个输出，每个树叶节点代表类或类的分布。</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%91.PNG" alt="" /></p><p>上面这个例子中play和don’t play是结果，表示玩还是不玩。然后不是叶结点的节点都有一个问号，例如第一个outlook询问的是天气，后面还有湿度和是否刮风。通过这些条件得到了叶节点，叶结点都是只包含一种情况，要么是play要么是don’t play</p><p>熵： 不确定性的多少，越不确定的信息信息熵越大。</p><p>我们可以用比特(bit)来衡量信息的多少。公式为每种事情的概率* 以二为底该事情概率的对数。</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%912.PNG" alt="" />.变量不确定性越大，熵也就越大。</p><p>例如，我们想要知道世界杯谁会夺冠，我们可以从往届比赛中得知每个球队夺冠的大致概率，然后从而推测出bit的大小。</p><h1 id="决策树归纳算法id3"><a class="markdownIt-Anchor" href="#决策树归纳算法id3"></a> 决策树归纳算法（ID3）</h1><p>决策树适合小规模，类别比较少的数据集。</p><p>我们通过什么确定该节点应该是什么问题呢?</p><p>信息获取量 Gain(A) = info(D) - info_A(D)</p><p>info(D)表示只考虑结果时信息量（bit值）。 info_A(D)表示考虑A后的信息量</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%913.PNG" alt="" /></p><p>上面这个例子中，后面age的计算是该种类的概率（如5/14或4/14等）* 在这个种类里的信息获取量。上面青年有五种，然后求得五种里买电脑或者不买电脑的信息获取量。</p><p>最后可以求得gain，然后选取gain最大的作为该节点。 通过划分后如果只有一种目标，那么划分结束，如果有多种目标，那么重新用这种方法选取gain最大的。</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%914.PNG" alt="" /></p><p>如果所有属性都用完了，那么采用多数表决，即哪个结果多就把它划分成哪个类。例如最后所有属性都使用了一遍，最后三人买电脑，两人不买电脑，那么最后就把它划分成买电脑类。</p><p>如果分的太细也可能出现问题。所以有时候达到一定纯度就不再往下分。还可以先全部分完然后再剪。</p><h1 id="运用"><a class="markdownIt-Anchor" href="#运用"></a> 运用</h1><p>python中有一个scikit-learn库包含了决策树。</p><p>首先sklearn要求输入的属性值必须是数值型的值而不能是young，old之类模糊的数据。</p><p>具体可以变成由0和1组成的集合。例如假如是young，那么按照young Middle old排列的话取值是100，如果是middle那么就是010.</p><p>所有特征值形成了一串0和1,以这个作为输入。</p><p>python中提供了一个函数可以直接把属性转化成01， 他叫DictVectorizer(),使用它的条件是我们把属性转化成了一个列表（所有样例构成一个列表，但是单个样例可以用字典进行描述)</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%915.PNG" alt="" />这是上例所形成的列表</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">vec</span> = DictVectorizer()</span><br><span class="line"><span class="attr">dummyx</span> = vec.fit_transform(featurelist).toarray()</span><br></pre></td></tr></table></figure><p>输出<br /><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%916.PNG" alt="" /></p><p>这是对于特征值的，对于目标标记也有专门的方法</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">lb</span> = processing.LabelBinarizer()</span><br><span class="line"><span class="attr">dummyY</span> = lb.fit_transform(labellist)</span><br></pre></td></tr></table></figure><p><strong>创建分类器</strong></p><p>前面都是对数据进行预处理，预处理完毕之后我们就要把它转换成决策树模型了。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">clf</span> = tree.DecesionTreeClassifier(criterion = <span class="string">&#x27;entropy&#x27;</span>) <span class="comment">#criterion是使用的决策树算法，具体可以看文档</span></span><br><span class="line"><span class="attr">ans</span> = clf.fit(dummyX, dummyY)</span><br></pre></td></tr></table></figure><p><strong>可视化</strong></p><p>虽然我们产生了结果，但是结果非常不直观，我们可以用graphviz将结果变成上面看到的图。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">&quot;allElectronicInformationGainOri.dot&quot;</span>, <span class="character">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f = tree.export<span class="constructor">_graphviz(<span class="params">clf</span>, <span class="params">feature_names</span>=<span class="params">vec</span>.<span class="params">get_feature_names</span>()</span>, out_file=f) # feature_names是属性的名字，因为在形成决策树过程中全变成<span class="number">0</span>和<span class="number">1</span>了</span><br></pre></td></tr></table></figure><p>通过这两行代码可以把结果输出到文件中<img src="/images/%E5%86%B3%E7%AD%96%E6%A0%917.PNG" alt="" />可以看到结果非常不直观，因此我们还需用graphviz进一步转化。</p><p>在cmd中输入<code>dot -Tpdf iris.dot -o output.pdf</code> iris.dot是原始文件的路径，-o是输出文件名</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%918.PNG" alt="" /></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.externals.six <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in the csv file and put features into list of dict and list of class label</span></span><br><span class="line">allElectronicsData = <span class="built_in">open</span>(<span class="string">r&#x27;/home/zhoumiao/MachineLearning/01decisiontree/AllElectronics.csv&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">reader = csv.reader(allElectronicsData)</span><br><span class="line">headers = reader.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">print(headers)</span><br><span class="line"></span><br><span class="line">featureList = []</span><br><span class="line">labelList = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">    labelList.append(row[<span class="built_in">len</span>(row)-<span class="number">1</span>])</span><br><span class="line">    rowDict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(row)-<span class="number">1</span>):</span><br><span class="line">        rowDict[headers[i]] = row[i]</span><br><span class="line">    featureList.append(rowDict)</span><br><span class="line"></span><br><span class="line">print(featureList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Vetorize features</span></span><br><span class="line">vec = DictVectorizer()</span><br><span class="line">dummyX = vec.fit_transform(featureList) .toarray()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;dummyX: &quot;</span> + <span class="built_in">str</span>(dummyX))</span><br><span class="line">print(vec.get_feature_names())</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;labelList: &quot;</span> + <span class="built_in">str</span>(labelList))</span><br><span class="line"></span><br><span class="line"><span class="comment"># vectorize class labels</span></span><br><span class="line">lb = preprocessing.LabelBinarizer()</span><br><span class="line">dummyY = lb.fit_transform(labelList)</span><br><span class="line">print(<span class="string">&quot;dummyY: &quot;</span> + <span class="built_in">str</span>(dummyY))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using decision tree for classification</span></span><br><span class="line"><span class="comment"># clf = tree.DecisionTreeClassifier()</span></span><br><span class="line">clf = tree.DecisionTreeClassifier(criterion=<span class="string">&#x27;entropy&#x27;</span>)</span><br><span class="line">clf = clf.fit(dummyX, dummyY)</span><br><span class="line">print(<span class="string">&quot;clf: &quot;</span> + <span class="built_in">str</span>(clf))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize model</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;allElectronicInformationGainOri.dot&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f = tree.export_graphviz(clf, feature_names=vec.get_feature_names(), out_file=f)</span><br><span class="line"></span><br><span class="line">oneRowX = dummyX[<span class="number">0</span>, :]</span><br><span class="line">print(<span class="string">&quot;oneRowX: &quot;</span> + <span class="built_in">str</span>(oneRowX))</span><br><span class="line"></span><br><span class="line">newRowX = oneRowX</span><br><span class="line">newRowX[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">newRowX[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">print(<span class="string">&quot;newRowX: &quot;</span> + <span class="built_in">str</span>(newRowX))</span><br><span class="line"></span><br><span class="line">predictedY = clf.predict(newRowX) <span class="comment"># 创建一个新的节点然后预测</span></span><br><span class="line">print(<span class="string">&quot;predictedY: &quot;</span> + <span class="built_in">str</span>(predictedY))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;基本结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor</summary>
      
    
    
    
    <category term="机器学习" scheme="http://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>动态顺序统计</title>
    <link href="http://xinhecuican.github.io/post/20ff5ccb.html"/>
    <id>http://xinhecuican.github.io/post/20ff5ccb.html</id>
    <published>2020-07-12T07:48:00.000Z</published>
    <updated>2020-07-14T08:40:50.074Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先要了解<a href="https://xinhecuican.github.io/post/f89cb603.html#more">红黑树</a>.</p><p>顺序统计树指示在普通的红黑树上附加了一个参量，x-&gt;size。这个参量表示的是该节点的子树含有元素个数。</p><p>为了找出第i小的关键字，可以用：</p><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">select</span>(node<span class="comment">* x, int i)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int r = x-&gt;left-&gt;size + 1;</span></span><br><span class="line">    </span><br><span class="line">    //<span class="meta">x</span>的序号，因为红黑树也是一个排序树，所以<span class="meta">x</span>一定比左边元素都大</span><br><span class="line">    <span class="meta">if</span>(i == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">return</span> <span class="meta">x</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">else</span> <span class="meta">if</span>(i &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">return</span> <span class="meta">select</span>(<span class="meta">x</span>-&gt;left, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">return</span> <span class="meta">select</span>(<span class="meta">x</span>-&gt;right, i-r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>确定一个元素的秩</strong></p><p>秩指的是排第几号元素。</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">rank(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">int</span> r = x-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span>size + <span class="number">1</span>;</span><br><span class="line">    node* y = x;</span><br><span class="line">    <span class="function"><span class="title">while</span>(y != t-&gt;</span>root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(y == y-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right)<span class="comment">//如果是右子树，那么还要加上左子树的数目</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">r</span> = r+y-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">y</span> = y-&gt;</span>p;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，使用中序遍历可以得到排序树的排序。中间循环的过程就是找到x在父亲节点子树中位置然后再到祖宗节点中所处位置最后到根节点所处位置。</p><p><strong>维护</strong></p><p>对于插入，红黑树插入分为两个阶段，第一阶段是找位置，只需要沿途让size+1就好了，第二阶段是旋转。对于左子树， x是原来最上面的节点，现在size是<code>x-&gt;left-&gt;size + x-&gt;right-&gt;size + 1</code>， 对于右儿子y来说，y的size就是最开始x的size（因为现在它使根节点）</p><h1 id="区间树"><a class="markdownIt-Anchor" href="#区间树"></a> 区间树</h1><p>区间树是另一种红黑树的扩展。它和普通红黑树的区别是多了一个区间x-&gt;int(interval)表示，区间最大值是int.high(区间的右端点),最小值是int.low.</p><p>此外，还附加了max（以x为根的子树中所有区间端点的最大值）</p><p><code>x-&gt;max = max(x-&gt;int-&gt;high, x-&gt;left-&gt;max, x-&gt;right-&gt;max)</code></p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">search(node* t, int(interval) i)<span class="comment">//查找与i重叠的区间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">node</span>* x = t-&gt;</span>root;</span><br><span class="line">    <span class="function"><span class="title">while</span>(x != NULL &amp;&amp; (x-&gt;</span><span class="function"><span class="title">int</span>-&gt;</span><span class="function"><span class="title">low</span>&gt;i-&gt;</span><span class="function"><span class="title">high</span> || x-&gt;</span><span class="function"><span class="title">int</span>-&gt;</span><span class="function"><span class="title">high</span>&lt;i-&gt;</span>low))<span class="comment">//x!=NULL &amp;&amp; i不在x的区间范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">if</span>(x-&gt;</span><span class="function"><span class="title">left</span> != NULL &amp;&amp; x-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="function"><span class="title">max</span> &gt;= i-&gt;</span>low)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">x</span> = x-&gt;</span>left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">x</span> = x-&gt;</span>right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最优二叉搜索树"><a class="markdownIt-Anchor" href="#最优二叉搜索树"></a> 最优二叉搜索树</h1><p>给一个n个不同关键字的已排序序列，用这些关键字构建一个二叉搜索树。对于每个关键字ki，都有一个概率pi表示搜索概率。因为还有可能没有搜索到，所以还有n+1个伪关键字。</p><p>可以证明，最优二叉搜索树的子树也是最优二叉树。</p><p>所以我们求解的子问题为： 求解ki到kj的最优二叉搜索树。并且 j&gt;=i-1.当j=i-1时，不包含关键字。</p><p>当j=i-1时，子树中只包含伪关键字di-1， 所以搜索代价是qi-1</p><p>当j&gt;=i时，我们要选取一个根节点kr, ki到kr-1为左子树，kr+1到j为右子树。当一棵树成为另一棵树的子树时，因为每个节点的深度都加1，所以搜索代价的增加值应该是所有概率之和，记这个概率为w(i, j)</p><p>注意w(i, j) = w(i, r-1) + pr + w(r+1, j)</p><p>所以现在概率应该是原来左子树代价+原来右子树代价+增加代价</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%925.jpg" alt="" /></p><p>这就是最优搜索代价的递归公式。e[i, j]表示从i到j构成的二叉树的最优搜索代价。</p><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">bst(int* p, int* q, int n)</span><br><span class="line">&#123;</span><br><span class="line">    //q是伪关键字搜索频率</span><br><span class="line">    int max = 2147483647;</span><br><span class="line">    int e<span class="comment">[n+2]</span><span class="comment">[n+1]</span>, w<span class="comment">[n+2]</span><span class="comment">[n+1]</span>, root<span class="comment">[n+1]</span><span class="comment">[n+1]</span>;</span><br><span class="line">    for(int i=1; i&lt;=n+1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e<span class="comment">[i]</span><span class="comment">[i-1]</span> = q<span class="comment">[i-1]</span>;</span><br><span class="line">        w<span class="comment">[i]</span><span class="comment">[i-1]</span> = q<span class="comment">[i-1]</span>;</span><br><span class="line">        for(int l=1; l&lt;=n; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i + l - 1;</span><br><span class="line">            e<span class="comment">[i]</span><span class="comment">[j]</span> = max;</span><br><span class="line">            w<span class="comment">[i]</span><span class="comment">[j]</span> = e<span class="comment">[i]</span><span class="comment">[j-1]</span> + p<span class="comment">[j]</span> + q<span class="comment">[j]</span>;</span><br><span class="line">            for(int r=i; r&lt;=j; r++)</span><br><span class="line">            &#123;</span><br><span class="line">                t = e<span class="comment">[i]</span><span class="comment">[r-1]</span> + e<span class="comment">[r+1]</span><span class="comment">[j]</span> + w<span class="comment">[<span class="comment">[i]</span><span class="comment">[j]</span>;</span></span><br><span class="line"><span class="comment">                if(t &lt; e<span class="comment">[i]</span><span class="comment">[j]</span>)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    e<span class="comment">[i]</span><span class="comment">[j]</span> = t;</span></span><br><span class="line"><span class="comment">                    root<span class="comment">[i]</span><span class="comment">[j]</span> = r;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return e;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;首先要了解&lt;a href=&quot;https://xinhecuican.gith</summary>
      
    
    
    
    <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
