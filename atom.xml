<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-01-24T01:30:55.173Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编中的多层循环</title>
    <link href="http://xinhecuican.github.io/2020/01/24/%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/"/>
    <id>http://xinhecuican.github.io/2020/01/24/%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-01-24T01:19:00.000Z</published>
    <updated>2020-01-24T01:30:55.173Z</updated>
    
    <content type="html"><![CDATA[<p>因为唯一的用于统计循环次数的寄存器就是cx，所以有多层循环的时候就会碰到循环次数难以记录的问题，以下是一种解决办法</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span>//用另一个寄存器来存<span class="built_in">cx</span>的次数</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol"> s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>+<span class="built_in">bx</span>]</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">si</span>+<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">   <span class="keyword">loop</span> s</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>//这里把<span class="built_in">cx</span>次数取出来减一次</span><br><span class="line">   <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure><p> 但是寄存器的数量是有限的，如果多次循环可能会导致寄存器不够用，因此可以先在数据段定义一个字型数据，然后直接把循环次数放到里面<br> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line"> data ends</span><br><span class="line"> </span><br><span class="line"> code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol">  s0:</span> <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">cx</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2</span></span><br><span class="line"><span class="symbol">  s:</span>  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">loop</span> s</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">     <span class="keyword">loop</span> s0</span><br></pre></td></tr></table></figure><br> 此外，还可以定义一个栈，直接用push，pop命令把cx值取出存入</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为唯一的用于统计循环次数的寄存器就是cx，所以有多层循环的时候就会碰到循环次数难以记录的问题，以下是一种解决办法&lt;/p&gt;
&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>si和di</title>
    <link href="http://xinhecuican.github.io/2020/01/24/si%E5%92%8Cdi/"/>
    <id>http://xinhecuican.github.io/2020/01/24/si%E5%92%8Cdi/</id>
    <published>2020-01-24T00:32:00.000Z</published>
    <updated>2020-01-24T00:54:19.957Z</updated>
    
    <content type="html"><![CDATA[<p>si和di在8086cpu中的功能与bx类似，si与di不能分为两个8位寄存器来使用</p><p>也就是说  ds：[si]是可以的</p><p>如果不用这些寄存器直接写的话就会出现之前所说的编译器和exe对程序的不同处理</p><p>例   mov ax,[si]在exe中就是 ds：[si]，但是如果是 mov，ax,[1]在exe中就是把ax中的数据放入1中</p><p>甚至可以直接用[bx+si]的方式或[bx+si+idata]的方式来指明内存地址</p><h3 id="不同寻址方式的比较"><a href="#不同寻址方式的比较" class="headerlink" title="不同寻址方式的比较"></a>不同寻址方式的比较</h3><p>[idata]用于一个常量的寻址，直接定位一个内存单元</p><p>[bx]用于一个变量来表示内存地址，间接定位内存单元</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;si和di在8086cpu中的功能与bx类似，si与di不能分为两个8位寄存器来使用&lt;/p&gt;
&lt;p&gt;也就是说  ds：[si]是可以的&lt;/p&gt;
&lt;p&gt;如果不用这些寄存器直接写的话就会出现之前所说的编译器和exe对程序的不同处理&lt;/p&gt;
&lt;p&gt;例   mov ax,[si]在
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>字符形式 的数据</title>
    <link href="http://xinhecuican.github.io/2020/01/23/%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F-%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://xinhecuican.github.io/2020/01/23/%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F-%E7%9A%84%E6%95%B0%E6%8D%AE/</id>
    <published>2020-01-23T03:44:00.000Z</published>
    <updated>2020-01-24T00:25:28.844Z</updated>
    
    <content type="html"><![CDATA[<p>首先要知道asc11码</p><p>形式： db ‘…’</p><p>无论多少个单词都只需要单引号</p><p>例 db‘unix’</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先要知道asc11码&lt;/p&gt;
&lt;p&gt;形式： db ‘…’&lt;/p&gt;
&lt;p&gt;无论多少个单词都只需要单引号&lt;/p&gt;
&lt;p&gt;例 db‘unix’&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>将不同代码放入不同段中</title>
    <link href="http://xinhecuican.github.io/2020/01/23/%E5%B0%86%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E6%AE%B5%E4%B8%AD/"/>
    <id>http://xinhecuican.github.io/2020/01/23/%E5%B0%86%E4%B8%8D%E5%90%8C%E4%BB%A3%E7%A0%81%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E6%AE%B5%E4%B8%AD/</id>
    <published>2020-01-23T01:42:00.000Z</published>
    <updated>2020-01-23T01:59:49.183Z</updated>
    
    <content type="html"><![CDATA[<p>举个栗子</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code <span class="built_in">ds</span>:data <span class="built_in">ss</span>:stack</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0345h</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">20h</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span> //<span class="built_in">ds</span>:<span class="built_in">bx</span>指向data中第一个内存单元</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span> <span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s0:</span><span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s0</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"> code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>看了这个就差不多了，前面定义的时候要注意不同段对应不同的寄存器，而后面要注意各个段有独自的segment与ends，而且从start开始要把各个段寄存器赋值，以备后面使用（mov ax，data）<strong>注意</strong> mov ds，data是错误的，8086cpu不允许直接把一个数值送入段寄存器中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;举个栗子&lt;/p&gt;
&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>在代码段中使用栈</title>
    <link href="http://xinhecuican.github.io/2020/01/23/%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88/"/>
    <id>http://xinhecuican.github.io/2020/01/23/%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88/</id>
    <published>2020-01-23T01:03:00.000Z</published>
    <updated>2020-01-23T01:33:37.472Z</updated>
    
    <content type="html"><![CDATA[<p>实际上栈是我们人为定义的一段内存空间，所以先要用dw来申请</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>  //申请<span class="number">6</span>个字的内存空间，栈是由高内存地址到低内存地址，所以栈顶为<span class="built_in">cs</span>：<span class="number">Ch</span></span><br><span class="line"><span class="symbol">start:</span> <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">Ch</span></span><br></pre></td></tr></table></figure><p>ss，sp就是前面所说的栈的指针</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实际上栈是我们人为定义的一段内存空间，所以先要用dw来申请&lt;/p&gt;
&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>dw</title>
    <link href="http://xinhecuican.github.io/2020/01/23/dw/"/>
    <id>http://xinhecuican.github.io/2020/01/23/dw/</id>
    <published>2020-01-23T00:48:00.000Z</published>
    <updated>2020-01-23T01:19:10.873Z</updated>
    
    <content type="html"><![CDATA[<p>dw即define word，定义字型数据。例如，dw 0123h,0456h,0789h.这样就定义了几个字型数据，那这些数据都在哪里呢，他们的段地址都是从cs开始的，而偏移地址从0开始，也就是说，0123h的偏移地址是0,0456h的偏移地址是2,0789h的偏移地址是6。</p><p>但是这样会带来一个问题，因为前十六个字节是dw所定义的字型数据，所以这样可能使程序的入口出现问题，所以可以</p><pre><code>assume cs:codesgcodesg segmentdw 0123h,0456h,0789hstart: mov bx,0mov ax,0mov cx,8s: add ax,cs:[bx]add bx,2loop smov ax,4c00hint 21hcodesg endsend start</code></pre><p>这里就是加上了一个标号start，这个标号的意思就是确定程序的入口，而最后在end这里还要来一个start，因为end的作用除了确定程序在哪里终止之外，还有一个作用是告诉编译器程序在哪里开始（因为这时一个伪指令）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dw即define word，定义字型数据。例如，dw 0123h,0456h,0789h.这样就定义了几个字型数据，那这些数据都在哪里呢，他们的段地址都是从cs开始的，而偏移地址从0开始，也就是说，0123h的偏移地址是0,0456h的偏移地址是2,0789h的偏移地址是
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>debug和源程序对指令的不同处理</title>
    <link href="http://xinhecuican.github.io/2020/01/22/debug%E5%92%8C%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%AF%B9%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86/"/>
    <id>http://xinhecuican.github.io/2020/01/22/debug%E5%92%8C%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%AF%B9%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86/</id>
    <published>2020-01-22T08:57:00.000Z</published>
    <updated>2020-01-22T09:40:10.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title="[]"></a>[]</h3><p>debug程序中[0]表示 ds：0处的数据进行处理</p><p>而源程序中表示把0这个数据给要处理的数据</p><p>例 mov ax,[0]在debug中表示把ds：0处元素给ax，而在源程序中表示把0给ax</p><p>在程序中，可以直接使用段寄存器加偏移地址来确定访问的元素，例如：ds：[bx],cs:[bx],ss:[bx]等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;[]&quot;&gt;&lt;/a&gt;[]&lt;/h3&gt;&lt;p&gt;debug程序中[0]表示 ds：0处的数据进行处理&lt;/p&gt;
&lt;p&gt;而源程序中表示把0这个数据给要处理的数据&lt;/p&gt;
&lt;p&gt;例 mov ax,[0]
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>[bx]和loop</title>
    <link href="http://xinhecuican.github.io/2020/01/21/bx-%E5%92%8Cloop/"/>
    <id>http://xinhecuican.github.io/2020/01/21/bx-%E5%92%8Cloop/</id>
    <published>2020-01-21T02:08:00.000Z</published>
    <updated>2020-01-24T00:31:36.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h3><p>mov ax,[bx]</p><p>这个的意思是把ds：bx处的内容放入ax中</p><p>mov [bx],ax</p><p>这个的意思是把ax中的内容放入 地址ds：bx处</p><h3 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h3><p>实际上还有更加灵活的方式指明内存地址，就是bx后加一个数据，这个数据可以是常数，也可以是变量</p><p>例 mov ax,ds:[bx+200]，也可以直接写为ds：200[bx]</p><p>这种处理方式可以方便的处理数组</p><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>格式：loop+标识符</p><p>执行过程：执行到loop时，先让cx-=1,再判断cx中的值，不为0则转至标号处继续执行，为0则进行下一步操作，寄存器cx用来储存循环次数</p><p>例</p><pre><code>mov cx,3mov ax,2s: add ax,ax  loop s</code></pre><p>这段程序的作用是计算2的三次方，首先让循环次数为3，ax=2，再从s处开始循环，当cx=0时退出，即进行3次</p><h3 id="用debug跟踪loop指令"><a href="#用debug跟踪loop指令" class="headerlink" title="用debug跟踪loop指令"></a>用debug跟踪loop指令</h3><p> tip：汇编程序中，数据不能以字母开头，所以如A231h等等前面都要加一个零</p><p> 如果想直接结束循环可以用p命令，如果用t命令的话，只会结束这一次循环</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;bx&quot;&gt;&lt;a href=&quot;#bx&quot; class=&quot;headerlink&quot; title=&quot;[bx]&quot;&gt;&lt;/a&gt;[bx]&lt;/h3&gt;&lt;p&gt;mov ax,[bx]&lt;/p&gt;
&lt;p&gt;这个的意思是把ds：bx处的内容放入ax中&lt;/p&gt;
&lt;p&gt;mov [bx],ax&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>程序执行过程的跟踪</title>
    <link href="http://xinhecuican.github.io/2020/01/21/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B7%9F%E8%B8%AA/"/>
    <id>http://xinhecuican.github.io/2020/01/21/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B7%9F%E8%B8%AA/</id>
    <published>2020-01-21T01:54:00.000Z</published>
    <updated>2020-01-21T02:00:15.897Z</updated>
    
    <content type="html"><![CDATA[<p>运用debug +程序名进入debug过程</p><p>例如 debug 1.exe</p><p>程序开始都是从0000的偏移地址开始的，设段地址为A，而程序开始有一段不做该程序内容，而有其他用途。这段程序占256个字节，叫psp，之后段地址偏移10h，所以真正的程序是从A+10:0 开始的（256个字节在16进制中是10，而A也是用16进制表示的）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;运用debug +程序名进入debug过程&lt;/p&gt;
&lt;p&gt;例如 debug 1.exe&lt;/p&gt;
&lt;p&gt;程序开始都是从0000的偏移地址开始的，设段地址为A，而程序开始有一段不做该程序内容，而有其他用途。这段程序占256个字节，叫psp，之后段地址偏移10h，所以真正的程序是
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>从asm到exe</title>
    <link href="http://xinhecuican.github.io/2020/01/21/%E4%BB%8Easm%E5%88%B0exe/"/>
    <id>http://xinhecuican.github.io/2020/01/21/%E4%BB%8Easm%E5%88%B0exe/</id>
    <published>2020-01-21T01:40:00.000Z</published>
    <updated>2020-01-21T01:53:04.623Z</updated>
    
    <content type="html"><![CDATA[<p>先要有masm.exe和link.exe，然后输入masm+程序名和link+程序名</p><p>或者masm+盘符+程序名，可以省略中间过程，节省时间<br>例：masm c:\1.asm</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先要有masm.exe和link.exe，然后输入masm+程序名和link+程序名&lt;/p&gt;
&lt;p&gt;或者masm+盘符+程序名，可以省略中间过程，节省时间&lt;br&gt;例：masm c:\1.asm&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编的第一个程序</title>
    <link href="http://xinhecuican.github.io/2020/01/20/%E6%B1%87%E7%BC%96%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"/>
    <id>http://xinhecuican.github.io/2020/01/20/%E6%B1%87%E7%BC%96%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-01-20T07:58:00.000Z</published>
    <updated>2020-01-20T09:19:18.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>编译器中，包含两种指令，一种是汇编指令，一种是伪指令。伪指令是给编译器看的，最终不会被cpu执行。先了解三个最为基础的伪指令</p><ul><li>XXX segment，XXX ends，这两个是配套使用的。功能是定义一个代码段，一个段必须要有一个名称标识（XXX是也）</li></ul><p>例如codesg segment ，codesg ends</p><ul><li>assume </li></ul><p>这条指令作用是假设某一寄存器和程序中的某一个用segment和ends定义的段相关联，写在最开头。</p><ul><li>end</li></ul><p>没什么特别的，程序的结束标识，不写程序不知道在哪里结束</p><h3 id="一个程序"><a href="#一个程序" class="headerlink" title="一个程序"></a>一个程序</h3><pre><code>assume cs: codesgcodesg segment    mov ax,0123    mov bx,0456    add ax,bx    mov ax,4c00    int 21codesg endsend</code></pre><h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>在单任务操作系统上，一次只可以执行一个程序，那么当我们写的这个程序执行完之后，还要把cpu控制权交给dos，而mov ax，4c00 和 int 21 就是做这个工作的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;伪指令&quot;&gt;&lt;a href=&quot;#伪指令&quot; class=&quot;headerlink&quot; title=&quot;伪指令&quot;&gt;&lt;/a&gt;伪指令&lt;/h3&gt;&lt;p&gt;编译器中，包含两种指令，一种是汇编指令，一种是伪指令。伪指令是给编译器看的，最终不会被cpu执行。先了解三个最为基础的伪指令&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>栈.                                      </title>
    <link href="http://xinhecuican.github.io/2020/01/20/%E6%A0%88/"/>
    <id>http://xinhecuican.github.io/2020/01/20/%E6%A0%88/</id>
    <published>2020-01-20T06:26:00.000Z</published>
    <updated>2020-01-20T07:58:09.483Z</updated>
    
    <content type="html"><![CDATA[<p>栈是一段连续的内存空间，这个空间的特殊性在于，最后进入这个空间的数据，最先出去</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过ss sp 两个寄存器确定了一个栈顶指针，然后随着一些操作，这个指针会向上向下移动<br>例如 push ax，这条指令会将ax中的内容运到栈中，然后sp-2。<strong>注意</strong>，栈顶地址为低地址，栈底地址为高地址，因此增加元素会使sp值减小</p><p>在栈为空的时候，偏移地址为栈底地址加2，例如栈底为000F，则此时偏移地址为10，在拉一个元素进栈后，偏移地址为000E，恰好是数据最高位（一个数据一个字，两个字节，栈底为000F，用了两个空间，因此此时元素到了000E，恰好sp也是000E</p><h3 id="超界问题"><a href="#超界问题" class="headerlink" title="超界问题"></a>超界问题</h3><p>8086cpu并没有特定的机制来检查我们是否超界，只能够靠自己小心，超界是一个十分严重的问题，因为既然这一段被分配为栈了，说明其他的内存有其他的用途，如果超界，可能会干扰其他程序的运行。要注意，栈的范围最大是0到ffff即2的16次方字节</p><h3 id="push-pop-命令"><a href="#push-pop-命令" class="headerlink" title="push pop 命令"></a>push pop 命令</h3><p>push 寄存器 pop 寄存器<br>也可以是push内存地址，pop内存地址 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;栈是一段连续的内存空间，这个空间的特殊性在于，最后进入这个空间的数据，最先出去&lt;/p&gt;
&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;通过ss sp 两个寄存器确定了一个栈顶指针，
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>debug</title>
    <link href="http://xinhecuican.github.io/2020/01/20/debug/"/>
    <id>http://xinhecuican.github.io/2020/01/20/debug/</id>
    <published>2020-01-20T06:15:00.000Z</published>
    <updated>2020-01-20T06:26:20.756Z</updated>
    
    <content type="html"><![CDATA[<p>这里列举几个debug的基本命令</p><h4 id="r"><a href="#r" class="headerlink" title="r"></a>r</h4><p>用来查看此时寄存器内的数值和下一步将要执行的命令<br>r 还可以接寄存器，用于修改寄存器内的内容<br>例：r ax 这样会出现ax的内容和一个冒号，然后就可以输入数据修改了</p><h3 id="d"><a href="#d" class="headerlink" title="d"></a>d</h3><p>格式：d 段地址：偏移地址<br>作用：列举出该地址下的机器码<br>例 d 1000:0,这样子将会列举从1000:0 到1000:7f的所有内容</p><h3 id="e"><a href="#e" class="headerlink" title="e"></a>e</h3><p>格式：e 段地址：偏移地址<br>作用：修改改地址下的机器码</p><h3 id="t"><a href="#t" class="headerlink" title="t"></a>t</h3><p>执行cs ip所指向内存地址的命令，直接输入t，不需要输入其他东西</p><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>作用：用汇编语言输入指令到内存上<br>写法： a 段地址：偏移地址<br>例： a 1000:0<br>输出1000：0  （input）mov ax，1<br>然后1000:0 到1000:3 就会输入这条指令了，之后将cs ip地址设置一下，然后用t指令运行</p><h3 id="u"><a href="#u" class="headerlink" title="u"></a>u</h3><p>作用：查看某地址下的汇编程序<br>写法： u 段地址：偏移地址<br>例 u 1000:0<br>然后就会输出1000:0 开始有的汇编指令了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里列举几个debug的基本命令&lt;/p&gt;
&lt;h4 id=&quot;r&quot;&gt;&lt;a href=&quot;#r&quot; class=&quot;headerlink&quot; title=&quot;r&quot;&gt;&lt;/a&gt;r&lt;/h4&gt;&lt;p&gt;用来查看此时寄存器内的数值和下一步将要执行的命令&lt;br&gt;r 还可以接寄存器，用于修改寄存器内的内容&lt;
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>树状数组和线段树</title>
    <link href="http://xinhecuican.github.io/2020/01/18/%E7%BA%BF%E6%AE%B5%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://xinhecuican.github.io/2020/01/18/%E7%BA%BF%E6%AE%B5%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2020-01-18T07:23:00.000Z</published>
    <updated>2020-01-21T11:44:25.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lowbit函数"><a href="#lowbit函数" class="headerlink" title="lowbit函数"></a>lowbit函数</h3><p>lowbit函数指的是将元素与元素的补码按位与，即a&amp;-a，这个值返回的是从右数第一个1开始的值</p><p>例如 6&amp;-6， 6二进制位为110，所以6的lowbit函数值为10，即十进制下的二</p><pre><code>ll lowbit(ll num){    return num&amp;-num;}</code></pre><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>首先我们可以把一整个数组分为若干小部分，然后让这几个小部分叠加就可以得到数组总的和。例如，我想求a[91],我可以先求c[88],发现c[88]管理2个数，再找c[86]，这样一直进行下去就可以了。</p><p>c又是什么呢？例如c[6]，它的lowbit函数为2，因此它管理两位数，所以c[6]=a[5]+a[6]</p><p>奇数位的c[i]只有他自己，而偶数位c[i]为2的k次方</p><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">add</span>(int <span class="keyword">x</span>, int k) &#123;</span><br><span class="line">  while (<span class="keyword">x</span> &lt;= n) &#123;  //不能越界</span><br><span class="line">    <span class="keyword">c</span>[<span class="keyword">x</span>] = <span class="keyword">c</span>[<span class="keyword">x</span>] + k<span class="comment">;</span></span><br><span class="line"><span class="comment">    x = x + lowbit(x);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>这个函数是把a[x]加上k，小于x的c不用修改</p><p>关键是x=x+lowbit(x)<br><img src="/images/1103198-20180725163149813-311841231.png" alt=""><br>从此图中我们可以看出，要想求偶数位节点大小，需要将所有子节点加起来，先要加自己和比自己小一位的奇数，再加上所有i+lowbit(i)=8的偶数</p><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int getsum(int <span class="symbol">x</span>) &#123;  <span class="comment">// a[1]……a[x]的和</span></span><br><span class="line">  int ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keywords">while</span> (<span class="symbol">x</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ans = ans + c[<span class="symbol">x</span>];</span><br><span class="line">    <span class="symbol">x</span> = <span class="symbol">x</span> - lowbit(<span class="symbol">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keywords">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">  <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; ++<span class="built_in">i</span>) &#123;</span><br><span class="line">    t[<span class="built_in">i</span>] += a[<span class="built_in">i</span>];</span><br><span class="line">    int <span class="built_in">j</span> = <span class="built_in">i</span> + lowbit(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">j</span> &lt;= n) t[<span class="built_in">j</span>] += t[<span class="built_in">i</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> kth(<span class="built_in">int</span> k) &#123;  <span class="comment">//权值树状数组查询第k小</span></span><br><span class="line">  <span class="built_in">int</span> cnt = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = log2(n); ~i; --i) &#123;</span><br><span class="line">    ret += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= n || cnt + t[ret] &gt;= k)</span><br><span class="line">      ret -= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cnt += t[ret];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>含义：线段树指的是将一个区间不断二分所形成的一个二叉树，根结点代表arr[0:N]区间所对应的信息，接着根结点被分为两个子树，分别存储arr[0:(N-1)/2]及arr[(N-1)/2+1:N]两个子区间对应的信息</p><p>初始化：注意此处我们对于segmentTree]数组的索引从1开始算起。则对于数组中的任意结点i，其左子结点为<code>2*i</code>，右子结点为<code>2*i + 1</code>，其母结点为i/2。<br><img src="/images/%E5%9B%BE%E7%89%879.png" alt=""><br><img src="/images/%E5%9B%BE%E7%89%8710.png" alt=""><br><img src="/images/%E5%9B%BE%E7%89%878.png" alt=""><br>递归实际意义是先向底层递归，然后从底层向上回溯，p的意思是节点的编号</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> build(<span class="built_in">int</span> s, <span class="built_in">int</span> t, <span class="built_in">int</span> p) &#123;</span><br><span class="line">  <span class="comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">  <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">int</span> m = (s + t) / <span class="number">2</span>;</span><br><span class="line">  build(s, m, p * <span class="number">2</span>), build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p><img src="/images/%E5%9B%BE%E7%89%8711.png" alt="">标记的作用是记录每次、每个节点要更新的值</p><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p><img src="/images/%E5%9B%BE%E7%89%8712.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;lowbit函数&quot;&gt;&lt;a href=&quot;#lowbit函数&quot; class=&quot;headerlink&quot; title=&quot;lowbit函数&quot;&gt;&lt;/a&gt;lowbit函数&lt;/h3&gt;&lt;p&gt;lowbit函数指的是将元素与元素的补码按位与，即a&amp;amp;-a，这个值返回的是从右数第一
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串之KMP算法</title>
    <link href="http://xinhecuican.github.io/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8BKMP%E7%AE%97%E6%B3%95/"/>
    <id>http://xinhecuican.github.io/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8BKMP%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-16T05:04:00.000Z</published>
    <updated>2020-01-16T06:55:17.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="由（扯）来（蛋）"><a href="#由（扯）来（蛋）" class="headerlink" title="由（扯）来（蛋）"></a>由（扯）来（蛋）</h3><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这三人的姓氏命名此算法。</p><h3 id="最长前缀和与后缀和"><a href="#最长前缀和与后缀和" class="headerlink" title="最长前缀和与后缀和"></a>最长前缀和与后缀和</h3><p>例如给出一个字符串ABCDABD<br><img src="/images/331.jpg" alt=""><br>前缀和就是从前往后数i个，后缀和是从第n-i个数到最后一个，首先我们便要找到每一个字母的最长相同前缀后缀和，然后求next数组，注意，只有一个元素时是不计算前缀后缀的，直接看为0</p><h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>next数组考虑的是除当前字符外的最长相同前缀后缀，实际上就是前一个前缀后缀和，因为把最后一个字母上去之后必定会使后缀和少一个，因此前缀后缀和也会-1，注意next数组中会出现-1，<strong>实际上这个数组就是将原数组整体右移一位，然后在第0位补上-1</strong></p><p><img src="/images/3331.jpg" alt=""></p><p><img src="/images/3332.jpg" alt=""></p><h3 id="用next数组进行匹配"><a href="#用next数组进行匹配" class="headerlink" title="用next数组进行匹配"></a>用next数组进行匹配</h3><p>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀 pj-k pj-k+1, …, pj-1 跟文本串 si-k si-k+1, …, si-1 匹配成功，但 pj 跟 si 匹配失败时，因为 next[j] = k，相当于在不包含 pj 的模式串中有最大长度为 k 的相同前缀后缀，即 p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令 j = next[j]，从而让模式串右移 j - next[j] 位，使得模式串的前缀 p0 p1, …, pk-1 对应着文本串 si-k si-k+1, …, si-1，而后让 pk 跟 si 继续匹配。如下图所示：<br><img src="/images/323.jpg" alt=""></p><p><strong>解释</strong>：因为前缀和后缀和相等，当最后一个匹配失误的时候就可以直接跳到后缀和开始的地方，这样就一下子匹配到了几位数，加快速度，至于合理性 ，K M P 这三个人已经证明过，而具体要跳几位呢？</p><p>比如说你有7个数，前面6个数已经匹配好了，结果第七位出了问题，这时一找next数组，发现第6位前缀和为2，那我们就要跳到第五位上去，找找规律，就是j-next[j]呀，没错，就是要跳这么多位，忘了自己推一下就好了，挺好推的</p><p><strong><em>失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</em></strong></p><h3 id="next数组求法"><a href="#next数组求法" class="headerlink" title="next数组求法"></a>next数组求法</h3><p>这里运用了递归的思想，首先对于前一两个可以直接写出来，然后对于后面的，假如第j个next值我们已经求出来了，那么对于第j+1个，</p><ol><li>如果p[k]=p[j]，则next[j+1]=k+1</li></ol><p>例如<img src="/images/3343.jpg" alt=""><br>C为p[j]，E为p[j+1]，next[j]=2,则第一，第二个与第五，第六个相同，如果第三个和3七个相同，则最大相同长度就为3，即p[k]=p[j]</p><p>2.如果p[k]!=p[j],则递归找p[next[k]]是否等于p[j]，p[next[next[k]]]是否等于p[j],直到找到或到了开头</p><p>对于第二种情况，也可以通过图来展示<br><img src="/images/3344.jpg" alt=""><br>现在p[j]!=p[k]，那么肯定要缩小范围，我么已经知道第一个与第二个是匹配的了，那么第五个第六个对应与第一个第二个匹配，但如果那里面没有前后缀的话，你减去一个就相当于破坏了结构（前缀从前往后，后缀也是从前往后，减去一个便要求这这个前缀串里面前几个要和后缀串里面后面几个匹配，因此要求next[k]就是为了里面要匹配，这样只需比较p[next[k]]和p[j]即可），假如中间就碰到了，那么next[j+1]=next[next[k]]+1,如果没碰到，那么next[j+1]=0（一朝回到解放前）</p><p>代码实现：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> GetNext(char* p,<span class="built_in">int</span> next[])  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">int</span> pLen = strlen(p);  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k;  </span><br><span class="line">            ++j;  </span><br><span class="line">            next[j] = k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配（最终代码）"><a href="#匹配（最终代码）" class="headerlink" title="匹配（最终代码）"></a>匹配（最终代码）</h3><p>匹配过程：</p><p>“假设现在文本串S匹配到 i 位置，模式串 P 匹配到 j 位置</p><p>如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符；</p><p>如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j] 位。</p><p>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。”</p><p>例 <img src="/images/3353.png" alt=""></p><p>例如此时i=10,j=6,此时文本串该位为空格，而匹配串为D，这时不匹配，就要让匹配串移动6-next[6]=4位，我令i=10,j=2,即匹配串为C,这就相当于让匹配位左移4位，而文本对应位不变，于是相当于匹配串右移4位（有种物理相对运动的既视感）</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      </span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      </span></span><br><span class="line">            <span class="comment">//next[j]即为j所对应的next值        </span></span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感到了代码的优美感有没有！</p><p>但是这样还可以优化</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>优化过后的<span class="keyword">next</span> 数组求法  </span><br><span class="line">void GetNextval(char* p, int <span class="keyword">next</span>[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int pLen = strlen(p);  </span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;  </span><br><span class="line">    int k = -<span class="number">1</span>;  </span><br><span class="line">    int j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">//</span>p[k]表示前缀，p[j]表示后缀    </span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k])  </span><br><span class="line">        &#123;  </span><br><span class="line">            ++j;  </span><br><span class="line">            ++k;  </span><br><span class="line">            <span class="regexp">//</span>较之前<span class="keyword">next</span>数组求法，改动在下面<span class="number">4</span>行  </span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])  </span><br><span class="line">                <span class="keyword">next</span>[j] = k;   <span class="regexp">//</span>之前只有这一行  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="regexp">//</span>因为不能出现p[j] = p[ <span class="keyword">next</span>[j ]]，所以当出现时需要继续递归，k = <span class="keyword">next</span>[k] = <span class="keyword">next</span>[<span class="keyword">next</span>[k]]  </span><br><span class="line">                <span class="keyword">next</span>[j] = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            k = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有点蒙，就先这样吧</p><p><a href="https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html" target="_blank" rel="noopener">参考文章（这篇文章真的太好了，生怕你不会）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;由（扯）来（蛋）&quot;&gt;&lt;a href=&quot;#由（扯）来（蛋）&quot; class=&quot;headerlink&quot; title=&quot;由（扯）来（蛋）&quot;&gt;&lt;/a&gt;由（扯）来（蛋）&lt;/h3&gt;&lt;p&gt;Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="http://xinhecuican.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>字符串之hash算法</title>
    <link href="http://xinhecuican.github.io/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8Bhash%E7%AE%97%E6%B3%95/"/>
    <id>http://xinhecuican.github.io/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8Bhash%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-16T04:14:00.000Z</published>
    <updated>2020-01-16T05:03:27.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hash基础概念"><a href="#hash基础概念" class="headerlink" title="hash基础概念"></a>hash基础概念</h3><p>但在工程实践中，要查找的关键字往往都不是自然数，即使是自然数也有可能是很大的值。因此，只要我们提前把关键字转换为在固定较小范围内的自然数，就可以实现常数时间的查找。那么问题来了，如何实现该转换关系呢？这就是哈希函数所要完成的工作。</p><p>哈希函数：又称散列函数，是把一段有限二进制串（字符串，整数等）转换为自然数的一种函数。</p><p>哈希值：哈希函数输出的最终结果。</p><p>字符串哈希函数：输入是字符串的哈希函数。</p><p>注：实际上就是用一个函数将字符串转化为整数，然后尽可能使一个整数对应一个字符串</p><p>现在的哈希函数基本上都是满射，多个字符串会对应一个数字，这种情况佳作冲突，为了减小冲突，列举几种方法</p><p><img src="/images/%E5%9B%BE%E7%89%876.png" alt=""><br>这种方法就是用进制转换的观念，一般用128,但这样十分容易超int型的范围，因此要想办法减小范围，可以用一个较大的数去摸，这时又出现了冲突的问题，那可以用两个数同时去摸，这样用两个数表示一个字符串冲突的几率便大大降低</p><p>BKDRHash算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BKDR Hash Function</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);<span class="comment">//ox7FFFFFFF代表int型最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;是与运算符，<a href="https://blog.csdn.net/ssdjdk/article/details/90199634" target="_blank" rel="noopener">详细看这</a></p><p>关于 <a href="https://blog.csdn.net/MyLinChi/article/details/79509455" target="_blank" rel="noopener">BKDRHash算法可以看</a></p><p>最好用unsigned int 类型，<a href="https://www.cnblogs.com/lailailai/p/4030151.html" target="_blank" rel="noopener">这样相当于每次hash操作都取了一次模</a></p><p>APhash算法</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// AP Hash Function</span><br><span class="line">unsigned int APHash(<span class="name">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int hash = 0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    for (i=0; *str<span class="comment">; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if ((<span class="name">i</span> &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= ((<span class="name">hash</span> &lt;&lt; <span class="number">7</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">3</span>))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= (~((<span class="name">hash</span> &lt;&lt; <span class="number">11</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">5</span>)))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return (<span class="name">hash</span> &amp; <span class="number">0</span>x7FFFFFFF)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/MyLinChi/article/details/79508112" target="_blank" rel="noopener">这篇博客讲的很详细</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;hash基础概念&quot;&gt;&lt;a href=&quot;#hash基础概念&quot; class=&quot;headerlink&quot; title=&quot;hash基础概念&quot;&gt;&lt;/a&gt;hash基础概念&lt;/h3&gt;&lt;p&gt;但在工程实践中，要查找的关键字往往都不是自然数，即使是自然数也有可能是很大的值。因此，只要我
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="http://xinhecuican.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://xinhecuican.github.io/2020/01/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://xinhecuican.github.io/2020/01/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-01-15T04:27:00.000Z</published>
    <updated>2020-01-15T11:49:35.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h3><p>无后效性是一个问题可以用动态规划求解的标志之一，理解无后效性对求解动态规划类题目非常重要</p><p>概念：某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响（某度上找的定义）</p><p>理解：无后效性指的是之前做过的事现在还可以继续去做，这便是前一阶段做的事对后一阶段无影响。如果前面做过了后面便不能去做或者做的事受限这便是有后效性</p><p>例：<a href="https://blog.csdn.net/qq_30137611/article/details/77655707" target="_blank" rel="noopener">这篇博客讲的很清楚</a></p><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p><a href="https://xinhecuican.github.io/2020/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">之前的一篇博客</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Good&#123;</span><br><span class="line"><span class="code">    int w;</span></span><br><span class="line"><span class="code">    int v;</span></span><br><span class="line">&#125;goods[101];</span><br><span class="line">int dp[<span class="string">101</span>][<span class="symbol">1001</span>];</span><br><span class="line">int n,S;//n表示有n个物品，S表示背包的最大容积</span><br><span class="line">for (i = 1; i <span class="xml"><span class="tag">&lt;<span class="name">=</span> <span class="attr">n</span>; <span class="attr">i</span>++)</span></span></span><br><span class="line"><span class="xml">&#123;</span></span><br><span class="line"><span class="xml">    for (j = S; j &gt;</span>= goods[i].w; j--)</span><br><span class="line"><span class="code">        dp[j] = max(dp[j], dp[j - goods[i].w] + goods[i].v);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，之所将j初始化为S，逆序循环更新状态是为了保证在更新dp[j]时，dp[j-goods[i].w]的状态尚未因为本次更新而发生改变，即等价于由</p><p>dp[i-1][j-goods[i].w]转移得到dp[i][j]。保证了更新dp[j]时，dp[j-goods[i].w]是没有放入物品i时的数据dp[i-1][j-goods[i].w]。</p><p>实际上01背包问题同一种思路代码写法有两种，如果s从0开始遍历就不需要逆序，但是从大于w[i]开始就需要逆序</p><p>实际上这里的二维数组可以优化变为一维数组</p><p>dp[i][j] = max{dp[i-1][j-w[i]]+v[i]，dp[i-1][j]，这里的i与i-1实际上是第i个物体与第i-1个物体，而这个可以用数组下标直接代替，这样便可以用一维数组解决背包问题，但是一维数组与二维数组的区别是二维数组保存了前i个物品所可以获得的最大价值，而一维数组只能保存题目要求的s个物品的最大价值，因此用一维还是用二维因题目而异</p><p>dp[j] = max{dp[j]，dp[j-w[i]]+v[i]}。从这个方程中我们可以发现，有两个dp[j]，但是要区分开。等号左边的dp[j]是当前i的状态，右边中括号内的dp[j]是第i-1状态下的值。</p><p>所以为了保证状态的正确转移，我们需要先更新等号左边中的dp[j]（当前状态的dp[j]）。</p><p>代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,maxv;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;maxv;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">1001</span>],v[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxv;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=maxv;k&gt;=w[i];k--)<span class="comment">/*这里是因为当背包体积小于物品体积时不可能成立，相当于if(k&lt;w[i])&#123;dp[i][k]=dp[i-1][k];&#125;*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[k]=<span class="built_in">max</span>(dp[k],dp[k-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[maxv]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展问题</p><p>继续0-1背包问题，如果在上面的问题加上一个限制条件，所选择的物品必须恰好装满背包，否则输出-1。这时数组初始化为负无穷</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">int w<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int v<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int maxv;</span><br><span class="line">int n;</span><br><span class="line">int dp<span class="comment">[MAXSIZE]</span><span class="comment">[MAXSIZE]</span>;</span><br><span class="line"></span><br><span class="line">int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &gt; b)</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxv;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w<span class="comment">[i]</span> &gt;&gt; v<span class="comment">[i]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化，当容积为0时，即不能装入，最大价值即为0</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[0]</span> = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化为-1，表示没有装满</span><br><span class="line">    for (int i = 0; i &lt;= n; i++)</span><br><span class="line">    for (int j = 1; j &lt;= maxv; j++)</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[j]</span> = -1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = maxv; j &gt;= w<span class="comment">[i]</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1表示容积为j - w<span class="comment">[i]</span>时没有装满，所以当容积为j，装w<span class="comment">[i]</span>时一定不能装满</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt; dp<span class="comment">[i-1]</span><span class="comment">[j]</span>表示装入物品i时签好装满并且总价值比前i-1个物品的总价值要大</span><br><span class="line">            if (dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1 &amp;&amp; dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt;= dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>)</span><br><span class="line">                dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = w<span class="comment">[i]</span> - 1; j &gt;= 1; j--)</span><br><span class="line">            dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp<span class="comment">[n]</span><span class="comment">[maxv]</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它大致相同，现在dp[i][j]表示的是恰好装j空间时价值的最大值</p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>题目：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (j = goods<span class="comment">[i]</span>.w; j &lt;= S; j++)</span><br><span class="line">        dp<span class="comment">[j]</span> = max(dp<span class="comment">[j]</span>, dp<span class="comment">[j - goods<span class="comment">[i]</span>.w]</span> + goods<span class="comment">[i]</span>.v);</span><br><span class="line">&#125;//不是很理解，但是先把模板记下吧</span><br></pre></td></tr></table></figure><p>这个代码和01背包代码十分相似，只有循环方向不同，为什么可以这样做呢？因为01背包要求每个物品只能选一次，因此根据这个式子，有可能会导致多选的就是dp[j - goods[i].w],如果从前往后循环，j-goods[i].w可能是已经选择了当前物品的情况</p><p><a href="https://pangyuworld.github.io/2019/04/03/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/#%E9%A2%98%E7%9B%AE%E7%B1%BB%E5%9E%8B-1" target="_blank" rel="noopener">可以去看</a></p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;无后效性&quot;&gt;&lt;a href=&quot;#无后效性&quot; class=&quot;headerlink&quot; title=&quot;无后效性&quot;&gt;&lt;/a&gt;无后效性&lt;/h3&gt;&lt;p&gt;无后效性是一个问题可以用动态规划求解的标志之一，理解无后效性对求解动态规划类题目非常重要&lt;/p&gt;
&lt;p&gt;概念：某阶段的状态一
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://xinhecuican.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>深度优先搜索和广度优先搜索</title>
    <link href="http://xinhecuican.github.io/2020/01/14/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    <id>http://xinhecuican.github.io/2020/01/14/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/</id>
    <published>2020-01-14T01:04:00.000Z</published>
    <updated>2020-01-14T07:38:57.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>基本思想：它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念</p><p>例<img src="/images/%E5%9B%BE%E7%89%871.png" alt=""></p><p>V0-&gt;V1-&gt;V4-&gt;V3-&gt;V5-&gt;V6,先从v0到V1，再从V1到V4，发现到了终点，就退回到V1继续寻找</p><p>代码</p><p>注意恢复初始状态十分重要，在一种情况走不了的情况下它可以使其恢复初始状态试下一条路</p><p><img src="/images/%E5%9B%BE%E7%89%872.png" alt=""></p><p>例题：<img src="/images/%E5%9B%BE%E7%89%873.png" alt=""></p><p>遍历连通图，能否从v0到v6</p><p>答案<img src="/images/%E5%9B%BE%E7%89%874.png" alt=""></p><p>说明，重要的便是模板，先判断当前情况是否满足，如果满足则退出，不满足则遍历所有情况，如果某一位置到了头便会返回false，然后返回到分叉点，搜索下一步（遍历作用在这），而最后一定要回到初始状态，因为别的搜索也可能用</p><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">广度优先搜索是最简便的图的搜索算法之一，别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中</span><br></pre></td></tr></table></figure><p>模板<br><img src="/images/%E5%9B%BE%E7%89%875.png" alt=""></p><p>说明：从某一个起始节点开始，看是否满足，如果不满足， 遍历所有可能的情况，这里便是tt，如果tt存在，那么就把它送入队列中，之后继续遍历可能情况，这里需要两个数组，一个数组是用来确定这点是否已经走过，另外一个数组是用来记录步数的。<a href="https://blog.csdn.net/freezhanacmore/article/details/8168265" target="_blank" rel="noopener">另外，有些题可能会导致数组超过范围，这时就要写一个判断条件排除掉越界的</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深度优先搜索&quot;&gt;&lt;a href=&quot;#深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索&quot;&gt;&lt;/a&gt;深度优先搜索&lt;/h3&gt;&lt;p&gt;基本思想：它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>scanf printf</title>
    <link href="http://xinhecuican.github.io/2020/01/13/scanf-printf/"/>
    <id>http://xinhecuican.github.io/2020/01/13/scanf-printf/</id>
    <published>2020-01-13T12:18:00.000Z</published>
    <updated>2020-01-13T12:45:34.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>格式：scanf(const char *format, …)</p><p>format – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。</p><p>format 说明符形式为:</p><p>[=%[*][width][modifiers]type=]</p><p><code>*</code>这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。</p><p>width    这指定了在当前读取操作中读取的最大字符数。</p><p>modifiers    为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）</p><p>type    一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格</p><p>| %a、%A|读入一个浮点值(仅 C99 有效)|float*|<br>| :——————————————-|<br>| %c     | 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。|    char *<br>|%d    |十进制整数：数字前面的 + 或 - 号是可选的。|    int *<br>|%e、%E、%f、%F、%g、%G    |浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4    |float *<br>|%i|    读入十进制，八进制，十六进制整数 。|    int *<br>|%o    |八进制整数。|    int *<br>|%s    |字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。|    char *<br>|%u    |无符号的十进制整数。|    unsigned int *</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>用%c 读数组时注意它不会读入换行符，因此每次用完之后要用getchar()<br>，而%s就不用担心这个问题</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>格式 printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p><p>声明 printf(const char *format, …)</p><p>|格式字符|    意义<br>|————————-|<br>|d|    以十进制形式输出带符号整数(正数不输出符号)<br>|o    |以八进制形式输出无符号整数(不输出前缀0)<br>|x,X    |以十六进制形式输出无符号整数(不输出前缀Ox)<br>|u    |以十进制形式输出无符号整数<br>|f|    以小数形式输出单、双精度实数<br>|e,E    |以指数形式输出单、双精度实数<br>|g,G    |以%f或%e中较短的输出宽度输出单、双精度实数<br>|c|    输出单个字符<br>|s    |输出字符串<br>|p|    输出指针地址<br>|lu    |32位无符号整数<br>|llu|    64位无符号整数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;scanf&quot;&gt;&lt;a href=&quot;#scanf&quot; class=&quot;headerlink&quot; title=&quot;scanf&quot;&gt;&lt;/a&gt;scanf&lt;/h3&gt;&lt;p&gt;格式：scanf(const char *format, …)&lt;/p&gt;
&lt;p&gt;format – 这是 C 字符串，包
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://xinhecuican.github.io/2020/01/13/%E9%98%9F%E5%88%97/"/>
    <id>http://xinhecuican.github.io/2020/01/13/%E9%98%9F%E5%88%97/</id>
    <published>2020-01-13T08:05:00.000Z</published>
    <updated>2020-01-14T06:39:20.507Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h3><p>队列是一种线性结构，有队头（front）队尾（rear）两个指针，每次拉进来一个元素会让队尾加一，而每次删除一个元素会让队头加一，这是一种先进先出的结构。</p><p>队列特殊情况判断</p><p>空队列 front=rear</p><p>满队列 rear-front=N（N指的是开的数组的大小）</p><p>POP 从队头删元素</p><p>push 拉元素到队尾</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">duilie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> front ,rear;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        front=rear=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front)==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear-front==N<span class="number">-1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(full())<span class="comment">//如果满了就不能拖进去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[++rear]=key;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>上面一种队列并不是真的有n个空间，如果pop了元素那空间就要减小，这样便浪费了许多空间，而用模运算组成一个循环可以使空间充分利用</p><p>特殊情况判断</p><p>空 ： front=rear</p><p>满 ：（ rear+1）% N=front</p><p>代码实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const <span class="built_in">int</span> Queue_Size=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">typedef <span class="keyword">struct</span> circlQueue</span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> *elem;</span><br><span class="line">       <span class="built_in">int</span> rear;</span><br><span class="line">       <span class="built_in">int</span> front;</span><br><span class="line">       <span class="built_in">int</span> queueSize;</span><br><span class="line">&#125;circlQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">void init<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem=<span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[Q<span class="identifier">ueue_Size</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;<span class="comment">//首尾指针相等说明队列为空。</span></span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=Queue_Size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*销毁队列*/</span></span><br><span class="line">void destroy<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       delete <span class="literal">[]</span><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*求队列的长度*/</span></span><br><span class="line"><span class="built_in">int</span>  length<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">int</span> length;</span><br><span class="line">       length=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear-<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;<span class="comment">/*一般情况下，rear在front的上方，此种算法是用于</span></span><br><span class="line"><span class="comment">  rear已到front的下方，即已出现假溢出的情况。*/</span></span><br><span class="line">       return length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*入队列*/</span></span><br><span class="line">void enter<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q,<span class="params">char</span> <span class="params">x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span>(((<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)<span class="comment">//判断栈满的情况</span></span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue OverFlow!"</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">rear</span>]</span>=x;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%Queue_Size;<span class="comment">//尾指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="built_in">char</span> output<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> e;</span><br><span class="line">       <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)</span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue Empty"</span>;</span><br><span class="line">       e=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">front</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;;<span class="comment">//头指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">       return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「hackerain」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/hackerain/article/details/5934240</span></span><br></pre></td></tr></table></figure><h3 id="队列的函数"><a href="#队列的函数" class="headerlink" title="队列的函数"></a>队列的函数</h3><p>push()：脱元素到队尾</p><p>pop()删队首元素</p><p>size()</p><p>front()返回队首元素</p><p>back()返回队尾元素</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>front无法使用迭代器，因为queue在物理地址上不连续，所以queue无法遍历，想要遍历只能不停top POP，这样会销毁队列</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>HDU 1387 </li></ul><p>Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.<br>In a team queue each element belongs to a team. If an element enters the queue, it first searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.</p><p>Your task is to write a program that simulates such a team queue.</p><p>Input</p><p>The input will contain one or more test cases. Each test case begins with the number of teams t (1&lt;=t&lt;=1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0 - 999999. A team may consist of up to 1000 elements.</p><p>Finally, a list of commands follows. There are three different kinds of commands:</p><p>ENQUEUE x - enter element x into the team queue<br>DEQUEUE - process the first element and remove it from the queue<br>STOP - end of test case<br>The input will be terminated by a value of 0 for t.</p><p>Output</p><p>For each test case, first print a line saying “Scenario #k”, where k is the number of the test case. Then, for each DEQUEUE command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line"><span class="number">3</span> <span class="number">201</span> <span class="number">202</span> <span class="number">203</span></span><br><span class="line">ENQUEUE <span class="number">101</span></span><br><span class="line">ENQUEUE <span class="number">201</span></span><br><span class="line">ENQUEUE <span class="number">102</span></span><br><span class="line">ENQUEUE <span class="number">202</span></span><br><span class="line">ENQUEUE <span class="number">103</span></span><br><span class="line">ENQUEUE <span class="number">203</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">259001</span> <span class="number">259002</span> <span class="number">259003</span> <span class="number">259004</span> <span class="number">259005</span></span><br><span class="line"><span class="number">6</span> <span class="number">260001</span> <span class="number">260002</span> <span class="number">260003</span> <span class="number">260004</span> <span class="number">260005</span> <span class="number">260006</span></span><br><span class="line">ENQUEUE <span class="number">259001</span></span><br><span class="line">ENQUEUE <span class="number">260001</span></span><br><span class="line">ENQUEUE <span class="number">259002</span></span><br><span class="line">ENQUEUE <span class="number">259003</span></span><br><span class="line">ENQUEUE <span class="number">259004</span></span><br><span class="line">ENQUEUE <span class="number">259005</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">ENQUEUE <span class="number">260002</span></span><br><span class="line">ENQUEUE <span class="number">260003</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">1</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">201</span></span><br><span class="line"><span class="number">202</span></span><br><span class="line"><span class="number">203</span></span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">2</span></span><br><span class="line"><span class="number">259001</span></span><br><span class="line"><span class="number">259002</span></span><br><span class="line"><span class="number">259003</span></span><br><span class="line"><span class="number">259004</span></span><br><span class="line"><span class="number">259005</span></span><br><span class="line"><span class="number">260001</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;队列基础&quot;&gt;&lt;a href=&quot;#队列基础&quot; class=&quot;headerlink&quot; title=&quot;队列基础&quot;&gt;&lt;/a&gt;队列基础&lt;/h3&gt;&lt;p&gt;队列是一种线性结构，有队头（front）队尾（rear）两个指针，每次拉进来一个元素会让队尾加一，而每次删除一个元素会让队头
      
    
    </summary>
    
    
      <category term="stl" scheme="http://xinhecuican.github.io/categories/stl/"/>
    
    
  </entry>
  
</feed>
