<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-01-20T09:19:18.720Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编的第一个程序</title>
    <link href="http://xinhecuican.github.io/2020/01/20/%E6%B1%87%E7%BC%96%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"/>
    <id>http://xinhecuican.github.io/2020/01/20/%E6%B1%87%E7%BC%96%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-01-20T07:58:00.000Z</published>
    <updated>2020-01-20T09:19:18.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>编译器中，包含两种指令，一种是汇编指令，一种是伪指令。伪指令是给编译器看的，最终不会被cpu执行。先了解三个最为基础的伪指令</p><ul><li>XXX segment，XXX ends，这两个是配套使用的。功能是定义一个代码段，一个段必须要有一个名称标识（XXX是也）</li></ul><p>例如codesg segment ，codesg ends</p><ul><li>assume </li></ul><p>这条指令作用是假设某一寄存器和程序中的某一个用segment和ends定义的段相关联，写在最开头。</p><ul><li>end</li></ul><p>没什么特别的，程序的结束标识，不写程序不知道在哪里结束</p><h3 id="一个程序"><a href="#一个程序" class="headerlink" title="一个程序"></a>一个程序</h3><pre><code>assume cs: codesgcodesg segment    mov ax,0123    mov bx,0456    add ax,bx    mov ax,4c00    int 21codesg endsend</code></pre><h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>在单任务操作系统上，一次只可以执行一个程序，那么当我们写的这个程序执行完之后，还要把cpu控制权交给dos，而mov ax，4c00 和 int 21 就是做这个工作的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;伪指令&quot;&gt;&lt;a href=&quot;#伪指令&quot; class=&quot;headerlink&quot; title=&quot;伪指令&quot;&gt;&lt;/a&gt;伪指令&lt;/h3&gt;&lt;p&gt;编译器中，包含两种指令，一种是汇编指令，一种是伪指令。伪指令是给编译器看的，最终不会被cpu执行。先了解三个最为基础的伪指令&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>栈.                                      </title>
    <link href="http://xinhecuican.github.io/2020/01/20/%E6%A0%88/"/>
    <id>http://xinhecuican.github.io/2020/01/20/%E6%A0%88/</id>
    <published>2020-01-20T06:26:00.000Z</published>
    <updated>2020-01-20T07:58:09.483Z</updated>
    
    <content type="html"><![CDATA[<p>栈是一段连续的内存空间，这个空间的特殊性在于，最后进入这个空间的数据，最先出去</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过ss sp 两个寄存器确定了一个栈顶指针，然后随着一些操作，这个指针会向上向下移动<br>例如 push ax，这条指令会将ax中的内容运到栈中，然后sp-2。<strong>注意</strong>，栈顶地址为低地址，栈底地址为高地址，因此增加元素会使sp值减小</p><p>在栈为空的时候，偏移地址为栈底地址加2，例如栈底为000F，则此时偏移地址为10，在拉一个元素进栈后，偏移地址为000E，恰好是数据最高位（一个数据一个字，两个字节，栈底为000F，用了两个空间，因此此时元素到了000E，恰好sp也是000E</p><h3 id="超界问题"><a href="#超界问题" class="headerlink" title="超界问题"></a>超界问题</h3><p>8086cpu并没有特定的机制来检查我们是否超界，只能够靠自己小心，超界是一个十分严重的问题，因为既然这一段被分配为栈了，说明其他的内存有其他的用途，如果超界，可能会干扰其他程序的运行。要注意，栈的范围最大是0到ffff即2的16次方字节</p><h3 id="push-pop-命令"><a href="#push-pop-命令" class="headerlink" title="push pop 命令"></a>push pop 命令</h3><p>push 寄存器 pop 寄存器<br>也可以是push内存地址，pop内存地址 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;栈是一段连续的内存空间，这个空间的特殊性在于，最后进入这个空间的数据，最先出去&lt;/p&gt;
&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;通过ss sp 两个寄存器确定了一个栈顶指针，
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>debug</title>
    <link href="http://xinhecuican.github.io/2020/01/20/debug/"/>
    <id>http://xinhecuican.github.io/2020/01/20/debug/</id>
    <published>2020-01-20T06:15:00.000Z</published>
    <updated>2020-01-20T06:26:20.756Z</updated>
    
    <content type="html"><![CDATA[<p>这里列举几个debug的基本命令</p><h4 id="r"><a href="#r" class="headerlink" title="r"></a>r</h4><p>用来查看此时寄存器内的数值和下一步将要执行的命令<br>r 还可以接寄存器，用于修改寄存器内的内容<br>例：r ax 这样会出现ax的内容和一个冒号，然后就可以输入数据修改了</p><h3 id="d"><a href="#d" class="headerlink" title="d"></a>d</h3><p>格式：d 段地址：偏移地址<br>作用：列举出该地址下的机器码<br>例 d 1000:0,这样子将会列举从1000:0 到1000:7f的所有内容</p><h3 id="e"><a href="#e" class="headerlink" title="e"></a>e</h3><p>格式：e 段地址：偏移地址<br>作用：修改改地址下的机器码</p><h3 id="t"><a href="#t" class="headerlink" title="t"></a>t</h3><p>执行cs ip所指向内存地址的命令，直接输入t，不需要输入其他东西</p><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>作用：用汇编语言输入指令到内存上<br>写法： a 段地址：偏移地址<br>例： a 1000:0<br>输出1000：0  （input）mov ax，1<br>然后1000:0 到1000:3 就会输入这条指令了，之后将cs ip地址设置一下，然后用t指令运行</p><h3 id="u"><a href="#u" class="headerlink" title="u"></a>u</h3><p>作用：查看某地址下的汇编程序<br>写法： u 段地址：偏移地址<br>例 u 1000:0<br>然后就会输出1000:0 开始有的汇编指令了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里列举几个debug的基本命令&lt;/p&gt;
&lt;h4 id=&quot;r&quot;&gt;&lt;a href=&quot;#r&quot; class=&quot;headerlink&quot; title=&quot;r&quot;&gt;&lt;/a&gt;r&lt;/h4&gt;&lt;p&gt;用来查看此时寄存器内的数值和下一步将要执行的命令&lt;br&gt;r 还可以接寄存器，用于修改寄存器内的内容&lt;
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>树状数组和线段树</title>
    <link href="http://xinhecuican.github.io/2020/01/18/%E7%BA%BF%E6%AE%B5%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://xinhecuican.github.io/2020/01/18/%E7%BA%BF%E6%AE%B5%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2020-01-18T07:23:00.000Z</published>
    <updated>2020-01-19T06:08:02.273Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lowbit函数"><a href="#lowbit函数" class="headerlink" title="lowbit函数"></a>lowbit函数</h3><p>lowbit函数指的是将元素与元素的补码按位与，即a&amp;-a，这个值返回的是从右数第一个1开始的值</p><p>例如 6&amp;-6， 6二进制位为110，所以6的lowbit函数值为10，即十进制下的二</p><pre><code>ll lowbit(ll num){    return num&amp;-num;}</code></pre><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>首先我们可以把一整个数组分为若干小部分，然后让这几个小部分叠加就可以得到数组总的和。例如，我想求a[91],我可以先求c[88],发现c[88]管理2个数，再找c[86]，这样一直进行下去就可以了。</p><p>c又是什么呢？例如c[6]，它的lowbit函数为2，因此它管理两位数，所以c[6]=a[5]+a[6]</p><p>奇数位的c[i]只有他自己，而偶数位c[i]为2的k次方</p><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">add</span>(int <span class="keyword">x</span>, int k) &#123;</span><br><span class="line">  while (<span class="keyword">x</span> &lt;= n) &#123;  //不能越界</span><br><span class="line">    <span class="keyword">c</span>[<span class="keyword">x</span>] = <span class="keyword">c</span>[<span class="keyword">x</span>] + k<span class="comment">;</span></span><br><span class="line"><span class="comment">    x = x + lowbit(x);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>这个函数是把a[x]加上k，小于x的c不用修改</p><p>关键是x=x+lowbit(x)<br><img src="/images/1103198-20180725163149813-311841231.png" alt=""><br>从此图中我们可以看出，要想求偶数位节点大小，需要将所有子节点加起来，先要加自己和比自己小一位的奇数，再加上所有i+lowbit(i)=8的偶数</p><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int getsum(int <span class="symbol">x</span>) &#123;  <span class="comment">// a[1]……a[x]的和</span></span><br><span class="line">  int ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keywords">while</span> (<span class="symbol">x</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ans = ans + c[<span class="symbol">x</span>];</span><br><span class="line">    <span class="symbol">x</span> = <span class="symbol">x</span> - lowbit(<span class="symbol">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keywords">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">  <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt;= n; ++<span class="built_in">i</span>) &#123;</span><br><span class="line">    t[<span class="built_in">i</span>] += a[<span class="built_in">i</span>];</span><br><span class="line">    int <span class="built_in">j</span> = <span class="built_in">i</span> + lowbit(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">j</span> &lt;= n) t[<span class="built_in">j</span>] += t[<span class="built_in">i</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> kth(<span class="built_in">int</span> k) &#123;  <span class="comment">//权值树状数组查询第k小</span></span><br><span class="line">  <span class="built_in">int</span> cnt = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = log2(n); ~i; --i) &#123;</span><br><span class="line">    ret += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= n || cnt + t[ret] &gt;= k)</span><br><span class="line">      ret -= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cnt += t[ret];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>含义：线段树指的是将一个区间不断二分所形成的一个二叉树，根结点代表arr[0:N]区间所对应的信息，接着根结点被分为两个子树，分别存储arr[0:(N-1)/2]及arr[(N-1)/2+1:N]两个子区间对应的信息</p><p>初始化：注意此处我们对于segmentTree]数组的索引从1开始算起。则对于数组中的任意结点i，其左子结点为<code>2*i</code>，右子结点为<code>2*i + 1</code>，其母结点为i/2。<br><img src="/images/%E5%9B%BE%E7%89%879.png" alt=""><br><img src="/images/%E5%9B%BE%E7%89%8710.png" alt=""><br><img src="/images/%E5%9B%BE%E7%89%878.png" alt=""><br>递归实际意义是先向底层递归，然后从底层向上回溯</p><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p><img src="/images/%E5%9B%BE%E7%89%8711.png" alt="">标记的作用是记录每次、每个节点要更新的值</p><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p><img src="/images/%E5%9B%BE%E7%89%8712.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;lowbit函数&quot;&gt;&lt;a href=&quot;#lowbit函数&quot; class=&quot;headerlink&quot; title=&quot;lowbit函数&quot;&gt;&lt;/a&gt;lowbit函数&lt;/h3&gt;&lt;p&gt;lowbit函数指的是将元素与元素的补码按位与，即a&amp;amp;-a，这个值返回的是从右数第一
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串之KMP算法</title>
    <link href="http://xinhecuican.github.io/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8BKMP%E7%AE%97%E6%B3%95/"/>
    <id>http://xinhecuican.github.io/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8BKMP%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-16T05:04:00.000Z</published>
    <updated>2020-01-16T06:55:17.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="由（扯）来（蛋）"><a href="#由（扯）来（蛋）" class="headerlink" title="由（扯）来（蛋）"></a>由（扯）来（蛋）</h3><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这三人的姓氏命名此算法。</p><h3 id="最长前缀和与后缀和"><a href="#最长前缀和与后缀和" class="headerlink" title="最长前缀和与后缀和"></a>最长前缀和与后缀和</h3><p>例如给出一个字符串ABCDABD<br><img src="/images/331.jpg" alt=""><br>前缀和就是从前往后数i个，后缀和是从第n-i个数到最后一个，首先我们便要找到每一个字母的最长相同前缀后缀和，然后求next数组，注意，只有一个元素时是不计算前缀后缀的，直接看为0</p><h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>next数组考虑的是除当前字符外的最长相同前缀后缀，实际上就是前一个前缀后缀和，因为把最后一个字母上去之后必定会使后缀和少一个，因此前缀后缀和也会-1，注意next数组中会出现-1，<strong>实际上这个数组就是将原数组整体右移一位，然后在第0位补上-1</strong></p><p><img src="/images/3331.jpg" alt=""></p><p><img src="/images/3332.jpg" alt=""></p><h3 id="用next数组进行匹配"><a href="#用next数组进行匹配" class="headerlink" title="用next数组进行匹配"></a>用next数组进行匹配</h3><p>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀 pj-k pj-k+1, …, pj-1 跟文本串 si-k si-k+1, …, si-1 匹配成功，但 pj 跟 si 匹配失败时，因为 next[j] = k，相当于在不包含 pj 的模式串中有最大长度为 k 的相同前缀后缀，即 p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令 j = next[j]，从而让模式串右移 j - next[j] 位，使得模式串的前缀 p0 p1, …, pk-1 对应着文本串 si-k si-k+1, …, si-1，而后让 pk 跟 si 继续匹配。如下图所示：<br><img src="/images/323.jpg" alt=""></p><p><strong>解释</strong>：因为前缀和后缀和相等，当最后一个匹配失误的时候就可以直接跳到后缀和开始的地方，这样就一下子匹配到了几位数，加快速度，至于合理性 ，K M P 这三个人已经证明过，而具体要跳几位呢？</p><p>比如说你有7个数，前面6个数已经匹配好了，结果第七位出了问题，这时一找next数组，发现第6位前缀和为2，那我们就要跳到第五位上去，找找规律，就是j-next[j]呀，没错，就是要跳这么多位，忘了自己推一下就好了，挺好推的</p><p><strong><em>失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</em></strong></p><h3 id="next数组求法"><a href="#next数组求法" class="headerlink" title="next数组求法"></a>next数组求法</h3><p>这里运用了递归的思想，首先对于前一两个可以直接写出来，然后对于后面的，假如第j个next值我们已经求出来了，那么对于第j+1个，</p><ol><li>如果p[k]=p[j]，则next[j+1]=k+1</li></ol><p>例如<img src="/images/3343.jpg" alt=""><br>C为p[j]，E为p[j+1]，next[j]=2,则第一，第二个与第五，第六个相同，如果第三个和3七个相同，则最大相同长度就为3，即p[k]=p[j]</p><p>2.如果p[k]!=p[j],则递归找p[next[k]]是否等于p[j]，p[next[next[k]]]是否等于p[j],直到找到或到了开头</p><p>对于第二种情况，也可以通过图来展示<br><img src="/images/3344.jpg" alt=""><br>现在p[j]!=p[k]，那么肯定要缩小范围，我么已经知道第一个与第二个是匹配的了，那么第五个第六个对应与第一个第二个匹配，但如果那里面没有前后缀的话，你减去一个就相当于破坏了结构（前缀从前往后，后缀也是从前往后，减去一个便要求这这个前缀串里面前几个要和后缀串里面后面几个匹配，因此要求next[k]就是为了里面要匹配，这样只需比较p[next[k]]和p[j]即可），假如中间就碰到了，那么next[j+1]=next[next[k]]+1,如果没碰到，那么next[j+1]=0（一朝回到解放前）</p><p>代码实现：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> GetNext(char* p,<span class="built_in">int</span> next[])  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">int</span> pLen = strlen(p);  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> k = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k;  </span><br><span class="line">            ++j;  </span><br><span class="line">            next[j] = k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配（最终代码）"><a href="#匹配（最终代码）" class="headerlink" title="匹配（最终代码）"></a>匹配（最终代码）</h3><p>匹配过程：</p><p>“假设现在文本串S匹配到 i 位置，模式串 P 匹配到 j 位置</p><p>如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符；</p><p>如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j] 位。</p><p>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。”</p><p>例 <img src="/images/3353.png" alt=""></p><p>例如此时i=10,j=6,此时文本串该位为空格，而匹配串为D，这时不匹配，就要让匹配串移动6-next[6]=4位，我令i=10,j=2,即匹配串为C,这就相当于让匹配位左移4位，而文本对应位不变，于是相当于匹配串右移4位（有种物理相对运动的既视感）</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    <span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      </span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      </span></span><br><span class="line">            <span class="comment">//next[j]即为j所对应的next值        </span></span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感到了代码的优美感有没有！</p><p>但是这样还可以优化</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>优化过后的<span class="keyword">next</span> 数组求法  </span><br><span class="line">void GetNextval(char* p, int <span class="keyword">next</span>[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int pLen = strlen(p);  </span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = -<span class="number">1</span>;  </span><br><span class="line">    int k = -<span class="number">1</span>;  </span><br><span class="line">    int j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">//</span>p[k]表示前缀，p[j]表示后缀    </span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k])  </span><br><span class="line">        &#123;  </span><br><span class="line">            ++j;  </span><br><span class="line">            ++k;  </span><br><span class="line">            <span class="regexp">//</span>较之前<span class="keyword">next</span>数组求法，改动在下面<span class="number">4</span>行  </span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])  </span><br><span class="line">                <span class="keyword">next</span>[j] = k;   <span class="regexp">//</span>之前只有这一行  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="regexp">//</span>因为不能出现p[j] = p[ <span class="keyword">next</span>[j ]]，所以当出现时需要继续递归，k = <span class="keyword">next</span>[k] = <span class="keyword">next</span>[<span class="keyword">next</span>[k]]  </span><br><span class="line">                <span class="keyword">next</span>[j] = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            k = <span class="keyword">next</span>[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有点蒙，就先这样吧</p><p><a href="https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html" target="_blank" rel="noopener">参考文章（这篇文章真的太好了，生怕你不会）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;由（扯）来（蛋）&quot;&gt;&lt;a href=&quot;#由（扯）来（蛋）&quot; class=&quot;headerlink&quot; title=&quot;由（扯）来（蛋）&quot;&gt;&lt;/a&gt;由（扯）来（蛋）&lt;/h3&gt;&lt;p&gt;Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="http://xinhecuican.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>字符串之hash算法</title>
    <link href="http://xinhecuican.github.io/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8Bhash%E7%AE%97%E6%B3%95/"/>
    <id>http://xinhecuican.github.io/2020/01/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8Bhash%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-16T04:14:00.000Z</published>
    <updated>2020-01-16T05:03:27.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hash基础概念"><a href="#hash基础概念" class="headerlink" title="hash基础概念"></a>hash基础概念</h3><p>但在工程实践中，要查找的关键字往往都不是自然数，即使是自然数也有可能是很大的值。因此，只要我们提前把关键字转换为在固定较小范围内的自然数，就可以实现常数时间的查找。那么问题来了，如何实现该转换关系呢？这就是哈希函数所要完成的工作。</p><p>哈希函数：又称散列函数，是把一段有限二进制串（字符串，整数等）转换为自然数的一种函数。</p><p>哈希值：哈希函数输出的最终结果。</p><p>字符串哈希函数：输入是字符串的哈希函数。</p><p>注：实际上就是用一个函数将字符串转化为整数，然后尽可能使一个整数对应一个字符串</p><p>现在的哈希函数基本上都是满射，多个字符串会对应一个数字，这种情况佳作冲突，为了减小冲突，列举几种方法</p><p><img src="/images/%E5%9B%BE%E7%89%876.png" alt=""><br>这种方法就是用进制转换的观念，一般用128,但这样十分容易超int型的范围，因此要想办法减小范围，可以用一个较大的数去摸，这时又出现了冲突的问题，那可以用两个数同时去摸，这样用两个数表示一个字符串冲突的几率便大大降低</p><p>BKDRHash算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BKDR Hash Function</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);<span class="comment">//ox7FFFFFFF代表int型最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;是与运算符，<a href="https://blog.csdn.net/ssdjdk/article/details/90199634" target="_blank" rel="noopener">详细看这</a></p><p>关于 <a href="https://blog.csdn.net/MyLinChi/article/details/79509455" target="_blank" rel="noopener">BKDRHash算法可以看</a></p><p>最好用unsigned int 类型，<a href="https://www.cnblogs.com/lailailai/p/4030151.html" target="_blank" rel="noopener">这样相当于每次hash操作都取了一次模</a></p><p>APhash算法</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// AP Hash Function</span><br><span class="line">unsigned int APHash(<span class="name">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int hash = 0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    for (i=0; *str<span class="comment">; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if ((<span class="name">i</span> &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= ((<span class="name">hash</span> &lt;&lt; <span class="number">7</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">3</span>))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hash ^= (~((<span class="name">hash</span> &lt;&lt; <span class="number">11</span>) ^ (<span class="name">*str++</span>) ^ (<span class="name">hash</span> &gt;&gt; <span class="number">5</span>)))<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return (<span class="name">hash</span> &amp; <span class="number">0</span>x7FFFFFFF)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/MyLinChi/article/details/79508112" target="_blank" rel="noopener">这篇博客讲的很详细</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;hash基础概念&quot;&gt;&lt;a href=&quot;#hash基础概念&quot; class=&quot;headerlink&quot; title=&quot;hash基础概念&quot;&gt;&lt;/a&gt;hash基础概念&lt;/h3&gt;&lt;p&gt;但在工程实践中，要查找的关键字往往都不是自然数，即使是自然数也有可能是很大的值。因此，只要我
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="http://xinhecuican.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://xinhecuican.github.io/2020/01/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://xinhecuican.github.io/2020/01/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-01-15T04:27:00.000Z</published>
    <updated>2020-01-15T11:49:35.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h3><p>无后效性是一个问题可以用动态规划求解的标志之一，理解无后效性对求解动态规划类题目非常重要</p><p>概念：某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响（某度上找的定义）</p><p>理解：无后效性指的是之前做过的事现在还可以继续去做，这便是前一阶段做的事对后一阶段无影响。如果前面做过了后面便不能去做或者做的事受限这便是有后效性</p><p>例：<a href="https://blog.csdn.net/qq_30137611/article/details/77655707" target="_blank" rel="noopener">这篇博客讲的很清楚</a></p><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p><a href="https://xinhecuican.github.io/2020/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">之前的一篇博客</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Good&#123;</span><br><span class="line"><span class="code">    int w;</span></span><br><span class="line"><span class="code">    int v;</span></span><br><span class="line">&#125;goods[101];</span><br><span class="line">int dp[<span class="string">101</span>][<span class="symbol">1001</span>];</span><br><span class="line">int n,S;//n表示有n个物品，S表示背包的最大容积</span><br><span class="line">for (i = 1; i <span class="xml"><span class="tag">&lt;<span class="name">=</span> <span class="attr">n</span>; <span class="attr">i</span>++)</span></span></span><br><span class="line"><span class="xml">&#123;</span></span><br><span class="line"><span class="xml">    for (j = S; j &gt;</span>= goods[i].w; j--)</span><br><span class="line"><span class="code">        dp[j] = max(dp[j], dp[j - goods[i].w] + goods[i].v);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，之所将j初始化为S，逆序循环更新状态是为了保证在更新dp[j]时，dp[j-goods[i].w]的状态尚未因为本次更新而发生改变，即等价于由</p><p>dp[i-1][j-goods[i].w]转移得到dp[i][j]。保证了更新dp[j]时，dp[j-goods[i].w]是没有放入物品i时的数据dp[i-1][j-goods[i].w]。</p><p>实际上01背包问题同一种思路代码写法有两种，如果s从0开始遍历就不需要逆序，但是从大于w[i]开始就需要逆序</p><p>实际上这里的二维数组可以优化变为一维数组</p><p>dp[i][j] = max{dp[i-1][j-w[i]]+v[i]，dp[i-1][j]，这里的i与i-1实际上是第i个物体与第i-1个物体，而这个可以用数组下标直接代替，这样便可以用一维数组解决背包问题，但是一维数组与二维数组的区别是二维数组保存了前i个物品所可以获得的最大价值，而一维数组只能保存题目要求的s个物品的最大价值，因此用一维还是用二维因题目而异</p><p>dp[j] = max{dp[j]，dp[j-w[i]]+v[i]}。从这个方程中我们可以发现，有两个dp[j]，但是要区分开。等号左边的dp[j]是当前i的状态，右边中括号内的dp[j]是第i-1状态下的值。</p><p>所以为了保证状态的正确转移，我们需要先更新等号左边中的dp[j]（当前状态的dp[j]）。</p><p>代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,maxv;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;maxv;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">1001</span>],v[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxv;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=maxv;k&gt;=w[i];k--)<span class="comment">/*这里是因为当背包体积小于物品体积时不可能成立，相当于if(k&lt;w[i])&#123;dp[i][k]=dp[i-1][k];&#125;*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[k]=<span class="built_in">max</span>(dp[k],dp[k-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[maxv]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展问题</p><p>继续0-1背包问题，如果在上面的问题加上一个限制条件，所选择的物品必须恰好装满背包，否则输出-1。这时数组初始化为负无穷</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">int w<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int v<span class="comment">[MAXSIZE]</span>;</span><br><span class="line">int maxv;</span><br><span class="line">int n;</span><br><span class="line">int dp<span class="comment">[MAXSIZE]</span><span class="comment">[MAXSIZE]</span>;</span><br><span class="line"></span><br><span class="line">int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &gt; b)</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxv;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w<span class="comment">[i]</span> &gt;&gt; v<span class="comment">[i]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化，当容积为0时，即不能装入，最大价值即为0</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[0]</span> = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化为-1，表示没有装满</span><br><span class="line">    for (int i = 0; i &lt;= n; i++)</span><br><span class="line">    for (int j = 1; j &lt;= maxv; j++)</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[j]</span> = -1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = maxv; j &gt;= w<span class="comment">[i]</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1表示容积为j - w<span class="comment">[i]</span>时没有装满，所以当容积为j，装w<span class="comment">[i]</span>时一定不能装满</span><br><span class="line">            //dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt; dp<span class="comment">[i-1]</span><span class="comment">[j]</span>表示装入物品i时签好装满并且总价值比前i-1个物品的总价值要大</span><br><span class="line">            if (dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> != -1 &amp;&amp; dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span> &gt;= dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>)</span><br><span class="line">                dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j - w<span class="comment">[i]</span>]</span> + v<span class="comment">[i]</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = w<span class="comment">[i]</span> - 1; j &gt;= 1; j--)</span><br><span class="line">            dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp<span class="comment">[n]</span><span class="comment">[maxv]</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它大致相同，现在dp[i][j]表示的是恰好装j空间时价值的最大值</p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>题目：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    for (j = goods<span class="comment">[i]</span>.w; j &lt;= S; j++)</span><br><span class="line">        dp<span class="comment">[j]</span> = max(dp<span class="comment">[j]</span>, dp<span class="comment">[j - goods<span class="comment">[i]</span>.w]</span> + goods<span class="comment">[i]</span>.v);</span><br><span class="line">&#125;//不是很理解，但是先把模板记下吧</span><br></pre></td></tr></table></figure><p>这个代码和01背包代码十分相似，只有循环方向不同，为什么可以这样做呢？因为01背包要求每个物品只能选一次，因此根据这个式子，有可能会导致多选的就是dp[j - goods[i].w],如果从前往后循环，j-goods[i].w可能是已经选择了当前物品的情况</p><p><a href="https://pangyuworld.github.io/2019/04/03/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/#%E9%A2%98%E7%9B%AE%E7%B1%BB%E5%9E%8B-1" target="_blank" rel="noopener">可以去看</a></p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;无后效性&quot;&gt;&lt;a href=&quot;#无后效性&quot; class=&quot;headerlink&quot; title=&quot;无后效性&quot;&gt;&lt;/a&gt;无后效性&lt;/h3&gt;&lt;p&gt;无后效性是一个问题可以用动态规划求解的标志之一，理解无后效性对求解动态规划类题目非常重要&lt;/p&gt;
&lt;p&gt;概念：某阶段的状态一
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://xinhecuican.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>深度优先搜索和广度优先搜索</title>
    <link href="http://xinhecuican.github.io/2020/01/14/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    <id>http://xinhecuican.github.io/2020/01/14/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/</id>
    <published>2020-01-14T01:04:00.000Z</published>
    <updated>2020-01-14T07:38:57.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>基本思想：它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念</p><p>例<img src="/images/%E5%9B%BE%E7%89%871.png" alt=""></p><p>V0-&gt;V1-&gt;V4-&gt;V3-&gt;V5-&gt;V6,先从v0到V1，再从V1到V4，发现到了终点，就退回到V1继续寻找</p><p>代码</p><p>注意恢复初始状态十分重要，在一种情况走不了的情况下它可以使其恢复初始状态试下一条路</p><p><img src="/images/%E5%9B%BE%E7%89%872.png" alt=""></p><p>例题：<img src="/images/%E5%9B%BE%E7%89%873.png" alt=""></p><p>遍历连通图，能否从v0到v6</p><p>答案<img src="/images/%E5%9B%BE%E7%89%874.png" alt=""></p><p>说明，重要的便是模板，先判断当前情况是否满足，如果满足则退出，不满足则遍历所有情况，如果某一位置到了头便会返回false，然后返回到分叉点，搜索下一步（遍历作用在这），而最后一定要回到初始状态，因为别的搜索也可能用</p><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">广度优先搜索是最简便的图的搜索算法之一，别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中</span><br></pre></td></tr></table></figure><p>模板<br><img src="/images/%E5%9B%BE%E7%89%875.png" alt=""></p><p>说明：从某一个起始节点开始，看是否满足，如果不满足， 遍历所有可能的情况，这里便是tt，如果tt存在，那么就把它送入队列中，之后继续遍历可能情况，这里需要两个数组，一个数组是用来确定这点是否已经走过，另外一个数组是用来记录步数的。<a href="https://blog.csdn.net/freezhanacmore/article/details/8168265" target="_blank" rel="noopener">另外，有些题可能会导致数组超过范围，这时就要写一个判断条件排除掉越界的</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深度优先搜索&quot;&gt;&lt;a href=&quot;#深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索&quot;&gt;&lt;/a&gt;深度优先搜索&lt;/h3&gt;&lt;p&gt;基本思想：它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>scanf printf</title>
    <link href="http://xinhecuican.github.io/2020/01/13/scanf-printf/"/>
    <id>http://xinhecuican.github.io/2020/01/13/scanf-printf/</id>
    <published>2020-01-13T12:18:00.000Z</published>
    <updated>2020-01-13T12:45:34.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>格式：scanf(const char *format, …)</p><p>format – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。</p><p>format 说明符形式为:</p><p>[=%[*][width][modifiers]type=]</p><p><code>*</code>这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。</p><p>width    这指定了在当前读取操作中读取的最大字符数。</p><p>modifiers    为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）</p><p>type    一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格</p><p>| %a、%A|读入一个浮点值(仅 C99 有效)|float*|<br>| :——————————————-|<br>| %c     | 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。|    char *<br>|%d    |十进制整数：数字前面的 + 或 - 号是可选的。|    int *<br>|%e、%E、%f、%F、%g、%G    |浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4    |float *<br>|%i|    读入十进制，八进制，十六进制整数 。|    int *<br>|%o    |八进制整数。|    int *<br>|%s    |字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。|    char *<br>|%u    |无符号的十进制整数。|    unsigned int *</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>用%c 读数组时注意它不会读入换行符，因此每次用完之后要用getchar()<br>，而%s就不用担心这个问题</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>格式 printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p><p>声明 printf(const char *format, …)</p><p>|格式字符|    意义<br>|————————-|<br>|d|    以十进制形式输出带符号整数(正数不输出符号)<br>|o    |以八进制形式输出无符号整数(不输出前缀0)<br>|x,X    |以十六进制形式输出无符号整数(不输出前缀Ox)<br>|u    |以十进制形式输出无符号整数<br>|f|    以小数形式输出单、双精度实数<br>|e,E    |以指数形式输出单、双精度实数<br>|g,G    |以%f或%e中较短的输出宽度输出单、双精度实数<br>|c|    输出单个字符<br>|s    |输出字符串<br>|p|    输出指针地址<br>|lu    |32位无符号整数<br>|llu|    64位无符号整数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;scanf&quot;&gt;&lt;a href=&quot;#scanf&quot; class=&quot;headerlink&quot; title=&quot;scanf&quot;&gt;&lt;/a&gt;scanf&lt;/h3&gt;&lt;p&gt;格式：scanf(const char *format, …)&lt;/p&gt;
&lt;p&gt;format – 这是 C 字符串，包
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://xinhecuican.github.io/2020/01/13/%E9%98%9F%E5%88%97/"/>
    <id>http://xinhecuican.github.io/2020/01/13/%E9%98%9F%E5%88%97/</id>
    <published>2020-01-13T08:05:00.000Z</published>
    <updated>2020-01-14T06:39:20.507Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h3><p>队列是一种线性结构，有队头（front）队尾（rear）两个指针，每次拉进来一个元素会让队尾加一，而每次删除一个元素会让队头加一，这是一种先进先出的结构。</p><p>队列特殊情况判断</p><p>空队列 front=rear</p><p>满队列 rear-front=N（N指的是开的数组的大小）</p><p>POP 从队头删元素</p><p>push 拉元素到队尾</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">duilie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> front ,rear;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        front=rear=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front)==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear-front==N<span class="number">-1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(full())<span class="comment">//如果满了就不能拖进去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[++rear]=key;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>上面一种队列并不是真的有n个空间，如果pop了元素那空间就要减小，这样便浪费了许多空间，而用模运算组成一个循环可以使空间充分利用</p><p>特殊情况判断</p><p>空 ： front=rear</p><p>满 ：（ rear+1）% N=front</p><p>代码实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const <span class="built_in">int</span> Queue_Size=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">typedef <span class="keyword">struct</span> circlQueue</span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> *elem;</span><br><span class="line">       <span class="built_in">int</span> rear;</span><br><span class="line">       <span class="built_in">int</span> front;</span><br><span class="line">       <span class="built_in">int</span> queueSize;</span><br><span class="line">&#125;circlQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">void init<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem=<span class="keyword">new</span> <span class="built_in">char</span><span class="literal">[Q<span class="identifier">ueue_Size</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;<span class="comment">//首尾指针相等说明队列为空。</span></span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=Queue_Size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*销毁队列*/</span></span><br><span class="line">void destroy<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       delete <span class="literal">[]</span><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*求队列的长度*/</span></span><br><span class="line"><span class="built_in">int</span>  length<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">int</span> length;</span><br><span class="line">       length=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear-<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;<span class="comment">/*一般情况下，rear在front的上方，此种算法是用于</span></span><br><span class="line"><span class="comment">  rear已到front的下方，即已出现假溢出的情况。*/</span></span><br><span class="line">       return length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*入队列*/</span></span><br><span class="line">void enter<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q,<span class="params">char</span> <span class="params">x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span>(((<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize)==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)<span class="comment">//判断栈满的情况</span></span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue OverFlow!"</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">rear</span>]</span>=x;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%Queue_Size;<span class="comment">//尾指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="built_in">char</span> output<span class="constructor">Queue_C(<span class="params">circlQueue</span> &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">char</span> e;</span><br><span class="line">       <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear==<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front)</span><br><span class="line">              cout&lt;&lt;<span class="string">"Queue Empty"</span>;</span><br><span class="line">       e=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>elem<span class="literal">[Q.<span class="identifier">front</span>]</span>;</span><br><span class="line">       <span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="number">1</span>)%<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>queueSize;;<span class="comment">//头指针应以此种方式加1，才会实现循环队列。</span></span><br><span class="line">       return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「hackerain」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/hackerain/article/details/5934240</span></span><br></pre></td></tr></table></figure><h3 id="队列的函数"><a href="#队列的函数" class="headerlink" title="队列的函数"></a>队列的函数</h3><p>push()：脱元素到队尾</p><p>pop()删队首元素</p><p>size()</p><p>front()返回队首元素</p><p>back()返回队尾元素</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>front无法使用迭代器，因为queue在物理地址上不连续，所以queue无法遍历，想要遍历只能不停top POP，这样会销毁队列</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>HDU 1387 </li></ul><p>Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.<br>In a team queue each element belongs to a team. If an element enters the queue, it first searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.</p><p>Your task is to write a program that simulates such a team queue.</p><p>Input</p><p>The input will contain one or more test cases. Each test case begins with the number of teams t (1&lt;=t&lt;=1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0 - 999999. A team may consist of up to 1000 elements.</p><p>Finally, a list of commands follows. There are three different kinds of commands:</p><p>ENQUEUE x - enter element x into the team queue<br>DEQUEUE - process the first element and remove it from the queue<br>STOP - end of test case<br>The input will be terminated by a value of 0 for t.</p><p>Output</p><p>For each test case, first print a line saying “Scenario #k”, where k is the number of the test case. Then, for each DEQUEUE command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line"><span class="number">3</span> <span class="number">201</span> <span class="number">202</span> <span class="number">203</span></span><br><span class="line">ENQUEUE <span class="number">101</span></span><br><span class="line">ENQUEUE <span class="number">201</span></span><br><span class="line">ENQUEUE <span class="number">102</span></span><br><span class="line">ENQUEUE <span class="number">202</span></span><br><span class="line">ENQUEUE <span class="number">103</span></span><br><span class="line">ENQUEUE <span class="number">203</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">259001</span> <span class="number">259002</span> <span class="number">259003</span> <span class="number">259004</span> <span class="number">259005</span></span><br><span class="line"><span class="number">6</span> <span class="number">260001</span> <span class="number">260002</span> <span class="number">260003</span> <span class="number">260004</span> <span class="number">260005</span> <span class="number">260006</span></span><br><span class="line">ENQUEUE <span class="number">259001</span></span><br><span class="line">ENQUEUE <span class="number">260001</span></span><br><span class="line">ENQUEUE <span class="number">259002</span></span><br><span class="line">ENQUEUE <span class="number">259003</span></span><br><span class="line">ENQUEUE <span class="number">259004</span></span><br><span class="line">ENQUEUE <span class="number">259005</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">ENQUEUE <span class="number">260002</span></span><br><span class="line">ENQUEUE <span class="number">260003</span></span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">DEQUEUE</span><br><span class="line">STOP</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">1</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">201</span></span><br><span class="line"><span class="number">202</span></span><br><span class="line"><span class="number">203</span></span><br><span class="line"></span><br><span class="line">Scenario #<span class="number">2</span></span><br><span class="line"><span class="number">259001</span></span><br><span class="line"><span class="number">259002</span></span><br><span class="line"><span class="number">259003</span></span><br><span class="line"><span class="number">259004</span></span><br><span class="line"><span class="number">259005</span></span><br><span class="line"><span class="number">260001</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;队列基础&quot;&gt;&lt;a href=&quot;#队列基础&quot; class=&quot;headerlink&quot; title=&quot;队列基础&quot;&gt;&lt;/a&gt;队列基础&lt;/h3&gt;&lt;p&gt;队列是一种线性结构，有队头（front）队尾（rear）两个指针，每次拉进来一个元素会让队尾加一，而每次删除一个元素会让队头
      
    
    </summary>
    
    
      <category term="stl" scheme="http://xinhecuican.github.io/categories/stl/"/>
    
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://xinhecuican.github.io/2020/01/13/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://xinhecuican.github.io/2020/01/13/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-01-13T06:31:00.000Z</published>
    <updated>2020-01-13T07:12:13.018Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>归并排序运用了分治的思想，先将数组二分成一个元素（一个元素时看为有序），然后将这些元素不断合并，每合并一次排一次序，最后就可以得到有序的数组。</p><p>比如说一个序列:12 ,23,1,44,233,10,9,8。我们先分成两段：12 ,23,1,44 和 233,10,9,8，<br>发现还能再分成4段：12 ,23 和 1,44——233,10 和 9,8。<br>再分成8段：12–23–1–44 和233–10–9–8。<br>这时候开始把子序列进行排序合并，一个元素就是有序的。所以不用排序。<br>合并成2个一组排序得到：12，23—-1，44—10，233—8，9。<br>再合并成4个一组排序得到：1，12，23，44—8，9，10，233。<br>最后合并得到最终结果：1，8，9，10，12，23，44，233。</p><p>合并过程看代码</p><p>链接：<a href="https://www.jianshu.com/p/b50a6034eb90" target="_blank" rel="noopener">https://www.jianshu.com/p/b50a6034eb90</a></p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/images/1024555-20161218163120151-452283750.png" alt=""></p><p>这个图片蓝色部分就是拆的过程，而绿的部分为并的过程</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paixu</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> mid,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span><span class="comment">//这是合并过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1=first,l2=mid+<span class="number">1</span>,r1=mid,r2=last;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1&amp;&amp;l2&lt;=r2)<span class="comment">//两部分都存在时看哪个小就加上哪个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[l1]&lt;=a[l2])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=a[l2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1&lt;=r1)<span class="comment">//第一部分有剩余就把第一部分剩下的全加上</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2&lt;=r2)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=a[l2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i+first]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xunhuan</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> a[],<span class="keyword">int</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(first+last)/<span class="number">2</span>;</span><br><span class="line">        xunhuan(first,mid,a,temp);<span class="comment">//拆左边</span></span><br><span class="line">        xunhuan(mid+<span class="number">1</span>,last,a,temp);<span class="comment">//拆右边</span></span><br><span class="line">        paixu(first,mid,last,a,temp);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[last-first];<span class="comment">//建一个临时数组，合并时用</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="comment">//判断是否传入空数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xunhuan(first,last,a,p);</span><br><span class="line">    <span class="keyword">delete</span> [] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h4&gt;&lt;p&gt;归并排序运用了分治的思想，先将数组二分成一个元素（一个元素时看为有序），然后将这些元素不断合并，每合并一次排一次序，最后就可
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://xinhecuican.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>前缀和</title>
    <link href="http://xinhecuican.github.io/2020/01/13/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>http://xinhecuican.github.io/2020/01/13/%E5%89%8D%E7%BC%80%E5%92%8C/</id>
    <published>2020-01-13T01:16:00.000Z</published>
    <updated>2020-01-13T02:08:35.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前缀和概念"><a href="#前缀和概念" class="headerlink" title="前缀和概念"></a>前缀和概念</h3><p>前缀和指的是用另一个数组b[n]来保存a[n]中前n项的和</p><p>例如，b[0]=a[0],b[1]=a[0]+a[1],…</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="求数组某一区间长度数字的和"><a href="#求数组某一区间长度数字的和" class="headerlink" title="求数组某一区间长度数字的和"></a>求数组某一区间长度数字的和</h4><p>如果我给你一串长度为n的数列a1,a2,a3……an,再给出m个询问，每次询问给出L，R两个数，要求给出区间[L,R]里的数的和，一般可能是从L到R遍历一次，但这样很花时间，有了前缀和之后可以直接b[R]-b[L]就得到L到R的和</p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分就是将数列中的每一项分别与前一项数做差</p><p>一个序列1 2 5 4 7 3，差分后得到1 1 3 -1 3 -4 -3</p><p>这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0）<br>差分序列最后比原序列多一个数（相当于0减最后一个数）</p><p>例 给你一串长度为n的数列a1,a2,a3……an，要求对a[L]~a[R]进行m次操作：</p><p>操作一：将a[L]~a[R]内的元素都加上P</p><p>操作二：将a[L]~a[R]内的元素都减去P</p><p>最后再给出一个询问求a[L]-a[R]内的元素之和？</p><p>如果用一般做法就是遍历加减，时间复杂度高，现在可以直接让b[L] 加上P，再让b[R+1]减去P，这样因为b[L+1]=b[L]+a[L+1]，所以L到R上每一项都会加P，而b[R+1]减去P是为了对后面的数不产生影响</p><p>如果有多次修改操作，可以先将每次修改保存到一个数组中，然后求前缀和时再加上<br>    #include&lt;bits/stdc++.h&gt;<br>    using namespace std;<br>    const int maxn=1e5+9;<br>    int a[maxn],b[maxn];<br>    int main(){<br>     int i,j,k,n,m,p;<br>     cin&gt;&gt;n&gt;&gt;m;<br>     for(i=1;i&lt;=n;i++){<br>        cin&gt;&gt;a[i];<br>     }<br>     for(i=1;i&lt;=m;i++){<br>        int L,R,t;<br>        cin&gt;&gt;t&gt;&gt;L&gt;&gt;R&gt;&gt;p;<br>        if(t==1){<br>            b[L]+=p;b[R+1]-=p; //仔细想想为什么b[R+1]要减去p<br>        }<br>        else{<br>            b[L]-=p;b[R+1]+=p;//这是减去p<br>        }<br>    }<br>    int add=0;<br>    for(i=1;i&lt;=n;i++){<br>        add+=b[i];<br>        a[i]+=a[i-1]+add;//这是求前缀和数组，并且add是把需要加p的地方加上<br>    }<br>    int x,y;<br>    cin&gt;&gt;x&gt;&gt;y;<br>    cout&lt;&lt;a[y]-a[x-1]&lt;&lt;endl;<br>}</p><h4 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4><p>1、差分序列求前缀和可得原序列</p><p>2、将原序列区间[L,R]中的元素全部+1，可以转化操作为差分序列L处+1，R+1处-1</p><p>3、按照性质2得到，每次修改原序列一个区间+1，那么每次差分序列修改处增加的和减少的相同</p><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>二维前缀和对应的是二维数组</p><p><img src="/images/20180817161822690.png" alt=""></p><p>b[2][4]表示的是b[1][1]+b[1][2]+b[1][3]+b[1][4]+b[2][1]+b[2][2]+b[2][3]</p><p>因此可以先加上b[1][4]+b[2][3]，这时重复了b[1][3]，再减去</p><p>因此公式<br>a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1]，因为这样，二维前缀和最好从一开始，0处全赋值为0</p><p>这时想知道从(x1,y1)到(x2,y2)的和要a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]</p><p>例如，求(3,3)到(4,4)的值，实际上是a[3][3]+a[3][4]+a[4][3]+a[4][4]</p><h3 id="二维差分（不是很清楚）"><a href="#二维差分（不是很清楚）" class="headerlink" title="二维差分（不是很清楚）"></a>二维差分（不是很清楚）</h3><p>和一维差分的第四个问题类似，让（x1,y1)和（x2,y2）矩形内的数都加上x</p><p>b[x1][y1]+=x; b[x2+1][y2+1]+=x;</p><p>b[x1][y2+1]-=x; b[x2+1][y1]-=x;</p><p> 参考博客<a href="https://blog.csdn.net/k_r_forever/article/details/81775899" target="_blank" rel="noopener">https://blog.csdn.net/k_r_forever/article/details/81775899</a></p><p> <a href="https://blog.csdn.net/Healer66/article/details/87201014" target="_blank" rel="noopener">https://blog.csdn.net/Healer66/article/details/87201014</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前缀和概念&quot;&gt;&lt;a href=&quot;#前缀和概念&quot; class=&quot;headerlink&quot; title=&quot;前缀和概念&quot;&gt;&lt;/a&gt;前缀和概念&lt;/h3&gt;&lt;p&gt;前缀和指的是用另一个数组b[n]来保存a[n]中前n项的和&lt;/p&gt;
&lt;p&gt;例如，b[0]=a[0],b[1]=a[0
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>结构体</title>
    <link href="http://xinhecuican.github.io/2020/01/12/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://xinhecuican.github.io/2020/01/12/%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2020-01-12T03:55:00.000Z</published>
    <updated>2020-01-12T04:06:14.247Z</updated>
    
    <content type="html"><![CDATA[<p>在c++中，结构体与类类似，都有个体域和成员函数，不同是class中默认的成员访问权限是private的，而struct中则是public的。 (2)class继承默认是private继承，而从struct继承默认是public继承。</p><p>定义：</p><pre><code> struct tag {  member-list}variable-list;</code></pre><p>注：struct为结构体关键字；<br>   tag为结构体的标志；<br>   member-list为结构体成员变量及成员函数列表，其必须列出其所有成员；<br>   variable-list为此结构体声明的变量；</p><p>tag相当于class中的类名，而variable-list相当于class中创建的对象</p><p>另外，如果想多创建几个对象，只需要<code>tag 变量名</code>即可</p><p>在c++中，可以直接用<code>variable-list+变量名</code>创建对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在c++中，结构体与类类似，都有个体域和成员函数，不同是class中默认的成员访问权限是private的，而struct中则是public的。 (2)class继承默认是private继承，而从struct继承默认是public继承。&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;pre
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>memset</title>
    <link href="http://xinhecuican.github.io/2020/01/11/memset/"/>
    <id>http://xinhecuican.github.io/2020/01/11/memset/</id>
    <published>2020-01-11T10:52:00.000Z</published>
    <updated>2020-01-11T10:54:16.063Z</updated>
    
    <content type="html"><![CDATA[<p>memset(标识符，填充数据,大小)</p><p>memset是一个字节一个字节填充的，所以一般只能填充0或-1因为这个一个字节和四个字节相同</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;memset(标识符，填充数据,大小)&lt;/p&gt;
&lt;p&gt;memset是一个字节一个字节填充的，所以一般只能填充0或-1因为这个一个字节和四个字节相同&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>快速输入</title>
    <link href="http://xinhecuican.github.io/2020/01/11/%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5/"/>
    <id>http://xinhecuican.github.io/2020/01/11/%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5/</id>
    <published>2020-01-11T10:47:00.000Z</published>
    <updated>2020-01-11T10:51:31.455Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="attribute">x</span>=0,f=1;</span><br><span class="line">    char <span class="attribute">ch</span>=getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span> (<span class="attribute">ch</span>=='-') <span class="attribute">f</span>=-1;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;<span class="attribute">x</span>=x*10+ch-'0';ch=getchar();&#125;</span><br><span class="line">    return x<span class="number">*f</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个快速输入只适合int类型，另外如果参加比赛，最好不要用cin，cout，速度较慢<br>用scanf，printf更好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>qsort</title>
    <link href="http://xinhecuican.github.io/2020/01/11/qsort/"/>
    <id>http://xinhecuican.github.io/2020/01/11/qsort/</id>
    <published>2020-01-11T10:46:00.000Z</published>
    <updated>2020-01-11T10:47:30.678Z</updated>
    
    <content type="html"><![CDATA[<p>自带的快排函数</p><p>qsortvoid qsort(void <em>base, size_t nitems, size_t size, int (*compar)(const void *, const void</em>))</p><p>参数</p><p>base– 指向要排序的数组的第一个元素的指针。<br>nitems– 由 base 指向的数组中元素的个数。<br>size– 数组中每个元素的大小，以字节为单位。<br>compar– 用来比较两个元素的函数，即函数指针（回调函数）</p><p>回调函数：</p><p>回调函数就是一个通过函数指针调用的函数。如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。 [2]<br>compar参数<br>compar参数指向一个比较两个元素的函数。比较函数的原型应该像下面这样。注意两个形参必须是const void *型，同时在调用compar 函数（compar实质为函数指针，这里称它所指向的函数也为compar）时，传入的实参也必须转换成const void *型。在compar函数内部会将const void *型转换成实际类型。<br>int compar(const void *p1, const void *p2);</p><p>如果compar返回值小于0（&lt; 0），那么p1所指向元素会被排在p2所指向元素的左面；<br>　　如果compar返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定；<br>　　如果compar返回值大于0（&gt; 0），那么p1所指向元素会被排在p2所指向元素的右面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自带的快排函数&lt;/p&gt;
&lt;p&gt;qsortvoid qsort(void &lt;em&gt;base, size_t nitems, size_t size, int (*compar)(const void *, const void&lt;/em&gt;))&lt;/p&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="stl" scheme="http://xinhecuican.github.io/categories/stl/"/>
    
    
  </entry>
  
  <entry>
    <title>pair</title>
    <link href="http://xinhecuican.github.io/2020/01/11/pair/"/>
    <id>http://xinhecuican.github.io/2020/01/11/pair/</id>
    <published>2020-01-11T10:28:00.000Z</published>
    <updated>2020-01-11T10:39:01.783Z</updated>
    
    <content type="html"><![CDATA[<p>pair实际上是一个结构体，它可以把两种类型结合起来使用,定义在<code>&lt;utility&gt;</code>中</p><p>定义：pair&lt;类型A,类型B&gt; 标识符</p><p>操作 pa.first 表示类型A pa.second 表示类型B</p><p>注意不能用-> 操作符，虽然我也不知道为什么]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;pair实际上是一个结构体，它可以把两种类型结合起来使用,定义在&lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;定义：pair&amp;lt;类型A,类型B&amp;gt; 标识符&lt;/p&gt;
&lt;p&gt;操作 pa.first 表示类型A pa.second 表示类型B&lt;
      
    
    </summary>
    
    
      <category term="stl" scheme="http://xinhecuican.github.io/categories/stl/"/>
    
    
  </entry>
  
  <entry>
    <title>迭代器支持的运算</title>
    <link href="http://xinhecuican.github.io/2020/01/11/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97/"/>
    <id>http://xinhecuican.github.io/2020/01/11/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97/</id>
    <published>2020-01-11T10:12:00.000Z</published>
    <updated>2020-01-11T10:13:03.292Z</updated>
    
    <content type="html"><![CDATA[<p>之前写搜狗在线测试题目的时候，曾经想遍历一个set遍历。当时是这样写的。</p><p>set<int>::iterator b = a.begin()+1</p><p>后来发现程序报错。究其原因是，set迭代器不支持加减数操作。<br>查看了一下维基百科，下面是有关说明。</p><p>1.所有迭代器都应该实现自增算符：iter++,++iter</p><p>2.Bidirectional迭代器：是在前向迭代器的基础上，多了单步向后遍历的能力。也就是–iter,iter–。</p><p>3.Random Access迭代器：在双向迭代器基础上，具有直接访问各数据元素的能力。随机迭代器增加了“迭代器算术运算”：</p><p>iter+=i 迭代器递增i位</p><p>iter-=i 迭代器递减i位</p><p>iter+i 加i位后的迭代器</p><p>iter-i 减i位后的迭代器</p><p>iter[i] 加i位后的迭代器的解引用</p><p>iter&lt;iter1 如果迭代器iter的位置在iter1前，返回true，否则返回false</p><p>iter&lt;=iter1 如果iter的位置在iter1的前面或同一位置时返回true，否则返回false</p><p>iter&gt;iter1 如果迭代器iter的位置在iter1后，返回true，否则返回false</p><p>iter&gt;=iter1 如果iter的位置在iter1的后面或同一位置时返回true，否则返回false</p><p>4.在STL定义的容器中，string，vector与deque提供了随机访问迭代器，list、set、multiset、map、multimap提供了双向迭代器。</p><p>————————————————</p><p>版权声明：本文为CSDN博主「ShenYounger」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wusecaiyun/article/details/49563197" target="_blank" rel="noopener">https://blog.csdn.net/wusecaiyun/article/details/49563197</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写搜狗在线测试题目的时候，曾经想遍历一个set遍历。当时是这样写的。&lt;/p&gt;
&lt;p&gt;set&lt;int&gt;::iterator b = a.begin()+1&lt;/p&gt;
&lt;p&gt;后来发现程序报错。究其原因是，set迭代器不支持加减数操作。&lt;br&gt;查看了一下维基百科，下面是有关说明
      
    
    </summary>
    
    
      <category term="stl" scheme="http://xinhecuican.github.io/categories/stl/"/>
    
    
  </entry>
  
  <entry>
    <title>vector</title>
    <link href="http://xinhecuican.github.io/2020/01/11/vector/"/>
    <id>http://xinhecuican.github.io/2020/01/11/vector/</id>
    <published>2020-01-11T08:21:00.000Z</published>
    <updated>2020-01-11T09:49:59.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h3><p>vector&lt;数据类型&gt; 标识符</p><h3 id="vector的函数"><a href="#vector的函数" class="headerlink" title="vector的函数"></a>vector的函数</h3><p>begin()返回开头元素的迭代器</p><p>end()同理</p><p>front() 返回开头元素的引用</p><p>back() 返回末尾元素的引用</p><p>size()返回vector内元素的数量</p><p>erase(迭代器) 删除一个元素</p><p>clear() 清空</p><p>insert(迭代器，a) 把a插入迭代器后</p><p><strong>例</strong>vector中现在有1 2 3 三个元素，vec.insert(vec.begin()+2,4)得到1 2 4 3</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>reverse(vec.begin(),vec.end()) <strong>(头文件<code>&lt;algorithm&gt;</code>)</strong></p><p>实际上不一定是begin到end，也可以begin()+1到、、、，只需要用迭代器就行了<p>sort排序，也要用<code>&lt;algorithm&gt;</code>默认升序</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> <span class="constructor">Comp(<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">a</span>,<span class="params">const</span> <span class="params">int</span> &amp;<span class="params">b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><pre><code>vector&lt;vector&lt;数据类型&gt; &gt; vec[3];//3行vector&lt;数据类型&gt; veci;for(int i=0;i&lt;3;i++){   for(int k=0;k&lt;4;k++)   {      veci.push_back();   }   vec.push_back(veci);}//四列</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vector的定义&quot;&gt;&lt;a href=&quot;#vector的定义&quot; class=&quot;headerlink&quot; title=&quot;vector的定义&quot;&gt;&lt;/a&gt;vector的定义&lt;/h3&gt;&lt;p&gt;vector&amp;lt;数据类型&amp;gt; 标识符&lt;/p&gt;
&lt;h3 id=&quot;vector的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>prioity_queue</title>
    <link href="http://xinhecuican.github.io/2020/01/11/prioity-queue/"/>
    <id>http://xinhecuican.github.io/2020/01/11/prioity-queue/</id>
    <published>2020-01-11T08:13:00.000Z</published>
    <updated>2020-01-11T08:18:01.763Z</updated>
    
    <content type="html"><![CDATA[<h3 id="prioity-queue"><a href="#prioity-queue" class="headerlink" title="prioity_queue"></a>prioity_queue</h3><p>实际上是一个大顶堆，定义在<code>&lt;queue&gt;</code>中</p><p><code>prioity_queue&lt;int&gt; qu</code>为大顶堆</p><p><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qu;</code>为小顶堆</p><p>.push()</p><p>.pop()取出元素，但不返回值</p><p>.top()不取出元素，返回值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;prioity-queue&quot;&gt;&lt;a href=&quot;#prioity-queue&quot; class=&quot;headerlink&quot; title=&quot;prioity_queue&quot;&gt;&lt;/a&gt;prioity_queue&lt;/h3&gt;&lt;p&gt;实际上是一个大顶堆，定义在&lt;code&gt;&amp;lt;que
      
    
    </summary>
    
    
      <category term="stl" scheme="http://xinhecuican.github.io/categories/stl/"/>
    
    
  </entry>
  
</feed>
