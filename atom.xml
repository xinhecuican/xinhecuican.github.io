<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-01-07T11:08:14.084Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&amp;&amp;与||小提示</title>
    <link href="http://xinhecuican.github.io/2020/01/07/%E4%B8%8E-%E5%B0%8F%E6%8F%90%E7%A4%BA/"/>
    <id>http://xinhecuican.github.io/2020/01/07/%E4%B8%8E-%E5%B0%8F%E6%8F%90%E7%A4%BA/</id>
    <published>2020-01-07T11:05:00.000Z</published>
    <updated>2020-01-07T11:08:14.084Z</updated>
    
    <content type="html"><![CDATA[<h4 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h4><p>&amp;&amp;运算符从左自由依次判断 ，如果判断有一个为假则停止判断</p><h4 id=""><a href="#" class="headerlink" title="||"></a>||</h4><p>同理如果判断有一个为真则停止判断</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int a=0,b=1,c;    c = (a != b) || (++a == b++);    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;    return 0;}</code></pre><p>输出为0 1因为前面一个为真，直接退出判断</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;amp-amp&quot;&gt;&lt;a href=&quot;#amp-amp&quot; class=&quot;headerlink&quot; title=&quot;&amp;amp;&amp;amp;&quot;&gt;&lt;/a&gt;&amp;amp;&amp;amp;&lt;/h4&gt;&lt;p&gt;&amp;amp;&amp;amp;运算符从左自由依次判断 ，如果判断有一个为假则停止判断&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>字符数组</title>
    <link href="http://xinhecuican.github.io/2020/01/07/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84/"/>
    <id>http://xinhecuican.github.io/2020/01/07/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84/</id>
    <published>2020-01-07T10:23:00.000Z</published>
    <updated>2020-01-07T10:35:51.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前方高能"><a href="#前方高能" class="headerlink" title="前方高能"></a>前方高能</h3><pre><code>char a[4]={&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;};cout&lt;&lt;a&lt;&lt;endl;</code></pre><p>这将输出什么呢，是<code>abcd</code>，实际上是<code>abcdPpB</code></p><p>这就有点神奇</p><h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>char +标识符+[]，注意字符数组的最后一定会有’\0’，</p><p>例如<code>char[]=&quot;abcd&quot;,这就是一个合法的赋值，但是char[4]=&quot;abcd&quot;是不合法的因为带双引号的为字符串，赋值给字符数组时编译器会自动加上&#39;\0&#39;这时需要5个空间</code></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为本来是要加上’\0’的，但是这时位子不够了，编译器只好帮它扩扩容，也就是说这是字符数组（其实现在已经不是字符数组了）长度已经不是4了，编译器会为后面几个位子附上值（不是随机的，我也有点不清楚，这样解释先），因此后面会多输出一些。但是如果开始就把长度设为5，这时’\0’就有位子放了，也就不会多出后面那些奇奇怪怪的字符</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前方高能&quot;&gt;&lt;a href=&quot;#前方高能&quot; class=&quot;headerlink&quot; title=&quot;前方高能&quot;&gt;&lt;/a&gt;前方高能&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;char a[4]={&amp;apos;a&amp;apos;,&amp;apos;b&amp;apos;,&amp;apos;c&amp;apos;,&amp;
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>next主题出现404的一个解决方法</title>
    <link href="http://xinhecuican.github.io/2020/01/07/next%E4%B8%BB%E9%A2%98%E5%87%BA%E7%8E%B0404%E7%9A%84%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://xinhecuican.github.io/2020/01/07/next%E4%B8%BB%E9%A2%98%E5%87%BA%E7%8E%B0404%E7%9A%84%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2020-01-07T09:08:00.000Z</published>
    <updated>2020-01-07T10:24:10.881Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>主题配置文件中</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">home:</span> /|| home</span><br><span class="line"></span><br><span class="line"><span class="symbol">about:</span> <span class="meta-keyword">/about/</span>|| user</span><br><span class="line"></span><br><span class="line"><span class="symbol">tags:</span> <span class="meta-keyword">/tags/</span>|| tags</span><br><span class="line"></span><br><span class="line"><span class="symbol">categories:</span> <span class="meta-keyword">/categories/</span>|| th</span><br><span class="line"></span><br><span class="line"><span class="symbol">archives:</span> <span class="meta-keyword">/archives/</span>|| archive</span><br><span class="line"></span><br><span class="line"><span class="meta">#schedule: /schedule/|| calendar</span></span><br><span class="line"><span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">#commonweal: /404/|| heartbeat</span></span><br></pre></td></tr></table></figure>  <p>注意/||，原来是/ ||，不要中间那个空格，亲测有效]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;code&gt;主题配置文件中&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="next" scheme="http://xinhecuican.github.io/categories/next/"/>
    
    
  </entry>
  
  <entry>
    <title>文件输入输出</title>
    <link href="http://xinhecuican.github.io/2020/01/07/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://xinhecuican.github.io/2020/01/07/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2020-01-07T08:57:00.000Z</published>
    <updated>2020-01-07T09:08:09.935Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文件输入in"><a href="#文件输入in" class="headerlink" title="文件输入in"></a>文件输入in</h4><p>文件输入指的是从文件_输入_给程序，对应的有in，get，read，seekg等<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seekg和seekp中有三个定位基址，分别是cur（当前）beg（开始），end（末尾）&lt;p&gt;</span><br><span class="line">例如 seekg（<span class="number">100</span>，ios：：beg）；seekg（<span class="number">2</span>*sizeof(Student)) student是一个类</span><br></pre></td></tr></table></figure><h4 id="文件输出out"><a href="#文件输出out" class="headerlink" title="文件输出out"></a>文件输出out</h4><p>文件输出指的是从程序<code>输出</code>给文件，对应的有out，put，write，seekp等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;文件输入in&quot;&gt;&lt;a href=&quot;#文件输入in&quot; class=&quot;headerlink&quot; title=&quot;文件输入in&quot;&gt;&lt;/a&gt;文件输入in&lt;/h4&gt;&lt;p&gt;文件输入指的是从文件_输入_给程序，对应的有in，get，read，seekg等

&lt;figure clas
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://xinhecuican.github.io/2020/01/07/hello-world/"/>
    <id>http://xinhecuican.github.io/2020/01/07/hello-world/</id>
    <published>2020-01-07T06:15:46.000Z</published>
    <updated>2020-01-07T06:15:48.667Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二分搜索</title>
    <link href="http://xinhecuican.github.io/2020/01/07/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    <id>http://xinhecuican.github.io/2020/01/07/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</id>
    <published>2020-01-07T05:50:00.000Z</published>
    <updated>2020-01-07T11:08:35.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="（主要是怕自己忘记了）"><a href="#（主要是怕自己忘记了）" class="headerlink" title="（主要是怕自己忘记了）"></a>（主要是怕自己忘记了）<p></h1><p>  一个要点，用二分时要先排序<p></p><pre><code>int erfen(int arr[],int key,int n)    {        int low=0,high=n-1;        while(low&lt;=high)        {            int mid=(low+high)/2;            if(arr[mid]&lt;key)            {                low=mid+1;            }            if(arr[mid]==key)            {                return mid;            }            if(arr[mid]&gt;key)            {                high=mid-1;            }        }        return -mid-1;     }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;（主要是怕自己忘记了）&quot;&gt;&lt;a href=&quot;#（主要是怕自己忘记了）&quot; class=&quot;headerlink&quot; title=&quot;（主要是怕自己忘记了）&quot;&gt;&lt;/a&gt;（主要是怕自己忘记了）&lt;p&gt;&lt;/h1&gt;&lt;p&gt;  一个要点，用二分时要先排序&lt;p&gt;&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>合法的字符常量</title>
    <link href="http://xinhecuican.github.io/2020/01/07/%E5%90%88%E6%B3%95%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F/"/>
    <id>http://xinhecuican.github.io/2020/01/07/%E5%90%88%E6%B3%95%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F/</id>
    <published>2020-01-07T00:44:00.000Z</published>
    <updated>2020-01-07T05:49:50.419Z</updated>
    
    <content type="html"><![CDATA[<p>用英文单引号括起来的一个字符，例如’a’,’ ‘等等。空格也是一个字符常量</p><p>注意<p>  1.转义字符也属于字符常量，例如'\t','\n'等，但是'\97'不算]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用英文单引号括起来的一个字符，例如’a’,’ ‘等等。空格也是一个字符常量&lt;/p&gt;
&lt;p&gt;注意&lt;p&gt;
  1.转义字符也属于字符常量，例如&#39;\t&#39;,&#39;\n&#39;等，但是&#39;\97&#39;不算
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="字符常量" scheme="http://xinhecuican.github.io/tags/%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://xinhecuican.github.io/2020/01/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://xinhecuican.github.io/2020/01/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-01-05T05:42:00.000Z</published>
    <updated>2020-01-07T07:15:00.460Z</updated>
    
    <content type="html"><![CDATA[<p>步骤：<br>1.先从数列中取出一个数作为基准数。</p><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p><p>3．再对左右区间重复第二步，直到各区间只有一个数。</p><p>例 6 1 2 7 9 3 4 5 10 8 进行排序<p><br> 1 以6为基准数，先从右边找比6小的数，我们用一个变量j一步步向左移动，好在移动三次后我<br> 们找到了5，j为7。现在再让另一个变量i向右移动去找比6大的数，当i为3时找到了7.现在再让5<br> 和7互换，得到了6 1 2 5 9 3 4 7 10 8,。在让j向左移动，找到了4，i向右找到了9，再让两个数<br> 互换，j再向左到3，此时i向左也到3，两者相遇，便让3和6互换，第一次结束<br> （想想原因）<p><br> 2 现在分为两部分，左边全比6小，右边全比6大，为3 1 2 5 4 6 9 7 10 8<br> 再在3 1 2 5 4 中用同样的方法搜索一次得到2 1 3 5 4,再在2 1 中搜索得到1 2<br> 然后在5 4 中搜索得到4 5，左边排序完成，右边用同样的方法排序就可得到答案</p><p> 不说了，上代码</p><pre><code>void sort(int a[],int l,int r){  if(l&lt;r)//l大于等于r时这一段排序结束  {      int i=l,j=r,x=a[l];      while(i&lt;j)      {          while(i&lt;j&amp;&amp;a[j]&gt;=x)          {              j--;          }          while(i&lt;j&amp;&amp;a[i]&lt;x)          {              i++;          }          swap(a[i],a[j]);      }      swap(a[l],a[i]);      sort(s,l,i-1);      sort(s,i+1,r); }</code></pre><p>  }<br>  引用 转载请标明出处，原文地址：<a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="noopener">http://blog.csdn.net/morewindows/article/details/6684558</a><br>         csdn 我见过最通俗易懂的快速排序过程讲解，转自《坐在马桶上看算法：快速排序》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;步骤：&lt;br&gt;1.先从数列中取出一个数作为基准数。&lt;/p&gt;
&lt;p&gt;2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。&lt;/p&gt;
&lt;p&gt;3．再对左右区间重复第二步，直到各区间只有一个数。&lt;/p&gt;
&lt;p&gt;例 6 1 2 7 9 3 4 5 10 8 进
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="快排" scheme="http://xinhecuican.github.io/tags/%E5%BF%AB%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划背包问题</title>
    <link href="http://xinhecuican.github.io/2020/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://xinhecuican.github.io/2020/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2020-01-04T14:00:00.000Z</published>
    <updated>2020-01-07T11:09:11.646Z</updated>
    
    <content type="html"><![CDATA[<p>有几个重量和价值分别为Wi和Vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和最大的值。</p><p>dp[i+1][j]:=从前i个物品中挑选出总重量不超过j的物品时，总价值的最大值<br>w[i]表示第i个物体的重量，v[i]表示第i个物体的价值<br>d[0][j]=0;<br>dp[i+1][j]={  dp[i][j],(j&lt;w[i])<br>              max(dp[i][j],dp[i][j−w[i]]+v[i])<br>        注解：这个函数中max(dp[i][j],dp[i][j−w[i]]+v[i])表示不动用w（i)的空间与动用w（i)的空间在加上v[i]的价值哪个更好</p><p>在w比较大的情况下用这种比较好<br>dp[i+1][j]:=前i个物品中挑选出价值总和为j时总重量最小值（不存在时就是INF）</p><p>分析：</p><p>由于前0个物品没有重量，所以：<br>dp[0][j]=INFdp[0][0]=0dp[0][j] = INF \ dp[0][0] = 0<br>dp[0][j]=INF<br>dp[0][0]=0</p><p>和前文同理可得递推关系式：</p><p>dp[0][0]=0dp[0][j]=INF,j!=0dp[i+1][j]={min(dp[i][j],dp[i+1][j−v[i]]+w[i]),j&gt;=v[i]dp[i][j],j&lt;v[i]\begin{aligned} &amp;dp[0][0] = 0 \&amp;dp[0][j] = INF , j != 0 \&amp;dp[i+1][j] = \left { \begin{aligned} &amp; min( dp[i][j], dp[i+1][j-v[i]] +w[i] ) , \qquad j&gt;=v[i]\ &amp; dp[i][j] ,\qquad j&lt;v[i] \end{aligned} \right.\end{aligned}<br>​    </p><p>dp[0][0]=0<br>dp[0][j]=INF,j!=0<br>dp[i+1][j]={<br>​    </p><p>min(dp[i][j],dp[i+1][j−v[i]]+w[i]),j&gt;=v[i]<br>dp[i][j],j&lt;v[i]</p><p>后一种代码</p><pre><code>int dp[MAX_N+1][MAX_N * MAX_V+1]; //能够容纳的最大价值MAX_N * MAX_Vint solve(){fill(dp[0],dp[0]+MAX_N * MAX_V +1 , INF);dp[0][0] = 0;for(int i =0; i&lt; n ; i++){    for(int j =0; j&lt;= MAX_N*MAX_V; j++){        if(j &lt; v[i]){            dp[i+1][j] = dp[i][j];        else{            dp[i+1][j] = dp[i+1][j-v[i]] +w[i];        }    }}// 在最后一行找到dp[n][j]&lt;=W 时的jres = 0;for(int i = 0; i&lt;= MAX_N*MAX_V;i++)     if(dp[n][i] &gt; W){         res =i-1;         break;    }return res;</code></pre><p>}<br>————————————————<br>版权声明：本文为CSDN博主「wyc-」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_28120673/article/details/81037700" target="_blank" rel="noopener">https://blog.csdn.net/qq_28120673/article/details/81037700</a></p><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有几个重量和价值分别为Wi和Vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和最大的值。&lt;/p&gt;
&lt;p&gt;dp[i+1][j]:=从前i个物品中挑选出总重量不超过j的物品时，总价值的最大值&lt;br&gt;w[i]表示第i个物体的重量，v[i]表示第i个物体的
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://xinhecuican.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>线性筛</title>
    <link href="http://xinhecuican.github.io/2020/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    <id>http://xinhecuican.github.io/2020/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B/</id>
    <published>2020-01-04T04:21:00.000Z</published>
    <updated>2020-01-07T11:09:26.517Z</updated>
    
    <content type="html"><![CDATA[<p>埃氏筛中有重复，例如6,2与3都筛了一次，效率低<br>线性筛定理，（口语不准确）一个数i乘以小于等于它的最小素因数的素数所得到的合数之间没有重复</p><pre><code>#define N 10000int flag[N+1],prime[N+1],pnum;/*flag[n] 表示n是否是素数，1是素数，0不是prime   中是所有的素数按从小到大排列、pnum  表示素数的个数*/void CreatePrime(){    pnum=0;//初始化没有素数    //先将所有数看做素数，然后开始筛选    for(int i=0; i&lt;=N; i++){        flag[i]=1;    }    //遍历筛去所有最大因数是i的合数    for(int i=2; i&lt;=N; i++){        if(flag[i]==1){        //把素数记录下来            p[pnum++]=i;        }        //遍历已知素数表中比i的最小素因数小的素数，并筛去合数        for(int j=0; j&lt;pnum &amp;&amp; p[j]*i&lt;=N; j++){        //筛去合数            flag[p[j]*i]=0;            if(i%p[j]==0)            //找到i的最小素因数，找到了就终止                break;        }    }</code></pre><p>————————————————<br>版权声明：本文为CSDN博主「太上绝情」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/bjrxyz/article/details/8125913" target="_blank" rel="noopener">https://blog.csdn.net/bjrxyz/article/details/8125913</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;埃氏筛中有重复，例如6,2与3都筛了一次，效率低&lt;br&gt;线性筛定理，（口语不准确）一个数i乘以小于等于它的最小素因数的素数所得到的合数之间没有重复&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define N 10000
int flag[N+1],prime[N+1],pnum;
/
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>埃氏筛</title>
    <link href="http://xinhecuican.github.io/2020/01/04/%E5%9F%83%E6%B0%8F%E7%AD%9B/"/>
    <id>http://xinhecuican.github.io/2020/01/04/%E5%9F%83%E6%B0%8F%E7%AD%9B/</id>
    <published>2020-01-04T03:52:00.000Z</published>
    <updated>2020-01-07T11:09:40.219Z</updated>
    
    <content type="html"><![CDATA[<p>在筛质数时，我们会发现，筛去2后，2的倍数4、6、8等一定不是素数;筛去3后，3的倍数6、9、12等一定不是倍数。简单模拟这个过程如下</p><pre><code>const int MAXN = 1000000；  void Prime()  {      for (int i=0; i&lt;MAXN; i++) prime[i]=1;  //先把每个数都定义为质数    prime[0]=prime[1]=0;      for (int i=2; i&lt;MAXN; i++)      {          if (!prime[i]) continue;          for (int j=i*2; j&lt;MAXN; j+=i) prime[j] = 0;  //将i的倍数标记为合数    }  }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在筛质数时，我们会发现，筛去2后，2的倍数4、6、8等一定不是素数;筛去3后，3的倍数6、9、12等一定不是倍数。简单模拟这个过程如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int MAXN = 1000000；  
void Prime()  
{  
    for
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>set</title>
    <link href="http://xinhecuican.github.io/2020/01/03/set/"/>
    <id>http://xinhecuican.github.io/2020/01/03/set/</id>
    <published>2020-01-03T09:59:00.000Z</published>
    <updated>2020-01-07T11:10:00.246Z</updated>
    
    <content type="html"><![CDATA[<p>如何判断set是否成功插入</p><pre><code>typedef pair&lt;iterator, bool&gt; _Pairib;pair&lt;set&lt;Student,FuncStudent&gt;::iterator,bool&gt; pair1=set1.insert(s1);if(pair1.second==true){    cout&lt;&lt;&quot;插入s1成功&quot;&lt;&lt;endl;}else{    cout&lt;&lt;&quot;插入s1失败&quot;&lt;&lt;endl;}</code></pre><p>————————————————<br>版权声明：本文为CSDN博主「阳光下的Smiles」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/liyuqian199695/article/details/49100543" target="_blank" rel="noopener">https://blog.csdn.net/liyuqian199695/article/details/49100543</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何判断set是否成功插入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef pair&amp;lt;iterator, bool&amp;gt; _Pairib;
pair&amp;lt;set&amp;lt;Student,FuncStudent&amp;gt;::iterator,bool&amp;gt; pair1=
      
    
    </summary>
    
    
      <category term="stl" scheme="http://xinhecuican.github.io/categories/stl/"/>
    
    
  </entry>
  
  <entry>
    <title>组合</title>
    <link href="http://xinhecuican.github.io/2020/01/03/%E7%BB%84%E5%90%88/"/>
    <id>http://xinhecuican.github.io/2020/01/03/%E7%BB%84%E5%90%88/</id>
    <published>2020-01-03T09:32:00.000Z</published>
    <updated>2020-01-07T11:10:14.457Z</updated>
    
    <content type="html"><![CDATA[<p>本程序的思路是开一个数组，其下标表示1到n个数，数组元素的值为1表示其代表的数被选中，为0则没选中。</p><p>首先初始化，将数组前n个元素置1，表示第一个组合为前n个数。</p><p>然后从左到右扫描数组元素值的“10”组合，找到第一个“10”组合后将其变为“01”组合，同时将其左边的所有“1”全部移动到数组的最左端。</p><p>当第一个“1”移动到数组的n-m的位置，即n个“1”全部移动到最右端时，就得到了最后一个组合。</p><p>例如求5中选3的组合：</p><p>1 1 1 0 0 //1,2,3</p><p>1 1 0 1 0 //1,2,4</p><p>1 0 1 1 0 //1,3,4</p><p>0 1 1 1 0 //2,3,4</p><p>1 1 0 0 1 //1,2,5</p><p>1 0 1 0 1 //1,3,5</p><p>0 1 1 0 1 //2,3,5</p><p>1 0 0 1 1 //1,4,5</p><p>0 1 0 1 1 //2,4,5</p><p>0 0 1 1 1 //3,4,5<br>————————————————<br>版权声明：本文为CSDN博主「文如王勃三生慧」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/hf19931101/article/details/79452799" target="_blank" rel="noopener">https://blog.csdn.net/hf19931101/article/details/79452799</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本程序的思路是开一个数组，其下标表示1到n个数，数组元素的值为1表示其代表的数被选中，为0则没选中。&lt;/p&gt;
&lt;p&gt;首先初始化，将数组前n个元素置1，表示第一个组合为前n个数。&lt;/p&gt;
&lt;p&gt;然后从左到右扫描数组元素值的“10”组合，找到第一个“10”组合后将其变为“01”
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>string大小写字母转换</title>
    <link href="http://xinhecuican.github.io/2020/01/01/%E2%80%9Dstring%E7%B1%BB%E5%AD%97%E7%AC%A6%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E2%80%9C/"/>
    <id>http://xinhecuican.github.io/2020/01/01/%E2%80%9Dstring%E7%B1%BB%E5%AD%97%E7%AC%A6%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E2%80%9C/</id>
    <published>2020-01-01T08:42:00.000Z</published>
    <updated>2020-01-07T11:10:32.667Z</updated>
    
    <content type="html"><![CDATA[<p>在algorithm库中有transform函数<br>transform(str.begin(),str.end(),str.begin(),::toupper)<br>注意transform有四个输入参数<br>1：str.begin()字符串的起始地址；<br>2：str.end()字符串的终止地址；<br>3：str.begin()是转换之后，输出到原str字符串的起始地址；<br>4：转换操作，可以选择toupper，tolower。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在algorithm库中有transform函数&lt;br&gt;transform(str.begin(),str.end(),str.begin(),::toupper)&lt;br&gt;注意transform有四个输入参数&lt;br&gt;1：str.begin()字符串的起始地址；&lt;br&gt;2：s
      
    
    </summary>
    
    
      <category term="stl" scheme="http://xinhecuican.github.io/categories/stl/"/>
    
    
  </entry>
  
  <entry>
    <title>“凸包”</title>
    <link href="http://xinhecuican.github.io/2019/12/31/%E2%80%9C%E5%87%B8%E5%8C%85%E2%80%9D/"/>
    <id>http://xinhecuican.github.io/2019/12/31/%E2%80%9C%E5%87%B8%E5%8C%85%E2%80%9D/</id>
    <published>2019-12-31T02:50:00.000Z</published>
    <updated>2020-01-07T11:10:44.446Z</updated>
    
    <content type="html"><![CDATA[<p>凸包就是把平面中所有点都包进去的凸多边形，当然多边形上的点也是题目中给出的点</p><p>分治法<br>  1 首先，横坐标最小p1和最大pn的点一定是凸包上的点<br>  2上包，即离p1pn最远的点，记pmax<br>  3再把pmax与p1连接，求左侧的上包，重复上述过程即可求解<img src="/images/20150530094927274" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;凸包就是把平面中所有点都包进去的凸多边形，当然多边形上的点也是题目中给出的点&lt;/p&gt;
&lt;p&gt;分治法&lt;br&gt;  1 首先，横坐标最小p1和最大pn的点一定是凸包上的点&lt;br&gt;  2上包，即离p1pn最远的点，记pmax&lt;br&gt;  3再把pmax与p1连接，求左侧的上包，重复上
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>神奇的逗号运算符</title>
    <link href="http://xinhecuican.github.io/2019/12/05/%E7%A5%9E%E5%A5%87%E7%9A%84%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://xinhecuican.github.io/2019/12/05/%E7%A5%9E%E5%A5%87%E7%9A%84%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2019-12-05T04:40:00.000Z</published>
    <updated>2020-01-07T11:10:51.763Z</updated>
    
    <content type="html"><![CDATA[<p>   cout&lt;&lt;(a,c),此时只会输出c的内容，但是a中的内容也会被计算，例如a=5,b=6,c=7  cout&lt;&lt;(（d=a+b),c) 输出为7，d=11</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   cout&amp;lt;&amp;lt;(a,c),此时只会输出c的内容，但是a中的内容也会被计算，例如a=5,b=6,c=7  cout&amp;lt;&amp;lt;(（d=a+b),c) 输出为7，d=11&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
