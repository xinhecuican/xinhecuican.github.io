<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinhecuican&#39;s Blog</title>
  
  
  <link href="https://xinhecuican.github.io/atom.xml" rel="self"/>
  
  <link href="https://xinhecuican.github.io/"/>
  <updated>2021-08-11T01:34:15.751Z</updated>
  <id>https://xinhecuican.github.io/</id>
  
  <author>
    <name>星河璀璨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js 动画</title>
    <link href="https://xinhecuican.github.io/post/121540ac.html"/>
    <id>https://xinhecuican.github.io/post/121540ac.html</id>
    <published>2021-08-05T12:06:00.000Z</published>
    <updated>2021-08-11T01:34:15.751Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="动画"><a class="markdownIt-Anchor" href="#动画"></a> 动画</h1><p>过去想要实现动画都是使用定时器，但是定时器的精度不高，可能导致动画播放不平滑。为了使计时精确，便是用requestAnimationFrame(func).并且这个函数还可以有一个参数，它的类型是DOMHighResTimeStamp，表示开始执行回调函数的时刻。</p><p>没执行一次requestAnimationFrame(func),他就会执行一次回调函数。但是这并不是一定的，如果调用太快他会自动进行合并。可以认为有一个任务队列，调用这个函数将它插入这个队列中，但是如果队列中有这个函数就不会插入。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> update<span class="constructor">Progress(<span class="params">time</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    var div = document.get<span class="constructor">ElementById(<span class="string">&quot;status&quot;</span>)</span>;</span><br><span class="line">    div.style.width = (parse<span class="constructor">Int(<span class="params">div</span>.<span class="params">style</span>.<span class="params">width</span>, 10)</span> + <span class="number">5</span>) + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(div.style.left != <span class="string">&quot;100%&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        request<span class="constructor">AnimationFrame(<span class="params">updateProgress</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">request<span class="constructor">AnimationFrame(<span class="params">updateProgress</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>window.cancelAnimationFrame(ID): 前面一个函数的返回值是一个ID，</li></ul><h1 id="canvas"><a class="markdownIt-Anchor" href="#canvas"></a> canvas</h1><p><code>&lt;canvas&gt;</code>元素创建一个画布。创建它时至少要提供width和height属性，否则不会显示。开始标签和结束标签中的内容是不支持<code>&lt;canvas&gt;</code>时提示的内容。</p><p><code>&lt;canvas id=&quot;drawing&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;A drawing of something&lt;/canvas&gt;</code></p><p>想要在canvas上进行绘图，首先要获得绘图上下文，使用<code>getContext(&quot;2d&quot;)</code>可以获得2D图形绘图对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(drawing.getContext)<span class="comment">//测试是否存在getContext函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>toDateURL(type)</code>获得<code>&lt;canvas&gt;</code>上的图像，参数为图片的类型。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = document.get<span class="constructor">ElementById(<span class="string">&quot;image/png&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">if</span>(drawing.getContext)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> imgURI = drawing.<span class="keyword">to</span><span class="constructor">DataURL(<span class="string">&quot;image/png&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">let</span> image = document.create<span class="constructor">Element(<span class="string">&quot;img&quot;</span>)</span>;</span><br><span class="line">    imge.src = imgURI;</span><br><span class="line">    document.body.append<span class="constructor">Child(<span class="params">image</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2d绘图"><a class="markdownIt-Anchor" href="#2d绘图"></a> 2D绘图</h2><p>属性：</p><ul><li>width:</li><li>height: 画布的长宽，默认是在画布的左上角，其他的坐标值都根据该点计算</li><li>fillStyle: 填充样式，gradient是渐变</li><li>strokeStyle: 边框样式</li><li>context.font: 以css语法决定的字体样式，例如<code>10px Arial</code></li><li>textAlign: 对齐方式，可以为start、end、left、right、center。推荐使用start和end，不使用left和right</li><li>textBaseLine: 指定文本的基线，可以为top、bottom、hanging、middle、alphabetic、ideographic。top表示y坐标在文本顶部，bottom表示y坐标在文本底部</li><li>shadowColor: css颜色值</li><li>shadowOffsetX: 阴影相对于路径的x坐标偏移量，默认是0</li><li>shodowOffsetY:</li><li>showdowBlur： 阴影的模糊量</li><li>globalAlpha: 透明度</li><li>globalCompositionOperation: 图像合成模式</li></ul><p><strong>绘制矩形</strong>：</p><ul><li>fillRect(x, y, w, h): 填充矩形，填充的样式由fillStyle决定</li><li>strokeRect(x, y, w, h):</li><li>clearRect(x, y, w, h):</li></ul><p>例如：</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing =<span class="built_in"> document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(drawing.getContext)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">context</span> = drawing.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    <span class="keyword">context</span>.fillStyle = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">    <span class="keyword">context</span>.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">context</span>.fillStyle = <span class="string">&quot;rgba(0, 0, 255, 0.5)&quot;</span>;</span><br><span class="line">    <span class="keyword">context</span>.fillRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/canvas1.png" alt="" /></p><p><strong>绘制路径</strong></p><p>路径由多个点组成，可以闭合也可以不闭合，可以利用它绘制各种复杂的图形。</p><p>首先调用context.beginPath()表示开始绘制，然后再调用下列方法进行绘制（只是描点，并没有真正开始绘制，还需要运行绘制完成操作才可以进行绘制）</p><ul><li>arc(x, y, radius, startAngle, endAngle, counterclockwise): 以(x, y)为中心，radius为半径绘制一条弧形。counterclockwise表示是否逆时针开始（默认是顺时针）</li><li>arcTo(x1, y1, x2, y2, radius): 从(x1, y1)到(x2, y2)绘制一条半径为raidus的弧</li><li>bezierCurveTo(c1x, c1y, c2x,c2y, x, y): 绘制一条以(c1x, c1y)和(c2x, c2y)为控制点，从上一点到(x, y)的弧线(三次贝塞尔曲线） <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = document.get<span class="constructor">ElementById(<span class="string">&quot;drawing_canvas&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> ctx = drawing.get<span class="constructor">Context(<span class="string">&quot;2d&quot;</span>)</span>;</span><br><span class="line">    ctx.<span class="keyword">begin</span><span class="constructor">Path()</span>;</span><br><span class="line">    ctx.move<span class="constructor">To(20, 20)</span>;</span><br><span class="line">    ctx.bezier<span class="constructor">CurveTo(20, 100, 200, 100, 200, 20)</span>;</span><br><span class="line">    ctx.stroke<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果为<img src="/images/canvas2.png" alt="" /></li><li>lineTo(x, y): 从上一点到(x, y)绘制直线</li><li>moveTo(x, y): 画笔移动到(x, y)</li><li>quadraticCurveTo(cx, cy, x, y): 以(cx, cy)为控制点，绘制一条虫上一点到(x, y)的弧线(二次贝塞尔曲线)</li><li>rect(x, y, width, height):</li><li>isPointInPath(x, y): 检测点是否在路径中</li></ul><p>绘制完成之后的操作函数</p><ul><li>closePath(): 绘制前面所有的线和一条道起点的线</li><li>fill(): 填充路径</li><li>stroke(): 绘制路径，使用这个函数才会真正在画面上有显示</li><li>clip(): 创建一个剪切区域</li></ul><p><strong>绘制文本</strong></p><ul><li>fillText(str, x, y, maxpexel): 以(x, y)为基准点开始绘制str，最大像素为maxpexel。他会使用fillstyle属性</li><li>strokeText(str, x, y, maxpexel): 参数含义和上面相同</li><li>measureText(): 获得一个文本属性对象，目前这个对象只有width一个属性</li></ul><p>例如：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">context</span>.<span class="built_in">font</span> = <span class="string">&quot;bold 14px Arial&quot;</span>;</span><br><span class="line"><span class="built_in">context</span>.textAlign = <span class="string">&quot;center&quot;</span>;</span><br><span class="line"><span class="built_in">context</span>.textBaseLine = <span class="string">&quot;middle&quot;</span>;</span><br><span class="line"><span class="built_in">context</span>.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">//使用measureText限制最大宽度</span><br><span class="line"><span class="built_in">let</span> fontSize = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">context</span>.<span class="built_in">font</span> = fontSize + <span class="string">&quot;px Arial&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">context</span>.measureText(<span class="string">&quot;hello world&quot;</span>).<span class="built_in">width</span> &gt; <span class="number">140</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fontSize--;</span><br><span class="line">    <span class="built_in">context</span>.<span class="built_in">font</span> = fontSize + <span class="string">&quot;px Arial&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">context</span>.fillText(<span class="string">&quot;hello world&quot;</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>变换</strong></p><p>可以对图像进行缩放，平移，旋转等操作</p><ul><li>rotate(angle): 以原点为中心旋转angle角度</li><li>scale(scalex, scaley): 进行缩放，x乘以scalex，y乘以scaley <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = document.get<span class="constructor">ElementById(<span class="string">&quot;drawing_canvas&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> ctx = drawing.get<span class="constructor">Context(<span class="string">&quot;2d&quot;</span>)</span>;</span><br><span class="line">    ctx.<span class="keyword">begin</span><span class="constructor">Path()</span>;</span><br><span class="line">    ctx.scale(<span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line">    ctx.stroke<span class="constructor">Rect(0, 0, 100, 100)</span>;<span class="comment">//一个正方形</span></span><br><span class="line">    ctx.stroke<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/js%E5%8A%A8%E7%94%BB3.png" alt="" /></li><li>translate(x, y): 把坐标原点移动到(x, y)主要是为了配合rotate使用</li><li>transform(m1_1, m1_2, m2_1, m2_2, dx, dy): 综合缩放旋转和移动，<a href="https://www.w3school.com.cn/tags/canvas_transform.asp">具体可看</a></li></ul><p><strong>渐变</strong></p><ul><li>createLinearGradient(x1, y1, x2, y2): 创建从(x1, y1)到(x2, y2)的渐变对象</li><li>createRadialGradient(x, y, radius, dstx, dsty, dstr): 放射性渐变，六个参数控制两个圆，第一个是内部圆，第二个是外部圆。</li></ul><p>获得渐变对象之后，可以使用addColorStop()方法创建色标.并且这个对象可以赋值给fillStyle和strokeStyle</p><ul><li>gradient.addColorStop(loc, color): loc是0-1范围的值，color是颜色</li></ul><p>例如：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = document.get<span class="constructor">ElementById(<span class="string">&quot;drawing_canvas&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> ctx = drawing.get<span class="constructor">Context(<span class="string">&quot;2d&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">let</span> gradient = ctx.create<span class="constructor">LinearGradient(30, 30, 70, 70)</span>;</span><br><span class="line">    gradient.add<span class="constructor">ColorStop(0, <span class="string">&quot;white&quot;</span>)</span>;</span><br><span class="line">    gradient.add<span class="constructor">ColorStop(1, <span class="string">&quot;black&quot;</span>)</span>;</span><br><span class="line">    ctx.fillStyle = gradient;</span><br><span class="line">    ctx.fill<span class="constructor">Rect(50, 50, 50, 50)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/js%E5%8A%A8%E7%94%BB4.png" alt="" /><br />正常情况下应该一半黑一半白，但是这里几乎都是黑色，因为渐变的范围是(30, 30)到(70, 70)，到了矩形部分已经快渐变完了，因此显示都是黑色。因此为了显示比较好的渐变要渐变范围和图形范围相适应。</p><p><strong>图像处理</strong></p><ul><li>drawImage(image, x, y, w, h, dstx, dsty, dstw, dsth): x，y，w，h是原图像的截取区域，dstx…是绘图区域中的一部分。</li><li>createPattern(img, repeat): 第一个参数时一个<code>&lt;img&gt;</code>元素，第二个参数是重复方式，有repeat、repeat-x、repeat-y和no-repeat</li></ul><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">image</span> = document.images[<span class="number">0</span>];</span><br><span class="line">pattern = <span class="built_in">context</span>.createPattern(<span class="built_in">image</span>, <span class="string">&quot;repeat&quot;</span>);</span><br><span class="line"><span class="built_in">context</span>.filstyle = pattern;</span><br><span class="line"><span class="built_in">context</span>.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>);//会在这个范围内重复显示图像</span><br></pre></td></tr></table></figure><ul><li>getImageData(x, y, w, h): 获得区域内的图像数据，返回的对象中有width、height、data三个属性。</li><li>putImageData(data, x, y): 将imageData对象放到(x, y)起点处</li></ul><p>data属性表示像素，它是一个一维数组，前四个表示第一个像素的r,g,b,a。</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">data</span> = imageData.data;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">red</span> = data[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">green</span> = datat[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">blue</span> = data[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">alpha</span> = data[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">red2</span> = data[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>globalCompositionOperation是多个形状之间如何融合。<a href="http://www.wuhoushu.com/2020/04/07/canvas%E5%AD%A6%E4%B9%A021%E4%B9%8BglobalCompositionOperation%E5%AD%A6%E4%B9%A0/">各属性具体讲解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;动画&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>ld链接脚本语法</title>
    <link href="https://xinhecuican.github.io/post/60b30b31.html"/>
    <id>https://xinhecuican.github.io/post/60b30b31.html</id>
    <published>2021-08-05T00:20:00.000Z</published>
    <updated>2021-08-05T10:28:05.844Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>ENTRY(symbol)</td><td>将符号symbol的值作为入口地址（主函数）。ld中有多种方法指定入口地址，他们的优先级如下排列。   1. ld中的-e选项 2. 脚本中的ENTRY 3. _start符号 4. .text段第一个字节地址 5. 0</td></tr><tr><td>STARTUP(filename)</td><td>将文件filename作为链接中的第一个输入文件</td></tr><tr><td>SEARCH_DIR(path)</td><td>库查找目录</td></tr><tr><td>INPUT(file, file, …)</td><td>将指定文件作为输入文件</td></tr><tr><td>INCLUDE filename</td><td>将指定文件包含进链接脚本（这是对脚本来说的，相当与在脚本中写了#include 加入其他脚本)</td></tr><tr><td>PROVIDE(symbol)</td><td>在链接脚本中添加某个符号</td></tr></tbody></table><p>此外，最基本的命令就是定义段的SECTIONS了，它的格式为：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">SECTIONS</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">secname </span>: &#123; contents &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">secname</span>是输出文件的对应段，<span class="selector-tag">contents</span>是输入文件的段</span><br><span class="line"></span><br><span class="line">其中<span class="selector-tag">contents</span>的语法为： <span class="selector-tag">filename</span>(<span class="selector-tag">sections</span>)</span><br><span class="line">表示要把某个文件中的某个段添加到<span class="selector-tag">secname</span>中</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">file1</span><span class="selector-class">.o</span>(<span class="selector-class">.data</span>): 将<span class="selector-tag">file1</span><span class="selector-class">.o</span>的<span class="selector-class">.data</span>段添加到输出文件的对应段中</span><br><span class="line">*(<span class="selector-class">.data</span>): 将所有输入文件的<span class="selector-class">.data</span>段添加到对应段中。此外，还可以使用其他正则表达式</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ENTRY(nomain)<span class="regexp">//</span>以nomain函数作为程序入口</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = <span class="number">0</span>x08048000 + SIZEOF_HEADERS;<span class="regexp">//</span>以这个地址作为当前虚拟地址</span><br><span class="line">    tinytext : &#123;*(.text) *(.data) *(.rodata) &#125;</span><br><span class="line">    <span class="regexp">/DISCARD/</span> : &#123;*(.comment)&#125;<span class="regexp">//</span>抛弃.comment段</span><br><span class="line">|</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;说明&lt;/</summary>
      
    
    
    
    <category term="c++" scheme="https://xinhecuican.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>js事件</title>
    <link href="https://xinhecuican.github.io/post/9fabc801.html"/>
    <id>https://xinhecuican.github.io/post/9fabc801.html</id>
    <published>2021-08-01T10:40:00.000Z</published>
    <updated>2021-08-05T09:51:23.298Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="事件流过程"><a class="markdownIt-Anchor" href="#事件流过程"></a> 事件流过程</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">当点击div后.click事件冒泡顺序：</span><br><span class="line"></span><br><span class="line">1. div</span><br><span class="line">2. body</span><br><span class="line">3. html</span><br><span class="line">4. document</span><br><span class="line">也就是从内部不断的向父节点传递，直到传递到根节点</span><br></pre></td></tr></table></figure><p>但是如果使用事件捕获，会出现不同的结果。它的顺序正好和前面讲的相反。</p><p>而在事件流中，真正的处理顺序是事件捕获、到达目标和事件冒泡。事件捕获时从根节点到达目标节点的过程，事件冒泡是从目标节点到根节点的过程。</p><h1 id="事件处理程序"><a class="markdownIt-Anchor" href="#事件处理程序"></a> 事件处理程序</h1><p>事件是用户或浏览器执行的动作，例如单击，单击，悬停等。事件处理程序的名字统一以on开头，例如onclick, onload等。</p><p><strong>html事件处理程序</strong></p><p>有些处理函数可以在html中直接指定。例如：</p><p><code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;console.log('click')&quot;/&gt;</code></p><p>这里是直接传递了一个函数字符串，也可以使用函数名，例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>)</span></span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;click me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;showMessage()&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>事件处理函数的作用域有了一些变化，首先有一个event变量，它保存的是event对象</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="keyword">type</span>=<span class="string">&quot;button&quot;</span>  value=<span class="string">&quot;click me&quot;</span> onclick=<span class="string">&quot;console.log(event.type)&quot;</span>/&gt;</span><br><span class="line">//event.<span class="keyword">type</span> <span class="type">= </span>button</span><br></pre></td></tr></table></figure><p>其次，this表示的是这个事件的目标元素，上面的例子中是input，也就是说可以使用<code>this.value</code>访问input的value元素</p><p>但是它会导致html和js的强耦合，难以对事件处理代码进行修改，因此不推荐这种模式。</p><p><strong>dom进行事件处理</strong></p><p>每个元素都有一些事件处理属性，例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;clicked&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = <span class="literal">null</span>;<span class="comment">//移除事件处理程序</span></span><br></pre></td></tr></table></figure><p>另外一种方法是使用addEventListener</p><ul><li>addEventListener(event_name, func, call_state):<ul><li>event_name: 事件名，例如&quot;click&quot;</li><li>func: 事件处理函数</li><li>call_state: 一个布尔值，为真(默认值）则在冒泡阶段调用，否则在捕获阶段调用</li></ul></li></ul><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">let btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mybtn&quot;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);//mybtn</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li>removeEventListener(event_name, func, call_state): 和上面参数相同，只有三个参数完全匹配才可以删除对应的eventListener,并且只有这种方式才可以删除由addEventListener加入的事件处理程序。</li></ul><p>匿名函数创建的eventListener无法删除</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.removeEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//删除无效，因为两个匿名函数不同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);</span><br><span class="line">btn.removeEventListener(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);<span class="comment">//有效</span></span><br></pre></td></tr></table></figure><p><strong>IE事件处理</strong></p><p>IE和dom类似，只是函数不同，它是attachEvent()和detachEvent()，但是和addEventListener相比少了最后一个参数，他在IE8之前只能指定冒泡模式，并且它的事件名字需要加上on，例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mybtn&quot;</span>);</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, ()=&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="事件对象"><a class="markdownIt-Anchor" href="#事件对象"></a> 事件对象</h1><p>event是事件处理函数的唯一参数，他有一系列关于事件的属性和方法</p><h2 id="dom事件对象"><a class="markdownIt-Anchor" href="#dom事件对象"></a> DOM事件对象</h2><p>不同的事件中包含的属性和方法也不一样，下面是一些共有的属性和方法</p><table><thead><tr><th>属性/方法</th><th>类型</th><th>读/写</th><th>说明</th></tr></thead><tbody><tr><td>bubbles</td><td>bool</td><td>r</td><td>表示事件是否冒泡</td></tr><tr><td>cancelable</td><td>bool</td><td>r</td><td>表示事件默认行为是否可以被取消</td></tr><tr><td>defaultPrevented</td><td>bool</td><td>r</td><td>true表示已经调用preventDefault()方法</td></tr><tr><td>trusted</td><td>bool</td><td>r</td><td>true表示该事件是由浏览器生成的</td></tr><tr><td>type</td><td>string</td><td>r</td><td>触发的事件类型</td></tr><tr><td>currentTarget</td><td>元素</td><td>r</td><td>当前事件处理程序的元素(this)</td></tr><tr><td>target</td><td>元素</td><td>r</td><td>事件的目标元素，冒泡的第一个程序</td></tr><tr><td>detail</td><td>整数</td><td>r</td><td>一些其他信息</td></tr><tr><td>eventPhase</td><td>整数</td><td>r</td><td>事件所处的阶段，一共有三个阶段.1表示捕获，2表示到达目标，3表示冒泡</td></tr><tr><td>preventDefault()</td><td>函数</td><td>r</td><td>取消事件的默认行为</td></tr><tr><td>stopImmediatePropagation()</td><td>函数</td><td>r</td><td>取消后续的捕获或冒泡，并组织调用后续的事件处理程序</td></tr><tr><td>stopPropagation()</td><td>函数</td><td>r</td><td>取消后续的捕获或冒泡</td></tr></tbody></table><p>例如单击时导航到指定url是链接的默认行为，选中复选框是点击复选框的默认行为，下面程序可以取消选中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;#id-checkbox&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">document</span>.getElementById(<span class="string">&quot;output-box&quot;</span>).innerHTML += <span class="string">&quot;Sorry! &lt;code&gt;preventDefault()&lt;/code&gt; won&#x27;t let you check this!&lt;br&gt;&quot;</span>;</span><br><span class="line">         event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="ie事件对象"><a class="markdownIt-Anchor" href="#ie事件对象"></a> IE事件对象</h2><p>IE中event对象在window.event中，因为是单线程一次只会执行一个事件处理函数因此这样做也没有问题。他也有一些共有的属性和方法</p><table><thead><tr><th>属性/方法</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>cancelBubble</td><td>bool</td><td>是否在冒泡阶段</td></tr><tr><td>returnValue</td><td>bool</td><td>可读写，设置为false 表示取消默认行为</td></tr><tr><td>srcElement</td><td>元素</td><td>事件目标（和DOM中的target相同）</td></tr><tr><td>type</td><td>string</td><td>事件类型</td></tr></tbody></table><h1 id="事件类型"><a class="markdownIt-Anchor" href="#事件类型"></a> 事件类型</h1><ul><li>用户界面事件（UIEvent): 与<a href="https://xinhecuican.github.io/post/f3d3ee5b.html#window%E5%AF%B9%E8%B1%A1">BOM</a>交互的通用事件.</li><li>焦点事件（FocusEvent): 在元素获得和失去焦点时从触发</li><li>滚轮事件(WheelEvent): 使用滚轮或者起到相同功能的设备时触发</li><li>键入事件（InputEvent): 输入文本触发</li><li>键盘事件(KeyboardEvent):</li><li>合成事件（CompositionEvent): 间接输入文本(使用输入法）时产生的事件</li></ul><h2 id="uievent"><a class="markdownIt-Anchor" href="#uievent"></a> UIEvent</h2><p>UIEvent包括很多种事件，他不一定和用户操作有关，有些在DOM出现之前就已经存在了，保留它主要是为了向后兼容。</p><ul><li>load： 在window上页面加载完成之后触发，在<code>&lt;frameset&gt;</code>的所有<code>&lt;frame&gt;</code>加载完成后触发，在<code>&lt;img&gt;</code>图片加载完成后触发， <code>&lt;object&gt;</code>相应对象加载完成后触发</li><li>unload： 当window界面完全卸载后触发，所有<code>&lt;frame&gt;</code>卸载后触发，<code>&lt;object&gt;</code>卸载完成后触发</li><li>abort： <code>&lt;object&gt;</code>对象在加载完成前被用户终止下载触发</li><li>error: 报错时触发</li><li>select: 文本框(<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>）上被选择若干个字符触发</li><li>resize: 窗口被缩放时触发</li><li>scroll： 滚动时在被滚动的元素上出发</li></ul><h2 id="focusevent"><a class="markdownIt-Anchor" href="#focusevent"></a> FocusEvent</h2><ul><li>blur: 失去焦点时触发，这个事件不冒泡</li><li>focus： 获得焦点时触发，不冒泡</li><li>DOMFocusIn： 获得焦点时触发，这个事件会冒泡，另外现在主要是focusin</li><li>DOMFocusOut： 和上面一样，推荐使用focusout</li></ul><h2 id="鼠标和滚轮事件"><a class="markdownIt-Anchor" href="#鼠标和滚轮事件"></a> 鼠标和滚轮事件</h2><p>鼠标事件主要是点击，双击等，总共有9种鼠标事件。</p><ul><li>click： 用户单击左键或回车键时触发。</li><li>dblclick: 双击</li><li>mousedown： 按下任意鼠标按键触发</li><li>mouseenter: 从元素外部到元素内部时触发，这个事件不冒泡，也不会在移动到该元素的子元素时触发</li><li>mouseleave: 元素内部到元素外部触发，…</li><li>mousemove: 在元素内移动时<strong>反复</strong>触发</li><li>mouseout: 从元素移动到其他元素时触发，会冒泡并且移动到子元素也会触发</li><li>mouseover: 移动到元素内触发， 和上面一样</li><li>mouseup: 释放鼠标键触发</li><li>mousewheel: 鼠标滚轮滚动事件，除了共有的属性外还有一个wheelDelta的属性。鼠标向外滚动时为120，向内部滚动时为-120.</li></ul><p>几个类似事件的触发也是有先后顺序的，mousedown和mouseup都触发完毕之后才会触发click事件。连续两次click才会有dblclick触发：</p><ol><li>mousedown</li><li>mouseup</li><li>click</li><li>mousedown</li><li>mouseup</li><li>click</li><li>dblclick</li></ol><p><strong>坐标</strong></p><p>客户端坐标是相对于窗口的坐标，可以通过event.clientX和event.clientY获取。</p><p><img src="/images/js%E4%BA%8B%E4%BB%B61.png" alt="" /></p><p>页面坐标是相对于这个页面来说的，滚动页面有一部分是不可见的，页面坐标就是包括这部分不可见的计算从该点到左上角的距离。它通过pageX和pageY获取</p><p>屏幕坐标是相对于屏幕左上角，可以通过screenX和screenY获取</p><p><strong>右键菜单</strong>js事件1.png</p><p>为了自定义右键菜单，出现了contextmenu事件，她会在右键菜单命令出现时触发。可以通过preventDefault()阻止默认的右键菜单。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;example&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;myidv&quot;</span>&gt;right click&lt;/div&gt;</span><br><span class="line">    &lt;ul id=<span class="string">&quot;mymenu&quot;</span> style=<span class="string">&quot;position:absolute;visibility:hidden;background-color:silver&quot;</span>&gt;<span class="comment">//一开始是隐藏的</span></span><br><span class="line">      &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.somewhere.com&quot;</span>&gt;</span>somewhere<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>)=&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mydiv&quot;</span>);</span><br><span class="line">    div.addEventListener(<span class="string">&quot;contextmenu&quot;</span>, <span class="function">(<span class="params">event</span>)=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">        <span class="keyword">let</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mymenu&quot;</span>);</span><br><span class="line">        menu.style.left = event.clientX + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">        menu.style.top = event.clientY + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">        menu.style.visibility = <span class="string">&quot;visible&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>)=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;mymenu&quot;</span>).style.visibility = <span class="string">&quot;hidden&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>修饰键</strong></p><p>有时候鼠标还需要根据ctrl，alt等修饰键判断状态，在js中定义了四个键属性：shiftKey，ctrlKey,altKey,metaKey。按下则为true，没有按下则为false</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mydiv&quot;</span>);</span><br><span class="line">div.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>)=&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.shiftKey)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;enter shift&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相关元素</strong></p><p>对于mouseout、mouseover等事件，除了关心事件的触发者，还关心现在移动到了哪个元素，也就是相关元素。它的属性是event.relatedTarget</p><p>对于mouseout事件来说，触发者是失去光标的元素，相关元素是获得光标的元素。</p><p><strong>其他属性</strong></p><ul><li>event.button: 表示现在按下的是哪个按键<ul><li>0： 没有按下任何键</li><li>1： 按下左键（主键）</li><li>2： 按下右键(副键）</li><li>3： 同时按下左右键</li><li>4： 按下中键</li><li>5： 同时按下主键和中键</li><li>6： 按下副键和中键</li><li>7： 同时按下三个键</li></ul></li><li>altleft: 是否按下左边的ctrl</li><li>ctrlleft:</li><li>shiftleft:</li><li>offsetX: 光标相对于元素边界的x坐标</li><li>offsetY:</li></ul><h2 id="键盘和输入事件"><a class="markdownIt-Anchor" href="#键盘和输入事件"></a> 键盘和输入事件</h2><p>事件：</p><ul><li>keydown： 按下按键触发</li><li>keyup： 释放按键触发</li></ul><p>对于字符类按键（a，b，c等），keydown和keyup会重复触发。对于非字符键(ctrl,alt等）如果只按一下，会触发keydown和keyup。如果持续按下，会一直触发keydown，待释放再触发keyup。</p><p>属性：</p><ul><li>keyCode： 键码，用来表示按下了哪个按键。</li><li>charcode： 只有在keydown时才会被设置值，是按键对应的ascii值。</li><li>keycode： 和charcode相同</li><li>key： 返回按键的字符串，如果是非字符按键则返回按键名（Shift,ArrowDown)</li><li>getModifierState(name): 获得修饰键状态，例如：<code>event.getModifierState(&quot;Shift&quot;);</code></li></ul><p><strong>textInput</strong></p><p>textInput在输入字符时触发，他有一些属性和方法：</p><ul><li>data： 输入的字符</li><li>inputMethod： 输入方法<ul><li>0： 不确定</li><li>1： 表示键盘</li><li>2： 粘贴</li><li>3： 拖放</li><li>4 ： 输入法</li><li>5： 表单</li><li>6： 手写</li><li>7： 语音</li><li>8： 组合</li><li>9： 脚本</li></ul></li></ul><p><strong>合成事件</strong></p><p>在使用输入法输入时，如果是一些其他语言（如中文），往往若干个输入才可以合成一个词，这时就需要一些新的事件进行管理</p><ul><li>compositionstart: 打开时触发，表示输入即将开始</li><li>compositionupdate: 输入字段触发</li><li>compositionend: 关闭时触发，包含本次合成中输入的全部内容</li></ul><h2 id="html事件"><a class="markdownIt-Anchor" href="#html事件"></a> html事件</h2><p><strong>beforeunload</strong></p><p>这个事件在window上触发，它可以在用户退出前提供一个对话框询问是否退出。一般在表单填上后退出时进行提示。可以通过returnValue修改提示内容</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;beforeunload&quot;</span>, <span class="function"><span class="params">(event)</span>=&gt;</span>&#123;</span><br><span class="line">    let message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    event.returnValue = message;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>DOMContentLoaded</strong></p><p>load事件会在图片等全部加载完成后才会触发，所需时间比较长。而DOMContentLoaded会在DOM树构建完成之后触发，不用等待图片，js，css等文件加载完成。它在document或window上。</p><p><strong>hashchange</strong></p><p>它会在url散列值（#后面的部分）触发时通知开发者。他有两个新属性，oldURL和newURL，分别存储变化前后的url。它在window对象中。</p><h1 id="模拟事件"><a class="markdownIt-Anchor" href="#模拟事件"></a> 模拟事件</h1><p>可以使用document.createEvent()创建一个event对象。然后使用dispatchEvent(event)发送给某一个对象，之后就会冒泡执行。</p><ul><li>document.createEvent(name): 创建一个事件，name是事件的类型，有&quot;UIEvents&quot;、“MouseEvents”、“HTMLEvents”</li><li>obj.dispatchEvents(event): 将这个事件传给obj对象并冒泡执行</li></ul><p><strong>模拟鼠标事件</strong></p><p>需要新建一个鼠标event对象，然后对其初始化。初始化使用initMouseEvent()对象，它共有15个参数</p><ul><li>type: 要触发的事件类型，如&quot;click&quot;</li><li>bubbles: 是否冒泡</li><li>cancelable： 是否可以取消</li><li>view：始终为document.defaultView</li><li>detail: 额外信息，被事件处理程序使用，通常为0</li><li>screenX:</li><li>screenY:</li><li>clientX:</li><li>clientY:</li><li>ctrlkey</li><li>altKey</li><li>shiftKey</li><li>metaKey</li><li>button: 表示按下了那个按钮，默认为0</li><li>relatedTarget: 关联对象</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = document.getElementById(<span class="string">&quot;mybtn&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">event</span> = document.createEvent(<span class="string">&quot;MouseEvents&quot;</span>);</span><br><span class="line"><span class="keyword">event</span>.initMouseEvent(<span class="string">&quot;click&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>, document.defaultView, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"> <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">btn.dispatchEvent(<span class="keyword">event</span>);</span><br></pre></td></tr></table></figure><p><strong>模拟键盘事件</strong></p><p>和鼠标事件类似，只是参数有所不同，<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyboardEvent">参数可参看</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;事件流过程&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>css选择器</title>
    <link href="https://xinhecuican.github.io/post/676848e4.html"/>
    <id>https://xinhecuican.github.io/post/676848e4.html</id>
    <published>2021-07-27T07:26:00.000Z</published>
    <updated>2021-07-27T11:00:10.842Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>选择器是用来快速便捷的查找某一元素的，一个html文档中这么多元素，属性，如果只使用获得某一元素然后遍历再获得子元素的方法那时不可想象的，可能随便查找一个元素都需要几十行代码。</p><p>而选择器就是为了简化查找操作的。他将几种常用的标签作为选择的key，只需要知道这些标签内部就会有一套算法帮助我们快速查找，并且还可以几个key连在一起查找。</p><h1 id="选择器种类"><a class="markdownIt-Anchor" href="#选择器种类"></a> 选择器种类</h1><h2 id="清空-id-类"><a class="markdownIt-Anchor" href="#清空-id-类"></a> *(清空) #(ID) .(类）</h2><p><strong>*（清空选择器)</strong></p><p>这个选择器会选择所有元素，常被用作清空margin和padding</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>#(ID选择器)</strong></p><p>它会选择所有匹配的ID</p><p>例如</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">&quot;gac_scont&quot;</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">css</span><br><span class="line"><span class="comment">#gac_scont&#123;</span></span><br><span class="line">   border: <span class="number">1</span>px solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>.(类选择器)</strong></p><p>类选择器会选择对应的类，例如</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;DH7hPe&quot;</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br><span class="line">css</span><br><span class="line">.DH7hPe</span><br><span class="line">&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="x类型x属性-x伪类"><a class="markdownIt-Anchor" href="#x类型x属性-x伪类"></a> X(类型),X[…](属性), x:…(伪类)</h2><p><strong>X</strong>是直接选择某种元素。例如a, img等。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &#123; <span class="attribute">margin-left</span>: <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>**X[attibute]**是选择该元素的某些属性，则对这个元素进行某些动作，例如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span>//存在<span class="selector-tag">title</span>属性</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;http://strongme.cn&quot;</span> rel=<span class="string">&quot;external nofollow&quot;</span>]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#1f6053</span>;</span><br><span class="line">&#125;</span><br><span class="line">//如果链接时对应的链接则把链接中的文本设置成绿色</span><br></pre></td></tr></table></figure><p>对于这些属性还可以使用类似正则表达式的形式。例如：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>[href^=<span class="string">&quot;https&quot;</span>]<span class="comment">//以https开头</span></span><br><span class="line"><span class="selector-tag">a</span>[href$=<span class="string">&quot;.jpg&quot;</span>]<span class="comment">//链接以jpg结尾</span></span><br><span class="line"><span class="selector-tag">a</span>[href*=<span class="string">&quot;strongme&quot;</span>]<span class="comment">//只要存在strongme的链接都可以通过，例如strongme.com,strongme.top</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>[headers~= col1]<span class="comment">//匹配属性有多个由空格分隔的值 选择其中一个</span></span><br><span class="line">例如： </span><br><span class="line">&lt;<span class="selector-tag">a</span> href=<span class="string">&quot;path/to/image.jpg&quot;</span> data-info=<span class="string">&quot;external image&quot;</span>&gt; Click Me, Fool &lt;/a&gt;</span><br><span class="line"><span class="selector-tag">a</span>[data-info~=<span class="string">&quot;external&quot;</span>]&#123; <span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><p>伪类选择器</p><table><thead><tr><th>选择器</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>:first-child</td><td>匹配父元素的第一个子元素</td><td>p:first-child</td></tr><tr><td>:link</td><td>未被点击的链接</td><td>a:link</td></tr><tr><td>:visited</td><td>已经被点击的链接</td><td>a:visited</td></tr><tr><td>:active</td><td>按下但未被释放的元素</td><td>a:active</td></tr><tr><td>:hover</td><td>鼠标悬浮在其上</td><td></td></tr><tr><td>X:focus</td><td>当前获得焦点的X元素</td><td></td></tr><tr><td>lang©</td><td>lang属性是C的元素</td><td>q:lang(sv)</td></tr><tr><td>:first-line</td><td>匹配元素的第一行</td><td>p:first-line</td></tr><tr><td>:first-letter</td><td>匹配元素的第一个字母</td><td>p:first-letter</td></tr><tr><td>:before</td><td>在元素生成之前插入的内容</td><td>p:before{ content:“台词：”;}</td></tr><tr><td>:after</td><td>在元素生成之后插入的内容</td><td></td></tr><tr><td>:enable</td><td>匹配表单中激活的元素</td><td></td></tr><tr><td>:disable</td><td>匹配禁用的元素</td><td><code>input[type=&quot;text&quot;]:disabled &#123; background:#ddd; &#125;</code></td></tr><tr><td>:checked</td><td>选择表单中被选中的单选框或复选框</td><td></td></tr><tr><td>:selection</td><td>匹配当前选中的元素</td><td></td></tr><tr><td>:root</td><td>根元素</td><td></td></tr><tr><td>:nth-child(n)</td><td>第n个子元素</td><td></td></tr><tr><td>:nth-last-child(n)</td><td>倒数第n个子元素</td><td></td></tr><tr><td>:first-of-type</td><td>和该元素同种类的第一个子元素</td><td></td></tr><tr><td>:empty</td><td>匹配不包含任何子元素的元素</td><td>p:empty</td></tr></tbody></table><h2 id="组合选择器"><a class="markdownIt-Anchor" href="#组合选择器"></a> 组合选择器</h2><ul><li>X,Y(多元素选择器）： 匹配X或Y</li><li>X Y： 首先匹配X，在符合X条件的元素中再用Y匹配</li><li>X&gt;Y: 匹配X，然后匹配在X下的直接后代</li><li>X+Y: 选择X条件下选中元素中第一个Y元素</li></ul><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;div id=&quot;container&quot;&gt;</span></span><br><span class="line">   <span class="params">&lt;ul&gt;</span></span><br><span class="line">      <span class="params">&lt;li&gt;</span> List Item</span><br><span class="line">        <span class="params">&lt;ul&gt;</span></span><br><span class="line">           <span class="params">&lt;li&gt;</span> Child <span class="params">&lt;/li&gt;</span></span><br><span class="line">        <span class="params">&lt;/ul&gt;</span></span><br><span class="line">      <span class="params">&lt;/li&gt;</span></span><br><span class="line">      <span class="params">&lt;li&gt;</span> List Item2 <span class="params">&lt;/li&gt;</span></span><br><span class="line">      <span class="params">&lt;li&gt;</span> List Item3 <span class="params">&lt;/li&gt;</span></span><br><span class="line">      <span class="params">&lt;li&gt;</span> List Item4 <span class="params">&lt;/li&gt;</span></span><br><span class="line">   <span class="params">&lt;/ul&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line">div<span class="meta">#container ul会选择两个地方的ul</span></span><br><span class="line">div<span class="meta">#container&gt;ul只会选择外层的ul</span></span><br><span class="line"></span><br><span class="line">ul li会选择第一个li即List Item对应的Li</span><br></pre></td></tr></table></figure><h1 id="优先级及性能"><a class="markdownIt-Anchor" href="#优先级及性能"></a> 优先级及性能</h1><p>可能有多个选择器同时选中一个元素，这时候就需要考虑优先级来确定哪一个选择器生效了。一般来说越特殊优先级越高。我们通常使用1表示标签名选择器，10表示类选择器，100表示ID选择器。例如：</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">div</span>.test<span class="number">1</span> .span var 优先级 <span class="number">1</span>+<span class="number">10</span> +<span class="number">10</span> +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">span</span>#xxx .songs li 优先级<span class="number">1</span>+<span class="number">100</span> + <span class="number">10</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#xxx li 优先级 100 + 1</span></span><br></pre></td></tr></table></figure><p>一些建议：</p><ol><li>避免在关键地方使用通用选择器,如<code>.content &#123;color: red;&#125;</code>。这种需要匹配所有元素，开销极大</li><li>避免使用标签或类选择器限制id选择器：<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">避免使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">button</span><span class="meta">#backButton &#123;…&#125;</span></span><br><span class="line">避免使用</span><br><span class="line">.menu-left<span class="meta">#newMenuIcon &#123;…&#125;</span></span><br><span class="line">推荐使用</span><br><span class="line"><span class="meta">#backButton &#123;…&#125;</span></span><br><span class="line">推荐使用</span><br><span class="line"><span class="meta">#newMenuIcon &#123;…&#125;</span></span><br></pre></td></tr></table></figure></li><li>不要在类选择器前加标签： 和上面一样，增加了不必要的匹配</li></ol><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.w3cschool.cn/css/css-selector.html">参考1</a></p><p><a href="https://code.tutsplus.com/zh-hans/tutorials/the-30-css-selectors-you-must-memorize--net-16048">参考2</a></p><p><a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html">参考3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>B/B+树</title>
    <link href="https://xinhecuican.github.io/post/69629cf2.html"/>
    <id>https://xinhecuican.github.io/post/69629cf2.html</id>
    <published>2021-07-26T11:15:00.000Z</published>
    <updated>2021-08-01T08:08:47.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="缘起"><a class="markdownIt-Anchor" href="#缘起"></a> 缘起</h1><p>B树属于动态查找树，二叉树，平衡二叉树，红黑树都是动态查找树。<a href="https://xinhecuican.github.io/post/33cb1151.html">关于查找的基础内容可看</a>。他们的查找效率都可以达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msubsup><mi>g</mi><mn>2</mn><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">log_2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9425479999999999em;vertical-align:-0.24810799999999997em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span>，其中n是树的深度。</p><p>虽然他们的查找效率和遍历相比已经有很大提升了，但是和哈希相比又大大不如。QMap（红黑树为数据结构）在n=10之后效率就比不过QHash(哈希为数据结构)，越到后面差距越大。但是在数据库中却是使用B树作为数据结构。因为数据库除了考虑速度还要考虑空间，而hash对空间要求大。因此日常对空间不敏感的程序尽量使用hash。</p><p>前面已经说了，决定查找次数的是树的深度。假如有65535个数据，那么树的深度为16，那么平均查找深度为 (1 + 2 * 2 + 3 * 4 + 4 * 8 + 5 * 16 + … + 16 * 32768) / 65535 = 14.如果14个数据块位于2个不同的磁盘块上（因为是指针不是连续存储），那么就需要2次磁盘读取，所需时间便在毫秒以上。他和直接查找也显现不出太多优势。</p><p>因此减少树高就是非常必要的了。一种解决思路就是由二叉树变为多叉树，每一层容纳的数量变多了，树高自然就减少了。此外，各个分支如果树高大致相同毫无疑问平均查找次数是最少的，这就是平衡二叉树的思想。而如果将这两种思路结合就形成了多路平衡查找树也就是B树。</p><h1 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B树</h1><h2 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h2><p>一颗m阶的B树定义如下：</p><ol><li>每个节点最多有m-1个关键字（有m个子节点）</li><li>根节点最少有一个关键字</li><li>非根节点至少有ceil(m/2) - 1个关键字</li><li>所有比当前节点小的节点都在左子树，比当前节点大的节点都在右子树</li><li>所有的叶子节点都在同一层，也就是说他们的深度都相同（保证是平衡二叉树）</li></ol><p>例如: <img src="/images/b%E6%A0%911.png" alt="" /></p><p>这是一个四阶的二叉树，它最多可以容纳三个关键字但是最多可以有四个子树。为了保证效率在实际应用中阶数一般都大于100.它是将(key, value)作为一个整体看待的，key作为索引，value保存值。例如<code>map[39] = &quot;hello&quot;, 39是键，hello是值</code>。</p><h2 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h2><p>步骤：</p><ol><li>找到插入位置并插入</li><li>判断插入节点的关键字数目是否大于m-1，如果大于则进行第3步</li><li>将节点中间的key放到父节点中，然后将这个节点一分为2，左半边是新插入的key的左子树，右半边是右子树。然后在父节点进行第3步直到停止分裂。</li></ol><p><img src="/images/b%E6%A0%912.png" alt="" /></p><p>当前是是最多是4个关键字，然后插入插入一个边需要分裂，将中间的41往上提，并且将左半边和右半边作为这个节点左子节点和右子节点。</p><p><img src="/images/b%E6%A0%913.png" alt="" /></p><p><img src="/images/b%E6%A0%914.png" alt="" /></p><p>之后插入一个节点后，又需要分裂，但是这次将27往上提发现父节点也装不下了，将子节点分裂完成后父节点也会进行分裂。</p><p><img src="/images/b%E6%A0%915.png" alt="" /></p><h2 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h2><p>步骤：</p><ol><li>如果位于非叶子节点，则首先使用后继节点替代他（也就是右子树中最小的节点）</li><li>如果右子树节点数量大于m/2-1,则停止，否则进行第3步</li><li>如果左子树节点数量大于m/2-1,则将左子树中最大的往上提，将父节点往右子树中放， 停止。否则将父节点和它的子节点进行合并（左子树m/2-1，右子树不足m/2-1,父节点1合起来不超过m-1，成立)。然后再在父节点中进行第2步。</li></ol><p>听起来比较复杂，其实就是将从左右子树中找一个来代替被删除的节点，如果左子树不能就换右子树，如果两个都不能那么降级合并。</p><p><img src="/images/b%E6%A0%916.png" alt="" /></p><p>删除27,将28往上提</p><p><img src="/images/b%E6%A0%917.png" alt="" /></p><p>右子树小于ceil(5/2)-1=2,而左子树有三个还可以抽调，因此把26往上，28放到右子树，结束。</p><p><img src="/images/b%E6%A0%918.png" alt="" /></p><p>然后再删除32，变成<img src="/images/b%E6%A0%919.png" alt="" /></p><p>这时右子树不够了，然后左子树也不能再往上提，因此进行合并<img src="/images/b%E6%A0%9110.png" alt="" /></p><p>然后审查父亲，发现有两个，满足条件，因此结束。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define TREE_SUM <span class="number">5</span></span><br><span class="line">#define HALF_SUM (TREE_SUM % <span class="number">2</span> == <span class="number">0</span>) ? TREE_SUM / <span class="number">2</span> <span class="number">-1</span> : TREE_SUM / <span class="number">2</span>;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> data_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> node</span><br><span class="line">&#123;</span><br><span class="line">    node* parent;</span><br><span class="line">    node* children[TREE_SUM+<span class="number">1</span>];</span><br><span class="line">    data_type data[TREE_SUM];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">len</span>;</span><br><span class="line">    <span class="keyword">int</span> parent_loc;</span><br><span class="line">    node()</span><br><span class="line">    &#123;</span><br><span class="line">        parent = NULL;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;TREE_SUM<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i].key = <span class="number">0</span>;</span><br><span class="line">            data[i].value = <span class="number">0</span>;</span><br><span class="line">            children[i] = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        children[TREE_SUM<span class="number">-1</span>] = NULL;</span><br><span class="line">        <span class="built_in">len</span> = <span class="number">0</span>;</span><br><span class="line">        parent_loc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> find(<span class="keyword">int</span> key, node* root, node* ans_node=NULL, <span class="keyword">bool</span>* success_find=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    node* temp = root;</span><br><span class="line">    while(temp != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;temp.<span class="built_in">len</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.data[i].key == key)</span><br><span class="line">            &#123;</span><br><span class="line">                ans_node = temp;</span><br><span class="line">                *success_find = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp.data[i].key &gt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.children[i] != NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = temp.children[i];</span><br><span class="line">                    success = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans_node = temp;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!success)</span><br><span class="line">        &#123;</span><br><span class="line">            node = temp;</span><br><span class="line">            <span class="keyword">return</span> temp.<span class="built_in">len</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(data_type data, node* root)</span><br><span class="line">&#123;</span><br><span class="line">    node* insert_node;</span><br><span class="line">    <span class="keyword">int</span> loc = find(data.key, root, insert_node);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=insert_node.<span class="built_in">len</span><span class="number">-1</span>; i&gt;=loc; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        insert_node.data[i+<span class="number">1</span>] = insert_node.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=insert_node.<span class="built_in">len</span>; i&gt;loc; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        insert_node.children[i+<span class="number">1</span>] = insert_node.chilren[i];</span><br><span class="line">        insert_node.children[i+<span class="number">1</span>].parent_loc = i+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//还要先判断hildren[i+1]是否是NULL，下面也一样，为了方便查看而省去</span></span><br><span class="line">    &#125;</span><br><span class="line">    insert_node.data[loc] = data;</span><br><span class="line">    insert_node.children[loc+<span class="number">1</span>] = NULL;</span><br><span class="line">    insert_node.<span class="built_in">len</span>++;</span><br><span class="line">    while(insert_node.<span class="built_in">len</span> &gt;= TREE_SUM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(insert_node.parent == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            node* node1 = <span class="built_in">new</span> node();</span><br><span class="line">            node* node2 = <span class="built_in">new</span> node();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;insert_node.<span class="built_in">len</span>/<span class="number">2</span>; i++)<span class="comment">//左子树</span></span><br><span class="line">            &#123;</span><br><span class="line">                node1.children[i] = insert_node.children[i];</span><br><span class="line">                node1.data[i] = insert_node.data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            node1.data[insert_node.<span class="built_in">len</span>/<span class="number">2</span>] = insert_node.data[insert_node.<span class="built_in">len</span>/<span class="number">2</span>];</span><br><span class="line">            node1.parent = insert_node;</span><br><span class="line">            node1.<span class="built_in">len</span> = insert_node.<span class="built_in">len</span>/<span class="number">2</span>;</span><br><span class="line">            node1.parent_loc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=insert_node.<span class="built_in">len</span>/<span class="number">2</span>+<span class="number">1</span>; i&lt;insert_node.<span class="built_in">len</span>; i++)<span class="comment">//右子树</span></span><br><span class="line">            &#123;</span><br><span class="line">                node2.children[i-insert_node.<span class="built_in">len</span>/<span class="number">2</span><span class="number">-1</span>] = insert_node.children[i];</span><br><span class="line">                node2.children.parent_loc = i - insert_node.<span class="built_in">len</span>/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">                node2.data[i-insert_node.<span class="built_in">len</span>/<span class="number">2</span><span class="number">-1</span>] = insert_node.data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            node2.parent = insert_node;</span><br><span class="line">            node2.<span class="built_in">len</span> = insert_node.<span class="built_in">len</span> - insert_node.<span class="built_in">len</span>/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            node2.parent_loc = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            insert_node.<span class="built_in">len</span> = <span class="number">1</span>;<span class="comment">//根</span></span><br><span class="line">            insert_node.data[<span class="number">0</span>] = insert_node.data[insert_node.<span class="built_in">len</span>/<span class="number">2</span>];</span><br><span class="line">            insert_node.children[<span class="number">0</span>] = node1;</span><br><span class="line">            insert_node.children[<span class="number">1</span>] = node2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node* new_node = <span class="built_in">new</span> node();</span><br><span class="line">            node* parent = insert_node.parent;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=parent.<span class="built_in">len</span><span class="number">-1</span>; i&gt;=insert_node.parent_loc; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                parent.data[i+<span class="number">1</span>] = parent.data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=parent.<span class="built_in">len</span>; i&gt;insert_node.parent_loc; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                parent.children[i+<span class="number">1</span>] = parent.children[i];</span><br><span class="line">                parent.children[i+<span class="number">1</span>].parent_loc = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent.data[insert_node.parent_loc] = insert_node.data[insert_node.<span class="built_in">len</span>/<span class="number">2</span>];</span><br><span class="line">            parent.children[insert_node.parent_loc+<span class="number">1</span>] = new_node;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=insert_node.<span class="built_in">len</span>/<span class="number">2</span>+<span class="number">1</span>; i&lt;insert_node.<span class="built_in">len</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                new_node.data[i-insert_node.<span class="built_in">len</span>/<span class="number">2</span><span class="number">-1</span>] = insert_node.data[i];</span><br><span class="line">                new_node.children[i-insert_node.<span class="built_in">len</span>/<span class="number">2</span><span class="number">-1</span>] = insert_node.children[i];</span><br><span class="line">                new_node.children.parent_loc = i - insert_node.<span class="built_in">len</span>/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_node.<span class="built_in">len</span> = insert_node.<span class="built_in">len</span> - insert_node.<span class="built_in">len</span>/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            new_node.children[new_node.<span class="built_in">len</span>] = insert_node.children[insert_node.<span class="built_in">len</span>];</span><br><span class="line">            new_node.children[new_node.<span class="built_in">len</span>].parent_loc = new_node.<span class="built_in">len</span>;</span><br><span class="line">            new_node.parent = insert_node.parent;</span><br><span class="line">            new_node.parent_loc = insert_node.parent_loc + <span class="number">1</span>;</span><br><span class="line">            parent.<span class="built_in">len</span>++;</span><br><span class="line">            insert_node = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(<span class="keyword">int</span> key, node* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    node* remove_node;</span><br><span class="line">    <span class="keyword">int</span> loc = find(key, root, remove_node, &amp;success);</span><br><span class="line">    <span class="keyword">if</span>(!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* now_node = remove_node.children[loc+<span class="number">1</span>];</span><br><span class="line">    while(now_node != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(now_node.children[<span class="number">0</span>] == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now_node = now_node.children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(now_node == NULL)<span class="comment">//右子树为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        now_node = remove_node.children[loc];</span><br><span class="line">        while(now_node != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now_node.children[<span class="number">0</span>] == NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            now_node = now_node.children[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now_node == NULL)<span class="comment">//叶子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            now_node = remove_node;</span><br><span class="line">            <span class="comment">//删除loc位置的节点并重新调整关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            remove_node.data[loc] = now_node.data[now_node.<span class="built_in">len</span><span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//调整now_node的关系</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        remove_node.data[loc] = now_node.data[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//调整关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    while(now_node.<span class="built_in">len</span> &lt; HALF_SUM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(now_node.parent_loc != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now_node.parent.children[now_node.parent_loc<span class="number">-1</span>].<span class="built_in">len</span> &gt; HALF_SUM)<span class="comment">//左子树可以提供,先要判断左子树是否为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将左子树最大的节往上提，父节点往下</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now_node.parent_loc != now_node.parent.<span class="built_in">len</span>+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now_node.parent.children[now_node.parent_loc+<span class="number">1</span>].<span class="built_in">len</span> &gt; HALF_SUM)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//和上面类似</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两边子树都无法提供，进行合成并转到父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="b树-2"><a class="markdownIt-Anchor" href="#b树-2"></a> B+树</h1><p>B+树基本结构和B树相同，并且有所延伸</p><ol><li>B+树分为内部节点（索引节点）和叶子节点，内部节点只负责索引，不保存数据，由叶子节点保存数据</li><li>每个叶子节点都有指向相邻叶子节点的指针（链表），并且从小到大排列</li></ol><p><img src="/images/b%E6%A0%9111.png" alt="" /></p><h2 id="插入-2"><a class="markdownIt-Anchor" href="#插入-2"></a> 插入</h2><ol><li>根据key找到插入位置，如果插入后&lt;=m-1,则结束。否则分裂节点。前m/2变为左子树，第m/2+1个节点的key（在子树中节点还存在）拉到父节点中，然后把m/2+1到m-1的节点的作为右子树。当前节点到父节点进行第2步</li><li>对于索引类节点，进行分裂时作为父节点的节点不在子树中保留，和B树类似</li></ol><p>B+树插入和B树最大的不同是在叶子节点的数据是不会删除的，这样带来一个好处是遍历速度明显加快，假如保存每个叶子节点所拥有的数据可以直接达到类似于索引的效果。缺点是会有一些相同的记录，带来了空间上的浪费。</p><p><img src="/images/b%E6%A0%9112.png" alt="" /></p><p>假设这是初始情况，现在插入16.中间节点是10，将10作为索引放入父节点中。m为5，m/2=2。因此左子树有2个元素，右子树有三个。</p><p><img src="/images/b%E6%A0%9113.png" alt="" /></p><h2 id="删除-2"><a class="markdownIt-Anchor" href="#删除-2"></a> 删除</h2><ol><li>删除叶子节点中的key，如果大于ceil(m)/2 - 1，则删除结束，否则进行第二步</li><li>如果兄弟节点有富余，向兄弟节点借（拿）一个记录，并且他们的父节点变成拿的那个节点。如果没有富余到第3步</li><li>进行合并，删除索引节点并且左右子树合并成一个。然后检查索引节点是否满足要求，之后和B树相同。</li></ol><blockquote><p>问： 如果删除的节点正好是索引节点有关系吗？</p></blockquote><p>因为索引节点正常情况下是右子树中最小的那个，删除之后左子树还是都比父节点小，右子树比父节点大，并没有破坏关系，可以正常插入删除，因此没有影响。</p><p><img src="/images/b%E6%A0%9114.png" alt="" /></p><p>现在删除7，因为左子树正好是m/2-1，因此只能合并，删除7的索引合并节点变成</p><p><img src="/images/b%E6%A0%9115.png" alt="" /></p><p>之后合并索引节点变成</p><p><img src="/images/b%E6%A0%9116.png" alt="" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.cnblogs.com/nullzx/p/8729425.html">B树和B+树的插入、删除图文详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;缘起&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="数据结构" scheme="https://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>简截代码结构</title>
    <link href="https://xinhecuican.github.io/post/35b71592.html"/>
    <id>https://xinhecuican.github.io/post/35b71592.html</id>
    <published>2021-07-23T11:20:00.000Z</published>
    <updated>2021-08-01T10:40:57.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="工具及基础"><a class="markdownIt-Anchor" href="#工具及基础"></a> 工具及基础</h1><p>本软件使用qt5.9.9。IDE推荐qt自带的qtcreater,它的帮助是真的好用，可以节省大量的查阅资料时间。</p><p>左边是代码，在insert上按F1即可出现右边帮助<br /><img src="/images/%E7%AE%80%E6%88%AA7.png" alt="" /></p><p>qt基础需要了解<strong>qt元对象系统</strong>、<strong>qt信号槽系统</strong>和<strong>qt内存管理</strong>。</p><h2 id="信号槽"><a class="markdownIt-Anchor" href="#信号槽"></a> 信号槽</h2><p>信号槽是qt特有的信号传递方式。在子类和父类之间如何进行信号传递呢？</p><ol><li>父类和子类相互引用<br /><a href="https://xinhecuican.github.io/post/cbf07f5d.html">父类与子类相互引用解决方法</a></li><li>定义接口<br />定义子类需要使用的接口并且由父类实现，并且把父类的指针以接口的形式传递给子类。这样子类就可以使用父类的部分函数。这样避免了相互引用但是容易引起代码结构混乱，本代码中new_capture/Widgets/Ipoint_position_change就是使用这种思想</li><li>使用信号槽</li></ol><p>信号槽可以理解为第二种方法，只是qt在后台帮我们生成了许多代码。它首先需要定义一个信号，然后再适当的时机抛出这个信号，然后等待其他代码接收。</p><p><strong>发出信号</strong></p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIST_ITEM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_ITEM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QListWidgetItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List_item</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT<span class="comment">//想要定义信号必须申明O_OBJECT宏，它相当于注册到了qt的管理系统中，这样qt才可以找到它。也可以认为是添加了这个宏才加入链接。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">button_type</span>&#123;</span>UP, DOWN, CLOSE, APPEND&#125;;</span><br><span class="line">    List_item();</span><br><span class="line">    List_item(QWidget* parent, QString <span class="built_in">text</span>, <span class="keyword">bool</span> useable);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(QString name)</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">get_name</span><span class="params">()</span></span>;</span><br><span class="line">signals:<span class="comment">//定义信号，信号可以使public，也可以是private，因为它一定是给其他人使用的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">text_change</span><span class="params">(QString <span class="built_in">text</span>)</span></span>;<span class="comment">//参数随便，返回值一定是void</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">button_click</span><span class="params">(button_type index)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLineEdit* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LIST_ITEM_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//截取List_item.cpp中的部分内容</span></span><br><span class="line">    up_button-&gt;setIcon(QIcon(<span class="string">&quot;:/image/up.png&quot;</span>));</span><br><span class="line">    up_button-&gt;setIconSize(QSize(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    QToolButton* down_button = <span class="keyword">new</span> QToolButton(<span class="keyword">this</span>);</span><br><span class="line">    down_button-&gt;setIcon(QIcon(<span class="string">&quot;:/image/down.png&quot;</span>));</span><br><span class="line">    down_button-&gt;setIconSize(QSize(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="built_in">connect</span>(up_button, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit button_click(UP);<span class="comment">//发出信号，参数是UP</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(down_button, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit button_click(DOWN);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><strong>接收信号</strong></p><p>接收信号需要使用slots槽，本代码中多使用lambda表达式，因此主要介绍lambda表达式的实现方式。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//connect是连接信号和槽的函数，list_widget是信号的发出者，它的类型是上面的List_item</span></span><br><span class="line"><span class="comment">//text_change就是上面声明的信号</span></span><br><span class="line"><span class="comment">//this是信号的接受者</span></span><br><span class="line"><span class="comment">//最后一个参数是接收到信号后执行的函数，这里使用c++ lambda表达式。</span></span><br><span class="line"><span class="comment">//可以认为使用这个函数就是生命了一个接口，父类实现了这个接口并且把它传给子类，子类会调用这个接口(发射信号时)</span></span><br><span class="line"><span class="built_in">connect</span>(list_widget, &amp;List_item::text_change, <span class="keyword">this</span>, [=](QString <span class="built_in">text</span>)&#123;</span><br><span class="line">        emit text_change(<span class="keyword">this</span>-&gt;indexFromItem(item).row(), <span class="built_in">text</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>当然上面只是类比，信号槽系统优点还有它的信号和槽是多对多的关系，可以有一个信号匹配多个槽。</p><h2 id="层次管理"><a class="markdownIt-Anchor" href="#层次管理"></a> 层次管理</h2><p>窗口化编程一般是建立窗口，然后窗口中添加各种小部件，例如文本框(QLineEdit)、按钮（QPushButton）、滚动区域（QScrollArea）等。并且他们之间的排布可以用QLayout进行管理。大部件如窗口可以添加小部件如QScrollArea，小部件中还可以添加小部件如QLabel（标签）。这些都可以在网上找到具体用法。</p><p>qt中的layout主要有QHBoxLayout、QVBoxLayout、QGridLayout。一般来说可以先加载一个QVBoxLayout(垂直排列），然后再添加若干个QHBoxLayout(水平排列)。</p><p>QLayout构建时如果添加了父类那么相当于调用了<code>parent-&gt;setLayout(layout)</code>,这时再调用setLayout(layout)就会出现一些警告，并且有可能导致无法添加组件进入layout的问题。</p><h1 id="hook"><a class="markdownIt-Anchor" href="#hook"></a> Hook</h1><p>Hook其实是另一个项目，为了好看也把它拉到主项目中。</p><p>Hook是windows消息钩子，它包括鼠标钩子和键盘钩子，可以使用它勾取一些键盘和鼠标的信息。比如说哪个按键按下和单击、双击等。它是一个动态库并且导入到主程序中</p><h1 id="mainwindow"><a class="markdownIt-Anchor" href="#mainwindow"></a> MainWindow</h1><p>main和MainWindow负责一些重要的初始化。</p><p>main负责配置加载，快捷键加载，消息过滤器注册，反射（Reflect)注册等。</p><p>MainWindow负责更新检测，内存清理检测、键盘钩子注入、开机启动等。</p><p><strong>内存清理检测</strong></p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">QTimer* timer = <span class="keyword">new</span> <span class="constructor">QTimer(<span class="params">this</span>)</span>;</span><br><span class="line"><span class="comment">//window_manager_thread是实际执行内存清理的函数，它位于Window_manager中</span></span><br><span class="line">connect(timer, <span class="constructor">SIGNAL(<span class="params">timeout</span>()</span>), this, <span class="constructor">SLOT(<span class="params">window_manager_thread</span>()</span>));</span><br><span class="line"><span class="built_in">int</span> time = Config::get<span class="constructor">_config(Config::<span class="params">clear_interval</span>)</span>;</span><br><span class="line">timer-&gt;start(time<span class="operator"> * </span><span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h1 id="base"><a class="markdownIt-Anchor" href="#base"></a> Base</h1><h2 id="record_element"><a class="markdownIt-Anchor" href="#record_element"></a> Record_element</h2><p>执行撤销和恢复功能的基类</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">undo</span><span class="params">(<span class="keyword">int</span> index=<span class="number">0</span>)</span></span>=<span class="number">0</span>;<span class="comment">//撤销,index和返回值都是为了橡皮擦的擦除功能而建立的，返回值表示当前index是否有效，它的管理类为Recorder，在Paint/Widgets中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">redo</span><span class="params">(<span class="keyword">int</span> index=<span class="number">0</span>)</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="serializable"><a class="markdownIt-Anchor" href="#serializable"></a> Serializable</h2><p>序列化和反序列化的基类。</p><p><strong>函数</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">实现json序列化需要实现这两个函数，他们会在Helper/Serialize中调用</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">serialized</span><span class="params">(QJsonObject* json)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">deserialized</span><span class="params">(QJsonObject* json)</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="tab_base"><a class="markdownIt-Anchor" href="#tab_base"></a> Tab_base</h2><p>设置中widget的基类，每一个tab_widget就是设置中的一行。具体实现在Panel(Setting_panel)/Widgets/…_tab.</p><ul><li>virtual QString get_name()=0;： 获得tab的名字</li><li>virtual int get_begin_index()=0; 获得tab的序号</li><li>virtual int get_default_index()=0; 获得tab的序号加上tab的当前下拉列表中的序号(只在Combo_tab中使用，也就是下拉列表）</li><li>virtual void reset()=0; 重置，如果没有保存就退出需要重置为初始值</li></ul><h2 id="window_base"><a class="markdownIt-Anchor" href="#window_base"></a> Window_base</h2><p>Window_base是各个Window的基类，Window_manager通过这个类定义了管理Window需要的动作。Window包括MainWindow、Capture_window、Paint_window、Setting</p><ul><li>virtual void on_window_select(): 当window选择时调用</li><li>virtual void on_window_cancal(): 当window隐藏时调用</li><li>virtual void on_window_close()： 当window销毁时调用</li><li>virtual void load_key_event(QString name)： 载入快捷键，name是window的名字，例如MainWindow</li></ul><h1 id="helper"><a class="markdownIt-Anchor" href="#helper"></a> Helper</h1><h2 id="debug"><a class="markdownIt-Anchor" href="#debug"></a> debug</h2><ul><li>static void show_error_message(QString message); 显示错误信息的弹出框</li><li>static void debug_print_warning(QString message); 在控制台显示错误信息</li></ul><h2 id="enumreflect"><a class="markdownIt-Anchor" href="#enumreflect"></a> EnumReflect</h2><p>EnumReflect是构建Enum的帮助类，它可以构建Enum时生成Enum的字符串。</p><ul><li>QString eto_string(enum_type type): 通过enum找到对应字符串</li><li>enum_type efrom_string(std::string str): 从字符串找到对应的enum</li><li>MAKE_ENUM: 这是一个宏，通过它可以生成上面两个函数。具体使用例子可以看Manager/config</li><li>DEFINE_STRING(class_name): 如果这个enum在类中，由于MAKE_ENUM中使用了static，需要在类外面初始化，因此需要在类外使用DEFINE_STRING宏</li></ul><h2 id="mstring"><a class="markdownIt-Anchor" href="#mstring"></a> mstring</h2><p>MString是为了翻译的一个帮助类，它内部有一个哈希表维护着字符串ID到字符串的映射。</p><p>MString的字符串书写规则为<code>&quot;&#123;ID&#125;content&quot;</code>,如果匹配到了ID，则会使用ID对应的字符串，如果没有匹配到则使用content。</p><ul><li>QString search(QString str): 搜索字符串，可以使用上面的形式，也可以不用加<code>&#123;&#125;</code>，这样会直接返回原字符串</li><li>void load_from_file(QString path): path是对应翻译文件的目录名，它的使用在Window_base和Config中</li></ul><h2 id="plist"><a class="markdownIt-Anchor" href="#plist"></a> plist</h2><p>是QList的扩展，如果它容纳的是指针的话可以使用对应函数快速删除指针并且将她移除列表。</p><ul><li>remove_one(int index):</li><li>remove_range(int begin, int end)</li><li>remove_all()：</li></ul><h2 id="reflect"><a class="markdownIt-Anchor" href="#reflect"></a> Reflect</h2><p>Reflect是反射类，即根据字符串获得函数或类实例。它借助了qt的元对象系统，使用它的条件有：</p><ol><li>继承QWidget为基础的类并且添加Q_OBJECT</li><li>构造函数前添加Q_INVOKABLE</li><li>调用registerClass</li></ol><p>完成上面的步骤之后就可以使用newInstance获得对象实例了。例如：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window_manager::create_window</span><span class="params">(QString name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(window_list.<span class="built_in">find</span>(name) == window_list.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="string">&quot;MainWindow&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            window_list[name] = create_data(<span class="keyword">static_cast</span>&lt;Window_base*&gt;(Reflect::newInstance(name)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(window_list.<span class="built_in">find</span>(<span class="string">&quot;MainWindow&quot;</span>) == window_list.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                window_list[<span class="string">&quot;MainWindow&quot;</span>] = create_data</span><br><span class="line">                        (<span class="keyword">static_cast</span>&lt;Window_base*&gt;(Reflect::newInstance(<span class="string">&quot;MainWindow&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            window_list[name] = create_data(<span class="keyword">static_cast</span>&lt;Window_base*&gt;(</span><br><span class="line">                            Reflect::newInstance(name, Q_ARG(QWidget*, window_list[<span class="string">&quot;MainWindow&quot;</span>].window))));<span class="comment">//一个参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serialize"><a class="markdownIt-Anchor" href="#serialize"></a> Serialize</h2><p>序列化类，可以增添，获取，写入等。</p><ul><li>static void serialize(QString path, Serializable* point): 写json文件到path中，会调用point的serailized函数</li><li>static bool deserialize(QString path, Serializable* point):返回值表示读文件成功与否</li><li>static void append(QString path, Serializable* point): 修改内容到文件中</li><li>static bool deserialize_data(QByteArray data, Serializable* point)： 从data中获取信息</li></ul><h1 id="manager"><a class="markdownIt-Anchor" href="#manager"></a> Manager</h1><h2 id="config"><a class="markdownIt-Anchor" href="#config"></a> Config</h2><h1 id="upgrateupdate"><a class="markdownIt-Anchor" href="#upgrateupdate"></a> Upgrate（Update）</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;工具及基础&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简截</title>
    <link href="https://xinhecuican.github.io/post/f0fbe9f2.html"/>
    <id>https://xinhecuican.github.io/post/f0fbe9f2.html</id>
    <published>2021-07-23T09:51:32.000Z</published>
    <updated>2021-09-01T00:36:13.353Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><p>简截是一款截图软件。它的主要功能是图片透明化。</p><table><thead><tr><th>透明化前</th><th>透明化后</th></tr></thead><tbody><tr><td><img src="/images/简截1.png"></td><td><img src="/images/简截2.png"></td></tr></tbody></table><p>此外他还支持多种截图模式并且可以图片上编辑</p><h1 id="下载及代码"><a class="markdownIt-Anchor" href="#下载及代码"></a> 下载及代码</h1><div class="btns rounded grid2">            <a class="button" href='https://github.com/xinhecuican/easy-capture/releases/download/main/easy_capture_0_2_2.exe' title='直接下载'><i class='fas fa-download'></i>直接下载</a><a class="button" href='https://pan.baidu.com/s/1grB-rIze5YSn0pCJF0GKlQ' title='百度网盘(提取码6cx0)'><i class='fas fa-book-open'></i>百度网盘(提取码6cx0)</a>          </div><details ><summary> 历史版本 </summary>              <div class='content'>              <ul><li>0.2.0： <a href="https://pan.baidu.com/s/1ZwhngEa8pEf1hfaJlub3UQ">https://pan.baidu.com/s/1ZwhngEa8pEf1hfaJlub3UQ</a> （提取码jh1b）</li><li>0.1.0: <a href="https://pan.baidu.com/s/1N3WG0Qxfym1VLl8A0eb-xQ">https://pan.baidu.com/s/1N3WG0Qxfym1VLl8A0eb-xQ</a> (提取码h2yn)</li></ul>              </div>            </details><p><a href="https://github.com/xinhecuican/easy-capture">github地址页</a></p><p><a href="https://xinhecuican.github.io/post/35b71592.html">源码结构及一些编写心得</a></p><p>欢迎拿走源码自己修改。也可以在评论区提意见（我设置了邮箱提醒）。</p><h1 id="功能介绍"><a class="markdownIt-Anchor" href="#功能介绍"></a> 功能介绍</h1><h2 id="基础功能"><a class="markdownIt-Anchor" href="#基础功能"></a> 基础功能</h2><blockquote><p>支持开机自启，自动更新，历史记录保存，自动复制到剪切板等功能</p></blockquote><h2 id="截图"><a class="markdownIt-Anchor" href="#截图"></a> 截图</h2><p>由于本人主要使用矩形区域截图，因此矩形区域的模式最多。它支持单个区域截图，多个分离区域截图，多个可合并区域截图。</p><p>按中键可以快速确认，也可以使用屏幕上的确认按钮和enter键。返回可以使用esc键。切换模式使用1,2,3键。快捷键可以在设置中进行调整</p><p><strong>分离区域截图</strong></p><p><img src="/images/%E7%AE%80%E6%88%AA3.gif" alt="" /></p><p><strong>可合并区域截图</strong></p><p><img src="/images/%E7%AE%80%E6%88%AA4.gif" alt="" /></p><p>多个区域截图主要是为了截取一些相关但不相连的部分。</p><h3 id="自由截图-滚动截图"><a class="markdownIt-Anchor" href="#自由截图-滚动截图"></a> 自由截图、滚动截图</h3><p>自由截图是画出一片区域，这片区域可以不闭合，画完会立刻确认。</p><p><img src="/images/%E7%AE%80%E6%88%AA5.gif" alt="" /></p><p>滚动截图</p><p><img src="/images/%E7%AE%80%E6%88%AA8.gif" alt="" /></p><h2 id="绘制"><a class="markdownIt-Anchor" href="#绘制"></a> 绘制</h2><p>当前仅支持笔和荧光笔绘制，并且支持撤销、恢复和擦除。</p><p><img src="/images/%E7%AE%80%E6%88%AA6.gif" alt="" /></p><h2 id="透明"><a class="markdownIt-Anchor" href="#透明"></a> 透明</h2><p>目前仅可以做到对某一个色素透明，对于渐变和拍屏无效。并且由于文字都是由不同种类像素组成因此无法做到选取文字（正好下学期有图像处理，看看通过反锯齿可以直接把文字的范围弄出来）。</p><h1 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键"></a> 快捷键</h1><p>鼠标：</p><table><thead><tr><th>区域</th><th>动作</th><th>作用</th></tr></thead><tbody><tr><td>截图</td><td>左键</td><td>在区域上时为移动区域，不在为创建新区域</td></tr><tr><td>截图</td><td>中键</td><td>确认</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>区域</th><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>全局</td><td>Ctrl+F1</td><td>如果当前为隐藏，则唤醒并跳转到截图窗口。否则无效</td></tr><tr><td>主窗口</td><td>Ctrl+N</td><td>打开截图窗口</td></tr><tr><td>截图窗口</td><td>1</td><td>只允许单个矩形区域</td></tr><tr><td>截图窗口</td><td>2</td><td>允许多个分离的矩形区域</td></tr><tr><td>截图窗口</td><td>3</td><td>允许多个可合并的矩形区域</td></tr><tr><td>截图窗口</td><td>Ctrl</td><td>移动所有矩形区域</td></tr><tr><td>截图窗口</td><td>Esc</td><td>退出</td></tr><tr><td>截图窗口</td><td>Enter</td><td>确认</td></tr><tr><td>绘图窗口</td><td>Ctrl+S</td><td>保存</td></tr><tr><td>绘图窗口</td><td>Ctrl+Z</td><td>撤销</td></tr><tr><td>绘图窗口</td><td>Ctrl+X</td><td>恢复</td></tr><tr><td>绘图窗口</td><td>Ctrl+N</td><td>跳转到截图窗口</td></tr></tbody></table><h1 id="更新计划"><a class="markdownIt-Anchor" href="#更新计划"></a> 更新计划</h1><ol><li>完成滚动截屏</li><li>修bug，重构部分代码</li><li>完善绘图区域，添加文本框，箭头和水印图片，支持旋转</li><li>完成UI_manager，可以利用qss(和css语法类似)修改样式并且提供主题</li><li>完善透明度选择，除了删除某些像素外可以选择保留哪些像素，并支持渐变颜色删除。</li></ol><h1 id="翻译"><a class="markdownIt-Anchor" href="#翻译"></a> 翻译</h1><p>本软件提供了便利的翻译方式，翻译文件位于Data/Languages下。翻译方式为将该目录下chinese.xml复制并且重命名为对应语言，例如english.xml。然后将文件里面的中文换成对应语言。以Data/Languages/MainWindow/chinese.xml为例</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>xml <span class="built_in">version</span>=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span><span class="meta">?&gt;</span></span><br><span class="line">&lt;strings language=<span class="string">&quot;chinese&quot;</span><span class="comment">&gt;//将language标签替换成对应语言，目前只有english,如果想翻译其他语言请先和作者联系</span></span><br><span class="line">    &lt;<span class="keyword">string</span> id=<span class="string">&quot;cR3jOHb9Qw&quot;</span> <span class="keyword">text</span>=<span class="string">&quot;新建&quot;</span>/<span class="comment">&gt;//中文翻译为对应语言</span></span><br><span class="line">    &lt;<span class="keyword">string</span> id=<span class="string">&quot;7yUWnx82jI&quot;</span> <span class="keyword">text</span>=<span class="string">&quot;模式&quot;</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">string</span> id=<span class="string">&quot;OBwjJUhTkh&quot;</span> <span class="keyword">text</span>=<span class="string">&quot;矩形窗口&quot;</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">string</span> id=<span class="string">&quot;fnGapBU4vo&quot;</span> <span class="keyword">text</span>=<span class="string">&quot;自由截图&quot;</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">string</span> id=<span class="string">&quot;ETY295cnab&quot;</span> <span class="keyword">text</span>=<span class="string">&quot;滚动截图&quot;</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">string</span> id=<span class="string">&quot;rzdUgOw26Y&quot;</span> <span class="keyword">text</span>=<span class="string">&quot;活动窗口截屏&quot;</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">string</span> id=<span class="string">&quot;FHFzLMcLYa&quot;</span> <span class="keyword">text</span>=<span class="string">&quot;全屏&quot;</span>/&gt;</span><br><span class="line">&lt;/strings&gt;</span><br></pre></td></tr></table></figure><p>如果先练练英文或其他语言的可以尝试一下</p><h1 id="bug提交及反馈"><a class="markdownIt-Anchor" href="#bug提交及反馈"></a> bug提交及反馈</h1><p>bug可以在下方评论区提交，也可以在github上提交。提交格式为：<code>[版本]+叙述，如果有报错最好把完整报错发过来</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="https://xinhecuican.github.io/post/f75e92e9.html"/>
    <id>https://xinhecuican.github.io/post/f75e92e9.html</id>
    <published>2021-07-21T12:28:00.000Z</published>
    <updated>2021-07-31T07:20:51.808Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><p>DOM（文档对象模型）是HTML和XML的编程接口，可以通过它查找和修改每一个节点的属性。DOM的表现形式类似于一棵树</p><p><img src="/images/dom1.png" alt="" /></p><p>document节点是每个文档的根节点，而html是它唯一的子节点，其他元素都在这个文档内。总共有12中类型的节点。这些节点统一由Node定义。</p><ul><li>Node.nodeType：定义了节点的类型，总共有十二种类型<ul><li>Node.ELEMENT_NODE(1)： 元素，如html，head等</li><li>Node.ATTRIBUTE_NODE(2): 属性，例如图中的href</li><li>Node.TEXT_NODE(3): 元素中间的文本</li><li>Node.CDATA_SECTION_NODE(4)</li><li>Node.ENTITY_REFERENCE_NODE(5)</li><li>Node.ENTITY_NODE(6)</li><li>Node.PROCESSING_INSTRUCTION_NODE(7)</li><li>Node.COMMENT_NODE(8)</li><li>Node.DOCUMENT_NODE(9)</li><li>Node.DOCUMENT_TYPE_NODE(10)</li><li>Node.DOCUMENT_FRAGMENT_NODE(11)</li><li>Node.NOTATION_NODE(12)</li></ul></li></ul><p><strong>访问节点：</strong></p><ul><li>Node.nodeName: 节点的名字，例如html，href等</li><li>Node.nodeValue: 节点的值，对于元素而言，节点的值始终是null</li><li>Node.childNodes: 节点的所有子节点</li><li>Node.parentNode: 父节点</li><li>Node.previousSibling: 前一个兄弟节点</li><li>Node.nextSibling:</li><li>Node.firstChild</li><li>Node.lastChild</li><li>Node.hasChildNodes():</li><li>childElementCount: 返回子元素的数量(不包括文本节点和注释）</li><li>firstElementChild: 第一个元素节点</li><li>lastElementChild:</li><li>previousElementSibling: 后一个Element节点</li><li>classList: 获得该节点下所有类名</li></ul><p><strong>操纵节点：</strong></p><ul><li>Node Node.appendChild(): 添加子节点到末尾，返回新添加的节点。如果添加原来就在DOM树上的节点作用相当于移动。</li><li>Node Node.insertBefore(child, now): 在now前插入</li><li>Node Node.replaceChild(new_node, now_node): 将现有节点替换成新节点</li><li>Node Node.removeChild(node): 移除该节点并返回。</li><li>Node Node.cloneNode(bool is_deep_clone): 复制节点，参数为是否深复制。如果是深复制，那么会复制整个dom树。否则只会复制当前节点并不指定父节点</li></ul><h2 id="查找元素"><a class="markdownIt-Anchor" href="#查找元素"></a> 查找元素</h2><p>可以通过getElementById()和getElementsByTagName()查找特定的元素。</p><ul><li>getElementById(id): 通过id查找对应的元素，例如 <figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">img</span>&gt;</span></span></span><br><span class="line"><span class="keyword">let</span> img =<span class="built_in"> document</span>.getElementById(<span class="string">&quot;test);</span></span><br><span class="line"><span class="string">console.log(img.src);</span></span><br></pre></td></tr></table></figure></li><li>getElementsByTagName(): 查找该文档下所有该元素名的元素，如<code>getElementsByTagName(&quot;p&quot;);</code>。此外，获得之后可以通过中括号访问对应name的元素。以下面的文档为例：<code>let inputs = getElementsByTagName(&quot;input&quot;); console.log(inputs[&quot;color&quot;]);</code></li><li>getElementByClassName(): 通过类名获得元素</li><li>getElementsByName()： 通过name获得元素，例如 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Which color do you Prefer?<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">id</span>=<span class="string">&quot;colorRed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;colorRed&quot;</span>&gt;</span>Red<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">id</span>=<span class="string">&quot;colorGreen&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;colorGreen&quot;</span>&gt;</span>Green<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">getElementsByName(&quot;color&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>document.anchors: 返回所有<strong>带name属性</strong>的<code>&lt;a&gt;</code>元素</li><li>document.images: 返回所有<code>&lt;img&gt;</code>元素</li><li>document.links: 返回所有<strong>带href</strong>的<code>&lt;a&gt;</code>元素</li></ul><h2 id="焦点管理"><a class="markdownIt-Anchor" href="#焦点管理"></a> 焦点管理</h2><p>通过<code>document.activeElement</code>可以获得当前获得焦点的DOM元素。并且可以通过捕捉用户输入然后调用focus()方法让某个元素获得焦点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line">button.focus();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement == button);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>默认情况下，加载完会设置body为焦点元素，没有加载完时是null。</p><p>使用hasFocus()方法判断是否有焦点</p><h2 id="element类型"><a class="markdownIt-Anchor" href="#element类型"></a> Element类型</h2><p>element是元素类型，例如li，p，html等都是元素。他们具有以下特征：</p><ol><li>nodeType=1</li><li>nodeName是元素标签名，也可以使用tagName进行获取</li><li>nodeValue=null</li><li>parentNode=Document或Element</li><li>子节点可以使Element、Text、Comment（注释）等</li></ol><p>HTMLElement继承于Element，他除了上述属性外还有一些额外的属性：</p><ul><li>id： 标识符</li><li>title： 一些额外信息，以提示条的形式展示</li><li>lang： 语言，很少用</li><li>dir： 语言书写方向，有&quot;ltr&quot;和&quot;rtl&quot;</li><li>className: 也就是class属性，由于class是关键字所以使用className代替</li></ul><p><strong>属性操作</strong></p><p>属性也就是元素中的一些标签，如src，id，class等。js提供了一系列的方法来操作属性。属性名不分大小写</p><ul><li>getAttribute(name): 通过属性名获得属性，例如<code>element.getAttribute(&quot;id&quot;);</code>。style属性会返回一个css字符串，而通过DOM访问会返回一个css对象。事件处理函数相同，如果使用getAttribute()会返回函数的字符串，而使用DOM访问会返回函数</li><li>setAttribute(name, value): 设置属性</li><li>insertAdjacentHTML(location, str): 在某个位置插入html字符串，location有<ul><li>beforebegin: 插入当前元素的前面，作为一个兄弟节点</li><li>afterbegin： 插入当前元素内部，作为第一个子节点</li><li>beforeend： 当前元素后面</li><li>afterend： 当前元素最后一个子节点</li></ul></li></ul><p>此外，我们可以直接为DOM对象中的属性赋值，例如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">div.id</span> = <span class="string">&quot;other_id&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">div.align</span> = <span class="string">&quot;left&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>Element提供了attributes操作所有元素的属性。它使NamedNodeMap类型，每个属性都是里面的一个节点。每个节点都可以使用nodeValue获得值或者设置值。下面是一些操作方法：</p><ul><li>getNamedItem(name): 返回属性名的node节点</li><li>removeNamedItem(name): 删除节点</li><li>setNamedItem(node): 设置属性节点，如果属性名没有就添加，有就覆盖</li><li>item(pos): 返回pos处的节点</li></ul><p>例如</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span><span class="built_in"> id</span> = <span class="type">element</span>.attributes.getNamedItem(<span class="string">&quot;id&quot;</span>).nodeValue;</span><br><span class="line">简写</span><br><span class="line"><span class="keyword">let</span><span class="built_in"> id</span> = <span class="type">element</span>.attributes[<span class="string">&#x27;id&#x27;</span>].nodeValue;</span><br><span class="line">//删除属性</span><br><span class="line"><span class="type">element</span>.attributes.removeNamedItem(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>创建元素</strong></p><p>可以使用document.crateElement(element_name)创建元素,参数为创建元素的标签名，例如创建div可以用<code>document.createElement('div');</code></p><p>创建元素后可以便捷的添加属性，如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">div.id</span> = <span class="string">&quot;newDiv&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">div.className</span> = <span class="string">&quot;box&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>创建完成之后可以使用前面提到的appendChild等函数添加到DOM树中。</p><h2 id="text类型"><a class="markdownIt-Anchor" href="#text类型"></a> Text类型</h2><p>Text是文本节点，它既可能是文本，也可能是转义后的HTML字符。</p><ul><li>nodeType = 1</li><li>nodeName = “#text”</li><li>nodeValue = 文本</li><li>parentNode = Element</li></ul><p>例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">hello world和test都是文本节点，title的parentNode是title</span><br></pre></td></tr></table></figure><p>text节点有一系列的文本操作方法：</p><ul><li>appendData(text): 在末尾追加</li><li>deleteData(offset, count): 在offset处删除count个字符</li><li>insertData(offset, text): 在offset插入text</li><li>replaceData(offset, count, text): 用text替换offset开始的count个字符</li><li>splitText(offset): 从offset处将文本节点拆分成两个文本节点。原</li><li>substringData(offset, count): 提取offset到offset+count的文本</li><li>length:</li></ul><p>除了上述方法进行操作外，我们还可以直接通过nodeValue进行修改，这些修改都会立刻反映。</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">let</span> textNode = div.firstChild;</span><br><span class="line">div.firstChild.nodeValue = <span class="string">&quot;other message&quot;</span>;</span><br><span class="line">div.firstChild.nodeValue = <span class="string">&quot;Some &lt;strong&gt;other&lt;/strong&gt; message&quot;</span>;</span><br><span class="line">//会转义，输出为 Some &amp;<span class="literal">lt</span>;strong&amp;<span class="literal">gt</span>;other&amp;<span class="literal">lt</span>;/strong&amp;<span class="literal">gt</span>; message</span><br></pre></td></tr></table></figure><h1 id="jquery"><a class="markdownIt-Anchor" href="#jquery"></a> jQuery</h1><p>jQuery可以让我们以<a href="https://xinhecuican.github.io/post/676848e4.html">css选择器</a>的形式快速对元素进行定位</p><p><strong>搜索</strong></p><ul><li>querySelector(str): 接收css选择符，返回该模式下第一个后代元素，没有返回null。他会从当前节点的子节点开始搜索 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selected = <span class="built_in">document</span>.querySeelctor(<span class="string">&quot;.selected&quot;</span>);<span class="comment">//搜索selected类的第一个元素</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">&quot;img.button&quot;</span>);<span class="comment">//选择类名为button的图片</span></span><br></pre></td></tr></table></figure></li><li>querySelectorAll(str): 他会返回所有匹配的节点，返回格式为NodeList</li><li>match(str): 存在返回true，不存在返回false</li></ul><h1 id="htmldocument扩展"><a class="markdownIt-Anchor" href="#htmldocument扩展"></a> HTMLDocument扩展</h1><p>HTML5扩展了HTMLDocument属性，增添了一些新的功能。</p><ol><li>document.readyState: 他有两个值，loading和complete表示文档加载状态。</li><li>document.compatMode: 表示当前位于什么渲染模式，有标准模式和混杂模式。标准模式是&quot;CSS1Compat&quot;,混杂模式是&quot;BackCompat&quot;.</li><li>document.head: 可以通过这个访问<code>&lt;head&gt;</code>元素</li><li>document.characterSet: 字符集，默认值是&quot;UTF-16&quot;</li></ol><h2 id="自定义属性"><a class="markdownIt-Anchor" href="#自定义属性"></a> 自定义属性</h2><p>html5允许元素指定非标准的属性，但要是用data-告诉浏览器这是自定属性，例如：<br /><code>&lt;div id=&quot;myDiv&quot; data-appid=&quot;12345&quot; data-myName=&quot;Nicholas&quot;&gt;&lt;/div&gt;</code></p><p>自定属性可以通过dataset访问。dataSet是DOMStringMap实例，包含键值对映射。每个属性都可以使用data-name中的那么进行访问。</p><p>例如</p><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">div</span> = document.getElementById(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> appid = <span class="keyword">div</span>.dataset.appId;</span><br><span class="line"><span class="keyword">let</span> myName = <span class="keyword">div</span>.dataset.myName;</span><br></pre></td></tr></table></figure><h2 id="innerhtml和outerhtml"><a class="markdownIt-Anchor" href="#innerhtml和outerhtml"></a> innerHTML和outerHTML</h2><p>innerHTML返回该元素所有后代的字符串，如果我们进行插入，他会把字符串清空变成我们插入的字符串，例如：</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a </span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><span class="xml"> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">querySelector(<span class="string">&quot;#content&quot;</span>).innerHTML</span><br><span class="line"></span><br><span class="line">//返回</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a </span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><span class="xml"> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">document</span>.body.getElementById(<span class="string">&quot;content&quot;</span>).innerHTML = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">原结构变成</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>outerHTML</strong>会返回调用者的HTML字符串，它的使用方式和innerHTML类似</p><h2 id="滚动"><a class="markdownIt-Anchor" href="#滚动"></a> 滚动</h2><ul><li>scrollIntoView(alignToTop, scrollIntoViewOptions):<ul><li>alignToTop: 如果是true，那么滚动后和窗口顶部平齐，否则和窗口底部平齐</li><li>scrollIntoViewOptions: 是一个对象，里面有三个属性。behavior，block，inline<ul><li>behavior: 定义过渡动画，有&quot;smooth&quot;, “auto”</li><li>block: 定义垂直方向对齐，有&quot;start&quot;,“center”,“end”,“nearest”</li><li>inline: 定义水平方向对齐，和垂直方向相同</li></ul></li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">document</span><span class="selector-class">.froms</span><span class="selector-attr">[0]</span><span class="selector-class">.scrollIntoView</span>();</span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.forms</span><span class="selector-attr">[0]</span><span class="selector-class">.scrollIntoView</span>(<span class="selector-tag">true</span>, &#123;<span class="attribute">block</span>: <span class="string">&quot;start&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="尺寸"><a class="markdownIt-Anchor" href="#尺寸"></a> 尺寸</h2><p>元素的布局如图所示<img src="/images/dom2.png" alt="" /></p><p><strong>设置margin和border</strong></p><ul><li>offsetHeight： border的高度（包括里面的）</li><li>offsetWidth： border的宽度</li><li>offsetLeft： border到margin左边界的距离</li><li>offsetTop： border到margin上边界的距离</li><li>offsetParent： 当前节点的偏移量上的父节点</li></ul><p>要计算一个元素在页面中的偏移量，需要把自己和所有父节点的offsetLeft和offsetTop相加</p><figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">function getElementL</span><br><span class="line">ocation(element)</span><br><span class="line">&#123;</span><br><span class="line">    let <span class="literal">left</span> = element.offsetLeft<span class="comment">;</span></span><br><span class="line">    let <span class="literal">top</span> = element.offsetTop<span class="comment">;</span></span><br><span class="line">    let <span class="literal">current</span> = element.offsetParent<span class="comment">;</span></span><br><span class="line">    while(<span class="literal">current</span> !== null)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">left</span> += <span class="literal">current</span>.offsetLeft<span class="comment">;</span></span><br><span class="line">        <span class="literal">top</span> += <span class="literal">current</span>.offsetTop<span class="comment">;</span></span><br><span class="line">        <span class="literal">current</span> = <span class="literal">current</span>.offsetParent<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>padding</strong></p><ul><li>clientWidth: padding整体宽度（包括最里面的）</li><li>clientHeight：高度</li></ul><p><strong>滚动尺寸</strong></p><ul><li>scrollHeight： 没有滚动条出现时元素总高度</li><li>scrollWidth： 总宽度</li><li>scrollLeft： 距离最左边的长度（包括隐藏的）</li><li>scrollTop： 距离最上面的长度</li></ul><h1 id="样式设置"><a class="markdownIt-Anchor" href="#样式设置"></a> 样式设置</h1><p>使用js可以动态修改样式表，样式表对应的元素属性是style。任何支持style属性的元素在js中都有一个对应的style属性，可以通过style对该元素样式表进行修改。</p><p>样式表创建共有三种方法：通过<code>&lt;link&gt;</code>创建、通过<code>&lt;style&gt;</code>创建、通过style属性创建。</p><p>样式表在装潢为js变量时名字有所改变，连字符全部删除，然后后面变成大写。例如：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>-<span class="built_in">image</span> //js： <span class="built_in">style</span>.backgroundImage</span><br><span class="line"><span class="built_in">font</span>-family //js: <span class="built_in">style</span>.fontFamily</span><br></pre></td></tr></table></figure><p>大多数属性名都是直接进行转换，但是float不能进行转换，因为它是关键字。因此在js的style中将它命名为cssFloat</p><p>属性和方法：</p><ul><li>cssText: 返回css字符串，可以通过它一次性设置所有属性，例如： <figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">myDiv.<span class="built_in">style</span>.cssText = <span class="string">&quot;width: 25px; height: 100px; background-color: green&quot;</span>;</span><br><span class="line">console.<span class="built_in">log</span>(myDiv.<span class="built_in">style</span>.cssText);</span><br></pre></td></tr></table></figure></li><li>length： 返回属性数量</li><li>parentRule: 返回CSSRule对象</li><li>getPropertyPriority(propertyName): 如果使用了!important，则返回important,否则返回空字符串</li><li>getPropertyValue(name): 返回属性的字符串值</li><li>item(index): 返回index的属性名</li><li>removeProperty(name):</li><li>setProperty(name, value, priority): 设置属性</li></ul><p>可以使用length对css属性进行遍历</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> prop, value;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=<span class="number">0</span>, len=myDiv.<span class="built_in">style</span>.<span class="built_in">length</span>; i&lt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">    prop = myDiv.<span class="built_in">style</span>[i];</span><br><span class="line">    value = myDiv.<span class="built_in">style</span>.getPropertyValue(prop);</span><br><span class="line">    console.<span class="built_in">log</span>(`prop: $&#123;value&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="built_in">style</span>中只包含<span class="built_in">style</span>属性为设个属性设置的值，不包含其他样式表继承过来的值，因此设置可能回合最终结果有偏差.可以通过getComputedStyle()获得最终结果，</span><br><span class="line"></span><br><span class="line">* getComputedStyle(element, str): 返回值是一个只读的<span class="built_in">style</span>类型。element是想要获得可计算属性的元素，str是伪元素字符串（<span class="string">&quot;:after&quot;</span>等)</span><br><span class="line"></span><br><span class="line">例如</span><br></pre></td></tr></table></figure><p>let myDive = document.getElementById(“myDiv”);<br />let computeStyle = document.defaultView.getComputedStyle(myDiv, null);</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## 操作样式表</span></span><br><span class="line"></span><br><span class="line">除了修改style提供的样式外，另外两种方法提供的样式我们也可以进行操作。HTMLLinkElement是通过<span class="code">`&lt;link&gt;`</span>创建的样式表, HTMLStyleElement是通过<span class="code">`&lt;style&gt;`</span>创建的样式表。CSSStyleSheet是通用样式表，可以表示上面两种，他只有一个属性可读写。</span><br><span class="line"></span><br><span class="line">CSSStyleSheet中的属性：</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> disabled： 表示样式表是否被禁用，可读写</span><br><span class="line"><span class="bullet">*</span> href： 如果是<span class="code">`&lt;link&gt;`</span>形式创建的样式表，返回url</span><br><span class="line"><span class="bullet">*</span> media： 表示支持媒体的集合，有一个length属性和item()方法</span><br><span class="line"><span class="bullet">*</span> ownerNode: 拥有该样式表的节点，要么是<span class="code">`&lt;link&gt;`</span>要么是<span class="code">`&lt;style&gt;`</span>,如果是@import形式导入的那么是null</span><br><span class="line"><span class="bullet">*</span> parentStyleSheet: 指向包含它的样式表</span><br><span class="line"><span class="bullet">*</span> title： ownerNode的title属性</span><br><span class="line"><span class="bullet">*</span> type： 样式表的类型</span><br><span class="line"><span class="bullet">*</span> cssRules： 规则集合</span><br><span class="line"><span class="bullet">*</span> ownerRule： 如果是由@import导入，则返回父样式表规则集合</span><br><span class="line"><span class="bullet">*</span> deleteRule(index):</span><br><span class="line"><span class="bullet">*</span> insertRule(rule, index);</span><br><span class="line"></span><br><span class="line"><span class="section">### 规则</span></span><br><span class="line"></span><br><span class="line">CSSRule表示一条规则, 一个选择器加样式就是一条规则。一般使用的是CSSStyleRule（其他@import,@font-face等很少用js操作）。下面是CSSStyleRule的属性</span><br><span class="line"><span class="bullet">*</span> cssText： 返回规则的文本</span><br><span class="line"><span class="bullet">*</span> parentRule： 如果被其他规则包含，返回父规则，否则返回null</span><br><span class="line"><span class="bullet">*</span> parentStyleSheet： 返回当前样式表</span><br><span class="line"><span class="bullet">*</span> style</span><br><span class="line"><span class="bullet">*</span> type： 表示规则类型，值固定为1</span><br><span class="line"><span class="bullet">*</span> selectorText： 返回规则的选择符文本，也就是# .等选择器</span><br><span class="line"></span><br><span class="line">例如：</span><br></pre></td></tr></table></figure><p>let sheet = document.styleSheets[0];<br />let rules = sheet.cssRules || sheet.rules;<br />let rule = rules[0];<br />rule.style.backgroundColor = “red”;</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">* insertRule(str, index): 添加新的规则,例如`sheet.insertRule(&quot;body &#123;background-color: silver&#125;&quot;, 0);`</span></span><br><span class="line"><span class="comment">* deleteRule(index):</span></span><br><span class="line"></span><br><span class="line"># 遍历</span><br><span class="line"></span><br><span class="line">使用NodeIterator和TreeWalker可以进行**深度优先遍历**。</span><br><span class="line"></span><br><span class="line"><span class="comment">**NodeIterator**</span></span><br><span class="line"></span><br><span class="line">可以使用document.createNodeIterator(root, whatToshow, filter)构建实例</span><br><span class="line"></span><br><span class="line"><span class="comment">* root： 根节点</span></span><br><span class="line"><span class="comment">* whatToShow: 指定访问哪些类型的节点</span></span><br><span class="line"><span class="comment">   * NodeFilter.SHOW_ALL: 访问所有节点</span></span><br><span class="line"><span class="comment">   * NodeFilter.SHOW_ELEMENT: 元素节点</span></span><br><span class="line"><span class="comment">   * NodeFileter.SHOW_ATTRIBUTE: 属性节点，DOM中不需要</span></span><br><span class="line"><span class="comment">   * SHOW_TEXT: 文本节点</span></span><br><span class="line"><span class="comment">   * SHOW_CDATA_SECTION: CData节点</span></span><br><span class="line"><span class="comment">   * SHOW_ENTITY_REFERENCE： 实体引用节点</span></span><br><span class="line"><span class="comment">   * SHOW_ENTITY： 实体节点</span></span><br><span class="line"><span class="comment">   * SHOW_PROCESSING_INSTRUCTION： 处理指令节点</span></span><br><span class="line"><span class="comment">   * SHOW_COMMENT： 注释节点</span></span><br><span class="line"><span class="comment">   * SHOW_DOCUMENT： 文档节点</span></span><br><span class="line"><span class="comment">   * SHOW_DOCUMENT_TYPE： 文档类型节点</span></span><br><span class="line"><span class="comment">   * SHOW_DOCUMENT_FRAGMENT: 文档片段节点</span></span><br><span class="line"><span class="comment">   * SHOW_NOTATION： 记号节点</span></span><br><span class="line"><span class="comment">* filter: NodeFilter对象或函数，表示应该接受或跳过节点类型</span></span><br><span class="line"></span><br><span class="line">NodeFilter是一个抽象类，不能创建实例，只要实现acceptNode方法传给createNodeFilter()就可以了。acceptNode(node)返回值是NodeFilter.FILTER_ACCEPT或NodeFIlter.FILTER_SKIP。对该node进行筛选，如果是NodeFilter.FILTER_ACCEPT就接受。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let show = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT;</p><p>let filter =<br />{<br />acceptNode(node)<br />{<br />return node.tagName.toLowerCase() == “p” ? NodeFilter.FILTER_ACCEPT : NodeFIlter.FILTER_SKIP;<br />}<br />}<br />let iter = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, filter);<br />或者<br />let filter = function(node)<br />{<br />return node.tagName.toLowerCase() == “p” ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;</p><pre class="highlight"><code class="">**遍历方法*** nextNode()/previousNode(): 返回深度优先搜索中的前一步或者后一步，如果到了根节点再调用previousNode会返回NULL， 同样如果到了最后一个节点再调用nextNode会返回null**TreeWalker**TreeWalker是NodeIterator的升级版，除了前面所说的方法外，还有一些额外的方法* document.createTreeWalker(): 创建TreeWalker* parentNode(): 遍历到父节点* firstChild(): 遍历到当前节点的子节点* lastChild()* nextSibling()* previousSibling()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="https://xinhecuican.github.io/post/f3d3ee5b.html"/>
    <id>https://xinhecuican.github.io/post/f3d3ee5b.html</id>
    <published>2021-07-15T11:50:00.000Z</published>
    <updated>2021-07-17T12:56:08.023Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="window对象"><a class="markdownIt-Anchor" href="#window对象"></a> window对象</h1><p>window对象在浏览器中有两重身份，一是Global对象，而是浏览器窗口的js接口。网页中定义的所有对象，变量都可以以window作为Global对象，并且使用parseInt()等方法。</p><p>使用var会自动添加到全局对象中。而使用let则不会。window对象还可以用来查询是否存在未声明的变量</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="number">1</span>;</span><br><span class="line">console.log(window.temp);<span class="comment">//全局对象加入window中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">new</span><span class="type">Value</span> = oldValue;<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">new</span><span class="type">Value</span> = window.oldValue;<span class="comment">//这里是属性查询，因此newValue会被设置为undefined而不会报错</span></span><br></pre></td></tr></table></figure><h2 id="窗口操作函数"><a class="markdownIt-Anchor" href="#窗口操作函数"></a> 窗口操作函数</h2><p>window.self始终指向window本身，window.top始终指向浏览器窗口本身，而window.parent始终指向当前窗口的父窗口，如果本身就是最上层窗口，那么window.parent和window.top相同</p><ul><li>window.moveTo(x, y): 将左上角移动到对应位置</li><li>window.moveBy(dx, dy): 从当前位置移动若干像素</li></ul><p><strong>窗口大小</strong></p><p>现代浏览器都支持四个属性：innerWidth/innerHeight/outerWidth/outerHeight.其中outerWidth和outerHeight返回浏览器自身窗口大小，而innerWidth和innerHeight返回浏览器可见视口大小(不包括边框和工具栏).</p><p>布局视口是整个页面的大小，有时候我们放大一下可能某些部分看不到了，可见视口就是可以看到的那一部分，布局视口包括看不到的部分。布局视口可以用document.body.clientWidth和document.body.clientHeight来获得。</p><ul><li>window.resizeTo(x, y): 缩放到某一个大小</li><li>window.resizeBy(x, y): 增加或减少一部分大小</li></ul><p>例如:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">window</span>.resizeTo(<span class="number">100</span>, <span class="number">100</span>);//缩放到(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"><span class="attribute">window</span>.resizeBy(<span class="number">100</span>, <span class="number">50</span>);//缩放到(<span class="number">200</span>, <span class="number">150</span>)，增加了(<span class="number">100</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><ul><li>window.scrollBy(x, y, behavior): 向右滚动x像素，向下滚动y像素.behavior可以设置为smooth平滑滚动。</li><li>window.scrollTo(x, y, behavior): …</li></ul><h2 id="导航和新窗口"><a class="markdownIt-Anchor" href="#导航和新窗口"></a> 导航和新窗口</h2><ul><li><p>window.open(url, name, attribute): 弹出新窗口。如果名字是当前存在的窗口名，那么会跳转到对应窗口，否则会打开一个新窗口。特性字符串用来指定新窗口的一些设置，它使用逗号分隔，常见的设置有：</p><table><thead><tr><th>设置</th><th>说明</th></tr></thead><tbody><tr><td>fullscreen</td><td>窗口是否最大化，只有IE支持</td></tr><tr><td>height</td><td>新窗口的高度， 不能小于100</td></tr><tr><td>left</td><td>新窗口x坐标 ，不能是负值</td></tr><tr><td>top</td><td>新窗口y坐标</td></tr><tr><td>width</td><td>新窗口宽度</td></tr><tr><td>location</td><td>是否显示地址栏，它还受浏览器影响</td></tr><tr><td>Menubar</td><td>是否显示菜单栏，默认为&quot;no&quot;</td></tr><tr><td>resizable</td><td>是否可以更改大小， 默认为&quot;no&quot;</td></tr><tr><td>scrollbars</td><td>是否可以滚动，默认为&quot;no&quot;</td></tr><tr><td>status</td><td>是否显示状态栏，受浏览器影响</td></tr><tr><td>toolbar</td><td>是否显示工具栏，默认为&quot;no&quot;</td></tr></tbody></table><p>例如：</p> <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">window</span>.<span class="keyword">open</span>(&quot;http://www.wrox.com/&quot;,</span><br><span class="line">        &quot;wroxWindow&quot;,</span><br><span class="line">        &quot;height=400, width=400, resizable=yes&quot;);</span><br></pre></td></tr></table></figure></li><li><p>window.close(): 关闭窗口。不能使用这个函数关闭主窗口，但是可以关闭弹出窗口。</p></li></ul><p>新窗口有一个opener指向打开自己的window对象，例如：</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">let <span class="keyword">win</span> = <span class="keyword">window</span>.<span class="keyword">open</span>(<span class="string">&quot;http://www.wrox.com/&quot;</span>, <span class="string">&quot;wroxwindow&quot;</span>);</span><br><span class="line">alert(<span class="keyword">win</span> === <span class="keyword">window</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>由于过去弹窗被广告滥用了，因此现在对弹窗增加了许多限制。例如在网页加载过程中使用window.open()没有效果，只有在用户操作下才允许创建弹窗。</p><p>如果弹窗被屏蔽了，那么他会返回null，并且有的还会让它抛出错误，因此除了检测返回值，还需要使用try/catch</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> win = <span class="built_in">window</span>.open(<span class="string">&quot;http://www.wrox.com&quot;</span>, <span class="string">&quot;_blank&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(win == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        blocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ex)</span><br><span class="line">&#123;</span><br><span class="line">    alert(<span class="string">&quot;blocked&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h2><ul><li>setTimeout(func, time, arguments):func是要执行的函数，time是等待的时间。并不是说需要等待这么久就可以执行，而是等待这么久才有执行的机会。arguments是要传入函数的参数</li></ul><p>js内部维护了一个消息队列，第二个参数的含义是等待time时间之后才把这个函数放入消息队列中。在时间结束前调用clearTimeout()可以取消任务，例如</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">let timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>alert(<span class="string">&quot;hello world&quot;</span>), <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">clearTimeout</span>(timeout);</span><br></pre></td></tr></table></figure><ul><li>setInterval(…): setInterval和setTimeout类似，只是它是循环计时的</li><li>clearInterval(): …</li></ul><h2 id="对话框"><a class="markdownIt-Anchor" href="#对话框"></a> 对话框</h2><ul><li>alert(message): 传递一个警示对话框，只有一个ok按钮<img src="/images/BOM1.png" alt="" /></li><li>confirm(): 有两个按钮，ok和cancel，返回true为ok</li><li>prompt(): 提示用户输入消息，两个参数分别是提示文字和输入框内的默认值。点击ok会返回文本框内的值，点击cancel会返回null</li><li>print(): 打印对话框</li></ul><h1 id="location对象"><a class="markdownIt-Anchor" href="#location对象"></a> location对象</h1><p>location记载了一些窗口的属性并且提供url操作方法。可以使用window.location或document.location进行访问</p><p>以http://foouser.barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents来说明</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>location.hash</td><td>url的散列值（也就是#contents)</td></tr><tr><td>location.host</td><td>服务器名和端口号</td></tr><tr><td>location.hostname</td><td>服务器名(<a href="http://www.wrox.com">www.wrox.com</a>)</td></tr><tr><td>href</td><td>完整url</td></tr><tr><td>pathname</td><td>路径和文件名，上面例子中是/WileyCDA/</td></tr><tr><td>port</td><td>端口</td></tr><tr><td>protocol</td><td>协议类型，一般是http: 或https:</td></tr><tr><td>search</td><td>查询字符串，以问号开头. ?q=javascript</td></tr><tr><td>username</td><td>用户名</td></tr><tr><td>password</td><td>密码</td></tr><tr><td>origin</td><td>url源地址，只读。<a href="http://www.wrox.com">http://www.wrox.com</a></td></tr></tbody></table><p><strong>查询参数分割</strong></p><p>location.search返回的是一整个字符串，里面可能有很多个查询项，获得所有单个查询项的方法为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getQueryString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> q = (location.search.length &gt; <span class="number">0</span>) ? location.search.substring(<span class="number">1</span>):<span class="string">&quot;&quot;</span>;</span><br><span class="line">    args = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一个split分割出每一个查询，第二个分割出问题和答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> q.split(<span class="string">&quot;&amp;&quot;</span>).map(<span class="function"><span class="params">kv</span> =&gt;</span> split(<span class="string">&quot;=&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);<span class="comment">//解码</span></span><br><span class="line">        <span class="keyword">let</span> value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(name.length)</span><br><span class="line">        &#123;</span><br><span class="line">            args[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还可以使用URLSearchParams类，它提供了get(),set()，delete()等方法用来查询字符串</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> <span class="constructor">URLSearchParams(<span class="params">location</span>.<span class="params">search</span>)</span>;</span><br><span class="line">searchParams.has(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">searchParams.get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> param <span class="keyword">of</span> searchParams)<span class="comment">//param是一个键值对</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改url</strong></p><p>可以使用location.assign传入一个url。它会导航到一个新的url，并且会在历史记录中添加一条记录。设置location.href或window.location,也会调用assign()。对location的一些属性设置也有同样的效果</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">window.location</span> = <span class="string">&quot;http://www.wrox.com&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">location.href</span> = <span class="string">&quot;http://www.wrox.com&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">location.hash</span> = <span class="string">&quot;#section1&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">location.search</span> = <span class="string">&quot;?q=javascript&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>如果不希望增加历史记录，可以使用replace方法，使用之后不能用撤回按钮恢复到原始页面。</p><ul><li>reload(from_server): 重新加载页面，from_server表示是否强制从服务器加载</li></ul><h1 id="navigator对象"><a class="markdownIt-Anchor" href="#navigator对象"></a> navigator对象</h1><p>navigator用来保存浏览器的一些属性</p><table><thead><tr><th>属性/方法</th><th>说明</th></tr></thead><tbody><tr><td>activeVrDisplays</td><td>返回数组，包含ispresenting属性为true的VRDisply实例（VR设置属性）</td></tr><tr><td>appCodeName</td><td>即使在非Mozilla浏览器中也会返回&quot;Mozilla&quot;</td></tr><tr><td>appName</td><td>浏览器全名</td></tr><tr><td>appVersion</td><td>浏览器版本，通常和实际不一致</td></tr><tr><td>battery</td><td>返回BatteryManager对象（电源管理）</td></tr><tr><td>buildId</td><td>浏览器构建编号</td></tr><tr><td>connection</td><td>NetworkInformation对象</td></tr><tr><td>cookieEnabled</td><td>是否启用cookie</td></tr><tr><td>credentials</td><td>返回CredentialsContainer对象</td></tr><tr><td>deviceMemory</td><td>返回以GB为单位的内存容量</td></tr><tr><td>doNotTrack</td><td>返回用户&quot;不跟踪&quot;设置</td></tr><tr><td>geolocation</td><td>返回Geolocation对象（地理位置定位）</td></tr><tr><td>hardwareConcurrency</td><td>设备处理器核心数量</td></tr><tr><td>javaEnabled</td><td>是否启用java</td></tr><tr><td>language</td><td>浏览器主语言</td></tr><tr><td>languages</td><td>偏好语言数组</td></tr><tr><td>locks</td><td>LockManager对象</td></tr><tr><td>mediaCapabilities</td><td>返回MediaCapabilities对象</td></tr><tr><td>mediaDevices</td><td>返回可用媒体数量</td></tr><tr><td>maxTouchPoints</td><td>设备触摸屏最大触点数</td></tr><tr><td>mimeTypes</td><td>返回浏览器注册的MIME类型数组（MIME是一种类型表述方法，可以说明它使文本还是音频、视频还是其他）</td></tr><tr><td>onLine</td><td>浏览器是否联网</td></tr><tr><td>oscpu</td><td>返回操作系统和cpu型号</td></tr><tr><td>permissions</td><td>返回Permissions对象</td></tr><tr><td>plugins</td><td>插件数组</td></tr><tr><td>…</td><td></td></tr></tbody></table><p><strong>检测插件</strong></p><p>插件数组中的每一项都包含下列属性：</p><ul><li>name： 插件名称</li><li>description： 插件介绍</li><li>filename： 插件文件名</li><li>length： 插件处理的MIME类型数量</li></ul><p><strong>注册处理程序</strong></p><p>可以使用navigator.registerProtocolHandler()方法注册为某些特定信息的处理程序，就像操作系统上的默认应用一样。</p><ul><li>registerProtocolHandler(protocol, url, name): protocol是要处理的协议类型（如mailto或ftp），url是处理该协议的url，name是应用名称。例如：</li></ul><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">navigator</span><span class="selector-class">.registerProtocolHandler</span>(<span class="string">&quot;mailto&quot;</span>,</span><br><span class="line"><span class="string">&quot;http://www.somemailclient.com?cmd=%s&quot;</span>,</span><br><span class="line"><span class="string">&quot;mail client&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="screen和history"><a class="markdownIt-Anchor" href="#screen和history"></a> screen和history</h1><p>screen反映了屏幕的一些信息。可以从<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Screen">这里获得它的属性</a></p><p>history的go方法可以向任何方向导航，如果传入的参数是负数，表示后退若干页。反之为前进若干页。</p><p>go方法也可以是一个字符串，这种情况下会导航到包含字符串的第一个位置，这个位置可能是前进也可能是后退。</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">history.go(-<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">history.go(<span class="string">&quot;wrox.com&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>用户点击切换页面时会有一个haschange事件，我们可以在这时执行某些操作改变url而不打开新页面。可以使用history.pushState()</p><ul><li><p>pushState(state, title, relativeurl): state是一个状态对象，这个对象保存有初始化页面状态所需要的信息，它的大小一般最大为500kb-1mb。第二个参数并未使用，第三个参数时要跳转的页面。</p><p>pushState执行后，当前状态会被推入历史记录中，地址栏也会变为新的url。但是即使location.href返回的是新内容，浏览器也不会向服务器发送请求。</p></li><li><p>popState： 点击后退按钮会触发一个popState事件，这个事件中有一个state属性，它表示pushState()中的第一个参数</p></li><li><p>history.state: 表示当前状态对象</p></li><li><p>replaceState(state, name): 更新当前状态对象</p></li></ul><p>``<br />history.pushState({foo: ‘bar’}, “title”, “baz.html”);</p><p>window.addEventListener(“popstate”, (event)=&gt;{<br />let state = event.state;<br />if(state)<br />{<br />processState(state);<br />}<br />});</p><p>history.replaceState({bar: ‘bar’}, “new title”);</p><pre class="highlight"><code class=""></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;window对象&quot;&gt;&lt;a class=&quot;markdownIt-An</summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>qt 选择器</title>
    <link href="https://xinhecuican.github.io/post/fc53134f.html"/>
    <id>https://xinhecuican.github.io/post/fc53134f.html</id>
    <published>2021-07-11T06:36:00.000Z</published>
    <updated>2021-07-13T01:28:54.503Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>qt的选择器中共有</p><ul><li>通用选择器(*): 作用于所有widget</li><li>类型选择器： 作用于该类及子类</li><li>类选择器： 只作用于这个类</li><li>ID选择器： 作用于某个对象</li><li>属性选择器： 作用域某个成员变量</li><li>包含选择器： 作用于某个类下的类</li><li>子元素选择器： 作用于某个类的直接子widget</li><li>伪类选择器： 选择某些状态，如QPushButton的hover和pressed状态</li><li>子控件选择器： 选择某个部件下面的子部件</li></ul><p>qss内部数属性一般是不区分大小写的，但是类名，属性名区分大小写</p><p>加载方法</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">QFile</span> <span class="selector-tag">qss</span>(&quot;<span class="selector-tag">StyleSheet</span><span class="selector-class">.qss</span>&quot;);</span><br><span class="line"><span class="selector-tag">qss</span><span class="selector-class">.open</span>(<span class="selector-tag">QFile</span><span class="selector-pseudo">::ReadOnly)</span>;</span><br><span class="line"><span class="selector-tag">app</span><span class="selector-class">.setStyleSheet</span>(<span class="selector-tag">qss</span><span class="selector-class">.readAll</span>());</span><br><span class="line"><span class="selector-tag">qss</span><span class="selector-class">.close</span>();</span><br></pre></td></tr></table></figure><h1 id="类型-类-id选择器"><a class="markdownIt-Anchor" href="#类型-类-id选择器"></a> 类型、类、ID选择器</h1><p><strong>类型选择器</strong></p><p>格式</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">className</span><br><span class="line">&#123;</span><br><span class="line"><span class="symbol">    attribute:</span> value;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中attribute是控件的各种属性，className是类名，由QObject::metaObject()::className获得。类型选择器匹配该类及其派生类</p><p>例如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">QPushButton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在自定义的命名空间中，QObject::className()返回值中有::，和子控件选择器冲突。为了避免这个问题，我们可以把::换成–</p></blockquote><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="symbol">ns</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="symbol">MyPushButton</span> : <span class="symbol">public</span> <span class="symbol">QPushButton</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">qApp-&gt;setStyleSheet(<span class="string">&quot;ns--MyPushButton &#123;background: yellow; &#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>类选择器</strong></p><p>类选择器和前面的区别是它不会选择子类。格式为：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.className</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">attribute</span>: value; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line"><span class="selector-class">.QFrame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ID选择器</strong></p><p>ID选择器选择的是对象的某个具体实例.格式为：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ID</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">attribute</span>: value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ID选择器会对所有同名的实例进行配置，无论它的类型是什么，而很多时候我们只想对某一个实例进行配置，因此一般前面需要加上类名匹配</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">QPushButton</span><span class="selector-id">#settings_popup_fileDialog_button</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">31px</span>;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F</span>OFOFO;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">qlineargradient</span>(spread: pad, x1:<span class="number">0</span>,y1:<span class="number">0</span>,x2:<span class="number">0</span>,y2:<span class="number">1</span>,stop:<span class="number">0</span> #<span class="number">454648</span>,stop:<span class="number">1</span> #<span class="number">7</span>A7A7A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包含-子元素选择器"><a class="markdownIt-Anchor" href="#包含-子元素选择器"></a> 包含、子元素选择器</h1><p><strong>包含选择器</strong></p><p>格式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">selector1</span> <span class="selector-tag">selector2</span> ...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">attribute</span>: value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它表示在selector1匹配的对象中，使用selector2进行筛选，然后对满足条件的对象进行匹配。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">BaseDialog</span> <span class="selector-tag">QPushButton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>子选择器</strong></p><p>格式: <code>selector1&gt;selector2 &#123; attribute: value; &#125;</code></p><p>子选择器和上面的包含选择器相比多了一层限制，它只能有selector1和selector2，不能出现seelector3乃至更多。</p><p>它常用于对某些布局下特定控件进行选择</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.QGroupBox</span>&gt;<span class="selector-class">.QCheckBox</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性-伪类-子控件选择器"><a class="markdownIt-Anchor" href="#属性-伪类-子控件选择器"></a> 属性、伪类、子控件选择器</h1><p><strong>属性选择器</strong></p><p>格式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[attribute=value]</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="attribute">attribute</span>: value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它先根据某些样式进行选择，然后修改样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[objectName|=<span class="string">&quot;button&quot;</span>]</span>//<span class="selector-tag">objectName</span>以<span class="selector-tag">button</span>开头</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QPushButton</span><span class="selector-attr">[flat=“false”]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性选择器用的计较少</p><p><strong>伪类选择器</strong></p><p>格式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">类或类型选择器<span class="selector-pseudo">:status</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">attribute</span>: value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪类选择器是对某些状态进行选择，如按下、禁用、启用等</p><table><thead><tr><th>伪类</th><th>说明</th></tr></thead><tbody><tr><td>:disabled</td><td>控件禁用时</td></tr><tr><td>:enabled</td><td>…</td></tr><tr><td>:focus</td><td>获得焦点时</td></tr><tr><td>:hover</td><td>鼠标放在widget上时</td></tr><tr><td>:pressed</td><td>…</td></tr><tr><td>:checked</td><td>被选中时</td></tr><tr><td>:unchecked</td><td>未选中时</td></tr><tr><td>…</td><td></td></tr></tbody></table><p><strong>子控件选择器</strong></p><p>子控件选择器是对某些复杂控件中的小部件进行设置，这一般是对官方给的控件中某些部分进行管理。</p><p>例如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">QComboBox</span><span class="selector-pseudo">::down-arrow</span>//<span class="selector-tag">QComBox</span>的向下箭头</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">image</span>: <span class="built_in">url</span>(down-arrow.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QComboBox</span><span class="selector-pseudo">::down-arrow</span><span class="selector-pseudo">:pressed</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">1px</span>; <span class="attribute">left</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://qtdebug.com/qtbook-qss-subcontrol/">子控件选择器可以看这</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;qt的选择器中共有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用选择器(*): 作用于所有</summary>
      
    
    
    
    <category term="c++" scheme="https://xinhecuican.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>js异步编程</title>
    <link href="https://xinhecuican.github.io/post/748b5171.html"/>
    <id>https://xinhecuican.github.io/post/748b5171.html</id>
    <published>2021-07-07T12:15:00.000Z</published>
    <updated>2021-08-06T12:52:36.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="期约"><a class="markdownIt-Anchor" href="#期约"></a> 期约</h1><h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><p>期约类似于事件处理。例如</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="constructor">Promise((<span class="params">resolve</span>, <span class="params">reject</span>)</span> =&gt; &#123;&#125;);</span><br><span class="line">set<span class="constructor">Timeout(<span class="params">console</span>.<span class="params">log</span>, 0, <span class="params">p1</span>)</span>;</span><br><span class="line">timeout的三个参数第一个是执行的函数，第二个是等待的时间，后面的都是函数的参数</span><br></pre></td></tr></table></figure><p>他和普通的timeout的区别在于它可以通过函数设置参数，从而异步决定某些函数是否执行及这些函数的参数。</p><p>期约具有三种状态： 待定(pending)、兑现/解决(resolved)、拒绝(rejected)</p><p>在待定状态下，期约可以落定，一旦跳转到解决或拒绝状态就不能再变化。</p><ul><li>Promise((resolve, reject) =&gt; {…})： reslove和reject是跳转到解决或拒绝状态的函数。两个函数都可以传递一个参数，resolve的参数表示解决期约的值（感觉有点像返回值）。reject的参数表示拒绝的理由。<strong>此外，reject还会抛出一个异常</strong></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">Promise(()</span> =&gt; set<span class="constructor">Timeout(<span class="params">console</span>.<span class="params">log</span>, 0, &#x27;<span class="params">executor</span>&#x27;)</span>);</span><br><span class="line">set<span class="constructor">Timeout(<span class="params">console</span>.<span class="params">log</span>, 0, &#x27;<span class="params">promise</span> <span class="params">initialized</span>&#x27;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//executor</span></span><br><span class="line"><span class="comment">//promise initialized</span></span><br></pre></td></tr></table></figure><p>异步的执行器是同步执行的，所以executor在promise initialized前面输出。</p><p>reject抛出的异常是不能被常规的try/catch捕获的，例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 Uncaught (in promise) Error: bar</span></span><br></pre></td></tr></table></figure><h2 id="thencatch"><a class="markdownIt-Anchor" href="#thencatch"></a> then，catch</h2><h3 id="then"><a class="markdownIt-Anchor" href="#then"></a> then</h3><p>Promise.prototype.then()可以为期约添加处理程序。也就是receive和reject的处理程序。例如：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">let p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line">let p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>));</span><br><span class="line">p1.<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;p1&quot;</span>)), <span class="function"><span class="params">()</span>=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;p1&quot;</span>));</span><br><span class="line">p2.<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;p2&quot;</span>)), <span class="function"><span class="params">()</span>=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;p2&quot;</span>));</span><br><span class="line">三秒后输出</span><br><span class="line">p1 resolved</span><br><span class="line">p2 rejected</span><br></pre></td></tr></table></figure><ul><li>Promise then(onresolve, onreject): 两个参数必须是函数类型，如果不需要onresolve可以传null。返回值是一个新的期约实例。这个期约实例是<strong>根据期约的状态创建的</strong>如果是解决状态那么会调用onresolve。<strong>如果原来是pending那么两个函数都不会执行</strong>。如果没有提供处理程序，那么会直接返回上一个期约的处理值。如果没有onResolve中没有显式的处理程序，那么会返回undefined。</li></ul><p>新的期约默认是解决状态，如果在then中返回一个新的期约并且是pending状态那么返回也是pending状态。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="module-access"><span class="module"><span class="identifier">Promise</span>.</span></span>resolve(&#x27;foo&#x27;);<span class="comment">//直接抛出解决的期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="keyword">then</span><span class="literal">()</span>;</span><br><span class="line">set<span class="constructor">Timeout(<span class="params">console</span>.<span class="params">log</span>, 0, <span class="params">p2</span>)</span>;<span class="comment">//Promise&lt;resolved&gt;: foo(没有处理程序会返回上一个期约的返回值)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="keyword">then</span>(<span class="literal">()</span>=&gt;&#x27;bar&#x27;);<span class="comment">//bar</span></span><br><span class="line">set<span class="constructor">Timeout(<span class="params">console</span>.<span class="params">log</span>, 0, <span class="params">p3</span>)</span>;<span class="comment">//Promise&lt;resolved&gt;: bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="keyword">then</span>(<span class="literal">()</span>=&gt; <span class="module-access"><span class="module"><span class="identifier">Promise</span>.</span></span>reject<span class="literal">()</span>);</span><br><span class="line"><span class="comment">//Uncaught (in promise): undefined</span></span><br><span class="line">set<span class="constructor">Timeout(<span class="params">console</span>.<span class="params">log</span>, 0, <span class="params">p4</span>)</span>;<span class="comment">//Promise&lt;rejected&gt;: undefined</span></span><br></pre></td></tr></table></figure><p>他直接运行resolve函数，可以在resolve函数中决定期约的状态。如果在resolve中抛出错误，则会调用rejected函数</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">let p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">let p1 = p.<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>&#125;);</span><br><span class="line">//Uncaught (<span class="keyword">in</span> promise) baz</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1);//<span class="built_in">Promise</span>&lt;rejected&gt; baz</span><br><span class="line">但是如果返回错误值结果是resolved状态</span><br><span class="line">let p2 = p.<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2);//<span class="built_in">Promise</span>&lt;resolved&gt;: Error: qux</span><br></pre></td></tr></table></figure><p>期约一旦落定，由这个期约所产生的期约都会延迟到当前线程同步代码的末尾执行。例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);resolve();&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p.then(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">输出为</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>如果有多个期约进入了接收或拒绝状态，那么他们后面的顺序按照代码顺序来</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="module-access"><span class="module"><span class="identifier">Promise</span>.</span></span>resolve<span class="literal">()</span>;</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="module-access"><span class="module"><span class="identifier">Promise</span>.</span></span>reject<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">p1.<span class="keyword">then</span>(<span class="literal">()</span>=&gt; set<span class="constructor">Timeout(<span class="params">console</span>.<span class="params">log</span>, 0, 1)</span>);</span><br><span class="line">p2.<span class="keyword">then</span>(<span class="literal">()</span>=&gt; set<span class="constructor">Timeout(<span class="params">console</span>.<span class="params">log</span>, 0, 2)</span>);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure><blockquote><p>如果前面的状态是reject，那么后面会调用onreject函数，并且返回期约的状态是resolve，因为你对reject状态进行处理</p></blockquote><h3 id="catch"><a class="markdownIt-Anchor" href="#catch"></a> catch</h3><p>catch是一个语法糖，它相当于只有onRejected处理程序</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject();</span><br><span class="line"><span class="keyword">let</span> onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, rejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, onRejected);<span class="comment">//rejected</span></span><br><span class="line">p.catch(onRejected);<span class="comment">//rejeected</span></span><br><span class="line"><span class="comment">//二者相同</span></span><br></pre></td></tr></table></figure><p><strong>finally</strong></p><p>Promise.prototype.finally()用来添加onFinally程序，他在解决或拒绝状态都会触发，但是他没法知道事解决还是拒绝状态，因此一般只用来清理代码。</p><p>和前面的then不同，它在大多数情况下都会原样后传父期约，而不会改变他。</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">let p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">let p1 = p.<span class="keyword">finally</span>();</span><br><span class="line">let p2 = p.<span class="keyword">finally</span>(<span class="function"><span class="params">()</span>=&gt;</span><span class="literal">undefined</span>);</span><br><span class="line">let p3 = p.<span class="keyword">finally</span>(<span class="function"><span class="params">()</span>=&gt;</span><span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1);</span><br><span class="line">...</span><br><span class="line"><span class="regexp">//</span>三个的返回值都是<span class="built_in">Promise</span> &lt;resolved&gt;: foo</span><br></pre></td></tr></table></figure><p>如果返回待定期约或者出现错误则会返回相应的期约</p><h2 id="期约连锁和期约合成"><a class="markdownIt-Anchor" href="#期约连锁和期约合成"></a> 期约连锁和期约合成</h2><p>期约连锁是让多个期约依次执行。也就是使用多个then。</p><p>例如:</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">let p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p1 executor&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p2 executor&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;)).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>这样比较直观，但是如果不使用期约也可以实现类似功能</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">function delay(str, callback=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(str);</span><br><span class="line">        callback &amp;&amp; callback();</span><br><span class="line">    ), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="string">&#x27;p1&#x27;</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    delay(<span class="string">&#x27;p2&#x27;</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        delay(<span class="string">&#x27;p3&#x27;</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            delay(<span class="string">&#x27;p4&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一个契约可以由任意多个处理程序，我们可以使用有向图进行描述</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  A</span><br><span class="line"> &#x2F; \</span><br><span class="line">B   C</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>Promise.all()</strong></p><p>Promise.all会在所有期约解决之后再解决。例如</p> <figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">let p = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);</span><br><span class="line">p.<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;all&#x27;</span>);</span><br></pre></td></tr></table></figure><p>只要有一个拒绝，那么最终的期约就是拒绝状态，返回值是第一个拒绝期约的理由</p><p><strong>Promise.race()</strong></p><p>返回一组期约中最先解决期约的镜像。</p> <figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"> let p = <span class="built_in">Promise</span>.race([</span><br><span class="line">     <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line">     <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span>=&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);//<span class="built_in">Promise</span>&lt;resolved&gt;: <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="期约扩展"><a class="markdownIt-Anchor" href="#期约扩展"></a> 期约扩展</h2><p><strong>期约取消</strong></p><p>期约是内部封闭的，我们无法决定它是什么时候停止。但是也有一些方法突破这个障碍</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cancel</span></span></span><br><span class="line">&#123;</span><br><span class="line">    constructor(cancelfn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span>=&gt;</span>&#123;</span><br><span class="line">            cancelfn(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;delay cancel&#x27;</span>);</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const startButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#start&#x27;</span>);</span><br><span class="line">const cancelButton =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#cancel&#x27;</span>);</span><br><span class="line"></span><br><span class="line">function cancellabelDelayedResolve(delay)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;set delay&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span>=&gt;</span>&#123;</span><br><span class="line">        const id = <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;delayed resolve&#x27;</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        )), delay);</span><br><span class="line">        const cancel = <span class="keyword">new</span> Cancel(<span class="function"><span class="params">(cancelCallback)</span>=&gt;</span></span><br><span class="line">        cancelButton.addEventListener(<span class="string">&#x27;click&#x27;</span>, cancelCallback));</span><br><span class="line">        cancel.promise.<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">clearTimeout</span>(id));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>期约进度通知</strong></p><p>基本思想是首先添加notify函数，然后在合适的时刻执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">extendPromise</span> <span class="keyword">extends</span> <span class="title">Promise</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">executor</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> notifyHandlers = [];</span><br><span class="line">        <span class="built_in">super</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> executor(resolve, reject, <span class="function">(<span class="params">status</span>)=&gt;</span>&#123;</span><br><span class="line">            notifyHandlers.map(<span class="function">(<span class="params">handler</span>)=&gt;</span>handler(status));<span class="comment">//执行每一个notify</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    notify(notifyHandler)<span class="comment">//添加notify函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.notifyHandlers.push(notifyHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> extendPromise(<span class="function">(<span class="params">resolve, reject, notify</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            notify(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>&amp; remaining`</span>);<span class="comment">//对每一个notify函数传该字符串</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>countdown(x - <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    countdown(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="异步函数"><a class="markdownIt-Anchor" href="#异步函数"></a> 异步函数</h1><p>格式：</p><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">async function foo()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = async function()<span class="meta">&#123;...&#125;</span>;</span><br><span class="line"><span class="keyword">let</span> baz = async ()=&gt;();</span><br><span class="line">class <span class="type">Qux</span></span><br><span class="line">&#123;</span><br><span class="line">    async qux()<span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他和普通函数的区别是如果它使用return返回了值那么返回值将会由Promise.resolve()包装成期约。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3(延迟执行</span></span><br></pre></td></tr></table></figure><p>如果抛出错误会返回拒绝的期约</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo.catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">但是如果在函数内部出现拒绝期约，这个错误不会被异步函数捕获</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo.catch(conosole.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//Uncaught(in promise): 3</span></span><br></pre></td></tr></table></figure><p><strong>await</strong></p><p>await表示该代码要在期约结束后再执行。例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">baz();<span class="comment">//1秒后输出</span></span><br><span class="line"></span><br><span class="line">如果没有<span class="keyword">await</span>，会先输出baz</span><br></pre></td></tr></table></figure><p>await必须在异步函数中使用，如果不是会抛出SyntaxError异常。</p><p>使用await后执行顺序较Promise更为复杂，看一个例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">8</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">输出顺序是字母顺序</span><br></pre></td></tr></table></figure><ol><li>首先带有await的都被推迟到同步代码的末尾执行，因此先输出1、2、3、4、5</li><li>然后foo中的await部分开始执行，它会先执行期约处理程序，然后把结果放到消息队列的末尾</li><li>然后执行第二个await，因为它已经获得值6了，因此它可以继续向下执行，输出6,7</li><li>现在第一个await获得了值，输出8,9</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;期约&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>js 代理和反射</title>
    <link href="https://xinhecuican.github.io/post/6a44c331.html"/>
    <id>https://xinhecuican.github.io/post/6a44c331.html</id>
    <published>2021-07-05T11:15:00.000Z</published>
    <updated>2021-07-07T12:15:15.824Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="代理基础"><a class="markdownIt-Anchor" href="#代理基础"></a> 代理基础</h1><p>代理是目标对象的抽象。代理类似于c++的指针，可以通过代理操作对象，但是它又是一个独立的变量。在代理上的修改会反映到目标对象上，在目标对象上的修改也会对代理起作用</p><p><strong>创建</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = </span><br><span class="line">&#123;</span><br><span class="line">    id: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);<span class="comment">//两个参数，第一个是操作的对象，第二个是处理程序对象，用来定义捕获器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id);<span class="comment">//target</span></span><br><span class="line"></span><br><span class="line">可以通过revocable()定义撤销代理，并且还可以通过一个返回值进行撤销,撤销完成后再使用代理会产生异常</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123; <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="string">&#x27;intercepted&#x27;</span>;&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(traget, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);<span class="comment">//intercepted</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);<span class="comment">//bar</span></span><br><span class="line"></span><br><span class="line">revoke();<span class="comment">//执行撤销，是Proxy.revocable的一个返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);</span><br></pre></td></tr></table></figure><p><strong>代理的一些不足</strong></p><p>由于代理和原对象毕竟是两个对象，所以在涉及this时可能会出现问题</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = ew <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">user_id</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wm.set(<span class="built_in">this</span>.user_id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> <span class="title">id</span>(<span class="params">user_id</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wm.set(<span class="built_in">this</span>, user_id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> <span class="title">id</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        wm.get(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.id);<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInstanceProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(userInstanceProxy.id);<span class="comment">//undefine</span></span><br><span class="line">这是因为user和userInstanceProxy对象不同，因此<span class="built_in">this</span>不同，导致无法检索</span><br></pre></td></tr></table></figure><h2 id="捕获器trap"><a class="markdownIt-Anchor" href="#捕获器trap"></a> 捕获器（trap）</h2><p>使用代理主要就是为了定义捕获器。捕获器<strong>是target中基本操作的拦截器</strong>。每次调用代理时，首先会调用捕获器函数，从而进行拦截和修改。捕获器类似于sql中的触发器</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = </span><br><span class="line">&#123;</span><br><span class="line">    foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler =</span><br><span class="line">&#123;</span><br><span class="line">    get()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);<span class="comment">//handler override</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy[<span class="string">&#x27;foo&#x27;</span>]);<span class="comment">//handler override</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.create(proxy)[<span class="string">&#x27;foo&#x27;</span>]);<span class="comment">//handler override</span></span><br></pre></td></tr></table></figure><p>通过定义get()捕获器，之后每次执行get操作时，都会触发get捕获器.诸如<code>.</code>、<code>[]</code>等操作都认为是get操作。但是在原对象上执行的操作不受影响。</p><p>捕获器可以访问当前是在操作哪个变量，从而执行相应的操作，例如</p><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler =</span><br><span class="line">&#123;</span><br><span class="line">    get(rapTarget, <span class="keyword">property</span><span class="string"></span>, receiver)<span class="comment">//trapTarget是代理的目标对象，receiver是代理自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(trapTarget === target);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">property</span><span class="string">)</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(receiver === proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.foo;<span class="comment">//true, foo, true</span></span><br></pre></td></tr></table></figure><p><strong>捕获器不变式</strong></p><p>捕获器可以捕获大部分基本操作，但是有一些操作会导致异常。捕获器不变式就是保证不会出现异常的约束。</p><p>例如：目标对象有一个不可写的属性，如果捕获器中返回了一个其他值，那么就会出现TypeError</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">&#x27;foo&#x27;</span>,&#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = </span><br><span class="line">&#123;</span><br><span class="line">    get()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;qux&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);<span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure><p>捕获器总共可以捕获13种基本操作</p><p><strong>get()</strong></p><p>get会拦截获取属性值的操作，对应的反射方法为Reflect.get()</p><ul><li>get(target, property, receiver): target是目标对象，property是操作属性的名字，receiver是带你对象</li></ul><p>拦截的操作有:</p><ul><li>proxy.property</li><li>proxy[property]</li><li>Object.create(proxy)[property]</li><li>Reflect.get(proxy, property, receiver)//反射是调用原函数</li></ul><p><strong>set</strong></p><p>set拦截设置属性值的操作，反射方法为Reflect.set()</p><ul><li>bool set(target, property, value, receiver): value是设置的值，返回值为true代表操作成功，false表示操作失败</li></ul><p>拦截的操作：</p><ul><li>proxy.property = value</li><li>proxy[property] = value</li><li>Object.create(proxy)[property] = value</li><li>Reflect.set(proxy, property, value, receiver)</li></ul><p>捕获器不变式(约束):</p><ul><li>如果target的property不可写且不可配置，则不能修改目标属性的值</li><li>如果target.property不可配置并且[[Set]]为undefined，则不能修改属性值</li></ul><p><strong>has</strong></p><p>has会捕获in操作符中的操作，反射为Reflect.has()</p><ul><li>bool has(target, property): 返回值表示这个属性是否存在</li></ul><p>拦截的操作：</p><ul><li>property in proxy</li><li>property in Object.create(proxy)</li><li>with(proxy) { (property);}</li><li>Reflect.has(proxy, property);</li></ul><p>不变式：</p><ul><li>如果target.property存在且不可配置，则必须返回true</li><li>target.property存在且目标对象不可扩展（不能添加新的属性，通过Object.preventExtensions(object)设置),则必须返回true</li></ul><p><strong>defineProperty</strong></p><p>拦截Object.defineProperty(),反射方法为Reflect.defineProperty()</p><ul><li>bool defineProperty(target, property, descriptor): 返回值表示是否成功定义。descriptor有enumrable、configurable、writable、value、get、set</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> my Target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">    defineProperty(target, property, descriptor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不变式：</p><ul><li>如果目标对象不可扩展，则无法定义属性</li><li>如果有一个可配置属性，不可添加同名的不可配置属性</li><li>如果有一个不可配置属性，不可添加同名的配置属性</li></ul><p><strong>getWonPropertyDescriptor</strong></p><p>捕获Object.getOwnPropertyDescriptor()。反射方法为Relfect.getOwnPropertyDescriptor()</p><ul><li>Object getOwnPropertyDescriptor(target, property): 返回描述对象，如果对象不存在则返回undefined</li></ul><p>不变式：</p><ul><li>target.property存在且可配置，这必须返回对应对象</li><li>target.property存在且target不可扩展，则处理程序必须返回一个表示该属性存在的对象</li><li>target.property不存在，则返回undefined</li></ul><p><strong>deleteProperty</strong></p><p>会在delete操作符中调用，对应的反射方法为Reflect.deleteProperty()</p><ul><li>bool deleteProperty(target, property): 返回值表示删除属性是否成功</li></ul><p>不变式：</p><ul><li>如果target.property存在且不可配置，则处理程序不能删除这个属性</li></ul><p><strong>onwKeys</strong></p><p>拦截Object.keys()（返回对象属性的属性名）,反射方法为Reflect.ownKeys()</p><ul><li>list ownKyes(target): 返回可枚举对象</li></ul><p>不变式：</p><ul><li>返回的枚举对象必须包含所有的不可配置的自有属性</li><li>如果对象不可扩展，则返回可枚举对象必须准确包含自有属性键</li></ul><p><strong>getPrototypeOf</strong></p><p>捕获获得prototype的操作。反射API为Reflect.getPrototypeOf()</p><ul><li>object getPrototypeOf(target): 返回值是原型对象或者是NULL</li></ul><p>拦截的操作：</p><ul><li>Object.getPrototypeOf(proxy)</li><li>Reflect.getPrototypeOf(proxy)</li><li><code>proxy.__proto__</code></li><li>Object.prototype.isPrototypeOf(proxy)</li><li>proxy instanceof Object</li></ul><p>捕获器不变式：</p><ul><li>如果target不可扩展，则唯一有效的返回值是Object</li></ul><p><strong>setPrototypeOf</strong></p><p>捕获Object.setPrototypeOf(),反射的API为Reflect.setPrototypeOf()</p><ul><li>bool setPrototypeOf(target, prototype): 返回值表示设置是否成功</li></ul><p>不变式：</p><ul><li>如果target不可扩展，则唯一有效的参数是这个对象的原型</li></ul><p><strong>isExtensible</strong></p><p>捕获Object.isExtensible，反射API为Reflect.isExtensible()</p><ul><li>bool isExtensible(target): 返回值表示target是否可扩展</li></ul><p>不变式：</p><ul><li>如果target可扩展，则处理程序必须返回true</li><li>如果target不可扩展，则处理程序必须返回false</li></ul><p><strong>preventExtensions</strong></p><p>…</p><p>返回值表示target是否已经不可扩展</p><p>不变式： 如果Object.isExtensible(proxy)是false，那么处理程序必须返回true</p><p><strong>apply</strong></p><p>它会在调用函数时调用，反射方法为Reflect.apply()</p><ul><li>apply(target, thisArg, argumentsList): thisArg是调用函数时的this参数，返回值任意</li></ul><p>拦截的操作：</p><ul><li>proxy(…argumentList)</li><li>Fuction.prototype.apply(thisArg, argumentList)</li><li>Function.prototype.call(thisArg, …argumentsList)</li><li>Reflect.apply(target, thisArgument, argumentList)</li></ul><p>不变式：</p><ul><li>target必须是一个函数对象</li></ul><p><strong>construct</strong></p><p>它会在new操作符中被调用，反射方法为Reflect.construct()</p><ul><li>Object construct(target, argumentsList, newTarget): target是目标构造函数，newTarget是最初被调用的构造函数（可能子类调用了父类的构造函数）。返回值是构造完成的对象</li></ul><p>不变式：</p><ul><li>target必须可以被用作构造函数</li></ul><h2 id="代理的应用"><a class="markdownIt-Anchor" href="#代理的应用"></a> 代理的应用</h2><p><strong>跟踪属性访问</strong></p><p>我们可以通过捕获get、set和has等操作，对对象进行监控</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = </span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&#x27;Jake&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    get(target, property, receiver)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getting $&#123;property&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    set(target, property, value, receiver)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setting $&#123;property&#125;=$&#123;value&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name;<span class="comment">//getting name</span></span><br><span class="line">proxy.age = <span class="number">27</span> <span class="comment">// setting age=27</span></span><br></pre></td></tr></table></figure><p><strong>隐藏属性</strong></p><p>因为代理内部对外部代码是不可见的，所以可以很方便的隐藏对象属性.此外，还可以通过set拒绝属性访问，通过apply对函数参数进行审查。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hidden = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> targetObject = </span><br><span class="line">&#123;</span><br><span class="line">   foo: <span class="number">1</span>,</span><br><span class="line">   bar: <span class="number">2</span>,</span><br><span class="line">   baz: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetObject, &#123;</span><br><span class="line">    get(target, property)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hidden.includes(property))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>数据绑定</strong></p><p>可以在构造时就添加入列表，避免错误。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">name</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name_ = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> newUser = <span class="built_in">Reflect</span>.construct(...arguments);</span><br><span class="line">        list.push(newUser);</span><br><span class="line">        <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h1><p>在java或c#语言中，反射的含义是通过函数名字字符串找到对应的函数.例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = </span><br><span class="line">&#123;</span><br><span class="line">    foo: <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = </span><br><span class="line">&#123;</span><br><span class="line">    get()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);<span class="comment">//通过Reflect.get反射到了target的get方法并且可以直接访问原对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);<span class="comment">//bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);<span class="comment">//bar</span></span><br><span class="line"></span><br><span class="line">我们可以使用这种方法获得本应该获得的结果，并且还可以加上一些修饰，例如</span><br><span class="line">get()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;代理基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor</summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>js迭代器和生成器</title>
    <link href="https://xinhecuican.github.io/post/1931a47d.html"/>
    <id>https://xinhecuican.github.io/post/1931a47d.html</id>
    <published>2021-07-04T10:29:00.000Z</published>
    <updated>2021-07-04T13:10:27.008Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h1><p>在很多语言中都有迭代器，例如</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">QList&lt;int&gt;::iterator iter = list.begin();</span><br><span class="line"><span class="keyword">while</span>(iter != list.end())</span><br><span class="line">&#123;</span><br><span class="line">    iter = iter-&gt;next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在js中</span><br><span class="line">let <span class="builtin-name">set</span> = new <span class="builtin-name">Set</span>().<span class="builtin-name">add</span>(3).<span class="builtin-name">add</span>(1).<span class="builtin-name">add</span>(4)</span><br></pre></td></tr></table></figure><p>通过上面的例子可以看出，迭代器的关键是不断返回一个相同类型的不同实例。在js中，实现Iterable接口就可以认为是一个迭代器。<strong>迭代器</strong>是按需创建的一次性对象，每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联对象的API（例如next）</p><p>实现Iterator接口需要实现两种能力： 自我识别能力和创建实现Iterator接口的对象的能力。这意味着需要暴露一个属性作为默认迭代器，并且这个属性还要以Symbol.iterator作为键。默认迭代器必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。</p><p>常见的实现了Iterator接口的类：字符串、数组、map、set、arguments、NodeList</p><p>可以使用for-of循环、数组解构、Array.from()等对迭代器进行遍历</p><h2 id="自定义迭代器"><a class="markdownIt-Anchor" href="#自定义迭代器"></a> 自定义迭代器</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(limit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    next()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.count &lt;= <span class="keyword">this</span>.limit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;done: <span class="literal">false</span>, value: <span class="keyword">this</span>.count++&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;done:<span class="literal">true</span>, value: undefined&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [Symbol.iterator]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述类实现了迭代器，首先我们可以使用iterator获得迭代类，并且next可以用来返回下一个对象。</p><p>但是这种方法并不理想，因为每个实例只能够被迭代一次。为了可以迭代多次，可以创建一个计数器</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">limit</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> limit = <span class="built_in">this</span>.limit;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        &#123;</span><br><span class="line">            next()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count &lt;= limit)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: cont++&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，每次调用Symbol.iterator时数据总是会变为初始状态。</p><p><strong>提前终止</strong></p><p>可以增加return()来提前终止迭代器。在for-of循环中，可以通过break、continue、return或throw提前退出</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">limit</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> limit = <span class="built_in">this</span>.limit;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        &#123;</span><br><span class="line">            next()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count &lt;= limit)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">false</span>, <span class="attr">value</span>: count++&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">return</span>()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生成器"><a class="markdownIt-Anchor" href="#生成器"></a> 生成器</h1><p>构造: 在函数名称前加一个星号(*)来表示它是生成器</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generatorFn = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = </span><br><span class="line">&#123;</span><br><span class="line">    * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">*号两边空格数目不影响解析</span><br></pre></td></tr></table></figure><h2 id="yield"><a class="markdownIt-Anchor" href="#yield"></a> yield</h2><p>调用生成器会产生一个生成器对象。这个对象实现了Iterator。每次调用next()都会跳转到下一个yield</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generator.next());<span class="comment">//foo</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next());<span class="comment">//bar</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next());<span class="comment">//baz</span></span><br></pre></td></tr></table></figure><p>每次执行到yield后就输出并停止执行，但是它的状态时保存的，下一次可以继续使用上一次yield中的变量。</p><p>碰到yield，next返回的done是false如果碰到return则done为true。即return终止迭代。</p><p>yield只有在生成器函数内部定义中有效，诸如闭包，内部函数等使用都会报错</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gene</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="function">()=&gt;</span>&#123;<span class="keyword">yield</span>;&#125;)();</span><br><span class="line">&#125;</span><br><span class="line">上面两种都会报错</span><br></pre></td></tr></table></figure><p><strong>yield接收输入</strong></p><p>yield除了作为输出返回值使用，<strong>他还可以接收传给next的第一个值</strong>。但是第一次调用next输入的参数是无效的，这一次调用是为了启动生成器函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gene</span>(<span class="params">initial</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(initial);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = gene(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">generator(<span class="string">&#x27;bar&#x27;</span>);<span class="comment">//foo，是因为第一次执行到yield就停止，并且没有输入任何参数</span></span><br><span class="line">generator(<span class="string">&#x27;baz&#x27;</span>);<span class="comment">//baz,第一个yield接收这个参数</span></span><br><span class="line">generator(<span class="string">&#x27;qux&#x27;</span>);<span class="comment">//qux</span></span><br></pre></td></tr></table></figure><p>yield可以同时用于输入和输出</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let gene = generator();</span><br><span class="line"></span><br><span class="line">gene.<span class="built_in">next</span>();//foo,做输出用</span><br><span class="line">gene.<span class="built_in">next</span>(<span class="string">&quot;bar&quot;</span>);//bar,<span class="built_in">yield</span>接收输入并<span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>yield与*配合</strong></p><p>yield后面可以接*来多次返回值，例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gene</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> gene())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);<span class="comment">//1, 2, 3, 4, 5, 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用这个很方便的实现递归操作</p><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">function</span> <span class="function"><span class="title">nTimes</span>(<span class="variable">n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="variable">n</span> &gt; <span class="number">0</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">yield</span>* <span class="function"><span class="title">nTimes</span>(<span class="variable">n</span> - <span class="number">1</span>);</span></span><br><span class="line"><span class="function">        <span class="variable">yield</span> <span class="variable">n</span> - <span class="number">1</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="variable">const</span> <span class="variable">x</span> <span class="variable">of</span> <span class="title">nTimes</span>(<span class="number">3</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">console.log</span>(<span class="variable">x</span>);<span class="comment">//0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">过程为</span><br><span class="line"><span class="function"><span class="title">nTimes</span>(<span class="number">2</span>);</span></span><br><span class="line"><span class="function"><span class="title">nTimes</span>(<span class="number">1</span>);</span></span><br><span class="line"><span class="function"><span class="title">nTimes</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="function"><span class="number">0</span></span></span><br><span class="line"><span class="function"><span class="number">1</span></span></span><br><span class="line"><span class="function"><span class="number">2</span></span></span><br></pre></td></tr></table></figure><p>也可以使用这种方法为类添加迭代器</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span>* <span class="built_in">this</span>.values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提前终止生成器"><a class="markdownIt-Anchor" href="#提前终止生成器"></a> 提前终止生成器</h2><p>所有的生成器都有return()方法，他会直接让生成器进入关闭状态，并且之后都无法恢复。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">//&#123;done:false, value: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">4</span>));<span class="comment">//&#123;done:true, value: 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g);<span class="comment">//generatorFn&#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>此外，还可以通过throw将错误抛出，如果错误未被处理，生成器将关闭.但是如果生成器函数内部处理了这个错误，那么生成器不会关闭</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gene</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = gene();</span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">//1</span></span><br><span class="line">g.throw(<span class="string">&#x27;foo&#x27;</span>);产生错误但是生成器内部接住了</span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">//3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;迭代器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;</summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>c++ 两个类互相引用</title>
    <link href="https://xinhecuican.github.io/post/cbf07f5d.html"/>
    <id>https://xinhecuican.github.io/post/cbf07f5d.html</id>
    <published>2021-06-23T11:04:00.000Z</published>
    <updated>2021-07-23T13:13:01.455Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>两个类互相引用如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_b</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------b.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_A</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看看上面的过程。加入首先发现a.h,然后根据a.h把b.h拖进来，然后b.h又把a.h拖进来，此时a.h包含a.h和b.h的内容，也就是说b.h定义了两次，因此会报错。</p><p>我们可以使用声明提前的方法解决这个问题</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_b</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">---------------------b.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _B_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span><span class="comment">//只是声明没有定义，因此只能使用指针。因为如果是一个完整的类的话需要知道大小</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B();</span><br><span class="line">    ~B();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A* a;<span class="comment">//使用指针</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endef</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------a.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line">A::A()</span><br><span class="line">&#123;</span><br><span class="line">    b = B();</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::print_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.get_data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_data</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> sum;&#125;</span><br><span class="line"></span><br><span class="line">--------------------b.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是必须是include a,因为开始只定义了class A这一个符号，里面有什么函数我们都不知道，通过include a.h我们才知道A的函数</span></span><br><span class="line"><span class="comment">并且include a.h的同时也include b.h，因为a.h中有include b.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">B::B()</span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="keyword">new</span> A();</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::print_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a-&gt;get_data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">B::get_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这只是一种权宜之计，出现循环定义本身就代表了代码写的有问题，他容易带来一些不易察觉的问题。</p><p>例如<br />B中引用了A，并且A使用new新建了若干个b的变量。然后在另一个类中A在一个list中，这时我们可能发现过一会B使用A会报错。</p><p>这是因为list中的变量经常创建和销毁，销毁时会执行拷贝。但是创建了新的A后B中A的指针还是指向原来被销毁的A，便会出现段错误</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;两个类互相引用如&lt;/p&gt;
&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="c++" scheme="https://xinhecuican.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>关联规则</title>
    <link href="https://xinhecuican.github.io/post/42e73f05.html"/>
    <id>https://xinhecuican.github.io/post/42e73f05.html</id>
    <published>2021-06-01T11:52:00.000Z</published>
    <updated>2021-06-01T13:25:17.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="引例"><a class="markdownIt-Anchor" href="#引例"></a> 引例</h1><p><strong>啤酒与尿布</strong></p><p>在一家超市里，有一个有趣的现象：尿布和啤酒赫然摆在一起出售。但是这个奇怪的举措却使尿布和啤酒的销量双双增加了。这不是一个笑话，而是发生在美国沃尔玛连锁店超市的真实案例，并一直为商家所津津乐道。沃尔玛拥有世界上最大的数据仓库系统，为了能够准确了解顾客在其门店的购买习惯，沃尔玛对其顾客的购物行为进行购物篮分析，想知道顾客经常一起购买的商品有哪些。沃尔玛数据仓库里集中了其各门店的详细原始交易数据。在这些原始交易数据的基础上，沃尔玛利用数据挖掘方法对这些数据进行分析和挖掘。</p><p>一个意外的发现是：&quot;跟尿布一起购买最多的商品竟是啤酒！经过大量实际调查和分析，揭示了一个隐藏在&quot;尿布与啤酒&quot;背后的美国人的一种行为模式：在美国，一些年轻的父亲下班后经常要到超市去买婴儿尿布，而他们中有30%～40%的人同时也为自己买一些啤酒。产生这一现象的原因是：美国的太太们常叮嘱她们的丈夫下班后为小孩买尿布，而丈夫们在买尿布后又随手带回了他们喜欢的啤酒。<br />按常规思维，尿布与啤酒风马牛不相及，若不是借助数据挖掘技术对海量交易数据进行挖掘和分析，沃尔玛是不可能发现数据内在这一有价值的规律的。</p><h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>从上例可以看出某些看起来不具有关联的事务实际上也有关联，为了找到这些关联，首先定义一些符号。</p><p>关联规则是一个蕴含式 x=&gt;y。他表示当x出现时y也一定会出现。</p><p>当然这种情况是非常少的，一般带有一定概率，为了表示这种概率，我们定义了<strong>支持度</strong>进行表示：D（所有样本）中包含X、Y的数量和所有交易数之比，记为Support(x=&gt;y)或S</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><mo stretchy="false">{</mo><mi>T</mi><mo>:</mo><mi>X</mi><mo>∩</mo><mi>Y</mi><mo stretchy="false">}</mo><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>D</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">S = \frac{|\{T: X \cap Y\}|}{|D|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">}</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>置信度是D中包含X、Y的交易数和X的交易数之比，记为confidence(x=&gt;y)或C</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>S</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><mo stretchy="false">{</mo><mi>T</mi><mo>:</mo><mi>X</mi><mo>∩</mo><mi>Y</mi><mo stretchy="false">}</mo><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>T</mi><mo>:</mo><mi>X</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">C = S = \frac{|\{T: X \cap Y\}|}{|T: X|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">}</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>支持度表示了这种类型在所有样本中出现的概率，如果概率太小表示这种情况出现很少，不具有代表性。而置信度表示了二者之间的联系，置信度越高联系越紧密。</p><p>关联规则就是要找支持度和置信度都大于某一范围的。</p><p>使用文字描述可以认为</p><figure class="highlight tp"><table><tr><td class="code"><pre><span class="line">C = 同时购买商品<span class="keyword">X</span>和<span class="keyword">Y</span>的交易数/购买<span class="keyword">X</span>的交易数</span><br><span class="line">S = 同时购买<span class="keyword">X</span>和<span class="keyword">Y</span>的交易数/总交易数</span><br></pre></td></tr></table></figure><h1 id="apriori算法"><a class="markdownIt-Anchor" href="#apriori算法"></a> Apriori算法</h1><p>术语：</p><ul><li>频繁项集： 支持度大于最小支持度的项集</li></ul><p>规则：</p><ul><li>一个频繁项集的子集一定是频繁项集</li><li>一个非频繁项集的超集一定不是频繁项集</li><li>连接规则： 我们可以把两个部分相同项集相同的部分合并，变成一个项集。例如ABC和BCE可以合成ABCE</li></ul><p>例如：</p><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">第一次购买    AB</span><br><span class="line"><span class="number">2</span>          BCE</span><br><span class="line"><span class="number">3</span>          ABCE</span><br><span class="line"><span class="number">4</span>         AD</span><br><span class="line">假设置信度和支持度最少都要是<span class="number">50</span><span class="comment">%</span></span><br></pre></td></tr></table></figure><ol><li>首先选择只有一个的项集。A B C D E.其中D的支持度只有25%小于最小支持度，抛弃</li><li>从A、B、C、E中得到两个的项集，有AB、AC、AE、BC、BE、CE。其中AC、AE小于最小支持度，抛弃</li><li>使用连接规则得到ABC、ABE、BCE、ACE。其中AC不是频繁项，所以ABC不存在，同理可以排除ACE、ABE，只剩下BCE。而BCE是频繁项集，所以保留</li></ol><p>从上面我们可以看出，算法过程大致为：</p><ol><li>首先找一个元素的频繁项集</li><li>根据一个元素的频繁项集找到两个元素的频繁项集</li><li>在多于两个元素的频繁项集中，首先使用联接规则找到k+1个元素的项集，然后使用前两个规则进行剪枝，最后找到频繁项集</li><li>重复上述步骤直到不能产生新的项集</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;引例&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="机器学习" scheme="https://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>js常用对象</title>
    <link href="https://xinhecuican.github.io/post/8e93d915.html"/>
    <id>https://xinhecuican.github.io/post/8e93d915.html</id>
    <published>2021-05-30T06:04:00.000Z</published>
    <updated>2021-07-03T13:32:12.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基本引用类型"><a class="markdownIt-Anchor" href="#基本引用类型"></a> 基本引用类型</h1><h2 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h2><p>Date和java的Date类似，里面保存的是从1970年1月1日至今的毫秒数。</p><p><strong>创建</strong></p><ul><li>Date(date): 创建一个Date对象，包含创建时的时间.date是字符串形式的时间，格式可以参照parse()的格式</li><li>Date.now(): 返回当前时间的毫秒数</li><li>Date.parse(): 将其他格式的时间字符串转换为该日期的毫秒数,例如<code>let someDate = new Date(Date.parse(&quot;May 23, 2019&quot;));</code><ul><li>可以使用下列格式</li><li>月/日/年： 如&quot;5/23/2019&quot;</li><li>月名 日, 年： 如&quot;May 23, 2019&quot;</li><li>周几 月名 日 年 时:分:秒:时区，如&quot;Tue May 23 2019 00:00:00 GMT-0700&quot;</li><li>YYYY-MM-DDTHH:mm:ss:sssZ,如&quot;2019-05-23T00:00:00</li></ul></li><li>Date.UTC(year, month, day, hour, minute, second):传入年、月(0-11)、日(1-31)、时(0-23)、分、秒并转化为毫秒数，如<code>let y2k = new Date(Date.UTC(2000, 0));</code></li></ul><p><strong>显示</strong></p><ul><li>toLocaleSting(): 输出类似于<code>2021/5/30 下午3:51:36</code></li><li>toString(): 输出为<code>Sun May 30 2021 15:51:36 GMT+0800 (中国标准时间)</code></li><li>toDateString(): 返回周几、月、日、年</li><li>toTimeString(): 返回时分秒和时区</li><li>toLocaleDateString(): 显示月日年</li><li>toLocaleTimeString(): 显示时分秒</li><li>toUTCString(): 显示完整的UTC时间</li></ul><p>还有一些获得单独时间的函数如getYear(),getDate()等可以从函数名得知意思就不再赘述。其中getTime()是获得毫秒的时间</p><h2 id="regexp"><a class="markdownIt-Anchor" href="#regexp"></a> RegExp</h2><p>RegExp是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>，可以通过一些简单的语法创建。如<code>let expression = /pattern/flags</code></p><blockquote><p>pattern可以设置lastIndex表示下次从该index处开始</p></blockquote><p>其中pattern是任何正则表达式。每个正则表达式可以带零个或多个标记(flags),用于控制正则表达式的行为，常见的标记有</p><ul><li>g(global): 全局模式，查找所有匹配字符串，而不是匹配一个就结束.</li><li>i(ignoreCase): 不区分大小写</li><li>m(multiline): 多行模式，查找到一行文本末尾会继续查找</li><li>y(sticky): 粘附模式，表示查找从lastIndex开始的字符串</li><li>u(unicode): Unicode模式，启用Unicode匹配</li><li>s(dotAll): dotAll模式，匹配任意字符（如<code>\n\r</code>等)</li></ul><p>可以使用后面的全称来访问是否设置了这些标记</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">pattern</span><span class="selector-class">.global</span>);</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">pattern</span><span class="selector-class">.source</span>);//表达式的字面字符串</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">pattern</span><span class="selector-class">.flags</span>);所有标记</span><br></pre></td></tr></table></figure><p>除了使用字面量，还可以使用构造函数来创建。例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;[bc]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>的模式参数时字符串，有些时候需要二次转义</span><br><span class="line"><span class="keyword">let</span> pattern3 = <span class="regexp">/\[bc\]at/</span></span><br><span class="line"><span class="keyword">let</span> pattern4 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\[bc\\]at&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>匹配</strong></p><p>使用RegExp进行匹配主要是exec(s)方法，方法的参例如：数是待匹配的字符串。如果成功，返回包含第一个匹配的数组，每个字符占一个位置。如果未成功，返回null。返回值虽然是数组，但是额外多加了index和input。index是匹配串中的起始位置，input是待匹配的字符串。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;mom and dad and baby&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);<span class="comment">//mom and data and baby</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]);<span class="comment">// and data and baby</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]);/ and baby</span><br></pre></td></tr></table></figure><p>每个括号表示一个捕获组，也就是第一个会匹配mom and dad and baby,第二个会匹配 and dad and baby.<a href="https://zh.javascript.info/regexp-groups#pi-pei-kuo-hao-zhong-de-nei-rong">有关捕获组可看这</a></p><p>如果使用了全局标记，那么一次匹配会显示一个匹配的信息，如果没有设置，那么只会返回第一个匹配信息。</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">text</span> = <span class="string">&#x27;cat, bat, sat, fat&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = /.<span class="keyword">at</span>/g;</span><br><span class="line"><span class="keyword">let</span><span class="built_in"> matches</span> = pattern.exec(<span class="type">text</span>);</span><br><span class="line">console.log<span class="built_in">(matches</span>[<span class="number">0</span>]);//cat</span><br><span class="line">matches = pattern.exec(<span class="type">text</span>);</span><br><span class="line">console.log<span class="built_in">(matches</span>[<span class="number">0</span>]);//bat</span><br></pre></td></tr></table></figure><p>如果使用了y，那么下次就会从lastIndex开始进行搜索，并且该标记会覆盖全局标记。注意y和g并不相同</p><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">let pattern = /.at/y;</span><br><span class="line">let matches = pattern.<span class="keyword">exec</span>(<span class="keyword">text</span>);</span><br><span class="line">console.<span class="keyword">log</span>(matches[<span class="number">0</span>]);<span class="comment">//cat</span></span><br><span class="line">console.<span class="keyword">log</span>(pattern.lastIndex);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">let matches = pattern.<span class="keyword">exec</span>(<span class="keyword">text</span>);</span><br><span class="line">console.<span class="keyword">log</span>(matches[<span class="number">0</span>])<span class="comment">//null</span></span><br><span class="line"><span class="comment">//和上面不同的原因是这里从3开始搜索，而3占据着.的位置，后面两个字符不是at，所以最终出错</span></span><br><span class="line"></span><br><span class="line">pattern.lastIndex = <span class="number">5</span>;</span><br><span class="line">matches = pattern.<span class="keyword">exec</span>(<span class="keyword">text</span>);</span><br><span class="line">console.<span class="keyword">log</span>(matches[<span class="number">0</span>]);<span class="comment">//bat</span></span><br></pre></td></tr></table></figure><blockquote><p>test(),如果有模式匹配则返回true</p></blockquote><p>此外RegExp本身还有一些属性</p><ul><li>input: 最后搜索的字符串</li><li>lastMatch: 最后匹配的文本</li><li>lastParen: 最后匹配的捕获组</li><li>leftContext: input字符串中出现在lastMatch前面的文本</li><li>rightContext: 出现在后面的文本</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;this has been a short summer&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input);<span class="comment">//this has been a shor summer</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext);<span class="comment">//this has been a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="boolean-number-string"><a class="markdownIt-Anchor" href="#boolean-number-string"></a> Boolean、Number、String</h2><p>这些都是原始值包装类型，也就是对原始值的行为进行扩充。每当用到某个原始值的方法和属性时，后台都会创建一个包含原始值的对象。</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let s1 = <span class="string">&#x27;some text&#x27;</span>;<span class="regexp">//</span>原始值</span><br><span class="line">let s2 = s1.substring(<span class="number">2</span>);<span class="regexp">//</span>创建了一个包装对象并调用substring函数</span><br></pre></td></tr></table></figure><p>包装类型的形成大致过程为：</p><ol><li>发现调用原始值的函数时，创建包装类型</li><li>调用实例上的方法</li><li>销毁实例</li></ol><p>这种方式也就意味着我们不能再包装类型上添加方法，因为它使用后会立刻销毁。可以显式的使用Boolean、Number、String创建包装对象，就可以对这些对象进行操作。但是不推荐直接使用包装类型，因为可能会导致一些错误。</p><p>构造函数创建的包装类型使用typedef会返回object，因此Object构造方法会根据传入参数不同自动转型。并且如果使用转型函数那么typeof会显示对应类型</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&#x27;some text&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);<span class="comment">//object</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;23&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">number</span> = <span class="built_in">Number</span>(value);<span class="comment">//转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">number</span>);<span class="comment">//number</span></span><br></pre></td></tr></table></figure><h3 id="number"><a class="markdownIt-Anchor" href="#number"></a> Number</h3><ul><li>toFixed(precision): 设置保留几位小数。例如 <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="attribute">console</span>.log(num.toFixed(<span class="number">2</span>));//<span class="number">10</span>.<span class="number">00</span></span><br></pre></td></tr></table></figure></li><li>toExponential(precision): 返回科学记数法形式的字符串，也可以设置精度</li><li>toPrecision(): 他会根据情况返回结果，可能是固定长度，也可能是科学记数法 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>;</span><br><span class="line">console.log(num.<span class="keyword">to</span><span class="constructor">Precision(1)</span>);<span class="comment">//1e+2</span></span><br><span class="line">console.log(num.<span class="keyword">to</span><span class="constructor">Precision(2)</span>);<span class="comment">//99</span></span><br><span class="line">console.log(num.<span class="keyword">to</span><span class="constructor">Precision(3)</span>);<span class="comment">//99.0</span></span><br></pre></td></tr></table></figure></li><li>isInteger(): 判断一个数值是否是整数，并不是说加了小数点就是整数，例如1.00是整数。他根据小数点之后是否还有位不是0判断是否是整数</li></ul><h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h3><p>js使用了两种unicode编码，都是两个字节表示一个字符。</p><p>两个字节最多表示65536中字符。但是为了表示更多字符，有时候会使用前16位中某些为特殊字符，然后后16位和前16位共同表示一个字符，这时使用charAt就会出现问题。</p><p>例如：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CodePoint(97, 98, 128522, 100, 101)</span>;<span class="comment">//将数字转换成unicode字符,分别是a, b, 笑脸, d, e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//128522的十六进制是0x1f60a</span></span><br><span class="line"></span><br><span class="line">console.log(message.length);<span class="comment">//6(实际上显示时只有五个字符</span></span><br><span class="line">console.log(message.<span class="built_in">char</span><span class="constructor">At(1)</span>);<span class="comment">//b</span></span><br><span class="line">console.log(message.<span class="built_in">char</span><span class="constructor">At(2)</span>);<span class="comment">//&lt;?&gt;</span></span><br><span class="line">console.log(message.<span class="built_in">char</span><span class="constructor">At(3)</span>);<span class="comment">//&lt;?&gt;</span></span><br><span class="line">console.log(message.<span class="built_in">char</span><span class="constructor">At(4)</span>);<span class="comment">//d</span></span><br><span class="line"></span><br><span class="line">console.log(message.<span class="built_in">char</span><span class="constructor">CodeAt(1)</span>);<span class="comment">//98,b的序号</span></span><br><span class="line">console.log(message.<span class="built_in">char</span><span class="constructor">CodeAt(2)</span>);<span class="comment">//55357</span></span><br></pre></td></tr></table></figure><ul><li>length</li><li>charAt(index): 返回下标处的字符</li><li>charCodeAt(index): 返回下标处的字符对应数值，例如0是48。但是它不会考虑扩展字符</li><li>codePointAt(index): 返回下表处的字符对应数值，考虑了扩展字符</li><li>fromCharCode(…): 根据字符对应数值返回字符串，如<code>String.fromChatCode(48, 49)//01</code></li><li>fromCodePoint(…): …</li><li>normalize(): 某些字符可以有多种编码方式，normalize()统一这些编码，共有NFD、NFC、NFKD、NFKC四种规范形式 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">console.log(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CharCode(0x00c5)</span>);<span class="comment">//大写拉丁字母</span></span><br><span class="line">console.log(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CharCode(0x212B)</span>);<span class="comment">//长度单位埃</span></span><br><span class="line">console.log(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CharCode(0x0041, 0x030a)</span>);<span class="comment">//大写拉丁字母上面加个圆圈</span></span><br><span class="line">这三个虽然编码不相同，但是实际上最后返回的是同一个东西，而使用==是比较不出的，这时我们就需要normalize<span class="literal">()</span>规范编码</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CharCode(0x00c5)</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CharCode(0x212b)</span>);</span><br><span class="line"></span><br><span class="line">console.log(a1<span class="operator"> == </span>a2);<span class="comment">//false</span></span><br><span class="line">console.log(a1.normalize(&#x27;NFD&#x27;)<span class="operator"> == </span>a2.normalize(&#x27;NFD&#x27;));<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul><p>下面是字符串操作方法</p><ul><li>concat(): 将若干个字符串拼接到当前字符串后面，concat()可以接受任意数量的字符串，例如 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;hello &#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> result = s.concat(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//hello world</span></span><br></pre></td></tr></table></figure></li><li>slice,substring, substr: 三个都是获得子字符串，第一个参数都是子字符串开始位置，前两个的第二个参数是结尾位置，而substr第二个参数是抽取字符数量。</li><li>indexOf(),lastIndexOf(): 查找子字符串在字符串中的位置，不同的是indexOf从开始查找，而lastIndexOf从结尾开始查找。第一个参数是要查找的字符串，第二个参数时起始位置</li><li>startsWith、endsWith/includes: 检查一个字符串是否包含另一个字符串，startsWith是从第一个字符开始匹配(检查是否是以这个字符串开头)，endsWith是从string.length-substring.length开始匹配。而includes检索整个字符串 <figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">let message = <span class="string">&#x27;foobarbaz&#x27;</span>;</span><br><span class="line">console.<span class="keyword">log</span>(message.<span class="keyword">startsWith</span>(<span class="string">&#x27;foo&#x27;</span>));<span class="comment">//true</span></span><br><span class="line">console.<span class="keyword">log</span>(message.<span class="keyword">startsWith</span>(<span class="string">&#x27;bar&#x27;</span>));<span class="comment">//false,不是以bar开头</span></span><br><span class="line"></span><br><span class="line">console.<span class="keyword">log</span>(message.<span class="keyword">endsWith</span>(<span class="string">&#x27;baz&#x27;</span>));<span class="comment">//true</span></span><br><span class="line">console.<span class="keyword">log</span>(message.includes(<span class="string">&#x27;baz&#x27;</span>));/true</span><br></pre></td></tr></table></figure></li><li>trim(): 删除两边所有的空格</li><li>repeat(times): 把原字符串复制times次</li><li>padStart()、padEnd(): 复制字符串，如果小于指定长度则会填充字符。第一个参数时长度，第二个参数时填充字符</li><li>toLowerCase(),  toUpperCase()</li></ul><p>下面是匹配（正则表达式）：</p><ul><li><p>match(regexp): 作用和RegExp中的exec类似，只是这里的参数变成了模式串，并且这里全局模式直接返回一个数组</p></li><li><p>search(regexp): 返回第一个匹配</p></li><li><p>replace(regexp, replace_str): 如果第一个参数是一个字符串，那么只会替换第一个匹配到的，如果想要匹配所有，必须使用正则表达式并且加上g。<br />其中replace_str有几种特殊的符号可以使用</p><table><thead><tr><th>字符</th><th>替换文本</th></tr></thead><tbody><tr><td><code>$$</code></td><td><code>$</code></td></tr><tr><td><code>$'</code></td><td>替换匹配子字符串之前的字符串</td></tr><tr><td>$`</td><td>匹配子字符串之后的字符串</td></tr><tr><td><code>$n</code></td><td>匹配第n个捕获组，关于捕获组可以看前面.范围是0-9</td></tr><tr><td><code>$nn</code></td><td>匹配第nn个捕获组，如01-99</td></tr></tbody></table><p>例如：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;cat, bat, sat, fat&#x27;</span>;</span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">&#x27;word ($1)&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//word (cat), word (bat), word (sat), word (fat)</span></span><br></pre></td></tr></table></figure></li></ul><p>字符串有迭代器，可以使用for-of访问每个字符，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());<span class="comment">//[value: &#x27;a&#x27;, done: false]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&#x27;abcde&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line">并且我们还可以使用解构操作符把字符串变成数组</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;abcde&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log([...message]);<span class="comment">//[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];</span></span><br></pre></td></tr></table></figure><h2 id="global"><a class="markdownIt-Anchor" href="#global"></a> Global</h2><p>内置对象就是在程序执行前就开始执行的对象，和宿主环境无关，例如Object、Array和String都是内置对象。</p><p>window对象已经实现了Global对象的代理，它有Global的一系列方法。</p><p>方法：</p><ul><li>encodeURI(),encodeURIComponent(): 用于编码URI来传给浏览器。他会对某些不能出现在URI中的字符进行处理，如空格.其中encodeURIComponent()会对冒号、斜杠、问号等字符也进行编码 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&#x27;http://www.wrox.com/illegal value.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"><span class="comment">//http://www.wrox.com/illegal%20value.js&#x27;,把空格变成%20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri));</span><br><span class="line"><span class="comment">//http%3a%2f%2fwww.wrox.com%2fillegal%20value.js&#x27;;</span></span><br></pre></td></tr></table></figure></li><li>eval(): 调用eval时，字符串会被解析为语句并执行，例如<code>eval(&quot;console.log('hi')&quot;);//hi</code></li></ul><h2 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h2><p>math提供了许多数学计算的方法。并且math上提供的计算比普通计算要快很多，因为它的实现更加高效。</p><p><strong>math属性</strong></p><p>math中的属性包含了一些特殊值</p><ul><li>E: 2.71828</li><li>LN10: 以10为底的自然对数</li><li>LN2: 以2为底的自然对数</li><li>LOG2E: 以2为底e的对数</li><li>LOG10E: 以10为底e的对数</li><li>PI</li><li>SQRT1_2: 1/2的平方根</li><li>SQRT2： 2的平方根</li></ul><p>方法：</p><ul><li>min(), max()</li><li>ceil(): 向上舍入</li><li>floor(): 向下舍入</li><li>round(): 四舍五入</li><li>fround(): 返回浮点数表示</li><li>random(): 返回0-1的随机数，其中包含0但不包含1</li><li>等等</li></ul><h1 id="集合引用类型"><a class="markdownIt-Anchor" href="#集合引用类型"></a> 集合引用类型</h1><h2 id="array"><a class="markdownIt-Anchor" href="#array"></a> Array</h2><p>创建数组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);<span class="comment">//创建长度为3的数组</span></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Greg&quot;</span>);<span class="comment">//只包含一个元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]<span class="comment">//使用数组字面量创建数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = [,,,,,];<span class="comment">//创建包含5个元素的数组</span></span><br></pre></td></tr></table></figure><ul><li>from(data, func, this): 从data转换为数组，data可以是集合，map等。func是进行的一些操作。this是func中的this值，但是func不能是箭头函数</li><li>of(): 将一组参数转换成数组</li></ul><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">const</span> a<span class="number">1</span> =<span class="meta"> [1, 2, 3, 4]</span></span><br><span class="line"><span class="attribute">const</span> a<span class="number">2</span> = Array.from(a<span class="number">1</span>, x=&gt;x**<span class="number">2</span>)</span><br><span class="line"><span class="attribute">const</span> a<span class="number">3</span> = Array.from(a<span class="number">1</span>, function(x) &#123;return x**this.exponent&#125;, &#123;exponent: <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="attribute">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>索引</strong></p><p>数组索引和c++最大的不同是它可以动态变化，例如</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="symbol">&#x27;red</span>&#x27;, <span class="symbol">&#x27;blue</span>&#x27;, green&#x27;];</span><br><span class="line">colors[<span class="number">3</span>] = <span class="symbol">&#x27;yellow</span>&#x27;;<span class="comment">//添加一个元素</span></span><br></pre></td></tr></table></figure><p>Array中有一个属性length代表了数组的长度,这个值是可以进行设置的，从而改变数组长度(如果缩减长度会导致原有内容消失)</p><figure class="highlight rsl"><table><tr><td class="code"><pre><span class="line">let colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">colors[<span class="number">99</span>] = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">console.<span class="built_in">log</span>(colors.<span class="built_in">length</span>)<span class="comment">//100</span></span><br><span class="line">colors.<span class="built_in">length</span> = <span class="number">2</span></span><br><span class="line">console.<span class="built_in">log</span>(colors[<span class="number">2</span>])<span class="comment">//undefined</span></span><br><span class="line">colors.<span class="built_in">length</span> = <span class="number">3</span></span><br><span class="line">console.<span class="built_in">log</span>(colors[<span class="number">2</span>])<span class="comment">//undefined，缩减后数据被删除了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以很方便的添加数据</span></span><br><span class="line">colors[<span class="built_in">length</span>] = <span class="string">&#x27;yellow&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><ul><li>keys(),values(), entries(): keys是索引的迭代器，values是值的迭代器，entries()是键值对的迭代器，例如 <figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">const <span class="meta">key</span> = <span class="meta">Array</span>.<span class="meta">from</span>(a.keys())</span><br><span class="line">console<span class="meta">.log(</span><span class="meta">key</span>)//0, 1, 2, 3</span><br><span class="line">const value = <span class="meta">Array</span>.<span class="meta">from</span>(a.values())</span><br><span class="line">console<span class="meta">.log(</span>value)//<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span></span><br><span class="line">const entries = <span class="meta">Array</span>.<span class="meta">from</span>(a.entries())</span><br><span class="line">console<span class="meta">.log(</span>entires)//[0, <span class="string">&#x27;foo&#x27;</span>], [1, <span class="string">&#x27;bar&#x27;</span>], [2, <span class="string">&#x27;baz&#x27;</span>], [3, <span class="string">&#x27;qux&#x27;</span>]</span><br><span class="line"></span><br><span class="line">for(const [idx, element] of a.entires())</span><br><span class="line">&#123;</span><br><span class="line">    console<span class="meta">.log(</span>idx);</span><br><span class="line">    console<span class="meta">.log(</span>element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>fill(sum, begin, end): 从begin到end填充sum</li><li>copyWithin(index, begin, end): 复制数组begin到end的内容并且插入到以index开始的位置中</li><li>toString(): 每个值都会调用toString()方法</li><li>push(): 拖入任意数量的值并且放入末尾</li><li>pop(): 删除最后一项</li><li>shift(): 取得第一项</li><li>unshift()： 从第一个位置插入</li><li>sort(func): 排序，可以按照指定的func进行排序</li><li>reverse(): 反向排序</li><li>concat(): 拼接</li><li>indexOf(), includes(), lastIndexOf(): 搜索某一个元素在数组中的位置，indexOf(), includes()从前往后搜索，lastIndexOf()从后往前.indexOf()和lastIndexOf()没有搜索到返回-1.includes()没有搜索到返回false。他们进行比较时使用====，也就是两项必须严格相等</li><li>every(func): 对每一项都运行函数，如果全部返回为真，则结果为真</li><li>filter(func): 运行函数为true的项会组成数组返回</li><li>foreach(func): 对每一项都运行函数</li><li>map(func): 对每一项都运行函数，返回由函数结果构成的数组</li><li>some(func): 只要有一项返回为true结果就为true <figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="literal">result</span> = number.every((item, index, <span class="built_in">array</span>)=&gt;item &gt; <span class="number">2</span>);//<span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> mapres = number.map((item, index, <span class="built_in">array</span>)=&gt;item * <span class="number">2</span>);</span><br><span class="line">number.forEach((item, index, <span class="built_in">array</span>)=&gt;<span class="meta">&#123;...&#125;</span>);</span><br></pre></td></tr></table></figure></li><li>reduce(func): 对数组中数据进行归约 <figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">values</span> = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"><span class="built_in">let</span> <span class="built_in">sum</span> = <span class="built_in">values</span>.reduce((prev, cur, index, <span class="built_in">array</span>)=&gt; prev + cur);//<span class="number">30</span></span><br><span class="line"></span><br><span class="line">第一次执行时prev=<span class="number">1</span>,cur=<span class="number">4</span>,第二次执行prev=<span class="number">5</span>(前面的归约结果), cur=<span class="number">9</span>（第三项</span><br></pre></td></tr></table></figure></li></ul><h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h2><p>创建：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;val1&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;val2&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;key3&#x27;</span>, <span class="string">&#x27;val3&#x27;</span>]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>map和object类型都可以插入键值对，但是他们还是有很大区别的。Object类型的键只能是数值，字符串或符号，而map可以是任意类型。其次map内部是有序的（插入顺序），而Object是无序的。我们可以使用entries()获得一个个按照插入顺序排列的(key, value)形式的数组</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(let pair of m.entries())</span><br><span class="line">&#123;</span><br><span class="line">    alert(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span>[key1, val1]</span><br><span class="line"><span class="regexp">//</span>[key2, val2]</span><br><span class="line"><span class="regexp">//</span>[key3, val3]</span><br></pre></td></tr></table></figure><p>函数：</p><ul><li>set(): 添加键值对</li><li>get()/has(): 输入键，查询值</li><li>delete()/clear(): 删除 <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> Map();</span><br><span class="line">m.<span class="built_in">get</span>(<span class="string">&quot;firstName&quot;</span>);</span><br><span class="line">m.<span class="built_in">set</span>(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Matt&quot;</span>);</span><br><span class="line"></span><br><span class="line">m.has(<span class="string">&quot;firstName&quot;</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">m.<span class="keyword">delete</span>(<span class="string">&quot;firstName&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>keys()/values(): 返回key或value的迭代器</li></ul><p>键和值在迭代器遍历时是可以修改的，但是在Map内部不会修改。当然，这种修改不会影响使用这个键访问值</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> Map([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(le tkey of m.keys())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">key</span> = <span class="string">&quot;newKey&quot;</span>;</span><br><span class="line">    alert(m.<span class="built_in">get</span>(<span class="string">&quot;key1&quot;</span>)<span class="comment">//val1,说明在map内没有被修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keyObj = &#123;id: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> Map([[keyObj, <span class="string">&quot;val1&quot;</span>]]);</span><br><span class="line"><span class="keyword">for</span>(let <span class="built_in">key</span> of m.keys())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">key</span>.id = <span class="string">&quot;newKey&quot;</span>;</span><br><span class="line">    alert(m.<span class="built_in">get</span>(<span class="built_in">key</span>);<span class="comment">//val1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>WeakMap</strong></p><p>弱映射表示映射的键是弱的，一旦键的引用被清除，这个键值对就会被清除。</p><p>他和普通的Map不同在于普通的map的键是在对象中独立存在的，除非调用delete否则不会被清除，而WeakMap中键直接引用外部变量，外部变量被清除这个键值对也就被清除。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> w = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = &#123; <span class="attr">key</span>: &#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">w.set(container.key, <span class="string">&#x27;val&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove_reference</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    container.key = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于container对象保有对key的引用，所以这个键值对暂时不会被清除，一旦调用remove_reference清除了外部引用之后，这个键值对将自动清除。</p><p>因为引用被删除就会自动回收，所以它可以很方便的给某些数据添加额外属性，省的每次都要delete</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> w = <span class="keyword">new</span> WeakMap();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line">w.<span class="keyword">set</span>(loginButton, &#123;disabled: <span class="keyword">true</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h2><p>set的基本函数和map类似，并且它的插入也是按序的。但是js里面的set和其他的set不同。它并没有提供集合操作方法，需要我们自己实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> union(a, ...bSets)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> unionSet = <span class="keyword">new</span> My_set(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> b <span class="keyword">of</span> bSets)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> bValue <span class="keyword">of</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            unionSet.add(bValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> intersect(a, ...bSets)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> interset = <span class="keyword">new</span> My_set(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> aValue <span class="keyword">of</span> interSet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> b <span class="keyword">of</span> bSets)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!b.has(aValue)</span><br><span class="line">            &#123;</span><br><span class="line">                interset.delete(aValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此外，他也有WeakSet，效果和WeakMap相同</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;基本引用类型&quot;&gt;&lt;a class=&quot;markdownIt-Anch</summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>贝叶斯方法</title>
    <link href="https://xinhecuican.github.io/post/cc8f0814.html"/>
    <id>https://xinhecuican.github.io/post/cc8f0814.html</id>
    <published>2021-05-28T07:20:00.000Z</published>
    <updated>2021-05-28T07:58:46.075Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="贝叶斯定理"><a class="markdownIt-Anchor" href="#贝叶斯定理"></a> 贝叶斯定理</h1><p>定理： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>H</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(H | X) = \frac{P(X | H) * P(H)}{P(X)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="mclose mtight">)</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>其中P(H | X)可以读作x条件下p的概率。</p><p>这个公式的意义在于我们可以使用先验概率来求解后验概率。例如：</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%913.PNG" alt="" /></p><p>上面的例子中，买不买电脑是我们想知道的。而给出一个新的样例，我们不知道他买不买电脑，但是我知道它的年龄，收入等其他信息，现在我需要根据这些信息推断它买不买电脑也就是<code>P( buys - computer = &quot;yes&quot; | age =&quot;&lt;=30&quot;)(小于30的人买电脑概率有多大)</code></p><h1 id="朴素贝叶斯归纳方法"><a class="markdownIt-Anchor" href="#朴素贝叶斯归纳方法"></a> 朴素贝叶斯归纳方法</h1><p>朴素贝叶斯就是各个属性之间相互独立。有一个数据样本集，每个样本是一个n维向量X＝（x1, x2, …xn）有m个类：C1, C2, …Cm；每个样本唯一的归属于一个类。</p><p>如果现在来了一个未知类别的数据X，想要求得它的分类，也就是P(H | X) H <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> {C1, C2, …, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">C_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>}，可以写为P(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> | X)$</p><p>依照贝叶斯定理，可得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mi mathvariant="normal">＝</mi><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(C_j |X) ＝ P(X|C_j) P(C_j )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord cjk_fallback">＝</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，由于P(X)是定值，所以P(X)可以省略。P(x | <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>)和P(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>)都可以求得，现在就可以求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(C_j | X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>的概率了。</p><p>其中P(x |<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>) = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\prod_{i=1}^n p(x_i | C_i )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p><p>计算过程：</p><ol><li>计算 P(C1), P(C2)等</li><li>计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x_1 | C_1 ), P(x_2 | C_2 )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> …</li><li>计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X | C_1 ), P(X | C_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> …</li><li>计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(C_1 | X), P(C_2 | X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> …</li></ol><p>以上面为例</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">希望分类的未知样本为</span><br><span class="line">X=( age =“≤<span class="number">30</span>”, income =“medium”, student = “ yes”, credit - rating = “fai<span class="string">r&quot;)</span></span><br><span class="line"><span class="string">要求计算出</span></span><br><span class="line"><span class="string">P(buys - computer =“yes”| X)</span></span><br><span class="line"><span class="string">和P(buys - computer = &quot;</span>no”| X)</span><br></pre></td></tr></table></figure><p>计算过程如下</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.</span><br><span class="line">P( buys - <span class="attr">computer</span> =“ yes”)=<span class="number">9</span>/<span class="number">14</span> =<span class="number">0.643</span>;</span><br><span class="line">P(buys - <span class="attr">computer</span> =<span class="string">&quot;no”)=5/14=0.357。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. </span></span><br><span class="line"><span class="string">P(age =“&lt; = 30”| buys - computer = &quot;</span>yes<span class="string">&quot;)=2/9= 0.222;</span></span><br><span class="line"><span class="string">P( age =“&lt; =30&quot;</span>| buys - <span class="attr">computer</span> =<span class="string">&quot;no&quot;</span>)=<span class="number">3</span>/<span class="number">5</span>= <span class="number">0.600</span>;</span><br><span class="line">P(<span class="attr">income=&quot;medium&quot;</span> | <span class="attr">buys-computer</span> =<span class="string">&quot;yes&quot;</span>)=<span class="number">4</span>/<span class="number">9</span>= <span class="number">0.444</span>;</span><br><span class="line">P( <span class="attr">income</span> =<span class="string">&quot;medium&quot;</span> | buys - <span class="attr">computer</span> =<span class="string">&quot;no&quot;</span>) =<span class="number">2</span>/<span class="number">5</span>= <span class="number">0.400</span>;</span><br><span class="line">P( <span class="attr">student</span> =<span class="string">&quot;yes&quot;</span> | buys - <span class="attr">computer</span> =<span class="string">&quot;yes&quot;</span>) =<span class="number">6</span>/<span class="number">9</span>= <span class="number">0.667</span>;</span><br><span class="line">P( <span class="attr">student</span> = <span class="string">&quot;yes&quot;</span> | buys - <span class="attr">computer</span> =<span class="string">&quot;no&quot;</span>)=<span class="number">1</span>/<span class="number">5</span>= <span class="number">0.200</span>;</span><br><span class="line">P(credit - <span class="attr">rating</span> =<span class="string">&quot;fair&quot;</span> | buys - <span class="attr">computer</span> =<span class="string">&quot;yes&quot;</span>)=<span class="number">6</span>/<span class="number">9</span>= <span class="number">0.667</span>;</span><br><span class="line">P(credit - <span class="attr">rating</span> =<span class="string">&quot;fair&quot;</span> | buys - <span class="attr">computer</span> =<span class="string">&quot;no&quot;</span>)=<span class="number">2</span>/<span class="number">5</span>=<span class="number">0.400</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. </span><br><span class="line">P( X | buys - <span class="attr">computer</span> =<span class="string">&quot;yes&quot;</span> ) =</span><br><span class="line"><span class="number">0.222</span> ×  <span class="number">0.444</span> × <span class="number">0.667</span> × <span class="number">0.667</span> = <span class="number">0.044</span>;</span><br><span class="line">P(X | buys - <span class="attr">computer</span> = <span class="string">&quot;no&quot;</span>) =</span><br><span class="line"><span class="number">0.600</span> × <span class="number">0.400</span> × <span class="number">0.200</span> × <span class="number">0.1400</span> = <span class="number">0.019</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. </span><br><span class="line">P( buys - <span class="attr">computer</span> = <span class="string">&quot; yes &quot;</span> | X) =</span><br><span class="line">    P(X | buys - <span class="attr">computer</span> = <span class="string">&quot; yes &quot;</span> ) x </span><br><span class="line">    P( buys <span class="attr">-computer</span> = <span class="string">&quot; yes &quot;</span> ) = <span class="number">0.044</span> × <span class="number">0.643</span> = <span class="number">0.028</span>;</span><br><span class="line">P( buys - <span class="attr">Computer</span> = <span class="string">&quot; no &quot;</span> | X) = </span><br><span class="line">    P(X | buys - <span class="attr">computer</span> = <span class="string">&quot; no &quot;</span> ) × </span><br><span class="line">    P ( buys <span class="attr">-computer</span> = <span class="string">&quot; no &quot;</span> ) =<span class="number">0.019</span> ×<span class="number">0.357</span> =<span class="number">0.007</span>。</span><br><span class="line">所以最终预测会买</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;贝叶斯定理&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>js函数</title>
    <link href="https://xinhecuican.github.io/post/39e6b899.html"/>
    <id>https://xinhecuican.github.io/post/39e6b899.html</id>
    <published>2021-05-27T00:21:00.000Z</published>
    <updated>2021-07-05T11:45:41.832Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1><p>在js中，函数其实是对象。每个函数都是Function类型的实例，Function也有自己的属性和方法。因为函数是对象，所以函数名其实就是指向对象的指针，甚至和这个对象没有强制绑定。</p><p>定义函数的一些方式：</p><p>直接定义</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">sum</span>(num1, num2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">num1</span> + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名定义,定义一个函数，然后把函数指针给sum变量</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">let <span class="built_in">sum</span> = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过箭头，可以称作箭头函数。这是一种语法糖，实际上和上面那个作用是一样的</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let</span> sum (num<span class="number">1</span>, num<span class="number">2</span>) =&gt; &#123; return num<span class="number">1</span> + num<span class="number">2</span>;&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数可以用在任何使用函数表达式的地方（不需要函数名的地方），但是箭头函数和普通函数还是有一些微妙的差别的，例如不能使用arguments等。</p><p>最后一种方法时使用Function构造函数，这个函数接收任意多个参数，最后一个参数会被当成函数体，例如<code>let sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);</code>.但是这种方法不推荐使用，因为他会被解释两次：第一次是解析new，第二次是解析函数。</p><p>函数和var类似，都会自动把声明提升到顶部，因此下列代码是可以的</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">console<span class="number">.</span><span class="built_in">log</span>(<span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">sum</span>(num1, num2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数名和参数"><a class="markdownIt-Anchor" href="#函数名和参数"></a> 函数名和参数</h2><p>因为函数名是指向函数的指针，所以他们和其他对象指针相同，这样就意味着函数可以有多个名称。</p><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(num1, num2)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consol.<span class="built_in">log</span>(<span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">10</span>));<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">let anothersum = <span class="built_in">sum</span>;</span><br><span class="line">console.<span class="built_in">log</span>(anothersum(<span class="number">10</span>, <span class="number">10</span>));/<span class="number">20</span></span><br></pre></td></tr></table></figure><p>所有函数对象都只会暴露一个只读的name属性，包含函数的信息。多数情况下就是包含一个函数标识符，也就是函数名。如果它是使用构造函数创建的，则会被标识成‘anonymous’</p><p>如果函数是get、set或者使用bind()实例化，那么标识符前面会加上一个前缀</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bind(<span class="literal">null</span>).name);<span class="comment">//bound foo</span></span><br><span class="line"><span class="keyword">let</span> dog =</span><br><span class="line">&#123;</span><br><span class="line">    years: <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">age</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.years;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">age</span>(<span class="params">newAge</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.years = newAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(dog, <span class="string">&#x27;age&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.get.name);<span class="comment">//get age</span></span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptro.set.name);<span class="comment">//set age</span></span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><p>ECMAScript函数的参数和大多数语言不同，它不关心传入参数的个数。定义函数时要接受两个参数，但是实际上可以传一个、两个、三个或者一个不传，都不会报错。</p><p>函数的参数在内部表现为一个数组，，函数调用时总会接收这个参数数组，但是数组中有什么其实并不关心。并且在使用function定义非箭头函数时，可以在函数内部访问arguments对象，从中获得传进来的每个参数值。</p><p>arguments对象类似于数组，可以通过arguments[0]获得第一个参数，arguments[1]获得第二个参数。可以使用arguments.length获得数组的长度</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">sayHi(<span class="string">&#x27;你&#x27;</span>, <span class="string">&#x27;好&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这和c语言中main函数的参数类似，length相当于argc，而这个数组相当于argv</p><p>我们可以修改arguments参数的值甚至添加元素，但是arguments是根据传入时参数的个数决定的，不会再改变</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fucntion add(num1, num2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//11</span></span><br></pre></td></tr></table></figure><p>但是在严格模式下即使把arguments的值改变了参数的值也不会改变</p><p><strong>箭头函数中的参数</strong></p><p>箭头函数中的参数不能使用arguments进行访问，只能使用参数名进行访问</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>);<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);&#125;;</span><br><span class="line">bar(<span class="number">5</span>);<span class="comment">//ReferenceError</span></span><br></pre></td></tr></table></figure><blockquote><p>js的函数没有重载，因为参数都是不确定的。在这种情况下，后命名的函数会覆盖前面一个函数</p></blockquote><h2 id="默认参数与扩展参数"><a class="markdownIt-Anchor" href="#默认参数与扩展参数"></a> 默认参数与扩展参数</h2><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;henry&#x27;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(makeKing();<span class="comment">//King henry VIII</span></span><br></pre></td></tr></table></figure><p>传undefined相当于没有传值，但是通过传undefined可以部分填充</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="literal">undefined</span>, <span class="string">&#x27;VI&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在使用默认参数时，arguments不会反映默认参数，他只会保存外来参数。</p><p>默认参数还可以直接传一个函数,并且在函数调用时相应的参数函数才会求值，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = [<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> ordinality = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumerals</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num[ordinality++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = getNumerals()</span>)//使用函数</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认参数的定义也是有先后顺序的，后面定义的可以引用前面定义的。例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = name</span>)//引用<span class="title">name</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">它类似于</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name, numerals</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> numerals = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展参数</strong></p><p>扩展参数也就是不定长参数，它在不同环境下有不同的用法。</p><ul><li><p>传入参数</p><p>当参数是一个数组时，实际上它的长度是知道的，因此它的作用是将数组中的元素进行拆分，每个元素都是输入的一个参数，可以使用arguments进行访问。</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以使用</span><br><span class="line"><span class="built_in">console</span>.log(getSum(...values));<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>, ...values)); <span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>, ...values, <span class="number">2</span>));<span class="comment">//13</span></span><br></pre></td></tr></table></figure></li><li><p>输入不定长参数<br />例如</p> <figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span><span class="params">(<span class="rest_arg">...values</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> values.reduce((x, y) =&gt; x+y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.log(getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));<span class="comment">//6</span></span><br></pre></td></tr></table></figure><p>通过这种方法得来的values是一个数组，可以通过数组访问其中的每个输入参数，这种方法可以用于箭头函数（箭头函数中不能用arguments），并且在arguments中每个参数还是独立的，上面<code>arguments.length</code>输出为3</p><p>不定长参数只能放在最后</p> <figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span><span class="params">(<span class="rest_arg">...values</span>, lastValue)</span></span>&#123;&#125;<span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span><span class="params">(firstValue, <span class="rest_arg">...values</span>)</span></span>&#123;&#125;<span class="comment">//可以</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="函数的参数与属性"><a class="markdownIt-Anchor" href="#函数的参数与属性"></a> 函数的参数与属性</h1><h2 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h2><p><strong>arguments</strong></p><p>前面已经使用过很多次arguments属性了，它代表传进来的参数。除了这个作用外，arguments其实还包含一个callee属性，是一个指向所在函数的指针。</p><p><strong>this</strong></p><p>在标准函数中，this引用的是调用函数的上下文对象，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = </span><br><span class="line">&#123;</span><br><span class="line">    color: <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor();<span class="comment">//red,这时它的上下文对象时window</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();<span class="comment">//blue</span></span><br></pre></td></tr></table></figure><p>而在箭头函数中，this引用的是定义时的上下文</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = </span><br><span class="line">&#123;</span><br><span class="line">    color: <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayColor = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line"></span><br><span class="line">sayColor();<span class="comment">//red</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();<span class="comment">//red,因为是在window中定义的</span></span><br></pre></td></tr></table></figure><blockquote><p>函数名只是保存指针的变量，实际上函数都在代码区，只不过执行的上下文不同</p></blockquote><p><strong>caller</strong></p><p>caller引用调用该函数的函数，例如</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">outer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">inner</span>()</span><br><span class="line">&#123;</span><br><span class="line">    console.log(<span class="keyword">inner</span>.caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">outer</span>();</span><br></pre></td></tr></table></figure><p>结果返回outer的代码，因为inner.caller是outer</p><p><strong>new.target</strong></p><p>new.target是为了检测这个函数是作为创建新对象而new的还是作为普通函数，如果是作为普通函数，那么new.target值是undefined，如果是new，那么将引用被调用的函数</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">new</span><span class="type"></span>.target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> `King must be instantiated <span class="keyword">using</span> <span class="string">&quot;new&quot;</span>`</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(`King instantiated <span class="keyword">using</span> <span class="string">&quot;new&quot;</span>`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">King</span>();<span class="comment">//King instantiated using &quot;new&quot;</span></span><br><span class="line">King();<span class="comment">//Error: King must be instantiated using &quot;new&quot;</span></span><br></pre></td></tr></table></figure><h2 id="属性和方法"><a class="markdownIt-Anchor" href="#属性和方法"></a> 属性和方法</h2><p>每个函数都有两个属性：length和prototype，其中length是函数定义的参数个数</p><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span><span class="params">(name)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(num1, num2)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(sayName.<span class="built_in">length</span>);<span class="comment">//1</span></span><br><span class="line">console.<span class="built_in">log</span>(sum.<span class="built_in">length</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>函数有两个方法：apply()和call()。</p><ul><li>apply(this, arguments): 第一个参数是函数调用时的上下文对象，也就是this所指向的值，第二个参数可以是Array，也可以是arguments对象 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callsum</span>(<span class="params">num1, num2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);<span class="comment">//传入arguments对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callsum(<span class="number">10</span>, <span class="number">10</span>));<span class="comment">//20</span></span><br></pre></td></tr></table></figure></li><li>call(this, arguments): 作用和apply相同，不同的是call中的参数必须一个个列出来，而不能传数组</li></ul><p>apply和call主要是用来切换this对象用的，例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = </span><br><span class="line">&#123;</span><br><span class="line">    color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor();</span><br><span class="line"></span><br><span class="line">sayColor.call(<span class="built_in">this</span>);<span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);<span class="comment">//red</span></span><br><span class="line">sayColor.call(o);<span class="comment">//blue</span></span><br></pre></td></tr></table></figure><ul><li>bind(this): 创建一个新的函数实例，并且将实例内部的this与传入的this对象进行绑定。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o =</span><br><span class="line">&#123;</span><br><span class="line">    color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor();<span class="comment">//blue</span></span><br></pre></td></tr></table></figure><h1 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h1><p>递归就是自己调用自己，一般由递归表达式和终止条件。js写递归时有它自己的特色</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);<span class="comment">//这样不会受函数名干扰</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">但是在严格模式下，不可以使用callee，可以替换成如下形式</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>递归的一大缺点就是内存占用高，而js新增一项内存管理机制（尾调用优化）可以在条件满足的时候重用栈帧</p><p>例如：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">outer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">inner()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来它的调用过程是这样的</p><ol><li>执行outer，第一个栈帧生成</li><li>发现返回inner，计算inner，并且第二个栈帧生成</li><li>计算完inner，第二个栈帧退出，然后返回给outer，第一个栈帧退出</li></ol><p>现在是：</p><ol><li>执行outer，第一个栈帧生成</li><li>发现inner，但是此时发现outer返回值和inner返回值相同，弹出outer栈帧</li><li>计算inner并返回</li></ol><p><strong>尾调用优化的条件：</strong></p><ol><li>在严格模式下执行</li><li>外部函数的返回值是对尾调用函数的调用(必须是在return中调用）</li><li>尾调用函数返回后不用执行额外的逻辑（如返回值加减等）</li><li>尾调用函数没有引用外部函数中变量</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> foo;&#125;</span><br><span class="line">    <span class="keyword">return</span> inner();<span class="comment">//闭包，没有优化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inner().toString();<span class="comment">//执行了额外的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">a, b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> inner(a + b);<span class="comment">//有优化，前面一个return可以提前得知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h1><p>闭包是一个函数引用了另一个函数中的变量，这通常是在嵌套函数中实现的。例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComp</span>(<span class="params">propertyName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> value1 = object1[propertyName];<span class="comment">//引用了外部变量</span></span><br><span class="line">        <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="keyword">if</span>(value1 &lt; value2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vlaue1 &gt; value2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面已经说过<a href="https://xinhecuican.github.io/post/fcee082f.html#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域链</a><br />。在函数执行时，每个函数都有一个包含其变量的对象。在全局上下文中叫变量对象，在局部上下文叫活动对象，它会随着函数的销毁而销毁。</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value1 &lt; value2)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>这个例子中在定义compare函数时，会为他创建作用域链，并且预装载全局变量对象，保存在[[Scope]]中。在调用这个函数时，会复制[[Scope]]来创建作用域，并且将自己的活动对象放在作用域链的前端。</p><p>而在createComp中，里面的匿名函数引用了createComp中的变量，因此当他返回之后createComp并不会销毁，只有在匿名函数引用清除之后才会被销毁</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span><span class="built_in"> compare</span> = createComp(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> result =<span class="built_in"> compare</span>(<span class="built_in">&#123;name</span>: <span class="string">&#x27;a&#x27;</span>&#125;, <span class="built_in">&#123;name</span>: <span class="string">&#x27;b&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">compare = null//清除引用，现在createComp才会被销毁</span><br></pre></td></tr></table></figure><p><strong>闭包中的this对象</strong></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">object</span> = </span><br><span class="line">&#123;</span><br><span class="line">    identity: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">    getIdentityFunc()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.identity;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">object</span>.getIdentityFunc()());<span class="comment">//The Window</span></span><br></pre></td></tr></table></figure><p>结果返回按常理说应该是object，但是却是window。考虑对象的生成过程，其中有一步就是把this变量赋给函数，但是没有赋给函数的函数，也就是说闭包内部的this是原始window。如果我们想要让他的this是对象，可以</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object = </span><br><span class="line">&#123;</span><br><span class="line">    identity: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">    getIdentityFunc()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.identity;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="私有变量"><a class="markdownIt-Anchor" href="#私有变量"></a> 私有变量</h1><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName());<span class="comment">//a</span></span><br></pre></td></tr></table></figure><p>上面的name实际上是一个私有变量，因为它的作用域是在函数内部的，可以通过参数名或arguments在函数中访问，但是函数外部无法访问，只有通过get和set才可以访问。</p><p><strong>静态私有变量</strong></p><p>上面那种是每个实例都有的私有变量，有时候需要所有实例共享私有变量，也就是静态私有变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)//<span class="title">Person</span>前面没有修饰符，所以自动将定义域归结到全局上下文</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName());<span class="comment">//a</span></span><br></pre></td></tr></table></figure><p>通过这种方式可以让所有person实例修改一个name属性，由于Person是闭包，所以这个匿名函数调用之后并不会销毁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>js对象</title>
    <link href="https://xinhecuican.github.io/post/d6f3a755.html"/>
    <id>https://xinhecuican.github.io/post/d6f3a755.html</id>
    <published>2021-05-23T02:54:00.000Z</published>
    <updated>2021-05-26T11:04:12.299Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基础操作"><a class="markdownIt-Anchor" href="#基础操作"></a> 基础操作</h1><p>创建自定义对象的方式通常是创建一个Object的新实例，然后添加属性和方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br><span class="line">person.job = <span class="string">&#x27;engineer&#x27;</span>;</span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是早期创建对象的方式。如果使用对象字面量可以这样写</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = </span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">    age: <span class="number">29</span>;</span><br><span class="line">    job: <span class="string">&#x27;engineer&#x27;</span>;</span><br><span class="line">    sayName()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性类型"><a class="markdownIt-Anchor" href="#属性类型"></a> 属性类型</h2><p>属性有些是对象中的成员变量，还有些类似于c#中的属性(property).这些属性都有一些内置的attribute（特性），我们可以修改这些特性。为了标识某一个内部特性，一般使用两个中括号括起来，例如<code>[[Enumberable]]</code></p><p>使用<code>Object.defineProperty()</code>可以更改属性的特性</p><p><strong>数据属性</strong></p><p>数据属性就是平常的变量，它包含一个保存数据值的位置，只会从这个位置读取，也会写入到这个位置，它的特性为</p><ul><li><code>[[Configurable]]</code>: 是否可以通过delete删除并重新定义，是否可以修改特性，是否可以把它改为可访问，它是下面配置的基础。默认是true</li><li><code>[[Enumerable]]</code>: 是否可以通过for-in返回，默认情况下是true</li><li><code>[[Writable]]</code>: 属性是否可以被修改，如果设置为false可以给这个变量赋值但是赋值无效。默认情况下是true</li><li><code>[[Value]]</code>: 包含属性实际的值</li></ul><p>修改特性可以同时设置一个或多个值</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">let person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person, <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">&#123;</span><br><span class="line">    writeable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">&#x27;Nicholas&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(person.<span class="built_in">name</span>); <span class="comment">//Nicholas</span></span><br><span class="line">person.<span class="built_in">name</span> = <span class="string">&#x27;Greg&#x27;</span>;</span><br><span class="line">console.<span class="built_in">log</span>(person.<span class="built_in">name</span>);<span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure><p>一个属性被设置为不可配置之后，就不可以设置为可配置了。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">let person = &#123;&#125;;</span><br><span class="line">Object.<span class="function"><span class="keyword">def</span><span class="title">ineProperty</span><span class="params">(person, <span class="string">&#x27;name&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="symbol">configurable:</span> <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="symbol">value:</span> <span class="string">&#x27;Nicholas&#x27;</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">Object.<span class="function"><span class="keyword">def</span><span class="title">ineProperty</span><span class="params">(person, <span class="string">&#x27;name&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="symbol">configurable:</span> <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;<span class="regexp">//</span>报错</span><br></pre></td></tr></table></figure><p><strong>访问器属性</strong></p><p>访问器有一个getter和一个setter函数，但是和c#中的属性不完全一样，c#中属性可以默认内部有一个值，但是访问器只可以对其他的值进行操作</p><ul><li><code>[[configurable]]</code>: 和上面一样</li><li><code>[[Enumerable]]</code>:</li><li><code>[[Get]]</code>: 默认是undefined</li><li><code>[[Set]]</code>: 默认是undefined</li></ul><p>访问器属性不能直接定义，必须使用Object.defineProperty()</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">let book = </span><br><span class="line">&#123;</span><br><span class="line">    year_: <span class="type">2017</span>, <span class="comment">//认为是私有属性</span></span><br><span class="line">    edition: <span class="type">1</span></span><br><span class="line"><span class="type"></span>&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(book, <span class="string">&#x27;year&#x27;</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span>(<span class="keyword">new</span><span class="type">Value</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span><span class="type">Value</span> &gt; <span class="number">2017</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.year_ = <span class="keyword">new</span><span class="type">Value</span>;</span><br><span class="line">            <span class="built_in">this</span>.edition += <span class="keyword">new</span><span class="type">Value</span> - <span class="number">2017</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2018</span>;</span><br></pre></td></tr></table></figure><p><strong>读取属性特性</strong></p><p>使用<code>Object.getOwnPropertyDescriptor(object_name, property_name)</code>获取属性的属性描述符,例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&#x27;year_&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value);<span class="comment">//2017</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(descriptor.get));<span class="comment">// undefined</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此外还有<code>Object.getOwnPropertyDescriptors()</code>方法，他会返回每一个对象的特性</p><p><strong>合并对象</strong></p><ul><li>Object.assign(): 将一个目标对象和多个源对象进行合并。将每个源对象的可枚举(Object.propertyIsEnumerable())和自有(Object.hasOwnProperty())属性复制到目标对象.对于每个符合条件的属性，会使用源对象上的[[get]]获得属性，然后使用目标对象的[[set]]设置属性</li></ul><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">dest</span> = &#123;&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">result</span> = Object.assign(dest, &#123;a: <span class="string">&#x27;foo&#x27;</span>&#125;, &#123;b: <span class="string">&#x27;bar&#x27;</span>&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>assign()是浅复制，也就是说只会复制对象的引用，他们指向内存中的位置是相同的。并且如果出错无法回滚。</p><h2 id="增强语法"><a class="markdownIt-Anchor" href="#增强语法"></a> 增强语法</h2><ol><li>属性值简写<br />在给对象添加变量时，经常发现属性名和变量名是一样的<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">letname = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">let person = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">name</span>: <span class="type">name</span>;</span><br><span class="line">&#125;</span><br><span class="line">console.log(person);</span><br></pre></td></tr></table></figure>为了简单，有一种简写为<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span><span class="built_in"> name</span> = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = </span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in"> name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可计算属性<br />可计算属性是用动态赋予变量名，例如<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> uniqueToken = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueKey</span>(<span class="params">key</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_<span class="subst">$&#123;uniqueToken++&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person =</span><br><span class="line">&#123;</span><br><span class="line">    [getUniqueKey(nameKey)] = <span class="string">&#x27;Matt&#x27;</span>;<span class="comment">//变量名是会变的。如name_0,name_1</span></span><br><span class="line">    [getUniqueKey(ageKey)] = <span class="number">27</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>简写方法名<br />在给对象定义方法时，通常要写方法名加冒号再加方法，现在可以直接使用方法名<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来</span></span><br><span class="line"><span class="keyword">let</span> person =</span><br><span class="line">&#123;</span><br><span class="line">    say_name: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//现在</span></span><br><span class="line"><span class="keyword">let</span> person = </span><br><span class="line">&#123;</span><br><span class="line">    say_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>简写还可以用于get和set，并且方法名可以用可计算属性代替<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = </span><br><span class="line">&#123;</span><br><span class="line">    name_: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对象解构<br />原来想要赋值必须一个个赋值，现在可以使用一条语句进行赋值<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来赋值</span></span><br><span class="line"><span class="keyword">let</span> personName = person.name;</span><br><span class="line"><span class="keyword">let</span> personAge = person.age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在</span></span><br><span class="line"><span class="keyword">let</span> &#123;name: personName, age: personAge&#125; = person;</span><br></pre></td></tr></table></figure></li></ol><h1 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h1><p><strong>工厂模式</strong></p><p>例如:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.ageg = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = createPerson(<span class="string">&#x27;a&#x27;</span>, <span class="number">29</span>, <span class="string">&#x27;doctor&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>构造函数模式</strong></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;a&#x27;</span>, <span class="number">29</span>, <span class="string">&#x27;doctor&#x27;</span>);</span><br></pre></td></tr></table></figure><p>构造函数不需要显示的创建对象，并且没有return。它使用new新建对象并且构造函数最好首字母大写。</p><p>它的创建过程为：</p><ol><li>在内存中创建一个新对象</li><li>将新对象内部的[[Prototype]]特性赋值为构造函数的prototype属性</li><li>构造函数内部的this被赋值为当前对象</li><li>执行构造函数内部代码（给对象添加属性）</li><li>如果构造函数返回非空对象，则返回该对象，否则返回新创建的对象</li></ol><p>但是这种创建方式有一些问题。例如上例中的sayName，在js中函数实际上是一个对象，因此每定一个一个函数相当于创建了一个对象，这会带来空间的浪费，因此可以这样</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">    <span class="built_in">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原型模式</strong></p><p>每个函数都会创建一个prototype属性，这个属性是一个对象，这个对象就是通过调用构造函数创建的对象的原型。在原型对象上定义的变量或属性可以被所有对象实例共享。原来直接赋给对象实例的值，可以赋给他们的原型</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.name = <span class="character">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.age = <span class="number">29</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.job = &#x27;engineer&#x27;;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.sayName = <span class="keyword">function</span><span class="literal">()</span>&#123;console.log(this.name);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="constructor">Person()</span>;</span><br><span class="line">person.say<span class="constructor">Name()</span>;</span><br></pre></td></tr></table></figure><p>我们可以把所有方法添加到原型上，这样就不会出现上面的创建一个对象就创建一个函数的情况了。</p><h1 id="原型"><a class="markdownIt-Anchor" href="#原型"></a> 原型</h1><p>只要创建一个函数，就会为这个函数创建一个prototype属性（指向原型）。所有原型会默认获得一个<code>constructor</code>属性，指向关联的构造函数。</p><p>原型对象默认只会有constructor属性，其他属性都继承于Object， Object的原型是null。每次创建新实例时，内部的[[Prototype]]特性就会指向原型，一般可以通过<code>__proto__</code>访问这个原型。如果没有这个属性还可以使用getPrototypeOf()获得prototype。</p><p><img src="/images/js%E5%AF%B9%E8%B1%A11.jpg" alt="" /></p><h2 id="原型层级"><a class="markdownIt-Anchor" href="#原型层级"></a> 原型层级</h2><p>通过对象访问属性时，会按照属性的名称开始搜索。首先搜索对象实例本身，如果本身没有则会搜索原型，再搜索原型的原型，知道搜索到null。</p><p>虽然可以通过实例读取到原型对象上的值，但是不能修改这些值。如果在实例上创建了和原名对象中同名的属性，则会覆盖原型对象上的属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//b，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);<span class="comment">//a,来自原型</span></span><br></pre></td></tr></table></figure><p>如果想要恢复对原型属性的访问，则必须使用delete删除这个属性</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">delete person1.<span class="built_in">name</span>;</span><br><span class="line">console.<span class="built_in">log</span>(person1.<span class="built_in">name</span>);<span class="comment">//a</span></span><br></pre></td></tr></table></figure><h3 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制"></a> 访问控制</h3><p>我们可以使用hasOwnProperty()判断某个属性是实例上的还是原型上的，而in操作符只要可以访问就会返回true</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;name&quot;</span> in person2);<span class="comment">//true</span></span><br><span class="line">console.<span class="built_in">log</span>(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>如果使用for-in循环，那么可以通过对象访问且可枚举的属性都会返回，包括实例和原型属性。如果想要获得对象上所有可枚举的实例属性，可以使用Object.keys()方法，这个方法只会返回该对象而不会返回原型的</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.name = <span class="character">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.age = <span class="number">29</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.job = &#x27;engineer&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>keys(<span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype);<span class="comment">//[&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="constructor">Person()</span>;</span><br><span class="line">keys = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>keys(person);<span class="comment">//[&#x27;&#x27;]</span></span><br><span class="line"></span><br><span class="line">person.name = <span class="character">&#x27;b&#x27;</span>;</span><br><span class="line">person.age = <span class="number">23</span>;</span><br><span class="line">keys = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>keys(person);<span class="comment">//[&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(value <span class="keyword">in</span> person)</span><br><span class="line">&#123;</span><br><span class="line">    console.log(value);<span class="comment">//name, age, job</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要获得所有实例属性，无论是否可以枚举，则可以使用Object.getOwnPropertyNames()</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">let keys = <span class="keyword">Object</span>.getOwnPropertyNames(person.prototype);</span><br><span class="line">console.log(keys)<span class="comment">//[&#x27;constructor&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;]</span></span><br><span class="line">多了一个<span class="function"><span class="keyword">constructor</span>，是不可枚举属性</span></span><br></pre></td></tr></table></figure><p>除了getOwnPropertyNames()外，还有getOwnPropertySymbols()获得所有的symbol</p><p>for-in循环和keys的枚举顺序是不确定的。而getOwnProperty的顺序是先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。</p><p><strong>对象迭代</strong></p><p>可以使用Object.values()或Object.entries()获得对象的属性值，例如</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">const o = </span><br><span class="line">&#123;</span><br><span class="line">    foo: <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">    baz: <span class="number">1</span>,</span><br><span class="line">    qux: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">Object</span>.<span class="keyword">values</span>(o));//[<span class="string">&#x27;bar&#x27;</span>, <span class="number">1</span>, &#123;&#125;]</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">Object</span>.entries((o)));//[[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],[<span class="string">&#x27;baz&#x27;</span>, <span class="number">1</span>], [<span class="string">&#x27;qux&#x27;</span>, &#123;&#125;]]</span><br></pre></td></tr></table></figure><p>符号属性会被忽略</p><p>此外，我们还可以使用对象字面量对原型进行赋值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = </span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">&#x27;engineer&#x27;</span>,</span><br><span class="line">    sayName()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样有一个问题，在创建Person时原型就已经确定了，这时原型指向的是Person。而此时原型又被重新创建，虽然Person.prototype指向没有问题，但是Person.prototype.constructor不指向Person，而是指向Object.我们可以通过在定义时指向Person来解决这个问题</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype = &#123;</span><br><span class="line">    constructor: Person,<span class="comment">//定义constructor</span></span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>但是此时constructor变成了可枚举的了，如果想要把它变成不可枚举类型，可以使用defineProperty()</p><p>即使这样还可能出现问题</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line"> Person.prototype =</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">     ...</span><br><span class="line">     <span class="title">sayNmae</span>(<span class="params"></span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">friend.sayName()<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>报错的原因是虽然修改为新的原型，但是friend的prototype还指向老的原型。因此就没有sayName函数。</p><h1 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h1><h2 id="原型链"><a class="markdownIt-Anchor" href="#原型链"></a> 原型链</h2><p>js的继承是基于原型链的。例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();<span class="comment">//继承</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面的代码关键是<code>SubType.prototype = new SuperType()</code>，通过创建一个父类的实例给子类的原型从而实现原型链的继承。现在子类的原型的原型就是<code>SuperType.protoType</code>.</p><p><img src="/images/js%E5%AF%B9%E8%B1%A12.jpg" alt="" /></p><p><strong>原型和实例的关系</strong></p><p>有两种方式确定原型和实例的关系，一种是使用instanceof操作符，如果一个实例的原型链中出现过相应的构造函数。则instanceof返回true</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);//<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType);//<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType);//<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>第二种方法时使用<code>isPrototypeOf()</code>方法，这是给原型用的，只要原型链中包含这个原型就会返回true</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">console.log(<span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>prototype.is<span class="constructor">PrototypeOf(<span class="params">instance</span>)</span>;<span class="comment">//true</span></span><br><span class="line">console.log(<span class="module-access"><span class="module"><span class="identifier">SuperType</span>.</span></span>prototype.is<span class="constructor">PrototypeOf(<span class="params">instance</span>)</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>但是原型链也有它的问题，例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = &#123;<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//red, blue, green, black</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//red, blue, green, black</span></span><br></pre></td></tr></table></figure><p>它的问题就是所有子类的父类都是同一个，如果修改父类的属性那么对于所有子类都是有效的。也就是让本来不是原型属性的属性变成了原型属性。</p><p>另一个问题是，子类在实例化时不能给父类构造函数传参</p><h2 id="盗用构造函数"><a class="markdownIt-Anchor" href="#盗用构造函数"></a> 盗用构造函数</h2><p>为了解决原型链模式的一些问题，提出了一种盗用构造函数的方式。例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);<span class="comment">//盗用构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(isntance1.colors);<span class="comment">//red, blue, green, black</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//red, blue, green</span></span><br></pre></td></tr></table></figure><p>通过call()或apply()方法，这样相当于SuperType的构造函数在SubType中执行了，这样每个sub对象都有父类的实例属性。</p><p>call()方法是使用指定对象调用某个函数，第一个参数就是指定的对象，这里是this也就是SubType。也就是说SuperType中this.color变成了SubType.color，SubType上创建了color变量。</p><p>我们可以使用原型链和盗用构造方法结合的方式来进行继承</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.age);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&#x27;a&#x27;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line">cnosole.log(instance1.colors);<span class="comment">//red, blue, green, black</span></span><br></pre></td></tr></table></figure><p>通过这两种方式的结合，我们在继承父类的方法和属性的同时也保存了隔离性</p><h2 id="寄生式组合继承"><a class="markdownIt-Anchor" href="#寄生式组合继承"></a> 寄生式组合继承</h2><p><strong>原型式继承</strong></p><p>例如:</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objec</span><span class="params">(o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是最开始说的原型链，这里用一个函数封装一下，并且这种模式还可以使用Object.create()代替,它的第一个参数是用来做原型的对象，另外一个参数时给新对象定义额外属性的对象，例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person =</span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    friends: &#123;<span class="string">&#x27;shelby&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person);<span class="comment">//继承自person</span></span><br><span class="line"><span class="keyword">let</span> thirdperson = <span class="built_in">Object</span>.create(person, &#123;<span class="attr">name</span>:&#123;<span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span>&#125;&#125;);</span><br></pre></td></tr></table></figure><p><strong>寄生式组合继承</strong></p><p>组合继承也存在效率问题，它的父类构造函数始终会调用两次，一次是创建子类原型时（prototype = new SuperType())，另一次是子类构造函数中（call调用）。</p><p>使用寄生式组合继承可以解决上面的问题</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">function</span> inheritProto<span class="keyword">type</span>(subType, superType)//使用这个代替原来的原型对象创建</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> proto<span class="keyword">type</span> = object(superType.protoType);//创建父类原型的副本</span><br><span class="line">    proto<span class="keyword">type</span>.constructor = subType;</span><br><span class="line">    subType.proto<span class="keyword">type</span> = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);<span class="comment">//用来替换SubType.prototype = new SuperType();</span></span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1><p><strong>定义</strong></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">mybaz</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">myQux</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的类其实是将上面的继承封装起来的一种语法糖，本质上还是上面的一套东西。类中可以包含构造方法、实例方法、get和set函数和静态方法。</p><p><strong>构造函数</strong></p><p>可以使用new对对象进行实例化，实例化会进行如下操作：</p><ol><li>在内存中创建一个新的对象</li><li>将新对象内部的[[Prototype]]指针赋值为构造函数的prototype属性</li><li>构造函数内部的this指向该对象</li><li>执行构造函数内部代码</li><li>如果构造函数返回非空对象，则返回该对象。否则返回新创建的对象</li></ol><p>如果构造函数没有定义，则默认会定义一个构造函数</p><p>类构造函数和普通构造函数的区别是，类构造函数必须要使用new，不使用会报错。而普通构造函数如果不使用new那么会将window作为this。</p><p>类中定义的constructor不会被当成构造函数，在对他使用instanceof操作符会返回false</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="title">constructor</span>(<span class="params">name, age</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;a&#x27;</span>, <span class="number">29</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person.constructor);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person.constructor(<span class="string">&#x27;b&#x27;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person.constructor);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上例也就说明了类的原型指向这个类而不是指向构造函数</p><h2 id="实例-原型和类成员"><a class="markdownIt-Anchor" href="#实例-原型和类成员"></a> 实例、原型和类成员</h2><p>所有构造函数中的属性和方法都不是共享的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sayName = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p1.name === p2.name);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>在类块中定义的其他方法实际上都是定义于原型上的，都是共享的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    locate()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;prototype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.locate();<span class="comment">//prototype</span></span><br></pre></td></tr></table></figure><p>类方法等同于对象属性，因此可以使用可计算值作为键</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(<span class="string">&quot;symbolKey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    stringKey()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;invoked stringKey&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [symbolKey]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;invoked symbolKey&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.stringKey();</span><br><span class="line">p[symbolKey]();</span><br></pre></td></tr></table></figure><p><strong>在类外部添加成员数据</strong></p><p>可以在类的外部手动添加属性，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    sayName()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.greeting = <span class="string">&#x27;My name is &#x27;</span>;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">p.sayName(); <span class="comment">// My name is Jake</span></span><br></pre></td></tr></table></figure><h2 id="继承-2"><a class="markdownIt-Anchor" href="#继承-2"></a> 继承</h2><p>可以使用<strong>extends</strong>关键字，继承任何拥有[[Construct]]和原型的对象。这也就意味着它不仅可以继承类还可以继承构造函数。并且他会继承父类中所有属性和构造方法</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">let b = <span class="keyword">new</span> <span class="type">Bus</span>();</span><br><span class="line">console.log(b instanceof <span class="type">Bus</span>);<span class="comment">//true</span></span><br><span class="line">console.log(b instanceof <span class="type">Vehicle</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>可以使用super访问父类，可以使用super()调用父类的构造函数，但是使用时需要注意以下问题</p><ul><li>super只能在派生类构造函数和静态方法中使用</li><li>不能单独调用super，要么是用他的构造函数，要么使用它的构造方法</li><li>如果没有定义类构造函数，那么实例化子类时会调用super()</li><li>在构造函数中，不能再调用super()之前使用this</li><li>如果派生类中显示定义了构造函数，那么必须在其中调用super(),或者返回一个对象<br />例如： <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> constructor()</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">type</span> = () =&gt;&#123;console.log(<span class="keyword">this</span>);&#125;;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="symbol">&#x27;Vehicl</span>e&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> constructor()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = <span class="keyword">new</span> <span class="type">Bus</span>();</span><br><span class="line">b.<span class="keyword">type</span>();</span><br><span class="line">console.log(b.name);</span><br><span class="line"><span class="comment">//报错</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="抽象基类"><a class="markdownIt-Anchor" href="#抽象基类"></a> 抽象基类</h3><p>虽然在js中并没有提供抽象类的关键字，但是我们可以手动实现</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehilce</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    constructor()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span>.target === <span class="type">Vehicle</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">&quot;can&#x27;t do this&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.foo)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">&quot;inheriting class must define foo()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    foo()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过在构造函数中使用new关键字进行检测new的目标是否是抽象类来组织抽象类的实现。我们同样可以检测是否有某个函数定义来限制必须定义某个函数（接口）</p><p><strong>类混入(继承多个类)</strong></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">let <span class="type">FooMixin</span> = (<span class="type">Superclass</span>) =&gt; <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span></span>&#123; foo()&#123;console.log(<span class="symbol">&#x27;fo</span>o&#x27;);&#125;&#125;;</span><br><span class="line"></span><br><span class="line">let <span class="type">BarMixin</span> = (<span class="type">Superclass</span>) =&gt; <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span></span>&#123; bar()&#123;console.log(<span class="string">&quot;bar&quot;</span>);&#125;&#125;;</span><br><span class="line"></span><br><span class="line">let <span class="type">BazMixin</span> = (<span class="type">Superclass</span>) =&gt; <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span></span>&#123; baz()&#123;console.log(<span class="string">&quot;baz&quot;</span>);&#125;&#125;;</span><br><span class="line"></span><br><span class="line">function mix(<span class="type">BaseClass</span>, ...<span class="type">Mixins</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Mixins</span>.reduce((accumulator, current) =&gt; current(accumulator), <span class="type">BaseClass</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Mix</span>(<span class="params"><span class="type">Vehicle</span>, <span class="type">FooMixin</span>, <span class="type">BarMixin</span>, <span class="type">BaxMixin</span></span>)</span>&#123;&#125;</span><br><span class="line">let b = <span class="keyword">new</span> <span class="type">Bus</span>();</span><br><span class="line">b.foo();</span><br><span class="line">b.bar();</span><br><span class="line">b.baz();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;基础操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor</summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>js变量、作用域、内存</title>
    <link href="https://xinhecuican.github.io/post/fcee082f.html"/>
    <id>https://xinhecuican.github.io/post/fcee082f.html</id>
    <published>2021-05-22T12:20:00.000Z</published>
    <updated>2021-05-23T02:53:29.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="原始值和引用值"><a class="markdownIt-Anchor" href="#原始值和引用值"></a> 原始值和引用值</h1><p>原始值就是最简单的数据类型，而引用值就是对象。</p><p>原始值不能有属性，尽管给原始值添加属性不会报错</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">let <span class="built_in">name</span> = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line"><span class="built_in">name</span>.age = <span class="number">27</span>;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">name</span>.age);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>原始值赋给另一个值时，会在内存中复制一份，因此两份互不干扰</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let</span> num<span class="number">1</span> = <span class="number">5</span>;</span><br><span class="line"><span class="attribute">let</span> num<span class="number">2</span> = num<span class="number">1</span>;</span><br><span class="line"><span class="attribute">num1</span> = <span class="number">3</span>;</span><br><span class="line"><span class="attribute">console</span>.log(num<span class="number">2</span>);//<span class="number">5</span></span><br></pre></td></tr></table></figure><p>把引用值从一个变量赋给另一个变量时，实际上是复制了指向这个对象的指针(对象本身在堆中)，因此一个变量对对象进行修改另一个也会修改。</p><p>js函数只存在值传递，也就是说参数是原变量复制一份传进去的，也就是说如果传递的是对象我们在函数中修改了对象的属性在函数外也是成立的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.name = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//b</span></span><br><span class="line">---</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.name = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">//如果是引用传递，那么函数外的obj的值也会随之更改，他将指向新的Object对象</span></span><br><span class="line">    obj.name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//b</span></span><br></pre></td></tr></table></figure><p>我们可以使用instanceof来判断具体的引用类型。使用方法为<code>variable instanceof constructor</code></p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);//person是<span class="built_in">Object</span>类型吗</span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>);//colors是<span class="built_in">Array</span>类型吗</span><br></pre></td></tr></table></figure><h1 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h1><p>变量或函数的上下文决定了他们可以访问那些数据。每个上下文都有一个关联的<strong>变量对象</strong>，而这个上下文的所有变量和函数都存在于这个对象上，虽然无法直接访问对象，但是后台处理时会用到它。</p><p>全局上下文是最外层的上下文。在浏览器中，全局上下文是window对象，因此所有通过var定义的全局变量和函数都会成为window对象的属性和方法。let和const声明的全局变量不会挂在window对象中，因为他们声明的全局变量是无效的。</p><p>每个函数都有自己的上下文，他们在一个上下文栈中。上下文在所有代码被执行完后会销毁</p><p>例如：</p><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> anotherColor = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = <span class="built_in">color</span>;</span><br><span class="line">        <span class="built_in">color</span> = tempColor;</span><br><span class="line">    &#125;</span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p><img src="/images/js%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%86%85%E5%AD%981.jpg" alt="" /></p><p>上下文代码执行时，有一个变量的作用域链，如图所示。里层可以访问外层，而外层不能访问里层。</p><p>with和catch都会变更上下文，catch会创建一个新的上下文。而with会添加到作用域链的尾部</p><h2 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明</h2><p><strong>var</strong></p><p>使用var时，会自动添加到最接近的上下文。在函数中，最接近的上下文是函数局部上下文。</p><blockquote><p>如果变量未经声明直接赋值，那么会被自动添加到全局上下文</p></blockquote><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1, num2)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sum</span> = num1 + num2;<span class="comment">//直接赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">//30</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">sum</span>);<span class="comment">//30，因为它是全局上下文，所以在外部可以访问到</span></span><br></pre></td></tr></table></figure><p><strong>let</strong>和<strong>const</strong>作用域都是块级的，也就是说是由最近的一队<code>&#123;&#125;</code>决定的。</p><h1 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h1><p>js和java一样，都是使用垃圾回收机制。垃圾回收是自动回收的。基本思路是每隔一定时间会自动执行看那些变量不再使用。</p><p><strong>标记清理</strong></p><p>js最常用的垃圾回收策略是标记清理。只有在上下文中的变量才有可能被清理，不再上下文中的变量因为其他的上下文还可能使用因此永运不应该释放他们的内存。</p><p>给变量加标记的方法有多种，例如当变量进入上下文时，反转某一位，或者维护在上下文或不在上下文的列表。</p><p>垃圾回收程序运行时，会标记内存中存储的所有变量，之后会将所有在上下文以及被上下文引用的变量的标记去掉，在此之后再被标记就是待删除的了。</p><p>现在大多数浏览器都是使用这种方法。这种方式的好处是在上下文结束后会释放相关变量</p><p><strong>引用计数</strong></p><p>引用计数的思路是每个值都记录被引用的次数。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="class"><span class="keyword">object</span> </span>= <span class="keyword">new</span> <span class="type">Object</span>();<span class="comment">//引用一次</span></span><br><span class="line"><span class="keyword">var</span> objectb = <span class="class"><span class="keyword">object</span></span>;<span class="comment">//引用两次</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> </span>= <span class="literal">null</span>;<span class="comment">//引用一次</span></span><br></pre></td></tr></table></figure><p>但是有时候会导致内存泄露，例如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> objecta = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">let</span> objectb = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    </span><br><span class="line">    objecta.otherobject = objectb;</span><br><span class="line">    objectb.otherobject = objecta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在objecta和objectb都有两个引用并且是相互引用，也就是说他们永运都不会释放。</p><h2 id="内存泄露及应对"><a class="markdownIt-Anchor" href="#内存泄露及应对"></a> 内存泄露及应对</h2><p>下面是一些内存泄露的情况</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;Jake&#x27;</span>;<span class="comment">//没类型，是全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);<span class="comment">//定时器会一直运行</span></span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">只要outer变量存在，那么name就不会被清除。</span><br></pre></td></tr></table></figure><p><strong>静态分配和对象池</strong></p><p>浏览器决定何时运行回收程序的一个标准就是对象更替的速度，如果有很多对象初始化，然后又一下子超出作用域，那么就会更频繁的调用垃圾回收程序。</p><p>例如：</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">function addVector(a, b)</span><br><span class="line">&#123;</span><br><span class="line">    let resultant = new Vector();</span><br><span class="line">    resultant.<span class="symbol">x</span> = a.<span class="symbol">x</span> + b.<span class="symbol">x</span>;</span><br><span class="line">    resultant.<span class="symbol">y</span> = a.<span class="symbol">y</span> + b.<span class="symbol">y</span>;</span><br><span class="line">    <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是两个向量相加，其中的临时变量resultant会很快创建又被清除，造成了浪费。</p><p>解决这个问题的方法是不要创建临时变量，而始终用一个变量</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">function addVector(a, b, resultant)</span><br><span class="line">&#123;</span><br><span class="line">    resultant.<span class="symbol">x</span> = a.<span class="symbol">x</span> + b.<span class="symbol">x</span>;</span><br><span class="line">    resultant.<span class="symbol">y</span> = a.<span class="symbol">y</span> + b.<span class="symbol">y</span>;</span><br><span class="line">    <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是从外部传入的变量那么在函数结束之后就不会被清除。但是这样的话resultant需要自己控制释放，不然可能多个结果引用同一个对象</p><p>我们可以使用对象池来管理一组对象，需要时可以使用它，不需要时释放控制权，但是只是提交给对象池，并不代表这个对象被销毁。</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let</span> v<span class="number">1</span> = vectorPool.allocate();</span><br><span class="line"><span class="attribute">let</span> v<span class="number">2</span> = vectorPool.allocate();</span><br><span class="line"><span class="attribute">let</span> v<span class="number">3</span> = vectorPool.allocate();</span><br><span class="line"></span><br><span class="line"><span class="attribute">v1</span>.x = <span class="number">10</span>;</span><br><span class="line"><span class="attribute">v1</span>.y = <span class="number">5</span>;</span><br><span class="line"><span class="attribute">v2</span>.x = -<span class="number">3</span>;</span><br><span class="line"><span class="attribute">v2</span>.y = -<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">addVector</span>(v<span class="number">1</span>, v<span class="number">2</span>, v<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="attribute">console</span>.log(v<span class="number">3</span>.x, v<span class="number">3</span>.y);//<span class="number">7</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">vectorPool</span>.free(v<span class="number">1</span>);</span><br><span class="line"><span class="attribute">vectorPool</span>.free(v<span class="number">2</span>);</span><br><span class="line"><span class="attribute">vectorPool</span>.free(v<span class="number">3</span>);</span><br></pre></td></tr></table></figure><pre class="highlight"><code class=""></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;原始值和引用值&quot;&gt;&lt;a class=&quot;markdownIt-Anc</summary>
      
    
    
    
    <category term="js" scheme="https://xinhecuican.github.io/categories/js/"/>
    
    
  </entry>
  
</feed>
