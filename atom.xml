<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-03-02T10:48:43.882Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c语言的动态内存分配</title>
    <link href="http://xinhecuican.github.io/2020/03/02/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://xinhecuican.github.io/2020/03/02/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</id>
    <published>2020-03-02T08:39:00.000Z</published>
    <updated>2020-03-02T10:48:43.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>头文件： malloc.h</p><p>原型 void* malloc( size)（不标准写法）</p><p>其中size表示的是你想申请的字节数，为了准确我们一般使用sizeof函数，而返回的是一个void指针，这就导致了我们一般都要强制类型转换到对应的类型。</p><p>例： int* p=(int*)malloc(sizeof(int))</p><p>   int* p=(int<em>)malloc(10</em>sizeof(int)) //数组</p><p>   前面的int* 就是强制类型转换</p><p>此外，malloc一般分配完内存后还要进行检查看是否分配成功</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p==NULL)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);<span class="regexp">//</span>退出程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且malloc是不会自动初始化的，所以在分配完内存后最好先用NULL初始化一下。</p><h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><p>字面意思，就是给一个已经分配内存的指针增加内存,原内存中的数据不变</p><p>头文件 #include &lt;stdlib.h&gt; 有些编译器需要#include &lt;alloc.h&gt;</p><p>原型： void* realloc(void *mem_address, unsigned int newsize);</p><p>mem_address是原指针，newsize是原有空间加上新增的空间</p><p>可能有下列几种情况</p><ol><li>如果原有空间后面还有足够的内存空间，那么直接在后面增加内存空间</li><li>如果原有空间不足，会重新分配空间到其他地方，同时原地址中的数据也会复制过去</li><li>如果没有可供分配的空间，返回NULL。此时，原指针仍然有效</li></ol><p>注意，如果分配成功，无论是否分到新空间，原指针都会被释放掉</p><p>如果 mem_address为0 那么和malloc相似，也是分配一块内存空间</p><p>如果 newsize为0，相当于free</p><p>也就是说，最好不要出现 p=realloc(p,size)这种写法，防止分配失败后指针直接丢失。好的办法是先用另一个参数接受realloc的内容，如果不为null，再让p=q</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* q;</span><br><span class="line">q=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(p,newsize);</span><br><span class="line"><span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>释放动态申请的内存空间</p><p>原型： void free(void* ptr)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;malloc&quot;&gt;&lt;a href=&quot;#malloc&quot; class=&quot;headerlink&quot; title=&quot;malloc&quot;&gt;&lt;/a&gt;malloc&lt;/h3&gt;&lt;p&gt;头文件： malloc.h&lt;/p&gt;
&lt;p&gt;原型 void* malloc( size)（不标准写法）&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>程序的进入与退出</title>
    <link href="http://xinhecuican.github.io/2020/03/02/%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%9B%E5%85%A5%E4%B8%8E%E9%80%80%E5%87%BA/"/>
    <id>http://xinhecuican.github.io/2020/03/02/%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%9B%E5%85%A5%E4%B8%8E%E9%80%80%E5%87%BA/</id>
    <published>2020-03-02T06:18:00.000Z</published>
    <updated>2020-03-02T08:38:55.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="程序进入"><a href="#程序进入" class="headerlink" title="程序进入"></a>程序进入</h3><p>在c++中，程序的入口是main函数，并且main函数有两个参数</p><p>int main(int argc,char* argv[])</p><p>argc是用来记录输入的参数的数量，而argv是用来记录输入的参数。</p><p>例如： ls -la，这个输入中有两个参数，第一个参数是ls，第二个参数是-la</p><h3 id="程序退出"><a href="#程序退出" class="headerlink" title="程序退出"></a>程序退出</h3><p>return 是退出当前函数，例如退出主函数或者退出任意函数</p><p>而 exit 是退出当前进程，也就是说就算是在调用的函数中，这个程序也会直接结束</p><p>exit(0)表示正常退出，exit(1)表示异常退出，更深入的内容涉及到进程。</p><p>exit函数在stdlib.h头文件中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;程序进入&quot;&gt;&lt;a href=&quot;#程序进入&quot; class=&quot;headerlink&quot; title=&quot;程序进入&quot;&gt;&lt;/a&gt;程序进入&lt;/h3&gt;&lt;p&gt;在c++中，程序的入口是main函数，并且main函数有两个参数&lt;/p&gt;
&lt;p&gt;int main(int argc,char
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="c++" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/c/"/>
    
    
  </entry>
  
  <entry>
    <title>过滤器</title>
    <link href="http://xinhecuican.github.io/2020/03/01/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://xinhecuican.github.io/2020/03/01/%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-03-01T02:53:00.000Z</published>
    <updated>2020-03-01T08:27:07.781Z</updated>
    
    <content type="html"><![CDATA[<p>管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中），但是在最前面的和在最后面的不一定是过滤器。</p><h3 id="cat-复制"><a href="#cat-复制" class="headerlink" title="cat 复制"></a>cat 复制</h3><p>cat的用途就是把标准输入中的数据复制到标准输出中</p><p>应用：可以与重定向结合。cat &gt; data，这样从键盘中输入的数据将直接传到data文件中</p><p>此外还可以让文件内容显示在控制台上，有 cat &lt; data，标准输入变成了data文件，标准输出是屏幕。为了方便，直接cat 文件名也是可以的</p><p>此外，tail也有类似的功能，但是它只能显示最后的十行</p><p>另外一个应用就是把一个文件复制到另一个文件。例如，cat &lt; data &gt; newdata</p><h4 id="增强cat功能"><a href="#增强cat功能" class="headerlink" title="增强cat功能"></a>增强cat功能</h4><p>cat &lt; file…= cat file …</p><p>有三个点说明了可以同时输入多个文件，这样就为组合多个文件提供了途径</p><p>cat data1 data2 data3 &gt;file</p><p>后缀： </p><pre><code>-n 在每行后面加一个行号-b 与-n一起使用，不要对空白行加行号-s 将多个连续的空白行变成一个空白行</code></pre><h3 id="split-分为不同文件"><a href="#split-分为不同文件" class="headerlink" title="split 分为不同文件"></a>split 分为不同文件</h3><p>语法 split [-d] [-a num] [-l lines] [file [prefix]]</p><p>作用： 将一个大文件分解成几个小文件。默认情况下，split将创建1000行长的空间</p><p>参数： </p><pre><code>-l 创建一个5000行的空间-d 将文件名改为从00开始编号-a 后面加数字，例如3表示从000开始，总共1000个文件名</code></pre><p>默认情况下，split创建的文件将以x开头，后面加aa，ab等</p><h3 id="tac-反转复制"><a href="#tac-反转复制" class="headerlink" title="tac 反转复制"></a>tac 反转复制</h3><p>相关过滤器： cat，rev</p><p>作用：和cat类似，但是在写入文件时把文件内容反转（tac是将cat反过来）。注意，这里的反过来并不是指从后往前倒着写，而是把行与行将顺序反过来。</p><h3 id="rev-反转字符顺序"><a href="#rev-反转字符顺序" class="headerlink" title="rev 反转字符顺序"></a>rev 反转字符顺序</h3><p>相关过滤器： cat tac</p><p>作用： 将各行字符顺序反转</p><p>语法： rev [file…]</p><p>例如： 有一个文件data，里面有</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345</span></span><br><span class="line">abcde</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure><p>之后用rev后会变成</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54321</span></span><br><span class="line">edcba</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure><p>rev也是直接输出到标准输出上的，也就是说并不会对源文件造成改变，如果想输出到文件中，还要重定向一下</p><h3 id="head，tail-从数据开头或者结尾读取"><a href="#head，tail-从数据开头或者结尾读取" class="headerlink" title="head，tail 从数据开头或者结尾读取"></a>head，tail 从数据开头或者结尾读取</h3><p>语法： head/tail [-n lines]，lines是希望选择的数据行</p><p>默认情况下，head和tail都只会选择十行数据，用-n可以选择任意行数</p><p>例： calculate | tail -n 15</p><h3 id="colrm-删除数据列"><a href="#colrm-删除数据列" class="headerlink" title="colrm 删除数据列"></a>colrm 删除数据列</h3><p>相关过滤器： cut paste</p><p>colrm（“column remove”)程序从标准输入中读取数据，删除指定数据列（也就是竖的删除），将剩余数据写入标准输出</p><p>语法： colrm [startcol [endcol]]，编号从1开始</p><p>例： colrm 14 30 &lt;students | less</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中），但是在最前面的和在最后面的不一定是过滤器。&lt;/p&gt;
&lt;h3 id=&quot;cat-复制&quot;&gt;&lt;a href=&quot;#cat-复制&quot; class=&quot;headerlink&quot; title=&quot;cat 复制&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>加法溢出和乘法溢出</title>
    <link href="http://xinhecuican.github.io/2020/02/29/%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA/"/>
    <id>http://xinhecuican.github.io/2020/02/29/%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA/</id>
    <published>2020-02-29T03:07:00.000Z</published>
    <updated>2020-02-29T03:46:23.753Z</updated>
    
    <content type="html"><![CDATA[<p>无符号数加法便是两个数相加，如果超过最大值那么就截断超过的位数。截断超过的位数也就相当于mod2^n,因为这样做超过的位都会被模去变成0.</p><p>有符号数加法相对复杂。先是变成无符号数加法，加完 之后再按有符号数编码去理解，这样就会产生两种溢出，正溢出和负溢出。</p><p>首先，如果两个数一正一负，则不可能产生进位。</p><p>正溢出很好理解，最高一位为符号位，假如两个正数一加，超过了最大值，那么第2^w-1位就会变成1，这一位是符号位，因此这个数字便会变成负数。</p><p>如果是负溢出，因为两个数最高位一定为1，如果2^w-2位没有发生进位的话，那么就产生了溢出，此时最高位为0，变成正数</p><p>例如：10111111+10111111（-65）=01111110（126）</p><p>所以说如果是正数溢出，则需要-2^m,如果是负溢出，则需要加上2^m</p><p>判定是否发生溢出 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=a+b;</span><br><span class="line"><span class="keyword">if</span>((a&gt;<span class="number">0</span>==b&gt;<span class="number">0</span>)&amp;&amp;(a&lt;<span class="number">0</span>!=s&lt;<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"发生溢出"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"没有发生溢出"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a&gt;0==b&gt;0的意义是判断a和b的符号是否相同,相同为真.a&lt;0!=s&lt;0的含义是判断a和s的符号是否<br>乘法溢出相对简单粗暴，直接把高位全部截断，也就是对2^w取模，有符号数乘法是先不管符号位直接把后面的位相乘，然后再把符号位补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无符号数加法便是两个数相加，如果超过最大值那么就截断超过的位数。截断超过的位数也就相当于mod2^n,因为这样做超过的位都会被模去变成0.&lt;/p&gt;
&lt;p&gt;有符号数加法相对复杂。先是变成无符号数加法，加完 之后再按有符号数编码去理解，这样就会产生两种溢出，正溢出和负溢出。&lt;/
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>重定向与管道</title>
    <link href="http://xinhecuican.github.io/2020/02/29/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93/"/>
    <id>http://xinhecuican.github.io/2020/02/29/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93/</id>
    <published>2020-02-29T00:05:00.000Z</published>
    <updated>2020-02-29T02:50:22.437Z</updated>
    
    <content type="html"><![CDATA[<h3 id="标准输入-标准输出和标准错误"><a href="#标准输入-标准输出和标准错误" class="headerlink" title="标准输入 标准输出和标准错误"></a>标准输入 标准输出和标准错误</h3><p>基本思想：每个基于文本的程序都可以从任何源接受输入，并向任何目标输出</p><p>标准输入指的是一种读取数据的通用办法，标准输出有两种，一种是标准输出，另一种是标准错误</p><p>而输入输出其实正常情况下有shell决定。为了保证程序的输出，需要告诉shell将输出目标设置成文件。</p><h3 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h3><p>在登陆时，shell会自动将标准输入设置成键盘，将标准输出和标准错误设置成屏幕。</p><p>但是每次输入命令时，可以告诉shell在此命令执行期间更换输入输出对象。</p><p>如果想把一个命令输出送到一个文件中，例如sort命令 可以写成 sort &gt; names</p><p>以这种命令输出时，如果文件不存在，shell会自动创建这个文件。如果文件存在，那他将会把文件内容全部清空然后再把内容输入到里面去</p><p>如果我们只想追加内容到这个文件中，可以用 &gt;&gt; 。如果文件不存在，这个命令也会创建新文件，如果存在，那么会追加内容到后面。</p><p>如果取消清空文件重新输入的选项，可以设置nonclobber选项。但是设置完之后，如果确实想替换掉这个文件，可以临时忽略掉noclobber，这时需要用<code>&gt;|</code>替换 &gt;</p><h4 id="重定向标准输入"><a href="#重定向标准输入" class="headerlink" title="重定向标准输入"></a>重定向标准输入</h4><p>符号： &lt;</p><p>左边是你要运行的程序，右边是你有读入数据的文件</p><p>例如 sort &lt; /etc/passwd</p><p>标准输入和标准输出可以同时指定</p><p>例如 sort &lt; rawdata &gt; report，这个命令会把rawdata中的数据给sort处理，然后把结果给report文件</p><h4 id="重定向标准错误"><a href="#重定向标准错误" class="headerlink" title="重定向标准错误"></a>重定向标准错误</h4><p>shell提供两种输出目标，标准输出和标准错误。正常情况下，两种输出同时显示在屏幕上，在需要时，可以把两种输出分隔开。</p><p>首先对unix处理I/O过程了解。每个输入源和每个输出目标都有一个唯一的数字标识，，这个数字 称为文件描述符。例如一个进程可能从#8中读取数据，并将文件写入#6中</p><p>例如为了将输出写入到文件8中，可以sort 8&gt; results，results就是第8个文件</p><p>默认情况下，Unix为每个进程提供三个预定义的文件描述符。而且大多数时候都可以使用。0代表标准输入，1代表标准输出，3代表标准错误。</p><p>所以要想重定向输入，可以用 0&lt;</p><p>而要想重定向标准输出，可以用 1&gt; ,这样错误信息就会留在屏幕上便于我们查看，而输出信息在文件中。如果想让标准错误在文件中，可以 2&gt;</p><p>此外，平常写的 &gt; 实际上代表的是 1&gt;</p><h4 id="子shell"><a href="#子shell" class="headerlink" title="子shell"></a>子shell</h4><p>进程就是加载到内存中准备运行的程序，当进程需要启动另一个进程的时候，这个进程创建了一个副本进程，原始跌进程叫做父进程，而这个进程叫做子进程。</p><p>而子进程一旦结束，优惠唤醒父进程继续执行命令，此时子进程消失。</p><p>子shell指的是在父shell中重新开一个shell，这样在子shell中造成的改变不会影响父shell，甚至是环境变量也一样，除非把它写入初始化文件中，不然这个全局变量也会随着子shell进程的结束而消亡。</p><p>如果有时你想在子shell中执行一条指令，又不想启动一个全新的shell，那么一个办法就是在外面加上小括号(),例如 （date）</p><h4 id="组合标准重定向输出和错误"><a href="#组合标准重定向输出和错误" class="headerlink" title="组合标准重定向输出和错误"></a>组合标准重定向输出和错误</h4><p>在bash中，基本思想是建议将一种类型的输出重定向到一个文件，然后再追加</p><p>command x&gt; outputfile y&gt;&amp;x</p><blockquote><p>&amp; 符号的意思是替代</p></blockquote><p>y&gt;&amp; x的意思是把2的输出发送给1相同的位置。</p><p>例： sort 2&gt;&amp;1 &gt;output 这个意思是把2的输出发送到与一相同的位置，而一是发送到屏幕的，于是2也发送到屏幕了</p><h4 id="抛弃输出"><a href="#抛弃输出" class="headerlink" title="抛弃输出"></a>抛弃输出</h4><p>为什么要抛弃输出呢？</p><p>有时候，需要运行一个程序。因为可能你并不关心这个文件的输出。有时候，可能希望查看文件正常输出，而不关心错误信息。</p><p>那么这个时候只需要重定向输出到 /etc/null即可。这个文件的特殊之处在于发送给他的任何东西都会消失。所以 它有个奇怪的名字叫做 位桶(bit bucket)</p><h3 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h3><p>管道线的作用就是让各个程序组合发挥作用</p><p>shell允许创建一系列的命令，在这一系列的命令中，一个命令的标准输出可以发送给下一个程序的标准输入。当这样做时，两个程序之间的连接就是管道，而命令序列本身叫做管道线。</p><p>在创建管道线时，只需将希望键入的命令用竖线| （管道符号） 分隔开即可</p><p>能从标准输入读取文本，并向标准输出写入文本的程序，称为过滤器。</p><h4 id="管道线分流-tee"><a href="#管道线分流-tee" class="headerlink" title="管道线分流 tee"></a>管道线分流 tee</h4><p>有时候，可能希望把程序的输出发送到两个地方</p><p>语法： tee [-a] file…</p><p>file就是希望将数据发送到的文件的名称</p><p>例：cat name1 name2 | tee masterlist | grep Harley</p><p>这个指令中的tee 会将输出保存到masterlist中并且将cat的输出给grep</p><p>同样，如果这个文件存在，那么tee将会重写这个文件。如果想要追加内容，那么可以tee -a(append)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;标准输入-标准输出和标准错误&quot;&gt;&lt;a href=&quot;#标准输入-标准输出和标准错误&quot; class=&quot;headerlink&quot; title=&quot;标准输入 标准输出和标准错误&quot;&gt;&lt;/a&gt;标准输入 标准输出和标准错误&lt;/h3&gt;&lt;p&gt;基本思想：每个基于文本的程序都可以从任何源接
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>初始化文件</title>
    <link href="http://xinhecuican.github.io/2020/02/27/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6/"/>
    <id>http://xinhecuican.github.io/2020/02/27/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6/</id>
    <published>2020-02-27T13:04:00.000Z</published>
    <updated>2020-02-29T00:04:50.119Z</updated>
    
    <content type="html"><![CDATA[<p>有两个初始化文件，第一个文件是在启动时执行的，叫做登录文件（login file).第二个文件是在启动shell时执行的，叫做环境文件(environment file)。<br>有的shell还有注销文件，注销文件指的是在shell关闭时执行的文件</p><p>bash shell中登录文件文件名（.Bash_profile .bash_login)，环境文件（.bashrc),注销文件（.bash_logout)</p><p>这些文件名都是以点开头，点文件的别名是隐藏文件，意义是除非你用ls指令去查看，通常状况你无法看到这个文件</p><p>登录shell指的是登录时默认启动的shell，非登录shel则需要在登录shell中执行命令才可以启动</p><p>登录shell执行登录文件和环境文件，非登录shell只执行环境文件</p><h4 id="初始化文件中放什么内容"><a href="#初始化文件中放什么内容" class="headerlink" title="初始化文件中放什么内容"></a>初始化文件中放什么内容</h4><p>登录文件有两项任务，设置环境和初始化工作对话（不知道什么意思）</p><p>所以登录文件有两项任务</p><ol><li>创建或修改环境变量的命令（PATH,PAGER等）</li><li>执行所有一次性操作的命令</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有两个初始化文件，第一个文件是在启动时执行的，叫做登录文件（login file).第二个文件是在启动shell时执行的，叫做环境文件(environment file)。&lt;br&gt;有的shell还有注销文件，注销文件指的是在shell关闭时执行的文件&lt;/p&gt;
&lt;p&gt;bash
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>宏定义</title>
    <link href="http://xinhecuican.github.io/2020/02/27/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <id>http://xinhecuican.github.io/2020/02/27/%E5%AE%8F%E5%AE%9A%E4%B9%89/</id>
    <published>2020-02-27T01:53:00.000Z</published>
    <updated>2020-02-27T02:02:14.262Z</updated>
    
    <content type="html"><![CDATA[<p>宏定义就是在开始用井号（#）定义一个函数或者是常量，这种定义在编译器中被处理，运算速度快，但使用宏定义时可能会出现一些隐蔽的问题</p><p>例如：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="keyword">DATA</span> sizeof(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">for(<span class="built_in">int</span> i=cnt;i-<span class="keyword">DATA</span>&gt;=<span class="number">0</span>;i-=<span class="keyword">DATA</span>)</span><br></pre></td></tr></table></figure><p>乍一看这样做似乎没什么问题，要注意sizeof返回的是一个无符号数，有符号数和无符号数做比较的时候会先把有符号数变成无符号数。而负数的有符号数最高位一定为1，这样就可能会导致数据异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宏定义就是在开始用井号（#）定义一个函数或者是常量，这种定义在编译器中被处理，运算速度快，但使用宏定义时可能会出现一些隐蔽的问题&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>delete的一个注意事项</title>
    <link href="http://xinhecuican.github.io/2020/02/26/delete%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://xinhecuican.github.io/2020/02/26/delete%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2020-02-26T07:34:00.000Z</published>
    <updated>2020-02-26T08:10:04.183Z</updated>
    
    <content type="html"><![CDATA[<p>实际上delete后的指针并不会变成空指针，仍指向堆里的地址。但是这个时候这块空间已经可以被其他的new申请了，如果你没有把原指针更改的话，有可能对原指针进行的修改会影响到新指针。因此每次delete完之后最好把这个指针变成空指针</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实际上delete后的指针并不会变成空指针，仍指向堆里的地址。但是这个时候这块空间已经可以被其他的new申请了，如果你没有把原指针更改的话，有可能对原指针进行的修改会影响到新指针。因此每次delete完之后最好把这个指针变成空指针&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="c++" scheme="http://xinhecuican.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>位运算和移位运算</title>
    <link href="http://xinhecuican.github.io/2020/02/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E4%B8%80%E4%BD%8D%E5%8E%9F%E9%85%B8/"/>
    <id>http://xinhecuican.github.io/2020/02/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E4%B8%80%E4%BD%8D%E5%8E%9F%E9%85%B8/</id>
    <published>2020-02-25T07:56:00.000Z</published>
    <updated>2020-02-27T11:19:14.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h3><p>这里的与运算并不是平常的bool运算，而是按位与。这种运算比加减法快</p><p>符号： &amp;</p><p>例： 1010&amp;1000=1000 1001&amp;0110=0000</p><p>含义： 1&amp;1=1,1&amp;0=0,0&amp;1=0,0&amp;0=0，只要不是两个都是,1，那么结果就是0</p><p>应用：</p><ul><li>替换指定位的值</li></ul><p>一个典型应用就是大小写转换，如果平常转换我们可能要写一大堆，但是经过仔细观察后发现大写字母和小写字母之间差距只有第5位，如果第五位为0，就是大写字母，为1就是小写字母，所以只要<code>a&amp;0b11011111</code>这一段代码就可以完成小写到大写的转换</p><ul><li>清零</li></ul><p>通过 a&amp;0b00000000 ,可以快速的把某个数变成零</p><h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h3><p>符号： |</p><p>例： 1010|1000=1010 1001|0110=1111</p><p>含义： 1|1=1,1|0=1，0|1=1，0|0=0</p><p>应用：</p><ul><li>设定某一个数据位为1，例如想把第五位设为1，只要 a|0b00100000</li></ul><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>符号： ^</p><p>例： 1010^1000=0010, 1001^0110=1111</p><p>含义： 1^1=0,1^0=1,0^1=1,0^0=0，同为假，异为真</p><p>应用：</p><ul><li><p>异或满足交换率，结合率</p></li><li><p>x^x=0,x^0=x,自己是自己的逆元，0是幺元</p></li><li><p>a^b^a=b,因此可以用这种性质做许多应用，一个应用就是交换两个变量的值</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*&amp; a,<span class="keyword">int</span>*&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a=*a ^ *b;  <span class="comment">//a=a^b</span></span><br><span class="line">    *b=*a ^ *b; <span class="comment">//b=a^b^b=a</span></span><br><span class="line">    *a=*a ^ *b; <span class="comment">//a=a^b^a=b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还可以用来检查重复数或者在其余都是偶数个重复数字中找到一个奇数</p><p>例：1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现<br>一次。每个数组元素只能访问一次</p><p>将所有的数全部异或，得到的结果与1^2^3^…^1000的结果进行异或，得到的结果就是重复数。</p><h3 id="按位非"><a href="#按位非" class="headerlink" title="按位非"></a>按位非</h3><p>符号： ~</p><p>例： ~1001=0110， ~1010=0101</p><p>含义： <del>1=0，</del>0=1 ,取反</p><p>应用：</p><ul><li><p>对于有符号数 <del>a=-(a+1),因为一般采用补码，而补码的负数就是正数-1再取反得到，所以</del>(a-1)=-a，可得~a=-(a+1)</p></li><li><p>把最低位变成0，a&amp;~1</p><h3 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h3></li></ul><p>符号： &lt;&lt;</p><p>例 00001010&lt;&lt;1 =&gt; 00010100</p><p>含义： 把所有的位向左移位，高位删去，低位补零，相当于乘上2的n次方</p><p>注意：如果移动次数超过了最高位，那么这是一个未定义行为。所以不同编译器，不同cpu对其有不同解释。gcc会将其自动变成0，而微软的编译器会先将移动位数模上最大位数然后再左移相应位数。cpu中也是取模的方式。</p><p>例如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;</span><br><span class="line">b=a&lt;&lt;<span class="number">40</span>;<span class="comment">//此时b=0，因为这个命令是在编译器中完成的</span></span><br><span class="line">a&lt;&lt;=<span class="number">40</span>;<span class="comment">//此时a！=0，因为这个命令是在cpu中完成的</span></span><br></pre></td></tr></table></figure><h3 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h3><p>符号： &gt;&gt;</p><p>含义 将所有位向右移位，高位视情况而定，低位舍弃</p><p>视情况而定是因为实际上有两种右移，第一种是逻辑右移，第二种是算术右移</p><ul><li>逻辑右移，高位直接取0</li><li>算术右移，高位要看情况，如果原来最高位是0，则取0。如果最高位是1，则后面加的都是1.</li></ul><p>那什么时候用逻辑右移还是算术右移呢？一般来说，有符号数算术右移，无符号数逻辑右移。因为有符号数用的是补码，如果是负数右移最高位补1才能让这个数还是负数</p><p>应用：</p><ul><li>不用-号把1变成-1<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;</span><br><span class="line">a&gt;&gt;=<span class="number">31</span>;<span class="comment">//最高位为1，其余都为0</span></span><br><span class="line">a&lt;&lt;=<span class="number">31</span>;<span class="comment">//都为1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="右移运算对整数的影响"><a href="#右移运算对整数的影响" class="headerlink" title="右移运算对整数的影响"></a>右移运算对整数的影响</h4><p>右移运算相当于除2，之后低位相当于小数点后面的数字。这时我们把它截断相当于取整，对于无符号数和有符号数中的非负数，这个取整是没什么影响的，但对于有符号数中的负数，取整却与除法取整有所偏差。</p><p>除法取整是趋向于零。也就是说，非负数向下取整，负数向上取整。而右移确是把小数后面的数全部舍弃，就相当于让这个数更小了。</p><p>例如： 假如右移后是 -1234.32423，结果是-1235.因为把小数点舍弃会使这个数更小。</p><p>有一种情况除外。就是右移产生的小数点位中全是0，这时舍弃它并不会产生影响，所以不会发生向下取整。</p><p>为了解决这个问题，一种办法就是 <code>(x+2^k-1)&gt;&gt;k</code>，为了加快速度，可以写成<code>(x+1&lt;&lt;k-1)&gt;&gt;k</code></p><p>现在来看这个式子的正确性，当最后几位全为0时，例如1000000右移三位，那么2^3-1=0b111,因为本来这个结果就是正确答案，现在加上111并没有改变它的值，0b1111000.111后面三位舍弃与原来相同，因此这个时候结论正确</p><p>如果后面不是全为0，那么这时必定产生进位，例如1101右移三位那么加上之后必定会使第四位进一位，这时我们再右移三位，便相当于让原来的答案加一，达到了向上取整的效果</p><p>最后，只有在有符号数中的负数中才要采用这种算法，在非负数中直接右移即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;与运算&quot;&gt;&lt;a href=&quot;#与运算&quot; class=&quot;headerlink&quot; title=&quot;与运算&quot;&gt;&lt;/a&gt;与运算&lt;/h3&gt;&lt;p&gt;这里的与运算并不是平常的bool运算，而是按位与。这种运算比加减法快&lt;/p&gt;
&lt;p&gt;符号： &amp;amp;&lt;/p&gt;
&lt;p&gt;例： 1010
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>c++输出16进制，10进制和2进制</title>
    <link href="http://xinhecuican.github.io/2020/02/22/c-%E8%BE%93%E5%87%BA16%E8%BF%9B%E5%88%B6%EF%BC%8C10%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6/"/>
    <id>http://xinhecuican.github.io/2020/02/22/c-%E8%BE%93%E5%87%BA16%E8%BF%9B%E5%88%B6%EF%BC%8C10%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6/</id>
    <published>2020-02-22T06:17:00.000Z</published>
    <updated>2020-02-22T06:29:45.858Z</updated>
    
    <content type="html"><![CDATA[<p>hex是输出16进制，例如<br><code>cout&lt;&lt;hex&lt;&lt;18&lt;&lt;endl;</code></p><p>dec十进制</p><p>另外这两种用了之后后面输出一直是这种进制，如果用了hex之后想要用十进制要写dec</p><p>二进制bitset</p><p>bitset有头文件 <code>&lt;bitset&gt;</code></p><p>  使用方法 bitset&lt;8&gt;(数字），其中8的含义是要输处几位二进制数，所以如果用int型是32，如果想把字符型转换就直接写8</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hex是输出16进制，例如&lt;br&gt;&lt;code&gt;cout&amp;lt;&amp;lt;hex&amp;lt;&amp;lt;18&amp;lt;&amp;lt;endl;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;dec十进制&lt;/p&gt;
&lt;p&gt;另外这两种用了之后后面输出一直是这种进制，如果用了hex之后想要用十进制要写dec&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>shell内部命令与外部命令与搜索路径</title>
    <link href="http://xinhecuican.github.io/2020/02/22/shell%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://xinhecuican.github.io/2020/02/22/shell%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-02-22T01:09:00.000Z</published>
    <updated>2020-02-24T12:50:25.583Z</updated>
    
    <content type="html"><![CDATA[<p>有些命令是shell外部的，shell会解析参数然后调用外部的程序去处理它，另外还有一些是对shell起作用的，叫shell内置命令</p><p>如果先查看内部命令，需要 man + shell名称 ，例如，man bash</p><h3 id="外部命令和搜索路径"><a href="#外部命令和搜索路径" class="headerlink" title="外部命令和搜索路径"></a>外部命令和搜索路径</h3><p>shell是如何知道那些程序都在哪呢？ 实际上shell是检查PATH环境变量，PATH包含一串字符，这串字符就是一系列目录名称，称作搜索路径。如果输入一个命令，shell会依次按这些目录去搜索命令</p><p>先要看PATH 直接 echo $PATH即可</p><h3 id="修改搜索路径"><a href="#修改搜索路径" class="headerlink" title="修改搜索路径"></a>修改搜索路径</h3><p>可以用export命令，export命令可以使PATH变量变成环境变量，这就意味着shell和随后所有进程都可以使用它，例如<code>export PATH=&quot;/bin:/usr/bin:/usr/ucb:/usr/local/bin&quot;</code></p><p>如果希望在搜索路径的末尾加上一条路径，可以 <code>export PATH=&quot;$PATH:$HOME/bin&quot;</code><br>如果想在最后加上一条指令，可以<code>export PATH=&quot;$HOME/bin:$PATH&quot;</code></p><p>如果把自己写的date命令放在开头，系统将会执行自己写的date命令，而不会执行系统本身的命令</p><p>实际上用export设置的环境变量在下次启动时就会失效，如果想一直保存需要修改一些特定的文件</p><h3 id="修改命令行提示"><a href="#修改命令行提示" class="headerlink" title="修改命令行提示"></a>修改命令行提示</h3><p>命令行提示的路径在PS1的环境变量当中,因此要修改的话只需要export PS1=”$ “就可以了</p><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>用反引号<code></code> `,用了这种符号会先执行反引号你饿不的命令然后再执行外部命令，</p><p>例如 <code>echo &quot;Date is</code>date` “</p><p>这个命令会显示Date is + 具体时间，注意要用双引号，单引号会把反引号引用掉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有些命令是shell外部的，shell会解析参数然后调用外部的程序去处理它，另外还有一些是对shell起作用的，叫shell内置命令&lt;/p&gt;
&lt;p&gt;如果先查看内部命令，需要 man + shell名称 ，例如，man bash&lt;/p&gt;
&lt;h3 id=&quot;外部命令和搜索路径&quot;&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>元字符的使用</title>
    <link href="http://xinhecuican.github.io/2020/02/22/%E4%BA%91%E5%AD%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xinhecuican.github.io/2020/02/22/%E4%BA%91%E5%AD%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-22T00:39:00.000Z</published>
    <updated>2020-02-22T01:07:20.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>元字符指的是Linux中有特殊含义的字符，例如 ； 换行符等。</p><h3 id="字符引用和转义"><a href="#字符引用和转义" class="headerlink" title="字符引用和转义"></a>字符引用和转义</h3><p>如果不想用元字符内在含义，只想打出这个字符，那么就需要用到引用字符。</p><p>字符引用的方法有三种，使用反斜线，使用一对单引号或者使用一对双引号</p><p>例如 echo a ; b 这样就会把他们当成不同的指令，但是如果 echo a; b,这样就会当成同一个指令，实际上\是转义字符，转义字符指的是把一个字符从一中状态转移到另一种状态</p><p>单引号会将一切字符引用，这样有时例如我需要引用其中一个变量的值的时候就会出现问题</p><p>这时我们就可以用到双引号，双引号不会引用 $ , \ , `(反引号），</p><p>引用能力强弱 ，&gt;‘’&gt;””</p><p>如果输入换行字符，单引号并不会转义它，但是\会转义它</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;元字符&quot;&gt;&lt;a href=&quot;#元字符&quot; class=&quot;headerlink&quot; title=&quot;元字符&quot;&gt;&lt;/a&gt;元字符&lt;/h3&gt;&lt;p&gt;元字符指的是Linux中有特殊含义的字符，例如 ； 换行符等。&lt;/p&gt;
&lt;h3 id=&quot;字符引用和转义&quot;&gt;&lt;a href=&quot;#字符引
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>顺序表</title>
    <link href="http://xinhecuican.github.io/2020/02/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <id>http://xinhecuican.github.io/2020/02/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</id>
    <published>2020-02-17T08:20:00.000Z</published>
    <updated>2020-02-17T08:51:30.974Z</updated>
    
    <content type="html"><![CDATA[<p>顺序表就是将元素放入一个连续的内存空间里，它的优点是可以快速访问，缺点是插入和删除操作时间复杂度高</p><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> datasize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>* p;<span class="comment">//存储空间的基址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//现在有的元素数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(node&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.p=<span class="keyword">new</span> <span class="keyword">int</span>[datasize];</span><br><span class="line">    <span class="keyword">if</span>(a.p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"储存分配失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> [] a.p;</span><br><span class="line">    &#125;</span><br><span class="line">    a.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化有两点要注意的地方，第一点是用了传引用，第二点是动态分配内存，这就表示如果使用完了要delete</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">find</span>(node&amp; a,int x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;a.<span class="built_in">length</span>;<span class="built_in">i</span>++)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(a.p[<span class="built_in">i</span>]==x)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">i</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入操作是把一个数插入第i位，其他位顺序后移</p><p>如果插入某一位概率相同，那么在第0位插入需要移动n个数，第一位插入需要移动n-1个数……在第n位插入需要移动0个数，总共有n-1中可能，总共需要移动的次数为n(n+1)/2,所以平均需要移动次数为n/2</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int insert(node&amp; a,int x,int <span class="built_in">i</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">i</span>&lt;<span class="number">0</span>||<span class="built_in">i</span>&gt;a.<span class="built_in">length</span>||a.<span class="built_in">length</span>==datasize)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">j</span>=a.<span class="built_in">length</span>;<span class="built_in">j</span>&gt;<span class="built_in">i</span>;<span class="built_in">j</span>--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="built_in">j</span>]=a[<span class="built_in">j</span><span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="built_in">i</span>]=x;</span><br><span class="line">    a.<span class="built_in">length</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>与上面操作类似，这里需要前移，并且平均操作次数为(n-1)/2</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> Delete(node&amp; a,<span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i;k&lt;a.length<span class="number">-1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.p[k]=a.p[k+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a.length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;顺序表就是将元素放入一个连续的内存空间里，它的优点是可以快速访问，缺点是插入和删除操作时间复杂度高&lt;/p&gt;
&lt;h3 id=&quot;建立&quot;&gt;&lt;a href=&quot;#建立&quot; class=&quot;headerlink&quot; title=&quot;建立&quot;&gt;&lt;/a&gt;建立&lt;/h3&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>linux指令学习</title>
    <link href="http://xinhecuican.github.io/2020/02/16/linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <id>http://xinhecuican.github.io/2020/02/16/linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-02-16T02:20:00.000Z</published>
    <updated>2020-02-29T02:20:14.872Z</updated>
    
    <content type="html"><![CDATA[<h5 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h5><p>一次输入多条命令，可以在命令之间用 <code>;</code>分割开来</p><p>语法： 命令名称 选项 参数</p><p><strong>选项</strong>有时被称为开关（switches）或标志（flags），选项通常是由一个连字符后面接着一些字母，或者两个连字符后接着一个单词构成。例如 –help，–version（显示版本信息）</p><p>使用多个单字符选项时，可以把他们连接在一起，用一个连字符来表示。例如 ls -lF<br>。注意，unix的选项区分大小写</p><p>实际上许多长参数有着对应的短参数，但是长参数是一个完整的单词，为了便于记忆，有时也是用长参数，这时就要用两个连字符</p><p>输入命令时，必须要把每个选项和参数用空格分隔开</p><p>有些命令有默认值，有些命令没有默认值，例如 ls 如果只输入ls的话他会返回当前工作目录下所有文件</p><p>手册中提示的语法</p><ol><li>方括号中的项是可选的</li><li>不再方括号中的项是必选项</li><li>黑体字必须原样输入</li><li>斜体字可以用适当的值代替</li><li>有省略号代表可以重复多次</li><li>如果一个单独的选项和参数组合在一起，这二者必须同时出现</li><li>由竖线（|）字符分开的两个或者多个项，宝石可以从这个列表中选择任意一项</li></ol><h5 id="用户提醒命令"><a href="#用户提醒命令" class="headerlink" title="用户提醒命令"></a>用户提醒命令</h5><ul><li>who 用来显示用这个计算机的用户</li><li>whoami 用来显示当前用户标识</li><li>quota 用来看自己拥有多少空间</li><li>lock 临时上锁 lock -5 锁5分钟</li><li>leave leave +15 十五分钟后离开 leave 1344 13点44分离开，到了时间它会不停的提醒你，相当于一个闹钟</li><li>id 用来显示你的基本信息</li><li>date 时间 date -u 协调世界时间（UTC时间）</li><li>cal 显示日历 cal+某一年份可以显示某一年份的日历 cal 7 2019 显示2019年7月的日历 cal -j +… 会显示第几天，所以想要知道这一年是不是闰年只需 cal -j 12 + 年份，看看12月最后一天是不是366天就可以了</li><li>su（substitute user） 这个指令是用来切换用户的，如果你知道一个用户的口令，那么就可以采用su+用户名的方式切换，这个时候用户标识改变了，但是你仍位于旧的环境之中。就像你让别人来你家做事，如果你想让别人在自己家做事，就要用su+’-‘+用户名</li></ul><p>特别的，如果你想拥有root权限，你需要 su - root ，这时你输入的是你自己的口令而不是root口令，因为在计算机中有特殊的配置文件，这个文件只有管理员能操作，他可以修改那些人可以通过su口令获得root权限</p><ul><li>man 联机文档帮助 当你查看联机文档时，可以用/符加上你想搜索的内容进行搜索，用n来显示下一个，用N来显示上一个。？符是向下搜索。<br>如果想在查看man文档时执行指令，只需输入！在输入命令，之后按enter键又能回到man文档中</li><li>foo bar 可以指代任意标识<br>man文档显示的内容</li></ul><ol><li>命令</li><li>系统调用</li><li>库函数</li><li>特殊文件</li><li>文件格式</li><li>游戏</li><li>杂项</li><li>系统管理</li></ol><ul><li><p>whatis 显示说明书页的第一行（名字和用途）例如 whatis time date，这样同时显示两条指令的信息。这种指令可以用 man -f 替换</p></li><li><p>apropos 搜索命令 他将显示所有带有该字符的命令。这种命令可以用man -k代替</p></li><li><p>info 另一种搜索命令，这种命令的特点是它有到其他命令的连接，就好像网页一样。这时一种树形结构，n跳转到下一个节点，p跳转到上一个节点，t跳转到当前文件的顶节点</p><h5 id="登入登出命令"><a href="#登入登出命令" class="headerlink" title="登入登出命令"></a>登入登出命令</h5></li><li><p>exit 退出当前用户，例如想从root模式退出用exit</p></li><li><p>sudo 以超级用户模式运行一条指令。如果你经常使用超级用户，可能在无意间删去一些重要文件导致系统出现故障，因此超级用户需慎用。因此要用可以用sudo命令。</p></li><li><p>less 浏览配置文件。例如我想浏览passwd文件，只需 less /etc/passwd</p></li></ul><p>配置文件就像windows系统下的注册表和ini文件</p><ul><li>dmesg 显示启动信息，但是这种显示太快，看不清</li><li>dmesg | less 显示启动信息</li><li>init 设置运行级别，1为单用户，2为多用户，等等，0是关机，6是重启</li></ul><p>如果想重启，可以用 sudo init 6</p><ul><li>reboot 重启 sudo reboot</li><li>shutdown 关机，这个要说关机时间，经常用的是sudo shutdown now</li></ul><h5 id="快捷键和便捷输入命令"><a href="#快捷键和便捷输入命令" class="headerlink" title="快捷键和便捷输入命令"></a>快捷键和便捷输入命令</h5><ul><li>erase 删除最好一个键入的字符，Ctrl+H</li><li>werase 删除最后一个单词 Ctrl+W</li><li>kill 删除一行 Ctrl+U</li><li>intr 停止程序 有些系统是Ctrl+C，有些是delete</li><li>quit 停止程序 Ctrl+\ 它不仅会停止程序，还会生成一个副本保存在core的文件中</li><li>stop 停止屏幕显示，Ctrl+S</li><li>start 开始屏幕显示 Ctrl+Q</li><li>eof 文件终止信号 Ctrl+D<br>可以通过Ctrl+D终止shell，但是有时候会不小心按到。为了让shell忽略eof，需要使用一个叫IGNOREEOF的环境变量，这个变量表示注销前BASH会忽略多少次eof，设置这个变量时，要 IGNOREEOF = 数字</li><li>stty -a 显示键盘映射，这个命令是表示各个快捷方式如erase的快捷键。stty是set terminal(设置终端）-a表示显示所有设置</li><li>stty 修改键映射。例如想修改kill命令 ，可以 stty kill Ctrl a</li><li>返回字符 ^M，指的是返回到这一行的开头</li><li>换行字符 ^J<br>文件每一行最后一定是一个返回加换行</li><li>stty sane，reset 候终端的设置被弄乱，可以采用这个命令是终端恢复到初始值</li><li>up 向上键，会转到上一条指令</li><li>down 转到下一条指令</li><li>fc 查看历史命令列表，用fc -l来查看，前面都有一个编号。如果想转到某一条指令，可以 fc -s(substitute) 编号。如果后面不接编号，则默认为上一条指令。但是用fc -s会立刻执行这条指令</li></ul><p>可以对这条命令进行小范围修改，格式为 fc -s pattern=replacement number<br>。pattern和replacement 都是字符串，而number是要修改时间的编号</p><ul><li>tab 自动补全命令，按一下如果有歧义，会发出提示声<h5 id="立即使用的程序"><a href="#立即使用的程序" class="headerlink" title="立即使用的程序"></a>立即使用的程序</h5></li><li>which 看某个命令会使用那些程序，如果显示地址，则说明有这些程序，如果没有输出，或者输出错误信息，则说明这个命令无法使用</li><li>quit 终止程序命令，但是也可以输入eof使程序终止</li><li>bc 计算器 如果想用bc内部的函数，要用bc -l命令（library)。如果是多个算式，中间要用”;”号隔开</li></ul><p>常用函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">s</span><span class="params">(x)</span></span> sinx  弧度制</span><br><span class="line"><span class="function"><span class="title">c</span><span class="params">(x)</span></span> cosx</span><br><span class="line"><span class="function"><span class="title">a</span><span class="params">(x)</span></span> arctanx</span><br><span class="line"><span class="function"><span class="title">ln</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">j</span><span class="params">(n,x)</span></span>  x的n次整阶贝塞尔函数</span><br></pre></td></tr></table></figure><p>如果想用小数运算，先要设置标度因子 scale 来确定精确到小数点后多少位。如果输入scale 则会返回scale的当前值 scale=3，则设置小数点后三位</p><p>有一点需要注意，当你用来 bc -l时，scale会自动设置为20</p><p>bc实际上是一套功能完整的数学编程语言，可以使用的变量有26个字母<br>例如 x=100 就是将x变量设为100</p><h5 id="变量显示命令"><a href="#变量显示命令" class="headerlink" title="变量显示命令"></a>变量显示命令</h5><p>环境变量实际上就是全局变量，用env显示环境变量，如果想让输出按字母表排序，可以用 env | sort | less</p><ul><li><p>set 显示shell变量</p></li><li><p>echo 显示赋予它对象的值，例如 echo I 将会输出I</p></li></ul><p>如果要显示一个变量的值，可以用$(美元符号），后面的变量最好加花括号（{}）</p><p>例如 echo ${TERM}</p><p>实际上，很多标点符号都有特殊的用途，为了能正确显示他们，要在最外面用双引号</p><ul><li><p>变量创建只需要一边写变量名，另一边写值即可。例如，HARLEY=cool，如果希望变量中有空格，则需使用双引号</p></li><li><p>export 将变量导出环境中（即变成全局变量）。还可以在创建同时导出。用 export 变量名=值即可</p></li><li><p>unset 删除变量。实际上没有办法简单的从环境中移除变量，因此最简单的办法是直接删除它。</p></li><li><p>set 显示shell所有选项的当前值，如果用 -o 则会简要的显示 +o是详细的显示。例如，set -o ignoreeof 这样在按 Ctrl+D的时候就不会突出shell了，如果想复位，只要+o</p></li><li><p>alias 建立别名，语法为alias name=command 例如 <code>alias It=&#39;-l temp*&#39;</code>。这种时候，单引号就比双引号要好，因为这样可以防止一些特殊字符被转义。此外，可以通过alias name 知道这个别名的当前值。可以只输入alias得知所有别名，通过unalias删去别名。如果想暂时不用别名，可以在命令之前输入” \ “</p></li></ul><h5 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h5><ul><li>gedit 文本编辑器，相当于windows下的记事本</li><li>#注释</li></ul><h5 id="条件执行指令"><a href="#条件执行指令" class="headerlink" title="条件执行指令"></a>条件执行指令</h5><p>command1 &amp;&amp; command2</p><p>在条件1满足的情况下执行command2</p><p>command1|| command2</p><p>在条件1不满足的情况下也执行command2</p><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td>PATH</td><td>设置shell搜索路径</td></tr><tr><td>PS1</td><td>设置标识符</td></tr><tr><td>SHELL</td><td>shell路径</td></tr><tr><td>HISTSIZE</td><td>fc中最大保存的指令数</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;命令语法&quot;&gt;&lt;a href=&quot;#命令语法&quot; class=&quot;headerlink&quot; title=&quot;命令语法&quot;&gt;&lt;/a&gt;命令语法&lt;/h5&gt;&lt;p&gt;一次输入多条命令，可以在命令之间用 &lt;code&gt;;&lt;/code&gt;分割开来&lt;/p&gt;
&lt;p&gt;语法： 命令名称 选项 参数&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>开始使用unix</title>
    <link href="http://xinhecuican.github.io/2020/02/13/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8unix/"/>
    <id>http://xinhecuican.github.io/2020/02/13/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8unix/</id>
    <published>2020-02-13T11:10:00.000Z</published>
    <updated>2020-02-16T02:19:49.105Z</updated>
    
    <content type="html"><![CDATA[<p>当你使用Unix系统的时候，第一件要你做的事便是输入用户标识和口令（账号密码），注意，在Unix中，密码是完全不可见的，甚至连*号都不会出现。</p><p>登陆之后出现的欢迎界面，这一部分源于一个特殊的初始化文档，这就意味着你可以对文档内容进行修改从而定制化你的初始化界面。</p><p>一旦初始化命令结束执行，Unix将启动shell，并将控制权交给他。这时shell会出现一个提示-称为shell提示，并等待命令。接下来就可以输入各种命令了。</p><p>最终，没有命令时，你可以通过注销结束工作会话，此时shell将停止运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当你使用Unix系统的时候，第一件要你做的事便是输入用户标识和口令（账号密码），注意，在Unix中，密码是完全不可见的，甚至连*号都不会出现。&lt;/p&gt;
&lt;p&gt;登陆之后出现的欢迎界面，这一部分源于一个特殊的初始化文档，这就意味着你可以对文档内容进行修改从而定制化你的初始化界面
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>unix基础</title>
    <link href="http://xinhecuican.github.io/2020/02/13/unix%E5%9F%BA%E7%A1%80/"/>
    <id>http://xinhecuican.github.io/2020/02/13/unix%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-13T03:25:00.000Z</published>
    <updated>2020-02-13T11:10:21.676Z</updated>
    
    <content type="html"><![CDATA[<ol><li>操作系统有初始化功能，初始化过程只是引导过程的一部分</li></ol><p>引导过程是计算机启动时会运行一个小程序，然后再运行另一个程序，逐层运行，最后运行一个十分复杂的程序，这个程序名字是内核。</p><p>内核是操作系统的核心，因此只要计算机开启，内核边一直运行。</p><p>内核可以分为微内核和单内核两种。单内核较大，运行速度较快，但是由于没有采用模块化设计，维护修改比较困难。而微内核自己只能运行最基本的功能，其他功能要交给服务器去运行（微内核调用的其他程序），微内核速度慢，但适用于定制化的任务，如移动电话。</p><h3 id="unix-内核-使用工具"><a href="#unix-内核-使用工具" class="headerlink" title="unix=内核+使用工具"></a>unix=内核+使用工具</h3><p>只有内核并不能带来很好的用户体验，因此还有许多其他的程序。最重要的是为用户提供计算机界面的程序，shell 和 GUI。</p><p>shell 是一种提供基于文本的界面的程序，也就是平时所说的命令提示符。</p><p>而 GUI（graphical user interface）是使用窗口，鼠标指针，图标等提供图形界面.</p><p>这些工具称为Unix实用工具，有几百个。</p><h3 id="服务器和客户端"><a href="#服务器和客户端" class="headerlink" title="服务器和客户端"></a>服务器和客户端</h3><p>早期由于主机昂贵而终端便宜，所以经常是多个主机连接一个终端。因此服务器和客户端的概念也因此产生。</p><p>提供某种类型的服务的程序叫做服务器，使用服务的程序叫做客户端。例如，但你用键盘键入字符时，是主机而不是终端把字符显示出来，终端只是向主机发出了一个输出字符的请求，然后主机进行解析然后把字符输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;操作系统有初始化功能，初始化过程只是引导过程的一部分&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;引导过程是计算机启动时会运行一个小程序，然后再运行另一个程序，逐层运行，最后运行一个十分复杂的程序，这个程序名字是内核。&lt;/p&gt;
&lt;p&gt;内核是操作系统的核心，因此只要计算机开启，内
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>单调队列</title>
    <link href="http://xinhecuican.github.io/2020/02/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <id>http://xinhecuican.github.io/2020/02/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</id>
    <published>2020-02-11T10:45:00.000Z</published>
    <updated>2020-02-11T10:47:47.412Z</updated>
    
    <content type="html"><![CDATA[<p>也就是有一个数列a，要求你求数列b和c，b[i]是a[i]…a[i+w-1]中的最小值，c[i]是最大值。如果a是1,3,-1,-3,5,3,6,7，则b为-1,-3,-3,-3,3,3，c为3,3,5,5,6,7。</p><p>这个问题相当于一个数据流（数列a）在不断地到来，而数据是不断过期的，相当于我们只能保存有限的数据（sliding window中的数据，此题中就是窗口的宽度w），对于到来的查询（此题中查询是每时刻都有的），我们要返回当前滑动窗口中的最大值\最小值。注意，元素是不断过期的。</p><p>解决这个问题可以使用一种叫做单调队列的数据结构，它维护这样一种队列：</p><p>a)从队头到队尾，元素在我们所关注的指标下是递减的（严格递减，而不是非递增），比如查询如果每次问的是窗口内的最小值，那么队列中元素从左至右就应该递增，如果每次问的是窗口内的最大值，则应该递减，依此类推。这是为了保证每次查询只需要取队头元素。</p><p>b)从队头到队尾，元素对应的时刻（此题中是该元素在数列a中的下标）是递增的，但不要求连续，这是为了保证最左面的元素总是最先过期，且每当有新元素来临的时候一定是插入队尾。</p><p>满足以上两点的队列就是单调队列，首先，只有第一个元素的序列一定是单调队列。</p><p>那么怎么维护这个单调队列呢？无非是处理插入和查询两个操作。</p><p>对于插入，由于性质b，因此来的新元素插入到队列的最后就能维持b)继续成立。但是为了维护a)的成立，即元素在我们关注的指标下递减，从队尾插入新元素的时候可能要删除队尾的一些元素，具体说来就是，找到第一个大于（在所关注指标下）新元素的元素，删除其后所有元素，并将新元素插于其后。因为所有被删除的元素都比新元素要小，而且比新元素要旧，因此在以后的任何查询中都不可能成为答案，所以可以放心删除。</p><p>对于查询，由于性质b，因此所有该时刻过期的元素一定都集中在队头，因此利用查询的时机删除队头所有过期的元素，在不含过期元素后，队头得元素就是查询的答案（性质a），将其返回即可。</p><p>由于每个元素都进队出队一次，因此摊销复杂度为O(n)。</p><p>这个讲的十分清楚，我只是<a href="https://blog.csdn.net/Baoli1008/article/details/47001513" target="_blank" rel="noopener">搬运</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;也就是有一个数列a，要求你求数列b和c，b[i]是a[i]…a[i+w-1]中的最小值，c[i]是最大值。如果a是1,3,-1,-3,5,3,6,7，则b为-1,-3,-3,-3,3,3，c为3,3,5,5,6,7。&lt;/p&gt;
&lt;p&gt;这个问题相当于一个数据流（数列a）在不断地
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>双端队列deque</title>
    <link href="http://xinhecuican.github.io/2020/02/09/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque/"/>
    <id>http://xinhecuican.github.io/2020/02/09/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque/</id>
    <published>2020-02-09T06:28:00.000Z</published>
    <updated>2020-02-09T07:37:09.641Z</updated>
    
    <content type="html"><![CDATA[<p>普通的队列有许多限制，例如从一边删除插入，不能使用迭代器（因为空间不连续）等等。<br>双端队列就允许从两边插入</p><p>deque的特点：</p><p>1、支持随机访问，即支持[]以及at()，但是性能没有vector好。</p><p>2、可以在内部进行插入和删除操作，但性能不及list。</p><p>deque和vector的不同之处：</p><p>1、两端都能够快速插入和删除元素。vector只能在尾端进行。</p><p>2、deque的元素存取和迭代器操作会稍微慢一些。因为deque的内部结构会多一个间接过程。</p><p>3、迭代器是特殊的智能指针，而不是一般指针。它需要在不同的区块之间跳转。</p><p>4、deque可以包含更多的元素，其max_size可能更大。因为不止使用一块内存。</p><p>5、不支持对容量和内存分配时机的控制。</p><p>注意：在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector。因为其内部结构显示不需要复制所有元素。</p><p>迭代器属于随机存取迭代器。</p><p>以上都是复制粘贴的，从以上我们可以看出它与vector相似，不同在于它可以从两头插入，这样插入效率高，如果从中间插入，要把很多元素都移动一遍，效率低</p><p>格式： deque&lt;类型&gt; 标识符</p><p>当生成一个 deque 容器时，也可以用由两个迭代器标识的一段元素来初始化它：</p><p>std::deque<a href="std::string">std::string</a> words_part { std::begin(words),std::begin(words) + 5 };</p><p>deque的成员函数：</p><p>deq[ ]：用来访问双向队列中单个的元素。</p><p>deq.front()：返回第一个元素的引用。</p><p>deq.back()：返回最后一个元素的引用。</p><p>deq.push_front(x)：把元素x插入到双向队列的头部。</p><p>deq.pop_front()：弹出双向队列的第一个元素。</p><p>deq.push_back(x)：把元素x插入到双向队列的尾部。</p><p>deq.pop_back()：弹出双向队列的最后一个元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;普通的队列有许多限制，例如从一边删除插入，不能使用迭代器（因为空间不连续）等等。&lt;br&gt;双端队列就允许从两边插入&lt;/p&gt;
&lt;p&gt;deque的特点：&lt;/p&gt;
&lt;p&gt;1、支持随机访问，即支持[]以及at()，但是性能没有vector好。&lt;/p&gt;
&lt;p&gt;2、可以在内部进行插入和删
      
    
    </summary>
    
    
      <category term="stl" scheme="http://xinhecuican.github.io/categories/stl/"/>
    
    
  </entry>
  
  <entry>
    <title>计算几何基础</title>
    <link href="http://xinhecuican.github.io/2020/02/06/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://xinhecuican.github.io/2020/02/06/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-06T01:30:00.000Z</published>
    <updated>2020-02-06T06:44:04.234Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断两直线是否相交"><a href="#判断两直线是否相交" class="headerlink" title="判断两直线是否相交"></a>判断两直线是否相交</h3><p>P(x1,y1) Q(x2,y2) 两向量的叉积为  x1<em>y2-x2</em>y1</p><p>如果 p*q&gt;0 p在q的顺时针方向</p><p>p*q&lt;0 p在q的逆时针方向</p><p>=0  ，共线或反向</p><p><img src="/images/20170428234108337.png" alt=""></p><p>先做一次快速排斥实验，判断下一个线段中 x 较大的端点是否小于另一个线段中 x 较小的段点，若是，则说明两个线段必然没有交点，同理判断下 y</p><p>代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>x)&lt;min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>x)<span class="operator"> || </span>max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>y)&lt;min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>y) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">max(<span class="constructor">A</span>.x,<span class="constructor">B</span>.x)&lt;min(<span class="constructor">C</span>.x,<span class="constructor">D</span>.x) <span class="operator">||</span> max(<span class="constructor">A</span>.y,<span class="constructor">B</span>.y)&lt;min(<span class="constructor">C</span>.y,<span class="constructor">C</span>.y)</span></span><br></pre></td></tr></table></figure><p>如图所示，如果想判断两线段相交，只需要判断A 和 B在cd两侧即可</p><p>所以只需要 向量<code>AD*CD</code>与 BD*CD异号即可</p><p>如果端点正好在另一条线段上，两者乘积等于0</p><p>如果两者平行，叉积也为0但是可以在快速排斥实验中排除掉</p><p>总代码</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct Line &#123;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">x</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="comment">    double y1;</span></span><br><span class="line"><span class="comment">    double x2;</span></span><br><span class="line"><span class="comment">    double y2;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">bool intersection(const Line &amp;l1, const Line &amp;l2)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    //快速排斥实验</span></span><br><span class="line"><span class="comment">    if ((l1.x1 &gt; l1.x2 ? l1.x1 : l1.x2) &lt; (l2.x1 &lt; l2.x2 ? l2.x1 : l2.x2) ||</span></span><br><span class="line"><span class="comment">        (l1.y1 &gt; l1.y2 ? l1.y1 : l1.y2) &lt; (l2.y1 &lt; l2.y2 ? l2.y1 : l2.y2) ||</span></span><br><span class="line"><span class="comment">        (l2.x1 &gt; l2.x2 ? l2.x1 : l2.x2) &lt; (l1.x1 &lt; l1.x2 ? l1.x1 : l1.x2) ||</span></span><br><span class="line"><span class="comment">        (l2.y1 &gt; l2.y2 ? l2.y1 : l2.y2) &lt; (l1.y1 &lt; l1.y2 ? l1.y1 : l1.y2))</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //跨立实验</span></span><br><span class="line"><span class="comment">    if ((((l1.x1 - l2.x1)*(l2.y2 - l2.y1) - (l1.y1 - l2.y1)*(l2.x2 - l2.x1))*</span></span><br><span class="line"><span class="comment">        ((l1.x2 - l2.x1)*(l2.y2 - l2.y1) - (l1.y2 - l2.y1)*(l2.x2 - l2.x1))) &gt; 0 ||</span></span><br><span class="line"><span class="comment">        (((l2.x1 - l1.x1)*(l1.y2 - l1.y1) - (l2.y1 - l1.y1)*(l1.x2 - l1.x1))*</span></span><br><span class="line"><span class="comment">        ((l2.x2 - l1.x1)*(l1.y2 - l1.y1) - (l2.y2 - l1.y1)*(l1.x2 - l1.x1))) &gt; 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/HelloZEX/article/details/80880385" target="_blank" rel="noopener">参考</a></p><h3 id="判断点是否在多边形内部"><a href="#判断点是否在多边形内部" class="headerlink" title="判断点是否在多边形内部"></a>判断点是否在多边形内部</h3><p>我们先将横纵坐标存在一个数组内</p><p>第一步</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.x &lt; minX <span class="params">||</span> p.x &gt; maxX <span class="params">||</span> p.y &lt; minY <span class="params">||</span> p.y &gt; maxY) &#123;</span><br><span class="line">     /<span class="regexp">/ 这个测试都过不了。。。直接返回false；</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这个测试是画一个四边形</p><p>第二步， 这里我们就要讲一个定理了，以某一点为端点画一条射线，如果穿过图形次数为奇数次，则在图形内，如果是偶数次，在图形外</p><p>为了方便讨论，我们将以x轴正方向做一条射线</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int pnpoly (int nvert, float *vertx, float *verty, float testx, float testy) &#123;</span><br><span class="line">    int <span class="built_in">i</span>, <span class="built_in">j</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">i</span> = <span class="number">0</span>, <span class="built_in">j</span> = nvert<span class="number">-1</span>; <span class="built_in">i</span> &lt; nvert; <span class="built_in">j</span> = <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ( (verty[<span class="built_in">i</span>]&gt;testy) != (verty[<span class="built_in">j</span>]&gt;testy) ) &amp;&amp;</span><br><span class="line">(testx &lt; (vertx[<span class="built_in">j</span>]-vertx[<span class="built_in">i</span>]) * (testy-verty[<span class="built_in">i</span>]) / (verty[<span class="built_in">j</span>]-verty[<span class="built_in">i</span>]) + vertx[<span class="built_in">i</span>]) )</span><br><span class="line">            c = !c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nvert 是 顶点数量，testx和testy是顶点横纵坐标</p><p>第一段的意思是</p><p>verty[i] &lt;testy &lt; verty[j]</p><p>或者</p><p>verty[j] &lt;testy &lt; verty[i]</p><p>这段代码是用来粗略判断射线是否会经过该边的（没考虑反向和端点）</p><p>第二段是用来判断测试点是否在两点连线之下，这里用了斜率（移下项）</p><p>c=!c;是用来判断奇数次还是偶数次的</p><h3 id="多边形的面积"><a href="#多边形的面积" class="headerlink" title="多边形的面积"></a>多边形的面积</h3><p>s=pow(p<em>(p-a)</em>(p-b)*(p-c),0.5),p=(a+b+c)/2</p><p>凸多边形都可以通过划分变成三角形</p><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>用最少的点把给出的点全部包住</p><h4 id="andraw算法"><a href="#andraw算法" class="headerlink" title="andraw算法"></a>andraw算法</h4><p>把所有点按第一关键字x第二关键字y按从小到大排序，并且删除重复点，得到序列p1…pn</p><p>把p1 p2放入凸包中，凸包中的点用栈来保存</p><p>然后 p1p2和p2p3叉积，如果叉积大于0，则说明p1p2在p2p3右边，说明p3在内部，我们就不选，反之则把它拖入栈中并且要把p2拖出栈中</p><p>这样一直到pn算完成了一遍（下凸包），我们还要从pn反过来到p1（上凸包）,合起来就是完整的凸包</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y==b.y&amp;&amp;a.x&lt;b.x)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">xcross</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b,<span class="built_in">point</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);<span class="comment">//斜率</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">point</span> node[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node,node+n,cmp);</span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">0</span>; num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;xcross(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">        top--;</span><br><span class="line">        top++;</span><br><span class="line">        num[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> basic=top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;basic&amp;&amp;xcross(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">        top--;</span><br><span class="line">        top++;</span><br><span class="line">        num[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> s;</span><br><span class="line">    s=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=dis(node[num[i<span class="number">-1</span>]],node[num[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1lf"</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h3><p>旋转卡壳可以用来求凸包的直径，宽度，两个不相交凸包间最大距离和最小距离等</p><p>如果过凸包上的两个点可以画一对平行直线，使凸包上所有点都夹在两<br>条平行线之间 || 落在平行线上，那么这两个点称为一对对踵点。</p><p><img src="/images/4429524-41118e7599b80fb5.webp" alt=""><br>其实简单来说就是用一对平行线“卡”住凸包进行旋转。<br>被一对卡壳正好卡住的对应点对称为对踵点，对锺点的具体定义不好说，不过从图上还是比较好理解的。可以证明对鍾点的个数不超过3*n/2</p><p>卡壳有两种情况，第一种是一点对一点， 也就是上图中的</p><p><img src="/images/4429524-6d28ceac8cc2b711.webp" alt=""></p><p>另一种是一边只有一点，另外一边有两个点</p><p>第二种情况中我们可以发现对鍾点到对应边的距离比其他的要大（不要问我为什么）</p><p>Step1：计算多边形 y 方向上的端点，称之为 ymin 和 ymax。</p><p>Step2：通过 ymin 和 ymax 构造两条水平切线，由于他们已经是一对对<br>踵点，计算他们之间的距离并维护一个当前最大值。</p><p>Step3：同时旋转两条直线到其中一条与多边形的一条边重合。</p><p>Step4：一个新的对踵点对此时产生，计算新的距离，并和当前最大值进<br>行比较，若大于当前最大值。则更新。</p><p>Step5：重复 Step3 和 Step4 的过程直到再次产生新的对踵点对。</p><p>Step6：输出最大直径的对踵点对。</p><p>听起来有点小麻烦，观察可以发现当平行线和多边形的一条边重合的时<br>候最会产生一对新的对踵点<br>这条边的两个端点和原来的点都可能更新最大值</p><p>不妨考虑找离每条边最远的点，显然，这条边的两个端点都和最远点是<br>对踵点<br>特殊情况，如果有两条边是平行的，必须考虑所有的对踵点。<br>旋转卡壳的均摊复杂度 O(n)，但这个问题需要求凸包，复杂度是<br>O(nlogn)</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void solve2(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ymax=-1e5,ymin=1e5<span class="comment">;</span></span><br><span class="line">    <span class="keyword">int</span> ymaxidx,yminidx<span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">int</span> i=<span class="number">1</span><span class="comment">;i&lt;=num;i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if(<span class="number">ch</span>[i].y&gt;ymax)</span><br><span class="line">        &#123;</span><br><span class="line">            ymax=<span class="number">ch</span>[i].y<span class="comment">;</span></span><br><span class="line">            ymaxidx=i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="number">ch</span>[i].y&lt;ymin)</span><br><span class="line">        &#123;</span><br><span class="line">            ymin=<span class="number">ch</span>[i].y<span class="comment">;</span></span><br><span class="line">            yminidx=i<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx])<span class="comment">;</span></span><br><span class="line">    <span class="number">ch</span>[num+<span class="number">1</span>]=<span class="number">ch</span>[<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    for(<span class="keyword">int</span> t=<span class="number">1</span><span class="comment">;t&lt;=num;t++,yminidx=yminidx%num+1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        while(xmult(<span class="number">ch</span>[yminidx+<span class="number">1</span>],<span class="number">ch</span>[ymaxidx+<span class="number">1</span>],<span class="number">ch</span>[yminidx])&gt;xmult(<span class="number">ch</span>[yminidx+<span class="number">1</span>],<span class="number">ch</span>[ymaxidx],<span class="number">ch</span>[yminidx]))ymaxidx=ymaxidx%num+<span class="number">1</span><span class="comment">;</span></span><br><span class="line">        ans=max(ans,dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx]))<span class="comment">;</span></span><br><span class="line">        ans=max(ans,dis2(<span class="number">ch</span>[ymaxidx]-<span class="number">ch</span>[yminidx+<span class="number">1</span>]))<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,ans)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;判断两直线是否相交&quot;&gt;&lt;a href=&quot;#判断两直线是否相交&quot; class=&quot;headerlink&quot; title=&quot;判断两直线是否相交&quot;&gt;&lt;/a&gt;判断两直线是否相交&lt;/h3&gt;&lt;p&gt;P(x1,y1) Q(x2,y2) 两向量的叉积为  x1&lt;em&gt;y2-x2&lt;/em
      
    
    </summary>
    
    
      <category term="数学" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>数论</title>
    <link href="http://xinhecuican.github.io/2020/02/06/%E6%95%B0%E8%AE%BA/"/>
    <id>http://xinhecuican.github.io/2020/02/06/%E6%95%B0%E8%AE%BA/</id>
    <published>2020-02-05T23:48:00.000Z</published>
    <updated>2020-02-09T06:24:55.600Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h3><p>如果a能被b整除，a=b*q，q为一整数记作b|a,a是被除的那个</p><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>如果a和bmod m 是同一个值，则称a和b同余，记作a (三横线） b(mod m)</p><p>例如： 3 和 8 关于5 同余  因为 3%5=3,8%5=3</p><p>重要性质：  </p><pre><code>（a+b)%c=a%c+b%c(a*b)%c=(a%c*b%c)%c(a^b)%c=(a%c^b)%c</code></pre><h3 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h3><p>任何大于1的正整数n都可以被分解为若干质数的乘积</p><p>约数个数 例如 72=2^3<em>3^2  ，而72有 1 2 3 4 6 8 9 12 18 24 36 72 12个约数<br>，而我可以从2^3 中提取出0个2,1个2，两个2，三个2把其他的数放到另一边，这样我们就可以得到4个约数，3也同理，用一下分配率，就可以得到约数个数为3</em>4=12</p><p>约数和  因为约数是从2和3中随机挑出若干个数进行分配，所以用分配率可得约数和为</p><p>(1+2+2^2+2^3)(1+3+3^2)</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>如果p是质数且a与p互质，则</p><p>a^(p-1)%p=1(a的p-1次方和1关于p同余）</p><p>互质指的是 二者除了1以外没有相同的约数</p><h3 id="求质数的方法"><a href="#求质数的方法" class="headerlink" title="求质数的方法"></a>求质数的方法</h3><p><a href="http://localhost:4000/2020/01/04/%E5%9F%83%E6%B0%8F%E7%AD%9B/" target="_blank" rel="noopener">埃氏筛</a></p><p><a href="http://localhost:4000/2020/01/04/%E7%BA%BF%E6%80%A7%E7%AD%9B/" target="_blank" rel="noopener">线性筛</a></p><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>概念：表示0到n-1中与n互素的数的个数</p><p>积性函数：如果 m和n互质 ，则f(m<em>n)=f(m)</em>f(n)</p><p>欧拉函数的性质：</p><ol><li>对于质数p  f(p)=p-1</li><li>如果n=p^k,则f(n)=p^k-p^k-1</li><li>欧拉函数是积性函数，但不是完全积性函数，当n为质数时成立，当m=2,n为奇数时，f(2*n)=n</li><li>n&gt;2时 f(n)是偶数</li><li>与n互质的数的和为 f(n)*n/2</li><li>n的因数的欧拉函数的和为n</li></ol><h3 id="模意义下的乘法逆元"><a href="#模意义下的乘法逆元" class="headerlink" title="模意义下的乘法逆元"></a>模意义下的乘法逆元</h3><p>例 1/5%7=?</p><p>3*5%7=1,所以1/5的逆元是3，所以1/5%7=3</p><p>逆元的求法</p><p>1 费马小定理</p><p>a*a^-1%p=1,a^p-1%p=1</p><p>可得 a^-1%p=a^p-2%p，然后用快速幂。但是费马小定理要求必须要是素数</p><p>2 线性求逆元（不理解）</p><p>公式：inv(a)=-p/a*inv(p%a)%p;</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">2</span>;<span class="built_in">i</span>&lt;=n;++<span class="built_in">i</span>)&#123;</span><br><span class="line">inv[<span class="built_in">i</span>]=((<span class="number">1</span>ll*(-p/<span class="built_in">i</span>)*inv[p<span class="comment">%i]%p)+p)%p;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 扩展欧几里得法</p><p>exgcd</p><p>exgcd用来求解ax+by=c，其中a，b，c都为整数</p><p>裴蜀定理</p><p>不定方程 ax+by=c存在整数解当且仅当gcd(a,b)|c ，当存在一组整数解时，必存在无限组解<br>ax+by=gcd(a,b)=&gt;bx1+a%by1=gcd(b,a%b)=&gt;x=x1,y=x1-(a/b)y1</p><p>x=x1+k<em>b/gcd(a,b) , y= y1-k</em>a/gcd(a,b)</p><p>之后一直求解直到x=1,y=0,这时b=0,所以gcd(a,b)=a,方程一定成立</p><p>在这里我们可以用递归反推，把x=1,y=0带入方程，一步步向上推</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> exgcd(<span class="built_in">int</span> a,<span class="built_in">int</span> b,<span class="built_in">int</span> &amp;x,<span class="built_in">int</span> &amp;y)&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> x1,y1;</span><br><span class="line">exgcd(b,a%b,x1,y1);</span><br><span class="line">x=y1;</span><br><span class="line">y=x1-(a/b)*y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就可以得到第三种方法</p><p>求逆元可以转化为：求关于x的同余方程ax（三横）1 mod b的最小正整数解</p><p>ax%b=1  ax=kb+1</p><p>即 ax-by=1</p><p>最后 x1%b+b即是答案</p><p><a href="https://big-news.cn/2019/05/19/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/" target="_blank" rel="noopener">可以看这篇博客</a></p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>求C(m,n)%p的值</p><p>可变成  (n!/m!(n-m)!)%p</p><p>之后就用费马小定理求逆元</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> ksm(<span class="built_in">int</span> a,<span class="built_in">int</span> b,<span class="built_in">int</span> p)&#123;</span><br><span class="line"><span class="built_in">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=<span class="number">1</span>ll*ret*a%p;</span><br><span class="line">a=<span class="number">1</span>ll*a*a%p;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> fac[maxn];</span><br><span class="line"><span class="built_in">int</span> inv(<span class="built_in">int</span> x)&#123;</span><br><span class="line"><span class="keyword">return</span> ksm(x,p<span class="number">-2</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> C(<span class="built_in">int</span> n,<span class="built_in">int</span> m)&#123;</span><br><span class="line"><span class="built_in">int</span> qwq=<span class="number">1</span>ll*fac[n]*inv(fac[n-m])%p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>ll*qwq*inv(fac[m])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> n,m;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">fac[i]=<span class="number">1</span>ll*fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"%d"</span>,C(n,m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;整除&quot;&gt;&lt;a href=&quot;#整除&quot; class=&quot;headerlink&quot; title=&quot;整除&quot;&gt;&lt;/a&gt;整除&lt;/h3&gt;&lt;p&gt;如果a能被b整除，a=b*q，q为一整数记作b|a,a是被除的那个&lt;/p&gt;
&lt;h3 id=&quot;同余&quot;&gt;&lt;a href=&quot;#同余&quot; class=
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
