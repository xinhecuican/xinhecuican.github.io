<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinhecuican&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-07-19T10:51:38.863Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>星河璀璨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>决策树算法</title>
    <link href="http://xinhecuican.github.io/post/ef296a07.html"/>
    <id>http://xinhecuican.github.io/post/ef296a07.html</id>
    <published>2020-07-19T02:42:00.000Z</published>
    <updated>2020-07-19T10:51:38.863Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 19 2020 18:51:48 GMT+0800 (中国标准时间) --><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>决策树是一个类似流程图的树形结构：其中，每个节点表示在一个属性上的测试。每个分支表示一个输出，每个树叶节点代表类或类的分布。</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%91.PNG" alt></p><p>上面这个例子中play和don’t play是结果，表示玩还是不玩。然后不是叶结点的节点都有一个问号，例如第一个outlook询问的是天气，后面还有湿度和是否刮风。通过这些条件得到了叶节点，叶结点都是只包含一种情况，要么是play要么是don’t play</p><p>熵： 不确定性的多少，越不确定的信息信息熵越大。</p><p>我们可以用比特(bit)来衡量信息的多少。公式为每种事情的概率* 以二为底该事情概率的对数。</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%912.PNG" alt>.变量不确定性越大，熵也就越大。</p><p>例如，我们想要知道世界杯谁会夺冠，我们可以从往届比赛中得知每个球队夺冠的大致概率，然后从而推测出bit的大小。</p><h1 id="决策树归纳算法（ID3）"><a href="#决策树归纳算法（ID3）" class="headerlink" title="决策树归纳算法（ID3）"></a>决策树归纳算法（ID3）</h1><p>决策树适合小规模，类别比较少的数据集。</p><p>我们通过什么确定该节点应该是什么问题呢?</p><p>信息获取量 Gain(A) = info(D) - info_A(D)</p><p>info(D)表示只考虑结果时信息量（bit值）。 info_A(D)表示考虑A后的信息量</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%913.PNG" alt></p><p>上面这个例子中，后面age的计算是该种类的概率（如5/14或4/14等）* 在这个种类里的信息获取量。上面青年有五种，然后求得五种里买电脑或者不买电脑的信息获取量。</p><p>最后可以求得gain，然后选取gain最大的作为该节点。 通过划分后如果只有一种目标，那么划分结束，如果有多种目标，那么重新用这种方法选取gain最大的。</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%914.PNG" alt></p><p>如果所有属性都用完了，那么采用多数表决，即哪个结果多就把它划分成哪个类。例如最后所有属性都使用了一遍，最后三人买电脑，两人不买电脑，那么最后就把它划分成买电脑类。</p><p>如果分的太细也可能出现问题。所以有时候达到一定纯度就不再往下分。还可以先全部分完然后再剪。</p><h1 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h1><p>python中有一个scikit-learn库包含了决策树。</p><p>首先sklearn要求输入的属性值必须是数值型的值而不能是young，old之类模糊的数据。</p><p>具体可以变成由0和1组成的集合。例如假如是young，那么按照young Middle old排列的话取值是100，如果是middle那么就是010.</p><p>所有特征值形成了一串0和1,以这个作为输入。</p><p>python中提供了一个函数可以直接把属性转化成01， 他叫DictVectorizer(),使用它的条件是我们把属性转化成了一个列表（所有样例构成一个列表，但是单个样例可以用字典进行描述)</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%915.PNG" alt>这是上例所形成的列表</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="INI"><figure class="iseeu highlight /ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vec</span> = DictVectorizer()</span><br><span class="line"><span class="attr">dummyx</span> = vec.fit_transform(featurelist).toarray()</span><br></pre></td></tr></table></figure></div><p>输出<br><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%916.PNG" alt></p><p>这是对于特征值的，对于目标标记也有专门的方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="INI"><figure class="iseeu highlight /ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lb</span> = processing.LabelBinarizer()</span><br><span class="line"><span class="attr">dummyY</span> = lb.fit_transform(labellist)</span><br></pre></td></tr></table></figure></div><p><strong>创建分类器</strong></p><p>前面都是对数据进行预处理，预处理完毕之后我们就要把它转换成决策树模型了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="INI"><figure class="iseeu highlight /ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clf</span> = tree.DecesionTreeClassifier(criterion = <span class="string">'entropy'</span>) <span class="comment">#criterion是使用的决策树算法，具体可以看文档</span></span><br><span class="line"><span class="attr">ans</span> = clf.fit(dummyX, dummyY)</span><br></pre></td></tr></table></figure></div><p><strong>可视化</strong></p><p>虽然我们产生了结果，但是结果非常不直观，我们可以用graphviz将结果变成上面看到的图。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">"allElectronicInformationGainOri.dot"</span>, <span class="character">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f = tree.export<span class="constructor">_graphviz(<span class="params">clf</span>, <span class="params">feature_names</span>=<span class="params">vec</span>.<span class="params">get_feature_names</span>()</span>, out_file=f) # feature_names是属性的名字，因为在形成决策树过程中全变成<span class="number">0</span>和<span class="number">1</span>了</span><br></pre></td></tr></table></figure></div><p>通过这两行代码可以把结果输出到文件中<img src="/images/%E5%86%B3%E7%AD%96%E6%A0%917.PNG" alt>可以看到结果非常不直观，因此我们还需用graphviz进一步转化。</p><p>在cmd中输入<code>dot -Tpdf iris.dot -o output.pdf</code> iris.dot是原始文件的路径，-o是输出文件名</p><p><img src="/images/%E5%86%B3%E7%AD%96%E6%A0%918.PNG" alt></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.externals.six <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in the csv file and put features into list of dict and list of class label</span></span><br><span class="line">allElectronicsData = open(<span class="string">r'/home/zhoumiao/MachineLearning/01decisiontree/AllElectronics.csv'</span>, <span class="string">'rb'</span>)</span><br><span class="line">reader = csv.reader(allElectronicsData)</span><br><span class="line">headers = reader.next()</span><br><span class="line"></span><br><span class="line">print(headers)</span><br><span class="line"></span><br><span class="line">featureList = []</span><br><span class="line">labelList = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">    labelList.append(row[len(row)<span class="number">-1</span>])</span><br><span class="line">    rowDict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(row)<span class="number">-1</span>):</span><br><span class="line">        rowDict[headers[i]] = row[i]</span><br><span class="line">    featureList.append(rowDict)</span><br><span class="line"></span><br><span class="line">print(featureList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Vetorize features</span></span><br><span class="line">vec = DictVectorizer()</span><br><span class="line">dummyX = vec.fit_transform(featureList) .toarray()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dummyX: "</span> + str(dummyX))</span><br><span class="line">print(vec.get_feature_names())</span><br><span class="line"></span><br><span class="line">print(<span class="string">"labelList: "</span> + str(labelList))</span><br><span class="line"></span><br><span class="line"><span class="comment"># vectorize class labels</span></span><br><span class="line">lb = preprocessing.LabelBinarizer()</span><br><span class="line">dummyY = lb.fit_transform(labelList)</span><br><span class="line">print(<span class="string">"dummyY: "</span> + str(dummyY))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using decision tree for classification</span></span><br><span class="line"><span class="comment"># clf = tree.DecisionTreeClassifier()</span></span><br><span class="line">clf = tree.DecisionTreeClassifier(criterion=<span class="string">'entropy'</span>)</span><br><span class="line">clf = clf.fit(dummyX, dummyY)</span><br><span class="line">print(<span class="string">"clf: "</span> + str(clf))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize model</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"allElectronicInformationGainOri.dot"</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f = tree.export_graphviz(clf, feature_names=vec.get_feature_names(), out_file=f)</span><br><span class="line"></span><br><span class="line">oneRowX = dummyX[<span class="number">0</span>, :]</span><br><span class="line">print(<span class="string">"oneRowX: "</span> + str(oneRowX))</span><br><span class="line"></span><br><span class="line">newRowX = oneRowX</span><br><span class="line">newRowX[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">newRowX[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">print(<span class="string">"newRowX: "</span> + str(newRowX))</span><br><span class="line"></span><br><span class="line">predictedY = clf.predict(newRowX) <span class="comment"># 创建一个新的节点然后预测</span></span><br><span class="line">print(<span class="string">"predictedY: "</span> + str(predictedY))</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 19 2020 18:51:48 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基本结构&quot;&gt;&lt;a href=&quot;#基本结构&quot; class=&quot;headerlink&quot; title=&quot;基本结构&quot;&gt;&lt;/a&gt;基本结构&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://xinhecuican.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>动态顺序统计</title>
    <link href="http://xinhecuican.github.io/post/20ff5ccb.html"/>
    <id>http://xinhecuican.github.io/post/20ff5ccb.html</id>
    <published>2020-07-12T07:48:00.000Z</published>
    <updated>2020-07-14T08:40:50.074Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 07:34:22 GMT+0800 (中国标准时间) --><p>首先要了解<a href="https://xinhecuican.github.io/post/f89cb603.html#more">红黑树</a>.</p><p>顺序统计树指示在普通的红黑树上附加了一个参量，x-&gt;size。这个参量表示的是该节点的子树含有元素个数。</p><p>为了找出第i小的关键字，可以用：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SAS"><figure class="iseeu highlight /sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">select</span>(node<span class="comment">* x, int i)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int r = x-&gt;left-&gt;size + 1;</span></span><br><span class="line">    </span><br><span class="line">    //<span class="meta">x</span>的序号，因为红黑树也是一个排序树，所以<span class="meta">x</span>一定比左边元素都大</span><br><span class="line">    <span class="meta">if</span>(i == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">return</span> <span class="meta">x</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">else</span> <span class="meta">if</span>(i &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">return</span> <span class="meta">select</span>(<span class="meta">x</span>-&gt;left, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">return</span> <span class="meta">select</span>(<span class="meta">x</span>-&gt;right, i-r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>确定一个元素的秩</strong></p><p>秩指的是排第几号元素。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rank(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">int</span> r = x-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span>size + <span class="number">1</span>;</span><br><span class="line">    node* y = x;</span><br><span class="line">    <span class="function"><span class="title">while</span>(y != t-&gt;</span>root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(y == y-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right)<span class="comment">//如果是右子树，那么还要加上左子树的数目</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">r</span> = r+y-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">y</span> = y-&gt;</span>p;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们知道，使用中序遍历可以得到排序树的排序。中间循环的过程就是找到x在父亲节点子树中位置然后再到祖宗节点中所处位置最后到根节点所处位置。</p><p><strong>维护</strong></p><p>对于插入，红黑树插入分为两个阶段，第一阶段是找位置，只需要沿途让size+1就好了，第二阶段是旋转。对于左子树， x是原来最上面的节点，现在size是<code>x-&gt;left-&gt;size + x-&gt;right-&gt;size + 1</code>， 对于右儿子y来说，y的size就是最开始x的size（因为现在它使根节点）</p><h1 id="区间树"><a href="#区间树" class="headerlink" title="区间树"></a>区间树</h1><p>区间树是另一种红黑树的扩展。它和普通红黑树的区别是多了一个区间x-&gt;int(interval)表示，区间最大值是int.high(区间的右端点),最小值是int.low.</p><p>此外，还附加了max（以x为根的子树中所有区间端点的最大值）</p><p><code>x-&gt;max = max(x-&gt;int-&gt;high, x-&gt;left-&gt;max, x-&gt;right-&gt;max)</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">search(node* t, int(interval) i)<span class="comment">//查找与i重叠的区间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">node</span>* x = t-&gt;</span>root;</span><br><span class="line">    <span class="function"><span class="title">while</span>(x != NULL &amp;&amp; (x-&gt;</span><span class="function"><span class="title">int</span>-&gt;</span><span class="function"><span class="title">low</span>&gt;i-&gt;</span><span class="function"><span class="title">high</span> || x-&gt;</span><span class="function"><span class="title">int</span>-&gt;</span><span class="function"><span class="title">high</span>&lt;i-&gt;</span>low))<span class="comment">//x!=NULL &amp;&amp; i不在x的区间范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">if</span>(x-&gt;</span><span class="function"><span class="title">left</span> != NULL &amp;&amp; x-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="function"><span class="title">max</span> &gt;= i-&gt;</span>low)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">x</span> = x-&gt;</span>left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">x</span> = x-&gt;</span>right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h1><p>给一个n个不同关键字的已排序序列，用这些关键字构建一个二叉搜索树。对于每个关键字ki，都有一个概率pi表示搜索概率。因为还有可能没有搜索到，所以还有n+1个伪关键字。</p><p>可以证明，最优二叉搜索树的子树也是最优二叉树。</p><p>所以我们求解的子问题为： 求解ki到kj的最优二叉搜索树。并且 j&gt;=i-1.当j=i-1时，不包含关键字。</p><p>当j=i-1时，子树中只包含伪关键字di-1， 所以搜索代价是qi-1</p><p>当j&gt;=i时，我们要选取一个根节点kr, ki到kr-1为左子树，kr+1到j为右子树。当一棵树成为另一棵树的子树时，因为每个节点的深度都加1，所以搜索代价的增加值应该是所有概率之和，记这个概率为w(i, j)</p><p>注意w(i, j) = w(i, r-1) + pr + w(r+1, j)</p><p>所以现在概率应该是原来左子树代价+原来右子树代价+增加代价</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%925.jpg" alt></p><p>这就是最优搜索代价的递归公式。e[i, j]表示从i到j构成的二叉树的最优搜索代价。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bst(int* p, int* q, int n)</span><br><span class="line">&#123;</span><br><span class="line">    //q是伪关键字搜索频率</span><br><span class="line">    int max = 2147483647;</span><br><span class="line">    int e<span class="comment">[n+2]</span><span class="comment">[n+1]</span>, w<span class="comment">[n+2]</span><span class="comment">[n+1]</span>, root<span class="comment">[n+1]</span><span class="comment">[n+1]</span>;</span><br><span class="line">    for(int i=1; i&lt;=n+1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e<span class="comment">[i]</span><span class="comment">[i-1]</span> = q<span class="comment">[i-1]</span>;</span><br><span class="line">        w<span class="comment">[i]</span><span class="comment">[i-1]</span> = q<span class="comment">[i-1]</span>;</span><br><span class="line">        for(int l=1; l&lt;=n; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i + l - 1;</span><br><span class="line">            e<span class="comment">[i]</span><span class="comment">[j]</span> = max;</span><br><span class="line">            w<span class="comment">[i]</span><span class="comment">[j]</span> = e<span class="comment">[i]</span><span class="comment">[j-1]</span> + p<span class="comment">[j]</span> + q<span class="comment">[j]</span>;</span><br><span class="line">            for(int r=i; r&lt;=j; r++)</span><br><span class="line">            &#123;</span><br><span class="line">                t = e<span class="comment">[i]</span><span class="comment">[r-1]</span> + e<span class="comment">[r+1]</span><span class="comment">[j]</span> + w<span class="comment">[<span class="comment">[i]</span><span class="comment">[j]</span>;</span></span><br><span class="line"><span class="comment">                if(t &lt; e<span class="comment">[i]</span><span class="comment">[j]</span>)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    e<span class="comment">[i]</span><span class="comment">[j]</span> = t;</span></span><br><span class="line"><span class="comment">                    root<span class="comment">[i]</span><span class="comment">[j]</span> = r;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return e;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 15 2020 07:34:22 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;首先要了解&lt;a href=&quot;https://xinhecuican.github.io/post/f89cb603.html#more&quot;&gt;红黑树&lt;/a
      
    
    </summary>
    
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://xinhecuican.github.io/post/f89cb603.html"/>
    <id>http://xinhecuican.github.io/post/f89cb603.html</id>
    <published>2020-07-08T06:50:00.000Z</published>
    <updated>2020-07-10T08:35:52.526Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 10 2020 16:36:08 GMT+0800 (中国标准时间) --><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>红黑树是一颗二叉搜索树，并且在每个节点上增加一个变量来储存颜色，可以是红或者是黑。红黑树保证了没有一条路径会比其他路径长两倍。</p><p>每个节点有五个属性：color、key、left、right、p(parent)。</p><p>红黑树满足以下性质：</p><ul><li>根节点是黑色</li><li>每个叶结点是黑色的。</li><li>如果一个节点是红色，则两个子节点是黑色</li><li>对于每个节点，从这个节点到所有后代节点的简单路径上，均包含相同数目的黑色节点。</li></ul><p>在叶结点中不存在值，可以用一个哨兵节点来代指叶结点。哨兵节点颜色为黑，其他值任意，之后一旦到叶结点就连接到哨兵，这样可以减少空间占用。</p><p>从某一节点出发（不包含这个节点）的任意一条简单路径上黑色节点的个数叫这个点的黑高。定义红黑树的黑高是根节点的黑高。</p><p>可以证明，节点数为n的红黑树高度至多为2lg(n+1).</p><h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p>插入和删除可能会改变红黑树的性质，这个时候就需要通过旋转来恢复红黑树的性质。</p><p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%911.jpg" alt></p><p>左旋的过程是把y的左边给x，然后x变为y的左儿子。右旋可以类比</p><p>左旋函数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void left_rotate(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//t是根节点</span></span><br><span class="line">    <span class="function"><span class="title">node</span>* y = x-&gt;</span>right;</span><br><span class="line">    <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">right</span> = y-&gt;</span>left;</span><br><span class="line">    <span class="function"><span class="title">if</span>(y-&gt;</span><span class="function"><span class="title">left</span> != NULL)//设置y-&gt;</span>left的父辈节点</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span>p = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">p</span> = x-&gt;</span>p;<span class="comment">//设置y的父辈节点</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(x-&gt;</span><span class="function"><span class="title">p</span> == NULL)//如果x-&gt;</span>p为NULL，说明它是根节点</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">t</span>-&gt;</span>root = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(x == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)<span class="comment">//这是设置原来x的父辈的连接</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right == y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">y</span>-&gt;</span>left = x;</span><br><span class="line">    <span class="function"><span class="title">x</span>-&gt;</span>p = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>我们可以先找到插入位置（用二叉搜索树的方法），然后将这个点着色为红。为了保证性质，我们还要用一个函数对节点重新着色并旋转。</p><p>调整函数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void fixup(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">while</span>(x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> == red)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(x-&gt;</span><span class="function"><span class="title">p</span> == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">node</span>* y = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">if</span>(y-&gt;</span><span class="built_in">color</span> == red)<span class="comment">//情况1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">y</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">                <span class="function"><span class="title">x</span> = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">else</span> <span class="keyword">if</span>(x == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right)<span class="comment">//情况2</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">x</span> = x-&gt;</span>p;</span><br><span class="line">                left_rotate(t, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = black;<span class="comment">//情况3</span></span><br><span class="line">            <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">            <span class="function"><span class="title">right_rotate</span>(t, x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>p);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//和上面一样，就是把左右换一下</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">root</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>因为插入的是红色的节点，所以所有路径黑色节点数目相同这个性质不可能破坏。</p><p>这里可能被破坏的是根节点必须是黑色和红节点儿子必须是黑色两个性质。所以要从这两个性质着手去解决。</p><p>上面这个函数每次while都要保持下面性质：</p><ul><li>x是红节点</li><li>如果x-&gt;p是根节点，那么x-&gt;p是黑节点</li><li>如果性质被破坏，只可能是上面两条。如果是第一条，那么x是根节点并且是红节点，如果是第二条，那么它是红并且它的父亲是红。</li></ul><p>上面三种情况区别是叔节点颜色不同。在所有情况中，相同的地方是x-&gt;p-&gt;p一定是黑色，因为x-&gt;p一定是红色。</p><p><strong>情况1：叔节点是红色</strong></p><p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%912.jpg" alt></p><p>如图，左边是最开始的情况，白色代表红色。我们就可以把A和D图成黑色，然后C变成红色，这样每条路径黑色节点数目仍没变，但是此时C变成了红节点，可能和C的父亲有冲突，所以我们要把指针移动到C点</p><p><strong>情况2，情况3： 叔节点是黑色并且x是左孩子/右孩子</strong></p><p>情况2是x为右孩子。</p><p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%913.png" alt></p><p>情况2可以通过一个左旋变成情况3，此时x是左孩子。</p><p>此时把D和A都是红色。再让C一个右旋就让D到了上面（开始进行了一次左旋D到了A上面）然后让D为黑色，A和C为红色就可以了。并且这个时候循环也会结束，因为</p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>首先要基于基础的搜索二叉树删除操作，即如果删除节点是叶结点，直接删除，如果删除节点只有一个子节点，那么删除这个节点后还要让它的父节点连接这个节点的子节点，如果有两个子节点，那么要让它的前驱（或后继）来替代他。并且它的前驱的右子节点连接它的父节点。</p><p>总的函数过程为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">transplant(node* t, node* u, node* v)<span class="comment">//删u节点操作，用v替代</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(u-&gt;</span>p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">t</span>-&gt;</span>root = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(u == u-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">u</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">u</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">v</span>-&gt;</span><span class="function"><span class="title">p</span> = u-&gt;</span>p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixup(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">while</span>(x != t-&gt;</span><span class="function"><span class="title">root</span> &amp;&amp; x-&gt;</span><span class="built_in">color</span> == black)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(x == x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">node</span>* w = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">if</span>(w-&gt;</span><span class="built_in">color</span> == red)<span class="comment">//情况1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">                <span class="function"><span class="title">left_rotate</span>(t, x-&gt;</span>p);</span><br><span class="line">                <span class="function"><span class="title">w</span> = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span>(w-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="function"><span class="title">color</span> == black &amp;&amp; w-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="built_in">color</span> == black)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="built_in">color</span> = red;<span class="comment">//情况2</span></span><br><span class="line">                <span class="function"><span class="title">x</span> = x-&gt;</span>p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">else</span> <span class="keyword">if</span>(w-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="built_in">color</span> == black)<span class="comment">//情况3</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">                <span class="function"><span class="title">w</span>-&gt;</span><span class="built_in">color</span> = red;</span><br><span class="line">                right_rotate(t, w);</span><br><span class="line">                <span class="function"><span class="title">w</span> = w-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span>right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">color</span> = x-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span>;<span class="comment">//情况4</span></span><br><span class="line">            <span class="function"><span class="title">x</span>-&gt;</span><span class="function"><span class="title">p</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">            <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">            <span class="function"><span class="title">left_rotate</span>(t, x-&gt;</span>p);</span><br><span class="line">            <span class="function"><span class="title">x</span> = t-&gt;</span>root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//就是左右交换一下</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="title">x</span>-&gt;</span><span class="built_in">color</span> = black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">delete(node* t, node* x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//y-&gt;original-&gt;color保存的是y发生改变之前的颜色</span></span><br><span class="line">    node* z;</span><br><span class="line">    node *y = x;</span><br><span class="line">    <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">original</span>-&gt;</span><span class="function"><span class="title">color</span> = y-&gt;</span><span class="built_in">color</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span>(x-&gt;</span>left == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">z</span> = x-&gt;</span>left;</span><br><span class="line">        <span class="function"><span class="title">transplant</span>(t, x, x-&gt;</span>right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(x-&gt;</span>right == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">z</span> = x-&gt;</span>right;</span><br><span class="line">        <span class="function"><span class="title">transplant</span>(t, x, x-&gt;</span>left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果两个子树都不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">y</span> = minimum(x-&gt;</span>right);<span class="comment">//找到x的后继</span></span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">original</span>-&gt;</span><span class="function"><span class="title">color</span> = y-&gt;</span><span class="built_in">color</span>;</span><br><span class="line">        <span class="function"><span class="title">z</span> = y-&gt;</span>right;</span><br><span class="line">        <span class="function"><span class="title">if</span>(y-&gt;</span>p == x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">z</span>-&gt;</span>p = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">transplant</span>(t, y, y-&gt;</span>right);</span><br><span class="line">            <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">right</span> = x-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span>p = y;</span><br><span class="line">        &#125;</span><br><span class="line">        transplant(t, x, y);</span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">left</span> = x-&gt;</span>left;</span><br><span class="line">        <span class="function"><span class="title">y</span>-&gt;</span><span class="function"><span class="title">color</span> = x-&gt;</span><span class="built_in">color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span>(y-&gt;</span><span class="function"><span class="title">original</span>-&gt;</span><span class="built_in">color</span> == black)</span><br><span class="line">    &#123;</span><br><span class="line">        fixup(t, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>保持y是要被删除的元素,因此如果y最初的颜色是黑色就可能改变性质。而z保存的是y的原始位置。</p><p>在fixup中，while循环总目标是把额外的黑色沿着树往上提。</p><p>while节点退出条件：</p><ul><li>x指向红黑节点（两种颜色）。然后再最后再将颜色变成单独的颜色。</li><li>x指向根节点</li><li>执行适当的旋转和重新着色，退出循环。</li></ul><p>在循环中，x总是指向双重黑色节点（双重黑色就是假设z位置处额外有一个黑色，之后y删除会移走一个黑色然后性质就符合了，但是多了一个黑色会导致开开始路径黑色数目就不同，所以要把这个双重黑色的节点放到根节点处，这样就不会有影响了，红黑色就是z处原来是红色。另外这是为了理解说的，和书上的不同）。</p><p>如果x是双重黑色，那么w（x的兄弟）不可能是NULL，因为这会导致两边黑色不相等。</p><p><strong>情况1： x的兄弟w是红色的</strong><br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%915.jpg" alt></p><p>它的目的是把兄弟节点变成黑色。先把父亲节点和兄弟节点的颜色设置好，然后进行旋转。会把情况变成情况2或3</p><p><strong>情况2： w黑色，并且w的两个子节点是黑色</strong></p><p>这个时候可以从w上去除一层黑色，也就是x变成单黑然后w变成红色，然后x到父亲节点（一定是红色），也就是说这个时候去掉了黑色但是性质不满足了（有两个红色），所以跳出循环后还要加一个把x变成黑色</p><p><strong>情况3： w黑色，w左孩子红色，右孩子黑色</strong></p><p>通过这种变换，会把情况变成情况4.</p><p><strong>情况4： w黑色，w右孩子红色</strong></p><p>这种情况也是可以去掉黑色的。然后把x设置成根是为了退出循环。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 10 2020 16:36:08 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h1&gt;&lt;p&gt;红黑树是一颗二叉
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>python wxpython</title>
    <link href="http://xinhecuican.github.io/post/235252ea.html"/>
    <id>http://xinhecuican.github.io/post/235252ea.html</id>
    <published>2020-07-08T00:58:00.000Z</published>
    <updated>2020-07-15T03:24:16.895Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 16 2020 08:49:38 GMT+0800 (中国标准时间) --><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>事件就是状态改变时发出的信号，然后你可以通过绑定指定一个函数去处理。例如按下按钮就产生了一个事件，之后可以让一个函数去处理按下按钮之后的反应。</p><p>绑定函数使用 Bind(event, handler, source=None, id=wx.ID_ANY, id2=wx.ID_ANY).event是产生的事件，handler是处理事件的方法,source是触发事件的对象。</p><p>例如 Bind(wx.EVT_BUTTON, self.Button_enter, button1)这样button1按下时会使用Button_enter函数</p><h1 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h1><p>方法： <code>Wx.Frame (parent, id, title, pos, size, style, name)</code></p><ul><li>parent是窗口父类，主要控制打开这个窗口时显示位置，一般显示在父窗口中央。如果是None显示在屏幕正中央。</li><li>id是窗口标识，一般选-1让id自动生成。</li><li>pos是左上角位置，用元组表示，例如(0,0),wx.DefaultPosition是由操作系统决定.</li><li>size是长和宽，wx.DefaultSize 是由操作系统决定。</li><li>style： 有wx.DEFAULT_FRAME_STYLE，wx.CAPTION，wx.MINIMIZE_BOX，wx.MAXIMIZE_BOX，wx.CLOSE_BOX，wx.SYSTEM_MENU，wx.RESIZE_BORDER，wx.STAY_ON_TOP，wx.FRAME_FLOAT_ON_PARENT</li><li>name： 内部用名</li></ul><p><img src="/images/wxpython4.png" alt></p><p>例： window = wx.Frame(None, -1, “Hello”, pos = (10,10), size = (300,200),style = wxDEFAULT_FRAME_STYLE, name = “frame”)</p><p>成员函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>CreateStatusBar()</td><td>创建窗口底部状态栏</td></tr><tr><td>CreateToolBar()</td><td>在顶部或左侧创建工具栏</td></tr><tr><td>GetMenuBar()</td><td>获取引用菜单栏</td></tr><tr><td>GetStatusBar()</td><td>获取引用状态栏</td></tr><tr><td>SetMenuBar()</td><td>显示菜单栏对象</td></tr><tr><td>setStatusBar()</td><td>关联状态栏对象到框架</td></tr><tr><td>SetToolBar()</td><td>关联工具栏对象到框架</td></tr><tr><td>SetStatusText()</td><td>在状态栏上显示的文字</td></tr><tr><td>Create()</td><td>创建有参数的框架</td></tr><tr><td>Centre()</td><td>让这个框架在中心</td></tr><tr><td>SetPosition()</td><td></td></tr><tr><td>SetSize()</td><td></td></tr><tr><td>SetTitle()</td><td></td></tr></tbody></table><p>事件：</p><ul><li>EVT_CLOSE： 当点击关闭按钮时</li><li>EVT_MENU_OPEN： 一个菜单要被打开时</li><li>EVT_MENU_CLOSE: 一个菜单被关闭后时</li><li>EVT_MENU_HIGHLIGHT： 让指定菜单凸显</li></ul><h1 id="panel"><a href="#panel" class="headerlink" title="panel"></a>panel</h1><p>创建： wx.panel(parent, id=ID_ANY, pos=DefaultPosition, size=DefaultSize,<br>style=TAB_TRAVERSAL, name=PanelNameStr)</p><p>parent指定了和Frame之间的父子关系。要定位布局或确定其他父子关系通过sizer(定位器)来完成(相当于layout)</p><h1 id="定位器"><a href="#定位器" class="headerlink" title="定位器"></a>定位器</h1><p>下面是常见定位器：</p><ul><li>wx.BoxSizer(): 把窗口布置成水平或垂直框,有水平(wx.HORIZONTAL)和垂直布局(wx.VERTICAL)，默认水平</li><li>wx.StaticBoxSizer(orient,parent,label=””)： 这是带有名字的StaticBoxSizer.创建的是一个静态框，也就是一个边框并且边框上有label</li><li>wx.StaticBoxSizer(box,orient=HORIZONTAL)： box是一个staticbox对象。</li><li>GridSizer(rows,cols,vgap,hgap): GridSizer创建一个若干行和列的小方格。其中vgap和hgap是两个方格之间的水平间隔和垂直间隔。</li><li>wx.FlexGridSizer(): GridSizer创建的方格大小是固定的，而FlexGridSizer大小可以改变。他有两个特殊的方法：AddGrowableRow(idx,proportion=0)、AddGrowableCo(idx,proportion=0).</li><li>wx.GridBagSizer(vgap,hgap): 这个可以横跨多个行和列。它的Add(control, pos, span, flags, border)，其中span是横跨的行数和列数，用一个元组表示。position是必须参数。它也可以用AddGrowableCo().idx是你想扩张的行，proportion是增加的比例。只要你的控件在那个行里拉伸时就会拉伸那个控件</li></ul><p>BoxSizer方法：</p><ul><li>AddSpacer()： 添加不可伸缩空间</li><li>AddStretchSpacer() ： 添加可伸缩空间</li><li>Clear(): 删除控件</li><li>Remove(): 销毁并删除一个控件</li></ul><p>调用容器的Fit()可以自动调整大小</p><p><strong>定位器的add函数</strong></p><p>add都是继承自wx.Sizer.</p><p>语法： Add(window,proportion=0,flag=0,border=0,userData=None)： window可以使要添加的组件，也可以是另外一个Sizer（嵌套）。</p><ul><li>proportion： 权重。如果为1表示sizer大小变化时，组件大小也会随之变化，变化速度为1。其值有0,1,2</li><li>flag： 用来控制对齐，边框和调整尺寸</li><li>border： 边框</li><li>userData： 用来传递额外的数据</li></ul><p>flag类型：</p><p><img src="/images/wxpython1.png" alt><br><img src="/images/wxpython2.png" alt><br><img src="/images/wxpython3.png" alt></p><h1 id="StaticText"><a href="#StaticText" class="headerlink" title="StaticText"></a>StaticText</h1><p>statictext是一个只读文本。</p><p>创建： Wx.StaticText(parent, id, label, position, size, style)：size是字号。style和上面的有所不同</p><p>style类型：</p><ul><li>wx.ALIGN_RIGHT,wx.ALIGN_LEFT,wx.ALIGN_CENTER: 控制文本出现位置</li><li>wx.ST_NO_AUTORESIZE: 防止标签的自动调整大小</li><li>wx.ST_ELLIPSIZE_START， wx.ST_ELLIPSIZE_MIDDLE， wx.ST_ELLIPSIZE_END: 省略号显示位置，有开始中间或结尾</li></ul><p>如果想要设置字体，首先要创建一个<code>wx.Font(pointSize,family,style,weight,underline,faceName,encoding)</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">family</span>: <span class="selector-tag">wx</span><span class="selector-class">.DECORATIVE</span>：一个正式的，老的英文样式字体。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.DEFAULT</span>：系统默认字体。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.MODERN</span>：一个单间隔（固定字符间距）字体。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.ROMAN</span>：<span class="selector-tag">serif</span>字体，通常类似于<span class="selector-tag">Times</span> <span class="selector-tag">New</span> <span class="selector-tag">Roman</span>。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.SCRIPT</span>：手写体或草写体。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.SWISS</span>：<span class="selector-tag">sans-serif</span>字体，通常类似于<span class="selector-tag">Helvetica</span>或<span class="selector-tag">Arial</span>。</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.FONTSTYLE_ITALIC</span>是斜体、<span class="selector-tag">wx</span><span class="selector-class">.FONTSTYLE_SLANT</span>罗马式斜体</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">style</span>: 指定文本是否倾斜，<span class="selector-tag">SLANT</span>是罗马式倾斜</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.NORMAL</span>,</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.SLANT</span>,</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.ITALIC</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">weight</span>：控制字体醒目程度</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.NORMAL</span>,</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.LIGHT</span>,</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.BOLD</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">underline</span>： 下划线，如果是<span class="selector-tag">True</span>就是有</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">faceName</span>： 指定字体名字</span><br></pre></td></tr></table></figure></div><p>最后使用SetFont方法添加</p><h1 id="TextCtrl-文本框"><a href="#TextCtrl-文本框" class="headerlink" title="TextCtrl 文本框"></a>TextCtrl 文本框</h1><p>创建： wx.TextCtrl(parent, id, value, pos, size, style)</p><p>value是起始文本</p><p>style参数：</p><ul><li>wx.TE_MULTILINE。允许文本框多行</li><li>wx.TE_PASSWORD。 输入变成星号，相当于密码框</li><li>wx.TE_READONLY. 只读</li><li>wx.TE_LEFT</li><li>wx.TE_RIGHT</li><li>wx.TE_CENTER</li><li>wx.HSCROLL: 纵向滚动条</li><li>wx.VSVROLL: 横向滚动条</li></ul><p>wx.TextAttr(colText, colBack=wx.NullColor, font=wx.NullFont) : 分别是 分别为字体颜色，背景色，字体。文本色和背景色为wxPython对象，可由颜色名或颜色的RGB值（红，绿，蓝）来 指定</p><p>绑定事件：EVT_TEXT(改变文本框内容时），EVT_TEXT_ENTER(按下enter键时），EVT_TEXT_MAXLEN（当文本长度达到SetMaxLength()设定的长度时）</p><h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><p>button是最普通的按钮，BitmapButton是用图片做按钮，ToggleButton有两种状态：按下和弹起。</p><p>button和ToggleButton的构造函数的参数都相同：<code>Wx.Button(parent, id, label, pos, size, style)。</code></p><p>其中label是显示在button上的文本。wx.BU_EXACTFIT是跨平台标记，使用了它就不会用系统默认的的尺寸作为最小尺寸，可以使用wx.BU_LEFT等标记设置对齐</p><p>BitmapButton的构造函数：</p><ul><li>Wx.Bitmap(fiiename, wx.BITMAP_TYPE)</li><li>Wx.BitmapButton(parent, id, bitmap, pos, size, style)</li></ul><p>BitmapButton有一些预定义的图片类型常量：</p><ul><li>wx.BITMAP_TYPE_BMP</li><li>wx.BITMAP_TYPE_ICO</li><li>wx.BITMAP_TYPE_CUR</li><li>wx.BITMAP_TYPE_TIFF</li><li>wx.BITMAP_TYPE_TIF</li><li>wx.BITMAP_TYPE_GIF</li><li>wx.BITMAP_TYPE_PNG</li><li>wx.BITMAP_TYPE_JPEG</li><li>wx.BITMAP_TYPE_PCX</li><li>wx.BITMAP_TYPE_ICON</li><li>wx.BITMAP_TYPE_ANY</li></ul><p>方法：</p><ul><li><p>SetLabel()： 设置标题</p></li><li><p>GetLabel()</p></li><li><p>SetDefault()： 按钮设置为默认顶层窗口。模拟click事件按下回车键</p></li><li><p>GetValue()： 这是ToggleButton的，获得按钮的状态。此外还有SetValue</p></li></ul><p>Button的事件是EVT_BUTTON</p><h2 id="RadioButton-amp-RadioBox"><a href="#RadioButton-amp-RadioBox" class="headerlink" title="RadioButton &amp; RadioBox"></a>RadioButton &amp; RadioBox</h2><p>每个RadioButton会显示一个圆形的框。一般是用它做一组按钮，同一时刻只能选择其中一个。</p><p>如果想要多个选项中选择一个选项，首先需要把样式设置成wx.RB_GROUP。</p><p>RadioBox提供了边框和标签组.</p><p>构造函数： RadioButton(parent, id, label, pos, size, style)</p><p>style参数仅用于该组中的第一个按钮。它的值是wx.RB_GROUP。对于组中的随后的按钮，wx.RB_SINGLE的style 参数可以任选地使用。</p><p>事件： wx.EVT_RADIOBUTTON</p><p>RadioBox构造函数：<code>RadioBox(parent, id, label, pos, size, choices[], initialdimensions, style)</code></p><ul><li>style: wx.RA_SPECIFY_ROWS或wx.RA_SPECIFY_COLS</li><li>initialdimensions: 最初的行\列数</li><li>choices[]: 按钮名列表</li><li>label也可以是一个图片</li></ul><p>RadioBox的方法：</p><ul><li>GetSelection()： 返回所选项目的索引</li><li>SetSelection()： 选择编程项目</li><li>GetString(): 获得所选项的标签</li><li>Show(): 显示或隐藏指定标签</li></ul><p>事件： wx.EVT_RADIOBOX。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="NIX"><figure class="iseeu highlight /nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="attr">rb1</span> = wx.RadioButton(pnl,<span class="number">11</span>, <span class="attr">label</span> = 'Value A', <span class="attr">pos</span> = (<span class="number">10</span>,<span class="number">10</span>), <span class="attr">style</span> = wx.RB_GROUP) </span><br><span class="line">self.<span class="attr">rb2</span> = wx.RadioButton(pnl,<span class="number">22</span>, <span class="attr">label</span> = 'Value B',<span class="attr">pos</span> = (<span class="number">10</span>,<span class="number">40</span>)) </span><br><span class="line">self.<span class="attr">rb3</span> = wx.RadioButton(pnl,<span class="number">33</span>, <span class="attr">label</span> = 'Value C',<span class="attr">pos</span> = (<span class="number">10</span>,<span class="number">70</span>))</span><br><span class="line"></span><br><span class="line">RadioBox</span><br><span class="line"></span><br><span class="line"><span class="attr">lblList</span> = ['Value X', 'Value Y', 'Value Z']     </span><br><span class="line">self.<span class="attr">rbox</span> = wx.RadioBox(pnl,<span class="attr">label</span> = 'RadioBox', <span class="attr">pos</span> = (<span class="number">80</span>,<span class="number">10</span>), <span class="attr">choices</span> = lblList ,<span class="attr">majorDimension</span> = <span class="number">1</span>, <span class="attr">style</span> = wx.RA_SPECIFY_ROWS)</span><br></pre></td></tr></table></figure></div><h1 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h1><p><img src="/images/wxpython7.PNG" alt></p><p>上图就是复选框，复选框可以有多个，允许用户多选</p><p>构造函数： Wx.CheckBox(parent, id, label, pos, size, style)</p><p>style有：</p><ul><li>wx.CHK_2STATE： 有两种选择，选或不选，这也是默认选项。</li><li>wx.CHK_3STATE： 三态复选框，第三状态称为混合或不确定的状态，一般用在“不适用”情景。</li><li>wx.ALIGN_RIGHT： 把名字放在左边，复选框放在右边</li></ul><p>方法：</p><ul><li>GetState()返回true或false</li><li>GetLabel()</li></ul><h1 id="ComboBox-amp-Choice"><a href="#ComboBox-amp-Choice" class="headerlink" title="ComboBox &amp; Choice"></a>ComboBox &amp; Choice</h1><p>ComboBox是一个下拉列表或者也可以永久显示。Choice也是下拉列表，但是只能只读。</p><p>构造方法： ComboBox(parent, id, value, pos, size, choices[], style)：choices是要填充进下拉列表的文本。value是最开始在框中显示的文本</p><p>style参数：</p><ul><li>wx.CB_SIMPLE: 组合框和永久显示的列表</li><li>wx.CB_DROPDOWN: 组合框和永久显示的列表</li><li>wx.CB_READONLY： 只读</li><li>wx.CB_SORT： 按字母排序</li></ul><p>方法：</p><ul><li>GetCurrentSelection (): 获得当前被选中的项目</li><li>SetSelection(i)： 设置i为被选中状态</li><li>GetString(i): 获得i的字符串</li><li>SetString()</li><li>SetValue()</li><li>FindString()： 搜索列表中字符串</li><li>GetStringSelection()： 获得当前项目选中的文本</li></ul><p>事件：</p><ul><li>wx. COMBOBOX： 当有项目被选择时</li><li>wx. EVT_TEXT： 组合框文本发生变化</li><li>wx. EVT_COMBOBOX_DROPDOWN： 下拉列表时</li><li>wx. EVT_COMBOBOX_CLOSEUP： 列表折叠时</li></ul><h1 id="Gauge-测量仪"><a href="#Gauge-测量仪" class="headerlink" title="Gauge 测量仪"></a>Gauge 测量仪</h1><p>Gauge其实是进度条，有确定模式和不确定模式两种。确定模式即显示百分比</p><p>在确定模式，进度位置会定期更新。在不确定模式，调用 Pulse() 函数将更新进度条。</p><p>构造函数： wx.Gauge(parent, id, range, pos, size, style)： range是表上的最大值，如果是不确定模式忽略此参数。</p><p>style参数：</p><ul><li>wx.GA_HORIZONTAL</li><li>wx.GA_VERTICAL</li><li>wx.GA_SMOOTH： 平滑的进度条，一个像素一个像素的更新</li><li>wx.GA_TEXT： 显示百分比形式</li></ul><p>方法：</p><ul><li>GetRange(): 获得进度条的最大值</li><li>SetRange()： 设置进度条的最大值</li><li>GetValue()</li><li>Pulse(): 切换成不确定模式</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import wx</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_frame</span>(<span class="title">wx</span>.<span class="title">Frame</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">super</span>().__init_<span class="number">_</span>(parent=None, title=<span class="string">"差评原因"</span>, size=(<span class="number">1000</span>, <span class="number">600</span>))</span><br><span class="line">        <span class="keyword">self</span>.Centre()</span><br><span class="line">        panel = wx.Panel(parent=<span class="keyword">self</span>)</span><br><span class="line">        value = [<span class="string">'choice1'</span>, <span class="string">'choice2'</span>, <span class="string">'choice3'</span>]</span><br><span class="line">        <span class="keyword">self</span>.gauge = wx.Gauge(panel, range=<span class="number">20</span>, style=wx.GA_HORIZONTAL)</span><br><span class="line">        button = wx.Button(panel, label=<span class="string">'开始'</span>)</span><br><span class="line">        <span class="keyword">self</span>.Bind(wx.EVT_BUTTON, <span class="keyword">self</span>.Onstart, button)</span><br><span class="line"></span><br><span class="line">        sizer = wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        sizer.Add(<span class="keyword">self</span>.gauge)</span><br><span class="line">        sizer.Add(button)</span><br><span class="line">        panel.SetSizer(sizer)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Onstart</span><span class="params">(<span class="keyword">self</span>, e)</span></span><span class="symbol">:</span></span><br><span class="line">        value = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)<span class="symbol">:</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            value += <span class="number">1</span></span><br><span class="line">            <span class="keyword">self</span>.gauge.SetValue(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">app</span>(<span class="title">wx</span>.<span class="title">App</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">OnInit</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        frame = my_frame()</span><br><span class="line">        frame.Show()</span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">OnExit</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">"退出"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    app = app()</span><br><span class="line">    app.MainLoop()</span><br></pre></td></tr></table></figure></div><p><img src="/images/wxpython8.PNG" alt></p><h1 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h1><p>Slider是一个滑块</p><p>构造函数： wx.Slider(parent, id, value, minValue, maxValue, pos, size, style) :</p><p>style参数：</p><ul><li>wx.SL_HORIZONTAL</li><li>wx.SL_VERTICAL</li><li>wx.SL_AUTOTICKS: 自动显示刻度线</li><li>wx.SL_LABELS: 显示最大值，最小值和当前值</li><li>wx.SL_MIN_MAX_LABELS: 只显示最大值和最小值</li><li>wx.SL_VALUE_LABEL： 只显示当前值</li></ul><p>方法：</p><ul><li>上面参数的set和get方法</li><li>SetTick()： 在给定位置显示刻度线</li><li>SetTickFreq()： 显示最大刻度和最小刻度之间的刻度间隔</li></ul><p>事件：</p><ul><li>wx.EVT_SCROLL： 因为他类似于滚动条，所以绑定滚动事件也可以发挥作用</li><li>wx.EVT_SLIDER: 刻度条位置发生变化时</li></ul><h1 id="MenuItem-Menu-amp-MenuBar-菜单栏"><a href="#MenuItem-Menu-amp-MenuBar-菜单栏" class="headerlink" title="MenuItem, Menu &amp; MenuBar 菜单栏"></a>MenuItem, Menu &amp; MenuBar 菜单栏</h1><p>菜单栏就是应用程序最顶端显示的一些菜单。</p><p>MenuBar是创建一个菜单栏，然后Menu就是菜单栏上的菜单，MeunItem是菜单中的一个个选项</p><p>ManuBar构造函数： wx.MenuBar(n, menus, titles, style) ： n是菜单数量，menus是标题的字符串，style只有wx.MB_DOCKABLE，菜单栏可以停靠。</p><p>设置完后可以用frame.SetMenuBar()把菜单加进去</p><p>方法：</p><ul><li>Append()： 添加菜单到菜单栏</li><li>Check()： 选中菜单</li><li>Enable()</li><li>Remove()</li></ul><p>Menu一般使用空的构造方法</p><p>Menu的方法；</p><ul><li><p>Append(menu, title)： 添加一个菜单项,title是菜单的名字。</p></li><li><p>AppendMenu()： 添加一个子菜单</p></li><li><p>AppendRadioItem()： 追加可选当前项</p></li><li><p>AppendCheckItem()： 追加可检查当前项</p></li><li><p>AppendSeparator()： 添加分割线</p></li><li><p>Insert()： 在指定位置插入一个新菜单。后面还有几个Insert和上面一样</p></li><li><p>GetMenuItems() ： 返回菜单项列表</p></li><li><p>Remove()</p></li><li><p>wx.MenuItem.SetBitmap(wx.Bitmap(image file))： 设置图像</p></li></ul><p>MenuItem构造函数： wx.MenuItem(parentMenu, id, text, kind)：text是菜单项的名字</p><ul><li>kind是菜单项的类型，有wx.ITEM_NORMAL(普通菜单项,相当于Button),wx.ITEM_CHECK（检查菜单项，相当于ToggleButton), wx.ITEM_RADIO(单选菜单项,相当于RadioButton）</li></ul><p>如果想要添加快捷键，使用text参数。<code>text = &quot;名称/t快捷键&quot;</code>.例如text = “Quit/tCtrl+Q”这样为名称是Quit的菜单项注册了Ctrl+Q的快捷键</p><p>菜单项有一系列标准ID： wx.ID_SEPARATOR，wx.ID_ANY，wx.ID_OPEN，wx.ID_CLOSE，wx.ID_NEW，wx.ID_SAVE，wx.ID_SAVEAS，wx.ID_EDIT，wx.ID_CUT，wx.ID_COPY，wx.ID_PASTE</p><p>事件： EVT_MENU。然后可以使用e.GetId()的方法得知选了哪个菜单项</p><h1 id="ToolBar"><a href="#ToolBar" class="headerlink" title="ToolBar"></a>ToolBar</h1><p>工具栏包括文本文字说明或图标按钮的一个或多个水平条，通常放在MenuBar下面。</p><p>构造函数： Wx.ToolBar(parent, id, pos, size, style)：</p><p>style:</p><ul><li>wx.TB_FLAT: 平面效果</li><li>wx.TB_HORIZONTAL</li><li>wx.TB_VERTICAL</li><li>wx.TB_DEFAULT_STYLE: 综合FLAT和HORIZONAL</li><li>wx.TB_DOCKABLE： 使工具栏可以浮动和停靠</li><li>wx.TB_NO_TOOLTIPS ： 不显示提示</li><li>wx.TB_NOICONS： 没有图标</li><li>wx.TB_TEXT： 显示文本，默认情况下只有图标</li></ul><p>函数：</p><ul><li>AddTool(parent, id, bitmap)： 添加工具到工具栏</li><li>AddRadioTool()： 添加Radio组，即这些选项中只能选择一个</li><li>AddCheckTool()： 添加复选框</li><li>AddLabelTool()： 添加标签</li><li>AddSeparator()： 添加分隔符</li><li>AddControl()： 添加其他组件。例如Button ComboBox等</li><li>ClearTools()： 删除所有在工具栏中的按钮</li><li>RemoveTool()： 删除组件</li><li>Realize()： 增加调用，最后必须要写</li></ul><p>事件： EVT_TOOL。这个事件只负责传递，具体实现还需要GetId然后判断ID进行处理。</p><p>注意，如果是通过AddControl加进来的方法不能通过EVT_TOOL响应，必须要通过他们自己的事件进行响应。</p><h1 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h1><p>Dialog就是平常弹出的对话框，如程序崩溃时发出的警告消息等。</p><p>wxpython中预定义了一些Dialog。如：MessageDialog，FileDialog，FontDialog类等。</p><p>构造函数：wx.Dialog(parent, id, title, pos, size, style)</p><p>style：</p><ul><li>wx.CAPTION： 对话框的文字说明</li><li>wx.DEFAULT_DIALOG_STYLE；相当于wx.CAPTION，wx.CLOSE_BOX和wx.SYSTEM_MENU的组合</li><li>wx.RESIZE_BORDER: 显示可调框架窗口大小</li><li>wx.SYSTEM_MENU: 显示系统菜单</li><li>wx.CLOSE_BOX： 显示关闭</li><li>wx.MAXIMIZE_BOX： 显示最大化菜单</li><li>wx.MINIMIZE_BOX</li><li>wx.STAY_ON_TOP: 该窗口显示在所有窗口顶部</li><li>wx.DIALOG_NO_PARENT</li></ul><p>事件：</p><ul><li>EVT_CLOSE： 关闭时产生</li><li>EVT_INIT_DIALOG： 初始化时产生</li></ul><p>函数：</p><ul><li>DoOK()： 当按下ok键时调用</li><li>ShowModal()： 显示了在应用程序模态方式的对话框</li><li>ShowWindowModal()： 对话框显示在顶层父窗口的模式</li><li>EndModal()： ShowModal调用传递值结束一个对话框模式</li></ul><h2 id="MessageDialog"><a href="#MessageDialog" class="headerlink" title="MessageDialog"></a>MessageDialog</h2><p>构造函数： wx.MessageDialog(parent, message, caption, style, pos) :caption是标题</p><p>style:</p><ul><li>wx.OK： 有是否两个选项，用了这个就不能用YES_NO或YES</li><li>wx.CANCEL</li><li>wx.YES_NO: 有是否取消三个选项。</li><li>WX.YES_DEFAULT: 使yes按钮为默认</li><li>wx.NO_DEFAULT</li><li>wx.ICON_EXCLAMATION： 显示警告图标</li><li>wx.ICON_ERROR</li><li>wx.ICON_INFORMATION： 显示一个信息图标</li><li>wx.ICON_QUESTION</li></ul><p>还有一种简便形式是MessageBox,直接就可以展示，不需要Show。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = wx.<span class="constructor">MessageDialog(<span class="params">self</span>.<span class="params">panel</span>, <span class="string">"消息"</span>, <span class="string">"标题"</span>, <span class="params">style</span>=<span class="params">wx</span>.OK | <span class="params">wx</span>.CANCEL | <span class="params">wx</span>.ICON_ERROR)</span>.<span class="constructor">ShowModal()</span></span><br><span class="line"></span><br><span class="line">wx.<span class="constructor">MessageBox(<span class="string">"消息"</span>, '标题', <span class="params">style</span>=<span class="params">wx</span>.OK | <span class="params">wx</span>.CANCEL | <span class="params">wx</span>.ICON_ERROR)</span></span><br></pre></td></tr></table></figure></div><p><img src="/images/wxpython9.PNG" alt></p><h2 id="TextEntryDialog"><a href="#TextEntryDialog" class="headerlink" title="TextEntryDialog"></a>TextEntryDialog</h2><p>这个类的对象显示一个文本字段，可定制的标签，提示用户输入以及两个按钮使用预定义样式的对话框。里面的文本框是TextCtrl，所以Style可以使用TextCtrl的</p><p>构造函数： wx.TextEntryDialog(parent, id, message, caption, value, style, pos) ： value是默认字符串。</p><p>方法：</p><ul><li>SetMaxLength()： 设置文本输入最大长度</li><li>SetValue()</li><li>GetValue()： 返回文本框中的内容</li><li>ShowModal()： 返回 wx.ID_OK 如果用户确认输入，以及 wx.ID_CANCEL 如果对话框被拒绝</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = wx.TextEntryDialog(self.panel, <span class="attribute">message</span>=<span class="string">'看一看'</span>, <span class="attribute">caption</span>=<span class="string">'标题'</span>)</span><br><span class="line">a.SetMaxLength(20)</span><br><span class="line"><span class="keyword">if</span>(a.ShowModal() == wx.ID_OK):</span><br><span class="line">    <span class="builtin-name">print</span>(a.GetValue())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'nothing'</span>)</span><br></pre></td></tr></table></figure></div><p><img src="/images/wxpython10.PNG" alt></p><h2 id="FileDialog"><a href="#FileDialog" class="headerlink" title="FileDialog"></a>FileDialog</h2><p>此类表示一个文件选择对话框。它使用户可以浏览文件系统并选择要打开文件或保存.文件滤波器也可以应用到只显示指定扩展名的文件。启动目录和默认的文件名也可以设置。</p><p>构造函数： wx.FileDialog(parent, message, DefaultDir, DefaultFile, wildcard, style, pos, size) ： DefaultDir是默认目录， DefaultFile是默认选择文件.wildcard是筛选器，可以使用正则表达式</p><p>style参数：</p><ul><li>wx.FD_DEFAULT_STYLE： 相当于wx.FD_OPEN</li><li>wx.FD_OPEN： 打开对话框，默认标题是打开</li><li>wx.FD_SAVE</li><li>wx.FD_OVERWRITE_PROMPT： 保存对话框，如果一个文件被覆盖时会提示</li><li>wx.FD_MULTIPLE： 允许选择多个文件</li><li>wx.FD_CHANGE_DIR： 更改当前工作目录到用户选择的文件目录</li></ul><p>方法：</p><ul><li>GetDirectory()： 返回默认目录</li><li>GetFileName()： 返回默认文件名</li><li>GetPath()： 获得选定文件的完整目录</li><li>SetDirectory()</li><li>SetFileName()</li><li>SetPath()</li><li>ShowModal(): 如果用户单击OK按钮返回wx.ID_OK，否则 wx.ID_CANCEL</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filesFilter = <span class="string">"txt(*.txt) | *.txt|"</span> <span class="string">"All files (*.*)|*.*"</span></span><br><span class="line">        a = wx.<span class="constructor">FileDialog(<span class="params">self</span>.<span class="params">panel</span>, '看一看', 'C:<span class="operator">/</span>', 'C:<span class="operator">/</span>Program Files', <span class="params">filesFilter</span>, <span class="params">wx</span>.FD_OPEN)</span></span><br><span class="line">        <span class="keyword">if</span>(a.<span class="constructor">ShowModal()</span><span class="operator"> == </span>wx.ID_OK):</span><br><span class="line">            <span class="keyword">with</span> <span class="keyword">open</span>(a.<span class="constructor">GetPath()</span>, <span class="character">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                self.text.<span class="constructor">SetValue(<span class="params">f</span>.<span class="params">read</span>()</span>)</span><br><span class="line">        a.<span class="constructor">Destroy()</span></span><br></pre></td></tr></table></figure></div><p><img src="/images/wxpython12.PNG" alt></p><h1 id="FontDialog"><a href="#FontDialog" class="headerlink" title="FontDialog"></a>FontDialog</h1><p>这个类的对象是一个字体选择对话框,所选字体的形式返回作为此对话框的返回值。</p><p>构造函数：wx.FontDialog(parent, data)： data一般使用wx.FontData()</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = wx.<span class="constructor">FontDialog(<span class="params">self</span>, <span class="params">wx</span>.FontData()</span>)</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="constructor">ShowModal()</span><span class="operator"> == </span>wx.ID_OK):</span><br><span class="line">            data = a.<span class="constructor">GetFontData()</span></span><br><span class="line">            font = data.<span class="constructor">GetChosenFont()</span></span><br><span class="line">            self.text.<span class="constructor">SetFont(<span class="params">font</span>)</span></span><br></pre></td></tr></table></figure></div><p><img src="/images/wxpython13.PNG" alt></p><h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><h2 id="SplitterWindow"><a href="#SplitterWindow" class="headerlink" title="SplitterWindow"></a>SplitterWindow</h2><p>这个类的对象是一个布局管理器，它拥有两个子窗口的大小可以通过拖动它们之间的界限来动态变化。Splitter控件给出了句柄来拖动调整控件。</p><p>构造函数： wx.SplitterWindow(self, id, pos, size, style)</p><p>style：</p><ul><li>wx.SP_3D： 绘制3D效果的边框和窗扇(sash)</li><li>wx.SP_THIN_SASH： 绘制一个薄的sash</li><li>wx.SP_3DSASH: 绘制3D效果的sash</li><li>wx.SP_BORDER: 绘制标准边框</li><li>wx.SP_NOBORDER： 无边框（默认）</li><li>wx.SP_PERMIT_UNSPLIT: 总是允许取消分割，即使采用最小的窗格大小不为零</li></ul><p>方法：</p><ul><li>SplitVertically(panel1, panel2): 设置左右面板，这两个面板的父亲必须是该splitterwindow</li></ul><p>事件：</p><ul><li>EVT_SPLITTER_SASH_POS_CHANGING()： sash位置改变时</li><li>EVT_SPLITTER_SASH_POS_CHANGED()： 窗框位置改变时</li><li>EVT_SPLITTER_UNSPLIT()： 一直取消分割</li><li>EVT_SPLITTER_DCLICK()： 窗框被双点击。默认行为是在取消分割窗口出现这种情况时</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import wx</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my<span class="constructor">_frame(<span class="params">wx</span>.Frame)</span>:</span><br><span class="line">    def <span class="constructor">__init__(<span class="params">self</span>)</span>:</span><br><span class="line">        super<span class="literal">()</span>.<span class="constructor">__init__(<span class="params">parent</span>=None, <span class="params">title</span>=<span class="string">"差评原因"</span>, <span class="params">size</span>=(1000, 600)</span>)</span><br><span class="line">        split = wx.<span class="constructor">SplitterWindow(<span class="params">self</span>, <span class="params">style</span>=<span class="params">wx</span>.SP_3D)</span></span><br><span class="line">        self.<span class="constructor">Centre()</span></span><br><span class="line">        self.panel = wx.<span class="constructor">Panel(<span class="params">parent</span>=<span class="params">split</span>)</span></span><br><span class="line">        value = <span class="literal">['<span class="identifier">choice1</span>', '<span class="identifier">choice2</span>', '<span class="identifier">choice3</span>']</span></span><br><span class="line"></span><br><span class="line">        panel2 = wx.<span class="constructor">Panel(<span class="params">split</span>)</span></span><br><span class="line"></span><br><span class="line">        button = wx.<span class="constructor">Button(<span class="params">self</span>.<span class="params">panel</span>, <span class="params">label</span>='按钮')</span></span><br><span class="line">        self.text = wx.<span class="constructor">TextCtrl(<span class="params">self</span>.<span class="params">panel</span>, <span class="params">style</span>=<span class="params">wx</span>.TE_MULTILINE)</span></span><br><span class="line">        self.text.<span class="constructor">SetEditable(False)</span></span><br><span class="line">        self.<span class="constructor">Bind(<span class="params">wx</span>.EVT_BUTTON, <span class="params">self</span>.Onstart, <span class="params">button</span>)</span></span><br><span class="line">        sizer = wx.<span class="constructor">BoxSizer(<span class="params">wx</span>.VERTICAL)</span></span><br><span class="line">        sizer.<span class="constructor">Add(<span class="params">button</span>, <span class="params">flag</span>=<span class="params">wx</span>.ALIGN_CENTER)</span></span><br><span class="line">        sizer.<span class="constructor">Add(<span class="params">self</span>.<span class="params">text</span>, <span class="params">border</span>=20, <span class="params">proportion</span>=1, <span class="params">flag</span>=<span class="params">wx</span>.ALL | <span class="params">wx</span>.EXPAND)</span></span><br><span class="line"></span><br><span class="line">        sizer2 = wx.<span class="constructor">BoxSizer(<span class="params">wx</span>.VERTICAL)</span></span><br><span class="line">        sizer2.<span class="constructor">Add(<span class="params">wx</span>.ListBox(<span class="params">panel2</span>, <span class="params">style</span>=<span class="params">wx</span>.LB_SINGLE)</span>, flag=wx.EXPAND, proportion=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.panel.<span class="constructor">SetSizer(<span class="params">sizer</span>)</span></span><br><span class="line">        panel2.<span class="constructor">SetSizer(<span class="params">sizer2</span>)</span></span><br><span class="line">        split.<span class="constructor">SplitVertically(<span class="params">panel2</span>, <span class="params">self</span>.<span class="params">panel</span>)</span></span><br><span class="line">    def <span class="constructor">Onstart(<span class="params">self</span>, <span class="params">e</span>)</span>:</span><br><span class="line">        a = wx.<span class="constructor">FontDialog(<span class="params">self</span>, <span class="params">wx</span>.FontData()</span>)</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="constructor">ShowModal()</span><span class="operator"> == </span>wx.ID_OK):</span><br><span class="line">            data = a.<span class="constructor">GetFontData()</span></span><br><span class="line">            font = data.<span class="constructor">GetChosenFont()</span></span><br><span class="line">            self.text.<span class="constructor">SetFont(<span class="params">font</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> app(wx.App):</span><br><span class="line">    def <span class="constructor">OnInit(<span class="params">self</span>)</span>:</span><br><span class="line">        frame = my<span class="constructor">_frame()</span></span><br><span class="line">        frame.<span class="constructor">Show()</span></span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def <span class="constructor">OnExit(<span class="params">self</span>)</span>:</span><br><span class="line">        print(<span class="string">"退出"</span>)</span><br><span class="line">        return <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__<span class="operator"> == </span>'__main__':</span><br><span class="line">    app = app<span class="literal">()</span></span><br><span class="line">    app.<span class="constructor">MainLoop()</span></span><br></pre></td></tr></table></figure></div><p><img src="/images/wxpython14.PNG" alt></p><h2 id="HtmlWindow"><a href="#HtmlWindow" class="headerlink" title="HtmlWindow"></a>HtmlWindow</h2><p>wx.HtmlWindow对象是一个通用的HTML浏览器。他是在html1库中的。</p><p>构造函数： wx.htmll.HtmlWindow(Parent, id, pos, size, style)</p><p>样式：</p><ul><li>wx.HW_SCROLLBAR_NEVER: 永运不显示进度条</li><li>wx.HW_SCROLLBAR_AUTO： 只有在窗口放不下时才显示进度条</li><li>wx.HW_NO_SELECTION： 不让用户选择文本</li></ul><p>事件：</p><ul><li>EVT_HTML_CELL_CLICKED： 当一个wx.HtmlCell被点击</li><li>EVT_HTML_CELL_HOVER： 经过一个HtmlCell</li><li>EVT_HTML_LINK_CLICKED: 一个超链接被点击</li></ul><p>方法；</p><ul><li>AppendToPage()： Html追加到当前显示的文本，并刷新</li><li>HistoryBack()： 回到以前访问过的网页</li><li>HistoryForward()： 转到历史的下一页</li><li>LoadPage()： 加载一个Html文件</li><li>OnLinkClicked()： 超链接被点击时调用</li><li>SetPage()： 设置标记HTML的标签，文字作为页面内容</li></ul><h1 id="可停靠窗口"><a href="#可停靠窗口" class="headerlink" title="可停靠窗口"></a>可停靠窗口</h1><p>大致过程：</p><ol><li>创建一个AuiManager对象。<code>self.mgr = wx.aui.AuiManager(self)</code></li><li>创建面板和里面的控件。</li><li>创建AuiPanelInfo. <code>info1 = wx.aui.AuiPaneInfo().Bottom()</code></li><li>把设计的面板添加到管理器。 <code>self.mgr.AddPane(pnl,info1)</code></li></ol><p>AuiPaneInfo参数：</p><ul><li>方向： Top, Bottom, Left, Right, 或 Center</li><li>位置： 多个窗格中可以放置一个可停靠的区域内。每个被赋予位置编号。</li><li>行： 多个窗格中显示在一排。就像一个以上的工具栏出现在同一行中。</li><li>层： 窗格可以放置在层中</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 16 2020 08:49:38 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;事件处理&quot;&gt;&lt;a href=&quot;#事件处理&quot; class=&quot;headerlink&quot; title=&quot;事件处理&quot;&gt;&lt;/a&gt;事件处理&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://xinhecuican.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 爬取</title>
    <link href="http://xinhecuican.github.io/post/3de4bc69.html"/>
    <id>http://xinhecuican.github.io/post/3de4bc69.html</id>
    <published>2020-07-01T12:16:00.000Z</published>
    <updated>2020-07-16T01:39:49.486Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 17 2020 10:39:11 GMT+0800 (中国标准时间) --><h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1><p>requests用来爬取网站上的信息。有七个主要方法</p><ul><li>r = requests.get(url， params， ** kwargs): url是你想爬取网站的url。通过get构造了一个向服务器请求资源的Request对象。返回一个包含服务器资源的Response对象。</li><li>head(): 获取网页头部信息</li><li>post(url, data, json, kwargs): 在后面添加数据。默认如果是列表等会存储到form字段下，如果是字符串会存在data字段下</li><li>put(): 覆盖网页某一字段数据。例如上传字符串会把data字段覆盖</li><li>patch(): 删改某一位置信息（和put的区别是put必须全部删除，patch只需要修改需要改的部分）</li><li>delete(): 删除url处的资源</li><li>request(method, url, ** kwargs): method有七种，分别是’GET’,’OPTIONS’等，注意其中delete是小写。</li></ul><p>kwargs参数（get,put, patch要比request少params，head,delete相同，post11个）：</p><ul><li>params： 输入参数</li></ul><p>例子 <img src="/images/python%E7%88%AC%E5%8F%963.PNG" alt></p><ul><li>data： 提交资源，一般用用字典的形式</li><li>json： 可以作为request的内容</li><li>headers： http头字段</li><li>cookies：</li><li>auth： http认证功能</li><li>files： 传输文件时使用</li><li>timeout： 设定的超时时间</li><li>proxies： 设定访问代理服务器</li><li>allow_redirects: 默认是True。重定向开关</li><li>stream： 是否对获取内容立即下载。默认立即下载</li><li>verify： 认证SSL证书字段</li><li>cert： 保存本地ssl路径字段</li></ul><p>Response对象属性：</p><ul><li>status_code: 200表示成功，404表示失败（不是200就是失败）</li><li>text： 爬取内容的字符串形式。</li><li>encoding： 猜测的编码形式。这是从服务器的charset字段获得的。如果服务器中没有charset字段，那么会返回ISO-8859-1</li><li>apparent_encoding: 备选编码形式.它是根据内容分析的（可能这个更加准确）</li><li>content： 爬取内容的二进制形式</li><li>request: response对应的request对象</li></ul><h2 id="爬取模板"><a href="#爬取模板" class="headerlink" title="爬取模板"></a>爬取模板</h2><p>requests异常种类：<img src="/images/python%E7%88%AC%E5%8F%961.PNG" alt></p><p>模板：<img src="/images/python%E7%88%AC%E5%8F%962.PNG" alt></p><p>有些网页会拒绝爬虫的爬取，这个时候我们可以通过更改头部信息让我们看上去是浏览器爬取。模板为：</p><p><img src="/images/python%E7%88%AC%E5%8F%964.PNG" alt></p><p>想要运用爬虫使用搜索引擎。首先要知道搜索引擎的接口，百度的接口是<code>http://www.baidu.com/s?wd=keyword</code>.360的接口是 <code>http://www.so.com/s?q=keyword</code>。其中keyword就是我们要搜索的内容。所以我们只需要在搜索时让url加上wd或q字段即可。</p><p>模板：<img src="/images/python%E7%88%AC%E5%8F%966.PNG" alt></p><p>获取图片要用二进制读取的方式，模板为<img src="/images/python%E7%88%AC%E5%8F%967.PNG" alt></p><p>ip138是一个用来查询ip内容的网站。它的接口是<code>&quot;http://m.ip138.com/ip.asp?ip=...&quot;</code>于是我们可以通过这个接口去访问ip地址的内容。</p><p>模板：<br><img src="/images/python%E7%88%AC%E5%8F%968.PNG" alt></p><h1 id="beautifulsoup4"><a href="#beautifulsoup4" class="headerlink" title="beautifulsoup4"></a>beautifulsoup4</h1><p>beautifulsoup4可以用来解析html和xml。</p><p>导入： import bs4或from bs4 import Beautifulsoup</p><p>基本元素：</p><ul><li>Tag： 标签，如<code>&lt;&gt;&lt;/&gt;</code></li><li>Name: 标签的名字，如<code>&lt;p&gt;&lt;/p&gt;</code>中的p</li><li>Attribute： 标签属性，如<code>&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt;</code> 中的src和alt。它是一个字典类型，可以用<code>&lt;tag&gt;.attrs</code>访问</li><li>NavigableString: 两个标签之间的字符串。用<code>&lt;tag&gt;.string</code>访问</li><li>Comment： 标签中间字符串的注释</li></ul><p>一些函数：</p><ul><li>prettify(): 在标签之间添加换行符，让html文本易读。</li><li>find_all(name, attrs, recursive, string, ** kwargs); 查找所有标签，返回列表，它有一种简写形式,标签(…)，因为它十分常用。name是标签名字。attrs是对某一属性值的检索（如果某个标签有这个属性返回的还是这个标签）。recursive是是否对所有子孙进行搜索，默认是True。string是检索两个标签之间的字符串。</li><li>find(),find_parents(),find_parent(),find_next_siblings(),find_next_sibling,find_preivous_siblings,find_previous_sibling(): 这些方法的参数和使用方法相同。其中find()只返回第一个结果并且是字符串类型。</li></ul><p>解析器: <img src="/images/python%E7%88%AC%E5%8F%969.PNG" alt></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">"F:/html/test.html"</span>, <span class="keyword">encoding</span>=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    soup = BeautifulSoup(f, <span class="string">"html.parser"</span>) <span class="comment"># soup代指这个文档，算作一种标签</span></span><br></pre></td></tr></table></figure></div><h2 id="标签树的遍历"><a href="#标签树的遍历" class="headerlink" title="标签树的遍历"></a>标签树的遍历</h2><p>任何html文档都可以看成是一个标签树，树的根节点就是</p><html>，因此我们可以从根节点出发得到整个标签树。</html><p></p><p>可以通过soup.html获得html标签。然后标签有如下属性：</p><ul><li>contents。子节点列表。\n也在列表中</li><li>children。子节点迭代类型，用于循环遍历儿子节点</li><li>descendants。包括所有的子孙节点，用于循环遍历</li><li>parent。 父亲标签</li><li>parents。 所有前辈</li><li>next_sibling: 返回html文本顺序的下一个平行标签(也就是父亲节点相同）。navigable_string也在列表中</li><li>previous_sibling： 返回html文本顺序的上一个平行标签</li><li>next_siblings</li><li>previous_siblings</li></ul><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><img src="/images/python%E7%88%AC%E5%8F%9610.PNG" alt><br><img src="/images/python%E7%88%AC%E5%8F%9611.PNG" alt></p><p>例如： 0-99表示 [1-9]?/d</p><p>python使用rowstring类型来表达正则表达式，即r’…’。这种String不会出现转义现象</p><p>函数：</p><ul><li>re.compile(pattern, flags=0): 把正则表达式编译成对象，便于多次使用。形成对象之后就可以使用下面的六个方法，都是相对的少了pattern参数</li></ul><p><img src="/images/python%E7%88%AC%E5%8F%9612.PNG" alt></p><ul><li>search(pattern, string, flags=0): pattern是正则表达式字符串后者原生字符串。因为原生字符串有些字符要转义，比较麻烦。String是要搜寻的文本，flags是控制标记</li><li>match匹配的字符串必须是从字符串开头开始。例如r3，如果我们用match搜寻数字，会返回空，因为数字不是从开头开始的。</li><li>split(pattern, string, maxsplit=0, flags=0): maxsplit是最大分割数，多余的部分将作为最后一个元素输出。split函数会去掉匹配上的部分，然后剩下的部分用一个列表输出，maxsplit就是最多去掉多少个匹配的</li><li>sub(pattern, repl, string, count=0, flags=0): repl是替换字符串，count是替换次数</li></ul><p><img src="/images/python%E7%88%AC%E5%8F%9613.PNG" alt>这是flags常用标记</p><p>match对象的属性：</p><ul><li>string： 待匹配的文本</li><li>re： 匹配时用的正则表达式</li><li>pos： 正则表达式搜索文本的开始位置</li><li>endpos： 结束位置</li></ul><p>match的方法：</p><ul><li>group(0): 获得匹配后的字符串</li><li>start(): 匹配字符串在原来字符串的开始位置</li><li>end(): 结尾位置</li><li>span(): 返回(start(), end())</li></ul><p>如果没有匹配上，会返回一个空指针</p><p>python默认是贪婪匹配，即返回多个匹配结果，例如search返回的就是最长的那个</p><p>如果我们想匹配最短字符串，就需要在匹配多个字符的后面加上一个问号。例如：</p><p><code>*?</code>、<code>+?</code>、<code>??</code>、<code>{m, n}?</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 17 2020 10:39:11 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;requests&quot;&gt;&lt;a href=&quot;#requests&quot; class=&quot;headerlink&quot; title=&quot;requests&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://xinhecuican.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python time random turtle jieba</title>
    <link href="http://xinhecuican.github.io/post/a3a786d6.html"/>
    <id>http://xinhecuican.github.io/post/a3a786d6.html</id>
    <published>2020-06-29T00:45:00.000Z</published>
    <updated>2020-07-19T02:41:02.954Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 19 2020 18:51:47 GMT+0800 (中国标准时间) --><h1 id="time"><a href="#time" class="headerlink" title="time"></a>time</h1><ul><li><p>time(): 输出从1970年1月1日到现在时间时间差（以秒为单位）。可以用来获取程序运行时间。</p></li><li><p>gmtime(): 获取utc时间。返回一个struct_time对象</p></li><li><p>localtime(): 获取本地时间,也是返回struct_time对象</p></li><li><p>ctime(): 获取本地时间的字符串</p></li><li><p>mktime(t): 把struct_time类型的t转化成时间差（从1970到现在）</p></li><li><p>strftime(“%Y-%m-%d %H:%M:%S”, t): 格式化t.例如2020-02-02 01:02:03</p></li><li><p>strptime(timestring, “…”): 将格式为…的timestring转化成struct_time</p></li><li><p>sleep(): 进程睡眠</p></li><li><p>perf_counter(): 用来计时。和time类似，但精度更高</p></li></ul><h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><ul><li>seed(): 初始化随机数种子</li><li>random(): 生成一个0到1的小数</li><li>randint(a, b): 生成a到b的随机整数</li><li>getrandbits(k): 生成一个kbit长的随机整数</li><li>randrange(start, stop, step): 生成一个start到stop步长为step的随机整数</li><li>uniform(a, b): 生成a到b随机小数</li><li>choice(seq): 从列表中随机返回一个元素</li><li>shuffle(seq): 随机排列</li><li>sample(pop, k): 从pop中选出k个数，以列表形式返回</li></ul><h1 id="turtle"><a href="#turtle" class="headerlink" title="turtle"></a>turtle</h1><ul><li><p>setup(width, height, startx, starty)如果width是小数，那么是窗口相对屏幕比例。如果startx是null，则在水平中央</p></li><li><p>forword(x):</p></li><li><p>backword(x)</p></li><li><p>right(x): 向右旋转</p></li><li><p>left(x):</p></li><li><p>setheading(x): 设置角度</p></li><li><p>goto(x, y): 移动到坐标处，原点是0,0。</p></li><li><p>circle(radius, e): 绘制半径是r，角度是e的圆</p></li><li><p>undo(): 取消最后一步动作。</p></li><li><p>speed(x): 设置速度，范围1到10</p></li><li><p>penup(): 提起画笔</p></li><li><p>pendown():</p></li><li><p>pensize():</p></li><li><p>color(): 设置颜色</p></li><li><p>begin_fill(): 开始填充</p></li><li><p>end_fill():</p></li><li><p>filling(): 是否填充。必须要在end_fill前写，如果在fill范围外写一定是false</p></li><li><p>clean(): 清空画的东西，但不改变画笔的位置</p></li><li><p>reset(): 重置</p></li><li><p>screensize(x, y): 设置屏幕长宽，超出屏幕大小的size时会有滚动条。</p></li><li><p>hideturtle(): 去除小箭头</p></li><li><p>showturtle(): 显示箭头</p></li></ul><h1 id="jieba"><a href="#jieba" class="headerlink" title="jieba"></a>jieba</h1><ul><li>lcut(x): 精确模式</li><li>lcut(x, cut_all=True): 全模式，速度快但是划分不精确</li><li>lcut_for_search(x): 饭后适合搜索引擎搜索的词。</li><li>add_word(x): 添加词</li></ul><h1 id="wordcloud"><a href="#wordcloud" class="headerlink" title="wordcloud"></a>wordcloud</h1><p>根据频率来确定大小。默认以空格和,为分隔符。</p><p>函数：</p><ul><li>a = wordcloud.WordCloud(font_path=, width=, height=).generate(text): 其中第二个WordCloud是wordcloud库中的类。</li><li>a.to_file(filename): 把词云输出成文件，filename是文件名。文件类型可以是png，jpg等。</li></ul><p><img src="/images/python_wordcloud.PNG" alt><br>这些是WordCloud的参数</p><p>如果是中文，先要用jieba进行分词。</p><h1 id="pyinstaller"><a href="#pyinstaller" class="headerlink" title="pyinstaller"></a>pyinstaller</h1><p>把源文件转化成exe文件。</p><p>使用： pyinstaller -F 源文件名</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 19 2020 18:51:47 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;time&quot;&gt;&lt;a href=&quot;#time&quot; class=&quot;headerlink&quot; title=&quot;time&quot;&gt;&lt;/a&gt;time&lt;/h1&gt;&lt;ul
      
    
    </summary>
    
    
      <category term="Python" scheme="http://xinhecuican.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>java 图片操作</title>
    <link href="http://xinhecuican.github.io/post/3319ed9a.html"/>
    <id>http://xinhecuican.github.io/post/3319ed9a.html</id>
    <published>2020-06-11T01:12:00.000Z</published>
    <updated>2020-06-11T02:41:29.119Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jun 11 2020 10:41:29 GMT+0800 (中国标准时间) --><h1 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h1><p><strong>通过Toolkit</strong></p><p>可以通过Toolkit工具从本地，网络或内存获取图片</p><ul><li>Image Toolkit.getDefaultToolkit().getImage(String filename)</li><li>Image Toolkit.getDefaultToolkit().getImage(URL url)</li><li>Image Toolkit.getDefaultToolkit().createImage(byte[] imageData)</li></ul><p><strong>通过ImageIO</strong></p><p>方法：</p><ul><li>BufferedImage ImageIO.read(File input)</li><li>ImageIO.read(URL input)</li><li>ImageIO.read(InputStream input)</li></ul><p>一般用这种方法</p><p><strong>ImageIO常用方法</strong></p><ul><li>int getWidth()： 获取图片宽度</li><li>int getHeight()</li><li>int getWidth(ImageObserver observer)</li><li>int getHeight(ImageObserver observer)</li><li>setRGB(int x, int y, int rgb)： 设置图片在(x, y)处像素</li><li>getRGB(int x, int y)： 获取像素</li><li>setRGB(int startX, int startY, int w, int h, int[] rgbArray, int offset, int scansize)：startx,starty是左上角，w和h是宽和高，offset是rgbarray偏移量。scansize是每一行在数组内长度，一般取w。</li><li>int[] getRGB(int startX, int startY, int w, int h, int[] rgbArray, int offset, int scansize)</li><li>BufferedImage getSubimage (int x, int y, int w, int h)： 剪裁图片</li><li>Image getScaledInstance(int width, int height, int hints)：图片缩放，生成的是Image，如果想变成BufferedImage，可以创建一个同样大小的BufferedImage，然后绘制进去。hints是缩放算法，取值如下：<ul><li>SCALE_AREA_AVERAGING: 使用 Area Averaging 图像缩放算法;</li><li>SCALE_DEFAULT: 使用默认的图像缩放算法;</li><li>SCALE_FAST: 选择一种图像缩放算法，在这种缩放算法中，缩放速度比缩放平滑度具有更高的优先级;</li><li>SCALE_REPLICATE: 使用 ReplicateScaleFilter 类中包含的图像缩放 算法;</li><li>SCALE_SMOOTH: 选择图像平滑度比缩放速度具有更高优先级的图像缩放算法。</li></ul></li></ul><p>在图片上绘制文字等</p><ul><li>Graphics2D createGraphics()： 创建绘制图片的画布</li><li>Graphics getGraphics()： 获得画布</li></ul><h1 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h1><ul><li>ImageIO.write(RenderedImage im, String formatName, File output)：RenderedImage可以是BufferedImage，format是图片格式，例如”jpg”等。output是输出文件</li><li>ImageIO.write(RenderedImage im, String formatName, OutputStream output)：这里的output是输出位置，可以输出到内存或文件中。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span><br><span class="line">        <span class="comment">// 获取屏幕尺寸</span></span><br><span class="line">        Dimension screenSize = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.get<span class="constructor">ScreenSize()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建需要截取的矩形区域</span></span><br><span class="line">        Rectangle rect = <span class="keyword">new</span> <span class="constructor">Rectangle(0, 0, <span class="params">screenSize</span>.<span class="params">width</span>, <span class="params">screenSize</span>.<span class="params">height</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截屏操作</span></span><br><span class="line">        BufferedImage bufImage = <span class="keyword">new</span> <span class="constructor">Robot()</span>.create<span class="constructor">ScreenCapture(<span class="params">rect</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存截取的图片</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>write(bufImage, <span class="string">"PNG"</span>, <span class="keyword">new</span> <span class="constructor">File(<span class="string">"capture.png"</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jun 11 2020 10:41:29 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;读取图片&quot;&gt;&lt;a href=&quot;#读取图片&quot; class=&quot;headerlink&quot; title=&quot;读取图片&quot;&gt;&lt;/a&gt;读取图片&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>swing JTree</title>
    <link href="http://xinhecuican.github.io/post/455a4c92.html"/>
    <id>http://xinhecuican.github.io/post/455a4c92.html</id>
    <published>2020-06-09T03:04:00.000Z</published>
    <updated>2020-06-10T02:50:49.321Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jun 10 2020 14:55:31 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>树图形就像文件目录。由TreeNode表示节点，用TreePath表示这个节点的路径。</p><p>创建时，先创建根节点，然后创建子节点连接，类似于树的链式表示。</p><p>TreeNode 是一个接口，创建节点对象时，通常使用已实现该接口的的 DefaultMutableTreeNode 类。</p><h1 id="DefaultMutableTreeNode"><a href="#DefaultMutableTreeNode" class="headerlink" title="DefaultMutableTreeNode"></a>DefaultMutableTreeNode</h1><p>表示一个节点，可以进行增查改删等操作。</p><p>构造方法：</p><ul><li>DefaultMutableTreeNode(Object userObject, boolean allowsChildren)：userObject是用户对象（节点名称），allowsChildren是是否允许拥有子节点</li></ul><p>方法：</p><ul><li>add()： 添加子节点</li><li>insert(MutableTreeNode newChild, int childIndex) ： 在指定位置插入子节点</li><li>getPreviousSibling()： 获得这个节点的前一个兄弟节点</li><li>getNextSibling()</li><li>getFirstChild()</li><li></li><li>remove(int childIndex)： 移除子节点</li><li>remove(MutableTreeNode aChild);</li><li>removeAll()</li><li>getChildCount()：获得子节点数量</li><li>getLeafCount()： 获得叶子结点数量</li><li>TreeNode getChildAt(int index)： 获取指定位置子节点</li><li>TreeNode getChildAfter(TreeNode aChild)： 获取子节点之后子节点</li><li>TreeNode getChildBefore(TreeNode aChild)</li><li>boolean isNodeChild(TreeNode aNode)： 判断是否是aNode是否是这个节点子节点</li><li>TreeNode getParent()： 获得父节点，没有返回null</li><li>boolean isRoot()： 是否是根节点</li><li>boolean isLeaf()</li><li>int getLevel()： 返回这个节点的层数，如果是根节点就是0</li><li>TreeNode[] getPath()： 返回从根结点到这个节点的路径，第一个节点是根节点</li><li>Enumeration children()： 遍历子节点（不包括孙子节点）</li><li>Enumeration breadthFirstEnumeration()： 遍历树（广度遍历）</li><li>Enumeration depthFirstEnumeration()： 深度遍历</li><li>setUserObject(Object userObject)</li><li>Object getUserObject(): 获得节点名称</li></ul><h1 id="TreePath"><a href="#TreePath" class="headerlink" title="TreePath"></a>TreePath</h1><p>一般使用方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode[] pathNodes = <span class="keyword">node</span>.<span class="title">getPath</span>();</span><br><span class="line">TreePath treePath = new TreePath(pathNodes);</span><br></pre></td></tr></table></figure></div><ul><li>treePath.getPathCount(): 获得节点数量</li><li>treePath.getPath()： 获得路径上的节点</li><li>treePath.getParentPath()： 获得这个节点上一个节点路径</li><li>treePath.isDescendant(TreePath aTreePath)： 判断aTreePath是否包含这个路径（判断aTreePath节点是否是子孙辈节点）</li></ul><h1 id="JTree"><a href="#JTree" class="headerlink" title="JTree"></a>JTree</h1><p>JTree负责把构造好的树显示出来。</p><p>构造方法：</p><ul><li>JTree(TreeNode root)： 由根节点就可以显示整个树</li><li>TreeModel treeModel = new DefaultTreeModel(TreeNode root)：构建一个树模型. 然后JTree(treeModel)</li></ul><p>方法：</p><ul><li>TreePath getPathForRow(int row)： 获得行索引。但是这个行索引实惠变化的，它不包括没有展开的。</li><li>int getRowForPath(TreePath path)： 根据路径获得行索引</li><li>int getRowForLocation(int x, int y)： 获得这个位置处的节点，可以和鼠标监听器一起使用。</li><li>TreePath getPathForLocation(int x, int y)</li><li>expandRow(int row)： 展开节点</li><li>expandPath(TreePath path)</li><li>collapseRow(int row)： 折叠节点</li><li>collapsePath(TreePath path)</li><li>isExpanded(int row)： 节点是否处于展开状态</li><li>isExpanded(TreePath path)</li><li>setSelectionRow(int row)： 设置当前选中的节点</li><li>setSelectionRow(int[] row)</li><li>setSelectionPath(TreePath path)</li><li>setSelectionPath(TreePath[] path): 多选</li><li>int[] getSelectionRows()： 获取当前选中的节点</li><li>TreePath getSelectionPath()</li><li>TreePath[] getSelectionPaths()</li><li>setRootVisible(boolean rootVisible)： 是否显示根节点（默认显示）</li><li>setShowsRootHandles(boolean newValue)： 是否显示根节点句柄（默认不显示）</li><li>setEditable(boolean flag)</li></ul><p>设置节点样式：</p><p>首先创建节点渲染器<code>DefaultTreeCellRenderer render = new DefaultTreeCellRenderer()</code></p><ul><li>render.setOpenIcon(Icon newIcon)： 设置节点展开时图标</li><li>render.setClosedIcon(Icon newIcon)：</li><li>render.setLeafIcon(Icon newIcon)： 叶子节点显示图标</li><li>render.setFont(Font font)</li><li>ender.setTextSelectionColor(Color newColor)：选中时颜色</li><li>render.setTextNonSelectionColor(Color newColor)</li><li>render.setBackgroundSelectionColor(Color newColor)： 选中时背景颜色</li><li>render.setBackgroundNonSelectionColor(Color newColor)</li></ul><p>之后设置节点渲染器<code>jTree.setCellRenderer(render)</code></p><p>监听器：</p><ul><li>addTreeExpansionListener： 节点展开/折叠监听器</li><li>addTreeWillExpandListener： 功能和上面相同，但是先执行</li><li>addTreeSelectionListener： 节点被选中监听器</li><li>tree.getModel().addTreeModelListener： 节点增删改监听器</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Tree</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="constructor">Tree(String <span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> <span class="constructor">JFrame(<span class="params">name</span>)</span>;</span><br><span class="line">        frame.pack<span class="literal">()</span>;</span><br><span class="line">        frame.set<span class="constructor">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class="line">        frame.set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        DefaultMutableTreeNode treeroot = <span class="keyword">new</span> <span class="constructor">DefaultMutableTreeNode()</span>;</span><br><span class="line">        Object<span class="literal">[]</span> treename = <span class="keyword">new</span> Object<span class="literal">[]</span>&#123;<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"H"</span>&#125;;</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;treename.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            treeroot.add(<span class="keyword">new</span> <span class="constructor">DefaultMutableTreeNode(<span class="params">treename</span>[<span class="params">i</span>])</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        Object<span class="literal">[]</span> C_treename = <span class="keyword">new</span> Object<span class="literal">[]</span>&#123;<span class="string">"user"</span>, <span class="string">"program"</span>, <span class="string">"data"</span>&#125;;</span><br><span class="line">        DefaultMutableTreeNode C_treenode = (DefaultMutableTreeNode) treeroot.get<span class="constructor">ChildAt(0)</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="module-access"><span class="module"><span class="identifier">C_treename</span>.</span></span>length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">C_treenode</span>.</span></span>add(<span class="keyword">new</span> <span class="constructor">DefaultMutableTreeNode(C_treename[<span class="params">i</span>])</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        JTree tree = <span class="keyword">new</span> <span class="constructor">JTree(<span class="params">treeroot</span>)</span>;</span><br><span class="line">        tree.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line">        tree.set<span class="constructor">RootVisible(<span class="params">false</span>)</span>;</span><br><span class="line">        tree.set<span class="constructor">ShowsRootHandles(<span class="params">true</span>)</span>;</span><br><span class="line">        frame.add(tree);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E7%BB%84%E4%BB%B69.PNG" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jun 10 2020 14:55:31 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;p&gt;树图形就像文件目
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>swing 表格</title>
    <link href="http://xinhecuican.github.io/post/ade8c6d6.html"/>
    <id>http://xinhecuican.github.io/post/ade8c6d6.html</id>
    <published>2020-06-09T01:08:00.000Z</published>
    <updated>2020-06-09T03:04:01.394Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jun 10 2020 09:08:35 GMT+0800 (中国标准时间) --><p><a href="https://blog.csdn.net/xietansheng/article/details/78079806" target="_blank" rel="external nofollow noopener noreferrer">学习自</a></p><h1 id="基础表格"><a href="#基础表格" class="headerlink" title="基础表格"></a>基础表格</h1><p>JTable用来编辑二维表格。注意添加到容器时表头和内容要分开添加。表头获取是table.getTableHeader()。</p><p>构造方法：</p><ul><li>JTable(int numRows, int numColumns)</li><li>JTable(Object[][] rowData, Object[] columnNames)：columnnames是表头名称</li><li>JTable(TableModel dm)： 用表格模型创建表格</li></ul><p>方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setFont</span><span class="params">(Font f)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//被选中字体颜色</span></span><br><span class="line"><span class="function"><span class="title">setSelectionForeground</span><span class="params">(Color selectionForeground)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setForeground</span><span class="params">(Color fg)</span></span><span class="comment">//字体颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setSelectionBackground</span><span class="params">(Color selectionBackground)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//网格颜色</span></span><br><span class="line"><span class="function"><span class="title">setGridColor</span><span class="params">(Color gridColor)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否显示网格</span></span><br><span class="line"><span class="function"><span class="title">setShowGrid</span><span class="params">(boolean showGrid)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//水平网格是否显示</span></span><br><span class="line"><span class="function"><span class="title">setShowHorizontalLines</span><span class="params">(boolean showHorizontalLines)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setShowVerticalLines</span><span class="params">(boolean showVerticalLines)</span></span></span><br></pre></td></tr></table></figure></div><ul><li>JTableHeader getTableHeader(): 获取表头</li><li>jTableHeader.setFont(Font font);： 设置表头颜色</li><li>jTableHeader.setForeground(Color fg)</li><li>jTableHeader.setResizingAllowed(boolean resizingAllowed)：时候可以拖动调整列大小</li><li>jTableHeader.setReorderingAllowed(boolean reorderingAllowed)： 是否可以拖动进行重新排序</li><li>setRowHeight(int rowHeight)： 行高</li><li>setRowHeight(int row, int rowHeight)： 指定行行高</li><li>setAutoResizeMode(int mode)改变列宽的操作<ul><li>JTable.AUTO_RESIZE_ALL_COLUMNS 在所有的调整大小操作中，按比例调整所有的列。</li><li>JTable.AUTO_RESIZE_LAST_COLUMN 在所有的调整大小操作中，只对最后一列进行调整。</li><li>JTable.AUTO_RESIZE_NEXT_COLUMN 在 UI 中调整了一个列时，对其下一列进行相反方向的调整。</li><li>JTable.AUTO_RESIZE_OFF 不自动调整列的宽度；使用滚动条</li><li>JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS 在 UI 调整中，更改后续列以保持总宽度不变；此为默认行为。</li></ul></li><li>TableColumn jTable.getColumnModel().getColumn(int columnIndex)：获取某列进行操作</li><li>tableColumn.setWidth(int width);</li><li>tableColumn.setPreferredWidth(int preferredWidth);</li><li>tableColumn.setMinWidth(int minWidth);</li><li>tableColumn.setMaxWidth(int maxWidth);</li><li>tableColumn.sizeWidthToFit()： 设置列宽使其符合单元格宽度</li><li>tableColumn.setResizable(boolean isResizable)： 是否允许手动改变列宽</li><li>tableColumn.setHeaderValue(Object headerValue)： 设置该列表头名称</li><li>jTable.getModel().setValueAt(Object aValue, int rowIndex, int columnIndex)： 设置某个位置数据</li><li>Object jTable.getModel().getValueAt(int rowIndex, int columnIndex)：得到某个位置数据</li></ul><h1 id="表格模型"><a href="#表格模型" class="headerlink" title="表格模型"></a>表格模型</h1><p>TableModel中储存了表格的一系列信息，实际上导入JTable中的数据自动变成TableModel。</p><p>TableModel中的方法：</p><ul><li>getRowCount()： 获取行数</li><li>getColumnCount()： 获取列数</li><li>String getColumnName(int columnIndex)：获取指定列的表头名称</li><li>Class&lt;?&gt; getColumnClass(int columnIndex)： 获取列中所有数据</li><li>isCellEditable(int rowIndex, int columnIndex)：单元格是否可编辑</li><li>Object getValueAt(int rowIndex, int columnIndex)： 获取单元格</li><li>setValueAt(Object aValue, int rowIndex, int columnIndex)： 获取单元格值</li></ul><p>监听器：</p><ul><li>tableModel.addTableModelListener(TableModelListener l)： 添加表格模型监听，表格的数据维护，对数据的监听。</li><li>tableModel.removeTableModelListener(TableModelListener l)：去除表格模型监听</li></ul><h1 id="ListSelectionModel-表格选择器"><a href="#ListSelectionModel-表格选择器" class="headerlink" title="ListSelectionModel 表格选择器"></a>ListSelectionModel 表格选择器</h1><p>它可以让用户以不同模式选中表格。</p><ul><li>table.setCellSelectionEnabled(boolean cellSelectionEnabled)：设置表格可以被选择</li><li>table.getSelectionModel()： 获得选择器</li><li>selectionModel.setSelectionMode(int selectionMode)：设置选择模式<ul><li>ListSelectionModel.MULTIPLE_INTERVAL_SELECTION 一次选择一个或多个连续的索引范围（默认）</li><li>ListSelectionModel.SINGLE_INTERVAL_SELECTION 一次选择一个连续的索引范围</li><li>ListSelectionModel.SINGLE_SELECTION 一次只能选择一个列表索引</li></ul></li></ul><p>监听器：</p><p>addListSelectionListener： 在选中状态改变时调用</p><h1 id="TableCellRenderer-单元格的渲染器"><a href="#TableCellRenderer-单元格的渲染器" class="headerlink" title="TableCellRenderer 单元格的渲染器"></a>TableCellRenderer 单元格的渲染器</h1><p>可以自己创建一个表格渲染器。然后TableColumn有setCellRenderer(renderer)。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="keyword">class</span> MyTableCellRenderer extends DefaultTableCellRenderer &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回默认的表单元格渲染器，此方法在父类中已实现，直接调用父类方法返回，在返回前做相关参数的设置即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        @Override</span><br><span class="line">        public Component get<span class="constructor">TableCellRendererComponent(JTable <span class="params">table</span>, Object <span class="params">value</span>, <span class="params">boolean</span> <span class="params">isSelected</span>, <span class="params">boolean</span> <span class="params">hasFocus</span>, <span class="params">int</span> <span class="params">row</span>, <span class="params">int</span> <span class="params">column</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数行背景设置为白色，奇数行背景设置为灰色</span></span><br><span class="line">            <span class="keyword">if</span> (row % <span class="number">2</span><span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                set<span class="constructor">Background(Color.WHITE)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set<span class="constructor">Background(Color.LIGHT_GRAY)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一列的内容水平居中对齐，最后一列的内容水平右对齐，其他列的内容水平左对齐</span></span><br><span class="line">            <span class="keyword">if</span> (column<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                set<span class="constructor">HorizontalAlignment(SwingConstants.CENTER)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (column<span class="operator"> == </span>(table.get<span class="constructor">ColumnCount()</span> - <span class="number">1</span>)) &#123;</span><br><span class="line">                set<span class="constructor">HorizontalAlignment(SwingConstants.RIGHT)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set<span class="constructor">HorizontalAlignment(SwingConstants.LEFT)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置提示文本，当鼠标移动到当前(row, column)所在单元格时显示的提示文本</span></span><br><span class="line">            set<span class="constructor">ToolTipText(<span class="string">"提示的内容: "</span> + <span class="params">row</span> + <span class="string">", "</span> + <span class="params">column</span>)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PS: 多个单元格使用同一渲染器时，需要自定义的属性，必须每次都设置，否则将自动沿用上一次的设置。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 单元格渲染器为表格单元格提供具体的显示，实现了单元格渲染器的 DefaultTableCellRenderer 继承自</span></span><br><span class="line"><span class="comment">             * 一个标准的组件类 JLabel，因此 JLabel 中相应的 API 在该渲染器实现类中都可以使用。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * super.getTableCellRendererComponent(...) 返回的实际上是当前对象（this），即 JLabel 实例，</span></span><br><span class="line"><span class="comment">             * 也就是以 JLabel 的形式显示单元格。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果需要自定义单元格的显示形式（比如显示成按钮、复选框、内嵌表格等），可以在此自己创建一个标准组件</span></span><br><span class="line"><span class="comment">             * 实例返回。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用父类的该方法完成渲染器的其他设置</span></span><br><span class="line">            return super.get<span class="constructor">TableCellRendererComponent(<span class="params">table</span>, <span class="params">value</span>, <span class="params">isSelected</span>, <span class="params">hasFocus</span>, <span class="params">row</span>, <span class="params">column</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h1 id="TableCellEditor-数据编辑器"><a href="#TableCellEditor-数据编辑器" class="headerlink" title="TableCellEditor 数据编辑器"></a>TableCellEditor 数据编辑器</h1><p>数据编辑器可以在表格中加入textfield，JComboBox等组件。实际一般使用默认的实现类DefaultCellEditor</p><p>tableColumn.setCellEditor(cellEditor)设置表格编辑器</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASPECTJ"><figure class="iseeu highlight /aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCellEditor</span> <span class="keyword">extends</span> <span class="title">DefaultCellEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCellEditor</span><span class="params">(JTextField textField)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(textField);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCellEditor</span><span class="params">(JCheckBox checkBox)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(checkBox);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCellEditor</span><span class="params">(JComboBox comboBox)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(comboBox);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">stopCellEditing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 获取当前单元格的编辑器组件</span></span><br><span class="line">            Component comp = getComponent();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前单元格编辑器输入的值</span></span><br><span class="line">            Object obj = getCellEditorValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前单元格编辑器输入的值不是数字，则返回 false（表示数据非法，不允许设置，无法保存）</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span> || !obj.toString().matches(<span class="string">"[0-9]*"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 数据非法时，设置编辑器组件内的内容颜色为红色</span></span><br><span class="line">                comp.setForeground(Color.RED);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据合法时，设置编辑器组件内的内容颜色为黑色</span></span><br><span class="line">            comp.setForeground(Color.BLACK);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合法数据交给父类处理</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">stopCellEditing</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h1 id="RowSorter-排序器"><a href="#RowSorter-排序器" class="headerlink" title="RowSorter 排序器"></a>RowSorter 排序器</h1><p>创建： <code>RowSorter&lt;TableModel&gt; rowSorter = new TableRowSorter&lt;TableModel&gt;(tableModel)</code></p><p>TableRowSroter是RowSorter的实现类。</p><p>使用 <code>table.setRowSorter(rowSorter)</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jun 10 2020 09:08:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xietansheng/article/details/78079806&quot; target
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>swing面板和其他组件</title>
    <link href="http://xinhecuican.github.io/post/ae8362df.html"/>
    <id>http://xinhecuican.github.io/post/ae8362df.html</id>
    <published>2020-06-06T07:05:00.000Z</published>
    <updated>2020-06-11T02:51:22.887Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jun 11 2020 10:51:23 GMT+0800 (中国标准时间) --><p><a href="https://blog.csdn.net/xietansheng/article/details/72814492" target="_blank" rel="external nofollow noopener noreferrer">学习自</a></p><h1 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h1><h2 id="JPanel"><a href="#JPanel" class="headerlink" title="JPanel"></a>JPanel</h2><p>可以在大布局里设计另一种布局</p><h2 id="JScrollPane-滚动面板"><a href="#JScrollPane-滚动面板" class="headerlink" title="JScrollPane 滚动面板"></a>JScrollPane 滚动面板</h2><p>它可以显示在文本较多的时候显示水平或垂直滚动条。如JTextArea或JTextField（水平滚动）或JList等可以使用滚动面板</p><p>JScrollPane内有一个ViewPort（视口），表示JScrollPane的显示区域，视口内包含一个需要滚动的组件。</p><p>构造方法：</p><ul><li>JScrollPane(Component view, int vsbPolicy, int hsbPolicy): view是需要加入视口的组件，vsb和hsb是水平和垂直滚动策略。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">策略取值</span><br><span class="line">ScrollPaneConstants<span class="selector-class">.VERTICAL_SCROLLBAR_AS_NEEDED</span>    <span class="comment">// 需要时显示（默认）</span></span><br><span class="line">ScrollPaneConstants<span class="selector-class">.VERTICAL_SCROLLBAR_NEVER</span>        <span class="comment">// 从不显示</span></span><br><span class="line">ScrollPaneConstants<span class="selector-class">.VERTICAL_SCROLLBAR_ALWAYS</span>       <span class="comment">// 总是显示</span></span><br><span class="line">水平就是把VERTICAL改成HORIZONAL</span><br></pre></td></tr></table></figure></div><p>方法：</p><ul><li>setViewportView(Component view)： 设置滚动条内组件(最好不要用add，容易出问题)</li><li>setVerticalScrollBarPolicy(int policy)： 垂直滚动条显示策略</li><li>setHorizontalScrollBarPolicy(int policy)： 水平滚动条显示策略</li><li>setWheelScrollingEnabled(boolean handleWheel)：是否响应鼠标，默认响应</li></ul><h2 id="JSplitPane-分隔面板"><a href="#JSplitPane-分隔面板" class="headerlink" title="JSplitPane 分隔面板"></a>JSplitPane 分隔面板</h2><p>分隔面板可以分隔两个组件。组件位置可以是上下或者左右。并且两个组件的分割线可以拉伸。</p><p>构造方法：</p><ul><li>JSplitPane(int orientation, boolean continuousLayout, Component leftComponent, Component rightComponent)： orientation是分割方向，可以取JSplitPane.HORIZONTAL_SPLIT或JSplitPane.VERTICAL_SPLIT。continuousLayout是拖动分割线时是否重绘组件。如果是false，那么拖动完了才会重绘。后面两个参数时两个组件</li></ul><p>方法：</p><ul><li>setOrientation(int orientation)：设置分割方向</li><li>setLeftComponent(Component comp)：设置左边/上面组件</li><li>setRightComponent(Component comp)</li><li>setContinuousLayout(boolean continuousLayout)</li><li>setOneTouchExpandable(boolean newValue)： 分隔条上快速折叠/展开组件小按钮</li><li>setDividerSize(int newSize)： 分隔条宽度</li><li>setDividerLocation(int location)：分隔条位置，相对于左边/上面的像素值</li><li>setDividerLocation(double proportionalLocation)： 这个是在0到1间取值，也是位置。</li></ul><h2 id="JTabbedPane-选项卡面板"><a href="#JTabbedPane-选项卡面板" class="headerlink" title="JTabbedPane 选项卡面板"></a>JTabbedPane 选项卡面板</h2><p>可以通过点击在组件之间进行切换。</p><p>构造方法：</p><ul><li>JTabbedPane(int tabPlacement, int tabLayoutPolicy)： 选项卡标题的位置, 值为 JTabbedPane.TOP、JTabbedPane.BOTTOM、JTabbedPane.LEFT 或 JTabbedPane.RIGHT, 默认为 TOP。tabLayoutPolicy是选项放不下时放置选项策略。有JTabbedPane.WRAP_TAB_LAYOUT 或 JTabbedPane.SCROLL_TAB_LAYOUT。</li></ul><p>方法：</p><ul><li>void addTab(String title, Icon icon, Component component, String tip)：添加选项，tip是焦点在选项卡时显示的文本。</li><li>insertTab(String title, Icon icon, Component component, String tip, int index)： 指定位置插入选项卡</li><li>removeTabAt(int index)：移除选项卡</li><li>remove(int index)</li><li>remove(Component component)</li><li>removeAll()</li><li>setSelectedIndex(int index)： 设置选中的选项卡</li><li>getSelectedIndex()： 获得选中的选项卡索引</li><li>Component getSelectedComponent()： 获得选项卡组件</li><li>setTitleAt(int index, String title)： 设置选项卡标题</li><li>setIconAt(int index, Icon icon)： 设置选项卡图标</li><li>setEnabledAt(int index, boolean enabled)： 设置选项是否可用</li><li>setComponentAt(int index, Component component)：设置组件</li><li>getTabCount()： 获得选项卡数量</li><li>setTabComponentAt(int index, Component titleComponent)：把一个组件放到标题位置（其他是标题位置就是标题，组件在下面）</li></ul><p>监听器： <code>addChangeListener(ChangeListener l)</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        JTabbedPane tabbedPane = <span class="keyword">new</span> <span class="constructor">JTabbedPane()</span>;</span><br><span class="line">        JTextArea textArea = <span class="keyword">new</span> <span class="constructor">JTextArea(20, 20)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectionColor(Color.RED)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectedTextColor(Color.YELLOW)</span>;</span><br><span class="line">        textArea.set<span class="constructor">CaretColor(Color.BLUE)</span>;</span><br><span class="line">        textArea.set<span class="constructor">LineWrap(<span class="params">true</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Font(<span class="params">new</span> Font(<span class="params">null</span>, Font.PLAIN, 20)</span>);</span><br><span class="line">        textArea.set<span class="constructor">WrapStyleWord(<span class="params">true</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        tabbedPane.add<span class="constructor">Tab(<span class="string">"text"</span>, <span class="params">textArea</span>)</span>;</span><br><span class="line">        tabbedPane.add<span class="constructor">Tab(<span class="string">"try"</span>, <span class="params">new</span> JButton(<span class="string">"ha"</span>)</span>);</span><br><span class="line">        tabbedPane.add<span class="constructor">Tab(<span class="string">"picture"</span>, <span class="params">new</span> ImageIcon(<span class="string">"F:\\hexo\\wodeboke\\source\\images\\pasted-0.png"</span>)</span>, <span class="keyword">new</span> <span class="constructor">JPasswordField(10)</span>);</span><br><span class="line">        add(tabbedPane);</span><br><span class="line"></span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">        set<span class="constructor">Size(100, 200)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">"Hello"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E9%9D%A2%E6%9D%BF1.PNG" alt></p><h2 id="JLayerPane-层级面板"><a href="#JLayerPane-层级面板" class="headerlink" title="JLayerPane 层级面板"></a>JLayerPane 层级面板</h2><p>层级面板允许组件重叠出现，并且把组件分成若干层。层取值-1到n-1</p><p>每一层组件位置可以设置编号，编号决定前后。层之间编号越大在前面，层中编号越大越接近底部。</p><p>加入层的组件必须要设置位置和大小（width和height），否则不予显示</p><p>构造方法：</p><ul><li>JLayerPane()</li></ul><p>方法：</p><ul><li>add(Component comp, Object layer, int position):因为layer是object，说明不能直接用整型，而是要用Integer类。</li><li>add(Component comp, Object layer)</li><li>setLayer(Component c, int layer, int position)</li><li>setLayer(Component c, int layer)</li><li>moveToFront(Component c): 把组件移到最顶端的位置</li><li>moveToBack(Component c)</li><li>setPosition(Component c, int position)：设置组件所在层</li></ul><h1 id="JDialog和JOptionPane"><a href="#JDialog和JOptionPane" class="headerlink" title="JDialog和JOptionPane"></a>JDialog和JOptionPane</h1><p>JOpintionPane是已经实现好的JDialog，以静态方法的形式提供调用。</p><p>JOpintionPane提供的调用：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>showMessageDialog</td><td>消息对话框，向用户展示一个消息，没有返回值。</td></tr><tr><td>showConfirmDialog</td><td>确认对话框，询问一个问题是否执行。</td></tr><tr><td>showInputDialog</td><td>输入对话框，要求用户提供某些输入。</td></tr><tr><td>showOptionDialog</td><td>选项对话框，上述三项的大统一，自定义按钮文本，询问用户需要点击哪个按钮。</td></tr></tbody></table><p>静态方法中的参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">(1)</span> <span class="attr">parentComponent:</span> <span class="string">对话框的父级组件，决定对话框显示的位置，对话框的显示会尽量紧靠组件的中心，如果传</span> <span class="literal">null</span><span class="string">，则显示在屏幕的中心。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(2)</span> <span class="attr">title:</span> <span class="string">对话框标题。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(3)</span> <span class="attr">message:</span> <span class="string">消息内容。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(4)</span> <span class="attr">messageType:</span> <span class="string">消息类型，主要是提供默认的对话框图标。可能的值为：</span></span><br><span class="line"></span><br><span class="line"><span class="string">JOptionPane.PLAIN_MESSAGE</span> <span class="string">简单消息（不使用图标）</span></span><br><span class="line"><span class="string">JOptionPane.INFORMATION_MESSAGE</span> <span class="string">信息消息（默认）</span></span><br><span class="line"><span class="string">JOptionPane.QUESTION_MESSAGE</span> <span class="string">问题消息</span></span><br><span class="line"><span class="string">JOptionPane.WARNING_MESSAGE</span> <span class="string">警告消息</span></span><br><span class="line"><span class="string">JOptionPane.ERROR_MESSAGE</span> <span class="string">错误消息</span></span><br><span class="line"><span class="string">(5)</span> <span class="attr">icon:</span> <span class="string">自定义的对话框图标，如果传</span> <span class="literal">null</span><span class="string">，则图标类型由</span> <span class="string">messageType</span> <span class="string">决定。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(6)</span> <span class="attr">optionType:</span> <span class="string">选项按钮的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(7)</span> <span class="string">options、initialValue:</span> <span class="string">自定义的选项按钮（如果穿</span> <span class="literal">null</span><span class="string">，则选项按钮由</span> <span class="string">optionType</span> <span class="string">决定），以及默认选中的选项按钮。</span></span><br><span class="line"></span><br><span class="line"><span class="string">(8)</span> <span class="string">selectionValues、initialSelectionValue:</span> <span class="string">提供的输入选项，以及默认选中的选项。</span></span><br></pre></td></tr></table></figure></div><p>但是不是每种选项都拥有所有参数,下面是每个方法最多的选项</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> showMessageDialog(Component parentComponent, </span><br><span class="line">                              <span class="built_in">Object</span> message, </span><br><span class="line">                              <span class="built_in">String</span> title, </span><br><span class="line">                              <span class="built_in">int</span> messageType, </span><br><span class="line">                              Icon icon)</span><br><span class="line">                              </span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> showConfirmDialog(Component parentComponent, </span><br><span class="line">                             <span class="built_in">Object</span> message, </span><br><span class="line">                             <span class="built_in">String</span> title, </span><br><span class="line">                             <span class="built_in">int</span> optionType, </span><br><span class="line">                             <span class="built_in">int</span> messageType, </span><br><span class="line">                             Icon icon)</span><br><span class="line">                             </span><br><span class="line"><span class="keyword">static</span> <span class="built_in">Object</span> showInputDialog(Component parentComponent, </span><br><span class="line">                              <span class="built_in">Object</span> message, </span><br><span class="line">                              <span class="built_in">String</span> title, </span><br><span class="line">                              <span class="built_in">int</span> messageType, </span><br><span class="line">                              Icon icon, </span><br><span class="line">                              <span class="built_in">Object</span>[] selectionValues, </span><br><span class="line">                              <span class="built_in">Object</span> initialSelectionValue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> showOptionDialog(Component parentComponent, </span><br><span class="line">                            <span class="built_in">Object</span> message, </span><br><span class="line">                            <span class="built_in">String</span> title, </span><br><span class="line">                            <span class="built_in">int</span> optionType, </span><br><span class="line">                            <span class="built_in">int</span> messageType, </span><br><span class="line">                            Icon icon, </span><br><span class="line">                            <span class="built_in">Object</span>[] options, </span><br><span class="line">                            <span class="built_in">Object</span> initialValue)</span><br></pre></td></tr></table></figure></div><p>其中showconfirmDialog的messageType参数可以是JOptionPane.YES_OPTION（是）或JOptionPane.NO_OPTION（否）或JOptionPane.CANCEL_OPTION（取消）或JOptionPane.CLOSED_OPTION（关闭）。也可以是JOptionPane.YES_NO_CANCEL_OPTION;等组合选项。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">public</span> Calculate(String <span class="type">name</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        super(<span class="type">name</span>);</span><br><span class="line">        JButton Button2 = <span class="built_in">new</span> JButton("show message");</span><br><span class="line">        Button2.addActionListener(<span class="built_in">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                showMessageDialog(<span class="keyword">null</span>, "message", "Hello", QUESTION_MESSAGE, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        JButton button = <span class="built_in">new</span> JButton("show input");</span><br><span class="line">        button.addActionListener(<span class="built_in">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                String[] <span class="keyword">select</span> = <span class="built_in">new</span> String[]&#123;"水果", "食物"&#125;;</span><br><span class="line">                <span class="keyword">Object</span> input = showInputDialog(</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        "input something",</span><br><span class="line">                        "Hello",</span><br><span class="line">                        WARNING_MESSAGE</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">input</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        JButton button1 = <span class="built_in">new</span> JButton("total");</span><br><span class="line">        button1.addActionListener(<span class="built_in">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="built_in">public</span> <span class="type">void</span> actionPerformed(ActionEvent actionEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                String[] <span class="keyword">select</span> = <span class="built_in">new</span> String[]&#123;"水果", "食物"&#125;;</span><br><span class="line">                <span class="type">int</span> o = showOptionDialog(</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        "please select one",</span><br><span class="line">                        "Hello",</span><br><span class="line">                        YES_NO_CANCEL_OPTION,</span><br><span class="line">                        PLAIN_MESSAGE,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">select</span>,</span><br><span class="line">                        <span class="keyword">select</span>[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">select</span>[o]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Box</span> vBox = <span class="type">Box</span>.createVerticalBox();</span><br><span class="line">        vBox.<span class="keyword">add</span>(button);</span><br><span class="line">        vBox.<span class="keyword">add</span>(Button2);</span><br><span class="line">        vBox.<span class="keyword">add</span>(button1);</span><br><span class="line">        <span class="keyword">add</span>(vBox);</span><br><span class="line">        setVisible(<span class="keyword">true</span>);</span><br><span class="line">        pack();</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">new</span> Calculate("Hello");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E9%9D%A2%E6%9D%BF2.PNG" alt><br><img src="/images/swing%E9%9D%A2%E6%9D%BF3.PNG" alt><br><img src="/images/swing%E9%9D%A2%E6%9D%BF4.PNG" alt></p><p>注意：showOptionDialog如果后面没有Object[]，那么下面的选项是YES_NO_CANCEL_OPTION。并且它的返回值是一个int型，如果点了叉那么返回值是-1.</p><p>showInputDialog返回值是输入的信息，</p><h1 id="JFileChooser-文件选择器"><a href="#JFileChooser-文件选择器" class="headerlink" title="JFileChooser 文件选择器"></a>JFileChooser 文件选择器</h1><p>可以用来打开和保存文件。</p><p>构造方法：</p><ul><li>JFileChooser(File currentDirectory)：打开文件时默认显示的文件夹。可以使用绝对目录</li></ul><p>方法：</p><ul><li>setCurrentDirectory(File dir)： 设置当前文件夹</li><li>setFileSelectionMode(int mode)：有三种模式。JFileChooser.FILES_ONLY: 只能选文件 或 JFileChooser.DIRECTORIES_ONLY: 只能选文件夹 或 JFileChooser.FILES_AND_DIRECTORIES: 文件和文件夹都可以选。</li><li>setMultiSelectionEnabled(boolean b)：是否可以选多个（默认不允许）</li><li>addChoosableFileFilter(FileFilter filter)： 添加文件类型选择。例如<code>fileChooser.setFileFilter(new FileNameExtensionFilter(&quot;image(*.jpg, *.png, *.gif)&quot;, &quot;jpg&quot;, &quot;png&quot;, &quot;gif&quot;));</code>前面是描述，后面是选择类型。</li><li>setFileFilter(FileFilter filter)： 设置默认使用的过滤器</li><li>setSelectedFile(File file)： 设置默认被选中的文件</li><li>setSelectedFiles(File[] selectedFiles)</li><li>showOpenDialog(Component parent)： 打开对话框（线程会被阻塞），parent是父组件，设置会让对话框显示在父组件中心，如果是null显示在屏幕中心。返回值有JFileChooser.CANCEL_OPTION: 点击了取消或关闭 或 JFileChooser.APPROVE_OPTION: 点击了确认或保存 或 JFileChooser.ERROR_OPTION: 出现错误</li><li>File getSelectedFile()： 获得选择的文件</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> File files;</span><br><span class="line">    <span class="keyword">private</span> FileReader fileReader;</span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">name</span>)</span> throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        JFileChooser fileChooser = <span class="keyword">new</span> <span class="constructor">JFileChooser(<span class="string">"F:\\系统设置\\Desktop\\我的文档"</span>)</span>;</span><br><span class="line">        fileChooser.add<span class="constructor">ChoosableFileFilter(<span class="params">new</span> FileNameExtensionFilter(<span class="string">"*.zip"</span>,<span class="string">"zip"</span>)</span>);</span><br><span class="line">        fileChooser.add<span class="constructor">ChoosableFileFilter(<span class="params">new</span> FileNameExtensionFilter(<span class="string">"*.txt"</span>, <span class="string">"txt"</span>)</span>);</span><br><span class="line">        fileChooser.set<span class="constructor">FileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES)</span>;</span><br><span class="line">        fileChooser.set<span class="constructor">MultiSelectionEnabled(<span class="params">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">        JButton button = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">"open to copy"</span>)</span>;</span><br><span class="line">        JTextArea textArea = <span class="keyword">new</span> <span class="constructor">JTextArea( 40, 40)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectedTextColor(Color.YELLOW)</span>;</span><br><span class="line">        textArea.set<span class="constructor">SelectionColor(Color.RED)</span>;</span><br><span class="line">        textArea.set<span class="constructor">CaretColor(Color.BLUE)</span>;</span><br><span class="line">        textArea.set<span class="constructor">WrapStyleWord(<span class="params">false</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Font(<span class="params">new</span> Font(<span class="params">null</span>, Font.PLAIN, 20)</span>);</span><br><span class="line">        textArea.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        JTextField textField = <span class="keyword">new</span> <span class="constructor">JTextField(<span class="string">"The content of the file will show here"</span>)</span>;</span><br><span class="line">        textField.set<span class="constructor">Editable(<span class="params">false</span>)</span>;</span><br><span class="line">        textArea.set<span class="constructor">Foreground(Color.RED)</span>;</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="constructor">JPanel()</span>;</span><br><span class="line">        panel.set<span class="constructor">Layout(<span class="params">new</span> BorderLayout()</span>);</span><br><span class="line">        JPanel panel1 = <span class="keyword">new</span> <span class="constructor">JPanel()</span>;</span><br><span class="line">        panel1.set<span class="constructor">Layout(<span class="params">new</span> BorderLayout()</span>);</span><br><span class="line">        panel1.add(button, BorderLayout.NORTH);</span><br><span class="line">        panel1.add(textField, BorderLayout.CENTER);</span><br><span class="line">        panel.add(panel1, BorderLayout.NORTH);</span><br><span class="line">        panel.add(textArea, BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line">        button.add<span class="constructor">ActionListener(<span class="params">new</span> ActionListener()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fileChooser.show<span class="constructor">OpenDialog(<span class="params">panel</span>)</span><span class="operator"> == </span>JFileChooser.APPROVE_OPTION)</span><br><span class="line">                &#123;</span><br><span class="line">                    files = fileChooser.get<span class="constructor">SelectedFile()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(fileChooser.show<span class="constructor">OpenDialog(<span class="params">panel</span>)</span><span class="operator"> == </span>JFileChooser.ERROR_OPTION)</span><br><span class="line">                &#123;</span><br><span class="line">                    show<span class="constructor">MessageDialog(<span class="params">fileChooser</span>, <span class="string">"something wrong"</span>, <span class="string">"hello"</span>, ERROR_MESSAGE, <span class="params">null</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fileReader = <span class="keyword">new</span> <span class="constructor">FileReader(<span class="params">files</span>)</span>;</span><br><span class="line">                    <span class="built_in">int</span> c;</span><br><span class="line">                    <span class="keyword">while</span>((c=fileReader.read<span class="literal">()</span>) != -<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        textArea.append(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of((<span class="params">char</span>)</span> c));</span><br><span class="line">                    &#125;</span><br><span class="line">                    fileReader.close<span class="literal">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        add(panel);</span><br><span class="line"></span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">        pack<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">"hello"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E5%9B%BE%E5%BD%A25.PNG" alt></p><p>如果想使用系统的ui可以用java.awt.FileDialog</p><h1 id="JColorChooser-颜色选择器"><a href="#JColorChooser-颜色选择器" class="headerlink" title="JColorChooser 颜色选择器"></a>JColorChooser 颜色选择器</h1><p>提供一个让用户选择颜色的对话框。</p><p>构造方法：</p><ul><li>public static Color showDialog(Component component, String title, Color initialColor)： 这是JColorChooser的静态方法。Component是父组件，title标题。</li></ul><h1 id="JMenuBar-菜单"><a href="#JMenuBar-菜单" class="headerlink" title="JMenuBar 菜单"></a>JMenuBar 菜单</h1><p>把菜单添加到JFrame后，会在顶部出现。菜单有三种：</p><ul><li>JMenu： 菜单栏上的菜单</li><li>JMenuBar： 菜单栏</li><li>JMenuItem, JCheckBoxMenuItem, JRadioButtonMenuItem： 子菜单，表示子菜单\带复选框的子菜单\带单选按钮的子菜单。</li></ul><p>JMenu、JCheckBoxMenuItem、JRadioButtonMenuItem 均继承自 JMenuItem。</p><p>JMenuItem的构造方法：</p><ul><li>JMenuItem(String title, Icon icon)： icon是菜单显示的图标</li></ul><p>把JMenuBar添加到JFrame是用setJmenuBar()方法</p><p>JMenuItem常用方法：</p><ul><li>setIcon(Icon defaultIcon)</li><li>setText(String text)</li><li>setMnemonic(int mnemonic): 设置快捷键助记符。也就是在标题后面会加一个下划线或其他标识然后再加上这个字母。它是用来提示你按下那个键触发快捷键的。例如： menuItem.setMnemonic(KeyEvent.VK_N);</li><li>setAccelerator(KeyStroke keyStroke)： 设置快捷键。例如：menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N, ActionEvent.ALT_MASK));</li><li>setActionCommand(String actionCommand)：设置菜单项的Action名称。如果多个菜单项使用同一个监听器就可以用这个方法设置名字用来辨别到底是哪一个触发了。</li></ul><p>监听器： addActionListener(ActionListener l)</p><p>JCheckBoxMenuItem、JRadioButtonMenuItem 常用方法:：</p><p>其实就是JCheckBoxButton类似的方法.它的监听器是addChangeListener(ChangeListener l)</p><p>JMenu常用方法：</p><ul><li>JMenuItem add(JMenuItem menuItem)： 添加一个子菜单到JMenu中</li><li>addSeparator()： 添加一个子菜单分界线</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Menu(<span class="keyword">String</span> name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JMenuBar menuBar = <span class="keyword">new</span> <span class="type">JMenuBar</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一级菜单</span></span><br><span class="line">        JMenu menu_File = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">"file"</span>);</span><br><span class="line">        JMenu menu_Edit = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">"edit"</span>);</span><br><span class="line">        JMenu menu_about = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">"about"</span>);</span><br><span class="line">        <span class="comment">//menu_File.setMnemonic(KeyEvent.VK_N);</span></span><br><span class="line">        <span class="comment">//menu_File.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N, ActionEvent.ALT_MASK));</span></span><br><span class="line">        menuBar.add(menu_about);</span><br><span class="line">        menuBar.add(menu_Edit);</span><br><span class="line">        menuBar.add(menu_File);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//file子菜单</span></span><br><span class="line">        JMenuItem File_open = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"open"</span>);</span><br><span class="line">        JMenuItem file_save = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"save"</span>);</span><br><span class="line">        JMenuItem file_new <span class="type"></span>= <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"new"</span>);</span><br><span class="line">        JMenuItem file_close = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"close"</span>);</span><br><span class="line">        menu_File.add(file_new<span class="type"></span>);</span><br><span class="line">        menu_File.add(file_save);</span><br><span class="line">        menu_File.add(File_open);</span><br><span class="line">        menu_File.addSeparator();</span><br><span class="line">        menu_File.add(file_close);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//edit子菜单</span></span><br><span class="line">        JMenuItem edit_paste = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"paste"</span>);</span><br><span class="line">        JMenuItem edit_cut= <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"cut"</span>);</span><br><span class="line">        JMenuItem edit_copy = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"copy"</span>);</span><br><span class="line">        menu_Edit.add(edit_copy);</span><br><span class="line">        menu_about.add(edit_cut);</span><br><span class="line">        menu_about.add(edit_paste);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//about子菜单</span></span><br><span class="line">        JMenuItem about_author = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"author"</span>);</span><br><span class="line">        JMenu menu_about_conference = <span class="keyword">new</span> <span class="type">JMenu</span>(<span class="string">"conference"</span>);</span><br><span class="line">        menu_about.add(about_author);</span><br><span class="line">        menu_about.add(menu_about_conference);</span><br><span class="line"></span><br><span class="line">        JMenuItem conference_link1 = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"first"</span>);</span><br><span class="line">        JMenuItem conference_link2 = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"second"</span>);</span><br><span class="line">        menu_about_conference.add(conference_link1);</span><br><span class="line">        menu_about_conference.add(conference_link2);</span><br><span class="line">        setJMenuBar(menuBar);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Menu</span>(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E9%9D%A2%E6%9D%BF7.PNG" alt></p><h1 id="JToolBar-工具栏"><a href="#JToolBar-工具栏" class="headerlink" title="JToolBar 工具栏"></a>JToolBar 工具栏</h1><p>工具栏显示了一些常用组件。它支持拖动，为了确保可以拖动，可以把它加入到BorderLayout的任意一边，并且不要再其他四边中加入子级</p><p>构造方法：</p><ul><li>JToolBar(String name, int orientation)： orientation是工具栏方向，可以取SwingConstants.HORIZONTAL或SwingConstants.VERTICAL，默认水平</li></ul><p>方法：</p><ul><li>Component add(Component comp)：添加组件到工具栏</li><li>addSeparator()：添加分割线</li><li>addSeparator(Dimension size)</li><li>Component getComponentAtIndex(int index)：获取指定位置组件（包括分隔符）</li><li>setFloatable(boolean b)：工具栏是否可以拖动</li><li>setOrientation(int o)</li><li>setMargin(Insets m)： 设置内边距</li><li>setBorderPainted(boolean b)： 是否绘制边框</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">tool</span> <span class="title">extends</span> <span class="title">JFrame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">tool</span>(<span class="params">String name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line"></span><br><span class="line">        JToolBar toolBar = <span class="keyword">new</span> JToolBar();</span><br><span class="line">        toolBar.setFloatable(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">add</span>(toolBar, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">        JButton button_next_music = <span class="keyword">new</span> JButton(<span class="string">"next"</span>, <span class="keyword">new</span> ImageIcon(<span class="string">"D:\\截图\\next.png"</span>));</span><br><span class="line">        JButton button_pause_music = <span class="keyword">new</span> JButton(<span class="string">"pause"</span>, <span class="keyword">new</span> ImageIcon(<span class="string">"D:\\截图\\pause.png"</span>));</span><br><span class="line">        JButton button_previous_music = <span class="keyword">new</span> JButton(<span class="string">"previous"</span>, <span class="keyword">new</span> ImageIcon(<span class="string">"D:\\截图\\previous.png"</span>));</span><br><span class="line">        toolBar.<span class="keyword">add</span>(button_previous_music);</span><br><span class="line">        toolBar.addSeparator();</span><br><span class="line">        toolBar.<span class="keyword">add</span>(button_pause_music);</span><br><span class="line">        toolBar.addSeparator();</span><br><span class="line">        toolBar.<span class="keyword">add</span>(button_next_music);</span><br><span class="line">        button_next_music.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span>(<span class="params">ActionEvent actionEvent</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"next music"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button_pause_music.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span>(<span class="params">ActionEvent actionEvent</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"pause"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button_previous_music.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span>(<span class="params">ActionEvent actionEvent</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"previous music"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">new</span> tool(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E9%9D%A2%E6%9D%BF8.PNG" alt>把它拖到左上角又可以固定。</p><h1 id="JPopupMenu-右键菜单"><a href="#JPopupMenu-右键菜单" class="headerlink" title="JPopupMenu 右键菜单"></a>JPopupMenu 右键菜单</h1><p>这个挺熟悉的，又叫弹出式菜单。它的使用和JToolBar类似。</p><h1 id="JInternalFrame-内部窗口"><a href="#JInternalFrame-内部窗口" class="headerlink" title="JInternalFrame 内部窗口"></a>JInternalFrame 内部窗口</h1><p>内部窗口是在JFrame内部显示一个完整的子窗口。</p><p>在实际使用中，通常将 JInternalFrame 添加到 JDesktopPane 中，由其来维护和显示 JInternalFrame。</p><p>方法等和JFrame类似</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JInternalFrame createInternalFrame() &#123;</span><br><span class="line">        <span class="comment">// 创建一个内部窗口</span></span><br><span class="line">        JInternalFrame internalFrame = <span class="keyword">new</span> <span class="type">JInternalFrame</span>(</span><br><span class="line">                <span class="string">"内部窗口"</span>,  <span class="comment">// title</span></span><br><span class="line">                <span class="literal">true</span>,       <span class="comment">// resizable</span></span><br><span class="line">                <span class="literal">true</span>,       <span class="comment">// closable</span></span><br><span class="line">                <span class="literal">true</span>,       <span class="comment">// maximizable</span></span><br><span class="line">                <span class="literal">true</span>        <span class="comment">// iconifiable</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置窗口的宽高</span></span><br><span class="line">        internalFrame.setSize(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 设置窗口的显示位置</span></span><br><span class="line">        internalFrame.setLocation(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 内部窗口的关闭按钮动作默认就是销毁窗口，所有不用设置</span></span><br><span class="line">        <span class="comment">// internalFrame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建内容面板</span></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="type">JPanel</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加组件到面板</span></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="type">JLabel</span>(<span class="string">"Label001"</span>));</span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="type">JButton</span>(<span class="string">"JButton001"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置内部窗口的内容面板</span></span><br><span class="line">        internalFrame.setContentPane(panel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 对于内部窗口，还可以不需要手动设置内容面板，直接把窗口当做普通面板使用，</span></span><br><span class="line"><span class="comment">         * 即直接设置布局，然后通过 add 添加组件，如下代码:</span></span><br><span class="line"><span class="comment">         *     internalFrame.setLayout(new FlowLayout());</span></span><br><span class="line"><span class="comment">         *     internalFrame.add(new JLabel("Label001"));</span></span><br><span class="line"><span class="comment">         *     internalFrame.add(new JButton("JButton001"));</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示内部窗口</span></span><br><span class="line">        internalFrame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> internalFrame;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h1 id="DeskTop"><a href="#DeskTop" class="headerlink" title="DeskTop"></a>DeskTop</h1><p>DeskTop可以让java程序启动本机上注册的程序。一般程序有</p><ul><li>打开浏览器</li><li>打开邮件</li><li>打开文件</li></ul><p>方法：</p><ul><li>static boolean isDesktopSupported()： 当前平台是否支持此类</li><li>static Desktop getDesktop()： 获得DeskTop实例</li><li>browse(URI uri)： 启用默认浏览器显示URI</li><li>open(File file)： 启用默认应用程序打开文件</li><li>edit(File file)： 启用默认编辑器编辑文件</li><li>print(File file)： 打印</li><li>mail()： 启用邮件管理</li><li>mail(URI mailtoURI)： 启用邮件管理并填充URI</li><li>isSupported(Desktop.Action action)： 查看当前平台是否支持上述操作。取值是DeskTop.Action.xxx xxx是上面操作的大写</li></ul><h1 id="系统剪切板"><a href="#系统剪切板" class="headerlink" title="系统剪切板"></a>系统剪切板</h1><p>获得系统剪切板：</p><p><code>Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();</code></p><p>使用：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><figcaption><span>class Main &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 把文本设置到剪贴板（复制）</span><br><span class="line">        setClipboardString(&quot;Hello System Clipboard!&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从剪贴板中获取文本（粘贴）</span><br><span class="line">        String text &#x3D; getClipboardString();</span><br><span class="line">        System.out.println(&quot;text: &quot; + text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 把文本设置到剪贴板（复制）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void setClipboardString(String text) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取系统剪贴板</span><br><span class="line">        Clipboard clipboard &#x3D; Toolkit.getDefaultToolkit().getSystemClipboard();</span><br><span class="line">        &#x2F;&#x2F; 封装文本内容</span><br><span class="line">        Transferable trans &#x3D; new StringSelection(text);</span><br><span class="line">        &#x2F;&#x2F; 把文本内容设置到系统剪贴板</span><br><span class="line">        clipboard.setContents(trans, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从剪贴板中获取文本（粘贴）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getClipboardString() &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取系统剪贴板</span><br><span class="line">        Clipboard clipboard &#x3D; Toolkit.getDefaultToolkit().getSystemClipboard();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取剪贴板中的内容</span><br><span class="line">        Transferable trans &#x3D; clipboard.getContents(null);</span><br><span class="line"></span><br><span class="line">        if (trans !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断剪贴板中的内容是否支持文本</span><br><span class="line">            if (trans.isDataFlavorSupported(DataFlavor.stringFlavor)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取剪贴板中的文本内容</span><br><span class="line">                    String text &#x3D; (String) trans.getTransferData(DataFlavor.stringFlavor);</span><br><span class="line">                    return text;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jun 11 2020 10:51:23 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xietansheng/article/details/72814492&quot; target
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Swing组件</title>
    <link href="http://xinhecuican.github.io/post/604b49d0.html"/>
    <id>http://xinhecuican.github.io/post/604b49d0.html</id>
    <published>2020-06-04T02:37:00.000Z</published>
    <updated>2020-07-08T09:09:34.235Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 09 2020 08:11:43 GMT+0800 (中国标准时间) --><h1 id="Border边框"><a href="#Border边框" class="headerlink" title="Border边框"></a>Border边框</h1><p>边框创建与设置</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Border border = <span class="module-access"><span class="module"><span class="identifier">BorderFactory</span>.</span></span>create<span class="constructor">XxxxBorder(<span class="operator">...</span>)</span>;</span><br><span class="line">jComponent.set<span class="constructor">Border(<span class="params">border</span>)</span>;<span class="comment">//设置边框</span></span><br></pre></td></tr></table></figure></div><p><strong>BorderFactory中的边框</strong></p><p>使用BorderFactory中的静态方法创建边框</p><ul><li><p>createEmptyBorder()： 空边框</p></li><li><p>createEmptyBorder(int top, int left, int bottom, int right)：</p></li><li><p>createLineBorder(Color color)： 线边框。color是线的颜色</p></li><li><p>createLineBorder(Color color, int thickness, boolean rounded)： thickness是线宽，rounded是是否有圆角</p></li><li><p>createTitledBorder(Border border, String title, int titleJustification, int titlePosition, Font titleFont, Color titleColor)：标题边框。border是要加标题的边框，title是标题内容。titleFont是标题字体，color是标题颜色。</p><ul><li>titleJustification有以下取值</li><li>TitledBorder.LEFT</li><li>TitledBorder.CENTER</li><li>TitledBorder.RIGHT</li><li>TitledBorder.LEADING</li><li>TitledBorder.TRAILING</li><li>TitledBorder.DEFAULT_JUSTIFICATION (leading)</li><li>titleposition是标题在边框位置。有以下取值</li><li>TitledBorder.ABOVE_TOP</li><li>TitledBorder.TOP（位于顶线上）</li><li>TitledBorder.BELOW_TOP</li><li>TitledBorder.ABOVE_BOTTOM</li><li>TitledBorder.BOTTOM（位于底线上）</li><li>TitledBorder.BELOW_BOTTOM</li><li>TitledBorder.DEFAULT_POSITION（顶部）</li></ul></li></ul><p>还有许多其他边框</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GAMS"><figure class="iseeu highlight /gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斜面边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createBevelBorder(...);</span><br><span class="line"><span class="comment">// 虚线边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createDashedBorder(...);</span><br><span class="line"><span class="comment">// “浮雕化”边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createEtchedBorder(...);</span><br><span class="line"><span class="comment">// 凹入斜面边缘的边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createLoweredBevelBorder(...);</span><br><span class="line"><span class="comment">// 具有凸出斜面边缘的边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createRaisedBevelBorder(...);</span><br><span class="line"><span class="comment">// 凸起软斜面</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createRaisedSoftBevelBorder(...);</span><br><span class="line"><span class="comment">// 合成边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> CompoundBorder createCompoundBorder(...);</span><br><span class="line"><span class="comment">// 类似衬边的边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> MatteBorder createMatteBorder(...);</span><br><span class="line"><span class="comment">// 共享斜面边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createSharedBevel(...)</span><br><span class="line"><span class="comment">// 软斜面边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createSoftBevelBorder(...);</span><br><span class="line"><span class="comment">// 画笔边框</span></span><br><span class="line"><span class="function"><span class="title">static</span></span> Border createStrokeBorder(...);</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing%E7%BB%84%E4%BB%B610.PNG" alt><br><a href="https://blog.csdn.net/xietansheng/article/details/78389211" target="_blank" rel="external nofollow noopener noreferrer">学习自</a></p><h1 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h1><p>所有的按钮都继承与AbstractButton。按钮有：普通按钮（JButton）、触发器按钮（JToggleButton）、复选框（JCheckBox）、单选按钮（JRadioButton）、箭头按钮（BasicArrowButton）和菜单项（JMenuItem）等。</p><p>方法：</p><ul><li>void setEnabled(boolean enable)： 设置这个按钮是否可用</li><li>setRolloverEnabled(boolean enable): 设置是否要产生翻转</li><li>setContentAreaFilled(): 是否要绘制父类内容。设置这个是让按钮周围不会有界限。</li><li>setFocusPainted(): 时候绘制焦点</li><li>setBorderPainted(): 是否绘制边框</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    JButton button;</span><br><span class="line">    JToggleButton togglebutton;</span><br><span class="line">    JCheckBox checkbox;</span><br><span class="line">    JRadioButton radiobutton;</span><br><span class="line">    BasicArrowButton arrowbutton;</span><br><span class="line">    JMenuItem menuitem;</span><br><span class="line">    <span class="keyword">public</span> Calculate(<span class="keyword">String</span> title)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">        setLayout(<span class="keyword">new</span> <span class="type">FlowLayout</span>());</span><br><span class="line">        button = <span class="keyword">new</span> <span class="type">JButton</span>(<span class="string">"button"</span>);</span><br><span class="line">        togglebutton = <span class="keyword">new</span> <span class="type">JToggleButton</span>(<span class="string">"togglebutton"</span>);</span><br><span class="line">        checkbox = <span class="keyword">new</span> <span class="type">JCheckBox</span>(<span class="string">"checkbox"</span>);</span><br><span class="line">        radiobutton = <span class="keyword">new</span> <span class="type">JRadioButton</span>(<span class="string">"radiobutton"</span>);</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="type">JPanel</span>();</span><br><span class="line">        panel.setBorder(<span class="keyword">new</span> <span class="type">TitledBorder</span>(<span class="string">"arrow"</span>));</span><br><span class="line">        arrowbutton = <span class="keyword">new</span> <span class="type">BasicArrowButton</span>(BasicArrowButton.NORTH);</span><br><span class="line">        panel.add(arrowbutton);</span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="type">BasicArrowButton</span>(BasicArrowButton.RIGHT));</span><br><span class="line">        menuitem = <span class="keyword">new</span> <span class="type">JMenuItem</span>(<span class="string">"menuitem"</span>);</span><br><span class="line">        add(button);</span><br><span class="line">        add(togglebutton);</span><br><span class="line">        add(checkbox);</span><br><span class="line">        add(radiobutton);</span><br><span class="line">        add(panel);</span><br><span class="line">        add(menuitem);</span><br><span class="line">        pack();</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Calculate</span>(<span class="string">"Calculate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing.PNG" alt></p><p>注意togglebutton有两种状态，按下和弹出，普通按钮按下就会立刻弹出，但是toggle按下就变成按下状态，需要再按一下才会变成弹出状态。</p><p>可以设置选中或者未选中<code>setSelected(boolean)</code>。也可以通过<code>isSelected()</code>查看是否被选中</p><p>在按钮中可以显示图标，ImageIcon类表示图标。有以下设置图标的方法：</p><ul><li>setIcon(Icon icon): 设置有效状态下的图标</li><li>setRolloverIcon(Icon icon): 设置鼠标移动到对应区域显示图标</li><li>setPressedIcon(Icon icon): 设置按下按钮时显示的图标</li><li>setDisabledIcon(Icon icon): 设置无效状态下的图标</li><li>setBorderPainted(boolean b)： 是否绘制边框</li></ul><p><strong>监听器</strong></p><p>JButton</p><ul><li>void addActionListener(ActionListener listener)</li><li>void removeActionListener(ActionListener listener)：移除监听器</li></ul><p>JRadioButton</p><ul><li>void addChangeListener(ChangeListener l)//状态改变监听器</li></ul><h2 id="JRadioButton-JCheckBox-JtoggleButton"><a href="#JRadioButton-JCheckBox-JtoggleButton" class="headerlink" title="JRadioButton/JCheckBox/JtoggleButton"></a>JRadioButton/JCheckBox/JtoggleButton</h2><p>从上面我们可以看出，这三者就是图形有所不同，大致功能还是相同的。</p><p>构造方法：</p><ul><li>JRadioButton(String text, boolean selected): selected确定开始的状态<br>例：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculate</span> <span class="title">extends</span> <span class="title">JFrame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JRadioButton button;</span><br><span class="line">    <span class="keyword">private</span> JRadioButton button2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculate</span>(<span class="params">String text</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        button = <span class="keyword">new</span> JRadioButton(<span class="string">"男"</span>);</span><br><span class="line">        button2 = <span class="keyword">new</span> JRadioButton(<span class="string">"女"</span>);</span><br><span class="line">        ButtonGroup <span class="keyword">group</span> = <span class="keyword">new</span> ButtonGroup();</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span>(<span class="params">ActionEvent actionEvent</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">if</span>(button.isSelected())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"button has been selected"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"Button hasn't been selected"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button.setSelected(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">group</span>.<span class="keyword">add</span>(button);</span><br><span class="line">        <span class="keyword">group</span>.<span class="keyword">add</span>(button2);</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line">        panel.<span class="keyword">add</span>(button);</span><br><span class="line">        panel.<span class="keyword">add</span>(button2);</span><br><span class="line">        <span class="keyword">add</span>(panel);</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">new</span> Calculate(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里有个问题，使用actionListener的话只会显示button has been selected.因为点击另外一个按钮时button按钮会自动关闭，而actionListener不检查，只有当按下button时才会输出。</p><p>如果用ChangeListener的话当鼠标移动到这两个按钮上面的时候就会输出，点击时又会输出，这样可能会使输出过于庞杂。</p><h2 id="按钮组"><a href="#按钮组" class="headerlink" title="按钮组"></a>按钮组</h2><p>当有多个单选按钮时，可以把他们加入到一个按钮组中。这个歌时候一次最多只能选择按钮组中一个按钮。</p><p>创建：</p><ul><li>ButtonGroup b = new ButtonGroup();</li></ul><p>把按钮添加到按钮组中用add。</p><h1 id="JTextField文本框"><a href="#JTextField文本框" class="headerlink" title="JTextField文本框"></a>JTextField文本框</h1><p>JTextField与PlainDocument关联，后者保存前者的文档。当用户向文本框中输入文本时，AWT线程会自动调用PlainDocument的insertString()方法，把用户输入的文本存到PlainDocument中。</p><p>文本框只能储存一行文本，不能多行。</p><p>构造方法：</p><ul><li>JTextField(String text): 显示默认文本</li><li>JTextField(int col): 设定首选列数，如果是零，就是默认列数。</li></ul><p>方法：</p><ul><li>String getText(): 获得文本</li><li>setCaretColor(Color c): 设置光标颜色</li><li>setSelectionColor(Color c): 设置选中背景颜色</li><li>setSelectedTextColor(Color c): 设置选中文本颜色</li><li>setDisabledTextColor(Color c): 设置不可用时文本颜色</li><li>setHorizontalAlignment(int alignment): 设置文本对齐方式</li><li>setEditable(boolean b): 设置文本框是否可以编辑</li><li>boolean isFocusOwner()： 查看当前组件是否拥有焦点</li><li>setSelectionStart(int selectionStart)：设置光标开始位置</li><li>setSelectionEnd(int selectionEnd)： 设置光标结束位置</li><li>copy(): 复制选中文本</li><li>cut(): 剪切选中文本</li><li>paste(): 将复制/剪切得到的文本复制到文本框</li></ul><p><strong>监听器</strong></p><p>void addFocusListener(FocusListener listener)： 焦点事件监听器</p><p>textField.getDocument().addDocumentListener(DocumentListener listener)：文本框内文本改变监听器</p><p>void addKeyListener(KeyListener listener)：按键监听器</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JTextField field;</span><br><span class="line">    <span class="keyword">private</span> JTextField log;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">text</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(text);</span><br><span class="line">        log = <span class="keyword">new</span> <span class="constructor">JTextField()</span>;</span><br><span class="line">        field = <span class="keyword">new</span> <span class="constructor">JTextField(8)</span>;</span><br><span class="line">        field.set<span class="constructor">Font(<span class="params">new</span> Font(<span class="params">null</span>, Font.PLAIN, 20)</span>);</span><br><span class="line"></span><br><span class="line">        field.set<span class="constructor">CaretColor(Color.BLUE)</span>;</span><br><span class="line">        field.set<span class="constructor">SelectionColor(Color.BLACK)</span>;</span><br><span class="line">        field.set<span class="constructor">SelectedTextColor(Color.GREEN)</span>;</span><br><span class="line">        field.set<span class="constructor">DisabledTextColor(Color.RED)</span>;</span><br><span class="line"></span><br><span class="line">        field.set<span class="constructor">HorizontalAlignment(SwingConstants.RIGHT)</span>;</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="constructor">JPanel()</span>;</span><br><span class="line">        JButton button_copy = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">"copy"</span>)</span>;</span><br><span class="line">        JButton button_paste = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">"paste"</span>)</span>;</span><br><span class="line">        JButton button_cut = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">"cut"</span>)</span>;</span><br><span class="line">        JToggleButton button_enabled = <span class="keyword">new</span> <span class="constructor">JToggleButton(<span class="string">"edit disable"</span>)</span>;</span><br><span class="line"></span><br><span class="line">        button_copy.add<span class="constructor">ActionListener(<span class="params">new</span> <span class="params">actioncopy</span>()</span>);</span><br><span class="line">        button_cut.add<span class="constructor">ActionListener(<span class="params">new</span> <span class="params">actioncut</span>()</span>);</span><br><span class="line">        button_paste.add<span class="constructor">ActionListener(<span class="params">new</span> <span class="params">actionpaste</span>()</span>);</span><br><span class="line">        button_enabled.add<span class="constructor">ActionListener(<span class="params">new</span> ActionListener()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(field.is<span class="constructor">Editable()</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    button_enabled.set<span class="constructor">Text(<span class="string">"edit enable"</span>)</span>;</span><br><span class="line">                    field.set<span class="constructor">Editable(<span class="params">false</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    button_enabled.set<span class="constructor">Text(<span class="string">"edit disable"</span>)</span>;</span><br><span class="line">                    field.set<span class="constructor">Editable(<span class="params">true</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        panel.add(button_copy);</span><br><span class="line">        panel.add(button_cut);</span><br><span class="line">        panel.add(button_paste);</span><br><span class="line">        panel.add(button_enabled);</span><br><span class="line"></span><br><span class="line">        field.add<span class="constructor">FocusListener(<span class="params">new</span> FocusAdapter()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void focus<span class="constructor">Gained(FocusEvent <span class="params">e</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                super.focus<span class="constructor">Gained(<span class="params">e</span>)</span>;</span><br><span class="line">                log.set<span class="constructor">Text(<span class="string">"your focus is in the text field"</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        field.add<span class="constructor">FocusListener(<span class="params">new</span> FocusAdapter()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void focus<span class="constructor">Lost(FocusEvent <span class="params">e</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                super.focus<span class="constructor">Lost(<span class="params">e</span>)</span>;</span><br><span class="line">                log.set<span class="constructor">Text(<span class="string">"yout focus is out of the text field"</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        add(panel, BorderLayout.NORTH);</span><br><span class="line">        add(log, BorderLayout.SOUTH);</span><br><span class="line">        add(field, BorderLayout.CENTER);</span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        pack<span class="literal">()</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">class</span> actioncopy implements ActionListener</span><br><span class="line">    &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            field.copy<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">class</span> actioncut implements  ActionListener</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            field.cut<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">class</span> actionpaste implements ActionListener</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void action<span class="constructor">Performed(ActionEvent <span class="params">actionEvent</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            field.paste<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">"Hello"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing3.PNG" alt></p><h1 id="JLabel标签"><a href="#JLabel标签" class="headerlink" title="JLabel标签"></a>JLabel标签</h1><p>标签主要用于展示文本和图片。</p><p>构造方法：</p><ul><li>JLabel()</li><li>JLabel(String text, int horizontalAlignment): text是文本，horizontalAlignment是对齐方式</li><li>JLabel(Icon Image): 图片</li><li>上面三种可以组合，也就是说可以同时显示图片和文本</li></ul><p>方法：</p><ul><li>setText(String text)</li><li>setIcon(Icon icon)</li></ul><p>// 设置文本相对于图片的位置（文本默认在图片右边垂直居中）</p><ul><li>void setHorizontalTextPosition(int textPosition)</li><li>void setVerticalTextPosition(int textPosition)</li></ul><p>// 设置标签内容（在标签内）的对其方式（默认左对齐并垂直居中）</p><ul><li>void setHorizontalAlignment(int alignment)</li><li>void setVerticalAlignment(int alignment)</li><li>setIconTextGap(int gap): 设置文本和图片之间的间隙</li></ul><p>构造方法中的图片还可以直接填URL从网络中获取。此外，Icon一般用的是ImageIcon</p><p>image实例创建</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一: 通过 java.awt.Toolkit 工具类来读取本地、网络 或 内存中 的 图片（支持 GIF、JPEG 或 PNG）</span></span><br><span class="line">Image image = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.get<span class="constructor">Image(String <span class="params">filename</span>)</span>;</span><br><span class="line">Image image = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.get<span class="constructor">Image(URL <span class="params">url</span>)</span>;</span><br><span class="line">Image image = <span class="module-access"><span class="module"><span class="identifier">Toolkit</span>.</span></span>get<span class="constructor">DefaultToolkit()</span>.create<span class="constructor">Image(<span class="params">byte</span>[] <span class="params">imageData</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二: 通过 javax.imageio.ImageIO 工具类读取本地、网络 或 内存中 的 图片（BufferedImage 继承自 Image）</span></span><br><span class="line">BufferedImage bufImage = <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>read(File input);</span><br><span class="line">BufferedImage bufImage = <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>read(URL input);</span><br><span class="line">BufferedImage bufImage = <span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>read(InputStream input);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PS_01: 图片宽高: BufferedImage 可以通过 bufImage.getWidth() 和 bufImage.getHeight() 方法直接获取图片的宽高;</span></span><br><span class="line"><span class="comment"> *                 Image 获取宽高需要另外传入一个 ImageObserver 参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PS_02: 图片裁剪: BufferedImage 通过 bufImage.getSubimage(int x, int y, int w, int h) 方法可以截取图片的</span></span><br><span class="line"><span class="comment"> *                 任意一部分，返回一个新的 BufferedImage 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PS_03: 图片缩放: Image 通过 image.getScaledInstance(int width, int height, int hints) 方法可以对图片进行</span></span><br><span class="line"><span class="comment"> *                 缩放，返回新的一个 Image 实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/xietansheng/article/details/74362076" target="_blank" rel="external nofollow noopener noreferrer">几乎照搬</a></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JLabel label ;</span><br><span class="line">    <span class="keyword">public</span> Calculate(<span class="keyword">String</span> text, <span class="keyword">String</span> image)</span><br><span class="line">    &#123;</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="type">JPanel</span>();</span><br><span class="line">        label = <span class="keyword">new</span> <span class="type">JLabel</span>(image);</span><br><span class="line">        label.setFont(<span class="keyword">new</span> <span class="type">Font</span>(<span class="literal">null</span>, Font.PLAIN, <span class="number">25</span>));</span><br><span class="line">        JLabel label2 = <span class="keyword">new</span> <span class="type">JLabel</span>();</span><br><span class="line">        label2.setIcon(<span class="keyword">new</span> <span class="type">ImageIcon</span>(<span class="string">"D:\\截图\\捕获.PNG"</span>));</span><br><span class="line">        label2.setText(<span class="string">"only an image"</span>);</span><br><span class="line">        label2.setHorizontalTextPosition(SwingConstants.CENTER);</span><br><span class="line">        label2.setVerticalTextPosition(SwingConstants.BOTTOM);</span><br><span class="line">        panel.add(label);</span><br><span class="line">        panel.add(label2);</span><br><span class="line">        add(panel);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        pack();</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Calculate</span>(<span class="string">"Hello"</span>, <span class="string">"This is an image"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/images/swing2.PNG" alt></p><h1 id="JPasswordField-密码框"><a href="#JPasswordField-密码框" class="headerlink" title="JPasswordField 密码框"></a>JPasswordField 密码框</h1><p>JPasswordField的构造方法和JTextField相同。</p><p>方法：</p><ul><li>char[] getpassword(): 获取输入的密码</li><li>setEchoChar(char c)： 设置默认显示的字符</li><li>setEditable()</li><li>setEnabled()</li></ul><p>常用的监听器和JTextField相同。</p><p><img src="/images/swing5.PNG" alt></p><p>密码框的特点就是输入字符不可见</p><h1 id="JTextArea-文本区域"><a href="#JTextArea-文本区域" class="headerlink" title="JTextArea 文本区域"></a>JTextArea 文本区域</h1><p>文本区域可以编辑多行文本。</p><p>构造方法：</p><ul><li>JTextArea(String text, int rows, int cols): 默认显示多少行多少列</li></ul><p>方法：</p><ul><li>setLineWrap(boolean b): 设置是否自动换行， 默认是false</li><li>setWrapStyleWord(boolean word)： 设置换行方式，如果是true，就在单词边界换行。如果是false，就在字符边界换行（也就是说到了上限就一定换行）</li><li>append(String str): 追加字符串到文末</li><li>replaceRange（String str, int start, int end): 替换文本</li><li>getLineCount()： 获取行数</li><li>getLineEndOfOffset(int line): 获取某一行行尾在文中偏移量</li><li>getLineOfOffset(int line)</li><li>setCaretColor(Color c)</li><li>setSelectionColor(Color c)</li><li>void setMinimum(int min)</li><li>void setMaximum(int max)</li><li>void setValue(int n)</li><li>setSelectedTextColor(Color c)</li><li>setDisabledTextColor(Color c)</li></ul><p>大致方法和监听器和JTextField相同</p><h1 id="JComboBox-下拉列表"><a href="#JComboBox-下拉列表" class="headerlink" title="JComboBox 下拉列表"></a>JComboBox 下拉列表</h1><p>下拉列表中选项内容由ComboBoxModel 实例来维护。</p><p>构造方法：</p><ul><li>JComboBox(ComboBoxModel model)</li><li>JComboBox(Object[] items)</li><li>JComboBox(Vector&lt;?&gt; items)</li></ul><p>ComboBoxModel 实例可以直接创建，也可以通过把 数组 或 集合 传递到 JComboBox 中间接创建。</p><p>常用方法：</p><ul><li>setSelectedIndex(int index)： 设置选中索引</li><li>getSelectedIndex(): 获得当前选中的索引</li><li>Object getSelectedItem()： 获得当前选中的数据项</li><li>setModel(ComboBoxModel&lt;?&gt; model)： 设置当前模型</li><li>ComboBoxModel&lt;?&gt; getModel()： 获得模型。再通过 model.getElementAt(int index) 和 model.getSize() 获得索引和选项数量</li><li>setEditable(boolean flag)： 设置是否可以编辑，默认false。如果设置成true，那么用户自己可以自行输入值。</li></ul><p>监听器：</p><ul><li>addItemListener(ItemListener listener)：选项选中状态改变</li></ul><p><img src="/images/swing6.PNG" alt></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">comboBox.add<span class="constructor">ItemListener(<span class="params">new</span> ItemListener()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void item<span class="constructor">StateChanged(ItemEvent <span class="params">e</span>)</span> &#123;</span><br><span class="line">                <span class="comment">// 只处理选中的状态</span></span><br><span class="line">                <span class="keyword">if</span> (e.get<span class="constructor">StateChange()</span><span class="operator"> == </span>ItemEvent.SELECTED) &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"选中: "</span> + comboBox.get<span class="constructor">SelectedIndex()</span> + <span class="string">" = "</span> + comboBox.get<span class="constructor">SelectedItem()</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></div><h1 id="JList-列表框"><a href="#JList-列表框" class="headerlink" title="JList 列表框"></a>JList 列表框</h1><p>列表框和下拉列表不同之处在于列表框一次把所有选项都显示并且可以多选（按ctrl），而下拉列表一次只能选择一个。同样内容有ListModel维护。</p><p>构造方法大致和JComboBox相同</p><p>方法：</p><ul><li>setListData(Object[] listData)： 设置列表元素</li><li>setListData(Vector&lt;?&gt; listData)</li><li>setModel(ListModel&lt;?&gt; model)</li><li>setSelectionMode(int selectionMode)：设置选择模式，有三种模式，单选，可间断多选，可连续多选。ListSelectionModel.MULTIPLE_INTERVAL_SELECTION，等。</li><li>setSelectedIndex(int index)： 设置某个选项被选中</li><li>setSelectedIndices(int[] indices)</li><li>getSelectedIndex()： 获得第一个被选中的索引</li><li>int[] getSelectedIndices()： 获得所有被选中的索引</li><li>setForeground(Color fg)： 未选中时字体颜色</li><li>setSelectionForeground(Color selectionForeground)：选中选项字体颜色</li><li>setSelectionBackground(Color selectionBackground)：选中条颜色</li></ul><p>监听器： addListSelectionListener(ListSelectionListener listener)。选项选中状态改变监听器</p><h1 id="JPrograssBar-进度条"><a href="#JPrograssBar-进度条" class="headerlink" title="JPrograssBar 进度条"></a>JPrograssBar 进度条</h1><p>当进度未知的时候，可以设置成不确定模式，不确定模式下也会持续显示动画。当确定就可以转换成确定模式。</p><p>构造方法：</p><ul><li><p>JPrograssBar(int orient, int min, int max): 进度条当前值，最大值，最小值。这些参量可以减少</p></li><li><p>void setMinimum(int min)</p></li><li><p>void setMaximum(int max)</p></li><li><p>void setValue(int n)：设置当前进度值</p></li><li><p>getValue()</p></li><li><p>getPercentComplete()： 获得当前进度百分比</p></li><li><p>setStringPainted(boolean b)： 是否以百分比显示文本</p></li><li><p>setIndeterminate(boolean newValue)： 是否设置成不确定模式</p></li><li><p>setOrientation(int newOrientation)： SwingConstants.VERTICAL 或 SwingConstants.HORIZONTAL</p></li><li><p>setMajorTickSpacing(int n)： 设置主刻度线间隔</p></li><li><p>setMinorTickSpacing(int n)： 设置主标记线内次标记线间隔</p></li><li><p>setPaintTicks(boolean b)： 是否绘制刻度线</p></li><li><p>setInverted(boolean b)： 是否让刻度值从大到小</p></li><li><p>setSnapToTicks(boolean b)： 是否让滑块对齐刻度。true滑块只能取刻度值</p></li><li><p>setLabelTable(Dictionary&lt;Integer, JComponent&gt; labels)：绘制特定的标签代替刻度值</p></li><li><p>setPaintTrack(boolean b)： 是否绘制滑道</p></li></ul><p>监听器：<code>addChangeListener(ChangeListener l)</code>: 进度改变监听器</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> <span class="title">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">String</span> <span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        super(<span class="built_in">text</span>);</span><br><span class="line">        JProgressBar progressBar = <span class="keyword">new</span> JProgressBar(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        progressBar.setValue(<span class="number">0</span>);</span><br><span class="line">        progressBar.setStringPainted(<span class="literal">true</span>);</span><br><span class="line">        progressBar.setIndeterminate(<span class="literal">false</span>);</span><br><span class="line">        progressBar.setOrientation(SwingConstants.HORIZONTAL);</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(<span class="literal">true</span>);</span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()</span><br><span class="line">            &#123;</span><br><span class="line">                progressBar.setValue(progressBar.getValue() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        timer.schedule(task, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">        add(progressBar);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line">        pack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Calculate(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里就可以解释为什么进度条为什么忽快忽慢的了。当某一部分任务完成的时候就会设置进度条向前进。</p><h1 id="JSlider"><a href="#JSlider" class="headerlink" title="JSlider"></a>JSlider</h1><p>通过滑块来选择不同的值。当鼠标焦点移到滑块上时，也可以通过上下左右移动滑块。</p><p>构造方法 ：</p><ul><li>JSlider(int orientation): 滑块方向，有SwingConstants.HORIZONAL和SwingConstants.VERTICAL.</li><li>JSlider(int min, int max): 滑块初始值可以是min到max中间任意一个值。</li><li>JSlider(int orientation, int min, int max, int value)</li></ul><p>方法：</p><ul><li>void setMinimum(int min)</li><li>void setMaximum(int max)</li><li>void setValue(int n)</li><li>setMajorTickSpacing(int n)： 设置主刻度线间隔</li><li>setMinorTickSpacing(int n)： 设置主标记线内次标记线间隔</li><li>setPaintTicks(boolean b)： 是否绘制刻度线</li><li>setPaintLabels(boolean b): 是否绘制标签</li><li>setInverted(boolean b)： 是否让刻度值从大到小</li><li>setSnapToTicks(boolean b)： 是否让滑块对齐刻度。true滑块只能取刻度值</li><li>setLabelTable(Dictionary&lt;Integer, JComponent&gt; labels)：绘制特定的标签代替刻度值。Integer是刻度值，JComponent可以使JLabel等。</li><li>setPaintTrack(boolean b)： 是否绘制滑道</li><li>setOrientation(int orientation)： 方向</li></ul><p>监听器：<code>addChangeListener(ChangeListener l)</code>: 滑道值改变监听</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Calculate extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="constructor">Calculate(String <span class="params">text</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(text);</span><br><span class="line">        JTextField textField = <span class="keyword">new</span> <span class="constructor">JTextField()</span>;</span><br><span class="line">        JSlider slider = <span class="keyword">new</span> <span class="constructor">JSlider(0, 20)</span>;</span><br><span class="line"></span><br><span class="line">        slider.set<span class="constructor">MajorTickSpacing(5)</span>;</span><br><span class="line">        slider.set<span class="constructor">MajorTickSpacing(1)</span>;</span><br><span class="line">        slider.set<span class="constructor">Orientation(SwingConstants.HORIZONTAL)</span>;</span><br><span class="line">        slider.set<span class="constructor">PaintLabels(<span class="params">true</span>)</span>;</span><br><span class="line">        slider.set<span class="constructor">PaintTrack(<span class="params">true</span>)</span>;</span><br><span class="line">        slider.set<span class="constructor">PaintTicks(<span class="params">true</span>)</span>;</span><br><span class="line">        slider.set<span class="constructor">SnapToTicks(<span class="params">true</span>)</span>;</span><br><span class="line">        Hashtable&lt;Integer, JComponent&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;Integer, JComponent&gt;<span class="literal">()</span>;</span><br><span class="line">        hashtable.put(<span class="number">0</span>, <span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">"Start"</span>)</span>);      <span class="comment">//  0  刻度位置，显示 "Start"</span></span><br><span class="line">        hashtable.put(<span class="number">10</span>, <span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">"Middle"</span>)</span>);    <span class="comment">//  10 刻度位置，显示 "Middle"</span></span><br><span class="line">        hashtable.put(<span class="number">20</span>, <span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">"End"</span>)</span>);       <span class="comment">//  20 刻度位置，显示 "End"</span></span><br><span class="line">        slider.set<span class="constructor">LabelTable(<span class="params">hashtable</span>)</span>;</span><br><span class="line">        slider.add<span class="constructor">ChangeListener(<span class="params">new</span> ChangeListener()</span></span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void state<span class="constructor">Changed(ChangeEvent <span class="params">changeEvent</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                textField.set<span class="constructor">Text(<span class="string">"now is "</span> + <span class="params">slider</span>.<span class="params">getValue</span>()</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        add(slider);</span><br><span class="line">        add(textField, BorderLayout.SOUTH);</span><br><span class="line"></span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)</span>;</span><br><span class="line">        pack<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Calculate(<span class="string">"Hello"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="Robot-模拟鼠标，键盘输入"><a href="#Robot-模拟鼠标，键盘输入" class="headerlink" title="Robot 模拟鼠标，键盘输入"></a>Robot 模拟鼠标，键盘输入</h1><p>这个类主要是为了方便自动测试</p><p>构造方法：</p><ul><li>Robot(GraphicsDevice screen)： 给指定屏幕创建一个对象</li><li>Robot(): 给默认屏幕创建一个对象</li></ul><p>方法：</p><ul><li>mouseMove(int x, int y)： 把鼠标移动到某个位置</li><li>mousePress(int buttons)： 按下某个键。有InputEvent.BUTTON1_MASK （鼠标左键）和InputEvent.BUTTON2_MASK （鼠标中键）和 InputEvent.BUTTON3_MASK （鼠标右键）</li><li>mouseRelease(int buttons)</li><li>mouseWheel(int wheelAmt)：旋转滚轮</li></ul><p>键盘输入：</p><ul><li>keyPress(int keycode)： keycode定义在KeyEvent.VK_xxx中</li><li>keyRelease(int keycode)</li></ul><p>屏幕相关：</p><ul><li>Color getPixelColor(int x, int y)： 获得像素颜色</li><li>BufferedImage createScreenCapture(Rectangle screenRect)： 截屏</li></ul><p>控制：</p><ul><li>delay(int ms)： 睡眠指定时间</li><li>waitForIdle()： 在当前队列中时间完成之前一直等待</li><li>setAutoWaitForIdle(boolean isOn)： 生成一个事件之后是否自动调用waitForIdle</li><li>boolean isAutoWaitForIdle()： 设置为true，按次序执行</li><li>setAutoDelay(int ms)： 每个事件完成后自动等待ms秒。</li><li>int getAutoDelay()</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">一般测试步骤</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws AWTException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Robot 实例</span></span><br><span class="line">        Robot robot = <span class="keyword">new</span> Robot();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行完一个事件后再执行下一个</span></span><br><span class="line">        robot.setAutoWaitForIdle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动鼠标到指定屏幕坐标</span></span><br><span class="line">        robot.mouseMove(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按下鼠标左键</span></span><br><span class="line">        robot.mousePress(InputEvent.BUTTON1_MASK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延时100毫秒</span></span><br><span class="line">        robot.<span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放鼠标左键（按下后必须要释放, 一次点击操作包含了按下和释放）</span></span><br><span class="line">        robot.mouseRelease(InputEvent.BUTTON1_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 09 2020 08:11:43 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;Border边框&quot;&gt;&lt;a href=&quot;#Border边框&quot; class=&quot;headerlink&quot; title=&quot;Border边框&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 图形界面</title>
    <link href="http://xinhecuican.github.io/post/2170659a.html"/>
    <id>http://xinhecuican.github.io/post/2170659a.html</id>
    <published>2020-06-01T12:31:00.000Z</published>
    <updated>2020-06-12T01:19:35.046Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jun 14 2020 08:33:10 GMT+0800 (中国标准时间) --><h1 id="AWT-和-Swing"><a href="#AWT-和-Swing" class="headerlink" title="AWT 和 Swing"></a>AWT 和 Swing</h1><p>GUI基本类在java.awt包中，这个包也称为抽象窗口工具包（Abstract Window Toolkit，AWT）。</p><p>java.awt包中有一个抽象类Component，它是除菜单类外所有类的父类，他有如下所有组件都有的方法</p><ul><li>getBackground(): 返回背景色</li><li>getGraphics(): 返回组件用的画笔</li><li>getHeight(): 返回组件高度</li><li>getLocation(): 获得组件位置</li><li>getSize(): 获得组件大小</li><li>getWidth(): 获得组件宽度</li><li>getX(): 获得组件x值</li><li>getY():</li><li>isVisible(): 组件是否可见</li><li>setBackGround(): 设置背景色</li><li>setBackGrounds(int x, int y, int width, int height): 设置位置及大小</li><li>setEnabled(boolean b): 设置组件是否可用</li><li>setFont(Font f): 设置字体</li><li>setForground(Color c): 设置前景色</li><li>setLocation(int x, int y): 设置组件位置</li><li>setSize(int width, int height): 设置组件宽高</li><li>setSize(Dimension d): 设置组件大小</li><li>setVisible(boolean b): 设置组件是否可见</li></ul><p>Container表示容器，继承了Component类。容器用来存放别的组件。有两种容器</p><ul><li>Window(窗口)： 他有两个子类，Frame(窗体）和Dialog（对话框）。Frame带有标题，并且可以自动调整大小，Dialog可以被移动，但不能改变大小</li><li>Panel（面板）： 他不能单独存在，只能存在于其他容器（如Window或其子类）。他有一个子类Applet，Applet可以在web中运行。</li></ul><p>为了使java创建的图形界面能够跨平台，引入了Swing组件。这些组件位于javax.swing包中。接下来主要讲swing。</p><p>多数Swing的父类是JComponent(除了JFrame和JDialog外其他都继承了这个）。</p><p>JComponent的一些方法</p><ul><li>setFont(Font font): 设置字体</li><li>setForeground(Color c): 设置字体颜色</li><li>setToolTipText(String text): 设置鼠标移动到上面的时候显示的文本</li><li>setBackGround(Color c)</li><li>setOpaque(boolean isOpaque)： 设置组件是否不透明，JLabel默认是透明。不透明才可以显示背景。</li><li>setLocationRelativeTo(Component c)： 设置窗口相对于指定组件的位置。当为null时，设置为中间。中点可以使用 GraphicsEnvironment.getCenterPoint 确定。</li><li>isFocusOwner(): 判断这个组件是否拥有焦点</li></ul><p>JFrame一些方法：</p><ul><li>setIconImage(Image image)</li><li>setResizable(boolean resizable)：窗口是否可以放大缩小</li><li>setLocation(int x, int y)： 位置</li><li>setBounds(int x, int y, int width, int height)： 设置大小和宽高</li><li>Point getLocationOnScreen()： 获得位置</li><li>dispose()： 销毁窗口。如果再次使用setVisiable()会重构组件</li></ul><h1 id="创建界面基本步骤"><a href="#创建界面基本步骤" class="headerlink" title="创建界面基本步骤"></a>创建界面基本步骤</h1><p>JFrame有一个构造方法JFrame(String title)。创建一个title位标题的JFrame对象，但是创建后它是不可见的，必须要经过下列步骤才可以可见：</p><ul><li>调用setSize(int width, int height): 设置JFrame大小，或者调用peck()自动确定大小。</li><li>调用setVisible(true): 使JFrame可见</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JFrame frame = <span class="keyword">new</span> JFrame(<span class="string">"Hello"</span>);</span><br><span class="line">    jframe.setSize(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    jframe.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>每个JFrame都会有内容面板(contentpane)，加入JFrame容器的组件实际上都是加入这个面板中</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Container content = jframe.getContentPane()<span class="comment">;</span></span><br><span class="line">content.add(jButton)<span class="comment">;//加入按钮组件</span></span><br></pre></td></tr></table></figure></div><p>add()方法直接向与之关联的内容面板加入组件，所以可以直接<code>jframe.add(jButton)</code>.</p><p>JFrame的setContentPane(Container content)用来重新设置面板。</p><p>JFrame的setDefaultCloseOperation(int operation)用来设置如何相应关闭操作<br>operation可以有以下操作</p><ul><li>JFrame.DO_NOTHING_ON_CLOSE: 什么也不做</li><li>JFrame.HIDE_ON_CLOSE: 隐藏窗体，这是默认选项</li><li>JFrame.DISPOSE_ON_CLOSE: 销毁窗体</li><li>JFrame.EXIT_ON_CLOSE: 结束程序</li></ul><h1 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h1><p>JFrame的默认布局管理器是BorderLayout，JPanel默认布局管理器是FlowLayout。</p><p>可以通过setLayout(Layout layout)设置布局。也可以通过setLayout(null)取消布局管理器，但是接下来要自己去管理布局，并且现在每个操作系统不同。</p><h2 id="FlowLayout-流式布局管理器"><a href="#FlowLayout-流式布局管理器" class="headerlink" title="FlowLayout 流式布局管理器"></a>FlowLayout 流式布局管理器</h2><p>他按照组件先后顺序从左到右放到容器中，到达边界时，会放置到下一行。</p><p>当容器被缩放时，组件位置可能变化，但是组件大小不会改变</p><p>构造方法：</p><ul><li>FlowLayout()</li><li>FlowLayout(int align)</li><li>FlowLayout(int align, int hgap, int vgap):align设置对齐方式，可以有FlowLayout.LEFT,FlowLayout.RIGHT, FlowLayout.CENTER. hgap和vgap设置组件间水平和垂直间隙</li></ul><h2 id="BorderLayout（边界布局管理器）"><a href="#BorderLayout（边界布局管理器）" class="headerlink" title="BorderLayout（边界布局管理器）"></a>BorderLayout（边界布局管理器）</h2><p>他把容器分成五个区域：东西南北中。</p><ul><li>它的东和西组件保持最佳宽度，高度拉伸至和所在区域一样高。南北保持最佳高度，宽度和这个区域一样宽。中间和这个区域一样大。</li><li>窗口垂直拉伸时，东西中拉伸，当窗口垂直拉伸时，南北中拉伸。</li><li>窗口缩放时，组件相对位置不变，但是组件大小改变</li><li>如果某个区域组件添加不止一个，只有最后一个是可见的。</li></ul><p>构造方法：</p><ul><li>BorderLayout()</li><li>BorderLayout(int hgap, int vgap)</li></ul><p>添加组件： void add(Component comp, Object constraints)。其中constraints是区域，可以是BorderLayout.NORTH,BorderLayout.SOUTH，BorderLayout.EAST,BorderLayout.WEST,BorderLayout.CENTER. 默认是中</p><p>还可以直接用字符串设置区域。但是首字母必须大写，其他必须小写。<code>f.add(new JButton(&quot;b1&quot;), &quot;North&quot;)</code></p><h2 id="GridLayout-网格布局管理器）"><a href="#GridLayout-网格布局管理器）" class="headerlink" title="GridLayout(网格布局管理器）"></a>GridLayout(网格布局管理器）</h2><p>他把容器分成许多行和列，添加组件时首先防止到左上角网格中，然后从左到右放置其他组件。</p><ul><li>组件相对位置不会随缩放而改变，但是组件大小会改变。</li><li>他总是忽略组件最佳大小，所有组件宽度相同，高度也相同</li></ul><p>构造方法：</p><ul><li>GridLayout()</li><li>GridLayout(int rows, int cols)</li><li>GirdLayout(int rows, int cols, int hgap, int vgap)</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculater</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">JFrame</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JPanel panel;</span><br><span class="line">    <span class="keyword">private</span> JLabel label;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span>[] name = &#123;<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"+"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"-"</span>,<span class="string">"1"</span>,<span class="string">"2"</span></span><br><span class="line">    ,<span class="string">"3"</span>,<span class="string">"*"</span>,<span class="string">"0"</span>,<span class="string">"."</span>,<span class="string">"="</span>,<span class="string">"/"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> JButton[] buttons = <span class="keyword">new</span> <span class="type">JButton</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">public</span> Calculater(<span class="keyword">String</span> title)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">    &#125;</span><br><span class="line">    label = <span class="keyword">new</span> <span class="type">JLabel</span>(<span class="string">"    "</span>);</span><br><span class="line">    panel = <span class="keyword">new</span> <span class="type">panel</span>();</span><br><span class="line">    panel.setLayout(<span class="keyword">new</span> <span class="type">GridLayout</span>(<span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line">    add(label, BorderLayout.NORTH);</span><br><span class="line">    add(panel, BorderLayout.CENTER);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;buttons.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buttons[i] = <span class="keyword">new</span> <span class="type">JButton</span>(name[i]);</span><br><span class="line">        panel.add(buttons[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    pack();</span><br><span class="line">    setVisible();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Calculater</span>(<span class="string">"Calculater"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这是一个计算器的图形界面，可以看到外面采用了BorderLayout，里面面板采用了GridLayout。</p><h2 id="CardLayout"><a href="#CardLayout" class="headerlink" title="CardLayout"></a>CardLayout</h2><p>他将界面看成一系列的卡片，任何时候只有一张卡片可见。</p><p>构造方法：</p><ul><li>CardLayout()</li><li>CardLayout(int hgap, int vgap)</li></ul><p>添加组件 void add(Component comp, Object constraints)。其中constraints实际上是一个字符串，表示卡片的名字。默认显示第一张卡片，可以采用show(Container parent, String name)指定显示哪一张卡片。parent指定容器</p><h2 id="GridBagLayout（网格包-布局管理器）"><a href="#GridBagLayout（网格包-布局管理器）" class="headerlink" title="GridBagLayout（网格包 布局管理器）"></a>GridBagLayout（网格包 布局管理器）</h2><p>创建步骤：</p><ul><li>创建GridBagLayout，并启用<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GridBagLayout layout = <span class="keyword">new</span> <span class="constructor">GridBagLayout()</span>;</span><br><span class="line">container.set<span class="constructor">Layout(<span class="params">layout</span>)</span>;</span><br></pre></td></tr></table></figure></div></li><li>创建一个GridBagConstraints对象<code>GridBagConstraints constraints = new GridBagConstraints();</code></li><li>配置a的各种属性<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="INI"><figure class="iseeu highlight /ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">constraints.gridx</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">constraints.gridy</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">constraints.gridwidth</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">constraints.gridwidth</span> = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></div></li><li>设置布局信息<code>lyout.setConstraints(component1, constraints)</code></li><li>加入容器<code>container.add(component1)</code></li></ul><p>其中GridBagConstraints只需要设置一个，然后重复设置里面属性即可。</p><p>这种布局器最为自由，可以完全自己配置，但是首先要画一个草图先规划好各个组件的坐标。</p><p>GridBagConstraints的属性：</p><ul><li>gridx和gridy： 左上角横纵坐标。最左边是（0，0）。默认值是RELATIVE，即最新添加元素后面</li><li>gridwidth，gridheight： 宽和高。默认值是1</li><li>fill： 当某组件显示区域大于他所要求大小时使用。可以设置如下取值<ul><li>GridBagConstraints.NONE: 默认，不改变组件大小</li><li>GridBagConstraints.HORIZONTAL: 填充水平方向，不改变水平大小</li><li>GridBagConstraints.VERTICAL: 填充垂直方向</li><li>GridBagConstraints.BOTH: 水平垂直都扩大以适应大小</li></ul></li><li>ipadx，ipady： 指定内部填充大小，即最小尺寸下还要加多少。宽度和高度都至少要加ipadx/ipady</li><li>insets: 指定外部填充大小。组件和区域边界之间最小区域大小，例如<code>a.insets = new Insets(1, 1, 1, 1);//上左下右边距</code></li><li>anchor: 当组件小于区域的时候使用。决定了在区域中的位置，有GridBagContraints.CENTER,等九个区域（包括NORTHEAST等角上区域）</li><li>weightx，weighty： 水平重量和垂直重量。他们决定拉伸时谁将占据空白区域。注意每一行或每一列至少要有一个占据重量，不然拉伸时组件大小将不会发生改变，从而导致周围空白。</li></ul><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>每一个可以触发的事件都是事件源，每一种事件都会有相应的监听器，监听器负责接受和处理这些事件。一个事件源可以触发多种事件，事件源可以使按钮，键盘，鼠标等，他们可以产生时间如按键，按按钮，点击然后触发事件处理。</p><h2 id="事件处理的实现"><a href="#事件处理的实现" class="headerlink" title="事件处理的实现"></a>事件处理的实现</h2><p>每个具体的事件都是某个事件类的实例，事件类有： ActionEvent，ItemEvent，MouseEvent，KeyEvent，FocusEvent，WindowEvent等。每个事件类对应一个事件监听接口，如ActionEvent对应ActionListener。</p><p>如果程序需要处理某种事件，就需要实现这些接口。</p><p><strong>用内部类实现接口</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> ButtonCounter extends JFrame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JButton button = <span class="keyword">new</span> <span class="constructor">JFrame(<span class="string">"1"</span>)</span>;</span><br><span class="line">    public <span class="constructor">ButtonCounter(String <span class="params">title</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(title);</span><br><span class="line">        <span class="comment">//注册监视器</span></span><br><span class="line">        button.add<span class="constructor">ActionListener(<span class="params">new</span> ActionListener()</span>&#123;</span><br><span class="line">            public void action<span class="constructor">Performed(ActionEvent <span class="params">evt</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> count = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">button</span>.<span class="params">getText</span>()</span>);</span><br><span class="line">                button.set<span class="constructor">Text(<span class="params">new</span> Integer(<span class="operator">++</span><span class="params">count</span>)</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add(button);</span><br><span class="line">        set<span class="constructor">Size(100, 100)</span>;</span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>使用容器类实现接口</strong></p><p>可以用容器类实现多个监听接口。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> FrmaeCounter extends JFrame implements ActionListener</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> JButton button = <span class="keyword">new</span> <span class="constructor">JButton(<span class="string">"1"</span>)</span>;</span><br><span class="line">    public <span class="constructor">FrameCounter(String <span class="params">title</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        super(title);</span><br><span class="line">        <span class="comment">//注册监听器</span></span><br><span class="line">        button.add<span class="constructor">ActionListener(<span class="params">this</span>)</span>;</span><br><span class="line">        add(button);</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class="line">        set<span class="constructor">Szie(100, 100)</span>;</span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void action<span class="constructor">Performed(ActionEvent <span class="params">evt</span>)</span><span class="comment">//实现接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">button</span>.<span class="params">getText</span>()</span>);</span><br><span class="line">        button.set<span class="constructor">Text(<span class="params">new</span> Integer(<span class="operator">++</span><span class="params">count</span>)</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>它可以让按钮中的数字按一次就加一</p><p><strong>定义顶层类实现接口</strong></p><p>创建一个专门用来处理事件的类，优点是可以使处理时间的代码和创建GUI的代码分离，缺点是监听类无法直接访问事件源，必须通过事件类的getSource()方法获得事件源。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="class"><span class="keyword">class</span> <span class="title">OuterCounter</span> <span class="title">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> JButton button = <span class="keyword">new</span> JButton(<span class="string">"1"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterCounter</span><span class="params">(<span class="keyword">String</span> title)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        super(title);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> MyListener(<span class="number">2</span>));<span class="comment">//创建监听器</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="title">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">step</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyListener</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">step</span> = <span class="built_in">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent evt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JButton button = (JButton)evt.getSource();<span class="comment">//获得事件源</span></span><br><span class="line">        <span class="keyword">int</span> count = Integer.<span class="built_in">parseInt</span>(button.getText());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当有动作（按按钮）产生时，会产生ActionEvent让Mylistener处理，如果是在一个类里，我们可以直接使用这个事件源（按钮），但是如果是其他类，就需要ActionEvent的getSource()来获得事件源（谁产生的设个事件）。</p><p><strong>事件适配器</strong></p><p>如果实现监听街口，就必须实现里面所有的方法。MouseListener有五个方法：mousePressed(),mouseReleased(),mouseEntered(),mouseExited(),<br>mouseClicked();在实际应用中，往往用不到这么多方法，因此可以使用适配器，适配器中实现了所有方法，但是都是空。例如MouseListener适配器类就是MouseAdapter</p><h2 id="事件源，时间和监听器之间的关系"><a href="#事件源，时间和监听器之间的关系" class="headerlink" title="事件源，时间和监听器之间的关系"></a>事件源，时间和监听器之间的关系</h2><h3 id="事件和监听接口"><a href="#事件和监听接口" class="headerlink" title="事件和监听接口"></a>事件和监听接口</h3><table><thead><tr><th>事件</th><th>监听接口</th><th>抽象方法</th></tr></thead><tbody><tr><td>Action</td><td>ActionListener</td><td>actioPerformed(ActionEvent evt)</td></tr><tr><td>ItemEvent</td><td>ItemListener</td><td>itemStateChanged(ItemEvent)</td></tr><tr><td>MouseEvent</td><td>MouseMotionListener</td><td>mouseDargged(MouseEvent)/mouseMoved(MouseEvent)</td></tr><tr><td>MouseEvent</td><td>MouseListener</td><td>mousePressed()/mouseReleased()/mouseEntered()/ mouseExited()/mouseClicked()</td></tr><tr><td>KeyEvent</td><td>KeyListener</td><td>keyPressed()/keyReleased()/keyTyped()</td></tr><tr><td>FocusEvent</td><td>FocusListener</td><td>focusGained()/foucusLost()</td></tr><tr><td>AdjustmentEvent</td><td>AdjustmentListener</td><td>adjustmentValueChanged()</td></tr><tr><td>ComponentEvent</td><td>ComponentListneer</td><td>componentMoved()/ componentResized()/componentShown()</td></tr><tr><td>WindowEvent</td><td>WinodwListener</td><td>windowClosing()/windowOpened()/ windowIconified()/windowDeiconfied()/ windowclosed() /windowActivated()/windowDeativated()</td></tr><tr><td>ContainerEvent</td><td>ContainerListener</td><td>componentAdded()/componentRemoved()</td></tr><tr><td>Textevent</td><td>TextListener</td><td>textValueChanged()</td></tr></tbody></table><p>MouseListener和MouseMotionListener都是监听MouseEvent。MouseMotionListener监听和鼠标移动相关事件。他们有以下方法</p><ul><li>mouseMoved(): 用户未按下鼠标直接移动时调用此方法</li><li>mouseDragged(): 按下鼠标并拖动</li><li>mouseClicked(): 单击鼠标</li><li>mosuePressed(): 按下鼠标</li><li>mouseReleased(): 释放鼠标</li><li>mouseExited(): 退出组件区域</li><li>mouseEntered(): 进入组件区域</li></ul><p><strong>组件及监听接口</strong></p><p>组件可以通过addxxxlistener方法注册监听器（监听器就是上面第二列）。</p><p><strong>适配器</strong></p><table><thead><tr><th>监听接口</th><th>监听器</th></tr></thead><tbody><tr><td>ComponentListener</td><td>ComponentAdapter</td></tr><tr><td>FocusListener</td><td>FocusAdapter</td></tr><tr><td>KeyListener</td><td>KeyAdapter</td></tr><tr><td>MouseListener</td><td>MouseAdapter</td></tr><tr><td>MouseMotionListener</td><td>MouseMotionAdapter</td></tr><tr><td>ContainerListener</td><td>ContainerAdapter</td></tr><tr><td>WindowListener</td><td>有</td></tr><tr><td>ItemListener</td><td>没有</td></tr><tr><td>ActionListener</td><td>没有</td></tr><tr><td>InputMethodListener</td><td>没有</td></tr></tbody></table><p>基本上有多个抽象方法的都有适配器</p><h1 id="AWT绘图"><a href="#AWT绘图" class="headerlink" title="AWT绘图"></a>AWT绘图</h1><p>在component中有两个和绘图有关方法：</p><ul><li>paint(Graphics g): 绘制组件外观</li><li>repaint(): 调用paint(),刷新组件的外观（对于awt组件来说调用repaint前还要调用update方法）</li></ul><p>在下列情况中，会调用paint：</p><ul><li>第一次显示在屏幕上时</li><li>组件大小发生变化时</li><li>调用repaint</li></ul><p>JComponent覆盖了paint，并将会话任务委托给三个protected的方法：</p><ul><li>paintComponent(): 画当前组件，</li><li>paintBorder(): 画边界</li><li>paintChildren(): 如果这个组件时容器，则画容器包含的组件</li></ul><p>JComponent会议组件背景色覆盖整个区域，所以如果画了图形想清除的话只需要调用super.paintComponent().</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorChange</span> <span class="keyword">extends</span> <span class="title">JPanel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Color color = Color.RED;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> times;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorChange</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"change color"</span>);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                color = (color==Color.RED) ? Color.GREEN : Color.RED;</span><br><span class="line">                repaint();<span class="comment">//刷新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add(button);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.paintComponent(g);<span class="comment">//清空画板</span></span><br><span class="line">        g.setColor(color);</span><br><span class="line">        g.fillReet(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);<span class="comment">//画矩形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame(<span class="string">"Hello"</span>);</span><br><span class="line">        frame.setContentPane(<span class="keyword">new</span> ColorChanger());</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面就重写了paintComponent方法，然后repaint()调用的就是重写后的方法。</p><h2 id="Graphics"><a href="#Graphics" class="headerlink" title="Graphics"></a>Graphics</h2><p>Graphics代表画笔，提供了各种绘制图形的方法：</p><ul><li>drawLine(int x1, int y1, int x2, int y2): 画一条直线</li><li>drawString(String string, int left, int bottom): 写字符串</li><li>drawImage(Image image, int left, int top, ImageObserver observer):画一个图片</li><li>drawRect(int left, int top, int width, int height): 画一个矩形</li><li>drawOval(int x, int y, int width, int height):画一个椭圆</li><li>fillRect(int left, int top, int width, int height): 填充矩形</li><li>fillOval(int x, int y, int width, int height): 填充一个椭圆</li></ul><p>其中left，top是左上角坐标。</p><p>如果没有调用Graphics的setColor()方法,将以前景色填充</p><p>使用完之后要用dispose()进行销毁</p><p>drawString(String str, int x, int y)将用当前画笔颜色和字体，将str显示.字符的左下角是(x,y)</p><h2 id="Graphics2D"><a href="#Graphics2D" class="headerlink" title="Graphics2D"></a>Graphics2D</h2><p>方法：</p><ul><li>setStroke(Stroke s)； 获得画笔的特性</li><li>draw(Shape shape): 滑参数指定的图形</li><li>fill(Shape shape): 填充参数指定的图形</li><li>translate(int x, int y)： 平移</li><li>rotate(double theta, double originX, double originY)：旋转</li><li>scale(double sx, double sy)： 缩放</li></ul><p>一般使用BasicStroke类。构造方法是<code>BasicStroke(float width, int cap, int join, float miterlimit, float[] dash, float_phase)</code>：</p><ul><li>width：笔画宽度，此宽度必须大于或等于0.0f。如果将宽度设置为0.0f，则将笔画设置为当前设备的默认宽度</li><li>cap：线端点的装饰</li><li>join：应用在路径线段交汇处的装饰</li><li>miterlimit：斜接处的裁剪限制。该参数值必须大于或等于1.0f</li><li>dash：表示虚线模式的数组</li><li>dash phase：开始虚线模式的偏移量</li></ul><p>他还有一些绘制图形的类</p><ul><li>java.awt.geom.Line2D: 画直线</li><li>java.awt.geom.Ellipse2D: 画椭圆</li><li>java.awt.geom.Rectangle2D: 画矩形</li></ul><p>上面这些画图形的都是抽象类，他们都有两个子类：Double和Float。例如LineD.Double。</p><p>上面这些实现类的构造方法和前面说的draw大致相似。</p><p>还可以利用java.awt.Toolkit的getScreenSize()来获得屏幕大小，从而设定JFrame大小。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>虚拟机中会创建一个专门的awt线程处理窗口，但是需要我们专门添加，添加代码<code>SwingUtilities.invokeLater(Runnable doRun)</code></p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处处于 主线程，提交任务到 事件调度线程 创建窗口</span></span><br><span class="line">        SwingUtilities.invokeLater(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                        <span class="comment">// 此处处于 事件调度线程</span></span><br><span class="line">                        createGUI();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>上面的线程只是用来创建窗口，绘图等不耗时的工作。<a href="https://blog.csdn.net/xietansheng/article/details/78389265" target="_blank" rel="external nofollow noopener noreferrer">详细可看</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jun 14 2020 08:33:10 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;AWT-和-Swing&quot;&gt;&lt;a href=&quot;#AWT-和-Swing&quot; class=&quot;headerlink&quot; title=&quot;AWT 和 Sw
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 常用类</title>
    <link href="http://xinhecuican.github.io/post/85b4e13b.html"/>
    <id>http://xinhecuican.github.io/post/85b4e13b.html</id>
    <published>2020-05-29T11:14:00.000Z</published>
    <updated>2020-06-01T12:41:48.237Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 01 2020 20:41:48 GMT+0800 (中国标准时间) --><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Object是所有java类共同的祖先。如果没有用extends，那么这个类将直接继承Object类。</p><p>Object类有一个默认构造方法，构造子类实例时，都会优先使用这个构造方法。</p><p><code>public Object(){}</code></p><p>方法：</p><ul><li>equals(Object obj): 比较两个对象是否相等，只有当两个变量引用一个实例时才会为真。</li><li>notify()</li><li>notifyAll()</li><li>wait()</li><li>hashCode(): 返回对象哈希码。</li><li>toString(): 返回当前对象字符串表示。如果println方法参数时Object，那么先会调用toString()</li><li>finalize(): 垃圾回收时先调用这个方法</li><li>getClass(): 返回运行时类。java引用变量有两种类型，编译时类型和运行时类型。运行时类型就是引用的实例。</li></ul><h1 id="String-和-StringBuffer"><a href="#String-和-StringBuffer" class="headerlink" title="String 和 StringBuffer"></a>String 和 StringBuffer</h1><p>String是不可变类，里面字符串永远不会改变(也就是平常用双引号括起来的那些),StringBuffer是可变类</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>构造方法：</p><ul><li>String()</li><li>String(String value):</li><li>String(char[] value): 会把字符数组转换成字符串</li><li>String(byte[] bytes): 会用本地默认编码把字节数组变成字符串</li><li>String(byte[] bytes, String charsetName): 根据charsetName指定的编码，构造字符串。</li></ul><p>方法：</p><ul><li>length()</li><li>char charAt(int index): 返回index上的字符</li><li>getChars(int srcBegin, int srcEnd, char[] dst, int dstbegin): 从当前字符串复制字符到dst中，srcBegin开始取字符，到srcEnd-1结束</li><li>equals(object str): 判断两个字符串是否相等</li><li>equalsIgnoreCase()： 忽略大小写</li><li>int compareTo(String str): 比较字符串大小</li><li>indexOf()和lastIndexOf(): 在字符串中检索特定字符或字符串，indexOf()从开始位置查找，另一个从后面开始查找<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str.index<span class="constructor">Of('<span class="params">e</span>')</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str.index<span class="constructor">Of(<span class="string">"ea"</span>, 2)</span>); <span class="comment">//从2开始</span></span><br></pre></td></tr></table></figure></div></li><li>concat(String str): 把str加载末尾</li><li>substring(): 返回子串，参数中可以有开始和结束位置</li><li>String[] split(String regex): 根据参数把字符串分成几个子串，例如根据空格分隔</li><li>replaceAll(String regex, String replacement): 把原来字符串中regrex换成replacement。replaceFirst()只替换第一个</li><li>trim(): 把字符串首尾空格删除</li><li>String valueOf(): 把基本类型转换成String类型。</li><li>toUpperCast()/toLowerCast(): 把字符串变成大小写</li></ul><h3 id="“hello”-和-new-String-“hello”-区别"><a href="#“hello”-和-new-String-“hello”-区别" class="headerlink" title="“hello” 和 new String(“hello”)区别"></a>“hello” 和 new String(“hello”)区别</h3><p>第一种： String s1 = “hello”</p><p>第二种： String s2 = new String(“hello”)</p><p>第一种方式hello是立即数，Java虚拟机只会分配一次内存（在data节中）。第二种方式是建立一个对象，每次新建一个对象都会重新分配一次内存。所以用第一种方式赋相同值给两个变量用equal()比较时true，而而第二种不是。</p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>构造方法：</p><ul><li>StringBuffer()</li><li>StringBuffer(int length)</li><li>StringBuffer(String str)：缓冲区初始字符串是str，并且提供16字节的额外缓冲区</li></ul><p>方法：</p><ul><li>length()</li><li>append(): 向缓冲区内添加字符串</li><li>toString(): 返回缓冲区内字符串</li><li>charAt(int index)</li><li>setCharAt(int index, char c): 在index处放c</li><li>getChars(int Begin, int end, char[] dst, int dstBegin):</li><li>subString()</li><li>insert(int offset, String str): 在offset位置插入字符串（字符串首位置在offset处）</li></ul><h2 id="String和StringBuffer区别"><a href="#String和StringBuffer区别" class="headerlink" title="String和StringBuffer区别"></a>String和StringBuffer区别</h2><p>String是不可变类。即使看上去提供了replaceAll()的修改方法实际上它是创建了一个新的字符串。而StringBuffer是在自身基础上进行修改。</p><p>String覆盖了equals()方法。</p><p>String对象可以用+号进行拼接，而StringBuffer不可以</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>就是用一些特殊字符来代替多个字符进行匹配</p><table><thead><tr><th>特殊字符</th><th>作用</th></tr></thead><tbody><tr><td>.</td><td>任意字符</td></tr><tr><td>[…]</td><td>匹配中括号中所有数据，例如[abc]可以匹配a或b或c</td></tr><tr><td>[^…]</td><td>匹配除括号数据外的任意数据</td></tr><tr><td>\s</td><td>空白符（空格，tab，换行，换页，回车）</td></tr><tr><td>\S</td><td>非空白符</td></tr><tr><td>\d</td><td>任意数字</td></tr><tr><td>\D</td><td>任意非数字</td></tr><tr><td>\w</td><td>大小写字母和数字</td></tr><tr><td>\W</td><td>除了大小写和数字外的字符</td></tr></tbody></table><p><a href="https://xinhecuican.github.io/post/26477.html">更多可以看这里</a></p><h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><p>String类的静态方法format()用于创建格式化字符串</p><ul><li>String format(String format, Object… args)</li><li>String format(Locale locale, String format, Object… args): locale指定语言</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(String.format(Locale.CHINESE, "%tc", <span class="type">date</span>));</span><br></pre></td></tr></table></figure></div><h2 id="日期，时间格式化"><a href="#日期，时间格式化" class="headerlink" title="日期，时间格式化"></a>日期，时间格式化</h2><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>%tb</td><td>月份简称，8月</td></tr><tr><td>%dB</td><td>全称</td></tr><tr><td>%ta</td><td>星期几</td></tr><tr><td>%tA</td><td>星期几全称</td></tr><tr><td>%ty</td><td>2位年份，如20</td></tr><tr><td>%tY</td><td>4位年份，如2020</td></tr><tr><td>%tm</td><td>月份，08</td></tr><tr><td>%te</td><td>一月中第几天</td></tr><tr><td>%tj</td><td>一年中第几天</td></tr><tr><td>%tc</td><td>具体时间和日期</td></tr><tr><td>%tF</td><td>年-月-日，四位年</td></tr><tr><td>%tD</td><td>年/月/日，两位年</td></tr><tr><td><strong>时间</strong></td><td></td></tr><tr><td>%tH</td><td>24时制（00-23）</td></tr><tr><td>%tI</td><td>十二小时（01-12）</td></tr><tr><td>%tk</td><td>24时（0-23）</td></tr><tr><td>%tl</td><td>12时（0-12）</td></tr><tr><td>%tM</td><td>分钟</td></tr><tr><td>%tS</td><td>秒</td></tr><tr><td>%tL</td><td>毫秒</td></tr><tr><td>%tN</td><td>微秒</td></tr><tr><td>%tp</td><td>上午下午标记</td></tr><tr><td>%tz</td><td>时区偏移量</td></tr><tr><td>%tZ</td><td>时区缩写</td></tr></tbody></table><h2 id="常规类型"><a href="#常规类型" class="headerlink" title="常规类型"></a>常规类型</h2><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>%b</td><td>布尔类型</td></tr><tr><td>%B</td><td>大写</td></tr><tr><td>%h,%H</td><td>哈希码</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%S</td><td>大写字符串</td></tr><tr><td>%c</td><td>字符</td></tr><tr><td>%C</td><td>大写</td></tr><tr><td>%d</td><td>十进制整数</td></tr><tr><td>%o</td><td>八进制</td></tr><tr><td>%x</td><td>十六进制</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%e</td><td>科学记数法表示的十进制</td></tr><tr><td>%n</td><td>换行</td></tr></tbody></table><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Stirng</span>.</span></span>format(<span class="string">"hi%s"</span>, <span class="string">"小红"</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"%c%n"</span>, <span class="character">'A'</span>);</span><br></pre></td></tr></table></figure></div><p>使用大致和c语言类似。</p><table><thead><tr><th>转换符号</th><th>含义</th></tr></thead><tbody><tr><td>转换符号</td><td>它是在%后面字符前面的,例如”%+d”</td></tr><tr><td>+</td><td>为数字添加正负号</td></tr><tr><td>-</td><td>左对齐</td></tr><tr><td>0</td><td>数字前补零，例如 “%04d” 表示如果数字不满四位前面要补零</td></tr><tr><td>(</td><td>添加括号，例如(“%(d”, 99) ,输出 (99)</td></tr><tr><td>#</td><td>如果是十六或十进制前面添加0x或0,如果是浮点数添加小数点</td></tr></tbody></table><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>每个基本类型都有一个包装类。包装类就是对应基本类型然后首字母大写（int,char除外）。例如int Integer float Float.char是Character</p><p>构造方法：</p><p>都可以用字符串作为参数来构造。Boolean类型可以用”true”或”false”。</p><p>除了Character和Boolean外其他类都是继承于Number类。</p><p>Number类方法如下：</p><ul><li><p>byteValue(): 返回Number对象的byte类型</p></li><li><p>intValue():</p></li><li><p>longValue()</p></li><li><p>shortValue()</p></li><li><p>doubleValue()</p></li><li><p>floatValue()</p></li><li><p>包装类都覆盖了toString()方法</p></li><li><p>都有parsexxx(String str)静态方法，可以把字符串转化成相应数据。例如parseint(“123”)</p></li></ul><h3 id="包装类自动装箱和拆箱"><a href="#包装类自动装箱和拆箱" class="headerlink" title="包装类自动装箱和拆箱"></a>包装类自动装箱和拆箱</h3><p>就是在基本类型和包装类之间进行转换。可以直接用基本类型赋值给包装类，也可以直接用包装类赋值给基本类型。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EBNF"><figure class="iseeu highlight /ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Integer a</span> = 3;</span><br><span class="line"><span class="attribute">int b</span> = new Integer(4);</span><br></pre></td></tr></table></figure></div><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>Math类里面基本上都是静态方法，并且他的构造方法时private，不能有实例。而且是final类型，不能有子类。</p><p>方法：</p><ul><li>abs()</li><li>ceil(): 向上取整</li><li>floor(): 向下取整</li><li>max()</li><li>min()</li><li>random(): 返回0到1间double类型的随机数。包括0，不包括1</li><li>round(): 四舍五入整数</li><li>sin()</li><li>cos()</li><li>tan()</li><li>exp(): 根号x</li><li>sqrt(): x的平方</li><li>pow(): 幂运算</li></ul><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>和Math类似</p><p>方法：</p><ul><li>nextInt(): 返回一个int型随机数，随机数大于等于0</li><li>nextInt(int n): n是随机数最大值</li><li>nextLong()</li><li>nextFloat()</li><li>nextDouble()</li><li>nextBoolean()</li></ul><h2 id="处理时间类"><a href="#处理时间类" class="headerlink" title="处理时间类"></a>处理时间类</h2><p><strong>Date</strong></p><p>Date类以毫秒方法日期。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="type">date</span> = <span class="built_in">new</span> <span class="type">Date</span>();</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.prtinln(<span class="type">date</span>);</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Sun Aug21 <span class="number">17</span>:<span class="number">32</span>:<span class="number">05</span> CST <span class="number">2016</span></span><br></pre></td></tr></table></figure></div><p><strong>DateFormat</strong></p><p>它可以定制日期格式</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LASSO"><figure class="iseeu highlight /lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span> <span class="built_in">date</span> = <span class="literal">new</span> <span class="built_in">Date</span>();</span><br><span class="line">SimpleDateFormat f = <span class="literal">new</span> SimpleDateFormat(<span class="string">"yyyy-MMMM-dd-EEEE"</span>);</span><br><span class="line">这些都是表示显示几位的年月日的.E是星期</span><br></pre></td></tr></table></figure></div><h2 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger BigDecimal"></a>BigInteger BigDecimal</h2><p>BigInteger可以接受任意位的整数运算。他有add(BigInteger b),subtract(BigInteger b) multiply(BigInteger b) divide(BigInteger b)等方法来进行四则运算</p><p>BigDecimal可以进行精确的浮点数运算。对于加减乘都是准确的，对于除法可以指定小数位和舍入模式。</p><p>divide(BigDeciaml b, int scale, RoundingMode more)more是舍入模式。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 01 2020 20:41:48 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://xinhecuican.github.io/post/a444b428.html"/>
    <id>http://xinhecuican.github.io/post/a444b428.html</id>
    <published>2020-05-25T05:32:00.000Z</published>
    <updated>2020-06-29T06:35:44.518Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 29 2020 14:35:44 GMT+0800 (中国标准时间) --><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>稳定？不稳定： 稳定指的是两个相同的元素排序完成之后在表中相对位置不变。</p><h2 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h2><p>当插入第i个时，前i-1个已经排好了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        tag = a[i];</span><br><span class="line">        <span class="built_in">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i<span class="number">-1</span>; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k]&gt;tag)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">                temp = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[k+<span class="number">1</span>] = tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>默认第一个已经排好，从第二个开始从后往前排，如果第k个数比要比较的数大就把这个数往后排。</p><p>复杂度： n^2</p><h2 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h2><p>折半排序基于前面的直接插入，不同的是它通过二分找插入位置。然后再移动</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    tag = a[i];</span><br><span class="line">    <span class="built_in">int</span> low=<span class="number">0</span>, high=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;tag)</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//high+1是插入位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=i<span class="number">-1</span>; k&gt;=high+<span class="number">1</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    a[high+<span class="number">1</span>] = tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度 n^2</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>思想： 把序列按gap划分成若干个子序列。例如有6个元素，gap是3，那么第0个和第3个是一个序列，第1个和第4个是一个序列。之后在每个子序列中直接插入。然后折半缩小gap。</p><p>第一个gap一般取n/2。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> gap = n/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(gap != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=gap; i&lt;n; i++)<span class="comment">//从gap开始是因为直接插入排序中默认第一个已经排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        tag = a[i];</span><br><span class="line">        <span class="built_in">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i-gap; k&gt;=<span class="number">0</span>; k-=gap)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k]&gt;tag)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k+tag] = a[k];</span><br><span class="line">                temp = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[temp+tag] = tag;</span><br><span class="line">    &#125;</span><br><span class="line">    gap /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度：n(longn)^2。但这是一种不稳定的排序</p><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><p>起泡排序是过程是逐个比较，比较出最小的放到第一个，然后放到第二个。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> flag=<span class="number">0</span>,exchange=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag&lt;n<span class="number">-1</span> &amp;&amp; exchange==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    exchange = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n<span class="number">-1</span>; i&gt;flag; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a[i<span class="number">-1</span>] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            a[i] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            a[i<span class="number">-1</span>] = a[i] ^ a[i<span class="number">-1</span>];</span><br><span class="line">            exchange = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这一步后小的在前面，然后下一次又是把i-1和i-2比，如果i-1小，又跑到前面</span></span><br><span class="line">        <span class="comment">//这样第i-1个一直是最小的（相对于它后面的元素）</span></span><br><span class="line">    &#125;</span><br><span class="line">    flag++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度 n^2</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><a href="https://xinhecuican.github.io/post/11306.html">以前的一篇</a></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><p>这个就不多说了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> min = <span class="number">2147483647</span>;</span><br><span class="line"><span class="built_in">int</span> tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k=i+<span class="number">1</span>; k&lt;n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[k]&lt;min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = a[k];</span><br><span class="line">            tag = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap（a[i], a[tag]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是完全二叉树产生的数组。然后建立一个父节点比子节点大/小的数组。父节点比子节点大的叫大顶堆，父节点比子节点小的叫小顶堆。</p><p>假设父节点是i，那么两个子节点分别是i<em>2和i</em>2+1。下标要从1开始</p><p>过程，以小顶堆为例</p><ul><li>初始化，首先构造一个大顶堆，过程是用这个节点和它的父节点进行比较，如果小就交换位置，然后再和新位置的父节点进行比较。先拿第一个数和第二个数进行比较，如果第一个数比第二个数小那个交换位置。然后第三个数和第一个数比较。此外，还可以从小到大直接建</li></ul><p>之后第4个数是插入到第二个数上的，就拿第四个数和第二个数比较，如果第四个数比第二个数小就把第二个数往上提，之后再和第一个数进行比较。然后依此类推。</p><p><img src="/images/%E6%8E%92%E5%BA%8F.png" alt></p><ul><li>把第一个元素和最后一个元素进行交换，然后对前n-1个元素进行处理。开始我们建立的是大顶堆，现在我们把最大的放到后面就变成小顶堆了。并且这时不仅满足小顶堆，还满足左儿子一定比右儿子小。</li></ul><p><img src="/images/%E6%8E%92%E5%BA%8F2.png" alt></p><ul><li>之后就是用根节点左右儿子中比较大的节点和根节点进行比较。然后如果比根节点大就进行换位。然后再在新位置和新的子节点进行比较。完成之后又把根节点放到最后。之后就重复第二步和第三步。（不画图了，难死我了）</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据上面自己写的，拿过几个数据代过，如果想看更标准的可以看下面模板(饶命)</span></span><br><span class="line"><span class="built_in">void</span> Heap(<span class="built_in">int</span> *a, <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> now = i;</span><br><span class="line">        <span class="keyword">while</span>((now&lt;&lt;<span class="number">1</span>) &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> largest ;</span><br><span class="line">            <span class="built_in">int</span> l = now &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> r = (now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span> == n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[l] &gt; a[now])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">int</span> temp = a[l];</span><br><span class="line">                    a[l] = a[now];</span><br><span class="line">                    a[now] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[l] &gt; a[r])</span><br><span class="line">            &#123;</span><br><span class="line">                largest = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                largest = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[largest] &gt; a[now])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = a[largest];</span><br><span class="line">                a[largest] = a[now];</span><br><span class="line">                a[now] = temp;</span><br><span class="line">                now = largest;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//初始化</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=n; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">1</span>] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        a[i] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = a[i] ^ a[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((now&lt;&lt;<span class="number">1</span>) &lt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> big;</span><br><span class="line">            <span class="keyword">if</span>((now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span> == i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = now&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[now] &lt; a[temp])</span><br><span class="line">                &#123;</span><br><span class="line">                    a[now] = a[temp] ^ a[now];</span><br><span class="line">                    a[temp] = a[temp] ^ a[now];</span><br><span class="line">                    a[now] = a[temp] ^ a[now];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//只有左节点</span></span><br><span class="line">            <span class="keyword">if</span>(a[now&lt;&lt;<span class="number">1</span>] &lt; a[(now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                big = (now&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                big = now&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[big] &gt; a[now])</span><br><span class="line">            &#123;</span><br><span class="line">                a[big] = a[big] ^ a[now];</span><br><span class="line">                a[now] = a[big] ^ a[now];</span><br><span class="line">                a[big] = a[big] ^ a[now];</span><br><span class="line">                now = big;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>模板</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆长度</span></span><br><span class="line"><span class="built_in">int</span> heapsize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//大顶堆化</span></span><br><span class="line"><span class="built_in">void</span> MAX_HEAPIFY(<span class="built_in">int</span> A[], <span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> l = <span class="number">2</span> * i;<span class="comment">//把 i 的左儿子 下标 赋给l</span></span><br><span class="line"><span class="built_in">int</span> r = <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//把 i 的左儿子 下标 赋给r</span></span><br><span class="line"><span class="built_in">int</span> largest;<span class="comment">//3个里面最大的下标</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (l &lt;= heapsize &amp;&amp; A[l]&gt;A[i])</span><br><span class="line">largest = l;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">largest = i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (r &lt;= heapsize &amp;&amp; A[r]&gt;A[largest])</span><br><span class="line">largest = r;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (largest != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换 A[largest] 和 A[i]</span></span><br><span class="line"><span class="built_in">int</span> tmp = A[largest];</span><br><span class="line">A[largest] = A[i];</span><br><span class="line">A[i] = tmp;</span><br><span class="line"> </span><br><span class="line">MAX_HEAPIFY(A, largest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="built_in">void</span> BUILD_MAX_HEAP(<span class="built_in">int</span> A[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = (<span class="built_in">int</span>)(heapsize / <span class="number">2</span>); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">MAX_HEAPIFY(A, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">printf(<span class="string">"%d "</span>, A[j]);</span><br><span class="line">printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="built_in">void</span> HEAPSORT(<span class="built_in">int</span> A[])</span><br><span class="line">&#123;</span><br><span class="line">BUILD_MAX_HEAP(A);<span class="comment">//ok</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="built_in">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (i = heapsize; i &gt;= <span class="number">2</span>; i--)<span class="comment">//A[1] 必定是最大的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换 A[1] 和 A[i]</span></span><br><span class="line">tmp = A[<span class="number">1</span>];</span><br><span class="line">A[<span class="number">1</span>] = A[i];</span><br><span class="line">A[i] = tmp;</span><br><span class="line"> </span><br><span class="line">heapsize--;</span><br><span class="line">MAX_HEAPIFY(A, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> A[<span class="number">11</span>] = &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//ok</span></span><br><span class="line"><span class="built_in">int</span> n = sizeof(A) / sizeof(<span class="built_in">int</span>) - <span class="number">1</span>;</span><br><span class="line">heapsize = n;</span><br><span class="line"> </span><br><span class="line">HEAPSORT(A);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">printf(<span class="string">"%d "</span>, A[i]);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度： nlogn.但是不稳定</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><a href="https://xinhecuican.github.io/post/63711.html">以前博客</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 29 2020 14:35:44 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>java I/O</title>
    <link href="http://xinhecuican.github.io/post/5be7e977.html"/>
    <id>http://xinhecuican.github.io/post/5be7e977.html</id>
    <published>2020-05-24T10:21:00.000Z</published>
    <updated>2020-06-07T06:45:14.328Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 08 2020 10:32:14 GMT+0800 (中国标准时间) --><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java.io.InputStream代表字节输入流，java.io.OutputStream代表输出流。他们都是抽象类，InputStream中有以下方法：</p><ul><li>int read():读入一个字节，并且转化成unsigned int型整数</li><li>int read(byte[] b): 从输入流中读取若干字节，保存在b数组中。如果到了输入流的结尾，返回1</li><li>int read(byte[] b, int off, int len): 如上，这里只是多了在b数组中的开始位置和读取数目</li><li>void close()： 关闭输入流。如果不关闭的话其他需要这个文件的就无法读取这个文件信息。类似于打开了一个应用程序再打开就说有一个实例正在运行。</li><li>int available(): 放回从输入流中读取字节数目</li><li>skip(long n): 从输入流中跳过n个字节</li><li>boolean markSupported(),void mark(int readLimit), void reset(): 如果想要重复读入数据，就先用markSupported()判断这个流是否支持重复读入数据，如果支持，通过mark在当前位置开始设置readLimit字节的标记，然后用reset()可以使输入流定位到做标记的起始位置，然后通过read()就可以重复读数据了。</li></ul><p>OutputStream中方法：</p><ul><li>void write(): 输出一个字节</li><li>void write(byte[] b): 同上</li><li>void write(byte[] b, int off, int len): 同上</li><li>void close()</li><li>void flush(): OutputStream本身的flush()不执行操作。但是如果是一些有缓冲区机制的实现类就有用了。在有缓冲区的输出流中，一般都是先把输出存在缓冲区中，等到了一定大小才会输出，<strong>这个方法的作用是强制输出缓冲区中数据</strong>。</li></ul><p>设置缓冲区的原因是输出并不是直接输出到屏幕中间要经历一系列的过程，耗时比较长，如果先存到缓冲区然后一次性输出就可以减少时间。</p><h1 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h1><h2 id="ByteArrayInputStream-字节数组输入流"><a href="#ByteArrayInputStream-字节数组输入流" class="headerlink" title="ByteArrayInputStream,字节数组输入流"></a>ByteArrayInputStream,字节数组输入流</h2><p>这个类从字节数组读取数据，可能会想直接用字符数组不就行了吗，为什么还要弄一个输入流类。ByteArrayInputStream实际上是一个<a href="https://xinhecuican.github.io/post/5951da65.html">适配器</a></p><p>构造方法：</p><p>ByteArrayInputStream(byte[] buf)</p><p>ByteArrayInputStream(byte[] buf, int offset, int length)</p><p>使用就是用上面的方法</p><h2 id="FileInputStream文件输入流"><a href="#FileInputStream文件输入流" class="headerlink" title="FileInputStream文件输入流"></a>FileInputStream文件输入流</h2><p>构造方法：</p><p>FileInputStream(File file)</p><p>FileInputStream(String name):通过name指定路径</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamTester</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span>((data=in.<span class="built_in">read</span>()) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(data+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果文件很大，为了提高读取效率，可以利用一个缓冲区。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        final <span class="keyword">int</span> SIZE = <span class="number">1024</span>;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FIleOutputStream(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">        <span class="keyword">int</span> len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        <span class="keyword">while</span>(len != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out.<span class="built_in">write</span>(buff, <span class="number">0</span>, len);</span><br><span class="line">            len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">        out.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果要打开的文件和这个类在同一文件夹下，可以用Class类的个体ResourceAsStream()方法,<strong>这时可以用相对路径</strong>。例如：</p><p><code>InputStream in = UseBuffer.getClass().getResourceAsStream(&quot;test.txt&quot;);</code></p><h2 id="PipedInputStream管道输入流"><a href="#PipedInputStream管道输入流" class="headerlink" title="PipedInputStream管道输入流"></a>PipedInputStream管道输入流</h2><p>管道输入流是从管道输出流中读取数据的。一般是一个线程从管道中输出，然后另外一个接受。使用管道的优点是如果管道中没有数据就会阻塞，有数据才会恢复运行，这样就可以对产生的数据进行处理。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Sender extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PipedOnputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getPipedOutputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-127</span>; i&lt;=<span class="number">128</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                out.<span class="built_in">write</span>(i);</span><br><span class="line">                <span class="built_in">yield</span>();<span class="comment">//让步给sender处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            out.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="title">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">private</span> PipedInputStream in;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span><span class="params">(Sender sender)</span><span class="keyword">throw</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//通过这个构造方法确定了两者的关系</span></span><br><span class="line">            in = <span class="keyword">new</span> PipedInputStream(sender.getPepedOutputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data;</span><br><span class="line">            <span class="keyword">while</span>((data=in.<span class="built_in">read</span>()) != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(data):</span><br><span class="line">            &#125;</span><br><span class="line">            in.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h2 id="SequenceInputStream-顺序输入流"><a href="#SequenceInputStream-顺序输入流" class="headerlink" title="SequenceInputStream 顺序输入流"></a>SequenceInputStream 顺序输入流</h2><p>它可以把几个输入流混合到一起输入。</p><p>构造方法：</p><p>SequenceInputStream(Enumeration e): e是枚举类型，包含若干个输入流</p><p>SequenceInputStream(InputStream s1, InputStream s2):只合并两个</p><p>它关闭的时候只需要关闭SequenceInputStream就会一次关闭所有的输入流。</p><h2 id="装饰器设计模式"><a href="#装饰器设计模式" class="headerlink" title="装饰器设计模式"></a>装饰器设计模式</h2><p>假设有一个类要子类实现三种方法，并且有的子类只需要实现一个，有的要实现多个，那么就要2^3-1个子类，数量过多。我们可以采用装饰器思想减少子类数目。</p><p>装饰器也是一个子类。这个子类的特殊之处在于他实现了某一个方法并且它内部封装了父类的实例。它的构造方法是：<code>decorate(Base base)</code></p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">B </span><span class="keyword">extends </span>A</span><br><span class="line"></span><br><span class="line"><span class="keyword">B </span><span class="keyword">b </span>= new <span class="keyword">B();</span></span><br><span class="line"><span class="keyword">decorate1 </span>dec1 = new decorate1(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec1.method1();</span></span><br><span class="line"><span class="keyword">decorate2 </span>dec2 = new decorate2(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec2.method2();</span></span><br></pre></td></tr></table></figure></div><h2 id="FilterInputStream-过滤输入流"><a href="#FilterInputStream-过滤输入流" class="headerlink" title="FilterInputStream 过滤输入流"></a>FilterInputStream 过滤输入流</h2><p>过滤输入流其实就是一个装饰器</p><p><strong>种类</strong></p><table><thead><tr><th>过滤输入流</th><th>描述</th></tr></thead><tbody><tr><td>DataInputStream</td><td>与DataOutputStream搭配使用，按照和平台无关的方式从流中读取基本类型（int，char，long等）</td></tr><tr><td>BufferedInputStream</td><td>利用缓冲区提高效率</td></tr><tr><td>PushbackInputStream</td><td>把督导的一个字节压回缓冲区中，编译器用</td></tr></tbody></table><p>这些都是FileterInputStream的子类,并且也是装饰器。</p><h3 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h3><p>它的不同方法可以按不同编码读取数据，并且都是以read开头：</p><ul><li>readByte()</li><li>readLong()</li><li>readFloat()</li><li>readUTF(): 从输入流中读取若干字节，并转化成UTF-8编码字符串</li></ul><p>UTF-8如果是ascii就只用一个字节，如果是其他字符就用两个或两个以上字节。</p><p>DataInputStream应该和DataOutputStream配套使用。只有配套使用才会保证数据的正确性（因为这里的UTF-8是java本土化的UTF-8,本来的UTF-8好像是稳定3个字节的）。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileOutputStream out1 = <span class="keyword">new</span> <span class="type">FileOutputStream</span>();</span><br><span class="line">        BufferedOutputStream out2 = <span class="keyword">new</span> <span class="type">BufferedOutputStream</span>(out1);</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> <span class="type">DataOutputStream</span>(out2);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><p>BufferedInputStream覆盖了读数据的行为，它利用缓冲区提高读取的效率。</p><p>构造方法：</p><ul><li>BufferedInputStream(InputStream in)</li><li>BufferedInputStream(InputStream in, int size):size指定缓冲区大小</li></ul><p>当数据源是文件时，可以用BufferedInputStream装饰数据流，然后再进行其他操作可以提高效率。</p><h3 id="PushbackInputStream"><a href="#PushbackInputStream" class="headerlink" title="PushbackInputStream"></a>PushbackInputStream</h3><p>它有一个后推缓冲区，用于存放已经读入的字节。</p><h1 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h1><p>输出流种类和输入流大致类似，sequenceInputStream对应的没有了，多了ObjectOutputStream。</p><p>ByteArrayOutputStream是把信息输出到字节数组中。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ByteArrayOutputStream <span class="keyword">out</span> = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">out</span>.write(<span class="string">"你好"</span>.getBytes(<span class="string">"UTF-8"</span>);<span class="comment">//String的getBytes可以放回制定类型的编码</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">out</span>.toByteArray();<span class="comment">//获得字符数组的方法</span></span><br><span class="line">        <span class="keyword">out</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>先用write把要输入的数据输入到输出流中，然后通过toByteArray方法输出到字节数组中。</p><p><strong>文件输出流</strong></p><p>前面大致类似，多了一种构造方法<code>FileOutputStream(String name, boolean append)</code></p><p>其中append是为了确定是不是要在末尾追加数据。</p><h2 id="FilterOutputStream-过滤输出流"><a href="#FilterOutputStream-过滤输出流" class="headerlink" title="FilterOutputStream 过滤输出流"></a>FilterOutputStream 过滤输出流</h2><p>同样有DataOutputStream和BufferedOutputStream，大致和输入流类似，多了一种PrintStream类</p><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><p>PrintStream和DataOutputStream类似，都可以输出格式化数据。他有如下方法。</p><ul><li>print(int i): 输出一个int</li><li>print(float i):</li><li>print(String i):</li><li>println(int i): 输出int型数据和换行符</li><li>println(float f):</li><li>println(String s):</li></ul><p>前面提到过，DataOutputStream和DataInputStream最好匹配使用是因为他们使用了特殊化的UTF-8编码。而PrintStream使用的是普通的UTF-8编码。</p><p>PrintStream的print()没有抛出IOException，但是他有checkError()判断写数据是否成功，如果返回true，则代表出现了错误。</p><p>PrintStream自带缓冲区。但是这和BufferedInputStream提供的缓冲区还有所不同。后者只有缓冲区满的时候才会输出，前者可以由用户决定数据量多少的时候输出。当然，默认还是满的时候输出。PrintStream还提供了一个自动化的输出方案：</p><ul><li>PrintStream(OutputStream out, boolean autoFlash)。当满足以下情况就会自动输出<ul><li>输出一个字节数组</li><li>输出一个换行符，即执行print(“\n”)或println()<h1 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader/Writer"></a>Reader/Writer</h1></li></ul></li></ul><p>InputStream和OutputStream处理的是字节，但是在很多场合要处理的是字符（java中字符时2字节）。Reader和Writer就是处理这些的。</p><p>java中字符时Unicode编码，但是文本文件中不一定是Unidcode编码，还有可能是UTF-8，GBK甚至ascii，因此如何处理不同类型编码就是一个难点。</p><p>String的getBytes(String encode)返回特定类型的编码，encode参数指定编码类型。如果不带参数就使用本地操作系统默认编码。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获得本地编码</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">"file.encoding"</span>)</span>);</span><br><span class="line">或：</span><br><span class="line">Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(cs);</span><br></pre></td></tr></table></figure></div><p>Reader类可以把其他类型的编码转换成java所使用的编码。Writer可以把Unicode转换成其他类型的编码。</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>Reader和InputStream类的种类大致类似.</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>CharArrayReader</td><td>把字符数组转换成Reader，从字符数组中读取字符</td></tr><tr><td>BufferedReader</td><td>装饰器，提供缓冲区。同时他的readLine()方法还可以读入一个字符串</td></tr><tr><td>LineNumberReader</td><td>提供缓冲区。并且可以跟踪字符输入流中中的行号</td></tr><tr><td>StringReader</td><td>把字符串转成Reader（数据源是字符串，和CharArrayReader类似），从字符串中读字符</td></tr><tr><td>PipedReader</td><td>连接PipedWriter</td></tr><tr><td>FilterReader</td><td>扩展其他Reader功能</td></tr><tr><td>InputStreamReader</td><td>把InputStream转换成Reader，可以指定数据源编码</td></tr><tr><td>FileReader</td><td></td></tr></tbody></table><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>构造方法：</p><ul><li>InputStreamReader(InputStream in): 按照本地的字符编码解读输入流中的字符</li><li>InputStreamReader(InputStream in, String charsetName): 按照charsetName指定的方式读取输入流中的字符</li></ul><p>这里的read读出来的不是一个字节而是一个字符</p><p>一些常用的方法：</p><ul><li>readLine(),一次读入一行</li><li>readFile(String fileName, String charsetName):从文件中读取字符串，并输出到控制台中</li><li>copyFile(String from, String charsetFrom, String to, String charsetTo): 把原文件复制到目标文件中，可以指定文件编码</li></ul><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>Writer和OutputStream大致类似，也有PrintWriter,区别是PrintStream只能用系统本地编码，而PrintWriter可以使用任意编码。PrintWriter构造方法：</p><ul><li>PrintWriter(Writer writer, boolean autoFlush)</li><li>PrintWriter(OutputStream out, boolean autoFlush)</li></ul><h1 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h1><p>在System类中，有三个静态变量：</p><ul><li>System.in: 代表标准输入流。默认输入时键盘</li><li>System.out: 是PrintStream类型（所以方法和PrintStream一样）。</li><li>System.err: 代表错误输出流，默认输出时输出到控制台。</li></ul><h2 id="对标准输入输出包装"><a href="#对标准输入输出包装" class="headerlink" title="对标准输入输出包装"></a>对标准输入输出包装</h2><p>可以利用到前面所学的只是对标准输入输出进行包装。System.in是InputStream类型，可以先用InputStreamReader变成Reader，然后在用BufferedReader装饰。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> <span class="constructor">InputStreamReader(System.<span class="params">in</span>)</span>;</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> <span class="constructor">BufferedReader(<span class="params">reader</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>重定向方法：</p><ul><li>setIn(InputStream, in): 对标准输入重定向</li><li>setOut(printStream out):</li><li>setErr(PrintStream out):</li></ul><p>这些方法时System的静态方法，所以写的时候是System.setIn()</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void redirect(InputStream <span class="keyword">in</span>, PrintStream out, PrintStream err)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">In(<span class="params">in</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Out(<span class="params">out</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Err(<span class="params">err</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String<span class="literal">[]</span> args)throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    InputStream stdin = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span><span class="keyword">in</span>;</span><br><span class="line">    PrintStream stdout = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out;</span><br><span class="line">    PrintStream stderr = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>err;</span><br><span class="line">    InputStream <span class="keyword">in</span> = <span class="keyword">new</span> <span class="constructor">BufferedInputStream(<span class="string">"D:\\temp.txt"</span>)</span>;</span><br><span class="line">    PrintStream out = <span class="keyword">new</span> <span class="constructor">BufferedOutputStream(<span class="string">"D:\\tempout.txt"</span>)</span>;</span><br><span class="line">    redirect(<span class="keyword">in</span>, out, stderr);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="RandomAccessFile-随机访问文件"><a href="#RandomAccessFile-随机访问文件" class="headerlink" title="RandomAccessFile 随机访问文件"></a>RandomAccessFile 随机访问文件</h1><p>随机访问文件就是可以从文件任意位置读写数据，他有如下定位方法：</p><ul><li>getFilePointer(): 返回当前位置</li><li>seeek(long pos): 设置位置，与未见开头相距pos</li><li>skipBytes(int n): 从当前开始跳过n个字节</li><li>length(): 返回文件包含的字节数</li></ul><p>RandomAccessFile实现了DataInput和DataOutput接口，可以读取格式化数据；</p><ul><li>RandomAccessFile(File file, String mode)</li><li>RandomAccessFile(String name, String mode):name指定路径</li></ul><p>其中mode是访问模式，可以有”r”和”rw”。表示只读和读写，但是”w”是非法的。</p><h1 id="新-I-O库"><a href="#新-I-O库" class="headerlink" title="新 I/O库"></a>新 I/O库</h1><p>这些类位于java.nio包中，nio是newio。他映入了四个数据类型</p><ul><li>Buffer： 缓冲区</li><li>Charset： 把Unicode和其他类型相互转换</li><li>Channel： 数据传送通道，把Buffer内容输出或读入到Buffer</li><li>Selector： 支持异步I/O操作，也叫非阻塞I/O操作</li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>缓冲区有两个作用：</p><ul><li>减少读取次数</li><li>和<a href="https://xinhecuican.github.io/post/7d1c86da.html">高速缓存</a>有关，这一段内存一直被重用。</li></ul><p>层次：<br><img src="/images/java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.jpg" alt></p><p>他有以下属性：</p><ul><li>容量</li><li>极限： 表示当前所使用缓冲区大小.极限可以修改</li><li>位置： 表示<strong>下一个</strong>读写单元位置</li></ul><p>他有如下设置属性方法：</p><ul><li>clear(): 把极限设置成容量，并且把位置变成0</li><li>flip(): 把极限设置成位置，然后把位置变成0</li><li>rewind(): 不改变极限，把位置变成0</li></ul><p>Buffer类是一个抽象类，他有8个具体类。最基本的是ByteBuffer类，他没有公开构造方法，但是有静态工厂。</p><ul><li>allocate(int capacity):</li><li>directAllocate(int capacity): 返回一个直接缓冲区。直接缓冲区速度较快，但是分配所需时间较多，所以一般只在所需空间较大并且长期使用的情况下才会用它。</li></ul><p>除了boolean类型之外，其他类型都有缓冲区（感觉和c的allocate有点类似），例如LongBuffer。此外，还有一种MappedByteBuffer，这是ByteBuffer的子类。它可以把缓冲区和文件某个区域直接映射（输出）。</p><p>共用方法：</p><ul><li>get(): 从当前位置读一个单元，然后位置加*ex位置读一个单元</li><li>put(): 向当前位置写入一个数据，然后位置加1</li><li>put(int index):</li></ul><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel用来连接缓冲区和数据源。它是一个接口，有两个方法：</p><ul><li>close(): 关闭通道</li><li>isOpen(): 判断通道是否打开</li></ul><p>通道会在创建时被打开，一旦被关闭就不能再次打开。</p><p>子接口ReadableByteChannel声明了read(ByteBuffer dst),把数据源数据读入到缓冲区中。WritableByteChannel声明了write(ByteBuffer src)，这个把src缓冲区中的数据输出。</p><p>ByteChannel扩展了上面说的两个接口，可以同时读写</p><p>ScatteringByteChannel扩展了ReadableByteChannel，可以分散读取数据。分散读取是指可以一次把数据放到多个缓冲区中。</p><p>GatheringByteChannel接口扩展了WritableByteChannel,可以把多个缓冲区中的数据一次性输出。他的wirte(ByteBuffer[] srcs)用来输出数据。</p><p><strong>这些方法都是缓冲区没满就继续读入</strong></p><p>FileChannel是Channel的实现类，他实现了ByteChannel，ScatteringByteChannel，GatheringByteChannel接口。支持上面所有操作。但是他没有公开构造方法，但是FileInputStream，FileOutputStream，RandomAccessFile类中提供了getChannel()方法，返回相应的FileChannel对象。</p><h2 id="Charset"><a href="#Charset" class="headerlink" title="Charset"></a>Charset</h2><p>Charset类每个实例代表特定的字符编码类型。他有以下用于编码转换的方法：</p><ul><li>ByteBuffer encode(String str): 把str转换成当前编码</li><li>ByteBuffer encode(CharBuffer cb): 把cb指定的字符缓冲区变成当前编码</li><li>CharBuffer decode(ByteBuffer bb): 把bb指定的ByteBuffer变成Unicode编码</li></ul><p>Charset有一个defaultCharset(): 返回代表本地平台编码的Charset对象。</p><h2 id="FileChannel读写文件"><a href="#FileChannel读写文件" class="headerlink" title="FileChannel读写文件"></a>FileChannel读写文件</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">&#123;</span><br><span class="line">    final <span class="built_in">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    FileChannel fc = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">"你好"</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//向文件末尾添加</span></span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">RandomAccessFile(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.position(fc.size<span class="literal">()</span>);<span class="comment">//定位到文件末尾</span></span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">"朋友"</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    </span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="string">"D:\\temp.txt"</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    ByteBuffer buff = <span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>allocate(BSIZE);</span><br><span class="line">    fc.read(buff);</span><br><span class="line">    buff.flip<span class="literal">()</span>;</span><br><span class="line">    Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(cs.decode(buff));</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><strong>控制缓冲区</strong></p><p>前面说的clear(),flip，rewind看似没用，但是它可以方便我们读入输出数据</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">buff </span>= <span class="keyword">ByteBuffer.allocate(BSIZE);</span></span><br><span class="line"><span class="keyword">while(in.read(buff) </span>!= -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">buff.flip();</span></span><br><span class="line"><span class="keyword"> </span>   out.write(<span class="keyword">buff);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">buff.clear();</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这段代码前面的flip是为了保证只操作当前数据，而clear()是为了保证接受尽可能多的数据。</p><p><strong>字符编码转换</strong></p><p>CharBuffer存放的数据单元室Unicode字符，ByteBuffer中的asCharBuffer()可以把Byte中数据转换成Unicode字符，并且存放在CharBuffer中。</p><h2 id="缓冲区视图"><a href="#缓冲区视图" class="headerlink" title="缓冲区视图"></a>缓冲区视图</h2><p>ByteBuffer类提供了asCharBuffer(),asIntBuffer(),和asFloatBuffer()来生成视图。通过视图，可以读取或写入各种类型的数据。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span>(bb.hasRemaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    bb.rewind();</span><br><span class="line">    CharBuffer cb = bb.asCharBuffer();</span><br><span class="line">    cb.<span class="built_in">put</span>(<span class="string">"你好"</span>);</span><br><span class="line">    whlie(bb.hasremaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h2><p>用于创建和修改那些因为太大而不能放入内存的文件。</p><p>FIleChannel类提供了获得MappedByteBuffer的map方法：</p><ul><li>MappedByteBuffer map(FIleChannel.MapMode mode, long position, long size)</li></ul><p>position是文件映射起始位置，size是映射区域大小，mode是模式，有三种：</p><ul><li>MapMode.READ_ONLY</li><li>READ_WRITE</li><li>MapMode.PRIVATE: 对MappedByteBuffer的修改不会保存到文件中，且其他程序不可见。</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">0x8000000</span>;</span><br><span class="line">    MappedByteBuffer mb = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D:\\test.txt"</span>,<span class="string">"rw"</span>).getChannel()</span><br><span class="line">    .<span class="built_in">map</span>(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, capacity);</span><br><span class="line">    mb.flip();</span><br><span class="line">    System.out.<span class="built_in">println</span>(Charset.forName(<span class="string">"GBK"</span>).decode(mb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h2><p>他允许程序同步访问作为共享资源的文件，但是可能发生同一时间多个线程同时访问的情况，甚至还有可能要和其他进程竞争。所以java中的文件锁是其他线程可见的。</p><p>FileChannel的tryLock()或Lock()用于锁定文件，如果成功放回FileLock对象，如果不成功就立刻返回null。lock()是阻塞式的，如果没有获得线程就会进入阻塞状态。</p><p>也可以部分加锁</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br><span class="line">lock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br></pre></td></tr></table></figure></div><p>上面的shared如果为true表示共享锁，如果是false是排他锁。</p><ul><li>共享锁，如果一个线程获得了共享锁，那么其他线程还可以获得共享锁，但是不能获得排他锁</li><li>排他锁，如果一个县城获得了排他锁，那么其他线程不可以获得共享锁或排他锁。</li></ul><p>可以用FileLock的isShared()判断锁的类型，如果是true，则是共享锁。release()用于释放文件锁。</p><h1 id="自动释放资源"><a href="#自动释放资源" class="headerlink" title="自动释放资源"></a>自动释放资源</h1><p>因为和c++中的delete一样，经常会忘了close(),所以从JDK7开始，绝大多数I/O类都实现了AutoCloseable接口。他会在一定条件下自动关闭：</p><ul><li>定义在try块中，退出try块时会自动调用close()(无论是正常出去还是非正常退出）。</li></ul><h1 id="用File来查看，创建，删除文件目录"><a href="#用File来查看，创建，删除文件目录" class="headerlink" title="用File来查看，创建，删除文件目录"></a>用File来查看，创建，删除文件目录</h1><p>File表示真实系统中的一个文件，他有如下构造方法：</p><ul><li>File(String pathname):</li><li>File(String parent, String child):parent表示根路径，child表示子路径。</li><li>File(File parent, String child)</li></ul><p>一般来说，如果只要处理一个文件，那么使用第一种构造方法，否则就用后面几种。</p><p>还提供管理文件方法：</p><ul><li>boolean canRead().测试程序是否能对进行读操作</li><li>boolean canWrite()</li><li>boolean delete():删除文件，如果删除的是目录并且目录中有东西就不能删除</li><li>boolean exists():看这个文件时候存在</li><li>String getAbsolutePath():获取文件绝对目录</li><li>String getChanonicalPath(): 获取真正的路径，没有<code>.</code>和<code>..</code></li><li>String getName()</li><li>String getParent()</li><li>String getPath(): 相对目录</li><li>String[] list(): 返回当前目录下所有文件列表</li><li>File[] listFiles().返回目录下的所有文件和目录的File对象</li><li>boolean mkdir(): 创建目录</li><li>boolean createNewFile(): 如果FIle表示文件且在当前目录下不存在，就创建</li></ul><h2 id="操作目录树"><a href="#操作目录树" class="headerlink" title="操作目录树"></a>操作目录树</h2><p>Files类： 有移动文件的move(),复制文件的copy()，搜索目录树的find().此外newDirectoryStream()回创建一个目录流，程序可以通过这个目录流遍历整个目录，用walkFileTree()遍历。</p><p>Path接口： 表示一个路径。</p><p>Paths类： 提供创建Path的静态方法，他的get(String first, String… more)返回一个Path对象，这个对象以first为根路径，以more为子路径.例如：<code>Paths.get(&quot;/root&quot;, &quot;dir1&quot;, &quot;dir2&quot;)</code>返回路径<code>/root/dir1/dir2</code>.</p><p><strong>查看zip</strong></p><p>可以通过FileSystems的newFileSystem()创建表示zip文件的FileSystem对象。然后可以用walkFileTree()遍历zip中所有文件。</p><p>其中walkFileTree可以查看官方文档。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 08 2020 10:32:14 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;java.io.
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Lambda</title>
    <link href="http://xinhecuican.github.io/post/d431fab4.html"/>
    <id>http://xinhecuican.github.io/post/d431fab4.html</id>
    <published>2020-05-22T10:02:00.000Z</published>
    <updated>2020-06-01T12:31:38.182Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 01 2020 20:31:38 GMT+0800 (中国标准时间) --><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names.<span class="keyword">forEach</span>((<span class="type">name</span>)-&gt;<span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span>));</span><br><span class="line">names.<span class="keyword">forEach</span>(<span class="keyword">System</span>.<span class="keyword">out</span>::println);//可以通过这种方式直接调用println</span><br></pre></td></tr></table></figure></div><p>基本语法； <code>(Type1 param1,Type2 param2,...)-&gt;{statment1, statment2... return statmentM;}</code></p><p>一般来讲，这个其实是接口或抽象类的简化。但是不是所有的类都可以使用Lambda的。</p><p>只有声明了函数式接口：<code>public @interface FunctionalInterface</code>才可以被Lambda赋值。这个就是可以简写的原因。通过函数式接口可以直接定位到这个类的某一个函数，然后就可以省略函数名等一系列要素.</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(String <span class="type">name</span>)-&gt;&#123;</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span>);</span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></div><p>这个是基础型，还有许多简化型：</p><ul><li>参数类型可以省略。例如上面可以把String省略，因为一般编译器都可以判断出来</li><li>当参数只有一个时，可以省略小括号（但是私以为还是写上的好，为了统一）</li><li>只有一条语句时，可以省略大括号。并且如果return没有返回值，也可以省略。也就是最前面第一个例子的写法。</li><li>也可以只包含一个普通表达式。语法：<code>(Type val1,Type val2...)-&gt;(expression)</code>。例如：<code>(int a, int b)-&gt;(a*b+2)</code></li></ul><h1 id="用Lambda代替内部类"><a href="#用Lambda代替内部类" class="headerlink" title="用Lambda代替内部类"></a>用Lambda代替内部类</h1><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(()</span>-&gt;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"Hello world!"</span>)).start<span class="literal">()</span>;<span class="comment">//方法1</span></span><br><span class="line"></span><br><span class="line">Runnable race = <span class="literal">()</span>-&gt;<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"Hello world!"</span>);<span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(<span class="params">race</span>)</span>.start<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></div><p>上面这个例子完整写法是：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">       <span class="keyword">new</span> Runnable()</span><br><span class="line">       &#123;    <span class="comment">//这是一个Runnable的匿名类</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.<span class="built_in">println</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="comment">//匿名类定义结束</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>至于匿名内部类，<a href="https://xinhecuican.github.io/post/348d4e04.html">可以参考</a></p><p>省去new和类名/接口名。并且直接实现run方法。此外()代表的是接口内部方法的参数，因为run()没有参数，所以这里也不写</p><h1 id="forEach-和排序"><a href="#forEach-和排序" class="headerlink" title="forEach()和排序"></a>forEach()和排序</h1><p>forEach定义： forEach(Consumer&lt;? super T&gt; action);</p><p>其中action实例必须实现Comsumer接口的accept(T t)方法。action指定具体的行为。</p><p>从jdk5开始，集合都实现了Iterable接口。也就是可以使用forEach()</p><p>例如：<code>names.forEach((name)-&gt;System.out.println(name+&quot;,&quot;));</code></p><p>上面的Lambda表达式相当于Consumer的匿名对象。</p><p><strong>排序</strong><br>实际上就是简化了Comparator接口或者其他有关排序接口的写法。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Comparator</span>&lt;<span class="keyword">String&gt; </span>sortByName = (<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>)-&gt;(<span class="built_in">s1</span>.compareTo(<span class="built_in">s2</span>))<span class="comment">;</span></span><br><span class="line"><span class="symbol">Collections.sort</span>(names,sortByName)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="symbol">Collections.sort</span>(names,(<span class="keyword">String </span><span class="built_in">s1</span>,<span class="keyword">String </span><span class="built_in">s2</span>)-&gt;(<span class="built_in">s1</span>.compareTo(<span class="built_in">s2</span>)))<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><h1 id="和streamapi联合"><a href="#和streamapi联合" class="headerlink" title="和streamapi联合"></a>和streamapi联合</h1><p>Stream接口是JDK8开始提供的，它可以充当Java集合的适配器。</p><p>方法：</p><ul><li>filter(Predicate&lt;? super T&gt; predivate); 返回包含符合条件元素的流</li><li>forEach(Consumer&lt;? super T&gt; action); 遍历集合中的元素</li><li>limit(long maxSize): 返回maxSize个数的元素</li><li>max(Comparator&lt;? super T&gt; comparator): 根据规则返回最大的元素</li><li>min(Comparator&lt;? super T&gt; comparator)</li><li>sorted(): 对集合中的元素自然排序</li><li>sorted(Comparator&lt;? super T&gt;</li><li>mapToInt(ToIntFunction&lt;? super T&gt; comparator)： 返回一个intStream型对象</li><li>mapToLong(ToLongFunction&lt;? super T&gt; mapper)</li><li>toArray(): 返回包含集合所有元素的对象数组</li></ul><h1 id="Lambda表达式变量作用域"><a href="#Lambda表达式变量作用域" class="headerlink" title="Lambda表达式变量作用域"></a>Lambda表达式变量作用域</h1><p>Lambda可以访问外部类的所有变量。还可以使用this，这里this引用的是外部类。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">String</span>[] data = &#123;<span class="string">"Tom"</span>, <span class="string">"Mike"</span>, <span class="string">"Mary"</span>&#125;;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; names = Arrays.asList(data);</span><br><span class="line">        <span class="keyword">char</span> var2 = <span class="string">','</span>;</span><br><span class="line">        names.forEach((name)-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            var1++;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="keyword">this</span>.var1+<span class="string">":"</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> A().test();</span><br><span class="line">    |</span><br><span class="line">|</span><br></pre></td></tr></table></figure></div><p>但是要注意一点，只能使用final修饰或者程序中不会改变的局部变量。这个类似于匿名内部类（实际上Lambda有匿名内部类的功能）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 01 2020 20:31:38 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 泛型</title>
    <link href="http://xinhecuican.github.io/post/70263071.html"/>
    <id>http://xinhecuican.github.io/post/70263071.html</id>
    <published>2020-05-21T10:37:00.000Z</published>
    <updated>2020-05-21T12:43:04.923Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu May 21 2020 20:49:10 GMT+0800 (中国标准时间) --><h1 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h1><p>由父类转给子类时允许的，但是会抛出ClassCastException。这种异常是运行时异常，编译期不会检查，这就加大了检查的难度。为了解决这个问题，从jdk5开始引入了泛型。泛型可以把ClassCastException转换成编译时类型不兼容错误。</p><p>泛型符号是&lt;&gt;,里面可以使任意一种类（不能是int等基础类型，可以是Integer).</p><p>例如： <code>Set&lt;Object&gt; set = new HashSet&lt;Object&gt;();//实例中的类型必须要和前面相同</code></p><h1 id="泛型类，数组，接口，方法"><a href="#泛型类，数组，接口，方法" class="headerlink" title="泛型类，数组，接口，方法"></a>泛型类，数组，接口，方法</h1><p><strong>泛型类</strong></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bag</span><span class="params">(T content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Bag&lt;<span class="keyword">String</span>&gt; bag = <span class="keyword">new</span> Bag&lt;<span class="keyword">String</span>&gt;(<span class="string">"mybook"</span>);</span><br><span class="line">        Integer content1 = bag.<span class="built_in">get</span>();<span class="comment">//出错</span></span><br><span class="line">        <span class="keyword">String</span> content2 = bag.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这和c++中的模板十分类似。同样泛型参数可以有许多个，例如：<code>public class A&lt;str,inte,dou&gt;{...}</code></p><p><strong>注意</strong> 如果没有传入泛型实参的话，泛型变量可以使任何类型。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> <span class="constructor">Generic(<span class="string">"111111"</span>)</span>;</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> <span class="constructor">Generic(4444)</span>;</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> <span class="constructor">Generic(55.55)</span>;</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> <span class="constructor">Generic(<span class="params">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.get<span class="constructor">Key()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.get<span class="constructor">Key()</span>);</span><br></pre></td></tr></table></figure></div><p><strong>泛型接口</strong></p><p>泛型接口和泛型类类似，但是它的实现类如果实现的是泛型接口，那么它的实现类也要是泛型。例如：</p><p><code>public class A&lt;T&gt; implements B&lt;T&gt;</code></p><p>如果<code>public class A implements B&lt;T&gt;</code>会报错</p><p>但是如果实现的是一个确定类型的接口，那么前面就不是必须加</p><p><code>public class A implements B&lt;Integer&gt;</code>可以</p><p><strong>数组</strong></p><p>以前我们都是 int[], double[],现在我们把前面的类型变成泛型。例如<code>T[]</code>。</p><p>这里要注意一点，不能使用泛型创建实例。例如<code>T[] content = new T[10];</code>是错误的。</p><p><strong>方法</strong></p><p>在普通类和泛型类中都可以定义泛型方法。泛型方法只需要在方法头部定义泛型符号就可以了，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    Integer[] b = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    a.printArray(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>感觉泛型方法很方便，直接传入参数就可以了，不用管类型。但是这样势必会增大时间开销。</p><h1 id="extends限定类型参数"><a href="#extends限定类型参数" class="headerlink" title="extends限定类型参数"></a>extends限定类型参数</h1><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> 类名&gt; 必须要是这个类或者子类</span><br><span class="line">&lt;T <span class="keyword">extends</span> 接口名&gt;</span><br></pre></td></tr></table></figure></div><h1 id="使用？通配符"><a href="#使用？通配符" class="headerlink" title="使用？通配符"></a>使用？通配符</h1><p>前面已经说过，实例中泛型类型必须要和定义时泛型类型相同。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; s1 =  <span class="keyword">new</span> HashSet&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">Set</span>&lt;<span class="keyword">String</span>&gt; s2 = <span class="keyword">new</span> HashSet&lt;<span class="built_in">Integer</span>&gt;();//报错</span><br></pre></td></tr></table></figure></div><p>为了防止上述错误，可以使用通配符？，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; listInteger = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        listInteger.add(<span class="number">11</span>);</span><br><span class="line">        <span class="built_in">print</span>(listInteger);</span><br><span class="line">        printNew(listInteger);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Collection&lt;Object&gt; collection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj: collection)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNew</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj: collection)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>print会出现问题，因为只能接受Object的泛型类型，后面一个就可以。</p><p>还可以和extends结合。例如：</p><p><code>TreeSet&lt;? extends Number&gt; x = new TreeSet&lt;Integer&gt;();//可以，Integer是Number的子类</code></p><p>这个和前面说的区别是前面是在定义时决定的，这个是在具体写代码时决定的，个人认为这种更为灵活。</p><p>还有super，后面类型只能是前面类型的父类或者他自己。例如：<code>TreeSet&lt;? super Integer&gt; x = new TreeSet&lt;Number&gt;();</code></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>看上去不同的泛型类型导致了不同的类。例如<code>A&lt;Integer&gt;</code>和<code>A&lt;String&gt;</code>是不同的类，但是实际上泛型的类型在编译时期已经赋给内部的变量了，这个时候泛型被擦除了，所以实际上创建实例时还是调用了方法区中的A。</li><li>因为上一条，所以不允许出现名字相同只有泛型类型不同的重载，例如：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"String"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;Integer&gt; ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Integer"</span>);</span><br><span class="line">&#125;</span><br><span class="line">会报错</span><br></pre></td></tr></table></figure></div></li><li>不能对确切的泛型使用instanceof符号，例如：<code>Collection cs = new ArrayList&lt;String&gt;(); cs instanceof Collection&lt;String&gt;; 报错</code></li></ul><p>但是如果后面使用通配符就可以，<code>cs instanceof Collection&lt;?&gt;通过</code></p><ul><li>不能使用泛型类型进行强制类型转换，例如：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection cs = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = (ArrayList&lt;<span class="keyword">String</span>&gt;)cs;<span class="comment">//会警告并且运行时容易出现异常</span></span><br></pre></td></tr></table></figure></div></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu May 21 2020 20:49:10 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;发展过程&quot;&gt;&lt;a href=&quot;#发展过程&quot; class=&quot;headerlink&quot; title=&quot;发展过程&quot;&gt;&lt;/a&gt;发展过程&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 集合，列表，队列，映射</title>
    <link href="http://xinhecuican.github.io/post/d5381517.html"/>
    <id>http://xinhecuican.github.io/post/d5381517.html</id>
    <published>2020-05-16T10:30:00.000Z</published>
    <updated>2020-06-01T12:59:39.883Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 01 2020 20:59:40 GMT+0800 (中国标准时间) --><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>Set（集），集合中对象不以特定方式排序（有的实现类可以），没有重复元素</li><li>List(列表），按照索引排序，可以有重复对象。List和数组类似。</li><li>Queue（队列），先进先出</li><li>Map（映射）： 有键值对。没有重复键对象，可以有重复值对象</li></ul><p>定义：</p><p><code>Set&lt;String&gt; set = new HashSet&lt;String&gt;();</code></p><h2 id="Collection-和-Interator接口"><a href="#Collection-和-Interator接口" class="headerlink" title="Collection 和 Interator接口"></a>Collection 和 Interator接口</h2><p>Collection声明了上面这些数据结构（不包含map）通用的方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean add(Object o)</td><td>加入对象</td></tr><tr><td>void clear()</td><td>删除所有对象</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否有特定对象</td></tr><tr><td>boolean isEmpty()</td><td></td></tr><tr><td>Iterator iterator()</td><td>返回一个Iterator对象（<a href="https://xinhecuican.github.io/post/37318.html">迭代器</a>）</td></tr><tr><td>boolean remove(Object o)</td><td></td></tr><tr><td>int size()</td><td>返回数目</td></tr><tr><td>Object[] toArray()<t>T[]toArray(T[] a)</t></td><td>返回一个数组，包含集合中所有元素</td></tr></tbody></table><p>Set接口，List接口，Queue接口都继承了Collection接口。</p><p>Inerator接口定义了如下方法：</p><ul><li>hasNext()：判断集合中的元素是否遍历完毕，如果没有返回true</li><li>next(): 返回下一个元素。例如iter.next()是让iter这个迭代器进一位</li><li>remove(): 删除由next()返回的元素</li></ul><p>如果先用iterator()得到一个Iterator对象后，又用Collection的其他方法，再用next()可能会抛出ConcurrentModifcationException异常。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LISP"><figure class="iseeu highlight /lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; a = new HashSet&lt;Integer&gt;()<span class="comment">;</span></span><br><span class="line">for(<span class="name">int</span> i=0<span class="comment">; i&lt;10; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    a.add(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;Integer&gt; iter = a.iterator()<span class="comment">;</span></span><br><span class="line">while(<span class="name">iter</span>.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="name">iter</span>.next())<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="添加基本类型数据"><a href="#添加基本类型数据" class="headerlink" title="添加基本类型数据"></a>添加基本类型数据</h2><p>实际上集合中只能存放对象。但是经常可以看到list.add(2)之类的操作。实际上在添加的时候已经隐式转换成Integer对象了。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>set本身是不排序的。但是它的实现类TreeSet具有排序功能。</p><h2 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h2><p>当添加一个新的元素时，首先要检查这个对象是否已经存在于集合中。如果存在就不添加。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> Set&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">String</span> s1 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">String</span> s2 = s1;</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(s1);</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(s2);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">set</span>.<span class="built_in">size</span>());</span><br><span class="line">结果放回<span class="number">1</span></span><br></pre></td></tr></table></figure></div><h2 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h2><p>HashSet使用哈希算法存放集合中对象。具有良好的查找和存取性能。</p><p>前面说过在Object类中有hashCode()方法返回哈希值，而这个有使用hash算法存储的，所以判断两个对象是否相等还可以<code>customer1.hashCode() == customer2.hashCode();</code></p><p>如果一个类覆盖了equals()方法，那么就应该实现hashCode()方法，保证党两个对象相等时，hashcode相同。</p><h2 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h2><p>TreeSet类实现了SortedSet接口，可以对集合中对象排序。TreeSet支持两种排序方法：自然排序和客户化排序。默认使用自然排序。</p><p><strong>自然排序</strong></p><p>TreeSet实现了Comparable接口的compareTo(Object o)方法比较集合中对象大小。如果返回值大于0，代表这个值大于o。<strong>只有实现了Comparable接口的对象才可以使用TreeSet进行排序</strong>。compareTo方法最好要从小到大进行排序，以便和其他的进行匹配。</p><p>下面列举了一些实现了Comparable接口的类</p><table><thead><tr><th>类</th><th>排序</th></tr></thead><tbody><tr><td>BigDecimal BigInteger Byte Double Float Integer Long Short</td><td>按数字大小</td></tr><tr><td>Character</td><td>按字符 Unicode值</td></tr><tr><td>String</td><td>按字符串中Unicode值</td></tr></tbody></table><p>如果是自己定义的类，首先要实现Comparable接口。并且最好也是通过返回值大于零小于零来判断谁大谁小的。</p><p>注意，如果把一个对象加入TreeSet并且修改它的属性TreeSet是不会重新排序的。所以适合排序的是不可变类。</p><p><strong>客户化排序</strong></p><p>客户化排序可以降序排序。首先实现java.util.Comparator<t>接口。Comparator有个compare(T x, T y)方法用于比较两个对象的大小，如果返回值大于0，表示x&gt;y。</t></p><p>如果想实现降序排序，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">CustomerComparator</span> <span class="symbol">implements</span> <span class="symbol">Comparator</span>&lt;<span class="symbol">Customer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> compare(Customer c1, Customer c2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c1,getName().compareTo(c2.getName())&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c1.getName().compareTo(c2.getName())&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Set&lt;Customer&gt; <span class="keyword">set</span> = new TreeSet&lt;Customer&gt;(new CustomerComparator());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Set有个构造方法 Set(Comparator comparaotr)可以使用Comparator来确定升序还是降序。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>list的实现类有：</p><ul><li>ArrayList： ArrayList代表长度可变数组。ArrayList实现了RandomAccess接口，这个接口不包含任何方法，仅仅表示有良好的随机访问性能。</li><li>LinkedList： 链式结构。LinkedList不仅仅可以做数组，还可以做堆栈，队列，双向队列。</li></ul><h2 id="访问元素和排序"><a href="#访问元素和排序" class="headerlink" title="访问元素和排序"></a>访问元素和排序</h2><p>list中get(int index)方法可以返回集合中索引位置的数。List中的iterator()和Set中的iterator()一样，也可以用来遍历。</p><p>此外，还可以用foreach来遍历</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LESS"><figure class="iseeu highlight /less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">for</span>(Integer <span class="attribute">i</span>: list)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.print</span>(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>至于排序，只能对集合中的对象按索引进行排序，如果想用其他方式，可以实现collections类和Comparator接口。Collections类中的sort方法可以用来排序</p><ul><li>sort(List list) 对List对象进行自然排序</li><li>sort(List list, Comparator comparator)进行客户化排序</li></ul><h2 id="ListIterator-接口"><a href="#ListIterator-接口" class="headerlink" title="ListIterator 接口"></a>ListIterator 接口</h2><p>List中listIterator()返回一个ListIterator对象，这个对象继承了Iterator接口，此外还有一些独有的方法</p><ul><li>add() 向列表中插入一个元素</li><li>hasNext() 判断列表中是否还有下一个元素</li><li>hasPrevious(): 判断列表中是否还有上一个元素</li><li>next(): 返回下一个元素</li><li>previous(): 返回上一个元素</li></ul><p>![](/images/java 集合，列表，队列，映射.jpg)</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue提供了add()和offer()两种方法来从队尾加元素，如果是add队满就会抛出IllegalStateException，如果是offer()会返回false。</p><p>删除也有两种，一种是remove()，一种是poll()。如果是remove，队空后会跑出NoSuchElementException，如果是poll，空了会返回null</p><p>获取元素，一种是element(),一种是peek().如果不成功（队空），那么会出现和删除队空同样的情况。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deque是一个接口</p><p>从头或尾添加元素</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addFirst</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="function"><span class="title">addLast</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">offerFirst</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">offerLast</span>(<span class="variable">E</span> <span class="variable">element</span>)</span></span><br></pre></td></tr></table></figure></div><p>如果队满，都会抛出IlllegalStateException.后两种方法返回false</p><p>删除</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">E</span> <span class="function"><span class="title">removeFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">removeLast</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">pollFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">pollLast</span>()</span></span><br></pre></td></tr></table></figure></div><p>和前面队空判断一样</p><p>获取</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">E</span> <span class="function"><span class="title">getFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">getLast</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">peekFirst</span>()</span></span><br><span class="line"><span class="variable">E</span> <span class="function"><span class="title">peekLast</span>()</span></span><br></pre></td></tr></table></figure></div><p>就是把上面的queue加了个first和last</p><p>LinkedList和ArrayList都实现了Deque接口，</p><h2 id="PriorityQueue-优先队列"><a href="#PriorityQueue-优先队列" class="headerlink" title="PriorityQueue 优先队列"></a>PriorityQueue 优先队列</h2><p>优先队列使用堆进行排序。并且因为要排序，所以想用优先队列要首先实现Comparable接口。</p><p>这里的remove总会首先删除最小的元素。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>定义： Map&lt;type1, type2&gt; map = new HashMap&lt;type1, type2&gt;();</p><p>其中type1是键类型，type2是值类型。</p><p>Map叫映射，就是给出键返回值。可以使用get(Object key)得到值。通过put(Object key, Object value)插入键值对。</p><p>Map的键不允许有重复，但是值可以有重复。</p><p>Map有两种常用实现，HashMap和TreeMap，HashMap用哈希算法来存取键对象，有良好的取性能。为了保证能正常工作，也要确保通过equals()比较为true时，两个对象返回哈希码相同。</p><p>TreeMap实现了SortedMap接口，可以对键进行排序。如果想进行客户化排序，可以调用TreeMap(Comparator comparator)构造函数。</p><p>Map的keySet()返回所有键对象的集合。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; <span class="keyword">set</span> = map.entrySet();<span class="comment">//注意</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iter = <span class="keyword">set</span>.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>=<span class="number">0</span></span><br><span class="line"><span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>=<span class="number">2</span></span><br><span class="line"><span class="number">3</span>=<span class="number">3</span></span><br><span class="line"><span class="number">4</span>=<span class="number">4</span></span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">6</span>=<span class="number">6</span></span><br><span class="line"><span class="number">7</span>=<span class="number">7</span></span><br><span class="line"><span class="number">8</span>=<span class="number">8</span></span><br><span class="line"><span class="number">9</span>=<span class="number">9</span></span><br></pre></td></tr></table></figure></div><p>set内的类型是Map.Entry,可以使用getKey()返回键，使用getValue()返回值。</p><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>适用于List的方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STATA"><figure class="iseeu highlight /stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span>(<span class="keyword">List</span> dest, <span class="keyword">List</span> src): 把一个<span class="keyword">list</span>复制到另一个<span class="keyword">list</span>中</span><br><span class="line">fill(<span class="keyword">List</span> <span class="keyword">list</span>,Object o) 想列表中填充元素</span><br><span class="line"><span class="keyword">sort</span>(<span class="keyword">List</span> <span class="keyword">list</span>) 排序</span><br><span class="line">binarySearch(<span class="keyword">List</span> <span class="keyword">list</span>, Object key) 如果有序就可以用这个</span><br><span class="line">shuffle(<span class="keyword">List</span> <span class="keyword">list</span>): 对<span class="keyword">List</span>中元素随机排列</span><br></pre></td></tr></table></figure></div><p>适用于Map或Collection的：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> max(Collection coll):返回集合中最大的元素</span><br><span class="line"><span class="built_in">Object</span> max(Collection coll, Comparator comp):采用指定规则进行比较，返回最大元素</span><br><span class="line"><span class="built_in">Object</span> min(Collection coll)</span><br><span class="line"><span class="built_in">Object</span> min(Collection coll, Comparator comp)</span><br><span class="line"><span class="built_in">Set</span> singleton(<span class="built_in">Object</span> o): 返回一个不可变的<span class="built_in">Set</span></span><br><span class="line"><span class="built_in">List</span> singletonList(<span class="built_in">Object</span> o) 返回不可改变的<span class="built_in">List</span></span><br><span class="line"><span class="built_in">Map</span> singletonMap（<span class="built_in">Object</span> key, <span class="built_in">Object</span> value):</span><br><span class="line">Collection synchronizedCollection(Collection c): 在原来的基础上，返回支持同步的集合</span><br><span class="line"><span class="built_in">Map</span> synchronizedMap(<span class="built_in">Map</span> m)</span><br><span class="line"><span class="built_in">Set</span> ...</span><br><span class="line"><span class="built_in">List</span> ...</span><br><span class="line">Collection unmodifiableCollection(Collection c): 在原来结合的基础上，返回不可改变的集合视图</span><br><span class="line">其他三个相同</span><br></pre></td></tr></table></figure></div><p>前面的singleton是指这个集合中只有一个元素，并且不允许修改</p><p>而后面的unmodifiable是返回这个集合，但是如果原集合修改，这个集合也会跟着修改。不允许修改指的是不允许修改这个集合视图</p><p><strong>线程安全的集合</strong></p><p>在平常情况下集合的实现类都没有同步锁机制，这样可以加快速度。但是当有多个线程同时操作一个锁的时候就需要同步机制了。一种方式就是在可能导致问题的代码块用synchronized，另一种就是上面讲的方法。</p><h1 id="集合批量操作"><a href="#集合批量操作" class="headerlink" title="集合批量操作"></a>集合批量操作</h1><p>前面说的都是一次处理一个元素，如果要处理多个元素，可以采用Collection中的方法：</p><ul><li>boolean retainAll(Collection&lt;?&gt; c)修改集合，保留在c中的元素并删去其他元素</li><li>boolean removeAll(Collection&lt;?&gt; c)删去集合中c的元素。</li><li>boolean addAll(Collection&lt;? extends E&gt; c): 把c中元素加入到当前集合中</li><li>boolean containsAll(Collection&lt;?&gt; c): 判断当前集合是否全部包含c</li></ul><h1 id="其他集合类"><a href="#其他集合类" class="headerlink" title="其他集合类"></a>其他集合类</h1><p>Properties是一种特殊的Map类。他可以用load()从输入流中读取键和值。例如；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties ps = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span><br><span class="line">InputStream <span class="keyword">in</span> = <span class="module-access"><span class="module"><span class="identifier">PropertiesTester</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ResourceAsStream(<span class="string">"myapp.properties"</span>)</span>;</span><br><span class="line">ps.load(<span class="keyword">in</span>);</span><br><span class="line"><span class="keyword">in</span>.close<span class="literal">()</span>;</span><br><span class="line">print(ps);</span><br><span class="line">ps=<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Properties()</span>;</span><br><span class="line">print(ps);</span><br></pre></td></tr></table></figure></div><p>可以使用System.getProperties()返回一个Propertiese对象。这个对象中包含一系列系统属性。</p><p>BitSet表示一组boolean数据集合。类似于boolean[]数组。最小初始容量是64位，可以通过BitSet(int bits)设置初始容量。如果达到了初始容量会自动增加。</p><p>BitSet中有以下方法：</p><ul><li>set(int index) 把index位置的元素设置成true</li><li>clear(int index) 把index位置的元素设false</li><li>get(int index): 获得index位置的元素值</li><li>and(BitSet bs): 与bs进行与运算，结果保存在当前BitSet中</li><li>or(Bitset bs)</li><li>xor(BitSet bs)</li></ul><p>BitSet在c++中是返回二进制信息，在这里也可以有这个作用。可以自己建立byteToBitSet()计算出byte类型的二进制位，其他类型类似。printBitSet()打印BitSet二进制信息。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte </span>a = <span class="number">125</span>;</span><br><span class="line"><span class="keyword">short </span><span class="keyword">b </span>= -<span class="number">125</span>;</span><br><span class="line">int c = -<span class="number">125</span>;</span><br><span class="line">long d = <span class="number">125</span>;</span><br><span class="line">printBitSet(<span class="keyword">byteToBitSet(a), </span><span class="keyword">BYTE_SIZE);</span></span><br><span class="line"><span class="keyword">printBitSet(shortToBitSet(b), </span><span class="keyword">SHORT_SIZE);</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure></div><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>位置： java.lang.Enum。这个类是抽象类</p><p>此外，还提供了关键字enum。例如 public enum Gender{FEMALE, MALE}</p><p>Enum类有如下非抽象方法（一般直接使用enum就可以了，也有这些)：</p><ul><li>intcompareTo(E o) 比较当前常量与指定对象的顺序</li><li>Class<e>getDeclaringClass()返回当前类型的class对象</e></li><li>String name() 返回当前枚举常量的名称。例如调用Gender.FEMALE的name()方法，会返回FEMALE</li><li>intordinal() 返回当前枚举常量在声明时的位置</li><li>toString() 返回枚举常量的名称</li><li><code>static&lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)</code>返回制定枚举类型和名称返回的枚举常量</li><li>static Enum[] values() 以数组的方式返回所有的枚举常量</li><li>range(from， to)用来迭代</li></ul><p>range用法例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">for(WeekDayEnum</span> <span class="string">day : EnumSet.range(WeekDayEnum.Mon, WeekDayEnum.Fri)) &#123; </span></span><br><span class="line">    <span class="meta">System.out.println(day);</span> <span class="string"></span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">输出</span></span><br><span class="line"><span class="attr">Mon</span> <span class="string"></span></span><br><span class="line"><span class="attr">Tue</span> <span class="string"></span></span><br><span class="line"><span class="attr">Wed</span> <span class="string"></span></span><br><span class="line"><span class="attr">Thu</span> <span class="string"></span></span><br><span class="line"><span class="attr">Fri</span></span><br></pre></td></tr></table></figure></div><p>枚举类型最大的作用就是可以用于switch，相当于扩充了switch的范围。</p><h2 id="枚举类型构造方法"><a href="#枚举类型构造方法" class="headerlink" title="枚举类型构造方法"></a>枚举类型构造方法</h2><p>这个构造方法时private，或friendly类型的，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Gender</span><br><span class="line">&#123;</span><br><span class="line">    MALE(<span class="string">"男性"</span>),</span><br><span class="line">    FEMALE(<span class="string">"女性"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> description;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Gender</span><span class="params">(<span class="keyword">String</span> description)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Gender g = Gender.valueOf(<span class="string">"FEMALE"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (g)<span class="comment">//必须要是实例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.<span class="built_in">println</span>(g.getDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.<span class="built_in">println</span>(g.getDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意前面定义时的符号，如果是基础类型，那么最后一个不用跟任何符号，如果不是，那么最后一个必须要封号。并且前面只能是逗号</p><p>enum是构造对象时产生的，因此看起来相同的两个类型实际上比较时也可能不相同。</p><h2 id="EnumSet和EnumMap"><a href="#EnumSet和EnumMap" class="headerlink" title="EnumSet和EnumMap"></a>EnumSet和EnumMap</h2><p>前面一个把枚举转化成集合，它的静态allOf()方法把枚举类所有常量实例存放到一个EnumSet类型的集合中，然后放回这个集合。</p><p>EnumMap转换成映射，它的EnumMap(Class<k>keyType)来指定具体的枚举类型。枚举常量以key的方式存到Map中。例如：</k></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EnumSet&lt;WeekDayEnum&gt; <span class="built_in">subset</span> = EnumSet.of(WeekDayEnum.Mon, WeekDayEnum.Wed); </span><br><span class="line">     <span class="keyword">for</span> (WeekDayEnum <span class="built_in">day</span> : <span class="built_in">subset</span>) &#123; </span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="built_in">day</span>);  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 01 2020 20:59:40 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;Set
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 数组</title>
    <link href="http://xinhecuican.github.io/post/325cdbf2.html"/>
    <id>http://xinhecuican.github.io/post/325cdbf2.html</id>
    <published>2020-05-14T11:54:00.000Z</published>
    <updated>2020-05-18T12:01:44.506Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>可以这样声明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] scores<span class="comment">;</span></span><br><span class="line">String[] names<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>也可以这样声明</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int scores[]<span class="comment">;</span></span><br><span class="line">String names[]<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>二维更为古怪</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-attr">[]</span><span class="selector-tag">x</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-tag">x</span><span class="selector-attr">[]</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">x</span><span class="selector-attr">[]</span><span class="selector-attr">[]</span>;</span><br></pre></td></tr></table></figure></div><p>这里注意一点，声明时不能往括号中加东西，会报错。例如：<code>int x[1];//报错</code></p><p>java中推荐吧括号放到前面，可能int[]也成了一个对象？</p><h2 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h2><p>创建数组对象语法和c++中创建动态数组类似。</p><p><code>int[] scores = new int[100];</code></p><p>上面这个代码首先要在堆中分配空间，然后把里面的数据初始化。</p><p>括号中的数字可以使常量，也可以是变量，甚至可以是0(表示里面没有数据).</p><h2 id="访问数组的元素和长度"><a href="#访问数组的元素和长度" class="headerlink" title="访问数组的元素和长度"></a>访问数组的元素和长度</h2><p>和c++一样，下标索引。如果越界，会抛出ArrayIndexOutOfBoundsException异常</p><p>所有数组都有length属性，表示数组的长度: <code>public final length</code>.</p><p>所以我们可以直接输出这一属性，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x<span class="literal">[]</span> = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="number">40</span>]</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.length); <span class="comment">//输出length</span></span><br></pre></td></tr></table></figure></div><p>如果是对象数组，那么数组中的元素时对象的引用，因此当我们不使用数组的时候最好把值赋null触发垃圾回收机制。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> sb = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">String</span> sbs[] = <span class="keyword">new</span> <span class="built_in">String</span>[](sb,<span class="keyword">null</span>);</span><br><span class="line">...</span><br><span class="line">sbs[<span class="number">0</span>] = <span class="keyword">null</span>;<span class="comment">//清除数组对象的引用</span></span><br><span class="line">sbs = <span class="keyword">null</span>;<span class="comment">//清除数组引用</span></span><br></pre></td></tr></table></figure></div><h2 id="多维数组和不规则数组"><a href="#多维数组和不规则数组" class="headerlink" title="多维数组和不规则数组"></a>多维数组和不规则数组</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[<span class="string"></span>][<span class="symbol"></span>] rooms = new String[<span class="string">2</span>][<span class="symbol"></span>];</span><br><span class="line">rooms[<span class="string">0</span>] = new String[]("Tom","Mike");</span><br><span class="line">rooms[<span class="string">1</span>] = new String[]("Mary");</span><br></pre></td></tr></table></figure></div><p>可以用不等长数组是因为每一行都是一个数组元素，都有自己的length变量</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;rooms.<span class="built_in">length</span>; <span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">0</span>; k&lt;rooms[<span class="built_in">i</span>].<span class="built_in">length</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(rooms[<span class="built_in">i</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>第一个循环的length是rooms引用多少个数组，rooms[]指的是每个数组的长度。</p><p>要注意只有最后一个括号可以不加数字，我的理解是只有最后一层才是真正的数组对象，才有length，同时，前面不确定就不知道要开多少个数组对象。</p><h2 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h2><p>在c++中数组是不能作为返回值的，因为c++中数组是一个指针，而又不能像其他指针一样确定它的大小。而在java中数组是一个对象，可以返回它的引用。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>平常我们想找某一个值都是通过遍历数组得到的，我们也可以用值通过某种映射关系得到在数组中的位置。这就是哈希表</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>%<span class="number">10</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个例子中value就是值，返回的是下标。但是这时如果超过十就会出现重复，这叫做哈希冲突。我们可以设计更复杂的映射来处理哈希冲突。</p><p>判断重复的条件是 object1.equals(boject2)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    private</span> Object value;</span><br><span class="line">    private <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(Object</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getValue()</span><br><span class="line">    &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">Node</span> <span class="title">getNext</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNext(<span class="keyword">Node</span> <span class="title">next</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyhashSet</span><br><span class="line">&#123;</span><br><span class="line">    private <span class="keyword">Node</span><span class="title">[] array</span>;</span><br><span class="line">    private int size = <span class="number">0</span>;//数组元素数目</span><br><span class="line">    public MyHashSet(int length)</span><br><span class="line">    &#123;</span><br><span class="line">        array = new <span class="keyword">Node</span><span class="title">[length</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    public int size()</span><br><span class="line">    &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int hash(Object o)//哈希算法</span><br><span class="line">    &#123;</span><br><span class="line">        int h = o.hashCode();//Object类中有这个方法</span><br><span class="line">        h += ~(h <span class="tag">&lt;&lt; 9);</span></span><br><span class="line"><span class="tag">        h ^= (h &gt;</span>&gt;&gt; <span class="number">14</span>);</span><br><span class="line">        h += (h <span class="tag">&lt;&lt; 4);</span></span><br><span class="line"><span class="tag">        h ^= (h &gt;</span>&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int indexFor(int hashCode)</span><br><span class="line">    &#123;</span><br><span class="line">        return hashCode &amp; (array.length-<span class="number">1</span>);//返回索引</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void add(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">newNode</span> = new <span class="keyword">Node</span><span class="title">(value</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array(index);</span><br><span class="line">        if(<span class="keyword">node</span> <span class="title">== null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            array(index) = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        else//处理哈希冲突</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">Node</span> <span class="title">nextNode</span>;</span><br><span class="line">            while(!<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value) &amp;&amp;</span><br><span class="line">            (nextnode = <span class="keyword">node</span>.<span class="title">getNext</span>()) != null)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= nextNode</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //不允许加入重复元素</span><br><span class="line">            if(!<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">node</span>.<span class="title">setNext</span>(newNode);</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //测试是否有这个对象</span><br><span class="line">    public boolean contains(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array[index];</span><br><span class="line">        while(<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; !<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">node</span> <span class="title">= node</span>.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">!=null</span> &amp;&amp; <span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean remove(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array[index];</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">!=null</span> &amp;&amp; <span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            array[index] = <span class="keyword">node</span>.<span class="title">getNext</span>();</span><br><span class="line">            size--;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">Node</span> <span class="title">lastNode</span> = null;</span><br><span class="line">        while(<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; !<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            lastNode.setNext(<span class="keyword">node</span>.<span class="title">getNext</span>());</span><br><span class="line">            size--;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object[] getAll()</span><br><span class="line">    &#123;</span><br><span class="line">        Object[] values = new Object[size];</span><br><span class="line">        int index = <span class="number">0</span>;</span><br><span class="line">        for(<span class="keyword">Node</span> node:<span class="title"> array</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            while(<span class="keyword">node</span> <span class="title">!= null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                values[index++] = <span class="keyword">node</span>.<span class="title">getValue</span>();</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= node</span>.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p>java.util.Arrays类，有一系列操作数组的方法。这是一个私有类</p><p>静态方法：</p><ul><li>equals(): 比较两个数组是否相同</li><li>fill(): 向数组中填充数据</li><li>sort(): 把数组升序排列</li><li>parallelSort(): 开启多个线程，以并发的方式对数组中元素进行排序，提高效率</li><li>asList()把一个数组变成List</li></ul><p>例： Arrays.sort(a);</p><h1 id="用-…-声明数目可变参数"><a href="#用-…-声明数目可变参数" class="headerlink" title="用 … 声明数目可变参数"></a>用 … 声明数目可变参数</h1><p>可以用int… a代替 int[] a;这种模式下如果输入立即数可以转化成数组类型：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>... datas)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//可以直接输入数据</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure></div><p>但是必须要放在参数列表的最后一位</p><p>```<br>pubilc void max(int… data, String p)//错误，int… 必须放在最后<br>{<br>…<br>}</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;声明&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟内存</title>
    <link href="http://xinhecuican.github.io/post/f79e4123.html"/>
    <id>http://xinhecuican.github.io/post/f79e4123.html</id>
    <published>2020-05-12T05:37:00.000Z</published>
    <updated>2020-05-19T06:30:23.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 14:30:29 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>我们在生成程序的时候，会发现每个程序的起始地址都是一样的，那么这种一样的地址怎么赋给实际的物理地址上的呢？这就要依靠虚拟内存机制了。</p><p>虚拟内存着力于解决进程间内存分配的问题，并且它还有一个作用是使进程之间相互隔绝。例如不小心产生了一个野指针指向了其他内存的位置，但是实际上却不会破坏其他程序而只会破坏自己的程序，这是因为虚拟内存限制了每个程序所使用的空间，如果超出限制就会报错。</p><p>程序中所使用的空间叫做虚拟空间，一共有2的n次方。而系统上有一个物理地址空间。虚拟内存做的其实是把虚拟空间上的内存地址映射到物理空间上。在cpu中，有一个叫MMU的部件专门做虚拟地址和物理地址转化。</p><h1 id="虚拟内存的组织形式"><a href="#虚拟内存的组织形式" class="headerlink" title="虚拟内存的组织形式"></a>虚拟内存的组织形式</h1><p>虚拟内存中的内存其实是按页进行划分的。这类似与磁盘中的扇区概念，即使那个扇区中只有一个字节的数据，取数据时也是把一个扇区全取出来。</p><p>虚拟内存页的大小一般是4kb到2mb之间。而物理内存也是按页进行分块，并且块的大小和虚拟内存页的大小相同。</p><p>其实把程序加载到内存时也不是一股脑直接加载的，而是一块一块逐个加载，并且如果内存满了还有块替换策略，这实质上是把内存当做一级缓存使用。</p><p>虚拟页有三种情况：</p><ul><li>未分配的， 这部分内存就是虚拟内存预留出来的部分，例如malloc使用的空间，各个段之间预留出来的空间等。</li><li>缓存的， 就是加载到内存中的</li><li>未缓存的，是程序的组成部分但是还没有加载到缓存中。</li></ul><p>由于磁盘访问速度过慢（比SRAM小100000倍），所以我们要尽可能的降低未命中率。第一个办法就是增大每一块的大小（所以才会有一块甚至到2mb，有的小程序都没这么大）。第二个办法是全相连。全相连可以极大降低冲突不命中概率。第三个是使用复杂的块替换策略，这和缓存不同，因为缓存和内存之间速度也就十倍差距，所以块替换策略越简单越好，但是内存与磁盘间不命中惩罚太大，大到情愿花一些时间来找那个最不可能被替换掉。最后是使用回写策略。 <a href="https://xinhecuican.github.io/post/7d1c86da.html">缓存</a></p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>页表是存放于物理内存中的，页表中中的内容代表虚拟内存中这片地址是否被使用，如果被使用，还要存放实际的物理地址。</p><p>页表的大小是由虚拟内存大小和页大小决定的。假设虚拟内存大小矢2的n次方，页大小矢2的p次方，那么页表就有2的n-p次方条。这实际上是一种以空间换时间的策略。每个进程都有一个页表。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt></p><p>上图中左边就是页表，右下角代表磁盘。页表中灰色代表未缓存，未缓存的地址就指向磁盘。而白色代表未分配，地址直接是NULL。如果我们访问0，因为0是未缓存并且内存已满，所以要替换一块下来，假设替换第四块，那么就要把页表中三的地址给改为内存中的物理地址并且把4的地址改为磁盘中的地址。</p><p>所以当我们访问内存时，如果访问到未加载的地址，那么会触发<a href="https://xinhecuican.github.io/post/28877bf.html#more">故障异常</a>,故障异常就会把磁盘中的内存加载进来并且重新执行这条指令。</p><p>如果我们加载到页表地址是NULL的地方，那么就会抛出segmentation fault。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.PNG" alt></p><p>通过页表，我们可以让物理内存彼此分离。并且还可以让两个进程数据共享，这也使动态库可能实现。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.PNG" alt></p><p>虚拟内存还提供了安全保护机制</p><p>这个是比较完整的页表，其中多了一些权限位。后面三个是读写和执行标志位，如果读的时候没有权限，那么就会抛出保护异常，这种异常一般都会终止程序。</p><p>第一个是模式标志位。有些操作系统专有的指令用户不能执行，有些专用寄存器用户不能访问。例如关机的指令即使用户特意编写也不会执行，因为它没有权限。</p><p>操作系统下的内存空间普通用户是没有办法去访问的。如果想调用操作系统的函数，可以使用陷阱异常，产生陷阱异常时，会转到特权模式。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>首先虚拟地址的低p位是页内偏移，因为虚拟内存页的大小和实际内存页的大小相同，所以二者偏移量相同。虚拟地址高n-p位是页号。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%984.PNG" alt></p><p>这张图表示了大致过程。cpu发出虚拟地址，mmu把地址解析成两部分。然后从内存中取出对应页号的地址（cpu中有页的基地址寄存器，页地址是根据页号*每页的大小+基地址得出）。然后mmu又根据取回来的页决定是否要去取内容。如果取，那么这个页中包含了物理页号，然后根据物理页号和偏移量得出实际地址。</p><p>如果标志位是0，那么还要到磁盘中去取出对应页放到内存中并且更新页表。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%985.PNG" alt></p><p>虚拟内存最大的问题就是显著增加了访问时间，本来只要访问一遍的现在要访问两遍。所以在mmu中又加了tlb寄存器专门用来存放页表。现在访问页表不用找内存了，直接找这个寄存器就可以了。如果没有找到再去内存中找并且更新tlb。</p><p>但是现代cpu都是多进程的。每个进程都有自己独立的页表，即使对应的内存相同可能标志位不同，也就是说每次更换进程都要把tlb清空一遍。一种解决办法是传给tlb页号的同时也传递一个进程信息，tlb也储存一个进程信息。</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>假设虚拟内存大小是2的48次方，每页大小矢4kb，每个页表项8字节，那么页表大小矢2的39次方也就是512G。这在现实中显然是不可能实现的，所以要想办法把页表压缩。</p><p>我们很容易想到的一个办法是那些未分配的虚拟内存就不要建立页表项了，但是这样会带来一个问题。原来我们在查找页表的时候都是直接寻址，这是因为假设页表中每一项都存在，现在我们有一些项缺失了，直接根据页号查表的方法也就不行了，只有一个个比对，这样有增大了时间消耗。</p><p>我们可以建立一个多级页表，外层页表每一个页表项缓存的比较大，例如2mb甚至4Gb等，然后这一项中的内容不是物理页号，而是下一级页表的地址，之后下一级页表比上一级小，到最后一级就存储物理页号。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.jpg" alt></p><p>如上图，最外面一层就占着最高位，然后依次递减。这是因为一旦最外层选中了就说明最高几位是那几号，那么就不用管了。</p><p>这样看起来好像是用空间并没有减少，因为到最后一层还是要建立，并且中间几层还要额外消耗空间。实际上如果某个缓存块是未分配的，那么就不会建立下一级页表了。而外面几层页表锁包含的比较大，这样一下就可以排除几百个G的未分配空间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先补充一下前面tlb结构。tlb也是一个缓存并且是组相联结构，这就代表着传递信息中必须要包含组号，然后剩余的是标志位。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.jpg" alt></p><p>上图中tlbi就是组号，前面的是标志位。mmu传给tlb的只有vpn。</p><p>先是cpu发出虚拟内存地址，然后mmu开始解析，解析处vpn传给tlb，如果tlb解析成功那么再传给mmu物理页号并与vpo合成成物理地址。之后在把物理地址发给缓存。按缓存的方式处理。</p><p>如果tlb未命中，那么会到内存系统（包括缓存）中用页表基地址寄存器（CR3）找到最外层的页表然后一层层解析找到物理页号，然后把页号发给mmu的同时缓存那一片区域给tlb。</p><p>如果内存系统中也没有命中（未缓存或者未分配），那么就出触发缺页异常，通过缺页异常判断是未分配还是未缓存还是其他情况。</p><p>缺页异常时判断与一个链表有关。我们知道虚拟内存时分为若干个段的，每个段都有起始地址和终止地址还有一些权限标志位，这个链表就是存放这些信息。当2发生缺页异常时，会判断这个地址是否是在这些段中，如果不在，那么直接抛出Segmentation Fault。如果在那么判断标志位，如果判断不成功会抛出保护异常，如果判断成功了然后再去磁盘中取数据。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 14:30:29 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;p&gt;我们在生成程序的
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
