<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-04-04T12:54:41.995Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gdb</title>
    <link href="http://xinhecuican.github.io/2020/04/03/gdb/"/>
    <id>http://xinhecuican.github.io/2020/04/03/gdb/</id>
    <published>2020-04-03T08:44:00.000Z</published>
    <updated>2020-04-04T12:54:41.995Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><h3 id="进入gdb"><a href="#进入gdb" class="headerlink" title="进入gdb"></a>进入gdb</h3><p>首先gdb一般都是用来调试c或c++的，gdb是要运行可执行文件的，所以先要进行编译。具体命令如下：</p><p><code>gcc -g 源文件.c -o 输出的目标文件</code></p><p>-g是用来插入编译所需的信息, -o是用来生成可执行文件</p><p>生成的时候会产生一大堆信息，如果不想看的话可以使用 -q 选项，如果想永久设定可以在bashrc中设置别名 alias gdb = ‘gdb -q’</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>start</td><td>进入main函数</td><td>无</td></tr><tr><td>run</td><td>重新开始运行 run-text 加载文本文件 run-bin加载二进制文件</td><td>r</td></tr><tr><td>next</td><td>执行一行程序，不进入函数，直接把函数执行完</td><td>n</td></tr><tr><td>step</td><td>执行一行程序，进入函数</td><td>s</td></tr><tr><td>list</td><td>查看程序，list+函数名查看函数</td><td>l</td></tr><tr><td>continue</td><td>继续执行到断点处</td><td>c</td></tr><tr><td>quit</td><td>终止程序</td><td>q</td></tr><tr><td>set 参数</td><td>设置断点</td><td>无</td></tr><tr><td>nexti</td><td>运行一条机器指令</td><td>ni</td></tr><tr><td>jump + 标号</td><td>跳转到某一位置执行</td><td>j</td></tr></tbody></table><p>注意jump命令跳转后仍是一直执行，所以要在某一位置手动设置断点</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>return</td><td>退出函数且不执行后面代码，也可以return+参数指定返回值</td><td>无</td></tr><tr><td>finish</td><td>退出函数且执行完剩下的代码</td><td>无</td></tr><tr><td>call/print</td><td>直接调用函数执行</td><td>无</td></tr><tr><td>info files</td><td>显示所有程序及位置</td><td>无</td></tr><tr><td>info functions（regex）</td><td>显示函数（可加正则表达式）</td><td>无</td></tr><tr><td>set step-mode on</td><td>进入不带调试信息的函数（如printf）</td><td>无</td></tr></tbody></table><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>break</td><td>设置断点</td><td>b</td></tr><tr><td>tbreak</td><td>设置临时断点（智能使用一次）</td><td>tb</td></tr><tr><td>info breakpoints</td><td>查看当前所有断点</td><td>i b</td></tr><tr><td>enable/disable breakpoints</td><td>启用/禁用断点</td><td>无</td></tr><tr><td>clear+编号</td><td>删除断点</td><td>无</td></tr><tr><td>** break参数 **</td><td></td><td><strong>例</strong></td></tr><tr><td>*+地址</td><td>在某一地址设置断点</td><td>b *0x400522</td></tr><tr><td>函数名</td><td>在某一函数进入前停止</td><td>b main</td></tr><tr><td>行号</td><td>在某一行号处设置断点</td><td>b 7</td></tr><tr><td>+offset/-offset</td><td>在当前行前后offset行设置</td><td>无</td></tr><tr><td>break … if &lt; condition&gt;</td><td>只有在条件满足时，断点才会被触发</td><td>b 10 if i==101</td></tr><tr><td>ignore bnum count</td><td>忽略bnum次编号为count的断点</td><td>ignore 1 5</td></tr><tr><td><strong>观察点</strong></td><td>观察变量值的变化</td><td></td></tr><tr><td>watch</td><td>当一个值发生变化时，程序会停下来，相当于是写观察点</td><td>无</td></tr><tr><td>reatch</td><td>当一个值发生读行为时，程序停止</td><td>无</td></tr><tr><td>awatch</td><td>每次读取或改变a的值都会让程序停下来</td><td>aw</td></tr><tr><td>info watch</td><td>显示观察点</td><td>i watch</td></tr><tr><td><strong>catchpoint</strong></td><td>当程序异常终止或加载链接库时停止运行，这里不展开</td><td></td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">）设置catchpoints:</span></span><br><span class="line"><span class="attr">a. catch event:</span> <span class="string">当事件event发生的时候，程序停止运行，这里event的取值有：</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">）throw:</span> <span class="string">C++抛出异常</span></span><br><span class="line"><span class="number">2</span><span class="string">）catch:</span> <span class="string">C++捕捉到异常</span></span><br><span class="line"><span class="number">3</span><span class="string">）exec:</span> <span class="string">exec被调用</span></span><br><span class="line"><span class="number">4</span><span class="string">）fork:</span> <span class="string">fork被调用</span></span><br><span class="line"><span class="number">5</span><span class="string">）vfork:</span> <span class="string">vfork被调用</span></span><br><span class="line"><span class="number">6</span><span class="string">）load:</span> <span class="string">加载动态库</span></span><br><span class="line"><span class="number">7</span><span class="string">）load</span> <span class="attr">libname:</span> <span class="string">加载名为libname的动态库</span></span><br><span class="line"><span class="number">8</span><span class="string">）unload:</span> <span class="string">卸载动态库</span></span><br><span class="line"><span class="number">9</span><span class="string">）unload</span> <span class="attr">libname:</span> <span class="string">卸载名为libname的动态库</span></span><br><span class="line"><span class="number">10</span><span class="string">）syscall</span> <span class="string">[args]:</span> <span class="string">调用系统调用，args可以指定系统调用号，或者系统名称</span></span><br><span class="line"><span class="attr">b. tcatch event:</span> <span class="string">设置只停一次的catchpoint，第一次生效后，该catchpoint被自动删除</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/kevinx_xu/article/details/36261571" target="_blank" rel="noopener">这一段从网上扒的</a></p><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>disassemble 如果不带参数，会自动显示后面若干条汇编指令。简写disas</p><p>如果带一个参数，可以带函数名也可以带某一个地址，都是显示那个地址处的函数的汇编代码。</p><p>如果带两个参数，也就是起始地址和终止地址，那么就会显示两个之间的代码</p><h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>reverse-continue</td><td>反向运行程序知道遇到一个能使程序中断的事件（比如断点，观察点，异常）</td><td>无</td></tr><tr><td>reverse-step</td><td>返回到上一次执行的源代码行</td><td>无</td></tr><tr><td>reverse-stepi</td><td>返回上一条机器指令</td><td>无</td></tr><tr><td>reverse-next</td><td>返回上一次执行的源代码行，但不执行函数</td><td>无</td></tr><tr><td>reverse-nexti</td><td>反向运行到上一条机器指令，除非这条指令用来返回一个函数调用、整个函数将会被反向执行。</td><td>无</td></tr><tr><td>reverse-finish</td><td>反向运行程序回到调用当前函数的地方</td><td>无</td></tr></tbody></table><p>注意，想使用回退功能先要用record命令对指令进行录制</p><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>** 函数栈帧打印**</td><td></td><td></td></tr><tr><td>i frame</td><td>输出了当前函数堆栈帧的地址，指令寄存器的值，局部变量地址及值等信息</td><td>无</td></tr><tr><td>frame n</td><td>打印第n层的函数栈帧</td><td>无</td></tr><tr><td>up/down n</td><td>向上/向下切换栈帧</td><td>无</td></tr><tr><td>print + 数组名</td><td>打印数组内容</td><td>p</td></tr><tr><td>set print array-indexes on</td><td>打印数组时打印下标</td><td>无</td></tr><tr><td>info locals</td><td>打印局部变量值</td><td>i locals</td></tr><tr><td>backtrace full n</td><td>由内向外显示n个栈帧的值</td><td>bt</td></tr><tr><td>set print pretty on</td><td>打印结构体</td><td>无</td></tr><tr><td>p *array@len</td><td>array数组名 len 数据长度</td><td>无</td></tr><tr><td>p $寄存器名</td><td>查看某个寄存器的值</td><td>无</td></tr><tr><td>info register</td><td>查看所有寄存器</td><td>i reg</td></tr></tbody></table><h4 id="x-显示内存中内容命令"><a href="#x-显示内存中内容命令" class="headerlink" title="x 显示内存中内容命令"></a>x 显示内存中内容命令</h4><p>格式: x /nfu<addr></addr></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">n表示要显示的内存单元的个数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">f表示显示方式,</span> <span class="string">可取如下值</span></span><br><span class="line"><span class="attr">x</span> <span class="string">按十六进制格式显示变量。</span></span><br><span class="line"><span class="attr">d</span> <span class="string">按十进制格式显示变量。</span></span><br><span class="line"><span class="attr">u</span> <span class="string">按十进制格式显示无符号整型。</span></span><br><span class="line"><span class="attr">o</span> <span class="string">按八进制格式显示变量。</span></span><br><span class="line"><span class="attr">t</span> <span class="string">按二进制格式显示变量。</span></span><br><span class="line"><span class="attr">a</span> <span class="string">按十六进制格式显示变量。</span></span><br><span class="line"><span class="attr">i</span> <span class="string">指令地址格式</span></span><br><span class="line"><span class="attr">c</span> <span class="string">按字符格式显示变量。</span></span><br><span class="line"><span class="attr">f</span> <span class="string">按浮点数格式显示变量。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">u表示一个地址单元的长度</span></span><br><span class="line"><span class="attr">b表示单字节，</span></span><br><span class="line"><span class="attr">h表示双字节，</span></span><br><span class="line"><span class="attr">w表示四字节，</span></span><br><span class="line"><span class="attr">g表示八字节</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;进入gdb&quot;&gt;&lt;a href=&quot;#进入gdb&quot; class=&quot;headerlink&quot; title=&quot;进入gdb&quot;&gt;&lt;/a&gt;进入gdb&lt;/h3
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>unix文件系统</title>
    <link href="http://xinhecuican.github.io/2020/03/30/unix%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://xinhecuican.github.io/2020/03/30/unix%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-03-30T12:50:00.000Z</published>
    <updated>2020-03-31T12:09:23.589Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>文件就是任意源，有一个名称，可以从中写入读出数据。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>unix中有三种文件类型，普通文件，目录和伪文件。</p><p>普通文件是大多数时候所使用的文件，包括文本文件和二进制文件。例如，纯文本，shell脚本，源程序，配置文件，html文件等。</p><p>目录不同之处在于他们用来组织，访问其他文件。从概念上讲，目录包含其他文件。这个文件其实类似于windows下的文件夹。</p><p>伪文件有时候也称为设备文件。这种文件是物理设备的内部表示。例如键盘，显示器，打印机等，这些设备都可以当成一个文件进行访问。</p><p>有一种特殊的伪文件时proc文件，这种文件可以访问linux内核中的信息，设置可以修改Linux内核中的数据。</p><h3 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h3><p>特殊文件就是表示物理设备的伪文件。这些文件都被存放于/dev下</p><p>一些常见的设备如下</p><table><thead><tr><th>位置</th><th>硬件</th></tr></thead><tbody><tr><td>/dev/sda</td><td>SCSI硬盘</td></tr><tr><td>/dev/sda</td><td>第一分区</td></tr><tr><td>/dev/hda</td><td>硬盘</td></tr><tr><td>/dev/Ip0</td><td>打印机</td></tr><tr><td>/dev/tty</td><td>当前终端</td></tr><tr><td>/dev/random</td><td>随机数生成器</td></tr><tr><td>/dev/null</td><td>放弃输入 输入不返回内容</td></tr><tr><td>/dev/zero</td><td>放弃送站，输入返回0</td></tr></tbody></table><p>写入到/dev/null 或/dev/zero 中的任何文件都会被抛弃，因此这些文件又叫做位桶。</p><p>如果想读取随即数，只需要读取/dev/random。</p><h3 id="mkfifo-命名管道"><a href="#mkfifo-命名管道" class="headerlink" title="mkfifo 命名管道"></a>mkfifo 命名管道</h3><p>在前面我们已经介绍过了管道，那种管道是匿名管道，就是只有当程序运行的时候它才被创建。</p><p>命名管道与匿名管道的显著区别就是必须显式的创建管道，其次，当命令结束之后，管道并不会消失，而是会继续存在，除非使用命令删除他们。</p><p>通常将命名管道称为FIFO，实际上就是队列。</p><p>语法： mkfifo [-m mode] pipe</p><p>其中，mode是chmod程序使用的一种文件类型，pipe是希望创建的管道名称。</p><p>用途：经常被用来两个进程中的通信。</p><p>例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfifo fifotest</span><br><span class="line"><span class="keyword">grep</span> bash <span class="regexp">/etc/</span>passwd &gt; fifotest <span class="comment">//第一个窗口上的命令</span></span><br><span class="line">wc -l &lt; fifotest <span class="comment">//这是第二个窗口上的命令</span></span><br></pre></td></tr></table></figure><p>如果想要去除管道，只需要rm + 管道名即可。</p><h3 id="proc文件"><a href="#proc文件" class="headerlink" title="proc文件"></a>proc文件</h3><p>proc文件时那些提供一些简单途径来检查多种类型的系统信息的伪文件。proc文件可以直接从内核中提取数据。</p><p>所有的proc文件都存放在/proc目录下，在这个目录中，可以发现每一个进程对应一个子目录。</p><p>如果想提取这些进程的信息，可以使用cat命令去找到当前有那些进程正在执行，如果进入这些目录，还可以知道这些进程的详细状态。</p><p>有一个特殊的proc文件，/proc/kcore，这个文件表示计算机的实际物理内存。可以使用ls -l选项查看这个文件的大小。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="根目录-子目录"><a href="#根目录-子目录" class="headerlink" title="根目录 子目录"></a>根目录 子目录</h4><p>目录是一个树形结构，对于每一层一定会有一个根，而用root过于麻烦，所以一般用/表示根目录。</p><p>例如 ls / 表示列举根目录下的所有文件。这样 ls /bin代表列bin目录下的所有文件。但是实际上如果列举根目录下的文件是不需要加/的，直接加上名字就好了，如果想访问根目录下子目录中的文件，就需要在子目录和子目录文件之间加一个/</p><p>例如： ls homework/bomb</p><h4 id="mount-umount挂载文件系统"><a href="#mount-umount挂载文件系统" class="headerlink" title="mount umount挂载文件系统"></a>mount umount挂载文件系统</h4><p>在系统中，有许多设备，也就有许多个文件系统。但是如果都是完全分隔的话，没办法在不同文件系统之间进行访问，所以一定有一颗主树，然后其他树挂载在主树上，这一个个文件系统其实类似于windows下的磁盘分区。</p><p>当小的文件系统连接上主树时，我们称为挂载。小文件系统附加到主树上的目录叫做挂载点</p><p>一般来说，系统已经自动挂载好了子树，但是有时候需要我们手动挂载子树（例如插入u盘时，当然现在也是自动挂载了）。这时需要mount程序。这里不再展开</p><h4 id="漫游根目录"><a href="#漫游根目录" class="headerlink" title="漫游根目录"></a>漫游根目录</h4><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>/</td><td>根目录</td></tr><tr><td>/bin</td><td>基本程序</td></tr><tr><td>/boot</td><td>启动系统时所需要的文件</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/dev</td><td>设备文件</td></tr><tr><td>/home</td><td>用户home目录</td></tr><tr><td>/lib</td><td>基本共享库，内核模块</td></tr><tr><td>/lost+found</td><td>由fsck恢复的受损文件</td></tr><tr><td>/media</td><td>可移动介质的挂载点</td></tr><tr><td>/mnt</td><td>不能挂载在其他位置的挂载点</td></tr><tr><td>/opt</td><td>第三方应用程序</td></tr><tr><td>/proc</td><td></td></tr><tr><td>/root</td><td>超级用户home目录</td></tr><tr><td>/srv</td><td>本地系统提供服务的数据</td></tr><tr><td>/tmp</td><td>临时文件</td></tr><tr><td>/usr</td><td>静态数据使用的文件系统</td></tr><tr><td>/var</td><td>可变数据使用的文件系统</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;文件就是任意源，有一个名称，可以从中写入读出数据。&lt;/p&gt;&lt;h3 id=&quot;文件类型&quot;&gt;&lt;a href=&quot;#文件类型&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>线索二叉树</title>
    <link href="http://xinhecuican.github.io/2020/03/29/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://xinhecuican.github.io/2020/03/29/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-03-29T06:54:00.000Z</published>
    <updated>2020-03-30T08:46:35.634Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>普通的二叉树中空节点数量很多，例如一个有2n条分支的二叉树，其中节点数只有n-1个，空节点有n+1个，因此就要想办法把这些没用到的节点利用起来。</p><p>可以用原来的空节点去存放指针，指向其他节点，这中指针叫做线索。</p><p>记ptr指向二叉链表中的一个结点，以下是建立线索的规则：</p><p>（1）如果ptr-&gt;lchild为空，则存放指向中序遍历序列中该结点的前驱结点。这个结点称为ptr的中序前驱；</p><p>（2）如果ptr-&gt;rchild为空，则存放指向中序遍历序列中该结点的后继结点。这个结点称为ptr的中序后继；</p><p>显然，在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继，需要一个区分标志的。因此，我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是区分0或1数字的布尔型变量，其占用内存空间要小于像lchild和rchild的指针变量。结点结构如下所示。<br><img src="/images/26548237_13584034551s55.jpg" alt=""></p><p>ltag = 0 表示指向左孩子，= 1 表示指向前驱</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉线索存储结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;Link, Thread&#125;PointerTag;    <span class="comment">//Link = 0表示指向左右孩子指针；Thread = 1表示指向前驱或后继的线索</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="keyword">char</span> data;                                      <span class="comment">//结点数据</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>                <span class="comment">//左右孩子指针</span></span><br><span class="line">       PointerTag  Ltag;                               <span class="comment">//左右标志</span></span><br><span class="line">       PointerTag  rtal;</span><br><span class="line">&#125;BitNode, *BiTree;</span><br></pre></td></tr></table></figure><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以，线索化的过程就是在遍历的过程中修改空指针的过程。<br></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> BiTree pre = NULL;                 <span class="comment">//全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"><span class="comment">//中序遍历进行中序线索化</span></span><br><span class="line">void InThreading(BiTree p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>lchild);          <span class="comment">//递归左子树线索化</span></span><br><span class="line">                <span class="comment">//===</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(!p-&gt;</span>lchild)           <span class="comment">//没有左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>ltag = Thread;    <span class="comment">//前驱线索</span></span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>lchild = pre; <span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(!pre-&gt;</span>rchild)     <span class="comment">//没有右孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rtag = Thread;  <span class="comment">//后继线索</span></span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rchild = p; <span class="comment">//前驱右孩子指针指向后继(当前结点p)</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">                <span class="comment">//===</span></span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>rchild);      <span class="comment">//递归右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述代码除了//===之间的代码以外，和二叉树中序遍历的递归代码机会完全一样。只不过将打印结点的功能改成了线索化的功能。<p></p><p>因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if(!pre-&gt;rchild)表示如果为空，则p就是pre的后继，于是pre-&gt;rchild = p，并且设置pre-&gt;rtag = Thread，完成后继结点的线索化。</p><p>前驱指的是某种遍历顺序中在你前面的节点，而后继就是在你后面的节点，这也是为什么pre = p 要写在InThreading(p-&gt;lchild)后面的原因，中序遍历是先做子树的，那么它只能是右子树的前驱而不能是左子树的前驱</p><p>遍历代码</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点。</span></span><br><span class="line"><span class="comment">//中序遍历二叉线索树表示二叉树t</span></span><br><span class="line">int InOrderThraverse_Thr(BiTree t)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="function"><span class="title">p</span> = t-&gt;</span>lchild;                               <span class="comment">//p指向根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != t)                               <span class="comment">//空树或遍历结束时p == t</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span>ltag == Link)                       <span class="comment">//当ltag = 0时循环到中序序列的第一个结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">printf</span>("%c ", p-&gt;</span><span class="keyword">data</span>);                      <span class="comment">//显示结点数据，可以更改为其他对结点的操作</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">rtag</span> == Thread &amp;&amp; p-&gt;</span>rchild != t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;</span><br><span class="line">            <span class="function"><span class="title">printf</span>("%c ", p-&gt;</span><span class="keyword">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;                         <span class="comment">//p进入其右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;普通的二叉树中空节点数量很多，例如一个有2n条分支的二叉树，其中节点数只有n-1个，空节点有n+1个，因此就要想办法把这些没用到的节点利用起来。&lt;/p
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树链表构建和应用</title>
    <link href="http://xinhecuican.github.io/2020/03/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E8%A1%A8%E6%9E%84%E5%BB%BA/"/>
    <id>http://xinhecuican.github.io/2020/03/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E8%A1%A8%E6%9E%84%E5%BB%BA/</id>
    <published>2020-03-29T01:23:00.000Z</published>
    <updated>2020-03-30T08:56:57.542Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>中序</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void inorder(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> != NULL)</span><br><span class="line">    &#123; </span><br><span class="line">        inorder(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">T</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">        inorder(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前序</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void preorder(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">T</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">        preorder(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        preorder(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历同理。</p><p>这个算法是以当前节点为基点，先输出当前节点数值，然后再去输出左子树数值，然后再递归输出左子树数值知道NULL，才又递归输出右子树数值。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="二叉树构建"><a href="#二叉树构建" class="headerlink" title="二叉树构建"></a>二叉树构建</h4><p>如果我们只给出数值和构建顺序，是无法构建二叉树的。例如，给出三个数，然后给出构建顺序是123这样总共有5中构建方法。因此还要把空节点加上才可以构建。空节点的值为-1或@</p><p>前序遍历构建</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void create(binarytree *<span class="literal">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'@'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">T</span> = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">T</span> = new binarynode;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">T</span> == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">T</span>-&gt;data = c;</span><br><span class="line">        create(<span class="literal">T</span>-&gt;left);</span><br><span class="line">        create(<span class="literal">T</span>-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是先构造当前节点，如果当前节点不是空节点，那么构造左节点和右节点。如果是，直接空节点返回。</p><h4 id="计算叶结点个数"><a href="#计算叶结点个数" class="headerlink" title="计算叶结点个数"></a>计算叶结点个数</h4><p>叶节点的特点就是左右子树都是空。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int calculate(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)//空树</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;<span class="built_in">left</span> == NULL &amp;&amp; T-&gt;<span class="built_in">right</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(T-&gt;<span class="built_in">left</span>) + calculate(T-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算节点个数"><a href="#计算节点个数" class="headerlink" title="计算节点个数"></a>计算节点个数</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int calulate(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + calculate(T-&gt;<span class="built_in">left</span>) + calculate(T-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算二叉树高度"><a href="#计算二叉树高度" class="headerlink" title="计算二叉树高度"></a>计算二叉树高度</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> counthigh(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = counthigh(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">n</span> = counthigh(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">        return m &gt; <span class="built_in">n</span> ? m+<span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的思想是比较左子树和右子树高度，然后再加上根的高度。</p><h4 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h4><p>按前序遍历的方法最好复制</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">binode* <span class="keyword">copy</span>(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    binode *<span class="keyword">temp</span> = <span class="built_in">new</span> node;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">temp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">exit</span>(overflow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">temp</span>-&gt;data = T-&gt;data;</span><br><span class="line">    <span class="keyword">temp</span>-&gt;left = <span class="keyword">copy</span>(T-&gt;left);</span><br><span class="line">    <span class="keyword">temp</span>-&gt;right = <span class="keyword">copy</span>(T-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归搜索二叉树"><a href="#非递归搜索二叉树" class="headerlink" title="非递归搜索二叉树"></a>非递归搜索二叉树</h3><p>非递归构造二叉树主要用到了栈来模拟递归过程。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> inorder(binode *T)</span><br><span class="line">&#123;</span><br><span class="line">    binode *p;</span><br><span class="line">    stack&lt;binode*&gt; s;<span class="comment">//如果不行就自己构建一个栈</span></span><br><span class="line">    s.<span class="keyword">push</span>(T);<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( p == s.gettop() &amp;&amp; p != <span class="keyword">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">push</span>(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="comment">/*因为是push左子树，所以最后先push进一个空然后才会退出循环</span></span><br><span class="line"><span class="comment">        所以要先把这个NULL去掉*/</span></span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p = s.gettop();</span><br><span class="line">            cout &lt;&lt; p-&gt;data;</span><br><span class="line">            s.<span class="keyword">pop</span>();<span class="comment">//去掉p节点</span></span><br><span class="line">            s.<span class="keyword">push</span>(p-&gt;right);</span><br><span class="line">            <span class="comment">/*如果p是叶结点，那么push右边也是NULL,内层循环不会执行，然后</span></span><br><span class="line"><span class="comment">            执行pop取点NULL，之后if中又会取出上一层节点继续找右子树*/</span></span><br><span class="line">            <span class="comment">//如果右子树中还有分支，那么会继续这个过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序的含义是先找左节点，然后把中间节点退出去，找右节点，在右节点中重复找左节点。</p><p><strong>前序遍历</strong>又稍有不同，因为前序遍历是先直接输出根节点，所以根节点就不需要存入栈中，实际栈中存入的是右节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(binode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;binode*&gt; s;</span><br><span class="line">    binode *p = T;</span><br><span class="line">    s.push(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;left;<span class="comment">//进入左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s.gettop();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是先输出根，然后把右子树拖入栈中，进入左子树，如果左子树遍历完了，p-&gt;left == NULL,之后就到右子树那边去遍历。</p><p><strong>后序遍历</strong>更为麻烦，stack要用自己的，设置一个标志位确定现在是左子树还是右子树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stacknode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    binode *ptr;</span><br><span class="line">    <span class="keyword">enum</span> tag&#123;L,R&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(binode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> s;</span><br><span class="line">    stacknode w;</span><br><span class="line">    binode *p = T;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            w.ptr = p;</span><br><span class="line">            w.tag = L;</span><br><span class="line">            push(s,w);</span><br><span class="line">            p = p-&gt;leftchild;</span><br><span class="line">        &#125;<span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">continue</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">continue</span> != <span class="number">0</span> &amp;&amp; !stackempty(s))</span><br><span class="line">        &#123;</span><br><span class="line">             pop(s,w);</span><br><span class="line">             p = w.ptr;</span><br><span class="line">             <span class="keyword">switch</span>(w.tag)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">case</span> L: w.tag = R;<span class="comment">//这时算作根节点，根节点为R那么下次就会输出</span></span><br><span class="line">                      push(s,w);</span><br><span class="line">                      <span class="keyword">continue</span> = <span class="number">0</span>;<span class="comment">//退出循环</span></span><br><span class="line">                      p = p-&gt;right;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> R: <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(p != <span class="literal">NULL</span> || !stackempty(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;递归遍历&quot;&gt;&lt;a href=&quot;#递归遍历&quot; class=&quot;headerlink&quot; title=&quot;递归遍历&quot;&gt;&lt;/a&gt;递归遍历&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>进程的储存和缓冲区溢出</title>
    <link href="http://xinhecuican.github.io/2020/03/28/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%82%A8%E5%AD%98%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <id>http://xinhecuican.github.io/2020/03/28/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%82%A8%E5%AD%98%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</id>
    <published>2020-03-28T06:20:00.000Z</published>
    <updated>2020-03-28T11:04:40.197Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><h3 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h3><p>用户空间是用户可以使用的空间，与之对应的是内核空间，这是系统所使用的空间。用户空间的大小有2的48次方，远远超出了内存的大小。</p><p>用户空间主要分为四个区域：</p><ul><li>栈，栈位于用户空间的最高处，从高处向低处生长。linux系统中栈空间大小是8MB</li><li>堆， 用于存放一些动态分配的数据</li><li>数据， 用来存放全局变量，静态变量，字符串常量</li><li>代码， 存放指令和共享库</li></ul><p>在Linux中，对于大小小于某一阈值的数据，在堆中分配时是从低地址向高地址生长。反之，从高地址向低地址生长</p><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>常见原因： 申请了一个数组但是访问时越界。</p><p>我们可以把数组叫做缓冲区，超出边界就是缓冲区溢出。</p><p>常见表现，对于输入的字符串没有进行长度检查直接赋值。如果缓冲区分配在栈中，就有可能造成栈中数据的破坏。如果造成了返回地址的破坏，可能直接导致程序的崩溃。这种错误叫做 segmentation fault</p><p>这里便可以被黑客利用，先故意把返回地址破坏了并且让返回地址到他自己写的程序上，这样retq时就可以调用自己写的程序。这种方法叫做注入。一般注入的数据有三部分，第一部分是恶意的指令。第二部分是占位数据，这部分数据没什么含义，只是和指令加起来正好到返回地址处，第三部分就是篡改的地址，篡改后的地址指向缓冲区底部即恶意指令所在的地方。</p><h3 id="防御代码注入攻击"><a href="#防御代码注入攻击" class="headerlink" title="防御代码注入攻击"></a>防御代码注入攻击</h3><ul><li>程序员：不要使用不安全的函数</li><li>系统： 栈基地址随机化分配。设置可执行权限位（就是设置一些地方的bit只能当做数据而不能当做指令）</li><li>编译器： 添加栈破坏检测。通过添加金丝雀值（canary value），位于当前栈帧底部。如果金丝雀值被破坏，那么就终止程序。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;用户空间&quot;&gt;&lt;a href=&quot;#用户空间&quot; class=&quot;headerlink&quot; title=&quot;用户空间&quot;&gt;&lt;/a&gt;用户空间&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>结构体</title>
    <link href="http://xinhecuican.github.io/2020/03/24/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://xinhecuican.github.io/2020/03/24/%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2020-03-24T13:26:00.000Z</published>
    <updated>2020-03-28T11:06:09.731Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><h3 id="结构体的构成"><a href="#结构体的构成" class="headerlink" title="结构体的构成"></a>结构体的构成</h3><p>首先位于结构体中的元素在计算机也是对应存储的。而结构体的名字其实就可以看成是第一个变量的首地址。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内存中是这样的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| val | c | a[<span class="number">0</span>] | a[<span class="number">1</span>]</span><br><span class="line">p   p+<span class="number">4</span>   p+<span class="number">5</span>   p+<span class="number">9</span></span><br></pre></td></tr></table></figure><p>而变量在内存中的位置于定义时的位置是对应的</p><h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>首先说明什么事字节对齐。它指的是变量在内存中的首地址是变量的长度的整数倍。</p><p>例如定义一个int型变量，那么这个变量首地址尽量要是4的整数倍。也就是地址最后两位一定为零，如果是long型，地址最后三位一定为零</p><p><strong>为什么要字节对齐？</strong></p><p>字节对齐可以加快访问数据的效率。原因是64位处理器数据总线是64位的，一次传过来8个字节的数据，所以如果我们是按8的整倍数进行存放，那么一定可以一次性取完，但是如果不是8的整倍数，例如int型首地址是6，那么就不可以一次性取完，要两次来取。而如果我们放在4这个位置，那么一定可以一次性取完。</p><p>此外例如首地址是2，这样也可以一次性取完，但是这样会造成空间浪费，因为现在不能再存int型了，可能会导致剩下4个字节都不能用。</p><p>对于x86系列，可以通过拼凑的方式把数据合起来。但是arm系列，如果没字节对齐，甚至会直接报错。</p><p>因此对于上面这个例子在c这个位置后面应该是p+8,为了让后面的整型保持对齐。而这多出的三个字节不会被使用（从此我们可以得出定义char型最好定义4个，不然多浪费）</p><p>此外，结构体的首地址的倍数由后面元素中占用空间最多的那个来决定。<strong>结尾的地址也要是占用空间最多的整倍数</strong>。结尾也要符合标准是为了便于用数组，因为数组的地址是连续的，所以每个的头和尾都要满足要求。</p><p>字节对齐还有利于结构体中元素的访问。我们之所以可以直接写a.data是因为每个元素在结构体中所占用的空间大小是一样的（考虑字节对齐），这样我们就可以像数组那样直接加上一个偏移量去访问。</p><p><strong>提示</strong>，为了节省空间，把相同类型的元素放到一块写，</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">|</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodeb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，第一种写法为保证字节对齐需要多消耗6字节的空间，而第二种写法只需要消耗两字节的空间。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;结构体的构成&quot;&gt;&lt;a href=&quot;#结构体的构成&quot; class=&quot;headerlink&quot; title=&quot;结构体的构成&quot;&gt;&lt;/a&gt;结构体的构成
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>vi</title>
    <link href="http://xinhecuican.github.io/2020/03/23/vi/"/>
    <id>http://xinhecuican.github.io/2020/03/23/vi/</id>
    <published>2020-03-23T12:18:00.000Z</published>
    <updated>2020-03-29T12:12:08.360Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><h3 id="启动vi"><a href="#启动vi" class="headerlink" title="启动vi"></a>启动vi</h3><p>语法： vi [-rR] [file…]</p><p>如果用vi启动了一个不存在的文件，那么他将新建这个文件。如果只输入vi，那么他将在当前文件夹下创建一个空文件</p><p>-R 以只读模式启动</p><p>vim是vi的进阶版本</p><p>语法： vi -C [-rR] [file…]</p><p>-C是兼容模式，它将尽可能的和vi保持一样</p><h3 id="命令模式和编辑模式"><a href="#命令模式和编辑模式" class="headerlink" title="命令模式和编辑模式"></a>命令模式和编辑模式</h3><p>当使用vi时，存放数据的区域叫做编辑缓冲区（editing buffer),如果想编辑文件，那么vi就将文件的内容复制到缓冲区中，然后再缓冲区中编辑。因此处理的其实是文件的副本。</p><p>在命令模式中，输入的一切字符都是命令。例如，在命令模式中，单个字母x就是删除一个字符。dd就是删除整行的命令。</p><p>第二种模式就是输入模式。这种模式下，任何内容都会输入到缓冲区中。</p><p>在启动过程中，vi完成三件事情。将文件中的内容复制到编辑缓冲区，将光标定位到缓冲区第一行的开头。最后vi进入命令模式。</p><h3 id="数据的恢复和关闭vi"><a href="#数据的恢复和关闭vi" class="headerlink" title="数据的恢复和关闭vi"></a>数据的恢复和关闭vi</h3><p>当使用vi时，数据会保存在编辑缓冲区内，因此当程序非正常终止时，临时文件依然存在。使用-r(recovery)就可以重新打开缓冲区</p><p>如果需要先保存再退出，使用的命令时ZZ,即先按下shift键，然后按z两次。这个命令不需要按enter键</p><p>如果不保存直接退出，可以 :q!，然后按return键</p><h3 id="vi屏幕的格式即vi和ex命令"><a href="#vi屏幕的格式即vi和ex命令" class="headerlink" title="vi屏幕的格式即vi和ex命令"></a>vi屏幕的格式即vi和ex命令</h3><p>屏幕底部的一行叫做命令行。这一行有两种功能：显示消息和显示键入时的命令。</p><p>大多数时候vi编辑的数据都是纯文本（字母，数字，标点符号等）。如果想输入控制字符，需要使用^v。 例如，如果想输入^c,那么需要输入^v^c.</p><p>vi和ex命令其实都是vi编辑器中的命令。大多数vi命令都是单字母或双字母形式。大多数vi命令无需按下return键。例如，一但输入dd，那么立刻会删除一行。</p><p>ex命令一般都比较长，并且在键入过程中会显示在屏幕下方。如果键入有错误，可以backspace删除单个字符或者^x/^u删除所有字符。</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>h 向左移动一个字符</p><p>j 向下移动一个字符</p><p>k 向上移动一个字符</p><p>l 向右移动一个字符</p><p>另外一种方式是上下左右键。</p><p>此外，backspace 向左移动一个位置，space向右移动一个位置。-号移动到上一行，+号移动到下一行。</p><p>0移动到当前行的开头，$移动到当前行的结尾。^移动到第一个非制表符/空格字符上</p><p>w移动到下一个单词的开头，e移动到下一个单词的结尾。b移动到上一个单词的开头</p><p>W，E，B的作用和w，e，b的作用相同，但是忽略标点符号</p><p>( 移动到上一个句子</p><p>) 移动到下一个句子</p><p>{ 移动到上一个段落</p><p>} 移动到下一个段落</p><p>句子的定义时一个字符串，以句号，逗号，问号和感叹号结尾，并且后面要接一个新行字符或者两个空格</p><p>H 移动到屏幕的顶部（是当前屏幕，不是整个文章）</p><p>M 移动到屏幕的中间</p><p>L 移动到屏幕的底部</p><p>为了增强命令的功能，可以在命令之前输入数字确定重复次数。例如：10w代表跳过十个单词。不需要输enter。</p><h4 id="整屏移动"><a href="#整屏移动" class="headerlink" title="整屏移动"></a>整屏移动</h4><p>^f(ctrl+f,forward) 移动到下一屏</p><p>^B(backward) 移动到上一屏</p><p>^d 下移半屏，^u 上移半屏</p><p>这里^d和^u前面加数字与前面略有不同。前面只对该次有效，而这里是一直有效</p><h4 id="跳转到前一位置"><a href="#跳转到前一位置" class="headerlink" title="跳转到前一位置"></a>跳转到前一位置</h4><p>可以使用两个反引号跳转到前一位置。这个前一位置并不简单指的是上一条指令的位置。如果你一直使用行跳转的话那么这条指令将会带你去没进行行跳转时的位置。其实相当于保存了两个地址，你可以在两个地址之间跳转进行修改，第一个地址就是每跳转之前的地址。第二个地址就是跳转之后的地址。如果你现在位于第二个地址上，那么进行跳转只会改变第二个地址。用了反引号后直接回到第一个地址，然后如果再在第一个地址上跳转，那么只会修改第一个地址。</p><p>第二个跳转地址是在你第一次使用移动命令后产生的，也可以看为开始第一个地址和第二个地址再同一位置。之后一直都是在对第二地址进行修改。</p><p>如果使用两个单引号，那么将会回到对应地址的开头。</p><p>此外，我们还可以通过设置标识来新增跳转地址。先键入m，再输入标识符，之后就可以直接跳转到有标识符的位置。标识符是不可见字符，所以最好自己先记好。</p><p>例如： ma设置a标识符。 `a回到a的位置</p><h3 id="搜索模式"><a href="#搜索模式" class="headerlink" title="搜索模式"></a>搜索模式</h3><p>符号： / ?</p><p>/ 向下面搜索，/+字符表示要搜索哪个字符。如果还想继续搜索该字符只需要输入/然后回车就会搜索下一个</p><p>？ 用法相同，向上搜索</p><p>或者按n继续向下搜索，N继续向上搜索</p><p>此外，还可以使用正则表达式中的锚</p><h3 id="使用行号和切换模式"><a href="#使用行号和切换模式" class="headerlink" title="使用行号和切换模式"></a>使用行号和切换模式</h3><p>可以通过 :set number 设置显示行号</p><p>如果行号关闭，可以通过 ^G键查看现在在文本中的哪个位置</p><p>可以通过 数字+G（大写）跳转到任意一行</p><p>此外，还可以通过 :+数字跳转到任意一行，其中 :$ 跳转到文本末尾</p><p>前文已经说了vi有两种模式，一种是编辑模式，一种是命令模式，从编辑模式切换成命令模式只有一种方法，按esc键。但是从命令模式转换到编辑模式有十二种之多</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">i</span> <span class="string">在当前光标之前插入字符</span></span><br><span class="line"><span class="attr">a</span> <span class="string">在光标之后插入字符</span></span><br><span class="line"><span class="attr">I</span> <span class="string">在当前行的开头插入字符</span></span><br><span class="line"><span class="attr">A</span> <span class="string">在当前行的末尾插入字符</span></span><br><span class="line"><span class="attr">o</span> <span class="string">在当前行下面插入一行</span></span><br><span class="line"><span class="attr">O</span> <span class="string">在当前行上面插入一行</span></span><br></pre></td></tr></table></figure><h3 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h3><p>如果只需要修改一个字符的话，那么可以在命令模式下输入r+字符就可以修改光标后面的字符（注意不是增加而是直接把光标后面的字符变成输入的字符）</p><p>如果想要修改很多字符，可以输入R，这时会切换到输入模式。随后键入的每个字符都会替换当前字符。</p><p>如果想要修改的字符数与原来并不相同，那么可以使用s（substitute)命令把一个字符变成许多个字符。如果输入了s，那么将回到输入模式，且此时光标后面的后面的字符将会变成$，然后再输入字符，$就会变成对应的字符</p><p>例如 m|a,输入s后变成 m|$，然后输入other，就会变成 mother</p><p>此外C命令是将光标后面的字符都替换，如果输入了这个命令，那么在该行的最后将会出现$</p><p>cc命令可以替换一整行，无论光标在哪里</p><p>c+移动光标命令，这将替换从光标处到移动后的光标处所有的字符，可以有重复次数</p><h3 id="替换文本"><a href="#替换文本" class="headerlink" title="替换文本"></a>替换文本</h3><p>这里我们主要谈论的是ex命令。这些命令都以 ： 为开始。</p><p>替换语法： :s/pattern/replace/</p><p>这条命令的含义是替换第一个pattern，如果后面加上g（global），那么将替换所有pattern。</p><p>如果希望改变之前先请求同意，可以在后面加上 c（confirm）。也可以同时使用gc</p><p>如果想要删除某些pattern，只需要 :s/pattern//g即可</p><p>在s前面加上数字表示替换某些行。例如： :57s/unix/linux 表示把第57行第一次出现的unix变成linux。</p><p>如果想从当前行到末尾，那么可以使用 : . , $s/pattern/replace/</p><p>其中 .(点）表示当前行，$表示最后一行，中间用逗号分割开来。</p><h3 id="删除字符"><a href="#删除字符" class="headerlink" title="删除字符"></a>删除字符</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">x</span> 删除右边的字符</span><br><span class="line"><span class="selector-tag">X</span> 删除左边的字符</span><br><span class="line"><span class="selector-tag">D</span> 删除当前光标到本行末尾的字符</span><br><span class="line"><span class="selector-tag">d</span>+移动指令 删除从当前光标到移动指令后的字符</span><br><span class="line"><span class="selector-tag">dd</span> 删除当前行</span><br><span class="line"><span class="selector-tag">ex</span> 命令</span><br><span class="line"><span class="selector-pseudo">:lined</span> 删除指定行</span><br><span class="line"><span class="selector-pseudo">:line</span>,<span class="selector-tag">lined</span> 删除多个行</span><br></pre></td></tr></table></figure><p>如果要删除所有行，一种是 :1,$d，另一种是:%d，%指的是所有行</p><h3 id="撤销或重复改变"><a href="#撤销或重复改变" class="headerlink" title="撤销或重复改变"></a>撤销或重复改变</h3><p>撤销就是如果命令输入错误，可以使用命令撤销</p><p>u 撤销上一命令对缓冲区进行的修改</p><p>U 恢复当前行</p><p>. 重复上一命令对编辑缓冲区进行的修改</p><p>其中 U 指的是将撤销至移动到当前行的那一刻起，对当前行所进行的所有改变</p><p>.命令可以用来重复，但是如果使用了撤销，那么它将会使用撤销所恢复的命令</p><h4 id="恢复删除"><a href="#恢复删除" class="headerlink" title="恢复删除"></a>恢复删除</h4><p>每当删除<strong>一行或者多行</strong>文本时，vi都将文本储存在一个缓冲区中，这个缓冲区称为编号缓冲区。vi有9个缓冲区。在任何时候，都可以将一个编号缓冲区中的内容插入到编辑缓冲区中。这样做时，需要键入一个双引号（“），后面跟着缓冲区的编号，再后面跟着一个p（put)命令，p是在当前行下面插入，P是在当前行上面插入。</p><p>如果你忘记是哪个编号缓冲区的话，可以先撤销一次，然后使用.号重复插入，这时vi将自动把缓冲区编号加1</p><h3 id="移动文本"><a href="#移动文本" class="headerlink" title="移动文本"></a>移动文本</h3><p>vi总是在一个称为无名缓冲区的地方为上一次删除保存一个副本。与编号缓冲区不同，编号缓冲区只会保存删除的多行，删除少数字符是不会被保存的。</p><p>p 命令用来把无名缓冲区的内容插入到当前位置之后</p><p>考虑组合命令xp，x是删除当前光标处的字符。p是把字符插入光标的右边。这样相当于把两个自住房换了一下顺序。</p><p>另一个重要的组合命令是deep，这个命令是将两个单词换序</p><p>ddp 调换两行，因为dd是删除一行，删除这行后光标在原本该行的下一行，然后p是插入到这一行的后一行，相当于两行换了位置。</p><h3 id="复制文本"><a href="#复制文本" class="headerlink" title="复制文本"></a>复制文本</h3><p>复制文本分为三步：</p><ol><li>使用y，yy或Y命令将文本有编辑缓冲区复制到无名缓冲区中，但不删除原始文本。</li><li>将光标移动到希望插入文本的位置。</li><li>使用p或P命令命令执行插入</li></ol><p>在不删除文本的情况下将文本复制到无名缓冲区，叫做接出（yank)，因此将命令命名为y，yy，Y。y，yy命令和d命令执行情况相同，</p><h3 id="改变字母大小写"><a href="#改变字母大小写" class="headerlink" title="改变字母大小写"></a>改变字母大小写</h3><p>符号： ~</p><p>该命令会改变vi当前字母的大小写，然后将光标向前移动一个字符。改变大小写的意思是把大写变成小写，小写变成大写。</p><p>有些版本的vi使用这个命令不会超过一行，just like me。</p><h3 id="设置选项"><a href="#设置选项" class="headerlink" title="设置选项"></a>设置选项</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> showmode 输入模式提醒</span><br><span class="line">:<span class="builtin-name">set</span> number 显示行号</span><br><span class="line">:<span class="builtin-name">set</span> nonumber 不显示行号</span><br><span class="line">:<span class="builtin-name">set</span> tabstop = number 设置制表符间距</span><br><span class="line">:<span class="builtin-name">set</span> autoindent 缩进以匹配上一行/下一行</span><br><span class="line">:<span class="builtin-name">set</span> autowrite 如果文本已修改，则在切换文件前保存</span><br><span class="line">:<span class="builtin-name">set</span> errorbells 显示错误信息时发出声音</span><br><span class="line">:<span class="builtin-name">set</span> list 将制表符显示成^I,将行的结束显示成$</span><br><span class="line">:<span class="builtin-name">set</span> showmatch 显示匹配的 () &#123;&#125; []</span><br><span class="line">:<span class="builtin-name">set</span> wrapscan 环绕文本进行搜索</span><br><span class="line">:<span class="builtin-name">set</span> lines 设置文本行数</span><br><span class="line">:<span class="builtin-name">set</span> wrapmargin = n 在键入过程中自动换行，n是离右边缘的位置，例如<span class="attribute">n</span>=6意味着在例右边缘6个字符的地方换行，为0关闭自动换行</span><br></pre></td></tr></table></figure><p>如果想查看当前选项是在什么状态，可以使用:set 选项？</p><p>如果显示所有选项的值，可以使用 :set all</p><h3 id="复制移动行"><a href="#复制移动行" class="headerlink" title="复制移动行"></a>复制移动行</h3><p>如果想指定行号进行移动，可以使用ex命令中的 :co(copy) :m(move)</p><p>:5co10,复制第5行，并将其放在第10行的下面</p><p>:4,8co20 复制4到8行，并将其放在20行的下面</p><h3 id="输入shell命令"><a href="#输入shell命令" class="headerlink" title="输入shell命令"></a>输入shell命令</h3><p>可以通过 :!+命令的方式，在不退出vi的情况下进行shell命令</p><p>:!! 重复上一条shell命令</p><p>如果现在缓冲区中直接插入shell命令的输出，可以使用 :r !</p><p>例如 :1r !date，就是将date输出插入第一行的后面</p><p>如果直接用感叹号，那么就会将文件中的数据交给shell命令进行操作，然后再将操作后的文件复制到原位置</p><p>例如： 5!!sort ，这个命令将会从当前开始把接下来5行排序。</p><p>!}sort 这个命令是将接下来一段排序。</p><h3 id="将文件中的数据插入编辑缓冲区中"><a href="#将文件中的数据插入编辑缓冲区中" class="headerlink" title="将文件中的数据插入编辑缓冲区中"></a>将文件中的数据插入编辑缓冲区中</h3><p>语法： :[line]r file</p><p>line 是行号 file是文件名</p><p>:r命令读取文件中的内容，然后将其插入指定行的后面</p><h3 id="不退出vi的情况下进行保存"><a href="#不退出vi的情况下进行保存" class="headerlink" title="不退出vi的情况下进行保存"></a>不退出vi的情况下进行保存</h3><p>:w 将数据写入原有文件<br>:w file 将数据写入一个新文件中<br>:w! file 覆盖原有文件<br>:w&gt;&gt; file 将数据追加到一个新文件中<br>:10w! save 将特定行保存到文件中<br>:wq 保存退出vi 和 ZZ有同样的效果</p><h3 id="切换到一个新文件"><a href="#切换到一个新文件" class="headerlink" title="切换到一个新文件"></a>切换到一个新文件</h3><p>:e + 文件名</p><p>当编辑一个新文件时，原有缓冲区内容会消失，所以首先要使用 :w保存.当使用:e时，系统会自动检查是否保存，如果没有保存，不允许切换到新文件。如果希望忽略这种保护，可以使用:e!命令</p><h3 id="使用缩写"><a href="#使用缩写" class="headerlink" title="使用缩写"></a>使用缩写</h3><p>:ab [short long]</p><p>short是缩写，long是缩写的原文。如果确定了缩写，那么在编辑模式下，如果拼写了缩写，系统会自动变成全称。当然，只有在这个缩写是一个单词（两边有空格）的情况下才会变全称。</p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>:map命令可以创建命令模式下的缩写，实际上，这就可以自己创建命令。这些命令叫做宏</p><p>语法： :map [x commands]</p><p>x是一个字符，commands是vi或ex命令序列</p><p>例如 :map K deep就是将两个单词换位的命令设置成一个宏</p><h3 id="初始化文件"><a href="#初始化文件" class="headerlink" title="初始化文件"></a>初始化文件</h3><p>对于vim来说，初始化文件是.vimrc,</p><p>如果想删除一个缩写，可以使用 :una short</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;启动vi&quot;&gt;&lt;a href=&quot;#启动vi&quot; class=&quot;headerlink&quot; title=&quot;启动vi&quot;&gt;&lt;/a&gt;启动vi&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编 函数</title>
    <link href="http://xinhecuican.github.io/2020/03/19/%E6%B1%87%E7%BC%96-%E5%87%BD%E6%95%B0/"/>
    <id>http://xinhecuican.github.io/2020/03/19/%E6%B1%87%E7%BC%96-%E5%87%BD%E6%95%B0/</id>
    <published>2020-03-19T07:30:00.000Z</published>
    <updated>2020-03-26T04:44:25.193Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>进入函数在汇编中其实就是callq，出函数就是retq。</p><p>而callq和retq的功能之前已经提到过</p><h3 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h3><p>在x86-64位系统中，有六个寄存器负责传入参数，分别是rdi，rsi，rdx，rcx,r8,r9，同时程序返回时返回值放在rax中。如果大于6个，多的部分就要放在栈上。如果我们想操作在栈上的参数，就要通过 x(%rsp)来操作了。</p><p>例如有7个参数，此时第7个参数就放在栈上那么 8(%rsp)就可以访问这个参数了，pushq操作分为两部分，首先是rsp-8，然后把数据放进去。这个时候其实数据就是在rsp-rsp+8的区域中，也就是说我们直接movq (%rsp)…就可以访问到我们刚才放进去的元素了</p><p>我们这里不采用(%rsp)的原因是因为调用函数是callq，在最后应该是把rip放到栈中，所以要加8到下一个元素。</p><p>如果有8个参数，那么栈中要先存第8个，然后再存第7个。</p><h3 id="栈上的局部储存"><a href="#栈上的局部储存" class="headerlink" title="栈上的局部储存"></a>栈上的局部储存</h3><p>由于现代编译器的不断优化和寄存器的增多，我们一般不把局部变量放到栈中，但是有的时候我们不得不把他们放到栈中。</p><ol><li>寄存器不足时</li><li>某一变量用了&amp;（取地址），因此这个时候不得不把它放到栈中，这样才有一个地址</li><li>当局部变量是数组或结构体时</li></ol><p>例如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">long <span class="keyword">caller</span>()</span><br><span class="line">&#123;</span><br><span class="line">    long <span class="keyword">x</span> = <span class="number">534</span>;</span><br><span class="line">    long <span class="keyword">y</span> = <span class="number">1057</span>;</span><br><span class="line">    long sum = swap_add(&amp;<span class="keyword">x</span>, &amp;<span class="keyword">y</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">汇编代码为：</span><br><span class="line"><span class="keyword">caller</span>:</span><br><span class="line">  subq $16, %rsp</span><br><span class="line">  movq $534, (%rsp)</span><br><span class="line">  movq $1057, <span class="number">8</span>(%rsp)</span><br><span class="line">  leaq <span class="number">8</span>(%rsp), %rsi</span><br><span class="line">  movq %rsp, %rdi</span><br><span class="line">  callq swap_add</span><br><span class="line">  ...</span><br><span class="line">  addq $16,%rsp</span><br></pre></td></tr></table></figure><p>汇编中第一行代码为rsp-16，这是为局部变量分配内存空间。534存在最近的一个，1057存在较远的一个，这与前面多个参数存储符合。</p><p>注意在这个函数结束时，分配的栈空间也要清除，也就是最后的addq</p><p>例2：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">long call_proc()</span><br><span class="line">&#123;</span><br><span class="line">    long <span class="keyword">x</span><span class="number">1</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="comment">    int x2 = 2;</span></span><br><span class="line"><span class="comment">    short x3 = 3;</span></span><br><span class="line"><span class="comment">    char x4 = 4;</span></span><br><span class="line"><span class="comment">    proc(x1,&amp;x1,x2,&amp;x2,x3,&amp;x3,x4,&amp;x4);</span></span><br><span class="line"><span class="comment">    return x1-x2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">汇编：</span></span><br><span class="line"><span class="comment">call_proc:</span></span><br><span class="line"><span class="comment">  subq $32,%rsp</span></span><br><span class="line"><span class="comment">  movq $1, 24(%rsp)</span></span><br><span class="line"><span class="comment">  movq $2, 20(%rsp)</span></span><br><span class="line"><span class="comment">  movq $3, 18(%rsp)</span></span><br><span class="line"><span class="comment">  movq $4, 17(%rsp)</span></span><br><span class="line"><span class="comment">  leaq 17(%rsp), %rax</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  movq %rax, 8(%rsp)</span></span><br><span class="line"><span class="comment">  movl $4, (%rsp)</span></span><br><span class="line"><span class="comment">  leaq 18(%rsp), %r9</span></span><br><span class="line"><span class="comment">  movl $3, %r8d</span></span><br><span class="line"><span class="comment">  leaq 20(%rsp), %rcx</span></span><br><span class="line"><span class="comment">  movl $2,%edx</span></span><br><span class="line"><span class="comment">  leaq 24(%rsp), %rsi</span></span><br><span class="line"><span class="comment">  movl $1, %edi</span></span><br><span class="line"><span class="comment">  call proc</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">  add $32,%rsp</span></span><br></pre></td></tr></table></figure><p>注意空行前面是存储地址，因为后面函数的参数中有使用。空行后面就是把8个参数赋值。可能这里会有疑问就是这里把参数都赋了值，那么函数返回到原函数时那些参数值不都变了吗？</p><p>按照惯例，寄存器 %rbx，%rbp 和 %r12到%15被划分成被调用者保存寄存器，也就是说，这些寄存器在被调用的函数中都会保存好，因此我们可以把参数存在这些寄存器中，然后需要的时候又从这些寄存器中取出来，这样就保证了参数值不会被改变。其他寄存器[1]<br>。叫做调用者保存寄存器，这些寄存器由调用者自己去保护，例如rdi，rsi等，被调用者并不会保护这些寄存器，也就是说传入参数时，要先把这些寄存器压入栈中，以防止被改变<br>[1]:rsp除外</p><p>例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">long p(long <span class="keyword">x</span>, long <span class="keyword">y</span>)</span><br><span class="line">&#123;</span><br><span class="line">    long u = <span class="string">q(y)</span>;</span><br><span class="line">    long v = <span class="string">q(x)</span>;</span><br><span class="line">    <span class="keyword">return</span> u+v;</span><br><span class="line">&#125;</span><br><span class="line">汇编：</span><br><span class="line">p:</span><br><span class="line">  pushq %rbp</span><br><span class="line">  pushq %rbx</span><br><span class="line">  subq $8,%rsp</span><br><span class="line">  movq %rdi, %rbp</span><br><span class="line">  movq %rsi, %rdi</span><br><span class="line">  call <span class="keyword">q</span></span><br><span class="line">  movq %rax, %rbx//保存得到的函数值</span><br><span class="line">  movq %rbp, %rdi</span><br><span class="line">  calll <span class="keyword">q</span></span><br><span class="line">  addq %rbx, %rax</span><br><span class="line">  addq $8, %rsp</span><br><span class="line">  popq %rbx</span><br><span class="line">  popq %rbp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>这段代码开始把rbp和rbx拉进栈，是因为后面要改变rbx和rbp，而p本身也是一个函数，要保证被调用者保存寄存器不会被改变，之后在q函数传递参数前先把p的参数保存到rbp和rbx中，这样就保证了参数在函数中不会被破坏。之后传递参数时也可以直接从rbp中传入，</p><h3 id="栈中的内容"><a href="#栈中的内容" class="headerlink" title="栈中的内容"></a>栈中的内容</h3><p>从上面我们可以看到，栈中的内容可能会有寄存器，局部变量，下一个函数所需要的参数等。</p><p>有三类函数，一种是只有调用者的身份，一种是既有调用者又有被调用者的身份，第三种是只有被调用者的身份。</p><p>对于第一种。首先保存参数，之后保存调用者保存寄存器和局部变量，然后保存返回地址。</p><p>对于第二种，同样首先保存参数，之后保存局部变量，但是这里还可能要保存被调用者保存寄存器。同样保存返回地址</p><p>对于第三种，其他大致相同，但是不需要保存被调用者保存寄存器了。</p><p>对于函数的大致过程，首先传入参数，然后运用call进入函数。然后里面可能有一些局部变量需要保存或者寄存器需要保存，这时我们需要分配一个栈帧。之后如果进入函数，首先我们要传递参数（如果进入多个函数且这些函数运动了调用者函数的参数那此时先要把调用者参数放到被调用者保存寄存器中，防止调用者的参数被破坏）。然后call进入函数，被调用者函数返回前先要把被调用者保存寄存器中的内容弹出，和把栈帧释放。之后在调用者函数返回之前要先把调用者保存寄存器弹出，最后返回。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;进入函数在汇编中其实就是callq，出函数就是retq。&lt;/p&gt;&lt;p&gt;而callq和retq的功能之前已经提到过&lt;/p&gt;&lt;h3 id=&quot;参数的传递&quot;&gt;
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
      <category term="AT&amp;T" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/AT-T/"/>
    
    
  </entry>
  
  <entry>
    <title>压缩矩阵</title>
    <link href="http://xinhecuican.github.io/2020/03/16/%E5%8E%8B%E7%BC%A9%E7%9F%A9%E9%98%B5/"/>
    <id>http://xinhecuican.github.io/2020/03/16/%E5%8E%8B%E7%BC%A9%E7%9F%A9%E9%98%B5/</id>
    <published>2020-03-16T02:39:00.000Z</published>
    <updated>2020-03-25T05:38:49.302Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>对于特殊的矩阵，例如上下三角矩阵，对称矩阵，三对角矩阵，可以转化成1维矩阵，减小空间的消耗。</p><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>对称矩阵有 aij=aji的特性，因此可以只保存一边，也就是压缩成 <code>n(n+1)/2</code>个</p><p>如果我们用一个一维数组s[n(n+1)/2]来保存，那么它域原矩阵的对应关系</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k= <span class="built_in">i</span>(<span class="built_in">i</span><span class="number">-1</span>)/<span class="number">2</span>+<span class="built_in">j</span><span class="number">-1</span> <span class="built_in">i</span>&gt;=<span class="built_in">j</span></span><br><span class="line">    <span class="built_in">j</span>(<span class="built_in">j</span><span class="number">-1</span>)/<span class="number">2</span>+<span class="built_in">i</span><span class="number">-1</span>  <span class="built_in">i</span>&lt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure><p>这个式子先只考虑一边，先看i&gt;=j的情况。此时第一行中压缩矩阵只保存一个值，第二行两个值，依此类推。所以对于第i行先把前i-1行中对应压缩矩阵的值的数量加起来，也就死i(i-1)/2，之后再加上第j行的第j-1个（这里因为数组下标是从0开始）。</p><p>这个例子中的行数是从第一行开始，实际上应该从第0行开始，所以</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k= <span class="built_in">i</span>(<span class="built_in">i</span>+<span class="number">1</span>)/<span class="number">2</span>+<span class="built_in">j</span> <span class="built_in">i</span>&gt;=<span class="built_in">j</span></span><br><span class="line">  <span class="built_in">j</span>(<span class="built_in">j</span>+<span class="number">1</span>)/<span class="number">2</span>+<span class="built_in">i</span> <span class="built_in">i</span>&lt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure><p>举个例子，第0行第0个在k中对应位置就是0</p><h4 id="上下三角矩阵"><a href="#上下三角矩阵" class="headerlink" title="上下三角矩阵"></a>上下三角矩阵</h4><p>对称矩阵行数和列数相同</p><p>上三角矩阵其实就是对称矩阵中 i&gt;=j的那一段</p><p>下三角矩阵中第一行的压缩矩阵元素数量是n,第二行是n-1,以此类推，我们也可以得到相应的关系式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=（<span class="number">2</span>*n-<span class="built_in">i</span><span class="number">-1</span>)*<span class="built_in">i</span>/<span class="number">2</span>+<span class="built_in">j</span> <span class="built_in">i</span>&lt;=<span class="built_in">j</span></span><br><span class="line">  (<span class="number">2</span>*n-<span class="built_in">j</span><span class="number">-1</span>)*<span class="built_in">j</span>/<span class="number">2</span>+<span class="built_in">i</span> <span class="built_in">i</span>&gt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure><h4 id="三对角矩阵"><a href="#三对角矩阵" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h4><p>除了第一行和最后一行有两个元素之外，其他行都有三个元素</p><p>对于<code>a[i][j]</code>来说，前面有 3*i-1个元素，本行它前面有j-i+1个位置。所以k=2 * i+j</p><p>反之，如果在压缩矩阵中是第k个位置，那么在原矩阵中 i=(k+1)/3 j=k-2*i</p><h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p>对于非零元素较少的矩阵，可以直接用一个结构体保存 i,j ,sum，然后再用一个结构体数组来保存所有的值。这个数组是从左至右扫描遍历的。一般稀疏矩阵中元素只占5%</p><h5 id="稀疏矩阵转置的算法"><a href="#稀疏矩阵转置的算法" class="headerlink" title="稀疏矩阵转置的算法"></a>稀疏矩阵转置的算法</h5><p>首先，如果用朴素的算法，就是从第零行开始遍历每一列，然后把列变成行。</p><p>如果我们用两个数组分别保存 每一列中元素的数量以及每一列在新的稀疏矩阵中的位置，就有办法可以加快速度</p><p>例如：<img src="/images/%E6%8D%95%E8%8E%B71.PNG" alt=""></p><p><img src="/images/%E6%8D%95%E8%8E%B7.PNG" alt=""></p><p>cpot 第一个位置是一是因为数组下标从1开始</p><p>for循环中注意q=cpot[col]，代表现在这个位置已经有东西了，所以再最后++cpot[col]代表现在这一列在新稀疏矩阵的首位置要后移一位。</p><p>其次，因为转置前行号已经是从小到大排了，所以行号小的一定在前面。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;对于特殊的矩阵，例如上下三角矩阵，对称矩阵，三对角矩阵，可以转化成1维矩阵，减小空间的消耗。&lt;/p&gt;&lt;h3 id=&quot;特殊矩阵&quot;&gt;&lt;a href=&quot;#特
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>union</title>
    <link href="http://xinhecuican.github.io/2020/03/15/union/"/>
    <id>http://xinhecuican.github.io/2020/03/15/union/</id>
    <published>2020-03-15T04:52:00.000Z</published>
    <updated>2020-03-28T06:13:07.457Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>首先看一下结构体，c语言中的结构体占用字节数是所有类型字节数的总和。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用sizeof测试一下结果是8，但是如果用union呢？会发现结果是4</p><p>union中的参数共用同一块内存空间，它们在内存中起始地址都相同，也就是说同一时间内联合体中其实只会有一个参数存在，当另一个参数被赋值时，此时内存中存的就是另一个参数的值，而前面的参数会被覆盖</p><p>但是size并不一定是根据最长的那个长度来决定的（实测不是，但是不懂），还要考虑内存对齐的问题</p><p>如果此时已经给某一变量赋上了值，再用另外一个变量输出，那么内存中的编码并不会改变，只是会按找相应类型的编码方式进行编码然后输出。</p><ul><li>在c++中的使用</li></ul><p>大致相同，但是union中不能有类，如果我们在再类CA中添加了构造函数，或者添加析构函数，我们就会发现程序就会出现错误。由于union里面的东西共享内存，所以不能定义静态、引用类型的变量。由于在union里也不允许存放带有构造函数、析构函数和复制构造函数等的类的对象，但是可以存放对应的类对象指针</p><ul><li>应用 类型转换</li></ul><p>因为union共用一片地址，所以我可以通过不同的定义去访问这片地址。例如一个double类型的数据，我可以用int型访问低四字节和高四字节，并且不改变位级别的数据，这就相当于类型转换</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;首先看一下结构体，c语言中的结构体占用字节数是所有类型字节数的总和。&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;figure class=&quot;highlight cp
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>广义表</title>
    <link href="http://xinhecuican.github.io/2020/03/15/%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <id>http://xinhecuican.github.io/2020/03/15/%E5%B9%BF%E4%B9%89%E8%A1%A8/</id>
    <published>2020-03-15T01:58:00.000Z</published>
    <updated>2020-03-15T06:30:17.957Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>广义表一般记作：LS=（a1,a2,…)</p><p>其中ai在线性表中只可以是单个元素，而在广义表中即可以是单个元素，也可以是广义表。如果是单个元素，叫做原子，如果是广义表，叫做子表。当广义表非空时，第一个元素叫做广义表的表头，其余所有元素叫做广义表的表尾。</p><p>例如： A（），空表</p><p>B（e) 只有一个原子元素e,长度为1</p><p>c（a,(b,c,d)) 长度是2</p><p>d( a ( d)) 递归表</p><ul><li>广义表的储存结构</li></ul><p>通常用链式存储结构</p><p>每个节点有tag域（标志域），hp，tp三个域，但是原子节点（就是表头节点）只有两个域，标志域和值域</p><p>定义：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">glnnode</span></span></span><br><span class="line">&#123;</span><br><span class="line">    int tag;<span class="regexp">//</span>表示是原子节点还是表结点</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        int atom;<span class="regexp">//</span>原子节点值域</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ptr</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            glnnode *hp,*tp;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了空表表头指针为空外，其他表表头指针必定指向一个表节点</p><p>同一层次的表可以从第一个节点通过尾节点依次往后数，而头结点则指向一个原子节点或者是一个子表。</p><p>例如，画出c表的表示</p><p>| | | 代表tag， 头结点，尾结点</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c-&gt; 1|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> -&gt; 1</span>|<span class="string"> </span>|<span class="string"> NULL</span></span><br><span class="line"><span class="string">    </span>|<span class="string">      </span>|<span class="string">  </span></span><br><span class="line"><span class="string">    -&gt;0</span>|<span class="string">a</span>|<span class="string">   -&gt;1</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt;1</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt;1</span>|<span class="string"> </span>|NULL</span><br><span class="line">             |<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">             -&gt;0|<span class="string">b</span>|<span class="string">  -&gt;0</span>|<span class="string">c</span>|<span class="string">  -&gt;0</span>|<span class="string">c</span>|</span><br></pre></td></tr></table></figure><p>这个代表的是 c=（a,(b,c,d))，可以看到，第一层节点的数目就是表的长度，第一层如果头结点接一个原子节点，那么在表中代表一个数，如果接一个表节点，代表一个子表，同理，第二层头节点如果是一个数，那么就代表第二层增加一个元素，如果头结点接一个表节点，那么说明还有一个子表</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;广义表一般记作：LS=（a1,a2,…)&lt;/p&gt;&lt;p&gt;其中ai在线性表中只可以是单个元素，而在广义表中即可以是单个元素，也可以是广义表。如果是单个元素
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编指令 AT&amp;T版 64位</title>
    <link href="http://xinhecuican.github.io/2020/03/12/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4-AT-T%E7%89%88-64%E4%BD%8D/"/>
    <id>http://xinhecuican.github.io/2020/03/12/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4-AT-T%E7%89%88-64%E4%BD%8D/</id>
    <published>2020-03-11T23:46:00.000Z</published>
    <updated>2020-03-21T00:59:52.033Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>用g++ -Og -S -masm=intel name.c 可以生成intel格式的汇编代码，-S是生成汇编代码，-Og是省去不重要的部分，如果不加这个，可能5条指令要变成十多条指令</p><p>-fno-if-conversion 分支语句不要采用条件传输的方式，条件跳转的方式</p><p>-g debug</p><p>objdump -d 反汇编</p><p>gdb 调试 b+ 标号 设置断点 info register 查看寄存器 r 执行到断点出</p><p>n（next） 执行下一条命令</p><h4 id="mov-移动指令"><a href="#mov-移动指令" class="headerlink" title="mov 移动指令"></a>mov 移动指令</h4><p>格式： movq a,b</p><p>a是原操作数，b是目标操作数</p><p>这个指令中的q代表的是64位</p><table><thead><tr><th>长度</th><th>类型</th><th>别名</th><th>缩写</th></tr></thead><tbody><tr><td>1</td><td>char</td><td>byte</td><td>b</td></tr><tr><td>2</td><td>short</td><td>word</td><td>w</td></tr><tr><td>4</td><td>int</td><td>double word（long word）</td><td>l</td></tr><tr><td>8</td><td>long</td><td>quad word</td><td>q</td></tr><tr><td>8</td><td>char*</td><td>quad word</td><td>q</td></tr><tr><td>4</td><td>float</td><td>…</td><td>s</td></tr><tr><td>8</td><td>double</td><td>…</td><td>l</td></tr></tbody></table><table><thead><tr><th>源操作数</th><th>目标操作数</th></tr></thead><tbody><tr><td>立即数（idata)</td><td>寄存器 ，地址</td></tr><tr><td>寄存器</td><td>寄存器，地址</td></tr><tr><td>地址</td><td>寄存器</td></tr></tbody></table><table><thead><tr><th>操作数</th><th>符号</th></tr></thead><tbody><tr><td>立即数</td><td>$</td></tr><tr><td>寄存器</td><td>%</td></tr><tr><td>地址</td><td>（）</td></tr></tbody></table><p>例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $2,%rax</span><br><span class="line">movq %rax,%rbx</span><br><span class="line">mov<span class="string">q (%rax)</span>,%rbx</span><br></pre></td></tr></table></figure><p>注意；</p><ul><li>当源操作数为地址的时候，目标操作数不能也是地址，因为一定要通过cpu进行调控，从地址到地址代表没有经过cpu（解释是这样，但我觉得不太合理）</li><li>立即数不能为8字节，使用 movabsq 可以让立即数为8字节</li><li>地址都是8字节，也就是上面的char*</li><li>如果把一个32位数给64位寄存器，那么高三十二位自动变成0.但是如果是16位或者8位的话高位不会改变</li></ul><p>例如：</p><p>movabsq $0x0011223344556677,%rax</p><p>movq $-1,%rax</p><p>%rax= 00000000ffffffff</p><h5 id="地址的写法"><a href="#地址的写法" class="headerlink" title="地址的写法"></a>地址的写法</h5><p>地址可以写为一个四元组 A（寄存器1，寄存器2，B）</p><p>这个四元组其实是 寄存器1+B*寄存器2+A</p><p>其中B可以是1,2,4,8。从数组的角度来看，寄存器1相当于起始地址，寄存器2相当于偏移地址，B是一个数据的字节数</p><p>同时 64位寄存器前缀是r，三十二位前缀是e，16位没有前缀，8位后面是l和h</p><p>例：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rax</span></span><br><span class="line"><span class="built_in">eax</span></span><br><span class="line"><span class="built_in">ax</span></span><br><span class="line"><span class="built_in">al</span></span><br><span class="line"><span class="number">ah</span></span><br></pre></td></tr></table></figure><h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>格式 movzab</p><p>a代表原格式，b代表现格式，一般是从小的转换成大的。而z代表多的位补0</p><p>例： movzlq</p><p>特殊形式： cltq 把32位寄存器扩展到64位并且赋值给自己，</p><p>movsab 有符号扩展，最高位为1那么扩展出来的位全是1。</p><h4 id="leaq-地址转移"><a href="#leaq-地址转移" class="headerlink" title="leaq 地址转移"></a>leaq 地址转移</h4><p>格式 leaq 地址，寄存器</p><p>看起来与mov没什么区别，但是mov中的地址是要取地址中的数，而这里的地址只是把对应地址给寄存器</p><p>例如： leaq (%rax,%rbx,4),%rdx 这条指令类似于把数组中某一元素的地址给了rdx</p><p>它还可用来求值</p><p>例如 要求x* 12</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mul(<span class="keyword">int</span> <span class="keyword">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">   lea<span class="string">q (%rdi,%rdi,2)</span>,%rax</span><br><span class="line">   salq %rax,<span class="number">2</span>//左移指令</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">x</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码只要看中间两条指令就可以了，leaq 中的数运算之后是3rdi，然后左移两位就是12了。</p><p>但是这条指令不会判断溢出，且不会改变标志寄存器</p><h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><p>这里涉及到标志寄存器，<a href="https://xinhecuican.github.io/2020/01/29/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/">在前面一篇博客中已经提到</a></p><p>cmpq 比较指令</p><p>textq 与比较</p><p>textq b a 把a与b相与，不改变a和b的值，只会改变标志寄存器中的zf和sf。</p><p>这个指令通常用来判断某一位是否是1，例如 textq a,0x1 ，如果最低位为1，那么zf就是0，说明最低位是1</p><h5 id="标志寄存器的访问"><a href="#标志寄存器的访问" class="headerlink" title="标志寄存器的访问"></a>标志寄存器的访问</h5><table><thead><tr><th>操作名</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>sete</td><td>ZF</td><td>Equal</td></tr><tr><td>setne</td><td>~ZF</td><td>not equal</td></tr><tr><td>sets</td><td>SF</td><td>sign</td></tr><tr><td>setns</td><td>~SF</td><td></td></tr><tr><td>setg</td><td><del>(SF^OF)&amp;</del>ZF</td><td>greater 有符号数</td></tr><tr><td>setge</td><td>~(SF^OF)</td><td>大于等于</td></tr><tr><td>setl</td><td>(SF^OF)</td><td>less</td></tr><tr><td>setle</td><td>…</td><td>小于等于</td></tr><tr><td>seta</td><td><del>CF&amp;</del>ZF</td><td>above 无符号数</td></tr><tr><td>setb</td><td>CF</td><td>below 小于</td></tr></tbody></table><p>这些指令都是返回到8位寄存器上，将高七位置0，最低位依据含义所进行的运算来判断是0还是1</p><p>之后可以 movzbl %al,%eax，这时高三十二位也会被清零</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p><a href="https://xinhecuican.github.io/2020/01/31/%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%8C%87%E4%BB%A4/">前面博客中也已谈到过</a></p><p>这里再补充jg和gb等，其实就是上面同样的模式</p><p>此外，由于是64位系统，没有cs寄存器，且intel使用cisc指令集，所以会自动根据指令长度进行判断用多少位长来储存位移</p><p>此外 x86 64位系统中 还提供了一种 jmp *(%rax) 也就是把rax作为地址，取内存中的内容</p><h4 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h4><p>格式： cmov +后缀 a b，后缀格式就是前面set的格式</p><p>作用: 如果满足条件，则把a赋值给b，如果不满足，则不做处理</p><p>现代编译器在遇到分支语句时会尽量用条件跳转的格式执行，因为cpu采用了流水线作业的模式（就是一次提前搬运多条指令） 但是条件跳转指令会使流水线停止运行，而流水线可以明显增加cpu速度。</p><p>条件跳转的格式就是先把 if 和else的内容都计算出来，然后在最后用条件跳转指令进行比较。</p><p>例如</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line"><span class="meta">if</span>(<span class="meta">x</span>&gt;y)</span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="meta">x</span>-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">else</span></span><br><span class="line">&#123;</span><br><span class="line">    a=y-<span class="meta">x</span>;</span><br><span class="line">&#125;</span><br><span class="line">汇编模式</span><br><span class="line">movq <span class="name">%rdi</span>,<span class="name">%rax</span></span><br><span class="line">subq <span class="name">%rsi</span>,<span class="name">%rax</span></span><br><span class="line">movq <span class="name">%rsi</span>,<span class="name">%rdx</span></span><br><span class="line">subq <span class="name">%rdi</span>,<span class="name">%rdx</span></span><br><span class="line">cmovle <span class="name">%rdx</span>,<span class="name">%rax</span></span><br></pre></td></tr></table></figure><p>可以看出，用条件跳转模式会多计算一些指令，不会破坏流水线，如果在流水线上减少的时间大于多进行指令所消耗的时间，那么用条件跳转指令比较合适。反之，直接用条件指令。</p><p>下列几种情况不适合用条件跳转指令</p><ol><li>分支语句计算量大（执行时间过多，划不来）</li><li>在要判断是否可以运算的情况，例如 var=p ？*p ： 0，这条语句意思是如果p不为空指针那么将p的内容赋给var，否则赋0.但是如果用条件跳转会出错，因为空指针不能取值</li><li>计算可能产生副作用（即前后两个分支之间会产生影响）。例如 var=x&gt;0 ? x*=3 : x+=6,这个分支前面对后面会产生影响，因此不能简单粗暴的直接条件跳转</li></ol><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ul><li>do-while循环</li></ul><p>do-while循环用goto语句表达成</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br></pre></td></tr></table></figure><p>这段代码便是先执行，后比较。很容易就可以转化成汇编。goto可以用条件转移指令代替。</p><ul><li>while循环</li></ul><p>while循环有两种形式，第一种是在最开始进行一次跳转，如果符合则进入循环，不符合则退出</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!x) <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>第二种是先跳过第一次循环直接进行判断。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goto test;</span><br><span class="line">loop:</span><br><span class="line">statement;</span><br><span class="line">test:</span><br><span class="line">if(x) goto loop;</span><br></pre></td></tr></table></figure><p>由于cpu流水线的限制，两条连续的跳转指令会减慢cpu运行的速度，因此最好采用第一种办法（虽然代码多）</p><ul><li>for循环</li></ul><p>for(init; test; update)</p><p>可以转化成</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init<span class="comment">;</span></span><br><span class="line">while(test)</span><br><span class="line">&#123;</span><br><span class="line">  statement<span class="comment">;</span></span><br><span class="line">  update<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再然后就可以变成汇编代码</p><h4 id="switch-汇编实现"><a href="#switch-汇编实现" class="headerlink" title="switch 汇编实现"></a>switch 汇编实现</h4><p>首先要了解条件语句和switch的区别，if语句要从上倒下一条一条判断，如果数量多的话时间开销大。而switch是根据标号直接跳转，无论要跳转到哪一个时间开销都一定。</p><p>内存中实际上在编译时已经设定了一个跳转表，这个跳转表的标号是一个固定的地址，不能被改变，这个标号内的数据就是每一条指令的跳转地址，而且是8字节。</p><p>因此跳转语句可以这样写: jmp .L4(,%rdi,8)</p><p>其中.L4代表的是跳转表的标号（不一定是这个名字，举个例子）而rdi就是switch中的x，</p><p>如果标号很大，例如10000甚至1000000开始的时候，如果把前面的查找表一个个全部设置出来，空间开销会很大，所以编译器会先自动的减去一个数使他处于较小的范围，但是这种情况只适用于数据密集的情况。</p><p>如果数据稀疏例如一个是1一个是10000，这个时候偏移也不行了，只有通过先排序再二分搜索来查找标号，这个复杂度是logn</p><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul><li>inc 自增</li><li>dec 自减</li><li>neg 取负 -x</li><li>not 取非 ~x</li><li>imul 乘</li><li>xor 异或</li><li>or 或</li><li>and 与</li><li>sal shl 左移</li><li>sar 算数右移</li><li>shr 逻辑右移</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;用g++ -Og -S -masm=intel name.c 可以生成intel格式的汇编代码，-S是生成汇编代码，-Og是省去不重要的部分，如果不加
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="AT&amp;T" scheme="http://xinhecuican.github.io/tags/AT-T/"/>
    
  </entry>
  
  <entry>
    <title>在不更改注册表的情况下把程序移出c盘</title>
    <link href="http://xinhecuican.github.io/2020/03/09/%E5%9C%A8%E4%B8%8D%E6%9B%B4%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%8A%8A%E7%A8%8B%E5%BA%8F%E7%A7%BB%E5%87%BAc%E7%9B%98/"/>
    <id>http://xinhecuican.github.io/2020/03/09/%E5%9C%A8%E4%B8%8D%E6%9B%B4%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%8A%8A%E7%A8%8B%E5%BA%8F%E7%A7%BB%E5%87%BAc%E7%9B%98/</id>
    <published>2020-03-09T03:37:00.000Z</published>
    <updated>2020-03-09T03:41:59.882Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>这里用的类似于快捷方式。用mklink命令，这个命令可以将两个文件夹连接，一个是真实存放内容的文件夹，另一个只有名称，实际内容并不放在哪里。所以我们可以创建一个这样的文件夹来骗过程序。例如 office</p><p>首先要用cmd而不能用powershell，这是系统自带命令.然后在其他盘建一个同名的文件夹。注意c盘的文件夹不要创建，执行命令后系统自动创建。</p><p><code>mklink /J &quot;C:\Program Files (x86)\Microsoft Files&quot; &quot;D:\Program Files (x86)\Microsoft Files&quot;</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;这里用的类似于快捷方式。用mklink命令，这个命令可以将两个文件夹连接，一个是真实存放内容的文件夹，另一个只有名称，实际内容并不放在哪里。所以我们可
      
    
    </summary>
    
    
      <category term="windows" scheme="http://xinhecuican.github.io/categories/windows/"/>
    
    
  </entry>
  
  <entry>
    <title>c语言的动态内存分配</title>
    <link href="http://xinhecuican.github.io/2020/03/02/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://xinhecuican.github.io/2020/03/02/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</id>
    <published>2020-03-02T08:39:00.000Z</published>
    <updated>2020-03-02T10:48:43.882Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>头文件： malloc.h</p><p>原型 void* malloc( size)（不标准写法）</p><p>其中size表示的是你想申请的字节数，为了准确我们一般使用sizeof函数，而返回的是一个void指针，这就导致了我们一般都要强制类型转换到对应的类型。</p><p>例： int* p=(int*)malloc(sizeof(int))</p><p>int* p=(int<em>)malloc(10</em>sizeof(int)) //数组</p><p>前面的int* 就是强制类型转换</p><p>此外，malloc一般分配完内存后还要进行检查看是否分配成功</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p==NULL)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);<span class="regexp">//</span>退出程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且malloc是不会自动初始化的，所以在分配完内存后最好先用NULL初始化一下。</p><h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><p>字面意思，就是给一个已经分配内存的指针增加内存,原内存中的数据不变</p><p>头文件 #include &lt;stdlib.h&gt; 有些编译器需要#include &lt;alloc.h&gt;</p><p>原型： void* realloc(void *mem_address, unsigned int newsize);</p><p>mem_address是原指针，newsize是原有空间加上新增的空间</p><p>可能有下列几种情况</p><ol><li>如果原有空间后面还有足够的内存空间，那么直接在后面增加内存空间</li><li>如果原有空间不足，会重新分配空间到其他地方，同时原地址中的数据也会复制过去</li><li>如果没有可供分配的空间，返回NULL。此时，原指针仍然有效</li></ol><p>注意，如果分配成功，无论是否分到新空间，原指针都会被释放掉</p><p>如果 mem_address为0 那么和malloc相似，也是分配一块内存空间</p><p>如果 newsize为0，相当于free</p><p>也就是说，最好不要出现 p=realloc(p,size)这种写法，防止分配失败后指针直接丢失。好的办法是先用另一个参数接受realloc的内容，如果不为null，再让p=q</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* q;</span><br><span class="line">q=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(p,newsize);</span><br><span class="line"><span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>释放动态申请的内存空间</p><p>原型： void free(void* ptr)</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;malloc&quot;&gt;&lt;a href=&quot;#malloc&quot; class=&quot;headerlink&quot; title=&quot;malloc&quot;&gt;&lt;/a&gt;malloc
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>程序的进入与退出</title>
    <link href="http://xinhecuican.github.io/2020/03/02/%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%9B%E5%85%A5%E4%B8%8E%E9%80%80%E5%87%BA/"/>
    <id>http://xinhecuican.github.io/2020/03/02/%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%9B%E5%85%A5%E4%B8%8E%E9%80%80%E5%87%BA/</id>
    <published>2020-03-02T06:18:00.000Z</published>
    <updated>2020-03-02T08:38:55.716Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><h3 id="程序进入"><a href="#程序进入" class="headerlink" title="程序进入"></a>程序进入</h3><p>在c++中，程序的入口是main函数，并且main函数有两个参数</p><p>int main(int argc,char* argv[])</p><p>argc是用来记录输入的参数的数量，而argv是用来记录输入的参数。</p><p>例如： ls -la，这个输入中有两个参数，第一个参数是ls，第二个参数是-la</p><h3 id="程序退出"><a href="#程序退出" class="headerlink" title="程序退出"></a>程序退出</h3><p>return 是退出当前函数，例如退出主函数或者退出任意函数</p><p>而 exit 是退出当前进程，也就是说就算是在调用的函数中，这个程序也会直接结束</p><p>exit(0)表示正常退出，exit(1)表示异常退出，更深入的内容涉及到进程。</p><p>exit函数在stdlib.h头文件中</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;程序进入&quot;&gt;&lt;a href=&quot;#程序进入&quot; class=&quot;headerlink&quot; title=&quot;程序进入&quot;&gt;&lt;/a&gt;程序进入&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="c++" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/c/"/>
    
    
  </entry>
  
  <entry>
    <title>过滤器</title>
    <link href="http://xinhecuican.github.io/2020/03/01/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://xinhecuican.github.io/2020/03/01/%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-03-01T02:53:00.000Z</published>
    <updated>2020-03-17T13:17:25.270Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中），但是在最前面的和在最后面的不一定是过滤器。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="cat-复制"><a href="#cat-复制" class="headerlink" title="cat 复制"></a>cat 复制</h4><p>cat的用途就是把标准输入中的数据复制到标准输出中</p><p>应用：可以与重定向结合。cat &gt; data，这样从键盘中输入的数据将直接传到data文件中</p><p>此外还可以让文件内容显示在控制台上，有 cat &lt; data，标准输入变成了data文件，标准输出是屏幕。为了方便，直接cat 文件名也是可以的</p><p>此外，tail也有类似的功能，但是它只能显示最后的十行</p><p>另外一个应用就是把一个文件复制到另一个文件。例如，cat &lt; data &gt; newdata</p><h5 id="增强cat功能"><a href="#增强cat功能" class="headerlink" title="增强cat功能"></a>增强cat功能</h5><p>cat &lt; file…= cat file …</p><p>有三个点说明了可以同时输入多个文件，这样就为组合多个文件提供了途径</p><p>cat data1 data2 data3 &gt;file</p><p>后缀：</p><pre><code>-n 在每行后面加一个行号-b 与-n一起使用，不要对空白行加行号-s 将多个连续的空白行变成一个空白行</code></pre><h4 id="split-分为不同文件"><a href="#split-分为不同文件" class="headerlink" title="split 分为不同文件"></a>split 分为不同文件</h4><p>语法 split [-d] [-a num] [-l lines] [file [prefix]]</p><p>作用： 将一个大文件分解成几个小文件。默认情况下，split将创建1000行长的空间</p><p>参数：</p><pre><code>-l 创建一个5000行的空间-d 将文件名改为从00开始编号-a 后面加数字，例如3表示从000开始，总共1000个文件名</code></pre><p>默认情况下，split创建的文件将以x开头，后面加aa，ab等</p><h4 id="tac-反转复制"><a href="#tac-反转复制" class="headerlink" title="tac 反转复制"></a>tac 反转复制</h4><p>相关过滤器： cat，rev</p><p>作用：和cat类似，但是在写入文件时把文件内容反转（tac是将cat反过来）。注意，这里的反过来并不是指从后往前倒着写，而是把行与行将顺序反过来。</p><h4 id="rev-反转字符顺序"><a href="#rev-反转字符顺序" class="headerlink" title="rev 反转字符顺序"></a>rev 反转字符顺序</h4><p>相关过滤器： cat tac</p><p>作用： 将各行字符顺序反转</p><p>语法： rev [file…]</p><p>例如： 有一个文件data，里面有</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345</span></span><br><span class="line">abcde</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure><p>之后用rev后会变成</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54321</span></span><br><span class="line">edcba</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure><p>rev也是直接输出到标准输出上的，也就是说并不会对源文件造成改变，如果想输出到文件中，还要重定向一下</p><h4 id="head，tail-从数据开头或者结尾读取"><a href="#head，tail-从数据开头或者结尾读取" class="headerlink" title="head，tail 从数据开头或者结尾读取"></a>head，tail 从数据开头或者结尾读取</h4><p>语法： head/tail [-n lines]，lines是希望选择的数据行</p><p>默认情况下，head和tail都只会选择十行数据，用-n可以选择任意行数</p><p>例： calculate | tail -n 15</p><h4 id="colrm-删除数据列"><a href="#colrm-删除数据列" class="headerlink" title="colrm 删除数据列"></a>colrm 删除数据列</h4><p>相关过滤器： cut paste</p><p>colrm（“column remove”)程序从标准输入中读取数据，删除指定数据列（也就是竖的删除），将剩余数据写入标准输出</p><p>语法： colrm [startcol [endcol]]，编号从1开始</p><p>例： colrm 14 30 &lt;students | less</p><h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><h4 id="cmp-比较两个任意文件"><a href="#cmp-比较两个任意文件" class="headerlink" title="cmp 比较两个任意文件"></a>cmp 比较两个任意文件</h4><p>相关过滤器：comm diff sdiff</p><p>语法: cmp file1 file2</p><p>cmp程序逐字节的比较文件，查看两个文件是否相同。如果两个文件相同，那么不做任何处理，如果不同，将会返回第一个不同的行和列</p><h4 id="comm-比较有序文件"><a href="#comm-比较有序文件" class="headerlink" title="comm 比较有序文件"></a>comm 比较有序文件</h4><p>语法：comm [-123] file1 file2</p><p>comm程序一行一行的比较两个有序的文本间，程序输出三列，第一列输出只包含在第一个文件中的行，第二列输出只包含在第二个文件中的行，第三列输出两个文件中都有的行。</p><p>因为comm是逐行比较，所以在比较之前最好使用sort进行排序</p><p>参数： -1 -2 -3 取消第一二三列的输出</p><h4 id="diff-比较无序文件"><a href="#diff-比较无序文件" class="headerlink" title="diff 比较无序文件"></a>diff 比较无序文件</h4><p>语法： diff [-bBiqswy] [-c| -Clines | -u | -Ulines] file1 file2</p><p>lines是说明上下文关系的行号</p><p>输出： diff的输出有三个不同的单字符指示： c（change） d（delete） a（append）。这三个字符说明了要想让两个文件相同需要做哪些改变。</p><p>这三个字符左右两边都会有数字，代表着需要修改的行号。例如，3c3代表把左边文件中的第三行变成右边文件中的第三行。</p><p>diff要求改变时，就会给出每一个文件的实际行，第一个文件中的行用小于号标记，第二个文件中的行用大于号标记。两组行之间还会有横线分隔开</p><p>例如，第一个文件为</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br><span class="line">asdf</span><br><span class="line"><span class="keyword">as</span> df</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>第二个文件为</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>     </span><br><span class="line"><span class="attribute">abcd</span></span><br><span class="line"><span class="attribute">asdf</span></span><br><span class="line"><span class="attribute">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">0a1</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">a</span>     </span><br><span class="line"><span class="number">3</span><span class="string">,4c4</span></span><br><span class="line"><span class="string">&lt;</span> <span class="string">as</span> <span class="string">df</span></span><br><span class="line"><span class="string">&lt;</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure><p>a左边的数代表在左边数后面追加一行，例如0a1代表在第0行后面加上右边的第一行</p><p>d一般只需要管左边的数字，它的意思是删去左边的那一行</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-i 忽略大小写区别</span></span><br><span class="line"><span class="deletion">-w（whitespace) 忽略所有空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别，就是把多个空白符看成一个</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行，</span></span><br><span class="line"><span class="deletion">-q 当两个文本不同时，忽略所有细节，只说两文本不同</span></span><br><span class="line"><span class="deletion">-s 会明确告诉两个文本相同</span></span><br><span class="line"><span class="deletion">-c 全文比较，+代表要增加，-代表要减少，！代表要替换</span></span><br><span class="line"><span class="deletion">-u 与-c类似，但是把两个文件混合在一起显示，两个重复行只输出一个</span></span><br><span class="line"><span class="deletion">-y 把两个文件并排输出</span></span><br></pre></td></tr></table></figure><h4 id="sdiff"><a href="#sdiff" class="headerlink" title="sdiff"></a>sdiff</h4><p>语法： sdiff [-bBilsW] [-w columns] file1 file2</p><p>作用：与 diff -y 类似，并排比较<br>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-l 当两个文件有共同行时，只显示左边的列</span></span><br><span class="line"><span class="deletion">-s 不显示两个文件中任何相同的行</span></span><br><span class="line"><span class="deletion">-w+数字 改变列的宽度</span></span><br><span class="line"><span class="deletion">-i 忽略大写和小写的区别</span></span><br><span class="line"><span class="deletion">-W 忽略所有的空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行</span></span><br></pre></td></tr></table></figure><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p>例如： diff game1_ver1.0.c game2_ver2.0.c &gt; game2_ver2.1</p><p>这个命令会把第一个文件和第二个文佳之间的差保存下来，这样可以节省空间，此外在日后不慎丢失文件时也有办法快速找回</p><h4 id="cut-抽取数据列"><a href="#cut-抽取数据列" class="headerlink" title="cut 抽取数据列"></a>cut 抽取数据列</h4><p>相关过滤器： colrm join paste</p><p>语法： cut -c list [file…]</p><p>list就是要抽取的数据列，各个列之间用逗号隔开，不能有空格，或者14-19表示从14列到19列</p><p>作用：抽取指定的列</p><p>这种按列切分遇到长度不同的数据时就显得无能为力，因此还有另一种抽取方式，抽取字段，即按照一定的定界符进行分割（如逗号，空格等）</p><p>参数：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c  <span class="meta">list</span> [<span class="meta">file</span>...] <span class="meta">list</span>表明抽取第几个字段</span><br><span class="line">-f  <span class="meta">list</span> [-d <span class="meta">delimiter</span>] [-s] [<span class="meta">file</span>...]  -d后面是定界符种类 -s（suppress 抑制）抛弃没有定界符的行。例如 cut -f 1 -d <span class="string">':'</span> ./temp</span><br></pre></td></tr></table></figure><h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>语法： paste [-d char…] [file…]</p><p>其中char是用来做分隔符的字符，默认情况为一个制表符或者是空格</p><p>作用： 把几个文件组合成一个表格（组合数据列）</p><p>如果指定了不止一个定界符，那么将会轮流使用定界符</p><p>例如： paste -d ‘|%’ name phone ，这个指令中就有两个定界符</p><h3 id="统计和格式化"><a href="#统计和格式化" class="headerlink" title="统计和格式化"></a>统计和格式化</h3><h4 id="nl-创建行号"><a href="#nl-创建行号" class="headerlink" title="nl 创建行号"></a>nl 创建行号</h4><p>语法： nl [-v start] [-i increment] [-b a] [-n ln|rn|rz] [file…]</p><p>start是起始行号 ，increment是增量</p><p>作用：希望在一些数据中永久的插入行号，在输出中临时插入行号。一般状况下，插入的行号都是临时的，原始数据并不会发生改变，除非重定向输出到文件中。</p><p>默认情况下，不会对空行编号</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-v 改变起始编号，默认起始编号是1</span></span><br><span class="line"><span class="deletion">-i 改变增量，默认增量为1</span></span><br><span class="line"><span class="deletion">-b a 对所有行编号，包括空行</span></span><br><span class="line"><span class="deletion">-n ln 左对齐 rn 右对齐 rz 右对齐，有前导0</span></span><br></pre></td></tr></table></figure><h4 id="wc（word-count）统计行单词和字符的数量"><a href="#wc（word-count）统计行单词和字符的数量" class="headerlink" title="wc（word count）统计行单词和字符的数量"></a>wc（word count）统计行单词和字符的数量</h4><p>语法： wc [-clLw] [file…]</p><p>作用：统计行，单词，字符的数量。所统计的数据可以来自另一个程序或者是一个或多个文件</p><p>输出依次输出行，单词数，字符数 和文件名。如果不止一个文件，那么会为每一个文件显示一个输出，然后最后一行是一个总输出。</p><p>参数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-l 统计行</span></span><br><span class="line"><span class="deletion">-w 统计单词</span></span><br><span class="line"><span class="deletion">-c 统计字符</span></span><br><span class="line"><span class="deletion">-L 该选项显示输入中最长行的长度</span></span><br></pre></td></tr></table></figure><p>此外，还可以用wc来统计某一目录中文件的数量，假设一个文件一行，用ls file | wc -l.</p><h4 id="制表符和空格"><a href="#制表符和空格" class="headerlink" title="制表符和空格"></a>制表符和空格</h4><p>在老式机器中，会在某些特定的为做一些机器标记，这些标记叫做制表位，如果按了制表位，那么机器会直接跳转到下一个制表位上，tab键与这个作用类似。一旦按了tab键，那么他将会自动跳转到下一个制表位。例如输入<code>A&lt;Tab&gt;BBBB&lt;Tab&gt;CCC</code>，实际上看起来中间有空格，实际上只有一个Tab</p><p>可视化制表符</p><p>第一种办法是在vi中，set list 那么制表符会转化成^I符号</p><h4 id="expand-将制表符转化成空格"><a href="#expand-将制表符转化成空格" class="headerlink" title="expand 将制表符转化成空格"></a>expand 将制表符转化成空格</h4><p>语法： expand [-i] [-t size] [-t list] [file…]</p><p>其中size是固定宽度制表符的大小（默认为8)，list是制表位列表</p><p>作用：expand将输入文件中所有的制表符转化成空格，别切维持与原文本相同的对齐方式</p><p>-i 只转换开头的制表符，其他的制表符保持不变</p><h4 id="unexpand-将空格转化成制表符"><a href="#unexpand-将空格转化成制表符" class="headerlink" title="unexpand 将空格转化成制表符"></a>unexpand 将空格转化成制表符</h4><p>语法： unexpand [-a] [-t size] [-t list] [file…]</p><p>其中size是制表符的大小（希望设置的），list是制表位列表</p><p>一般情况下，unexpand只转化第一行的空格，如果想要转换所有行的空格，那么需要-a选项</p><h4 id="fold-格式化行"><a href="#fold-格式化行" class="headerlink" title="fold 格式化行"></a>fold 格式化行</h4><p>相关过滤器： fmt ,pr</p><p>语法： fold [-s] [w witch] [file…]</p><p>其中witch是新行的宽度。</p><p>作用： 将长的行分割成短行。也就是把一行分成多行。其实就是在适当位置插入一个回车符</p><p>默认状态下，80个字符为一行。</p><p>-s选项是告诉程序不要分割单词，也就是说如果那个单词正好在要分割的位置，那么现在会先显示这个单词在转到下一行。</p><h4 id="fmt-格式化段落"><a href="#fmt-格式化段落" class="headerlink" title="fmt 格式化段落"></a>fmt 格式化段落</h4><p>语法： fmt [-su] [-w width] [file…]</p><p>作用：让各行连接在一起，并且不改变空白符。</p><p>当它读取文本时，假定段落由空行分隔。一个“段落”就是一个或多个连续的文本行，不包括空行。fmt根据下列规则读取一个段落</p><ul><li>行宽： 让每行尽可能的长，并且不超过指定的长度。默认情况下，每行最多75个字符</li><li>句子： 无论何时，尽可能在句子末尾分隔行。避免在句子的第一个单词之后或最后一个单词之前分隔行。</li><li>空白符： 保持单词及空行之间的所有缩进，空格。</li><li>制表符： 所有制表符转化成空格。并在最后输出时合适的位置插入制表符</li></ul><p>说起来复杂，其实就是让那些长短不一的段落尽量变得长。</p><p>例如</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">As we all know,</span><br><span class="line"><span class="keyword">success </span>cones slowly and</span><br><span class="line">is due to a number of different factors all coming</span><br><span class="line">together</span><br><span class="line">over a period of years</span><br></pre></td></tr></table></figure><p>使用命令后</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">As</span> we <span class="keyword">all</span> know, <span class="type">real</span> success comes slowly <span class="keyword">and</span> <span class="keyword">is</span></span><br><span class="line">due <span class="keyword">to</span> a number <span class="keyword">of</span> different factors <span class="keyword">all</span> coming</span><br><span class="line">together <span class="keyword">over</span> a period <span class="keyword">of</span> years.</span><br></pre></td></tr></table></figure><p>此外，它是一段的作用，如果两行之间有个空行就把他们当成两段单独处理，互不影响</p><p>参数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-u(uniform spacing 统一间距) 减少空格，每个单词之间最多只有一个空格，句子末尾最多只有两个空格。</span></span><br><span class="line"><span class="deletion">-w 设定宽度</span></span><br></pre></td></tr></table></figure><h4 id="pr-按页格式化文本"><a href="#pr-按页格式化文本" class="headerlink" title="pr 按页格式化文本"></a>pr 按页格式化文本</h4><p>语法： pr [-dt] [+beg[:end]] [-h text] [-l n] [-o margin] [-W width] [file…]</p><p>作用： 按页格式化文件，以便于打印。</p><p>其中 beg是需要格式化的第一页，end是最后一页，text是标题，n是每页的行数，margin是左边缘的大小，width是输出的宽度。</p><p>默认情况下，pr是通过顶端插入一个标题，左边插入一个边缘，底部插入一个页尾来格式化文件。标题包括修改时间，文件名称和页号。</p><p>如果想查看效果，最好在less程序中</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-d 双倍行距文本（word中的）</span></span><br><span class="line"><span class="addition">+begin;end 从那页到哪页格式化</span></span><br><span class="line"><span class="deletion">-l 改变每页总行数</span></span><br><span class="line"><span class="deletion">-o 设置左边缘</span></span><br><span class="line"><span class="deletion">-W 改变每一行的字符数（默认是72）</span></span><br></pre></td></tr></table></figure><p>还可以按列格式化文本</p><p>语法： pr [-mt] [-columns] [-l lines] [-W width] [file…]</p><p>column是输出列的数量，lines是每页的行数，width是每行的字符数。这个选项不建议用，会截断字符。</p><h3 id="选取，排序，组合，变换"><a href="#选取，排序，组合，变换" class="headerlink" title="选取，排序，组合，变换"></a>选取，排序，组合，变换</h3><h4 id="grep-选取特定模式的行"><a href="#grep-选取特定模式的行" class="headerlink" title="grep 选取特定模式的行"></a>grep 选取特定模式的行</h4><p>相关过滤器： look strings</p><p>语法： grep [-cilLnrsvwx] pattern [file…]</p><p>pattern是要搜索的格式</p><p>作用： 从标准输入或文件中读取数据，抽取所有包含特定模式的行，并写入标准输出。</p><p>这个模式可以是字符串标点符号等，但是如果是标号或者特殊字符时，最好用’’强引用，以防止歧义。</p><p>选项：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-c(count) 统计所抽取行的数量，但不显示行本身</span></span><br><span class="line"><span class="deletion">-i（ignore) 忽略大小写的区别</span></span><br><span class="line"><span class="deletion">-n 所选行在原文件中的位置</span></span><br><span class="line"><span class="deletion">-l（list），如果在不只一个文件中搜索，使用这个选项可以只把匹配的文件名列举出来，此时文件名也要输出多个</span></span><br><span class="line"><span class="deletion">-L 显示不包含该模式的文件名</span></span><br><span class="line"><span class="deletion">-v（reverse） 选取不包含模式的行</span></span><br><span class="line"><span class="deletion">-x 选取完全匹配的行</span></span><br><span class="line"><span class="deletion">-r（recursive递归） 搜索整个目录树</span></span><br></pre></td></tr></table></figure><h5 id="fgrep，egrep-grep变体"><a href="#fgrep，egrep-grep变体" class="headerlink" title="fgrep，egrep grep变体"></a>fgrep，egrep grep变体</h5><p>fgrep，历史上使用，现在基本不用</p><p>egrep grep扩展版本，功能比grep强大，可以通过 grep -E的方式<br>-w 只匹配完整的单词，并且最好配合-l使用。</p><h4 id="look-选取以特定模式开头的行"><a href="#look-选取以特定模式开头的行" class="headerlink" title="look 选取以特定模式开头的行"></a>look 选取以特定模式开头的行</h4><p>格式： look [-df] pattern file…</p><p>作用： 搜索以字母顺序排列的数据，并查找所有以特定模式开头的行。然后输出这些行</p><p>look其实并不是一个过滤器，它只能从文件中读入，因此只能写于管道线的开头</p><p>-d 忽略标点和其他字符，本来是指搜索第一个单词</p><p>-f（fold同等） 忽略大写和小写的区别</p><h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h4><p>格式 sort [-dfnru] [-o outfile] [infile…]</p><p>作用： 排序数据和查看数据是否已经有序。他可以比较整行，也可以从每行中选取一部分进行比较。</p><p>sort可以重定向输出到另一个文件，但是不能输出到输入文件</p><p>例如： sort temp &gt; temp 是不可以的</p><p>但是可以使用-o选项，此时该文件中原有数据将会被保存，排序后的数据也会被追加到这个文件中</p><h5 id="dfnr-控制数据排序的顺序"><a href="#dfnr-控制数据排序的顺序" class="headerlink" title="-dfnr 控制数据排序的顺序"></a>-dfnr 控制数据排序的顺序</h5><p>-d(dictionary) 只查看字母，数字和空白符，当确定有阻碍排序的因素（如标点符号等），可以使用这个选项。</p><p>-f（fold 等同）不区分大小写</p><p>-n（numeric 数字） 识别开头或者字段开头的数字，并按照数字进行排序</p><p>-r 反向排序</p><p>-u（unique 唯一） 对于相同行，只保留一行</p><h5 id="检测数据是否有序-c"><a href="#检测数据是否有序-c" class="headerlink" title="检测数据是否有序 -c"></a>检测数据是否有序 -c</h5><p>-c（check） 不会排列数据，只会告诉数据是否有序，如果有序，将不会显示任何内容</p><h4 id="uniq-查找重复的行"><a href="#uniq-查找重复的行" class="headerlink" title="uniq 查找重复的行"></a>uniq 查找重复的行</h4><p>语法： uniq [-cdu] [infile [outfile]</p><p>作用： 消除重复行，选取重复行，选取唯一行，统计重复行的数量。不加选项输出非重复行和只输出一次重复行</p><p>注意uniq的输入必须是有序的</p><p>-d 只查看重复行</p><p>-u 只查看非重复行</p><p>-c 统计重复行出现的次数</p><h4 id="join-合并两个文件的有序数据"><a href="#join-合并两个文件的有序数据" class="headerlink" title="join 合并两个文件的有序数据"></a>join 合并两个文件的有序数据</h4><p>相关过滤器： colrm cut paste</p><p>语法： join [-i] [-al|-vl] [-a2|-v2] [-l field1] [-2 field2] file1 file2</p><p>其中field是引用特定数段的数字</p><p>作用： 把两个文件中对应行合并到一起。但是这又和sort不同，sort是直接把两个文件拼接在一起，而join则是重复数据合并为一个输出。不重复数据直接输出。读取输入时，会忽略前导空白符。</p><p>不使用其他标号情况下，只会显示有匹配的连接字段（也就是两个文件对应行有相同字段），如果使用-a(all)选项，将会显示整个文件，后面要加a1或a2。a1代表把第一个文件中不匹配的内容也加上去。如果是v1，显示V1中不匹配的行</p><p>-1+sum 将第一个文件中的第sum个字段和第二个文件中的第一个字段进行匹配</p><h4 id="tsort-由偏序创建全序"><a href="#tsort-由偏序创建全序" class="headerlink" title="tsort 由偏序创建全序"></a>tsort 由偏序创建全序</h4><p>语法： tsort file</p><p>作用：将一系列的事一件一件从头到尾输出</p><p>例如：两个单词第二个单词代表在第一个单词后要做的事</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eat clean-<span class="keyword">dishes</span></span><br><span class="line"><span class="keyword">clean-dishes </span>watch-TV</span><br><span class="line"><span class="keyword">shop </span>cook</span><br><span class="line">cook eat</span><br></pre></td></tr></table></figure><p>在使用了tsort后，输出为</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shop</span></span><br><span class="line"><span class="keyword">cook</span></span><br><span class="line"><span class="keyword">eat</span></span><br><span class="line"><span class="keyword">clean-dishes</span></span><br><span class="line"><span class="keyword">watch-TV</span></span><br></pre></td></tr></table></figure><h4 id="strings-在二进制文件中搜索字符串"><a href="#strings-在二进制文件中搜索字符串" class="headerlink" title="strings 在二进制文件中搜索字符串"></a>strings 在二进制文件中搜索字符串</h4><p>语法： strings [-length] file…</p><p>在现代软件中基本都有这种功能，不再展开</p><h4 id="转换字符-tr"><a href="#转换字符-tr" class="headerlink" title="转换字符 tr"></a>转换字符 tr</h4><p>语法： tr [-cds] [set1 [set2]]</p><p>set1是字符组</p><p>作用：可以将一个字符转化成另一个字符，例如将小写转化成大写，将制表符转化成空格，或者将0转化成x等。此外，还可以将多个字符变成一个字符，例如将多个空格转化成一个空格。最后，还可以删除指定字符，例如删除制表符。</p><p>例如： tr a A &lt; old tr a-z A-Z &lt; old</p><p>当需要替换的字符中出现由特殊意义的字符时，需要引用他们</p><p>还有几种特殊的缩写 [:lower:] 代表小写字母，[:upper:]代表大写字母，[:digit:]代表数字</p><p>tr还可以转换不可见字符</p><p>例如： tr ‘\n’ ‘\t’ &lt; old</p><p>参数：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">s 多个字符变成一个字符 例如 tr -s <span class="string">' '</span> <span class="string">' '</span> &lt; old</span></span><br><span class="line"><span class="ruby">-d 删除指定字符</span></span><br><span class="line"><span class="ruby">-c 把没选上的字符变成另一个字符，例如 tr -c <span class="string">' \n'</span> x &lt; old，这个的意思就是除了空格和换行之外其他所有字符都变成x</span></span><br></pre></td></tr></table></figure><h4 id="sed-非交互式文本编辑"><a href="#sed-非交互式文本编辑" class="headerlink" title="sed 非交互式文本编辑"></a>sed 非交互式文本编辑</h4><p>交互式文本编辑就是有一个窗口，例如gedit vi等。而非交互式则需要提前设计命令，然后将命令发给程序。</p><p>语法： sed [-i] command | -e command… [file…]</p><p>command是sed命令</p><p>作用： sed是一个标准的过滤器，可以对标准输入或者标准输出进行修改</p><p>sed从输入流中每次读取一行。然后执行下面三个步骤</p><ol><li>从输入流中读取一行</li><li>执行指定的命令，对该行进行必要的修改</li><li>将该行写入输出流中</li></ol><p>因为是修改标准输入或者标准输出，所以源文件不会被修改，如果要修改原文件，可以加上-i(in-place)选项，这个选项会将输出保存到一个临时文件，一但所有数据处理完，sed就会把临时文件复制到原文件中</p><h5 id="使用sed进行替换"><a href="#使用sed进行替换" class="headerlink" title="使用sed进行替换"></a>使用sed进行替换</h5><p>想要用sed对标准输入或输出的内容进行修改，可以采用 s命令</p><p>形式： /address|pattern/ s /search/replacement/[g]</p><p>address 是输入流中一个行或者多个行的地址，pattern是一个字符串，search是正则表达式，replacement是一个替换文本</p><p>例如 sed s/harley/Harley,这个例子意思就是把每一行的第一个harley改成Harley，如果想把所有都改了，那么在后面要加上一个g</p><p>如果只对一些行进行操作，可以用下列语法：</p><p>number[,number] /regex/</p><p>number是行号</p><p>例如： sed ‘5s/harley/Harley/g’ names</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中），但是在最前面的和在最后面的不一定是过滤器。&lt;/p&gt;&lt;h3 id=&quot;基础&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>加法溢出和乘法溢出</title>
    <link href="http://xinhecuican.github.io/2020/02/29/%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA/"/>
    <id>http://xinhecuican.github.io/2020/02/29/%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA/</id>
    <published>2020-02-29T03:07:00.000Z</published>
    <updated>2020-02-29T03:46:23.753Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>无符号数加法便是两个数相加，如果超过最大值那么就截断超过的位数。截断超过的位数也就相当于mod2^n,因为这样做超过的位都会被模去变成0.</p><p>有符号数加法相对复杂。先是变成无符号数加法，加完 之后再按有符号数编码去理解，这样就会产生两种溢出，正溢出和负溢出。</p><p>首先，如果两个数一正一负，则不可能产生进位。</p><p>正溢出很好理解，最高一位为符号位，假如两个正数一加，超过了最大值，那么第2^w-1位就会变成1，这一位是符号位，因此这个数字便会变成负数。</p><p>如果是负溢出，因为两个数最高位一定为1，如果2^w-2位没有发生进位的话，那么就产生了溢出，此时最高位为0，变成正数</p><p>例如：10111111+10111111（-65）=01111110（126）</p><p>所以说如果是正数溢出，则需要-2^m,如果是负溢出，则需要加上2^m</p><p>判定是否发生溢出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=a+b;</span><br><span class="line"><span class="keyword">if</span>((a&gt;<span class="number">0</span>==b&gt;<span class="number">0</span>)&amp;&amp;(a&lt;<span class="number">0</span>!=s&lt;<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"发生溢出"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"没有发生溢出"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a&gt;0==b&gt;0的意义是判断a和b的符号是否相同,相同为真.a&lt;0!=s&lt;0的含义是判断a和s的符号是否<br>乘法溢出相对简单粗暴，直接把高位全部截断，也就是对2^w取模，有符号数乘法是先不管符号位直接把后面的位相乘，然后再把符号位补上。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;无符号数加法便是两个数相加，如果超过最大值那么就截断超过的位数。截断超过的位数也就相当于mod2^n,因为这样做超过的位都会被模去变成0.&lt;/p&gt;&lt;p
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>重定向与管道</title>
    <link href="http://xinhecuican.github.io/2020/02/29/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93/"/>
    <id>http://xinhecuican.github.io/2020/02/29/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93/</id>
    <published>2020-02-29T00:05:00.000Z</published>
    <updated>2020-02-29T02:50:22.437Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><h3 id="标准输入-标准输出和标准错误"><a href="#标准输入-标准输出和标准错误" class="headerlink" title="标准输入 标准输出和标准错误"></a>标准输入 标准输出和标准错误</h3><p>基本思想：每个基于文本的程序都可以从任何源接受输入，并向任何目标输出</p><p>标准输入指的是一种读取数据的通用办法，标准输出有两种，一种是标准输出，另一种是标准错误</p><p>而输入输出其实正常情况下有shell决定。为了保证程序的输出，需要告诉shell将输出目标设置成文件。</p><h3 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h3><p>在登陆时，shell会自动将标准输入设置成键盘，将标准输出和标准错误设置成屏幕。</p><p>但是每次输入命令时，可以告诉shell在此命令执行期间更换输入输出对象。</p><p>如果想把一个命令输出送到一个文件中，例如sort命令 可以写成 sort &gt; names</p><p>以这种命令输出时，如果文件不存在，shell会自动创建这个文件。如果文件存在，那他将会把文件内容全部清空然后再把内容输入到里面去</p><p>如果我们只想追加内容到这个文件中，可以用 &gt;&gt; 。如果文件不存在，这个命令也会创建新文件，如果存在，那么会追加内容到后面。</p><p>如果取消清空文件重新输入的选项，可以设置nonclobber选项。但是设置完之后，如果确实想替换掉这个文件，可以临时忽略掉noclobber，这时需要用<code>&gt;|</code>替换 &gt;</p><h4 id="重定向标准输入"><a href="#重定向标准输入" class="headerlink" title="重定向标准输入"></a>重定向标准输入</h4><p>符号： &lt;</p><p>左边是你要运行的程序，右边是你有读入数据的文件</p><p>例如 sort &lt; /etc/passwd</p><p>标准输入和标准输出可以同时指定</p><p>例如 sort &lt; rawdata &gt; report，这个命令会把rawdata中的数据给sort处理，然后把结果给report文件</p><h4 id="重定向标准错误"><a href="#重定向标准错误" class="headerlink" title="重定向标准错误"></a>重定向标准错误</h4><p>shell提供两种输出目标，标准输出和标准错误。正常情况下，两种输出同时显示在屏幕上，在需要时，可以把两种输出分隔开。</p><p>首先对unix处理I/O过程了解。每个输入源和每个输出目标都有一个唯一的数字标识，，这个数字 称为文件描述符。例如一个进程可能从#8中读取数据，并将文件写入#6中</p><p>例如为了将输出写入到文件8中，可以sort 8&gt; results，results就是第8个文件</p><p>默认情况下，Unix为每个进程提供三个预定义的文件描述符。而且大多数时候都可以使用。0代表标准输入，1代表标准输出，3代表标准错误。</p><p>所以要想重定向输入，可以用 0&lt;</p><p>而要想重定向标准输出，可以用 1&gt; ,这样错误信息就会留在屏幕上便于我们查看，而输出信息在文件中。如果想让标准错误在文件中，可以 2&gt;</p><p>此外，平常写的 &gt; 实际上代表的是 1&gt;</p><h4 id="子shell"><a href="#子shell" class="headerlink" title="子shell"></a>子shell</h4><p>进程就是加载到内存中准备运行的程序，当进程需要启动另一个进程的时候，这个进程创建了一个副本进程，原始跌进程叫做父进程，而这个进程叫做子进程。</p><p>而子进程一旦结束，优惠唤醒父进程继续执行命令，此时子进程消失。</p><p>子shell指的是在父shell中重新开一个shell，这样在子shell中造成的改变不会影响父shell，甚至是环境变量也一样，除非把它写入初始化文件中，不然这个全局变量也会随着子shell进程的结束而消亡。</p><p>如果有时你想在子shell中执行一条指令，又不想启动一个全新的shell，那么一个办法就是在外面加上小括号(),例如 （date）</p><h4 id="组合标准重定向输出和错误"><a href="#组合标准重定向输出和错误" class="headerlink" title="组合标准重定向输出和错误"></a>组合标准重定向输出和错误</h4><p>在bash中，基本思想是建议将一种类型的输出重定向到一个文件，然后再追加</p><p>command x&gt; outputfile y&gt;&amp;x</p><blockquote><p>&amp; 符号的意思是替代</p></blockquote><p>y&gt;&amp; x的意思是把2的输出发送给1相同的位置。</p><p>例： sort 2&gt;&amp;1 &gt;output 这个意思是把2的输出发送到与一相同的位置，而一是发送到屏幕的，于是2也发送到屏幕了</p><h4 id="抛弃输出"><a href="#抛弃输出" class="headerlink" title="抛弃输出"></a>抛弃输出</h4><p>为什么要抛弃输出呢？</p><p>有时候，需要运行一个程序。因为可能你并不关心这个文件的输出。有时候，可能希望查看文件正常输出，而不关心错误信息。</p><p>那么这个时候只需要重定向输出到 /etc/null即可。这个文件的特殊之处在于发送给他的任何东西都会消失。所以 它有个奇怪的名字叫做 位桶(bit bucket)</p><h3 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h3><p>管道线的作用就是让各个程序组合发挥作用</p><p>shell允许创建一系列的命令，在这一系列的命令中，一个命令的标准输出可以发送给下一个程序的标准输入。当这样做时，两个程序之间的连接就是管道，而命令序列本身叫做管道线。</p><p>在创建管道线时，只需将希望键入的命令用竖线| （管道符号） 分隔开即可</p><p>能从标准输入读取文本，并向标准输出写入文本的程序，称为过滤器。</p><h4 id="管道线分流-tee"><a href="#管道线分流-tee" class="headerlink" title="管道线分流 tee"></a>管道线分流 tee</h4><p>有时候，可能希望把程序的输出发送到两个地方</p><p>语法： tee [-a] file…</p><p>file就是希望将数据发送到的文件的名称</p><p>例：cat name1 name2 | tee masterlist | grep Harley</p><p>这个指令中的tee 会将输出保存到masterlist中并且将cat的输出给grep</p><p>同样，如果这个文件存在，那么tee将会重写这个文件。如果想要追加内容，那么可以tee -a(append)</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;标准输入-标准输出和标准错误&quot;&gt;&lt;a href=&quot;#标准输入-标准输出和标准错误&quot; class=&quot;headerlink&quot; title=&quot;标准
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>初始化文件</title>
    <link href="http://xinhecuican.github.io/2020/02/27/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6/"/>
    <id>http://xinhecuican.github.io/2020/02/27/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6/</id>
    <published>2020-02-27T13:04:00.000Z</published>
    <updated>2020-02-29T00:04:50.119Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>有两个初始化文件，第一个文件是在启动时执行的，叫做登录文件（login file).第二个文件是在启动shell时执行的，叫做环境文件(environment file)。<br>有的shell还有注销文件，注销文件指的是在shell关闭时执行的文件</p><p>bash shell中登录文件文件名（.Bash_profile .bash_login)，环境文件（.bashrc),注销文件（.bash_logout)</p><p>这些文件名都是以点开头，点文件的别名是隐藏文件，意义是除非你用ls指令去查看，通常状况你无法看到这个文件</p><p>登录shell指的是登录时默认启动的shell，非登录shel则需要在登录shell中执行命令才可以启动</p><p>登录shell执行登录文件和环境文件，非登录shell只执行环境文件</p><h4 id="初始化文件中放什么内容"><a href="#初始化文件中放什么内容" class="headerlink" title="初始化文件中放什么内容"></a>初始化文件中放什么内容</h4><p>登录文件有两项任务，设置环境和初始化工作对话（不知道什么意思）</p><p>所以登录文件有两项任务</p><ol><li>创建或修改环境变量的命令（PATH,PAGER等）</li><li>执行所有一次性操作的命令</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;有两个初始化文件，第一个文件是在启动时执行的，叫做登录文件（login file).第二个文件是在启动shell时执行的，叫做环境文件(environ
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>宏定义</title>
    <link href="http://xinhecuican.github.io/2020/02/27/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <id>http://xinhecuican.github.io/2020/02/27/%E5%AE%8F%E5%AE%9A%E4%B9%89/</id>
    <published>2020-02-27T01:53:00.000Z</published>
    <updated>2020-02-27T02:02:14.262Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --><p>宏定义就是在开始用井号（#）定义一个函数或者是常量，这种定义在编译器中被处理，运算速度快，但使用宏定义时可能会出现一些隐蔽的问题</p><p>例如：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="keyword">DATA</span> sizeof(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">for(<span class="built_in">int</span> i=cnt;i-<span class="keyword">DATA</span>&gt;=<span class="number">0</span>;i-=<span class="keyword">DATA</span>)</span><br></pre></td></tr></table></figure><p>乍一看这样做似乎没什么问题，要注意sizeof返回的是一个无符号数，有符号数和无符号数做比较的时候会先把有符号数变成无符号数。而负数的有符号数最高位一定为1，这样就可能会导致数据异常。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 06 2020 19:26:37 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;宏定义就是在开始用井号（#）定义一个函数或者是常量，这种定义在编译器中被处理，运算速度快，但使用宏定义时可能会出现一些隐蔽的问题&lt;/p&gt;&lt;p&gt;例如：&lt;
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
