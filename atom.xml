<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinhecuican&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-04-28T07:14:26.884Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>星河璀璨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java 对象的生命周期</title>
    <link href="http://xinhecuican.github.io/post/53677394.html"/>
    <id>http://xinhecuican.github.io/post/53677394.html</id>
    <published>2020-04-27T03:43:00.000Z</published>
    <updated>2020-04-28T07:14:26.884Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Apr 28 2020 15:14:51 GMT+0800 (中国标准时间) --><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><p>有四种显式创建的方式：</p><ul><li>new创建</li><li>运用反射，调用java.lang.Class或java.lang.reflect.Constructor类的newInstance()方法</li><li>调用对象的clone()方法</li><li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射创建</span></span><br><span class="line">Class objClass = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"Customer"</span>)</span>;</span><br><span class="line">Customer cl = (Customer)objClass.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line"><span class="comment">//通过克隆创建</span></span><br><span class="line">Customer c3 = (Customer)c2.clone<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></div><p>通过new或反射的方法创建的时候，都会调用构造方法。但是通过克隆创建不会执行构造方法。在Object类中就定义了clone()方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASPECTJ"><figure class="iseeu highlight /aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object clone()<span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Cloneable))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportException();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这种方式下如果对应类没有实现cloneable接口，那么clone（）方法会抛出异常。<strong>如果想用clone，那么必须要实现Cloneable接口</strong>。</p><p>clone会创建一个对象，对象的属性值相同，但是内存地址不同。</p><p><strong>隐式创建对象</strong></p><ul><li>输入main的参数都会转化成String对象</li><li>+号对String类型创建新对象</li><li>加载一个类时，会创建Class实例</li></ul><p><strong>创建对象步骤</strong></p><ol><li>给对象分配内存</li><li>将实例变量自动初始化成默认值</li><li>初始化对象。例如private int a = 1;在第二步赋值成0，在第三步中才会变成1.</li></ol><p>对于第三步，如果是通过clone的方法创建，那么将原来成员变量的值赋给新的成员变量。如果是用第四种方法，那么是通过输入流读入序列化数据。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法时负责初始化的，可以提供参数，也可以不提供，一般设置一个默认构造函数有好处。</p><ul><li>方法名要与类名相同</li><li>不声明返回类型</li><li>不能被static,final,synchronized,abstract,native修饰</li></ul><p><strong>重载构造方法</strong></p><p>这是为了满足多样化的需求。需要注意一点在一个构造方法中可以用this调用另一个构造方法。但是如果在一个构造方法中使用了this语句，那么它必须在第一行。</p><h4 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h4><p>其实和c++一样，在没有构造方法的时候会提供一个默认构造方法，如果写了一个构造方法那么系统就不会提供构造方法。但是最好要有一个不带参数的构造方法。</p><h4 id="子类调用父类构造方法"><a href="#子类调用父类构造方法" class="headerlink" title="子类调用父类构造方法"></a>子类调用父类构造方法</h4><p>父类构造方法不能被子类继承。在构造子类时，先执行祖先的构造方法，然后一次向下。这样可以确保子类从父类继承的东西可以被使用。可以用super(…)调用父类构造方法。如果没有用super显示构造，那么子类会用父类的默认构造方法。如果子类没有构造方法，将会出现编译错误</p><h4 id="构造方法的访问级别"><a href="#构造方法的访问级别" class="headerlink" title="构造方法的访问级别"></a>构造方法的访问级别</h4><p>这里主要将private的访问级别的意义。</p><p>当构造函数是private时，只有当前类可以访问它。这也代表不能有子类。所以只有一些特殊的场合才会使用它。</p><ol><li>只有静态方法，没有实例方法</li><li>禁止被继承。这个与final的区别就是private不允许其他类创建它的实例，而final可以。</li><li>这个类要把自己封装起来。</li></ol><h3 id="静态工厂办法"><a href="#静态工厂办法" class="headerlink" title="静态工厂办法"></a>静态工厂办法</h3><p>创建实例最常见的方法是用new调用类的构造方法。在这种情况下，可以创建任意多的实例。如果类想要进一步封装创建实例的细节，并控制实例数目，可以用静态工厂的方法。</p><p>静态工厂方法指的是在类中提供一个公有的静态方法，返回类的一个实例。</p><p>静态工厂实际上是一种普通的方法，但是它有平常创建实例时所不具有的灵活性。</p><p><strong>特点一</strong>： 可以有不同于类的名字，这样在重构构造方法时可以更清晰的说明其中的不同，使可读性增大。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Person get<span class="constructor">ManInstance(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">       return <span class="keyword">new</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>, SEX.<span class="params">man</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public static Person get<span class="constructor">WomanInstance(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">       return <span class="keyword">new</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>, SEX.<span class="params">woman</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>一般都喜欢把静态工厂取名为valueof或getInstance。</p><p><strong>特点二</strong>： 可以不创建新对象。重复利用原有对象</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> A init = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">getinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>特点三</strong>： 可以创建子类的实例</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public static <span class="type">A</span> getson()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Sub</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>因为静态工厂每次不一定创建新的实例，所以在一些特殊的场合有应用。</p><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>单例类就是只有一个实例的类，这种类只有一个实例。一般是系统中具有唯一性的组件才会使用。这种类一般要消耗很多内存，为了防止随便开然后爆内存，所以设置成单例类。</p><p>一种办法是提供public static final的静态常量，然后该常量引用唯一实例。在把构造方法定义成private类型。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Globalconfig</span><br><span class="line">&#123;</span><br><span class="line">    public static final GlobalConfig<span class="built_in"> INSTANCE </span>= new GlobalConfig();</span><br><span class="line">    private GlobalConfig();</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另一种办法就是把构造方法定义成private类型，然后提供构造工厂。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Globalconfig</span><br><span class="line">&#123;</span><br><span class="line">    public static final GlobalConfig<span class="built_in"> INSTANCE </span>= new GlobalConfig();</span><br><span class="line">    private GlobalConfig()&#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">    public static GlobalConfig getInstatnces()</span><br><span class="line">    &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>枚举类是实例数目有限的类。比如，表示性别的Gender类，他只会有两个类。</p><p>设计时，同样把构造方法定义成private，然后创建若干个public static final的静态变量。还可以提供静态工厂。另外如果想使用这些实例，直接用类名即可。</p><h4 id="不可变类和实例缓存"><a href="#不可变类和实例缓存" class="headerlink" title="不可变类和实例缓存"></a>不可变类和实例缓存</h4><p>不可变类指的是创建之后就不可以更改属性值，和final类似。例如Long类，String类。</p><p>创建不可变类时，要考虑一下内容：</p><ul><li>把属性定义成final类型</li><li>不对外公开的（private）set方法</li><li>public的get方法</li><li>在构造方法中初始化所有属性</li><li>覆盖Object类的equals()和hashCode()方法。</li></ul><p>对于不可变类，因为数据成员不会改变，所以在创建实例时，如果二者数据成员相同，那么可以共有一份空间，这样就减小了内存消耗。这叫做实例缓存。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(10)</span>;</span><br><span class="line">Integer b = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(10)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(a<span class="operator"> == </span>b);<span class="comment">//会打印true</span></span><br></pre></td></tr></table></figure></div><p>关于两个对象的等于，在<a href="https://xinhecuican.github.io/post/4b1879e3.html">前面一篇博客</a>中已有说明。</p><p>这就说明了两者共用了内存空间。那么我们应该如何实现实例缓存呢？</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> <span class="type">Name</span></span><br><span class="line">&#123;</span><br><span class="line">    private static final <span class="keyword">Set</span>&lt;SoftReference&lt;<span class="type">Name</span>&gt;&gt; names = <span class="built_in">new</span> HashSet&lt;SoftReference&lt;<span class="type">Name</span>&gt;&gt;();//实例缓存，存放<span class="type">Name</span>的软引用</span><br><span class="line">    <span class="built_in">public</span> sattic <span class="type">Name</span> valueOf(String firstname, Stirng lastname)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(SoftReference&lt;<span class="type">Name</span>&gt; <span class="keyword">ref</span>:names)//循环查看是否已经存在</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Name</span> <span class="type">name</span> = <span class="keyword">ref</span>.<span class="keyword">get</span>();//获得软引用的<span class="type">Name</span>对象</span><br><span class="line">            <span class="keyword">if</span>(<span class="type">name</span> != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; <span class="type">name</span>.firstname.equals(firstname)</span><br><span class="line">            &amp;&amp; <span class="type">name</span>.lastname.equals(lastname))</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果缓存中不存在<span class="type">Name</span>对象，就创建新对象，并加入到实例缓存</span><br><span class="line">            <span class="type">Name</span> <span class="type">name</span> = <span class="built_in">new</span> <span class="type">Name</span>(firstname, lastname);</span><br><span class="line">            names.<span class="keyword">add</span>(<span class="built_in">new</span> SoftReference&lt;<span class="type">Name</span>&gt;(<span class="type">name</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当然，实例缓存也需要消耗内存空间，如果对所有不可变类都使用，可能有的反而会减少内存。当有如下情况时，才会使用实例缓存。</p><ul><li>不可变类实例种类有限</li><li>需要频繁访问某些特定的实例。</li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>在c++中，内存回收是程序员自己负责，因为人难免犯错嘛，可能会导致一系列奇奇怪怪的错误。所以在java中，内存回收是java虚拟机做的。</p><p>只有对象不被任何变量引用时，它的内存才会被回收。当垃圾回收器回收内存时，会先调用该对象的finalize()方法，该方法可能使对象复活，导致垃圾回收器取消回收内存。</p><p>对垃圾回收器来说，程序由三种状态：</p><ol><li>可触及状态：只要还有引用变量引用对象，那么这个对象就处于可触及状态。</li><li>可复活状态： 当程序中没有引用2变量引用时，就进入了可复活状态，复活的关键是finalize方法，这个方法有可能使他复活</li><li>不可触及状态： 也就是调用了finalize状态并且没有复活之后。这种状态下虚拟机才会真正回收内存。</li></ol><h4 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h4><p>finalize()方法就是要销毁时执行的方法，如果finalize方法如果出现异常系统也不会报错而是直接清除。下面讲一下如何把它变成可触及状态。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ghost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Map&lt;<span class="keyword">String</span>, Ghost&gt; ghosts = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>,Ghost&gt;();</span><br><span class="line">    <span class="keyword">String</span> name ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ghost <span class="title">getInstance</span><span class="params">(<span class="keyword">String</span> name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Ghost ghost = ghost(name);</span><br><span class="line">        <span class="keyword">if</span>(ghost == null)</span><br><span class="line">        &#123;</span><br><span class="line">            ghost = <span class="keyword">new</span> Ghost(name);</span><br><span class="line">            ghosts.<span class="built_in">put</span>(name, ghost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ghost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ghosts.<span class="built_in">put</span>(name, <span class="keyword">this</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"execute finalize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个程序在将要被销毁时会调用finalize，之后就把这个对象有放回了Map中，又把这个对象复活了。</p><p>但是实际最好不要用finalize，因为这会扰乱正常的回收机制，导致永远无法回收。</p><p><strong>清除过期引用</strong></p><p>正常情况下，虚拟机都会很好的执行垃圾回收，但是在对象数组等线性结构中，如果只让指针减一，是无法进行垃圾回收的，因为这个数组仍保留对它的引用，但是这个被清除的数据已经无意义了，下面举个例子</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">Object</span>[] elements = <span class="keyword">new</span> <span class="keyword">Object</span>[capacity];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements[--<span class="built_in">size</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个方法的确没什么问题，也可以得到正确的执行，但是实际上size位置的引用并没有被清除，所以当你不断的增加然后开始不断的删除时，这个栈一直在占用大量的空间。所以要想办法除法java的回收机制</p><p>方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">Object</span> object = elements[--<span class="built_in">size</span>];</span><br><span class="line">    elements[<span class="built_in">size</span>] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="强引用，弱引用，软引用，虚引用"><a href="#强引用，弱引用，软引用，虚引用" class="headerlink" title="强引用，弱引用，软引用，虚引用"></a>强引用，弱引用，软引用，虚引用</h3><p>在早期的java中，并没有各种引用。这些引用代表的是清除的级别，如果空间不够了，那么先清除级别低的，这样对程序造成的影响就小。</p><p>在java.lang.ref包中，有Reference的抽象父类，下面有SoftReference,WeakReference,PhantomRefence，分别代表软引用，弱引用，虚引用。<br>ReferenceQueue表示引用队列，它可以和上面三种引用联合使用，以便跟踪虚拟机回收所引起的对象的活动(具体的现在不清楚）。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用就是普通的引用。如果一个类是强引用，那么除非没有变量引用它，虚拟机绝对不会回收它，甚至空间不足的时候虚拟机抛出OutOfMemoryError也不会回收。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>如果一个对象只有软引用，那么空间足够就会留着它，空间不足就会回收它。前面就有一个软引用的例子。</p><p>软引用可以和引用队列（ReferenceQueue）配合使用，如果软引用所引用的对象被回收，那么虚拟机就会把这个软引用加入到与之关联的引用队列中</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用比软引用更没人权。一旦垃圾回收器发现了弱引用，不管有没有内存，都会回收它。只是因为垃圾回收是一个优先级比较低的线程，所以不一定会很快发现弱引用。</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>弱引用都如此了，虚引用肯定更倒霉。同样也是一旦被发现分分钟清除的货。而且优先级比弱引用还要低。虚引用并不会决定对象生命周期。对象持有虚引用和没有引用一样，如果只有虚引用，还是会被清除。</p><p>弱引用<strong>必须</strong>要和引用队列一起使用。当回收一个对象时，如果发现它有虚引用，那么就会在回收对象之前，把这个虚引用对象加入引用队列中。</p><p>那么它的作用是什么？因为虚引用会被放到引用队列中，所以可以设一个虚引用，然后通过虚引用是否在引用队列中来判断这个对象时候要被回收。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">"hello"</span>);<span class="comment">//创建强引用</span></span><br><span class="line">ReferenceQueue&lt;<span class="keyword">String</span>&gt; rq = <span class="keyword">new</span> <span class="type">ReferenceQueue</span>&lt;<span class="keyword">String</span>&gt;();<span class="comment">//创建引用队列</span></span><br><span class="line">WeakReference&lt;<span class="keyword">String</span>&gt; wf = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;<span class="keyword">String</span>&gt;(str,rq);<span class="comment">//创建弱引用</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Apr 28 2020 15:14:51 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;创建对象的方式&quot;&gt;&lt;a href=&quot;#创建对象的方式&quot; class=&quot;headerlink&quot; title=&quot;创建对象的方式&quot;&gt;&lt;/a&gt;创建对
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="http://xinhecuican.github.io/post/50daec4.html"/>
    <id>http://xinhecuican.github.io/post/50daec4.html</id>
    <published>2020-04-26T11:54:00.000Z</published>
    <updated>2020-04-26T13:44:22.709Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 26 2020 21:44:38 GMT+0800 (中国标准时间) --><h3 id="AOV网络"><a href="#AOV网络" class="headerlink" title="AOV网络"></a>AOV网络</h3><p>aov网络指的是用顶点表示活动的网络。讲个例子吧</p><p>例如学习课程有个前后顺序，前面一门课没有学完后面一门课动不了手。这样就可以用顶点表示课程，然后用有向箭头表示学习的次序，这样就是一种AOV网络。并且显然每个点都要走，因为每门课都要学。</p><p><img src="/images/%E7%BD%91%E7%BB%9C1.PNG" alt="后面这个数字代表先修课程"><br><img src="/images/%E7%BD%91%E7%BB%9C2.PNG" alt></p><p>检测有向环可以用对AOV网络构造拓扑序列。构造方法等会讲，如果有环，那么就会出现永远都有入度的情况，就说明有环。</p><p><strong>构造过程</strong></p><p>就拿上面一个图来说吧。必须先要学完c1，c2才可以学c3.学了c1又可以学c8，按照这样的顺序就可以得出学习顺序是C1C2C3C5C4C8C9C7C6。当然，还有许多其他的次序。</p><p>从中我们可以发现一个规律，假如每当我们学一门课就删去这些边，那么我们可以学习一个课程时入度一定为0.例如我们学完1和2后3入度就是0所以现在我们可以学了。如果入度不为0说明我们还有前置知识我们没有掌握，就不能学。</p><p>总结：找出入度为0的点，删去与之相邻的边，然后找新的入度为0的点，重复上述过程。</p><p>下面给出模板：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAXIMA"><figure class="iseeu highlight /maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    int val;//边权</span><br><span class="line">    int <span class="built_in">last</span>;</span><br><span class="line">    edge* next;</span><br><span class="line">&#125;;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int insum;//入度</span><br><span class="line">    edge* <span class="built_in">first</span>;</span><br><span class="line">&#125;;</span><br><span class="line">node nod[<span class="number">100</span>];//随便设的数字，也可以<span class="built_in">new</span>来构建</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nod[i].<span class="built_in">first</span> = NULL;</span><br><span class="line">        nod[i].insum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void addedge(int <span class="built_in">sum</span>, int <span class="built_in">first</span>, int <span class="built_in">last</span>)</span><br><span class="line">&#123;</span><br><span class="line">    //用后插法</span><br><span class="line">    edge* temp = <span class="built_in">new</span> edge;//needfree</span><br><span class="line">    temp-&gt;val = <span class="built_in">sum</span>;</span><br><span class="line">    temp-&gt;<span class="built_in">last</span> = <span class="built_in">last</span>;</span><br><span class="line">    temp-&gt;next = nod[<span class="built_in">first</span>].<span class="built_in">first</span>;</span><br><span class="line">    nod[<span class="built_in">first</span>].<span class="built_in">first</span> = temp;</span><br><span class="line">    nod[<span class="built_in">last</span>].insum++;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">sum</span>, <span class="built_in">first</span>, <span class="built_in">last</span>;</span><br><span class="line">    node* tempnode;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;<span class="built_in">sum</span>&gt;&gt;<span class="built_in">first</span>&gt;&gt;<span class="built_in">last</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addedge(<span class="built_in">sum</span>, <span class="built_in">first</span>, <span class="built_in">last</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node* aovstack = <span class="built_in">new</span> node;//needfree,链栈，用来存放入度为<span class="number">0</span>的节点</span><br><span class="line">    int <span class="built_in">time</span> = <span class="number">0</span>;//记录栈中有多少元素</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nod[i].insum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tempnode = nod[i];</span><br><span class="line">            tempnode-&gt;<span class="built_in">first</span> = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">            aovstack-&gt;<span class="built_in">first</span> = tempnode;</span><br><span class="line">            <span class="built_in">time</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">time</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">time</span>--;</span><br><span class="line">        tempnode = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">        node* temp = aovstack;</span><br><span class="line">        aovstack = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">        <span class="built_in">delete</span> temp;</span><br><span class="line">        edge* tempedge = tempnode-&gt;<span class="built_in">first</span>;</span><br><span class="line">        <span class="keyword">while</span>(tempedge != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--nod[tempedge-&gt;<span class="built_in">last</span>].insum == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">time</span>++;</span><br><span class="line">                tempnode = nod[tempedge-&gt;<span class="built_in">last</span>];</span><br><span class="line">                tempnode-&gt;<span class="built_in">first</span> = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">                aovstack-&gt;<span class="built_in">first</span> = tempnode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/******************</span></span><br><span class="line"><span class="comment">            *output...</span></span><br><span class="line"><span class="comment">            ***************/</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***************</span></span><br><span class="line"><span class="comment">    * delete...</span></span><br><span class="line"><span class="comment">    *******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="AOE网络"><a href="#AOE网络" class="headerlink" title="AOE网络"></a>AOE网络</h3><p>这个是用边表示活动，顶点表示事件。</p><p><img src="/images/%E7%BD%91%E7%BB%9C3.PNG" alt></p><p>这是一个AOE网络图，注意和上面类似这里每一条边都是要到的。我们要找的就是花费时间最长的那条路，因为那条路走完了所有活动才完成。那么这条路叫做关键路径，这条路径上的活动叫做关键活动。如果我们想缩短工期的时间，那么我们就要先缩短关键活动的时间。</p><p><strong>几个名词</strong></p><p>事件最早可能开始时间 ve(i)</p><p>事件最迟允许开始时间 vl(i)</p><p>活动最早可能开始时间 e[i]</p><p>活动最迟开始时间 l[i]</p><p><strong>所以关键活动就是 e[i] == l[i]</strong> ，因为最早时间和最晚时间相同说明耽误不得。</p><p><strong>求法</strong></p><p>代码比较简单，这里只讲一下思路。</p><p>同样使用邻接表。用四个数组分别表示上面四个名词。首先求前面两个。</p><p>事件最早时间这么多到那个点的路径中最晚的那个。例如上面的6点应该是40而不是30，因为只有最晚的那个完成了才能算真正到了那个点。</p><p>事件最晚开始时间要从后往前算。最后那个点的最晚开始时间我们一般是知道的，就是截至时间。然后往前面去减，如果有多条路径到那个点就选最小的。同样的道理因为所有边走完这件事才算做完了，如果你选大的相当于到最后那个点的所需时间少，结果这边走完了那个时间小的还没有走完。</p><p>举个例子：假设8点的截至时间是60，那么4点的截至时间应该是从8到7到5那一条。</p><p>活动最早开始时间是活动的起点的最早开始时间</p><p>活动的最晚开始时间是活动的终点的最晚开始时间减去这条边的权</p><p><img src="/images/aoe%E7%BD%91%E7%BB%9C.PNG" alt></p><p>从这个代码中我们看出每个顶点遍历就可以了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 26 2020 21:44:38 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;AOV网络&quot;&gt;&lt;a href=&quot;#AOV网络&quot; class=&quot;headerlink&quot; title=&quot;AOV网络&quot;&gt;&lt;/a&gt;AOV网络&lt;/h3
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>java 类的生命周期</title>
    <link href="http://xinhecuican.github.io/post/61eaf19a.html"/>
    <id>http://xinhecuican.github.io/post/61eaf19a.html</id>
    <published>2020-04-26T03:33:00.000Z</published>
    <updated>2020-04-27T03:42:48.272Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Apr 28 2020 08:14:44 GMT+0800 (中国标准时间) --><h3 id="类的加载连接和初始化"><a href="#类的加载连接和初始化" class="headerlink" title="类的加载连接和初始化"></a>类的加载连接和初始化</h3><ol><li><p>加载： 查找并加载类的二进制数据</p></li><li><p>链接： 包括验证，准备和解析类的二进制数据</p><ul><li>验证： 确保加载类的正确性。</li><li>准备： 为类的静态变量分配内存，将其初始化为默认值（也就是0）</li><li>解析： 将类的符号引用<a href="符号引用就是在编译阶段，虚拟机并不知道所有引用类的地址（因为还没有加到内存中），就用一个符号表示地址。而直接引用就是真实的地址。">^1</a>变成直接引用</li></ul></li><li><p>初始化： 把类的静态变量赋予正确的初始值。</p></li></ol><h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><p>类的加载是指把类的.class文件中的二进制数据读入到内存中，把它存放在方法区中。然后再兑取川家一个java.lang.Class对象，用来封装类在方法区的数据结构。<strong>通俗的来讲就是把代码加载到内存中</strong>。</p><p>类的加载是由虚拟机自带的加载器来完成的，但是我们也可以自己去定义。用java.lang.ClassLoader类的子类的实例。</p><p>类加载器允许某个类将要被使用时预先加载它。如果预先加载过程中遇到了.class的错误。那么类加载器在首次主动使用这个类的时候报错（LinkageError)</p><h4 id="类的链接"><a href="#类的链接" class="headerlink" title="类的链接"></a>类的链接</h4><p><strong>类的验证</strong></p><p>类的验证主要验证一下内容：</p><ul><li>类文件格式， 看看后缀是否符合</li><li>语义检查 看看是否符合java语义（例如把一个String给int或final是否有子类）</li><li>字节码验证，字节码代表java方法。</li><li>二进制兼容验证。查看这个类引用的另一个类的方法的=在另一个类中是否存在。</li></ul><p><strong>类的准备</strong></p><p>为类的静态变量分配内存，并设置成0（boolean是false，char是’\u0000’)</p><p><strong>类的解析</strong></p><p>符号引用上面已经解释过了，其实也就是这个类引用的其他类或其他类的成员变量和方法等。因为这些类在编译阶段并没有加载，所以虚拟机也不知道要到哪里去找这些方法，所以先弄一个符号代表这个方法。</p><h4 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h4><p>静态变量的初始化有两种途径。（1） 声明时直接赋值 （2） 在静态代码块中初始化。</p><p>初始化并不是直接初始化。如果没有加载和链接，那么先加载和链接。如果父类没有初始化，那么先初始化父类。</p><p>虚拟机只有首次启用一个类的时候才会初始化它。也就是说，创建对象实例，或者访问使用静态变量，还有是某个正在初始化类的父类时都会初始化它。</p><p>此外，当final类型的静态变量，如果能直接计算出值，那么会当成常量，不会导致初始化。反之，会导致初始化。</p><h3 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h3><p>类加载和Linux进程生成类似，都是先有一个根加载器，然后其他类加载器只有一个父加载器。父加载器不是加载自己，而是加载子类，但是是子类请求父类加载自己。</p><p>有三类自带的加载器：</p><ul><li>根加载器，负责加载一些核心库，例如java.lang.*</li><li>扩展加载器，它的父加载器是根加载器。他从java.ext.dirs系统属性指定的目录中加载扩展。或者从JDK的jre\lib\ext中加载扩展</li><li>系统加载器：也叫应用类加载器。它的父加载器是扩展加载器。他从classpath环境变量或者子系统属性java.class.path中加载类，它是用户自定义加载器的默认父加载器。</li></ul><p><strong>类加载的过程</strong></p><p>例如要加载一个类，首先请求父类加载器代为加载，父类再向它的父类代为加载…。一直到根加载器，如果根加载器不能加载，那么就让扩展加载器加载，如果不能加载…。直到找到一个可以加载的。如果所有加载器都不能加载，那么返回ClassNotFoundException。</p><p>成功加载那个类的加载器叫定义类加载器。</p><p>这种机制是为了安全考虑，因为在这种严密的机制下，用户自定义的加载器不可能取代由父加载器完成的任务。</p><p>这里加载器并不一定是和类一样的父子关系。一对父子加载器可能是同一个类的两个实例。</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>每个类加载器都有自己的命名空间，命名空间由该加载器和所有父加载器所加载的类组成。在同一个命名空间中，不可能出现名字（包括包名）完全相同的两个类。不同的命名空间中就有可能出现。</p><h4 id="运行时包"><a href="#运行时包" class="headerlink" title="运行时包"></a>运行时包</h4><p>同一加载器加载的属于相同包的类组成了运行时包。包名相同不一定默认访问级别可以访问，必须要组成运行时包才可以访问默认访问级别。</p><h3 id="创建用户自定义加载器"><a href="#创建用户自定义加载器" class="headerlink" title="创建用户自定义加载器"></a>创建用户自定义加载器</h3><p>首先介绍自定义类的应用场景：</p><p>（1）加密：Java代码可以轻易的被反编译，如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用Java的ClassLoader去加载类了，这时就需要自定义ClassLoader在加载类的时候先解密类，然后再加载。</p><p>（2）从非标准的来源加载代码：如果你的字节码是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。</p><p>（3）以上两种情况在实际中的综合运用：比如你的应用需要通过网络来传输 Java 类的字节码，为了安全性，这些字节码经过了加密处理。这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出在Java虚拟机中运行的类。</p><p>要扩展自己的类加载器，只需扩展java.lang.Classloader类，瑞啊后覆盖findClass(String name)方法。该方法根据参数指定类的名字，返回对应Class对象的引用。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.<span class="keyword">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyClassLoader <span class="keyword">extends</span> ClassLoader</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyClassLoader()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> MyClassLoader(ClassLoader parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"D:/People.class"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(<span class="keyword">file</span>);</span><br><span class="line">            <span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</span></span><br><span class="line">            <span class="keyword">Class</span>&lt;?&gt; c = <span class="keyword">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(<span class="keyword">File</span> <span class="keyword">file</span>) <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里要读入.class的字节，因此要使用字节流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">file</span>);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.<span class="keyword">read</span>(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.<span class="keyword">write</span>(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/SEU_Calvin/article/details/52315125" target="_blank" rel="external nofollow noopener noreferrer">这段代码是扒下来的</a></p><h4 id="URLClassLoader加载类"><a href="#URLClassLoader加载类" class="headerlink" title="URLClassLoader加载类"></a>URLClassLoader加载类</h4><p>在java.net包中，提供了URLClassLoader类，它可以从网上下载类。可以直接使用这个类作为自定义加载器。</p><p>构造方法: <code>URLClassLoader(URL[] urls)//父加载器是系统加载器</code></p><p><code>URLClassLoader(URL[] urls, ClassLoader parent)//指定父加载器</code></p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>java自带类加载器所加载的类是永远不会被卸载的。而用户自定义的类加载器可以被卸载。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Apr 28 2020 08:14:44 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;类的加载连接和初始化&quot;&gt;&lt;a href=&quot;#类的加载连接和初始化&quot; class=&quot;headerlink&quot; title=&quot;类的加载连接和初始化
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 异常处理</title>
    <link href="http://xinhecuican.github.io/post/e058ffd8.html"/>
    <id>http://xinhecuican.github.io/post/e058ffd8.html</id>
    <published>2020-04-25T05:40:00.000Z</published>
    <updated>2020-04-26T03:18:26.332Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 26 2020 21:44:38 GMT+0800 (中国标准时间) --><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>有两种办法抛出异常：</p><ul><li>通过try-catch抛出，例如</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span> <span class="title">A</span><span class="params">(int money)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    try</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        if(--money&lt;=0)</span></span></span><br><span class="line"><span class="function"><span class="comment">        &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">            throw new SpecialException("Outof money");</span></span></span><br><span class="line"><span class="function"><span class="comment">        &#125;</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="title">catch</span><span class="params">(SpecialException e)</span></span></span><br><span class="line"><span class="function">    <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        处理异常</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><ul><li>在方法声明处声明抛出</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span> <span class="title">A</span><span class="params">(int money)</span><span class="title">throws</span> <span class="title">SpecialException</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    if(--money&lt;=0)</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        throw new SpecialException("Out of money");</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><p>每次抛出异常之后，都要找到catch块，如果在当前方法中没有找到，那么它将会弹出栈帧，到了上一级继续寻找知道找到。找到之后就执行catch块内容然后退出。</p><p>如果到最底部也没有找到catch块，那么就调用异常对象的printStackTrace()方法，打印异常信息。</p><p>如果该线程不是主线程，那么就会退出这一个线程，如果是主线程（main），那么就会退出程序。</p><p>抛出异常和处理异常最好在同一方法，不然对性能影响较大。</p><h4 id="finally-在任何情况下都要执行的代码"><a href="#finally-在任何情况下都要执行的代码" class="headerlink" title="finally 在任何情况下都要执行的代码"></a>finally 在任何情况下都要执行的代码</h4><p>因为异常处理会打断正常进程，所以可能会导致一些占用的资源不会被释放。在c++中就是动态内存分配的问题，在java中额例如关闭数据库链接，关闭输入流。</p><p>finally跟在catch后面，并且一定不能在前面。</p><h4 id="throws-抛出可能的异常"><a href="#throws-抛出可能的异常" class="headerlink" title="throws 抛出可能的异常"></a>throws 抛出可能的异常</h4><p>如果一个方法需要抛出异常，但没有能力解决异常，可以在方法头声明throws语句，在前面已经举过例子了。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>try后面可以有多个catch块，只能有至多一个finally块，也可以只跟finally块。</li><li>在try块中定义的变量，在catch和finally中不能访问。</li><li>每当try后面有多个catch时，会依次对catch块进行匹配，只需要匹配同一继承分支上的父类就会执行。例如， IOException是Exception的子类，如果抛出IOExpception且Exception的catch块在前那么就只会执行Exception。例：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code1;<span class="comment">//抛出FileNotfoundException</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLExceptio e)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"SOLException"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Exception"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"IOException"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个只会输出Exception，因为Exception和FileNotFoundException在还有IOException在同一继承分支上，每一次直接走Exception了，而不会走IOException。<strong>所以让子类的catch在前面，防止错误的catch</strong>。</p><ul><li>为了简化，可以用 | 分隔两个异常在一个catch块中进行处理。例如 catch( FileNotFoundException | InterruptedIOException e){…}</li><li>如果一个地方出现受检查异常，要么用throws，要么用try，不然会出现编译错误（这样也就方便些try了，不然写代码的时候还真不好说哪里有异常）。</li></ul><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p>正常流程是捕捉异常，执行catch，执行finally，退出。有两种退出方式</p><p>第一种使用System.exit(number);这种方法会直接退出程序，</p><p>第二种是return，退出本方法，这个时候如果有返回值还可以弄个返回值以便其他部分正常运行。finally执行于return之前。一般return是在catch中的，但是也可以在finally中，但是这样可能会导致问题。</p><ul><li>返回值覆盖，因为catch执行于return之前，所以如果要执行catch中的return，会先执行finally中的return，这个时候catch中的return就不会执行了。</li><li>丢失异常，如果在catch中抛出异常且finally中有return就可能发生异常丢失。这个时候catch中的异常就不会被抛出。此外，如果catch和finally中都抛出异常，那么catch中的异常将会丢失。</li></ul><p>为了解决丢失异常的问题，Throwable接口中有两个默认实现的方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> addSuppressed(Throwable exception)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Throwable[] getSuppressed()</span><br></pre></td></tr></table></figure></div><p>其中addSuppressed()方法就是把丢失的异常保存下来，getSuppressed就是返回所有保存下来的异常。当然，并不是系统自动添加，还要手动用这些方法去添加。</p><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p>java中用类来描述异常。所有异常的祖先是java.lang.Throwable类。它的实例就是具体的异常，可以通过throw抛出。它提供了一些常用方法，包括</p><ul><li>getMessage() 返回String类型的异常信息</li><li>printStackTrace() 打印跟踪方法调用栈获得的详细异常信息</li></ul><p>例如catch到这个异常后，可以<code>System.out.println(e.getMessage())</code>来输出异常信息。例如e里面的信息时Out of money（就是前面的），那么就会输出这个异常信息。</p><p>而如果用后面那个方法，将会说明哪个类，哪一行出现了异常。</p><p><img src="/images/20160603151809323" alt="异常类图"></p><ul><li>Error类，表示单靠程序本身无法恢复的严重错误，例如内存不足，或者栈溢出。</li><li>Exception类，表示程序可以处理的异常。出现这些异常时，可以进行处理而不退出程序。</li><li>IOException 输入输出时产生的异常。</li><li>ArithmeticException 数学异常。例如除以0</li><li>NullpointerException，空指针异常。当引用变量时null是，试图使用这个变量将会出现。</li><li>IndexOutOfBoundsException 下标越界异常</li><li>ClassCastException 类型转换异常，例如父类转子类</li><li>IllegalArgumentException 非法参数，例如 if(name==null)throw new IllegalArgumentException(“姓名不能为空”)。</li></ul><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>RuntimeException一个子树都可以叫运行时异常。这种异常特点是编译器不会检查他。例如上面说的数学异常。当这种异常出现的时候程序将异常终止。其他的都是受检查异常。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>可以通过继承来实现自定义异常。一般挂在Exception或RuntimeException上。</p><p>自定义异常要一般要写以下部分。</p><p>异常数据，异常原因（String类型），然后是一个带参数的构造函数。之后提供方法说明这个异常。</p><h4 id="异常转义异常链"><a href="#异常转义异常链" class="headerlink" title="异常转义异常链"></a>异常转义异常链</h4><p>原始的异常对于用户来说看不懂，这个时候我们就要抛出一些更人性化的异常。但是与此同时我们也要把原始异常保存易于我们排错。这个时候我们就可以在原始异常上进行扩展。扩展类的数据域中可以来一个Throwable的引用变量，然后在构造函数中把原始异常导入。这样就保存了原始异常。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Throwable</span> cause = <span class="literal">null</span>;</span><br><span class="line">    public <span class="type">BaseException</span>();</span><br><span class="line">    public <span class="type">BaseException</span>(<span class="type">Throwable</span> cause)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">BaseException</span>(<span class="type">String</span> msg, <span class="type">Throwable</span> cause)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div><h4 id="处理多样化异常"><a href="#处理多样化异常" class="headerlink" title="处理多样化异常"></a>处理多样化异常</h4><p>就是一次性抛出多个异常，这就需要先自定义一个异常类，收集多种异常然后一次性输出。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> int size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">List</span>&lt;<span class="type">Throwable</span>&gt;exceptions = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="type">Throwable</span>&gt;();</span><br><span class="line">    public void addExcpetion(<span class="type">BaseException</span> ex)</span><br><span class="line">    &#123;</span><br><span class="line">        exceptions.add(ex);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>记录日志的作用：监视代码中变量情况，周期性的记录到文件中供其他应用统计分析。承担继承开发环境中调试器作用。</p><p>要在程序中输出日志，最普通的办法是用println输出。比较好的做法是用一个日志操作类。</p><p>现在可以直接使用java.util.logging日志操作包。这个包中主要有四个类</p><ul><li>Logger类：生成日志，并对日志信息分级筛选，确定什么等级被输出，什么不输出。</li><li>Handler： 负责输出日志信息。它有两个子类：ConcoleHandler（输出到Dos控制台），FileHandler（输出到文件中）</li><li>Level类： 表示日志各个界别。</li></ul><h4 id="创建及设置级别"><a href="#创建及设置级别" class="headerlink" title="创建及设置级别"></a>创建及设置级别</h4><p>创建 <code>Logger mylogger = Logger.getLogger(&quot;mylogger&quot;);</code></p><p>getlogger就是用来创建对象的。如果mylogger存在，那么直接返回引用。</p><p>级别： SEVERE(严重）， WARNING(警告），INFO , CONFIG(确认），FINE（好），CONFIG,FINE,FINER,FINEST</p><p>默认情况下，只会输出最高三个级别的。可以使用Logger类的setLevel()来设置级别。例：<code>mylogger.setLevel(&quot;Level.FINE&quot;)//把日志设置成FINE级别</code>。这样设置FINE及以上级别都会被设置。还有Level.on开启所有级别和Level.off关闭所有级别。</p><p><code>mylogger.info(&quot;这是一条普通提示消息&quot;)</code>用级别的名字设置提示消息</p><h4 id="输出日志到文件"><a href="#输出日志到文件" class="headerlink" title="输出日志到文件"></a>输出日志到文件</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileHandler fileHandler = <span class="keyword">new</span> <span class="constructor">FileHandler(<span class="string">"C:\\test.log"</span>)</span>;</span><br><span class="line">fileHandler.set<span class="constructor">Level(Level.INFO)</span>;<span class="comment">//设定向文件中写日志的级别</span></span><br><span class="line">mylogger.add<span class="constructor">Handler(<span class="params">fileHandler</span>)</span>;<span class="comment">//将FileHandler与Logger关联</span></span><br></pre></td></tr></table></figure></div><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>语法： assert 条件表达式 或 assert 条件表达式 : 包含错误信息的表达式。</p><p>作用： 当条件表达式为false时，会抛出AssertError，这是一个错误。如果后面有包含错误信息的表达式，那么将会输出后面的内容</p><p>例如： assert b!=0 : ”b不能为0“；</p><p>启用断言需要-ea参数，而IDEA中默认是关闭的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 26 2020 21:44:38 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;异常处理流程&quot;&gt;&lt;a href=&quot;#异常处理流程&quot; class=&quot;headerlink&quot; title=&quot;异常处理流程&quot;&gt;&lt;/a&gt;异常处理流程
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="http://xinhecuican.github.io/post/5951da65.html"/>
    <id>http://xinhecuican.github.io/post/5951da65.html</id>
    <published>2020-04-23T08:39:00.000Z</published>
    <updated>2020-04-25T04:56:28.514Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 25 2020 12:56:35 GMT+0800 (中国标准时间) --><h3 id="接口的基本特征"><a href="#接口的基本特征" class="headerlink" title="接口的基本特征"></a>接口的基本特征</h3><p>在java中接口有两种意思</p><ul><li>第一种是概念性的接口，指的是封装的内容对外界提供的服务（一开始一听接口一定以为就是这个吧）</li><li>第二种是一种接口类型</li></ul><p>定义接口使用interface关键字，实现接口使用implement关键字。这个类似于父类和子类。</p><p>注意点：</p><ul><li>接口成员变量默认是public或static或final类型的，必须显示初始化。例如<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> b;</span><br><span class="line">    <span class="built_in">int</span> c = <span class="number">3</span>;<span class="comment">//正确，显式初始化表示定义同时要赋值，并且默认是上面三种类型</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure></div></li><li>方法默认是public abstract类型。JDK8开始才可以有默认方法和静态方法之前只能有抽象方法。默认方法用<strong>default关键字</strong>声明，可以有自己的实现，接口实现类可以直接访问默认方法，也可以覆盖它。静态方法可以在接口内部访问或者实现接口的类通过使用接口名字来访问。<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span>;<span class="comment">//默认是public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method3</span>(<span class="params"></span>)</span>;<span class="comment">//编译器默认是public的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span>(<span class="params"></span>)</span>;<span class="comment">//不可以，必须要有abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li>接口没有构造方法，不能够被实例化</li><li>接口可以继承于多个接口，但是不能实现接口。例如：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">&#125;</span><br><span class="line">public<span class="built_in"> interface </span>B</span><br><span class="line">&#123;&#125;</span><br><span class="line">public<span class="built_in"> interface </span>C extends A,B</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>与子类继承抽象父类相似，当类实现某个接口时，<strong>必须要重写接口中的所有抽象方法，否则这个类必须定义成抽象类</strong>。</li><li>不允许创建接口的实例，但允许创建接口类型的引用变量，该变量引用实现了接口的类的实例（也可以看成是子类的实例）</li><li>一个类只能够继承一个父类，但可以实现多个接口。例如：<br><code>public class A extends Base implement intera, interb{...}</code></li></ul><p>接口可以在一定程度上弥补一个类只能有一个直接父类的遗憾，有利于扩展。</p><h3 id="接口模式"><a href="#接口模式" class="headerlink" title="接口模式"></a>接口模式</h3><h4 id="定制服务模式"><a href="#定制服务模式" class="headerlink" title="定制服务模式"></a>定制服务模式</h4><p>这种模式就是利用接口可以继承多个接口，把多个子功能整合到一起变成一个大的服务。例如一个套餐里面有流量服务，电话服务，语音服务等等。这些都是一个接口。之后整合成整个的套餐包含上述服务</p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>适配器就是用来做两个系统之间转换的。有两种方式实现转换。</p><p>第一种就是通过继承，继承源类的实例和目标类的接口。</p><p>第二种是通过组合，组合两种类的接口，然后实现。</p><p>例如，一个接口有add（a,b)函数，另一个有addone(a)函数，第二个函数不能作用是让a+1，但是它没有加法（假设）。这时我们设计一个接口，继承上面两个接口，这样我们就有办法用原接口的实现类从而实现加法完成第二个方法。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>这种适配器其实是一个类，因为接口中都是抽象函数，所以当你使用适配器的时候不得不实现所有功能-即使你只想实现一个。所以干脆实现了一种类，这个类实现了所有抽象方法，但是内容全是空。这样再用其他类继承这个类就可以一次实现一种了。</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理人其实就是中间人，代理类和代理人类似，这个类负责预处理一些消息，例如钱少于多少就直接拒绝。也负责向委托类传递信息。</p><h4 id="标识类型模式"><a href="#标识类型模式" class="headerlink" title="标识类型模式"></a>标识类型模式</h4><p>标识类型一般是标识某一类事物。例如事物，树，人物等等。使用这种接口而不是直接使用一个类的好处是便于同一管理。</p><h4 id="常量接口"><a href="#常量接口" class="headerlink" title="常量接口"></a>常量接口</h4><p>常量接口就是把一些常量放到一起。要使用的时候直接implements就可以了。</p><p>但是这种接口有一个弊端，就是破坏了封装性。为了解决这个问题，可以使用import static语句。import static允许直接访问另一个类的静态常量</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 25 2020 12:56:35 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;接口的基本特征&quot;&gt;&lt;a href=&quot;#接口的基本特征&quot; class=&quot;headerlink&quot; title=&quot;接口的基本特征&quot;&gt;&lt;/a&gt;接口的
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 继承和多态</title>
    <link href="http://xinhecuican.github.io/post/17862176.html"/>
    <id>http://xinhecuican.github.io/post/17862176.html</id>
    <published>2020-04-22T09:00:00.000Z</published>
    <updated>2020-04-25T03:08:37.602Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 25 2020 12:56:35 GMT+0800 (中国标准时间) --><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>利用extends来进行继承，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以上表明Sub类继承Base类，具体继承还要分两种情况。</p><ul><li>如果在同一个包中，那么Sub继承了Base中的public，protected和默认访问级别的成员变量和方法</li><li>如果在不同的包中，不继承默认访问级别的成员变量和成员方法，其他和上一个相同。</li></ul><p>默认访问级别就是前面没有加任何关键字。</p><p>java不支持多继承，一个类只能继承于一个类，但是父类可以有多个子类，就像一棵树。下级继承会继承同一分支上所有的成员和方法。</p><p>java中有一个所有类的祖先叫object类，如果没有使用extends关键字那么会自动继承这个类。</p><h3 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h3><p>覆盖指的是父类中的函数在子类中重新写。要满足下列条件：</p><ul><li>子类方法名称，函数签名（包括参数位置）和返回类型都要和父类方法一致</li><li>在子类中，必须要先覆盖函数，才可以重写函数</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Base类中：</span><br><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Sub</span>类中：</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">int</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">这样会报错</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果<span class="title">Sub</span>类这样</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">int</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function">这样可以编译通过</span></span><br></pre></td></tr></table></figure></div><ul><li>子类方法不可以缩小父类的访问权限，如果父类的方法时private那么子类就不能写public</li><li>子类不能抛出比父类更多的异常</li><li>子类无法覆盖父类的方法，只能够隐藏。这两者的区别是覆盖的话父类可以使用子类的，子类也可以使用父类的。隐藏的话父类只能使用父类的，子类只能使用子类的。这是由于static定义的区域所决定的。<br>例：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package newpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------</span><br><span class="line">package newpackage;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newsec</span> <span class="title">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Sub"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Sub"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base a = <span class="keyword">new</span> newsec();</span><br><span class="line">        a.method();</span><br><span class="line">        a.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出时Base和Sub</span><br></pre></td></tr></table></figure></div><ul><li>可以扩大访问权限。并且如果是抽象类，子类可以只扩大访问范围而不做任何事.但是必须要实现它，不然只能让子类也定义成抽象类。</li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super和this一样都是指向一个对象，不同的是super指向父类，this指向自己。</p><p>使用场合：</p><ul><li>局部变量和类变量重名</li><li>子类覆盖了父类的方法或成员变量时，可以用这种方法使用父类的方法</li></ul><p>需要注意，如果父类成员变量和方法被定义成private，那么子类无论如何都无法访问他们。不能再静态方法区使用super关键字。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是父类可以使用子类，子类也可以使用父类（自我理解）。下面讲具体使用规范。</p><ul><li>对于一个引用类型变量，编译器按声明变量进行处理。例如</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Base </span>who = new <span class="keyword">Sub();</span></span><br><span class="line"><span class="keyword">who.subVar </span>= <span class="string">"123"</span>;</span><br><span class="line">这里编译会出错，无论后面引用了谁，who都是<span class="keyword">Base类，而父类不能直接使用子类的变量</span></span><br></pre></td></tr></table></figure></div><ul><li><p>编译器允许继承分支关系的类进行类型转换。对于向上转型（子类使用父类的），编译器会自动类型转换。对于向下转型则需要强制类型转换。在运行时，子类可以转换成父类，但是父类实际上无法转换成子类。因为父类有的子类一定有，子类有的父类却不一定有。</p></li><li><p>对于引用对象绑定，遵循如下规则</p><ol><li>对于实例方法和引用变量是由实际使用的对象进行绑定。这个是动态的，也就是说方法的实际输出是由实际类型所决定。例如 Base a = new Sub();输出时Sub的。如果这个时候Sub的子类b = a;那么输出还是Sub的。但是如果使用了子类中独有的方法会报错</li><li>静态方法和成员变量由前面定义的类型所决定，这属于静态绑定，在编译时期已经决定。无论引用了谁都不会改变。</li></ol></li></ul><h3 id="继承的使用"><a href="#继承的使用" class="headerlink" title="继承的使用"></a>继承的使用</h3><p>继承树的最上层一般是抽象层。并且继承树上有接口类型，那么尽可能的把应用变量声明成继承树上层的接口类型。因为实例可以是子类，向上转型不会出现问题，这样便于使用多个子类，如果想用子类独有的东西就把引用变量定义成子类。</p><p>继承关系会打破封装，因为上层类改变会使下层类也跟着改变。所以对上层类定义要谨慎。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><table><thead><tr><th>修饰符</th><th>类</th><th>成员方法</th><th>构造方法</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>abstract（抽象的）</td><td>有</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>static（静态的）</td><td>无</td><td>有</td><td>无</td><td>有</td><td>无</td></tr><tr><td>public</td><td>有</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>protected</td><td>无</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>private</td><td>无</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>synchronized（同步的）</td><td>无</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>native（本地的）</td><td>无</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>transient（暂时的）</td><td>无</td><td>无</td><td>无</td><td>有</td><td>无</td></tr><tr><td>volatile（易失的）</td><td>无</td><td>无</td><td>无</td><td>有</td><td>无</td></tr><tr><td>final（不可改变的）</td><td>有</td><td>有</td><td>无</td><td>有</td><td>有</td></tr></tbody></table><p>表中的类指的是顶层类，与内部类相对应（内部类是定义在类或方法中的类）。</p><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><p>访问控制指的是其他类或对象可以查看的东西。一共有四种访问级别</p><ul><li>public 所有都是可以给外部看的</li><li>protected 只对子类和一个包中的类公开</li><li>默认级别 没有修饰符 只对同一个包中的类公开，不对子类公开</li><li>private 不对外公开</li></ul><p>public&gt;protected&gt;默认&gt;private。public与其他不同是其他包也可以查看</p><p>顶层类只能是public或protected，不然会出现编译错误。</p><p>访问级别是对成员变量和类来说的，对局部变量没有意义，局部变量的访问范围就是方法内部。</p><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p>用abstract修饰的类表示抽象类，抽象类不允许实例化，也就是抽象类不允许创建实例</p><p>用abstract修饰的方法表示抽象方法，抽象方法内部没有内容，只有一个函数头。</p><p>注意，如果有抽象方法，这个类必须定义成抽象类。此外，没有抽象静态方法，abstract和static是互相矛盾的。</p><p>抽象类本身不可以实例化，但是可以创建一个抽象类的引用变量然后引用具体类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base a = <span class="keyword">new</span> <span class="type">Base</span>();<span class="comment">//不可以，因为Base是抽象类</span></span><br><span class="line">Base b = <span class="keyword">new</span> <span class="type">Sub</span>(); <span class="comment">//Sub是具体类</span></span><br></pre></td></tr></table></figure></div><p>抽象方法不可以用private修饰，因为抽象出来本来就是要让子类去实现的，private一下子类就无法使用了。</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final有不可改变的含义。</p><p>用final修饰的类不能被继承，没有子类</p><p>用final修饰的方法不能被覆盖</p><p>final修饰的变量表示常量，只能赋一次值</p><p>final不能用来修饰构造方法。</p><p>final修饰引用变量，这个变量不能只能引用一个实例，但是可以对这个实例进行修改。</p><p>不允许覆盖就是不能用相同的函数签名去重写这个函数</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul><li>static修饰的成员变量时静态变量，可以直接通过类名进行访问，并且所有实例共用一个静态变量</li><li>修饰成员方法表示静态方法，可以直接通过类名访问</li><li>修饰的程序代码块叫做静态代码块，加载类时会执行这些代码块</li></ul><p>静态变量只有一份备份，处于方法区，在加载类的时候随之加载。</p><p>注意，在静态方法中没办法用this，因为静态方法时所有类共有的，this表示的是某个特定的类。所以在main方法中不能用this和super，因为main是static的，如果想访问这个类的内容，可以先定义一个该类的引用变量。</p><p>如果直接访问了，编译器会报<strong>在静态方法内不允许访问非静态变量</strong>。</p><p>main函数必须是static的原因是只要加载了main所在的类main就被加载了，可以直接去执行，不然还要先创建一个类然后使用main方法。</p><p>类中可以包含一些静态代码块，这些代码块不存在与任何方法中，加载类时一次执行这些代码块。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"First Static code i="</span> + i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>static代码块和静态方法一样，不可以直接调用实例变量和实例方法，只用通过先引用之后才可以进行调用。</p><h5 id="static进行静态导入"><a href="#static进行静态导入" class="headerlink" title="static进行静态导入"></a>static进行静态导入</h5><p>静态导入类似于c++中的using namespace std;可以简写代码。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">import</span>.<span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out.<span class="built_in">println</span>(MIN_VALUE);<span class="comment">//原来是Integer.MIN_VALUE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>但是如果静态导入过多，可能会导致冲突，因此尽量导入的时候具体一点。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 25 2020 12:56:35 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java switch foreach</title>
    <link href="http://xinhecuican.github.io/post/4c720881.html"/>
    <id>http://xinhecuican.github.io/post/4c720881.html</id>
    <published>2020-04-22T08:49:00.000Z</published>
    <updated>2020-04-22T09:00:38.545Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 22 2020 17:00:38 GMT+0800 (中国标准时间) --><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch的条件（switch括号中的内容）可以有一下几种。</p><ul><li>可以自动转换成int的类型（byte,short,int,char)</li><li>字符串类型<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AUTOIT"><figure class="iseeu highlight /autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> color = <span class="string">"red"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">switch</span>(color)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">   System.out.println(<span class="string">"红色"</span>)<span class="comment">;</span></span><br><span class="line">   <span class="built_in">break</span><span class="comment">;</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">"blue:</span></span><br><span class="line"><span class="string">   System.out.println("</span>蓝色<span class="string">");</span></span><br><span class="line"><span class="string">   break;</span></span><br><span class="line"><span class="string"> default:</span></span><br><span class="line"><span class="string">   System.out.println("</span>其他颜色<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div></li><li>枚举类型<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRYSTAL"><figure class="iseeu highlight /crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Colour</span>(<span class="title">red</span>,<span class="title">blue</span>);</span></span><br><span class="line">Colour c = Colour.red;</span><br><span class="line">Switch(c)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><h3 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h3></li></ul><p>foreach是for的特殊简化版本。用来遍历数组或集合</p><p>语法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(变量类型 变量名 : 待输出的集合或数组)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其实这也只能说是稍稍简化，直接写for就可以了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 22 2020 17:00:38 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;switch&quot;&gt;&lt;a href=&quot;#switch&quot; class=&quot;headerlink&quot; title=&quot;switch&quot;&gt;&lt;/a&gt;switch
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 操作符</title>
    <link href="http://xinhecuican.github.io/post/4b1879e3.html"/>
    <id>http://xinhecuican.github.io/post/4b1879e3.html</id>
    <published>2020-04-21T10:23:00.000Z</published>
    <updated>2020-04-26T05:18:42.594Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 26 2020 21:44:38 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>c++中没有 &gt;&gt;&gt;(逻辑右移）操作符，这是在java中才有的。c++想要实现逻辑右移的功能要么进行更复杂的运算要么用unsigned。<a href="https://xinhecuican.github.io/post/61738.html">这篇博客中详细讲了算术右移和逻辑右移</a></p><p>浮点数不支持移位运算。并且如果其中一个浮点数是double型，结果就是double型。</p><table><thead><tr><th>逻辑运算符（部分）</th><th>操作</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>短路与</td></tr><tr><td>&amp;</td><td>非短路与</td></tr><tr><td>两竖线</td><td>短路或</td></tr><tr><td>一竖线</td><td>非短路或</td></tr></tbody></table><p>短路与非短路的区别是对于短路运算符如果左边可以判断，那么就不会去判断右边。非短路运算符无论条件如何都会执行两边。</p><p>非短路运算符的作用是有时我们先要进行一些运算再判断，非短路运算符可以确保运算的执行。例如 if(b == true &amp; (output+=10) == 20 ).其中output+=10就是运算，</p><h3 id="操作符在对象中"><a href="#操作符在对象中" class="headerlink" title="==操作符在对象中"></a>==操作符在对象中</h3><p>当==操作符在对象中时，两个引用变量必须是引用同一个对象，结果才为true。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Integer <span class="built_in">int</span>1 = new Integer(<span class="number">1</span>);</span><br><span class="line">Integer <span class="built_in">int</span>2 = new Integer(<span class="number">1</span>);</span><br><span class="line">Integer <span class="built_in">int</span>3 = <span class="built_in">int</span>1;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="built_in">int</span>1 == <span class="built_in">int</span>2);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="built_in">int</span>1 == <span class="built_in">int</span>3);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></div><p>可见哪怕赋了一样的值两个对象还是不同的。</p><h4 id="与多态"><a href="#与多态" class="headerlink" title="== 与多态"></a>== 与多态</h4><p>想要使用必须要两个类是相同的或者处于同一分支。例如 cat和dog都继承与animal类，cat可以和animal进行比较，但是cat不能和dog进行比较。</p><p>数组也是引用类型，可以用==进行比较，但是前提是两边变量类型必须相同，例如一个int型和一个long型进行比较就会报错。</p><h4 id="对象的equal（）方法"><a href="#对象的equal（）方法" class="headerlink" title="对象的equal（）方法"></a>对象的equal（）方法</h4><p>有些jdk中的一些类覆盖了object类的equal（）。这种情况下比较就是如果类型一致且内容一致（数据域），那么就返回true，否则返回false。例如String类。</p><p>所以如果要进行字符串比较的话，必须使用equal方法。不然除非是复制的两个字符串，不然即使内容相同也会出错。</p><h3 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h3><p>instanceof操作符用于判断引用类型所引用的对象是否是一个类或其祖先的实例。如果是返回true。</p><p>格式： 实例名 instanceof 类名或接口名</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = <span class="keyword">new</span> <span class="constructor">Dog()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(dog instanceof Dog);</span><br><span class="line"></span><br><span class="line">output: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">同时如果Dog替换成dog的父类或祖先类，或Dog类或其祖先实现的接口时，都会返回<span class="literal">true</span></span><br></pre></td></tr></table></figure></div><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><strong>自动类型转换</strong></p><p>总的规则就是小的和大的相乘结果是大的。浮点数和整数相乘结果是浮点数。</p><p><strong>强制类型转换</strong></p><p>把高位类型赋值给低位类型，结果一定要进行强制类型转换（显式转换）。由小到大进行自动类型转换。</p><p>例 ：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">int</span> i = (<span class="built_in">int</span>)<span class="number">3.14</span>;</span><br><span class="line">long j = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">int</span> i2 = (<span class="built_in">int</span>)j;</span><br><span class="line"></span><br><span class="line">其中只有第一个是不合法的，因为浮点数默认是<span class="built_in">double</span>型。</span><br></pre></td></tr></table></figure></div><p>此外，如果超过了数据范围也必须强制类型转换。</p><p>char c = -1;//错误，因为超过了数据范围</p><p>char c = 97;//正确</p><p><strong>引用类型的强制转换</strong></p><p>子类复制给祖先类，会自动进行类型转换。而父类给子类则必须进行强制类型转换。</p><p>如果不在统一继承分支上则不可以进行转换。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EBNF"><figure class="iseeu highlight /ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Animal cat</span> = new Cat();</span><br><span class="line"><span class="attribute">Dog dog</span> = (Dog)cat;</span><br></pre></td></tr></table></figure></div><p>上面的代码可以通过编译，但是在运行时会跑出ClassCastException异常</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 26 2020 21:44:38 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;c++中没有 &amp;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 数据类型和变量</title>
    <link href="http://xinhecuican.github.io/post/f201f9fd.html"/>
    <id>http://xinhecuican.github.io/post/f201f9fd.html</id>
    <published>2020-04-20T03:40:00.000Z</published>
    <updated>2020-04-21T12:14:45.593Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Apr 21 2020 20:14:58 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>因为是记笔记，这里只说一下和c++不同的地方。</p><p>定义及使用的方式和c++基本一致，就是有些名字改了而已。</p><p>类变量自动初始化，boolean初始化为false，其他初始化为0。但是普通的变量还有自己初始化。这里和c++不同的是如果没有初始化会报错。当然，如果一直没有使用的话不初始化也不会报错。</p><p>boolean 就是c++中的bool型。但是有一点不同，这里只能赋true or false，赋一个整数变成bool型是不可以的。但是无语的是底层实现其实还是非零是true，零是false。也就是说，在java中,int i = 1; if(i)的行为是不被允许的，因为整型不可以变成boolean型。</p><p>byte 一个字节，和char不同，这个是整型的。当然，java中也有char</p><p>在java中，如果数学表达式都是整数，则返回值只能是int或long型。如果把返回值赋给byte型，要进行强制类型转换。<strong>强制类型转换例：byte a = (byte)(1+1);</strong></p><p>可以用下划线分隔，例如：int a = 10_000_000;实际上就是1000万，这样可以增加可读性。</p><p>此外，可以在后面加尾标表示类型。例如 l是long型，f是float，D是double。S是short，C表示char。例如： 100L。</p><p>小数没有后缀默认是double型</p><h4 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h4><ul><li>如果int型直接赋给byte，short或char型的时候，如果在数据范围内，可以直接赋值，如果超出数据范围，必须要进行强制类型转换，而且是显式的，不然会报错。超出部分直接截断，没超出的再按对应编码方式解释。</li></ul><p>byte b = 129;//错</p><p>byte b = (byte)129;//对</p><ul><li>浮点型赋给整型必须要进行强制类型转换，而整型给浮点型不要</li><li>double给float要强制类型转换，而float给double不要</li></ul><p><strong>java语言编码</strong></p><p>java采用UCS-2编码，字符占两个字节，把字符看成无符号整数对待。一般来说不用记字符的编码，但是像一些特殊的例如<code>&#39;</code>如果直接char c = ‘’’就会出错。所以可以加反斜线进行转义。char c = ‘&#39;‘</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用可分为类引用，接口引用，数组引用。</p><p>类引用引用类的实例，接口引用引用接口的实例，数组引用引用数组的实例（数组页看成对象）。无论是哪种，都是引用一个对象</p><p>如果没有引用一个实例，可以赋值成null，例如：</p><p>Doll a = null;</p><p>Doll a = new Doll(“beibei”);</p><p>用new关键字可以创建一个对象，它做了下面的事：</p><ul><li>为对象分配空间，并将变量初始化</li><li>调用构造方法</li><li>返回对象引用</li></ul><h4 id="实例变量和静态变量和静态函数"><a href="#实例变量和静态变量和静态函数" class="headerlink" title="实例变量和静态变量和静态函数"></a>实例变量和静态变量和静态函数</h4><p>类的成员变量有两种，一种是static修饰的变量，叫做类变量，或静态变量。一种是普通的实例变量。</p><p>静态变量就是归所有实例所共享的。而普通变量就是每一个实例所独有的。</p><p>静态变量储存在方法区，而普通变量存放在堆区。想到java类方法的访问过程就可以知道方法区是存放一些共有的东西，例如方法的二进制代码。每个类使用方法时直接调用就可以了。</p><p>静态函数有几个特点：</p><p>如果不是类中的静态函数，那么只能在当前文件中使用，相当于权限是private。</p><p>如果是类中的静态函数，只能使用静态变量，也不能调用类中的非静态成员函数。</p><p><strong>this</strong></p><p>java中也有this指针，也是指向当前对象，但是使用的是点操作符而不是箭头。使用上与c++大致相同，</p><p>例： owner.setdog(this)//this代表当前dog的对象</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>如果传递的是基本数据类型，那么就传递参数的值（值传递？）。如果是对象或者数组，那么就是引用传递。注意数组不是指针传递了，因为java中好像没有指针的概念。所以这里数组应该也可以作为返回值（纯推测，还没看到）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Apr 21 2020 20:14:58 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;因为是记笔记，这
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java初探</title>
    <link href="http://xinhecuican.github.io/post/912b2566.html"/>
    <id>http://xinhecuican.github.io/post/912b2566.html</id>
    <published>2020-04-19T10:59:00.000Z</published>
    <updated>2020-04-20T03:40:13.593Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 20 2020 11:40:19 GMT+0800 (中国标准时间) --><h3 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h3><p>java源文件可能包含以下内容：</p><ul><li>包声明语句</li><li>包引入语句</li><li>类声明</li><li>接口声明</li></ul><p>这些内容都不是必须的。此外要注意只能有一个类或接口是public的（一般也是private）。</p><h4 id="包声明语句"><a href="#包声明语句" class="headerlink" title="包声明语句"></a>包声明语句</h4><p>包声明语句把类放到特定的包中。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="NIMROD"><figure class="iseeu highlight /nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package com.abc.dollapp;</span><br><span class="line">public calss appmain<span class="meta">&#123;...&#125;</span>;</span><br><span class="line">class doll<span class="meta">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure></div><p>在这个例子中appmain和doll都在com.abc.dollapp包中。</p><p>在一个java文件中，只能有一个package语句。如果没有提供package，那么就表明在系统默认的包中。</p><h5 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h5><ol><li>用于区分名字相同的类。例如定义了两中车类名都叫car，一种实际上是奔驰，一种是宝马。把他们丢在不同的包中就可以区分他们，相当于使用了不同的命名空间[^1]。</li></ol><p>[^1]:命名空间实际上就是在函数前的一些附加消息。因为可能同时引入了多个库，库文件中可能某些函数名字相同，这个时候只有通过前面添加一些信息来辨别。典型例子就是using namespace std;这个含义就是使用标准命名空间。不然就要写std::cout来进行辨别。<br>2. 有助于访问权限的控制。但不同包之间进行访问时，就会受到访问权限的控制。<br>3. 有助于组织划分各个类。</p><h5 id="包的命名规范"><a href="#包的命名规范" class="headerlink" title="包的命名规范"></a>包的命名规范</h5><p>包的名字通常用小写，一般包含以下信息：</p><ol><li>类的创建者信息</li><li>类所属软件信息</li><li>类在具体项目中所处的位置</li></ol><p>jdk提供了一些基本包</p><ul><li>java.lang包，包含线程类（Thread)，异常类（Exception），系统类（System），整数类（Integer），字符串类（String）等。这个包系统会自动引入。</li><li>java.awt。抽象窗口工具包。用于构建GUI界面和绘图类</li><li>java.io 输入输出包。例如文件输入类（FileInputStream类）</li><li>java.util 实用类，例如日期类（Date）集合类（Collection）</li><li>java.net 支持TCP/IP网络协议。</li></ul><h5 id="包引入"><a href="#包引入" class="headerlink" title="包引入"></a>包引入</h5><p>如果一个类访问了另一个包的类，那么一定要引入这个类（就像c++中的库引入一样）。</p><p>语法： import 包名.类名</p><p>如果想引入一个包中所有类， 可以 import 包名.*</p><p>要注意最好使用第一种语法，因为第二种不仅耗时大并且还可能带来类名重复的问题，这个时候每写一个类都要写它的包名。</p><p>并且如果包中还有包的话，第二种语法是不会把内层包的类引入的。之所以可以包中有包是为了保证层次结构。例如前面提到的com.abc其实就是包中有包，com是外层，abc是内层。</p><p>package语句必须在import前</p><h4 id="方法（函数）声明"><a href="#方法（函数）声明" class="headerlink" title="方法（函数）声明"></a>方法（函数）声明</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DUST"><figure class="iseeu highlight /dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">返回值 函数名（参数）</span></span><br><span class="line"><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    主体</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这里的函数和c++大致相同</p><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>main方法和c++不一样了，要包含几个要素</p><ul><li>访问限制 public</li><li>静态方法 static</li><li>参数 main(String args[])</li><li>返回类型 void</li></ul><p>所以合起来就是 static public void main（String args[])</p><h5 id="给main传递参数"><a href="#给main传递参数" class="headerlink" title="给main传递参数"></a>给main传递参数</h5><p>格式： java classname [args…]</p><p>classname指的是类名</p><p>例如： java com.abc.dollapp.main.MainApp parameter0 parameter1</p><p>也就是c++中的argc，argv</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>第一种 //</p><p>第二种 <code>/*...*/</code></p><p>第三种 <code>/**...*/</code>，当这种注释出现在类的声明时，会作为javadoc的内容</p><h4 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h4><p>关键字之后慢慢就会知道</p><p>标识符命名规则：</p><ul><li>首字母必须是字母，下划线（_)，符号￥或符号$。</li><li>除开首字母其他字符可以用数字</li><li>没有长度限制</li></ul><h3 id="用jdk管理java应用"><a href="#用jdk管理java应用" class="headerlink" title="用jdk管理java应用"></a>用jdk管理java应用</h3><p>java常用目录（防止以后看到这些目录都不知道是干什么的）</p><table><thead><tr><th>src</th><th>存放源文件</th></tr></thead><tbody><tr><td>classes</td><td>存放编译生成的java文件</td></tr><tr><td>lib</td><td>存放第三方java软件的JAR文件（不要问我这是什么）</td></tr><tr><td>doc</td><td>存放帮助文档</td></tr><tr><td>doc\api</td><td>存放javadoc文档</td></tr><tr><td>deploy</td><td>存放打包文件，jar文件</td></tr></tbody></table><h3 id="使用javadoc文档"><a href="#使用javadoc文档" class="headerlink" title="使用javadoc文档"></a>使用javadoc文档</h3><p>java中有一个程序，可以识别类中的注释并将其转化成html文件。只有满足规范的文件才可以转化。</p><p>首先的规范就是注释要<code>/**...*/</code>才可以。里面可以有普通文件，html标记和javadoc标记。</p><p>范围：javadoc命令只处理类声明，接口声明，成员方法声明，成员变量声明，以及构造方法<strong>之前</strong>声明的注释。也就是说要在函数或类等的外面去声明。</p><h4 id="javadoc标记"><a href="#javadoc标记" class="headerlink" title="javadoc标记"></a>javadoc标记</h4><table><thead><tr><th>标记</th><th>说明</th></tr></thead><tbody><tr><td>@version</td><td>版本</td></tr><tr><td>@since</td><td>指定最早出现在哪个版本</td></tr><tr><td>@author</td><td>作者</td></tr><tr><td>@see</td><td>生成参考其他javadoc的链接</td></tr><tr><td>@link</td><td>生成链接，但是还可以添加其他的话</td></tr><tr><td>@deprecated</td><td>表示某些类或方法不提倡使用，之后可能会被废弃</td></tr><tr><td>@param</td><td>描述方法参数</td></tr><tr><td>@return</td><td>返回值</td></tr><tr><td>@throws</td><td>描述方法抛出的异常，指出抛出异常的条件</td></tr></tbody></table><p>@see用于生成到其他文档的链接。例如<code>@see #setWord</code>生成到setWord的链接。一共有三种格式</p><ul><li>set com.abc.dollapp.doll 生成到其他类的javadoc文档</li><li>set #setWord 生成当前类不同方法的javadoc文档</li><li>set com.abc.dollapp.doll#speak 生成到其他类的某一个方法的javadoc文档</li></ul><p>至于link在语法上与set大致相同，但是他可以用大括号插入到某一句话中，例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 如果&#123;<span class="variable">@link</span> <span class="comment">#word word成员变量&#125;不为NULL；</span></span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure></div><p>输出： 如果word<u>成员变量</u>不为NULL；</p><p>javadoc命令用法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="D"><figure class="iseeu highlight /d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">public</span> 仅为<span class="keyword">public</span>级别的类建立文档</span><br><span class="line">-<span class="keyword">protected</span> 进位<span class="keyword">public</span>和<span class="keyword">protected</span>建立文档 默认选项</span><br><span class="line">-<span class="keyword">package</span></span><br><span class="line">-<span class="keyword">private</span></span><br><span class="line">-<span class="keyword">version</span> 解析<span class="keyword">version</span>标记，默认情况会忽略</span><br><span class="line">-author </span><br><span class="line">-sourcepath&lt;path&gt; 指定源文件路径</span><br><span class="line">-classpath</span><br><span class="line">-d &lt;directory&gt; 指定javadoc的输出目录</span><br></pre></td></tr></table></figure></div><p>语法： javadoc [options] [packagenames] [sourcefiles]</p><h3 id="java虚拟机运行java的基本原理"><a href="#java虚拟机运行java的基本原理" class="headerlink" title="java虚拟机运行java的基本原理"></a>java虚拟机运行java的基本原理</h3><p>过程：先进行编译，之后进入虚拟机中变成机器指令。具体过程就不解释了，但是这里有一步就是根据操作系统进行运行。而java程序使运行在虚拟机上的。所以编译出来的文件可以在任何平台上运行。</p><p>系统会先给虚拟机分配一个空间。虚拟机又会把这个空间分成若干个部分。主要包括堆区，栈区，方法区等等。堆中存放对象，方法区中存放类的类型信息，方法信息和静态变量等等。</p><p>运行程序时，先要把程序的二进制加载到内存，然后对程序进行验证（包括初始化），之后再执行。</p><p>当生成一个实例时，虚拟机会先搜索方法区，如果方法区没有，那么就会先加载这个类。之后在堆区分配一片内存用来存放实例，实例有一个指向方法区的指针。这个实例用一个局部指针指向它（也就是实例名，和数组很像，不是说java不提供指针吗）。</p><p>所以运行一个java方法的过程是：先由类名到堆区，然后堆指向方法区的指针把对应的方法取出来（机器指令）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 20 2020 11:40:19 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;源文件结构&quot;&gt;&lt;a href=&quot;#源文件结构&quot; class=&quot;headerlink&quot; title=&quot;源文件结构&quot;&gt;&lt;/a&gt;源文件结构&lt;/h3
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title> UML简介</title>
    <link href="http://xinhecuican.github.io/post/5f9e4eff.html"/>
    <id>http://xinhecuican.github.io/post/5f9e4eff.html</id>
    <published>2020-04-18T12:42:00.000Z</published>
    <updated>2020-04-18T13:26:53.845Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Apr 18 2020 21:27:07 GMT+0800 (中国标准时间) --><p>简单来说UML就是结构图，表示对象与类，类与类之间的联系。</p><p>UML主要包含以下框图：</p><ul><li>用例图 从用户角度描述系统功能，简单来说就是用户让系统干什么（也可以说是系统的输入）</li><li>类框图 表示类与类之间的联系</li><li>状态转换图 这是针对有不同状态的类。类如开关的开和关就是状态的转换</li><li>时序图和协作图 时序图是在时间维度上描述用户的输入和类的使用。协作图则用箭头表示而不是通过时间轴表示</li></ul><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>用例图的要素有</p><ul><li>用户 画成一个人型</li><li>用例 系统的某一个功能，大多数时候就是某一个函数，用椭圆表示</li><li>关系，用箭头表示</li></ul><p>也可以用用例文档补充描述。</p><ul><li>前置条件，什么时候才可以输入</li><li>主事件流，也就是这个用例干了什么事</li><li>其它事件流， 比如错误了该干什么事</li><li>后置条件 用例必须为真条件（个人理解是什么时候可以输出）</li></ul><h3 id="类框图"><a href="#类框图" class="headerlink" title="类框图"></a>类框图</h3><p>类框图是表示类与类之间的关系（静态）。这个意思就是这个关系使不变的，做了一个就要去做另一个。</p><p>要素： 用一个方框表示类，方框的上面是类名，下面是函数名。用箭头表示方框之间关系。</p><h3 id="时序图与协作图"><a href="#时序图与协作图" class="headerlink" title="时序图与协作图"></a>时序图与协作图</h3><p>时序图有两个要素，</p><p>垂直上表示时间，水平上表示发送消息的过程。（用函数名和箭头表示）</p><p><img src="/images/%E4%B8%8B%E8%BD%BD.png" alt></p><p>协作图就用一个个箭头表示时间之间关系的。</p><p><img src="/images/20151113162700894" alt></p><h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p>要素：</p><ul><li>初始点 实心圆</li><li>状态之间的转换 箭头</li><li>状态 用圆点表示</li><li>终止点 用一个圆里面再加一个实心圆表示</li></ul><p>例：<br><img src="/images/20170305152530328.png" alt></p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><ul><li>关联 一个类和另一个类的实例有联系，例如老师和学生有联系。</li><li>依赖 A类访问类B提供的服务。例如A调用B的函数</li><li>聚集 A为整体类，B为局部类。A对象有B的对象组合而成（有个体组合成整体）。例如个人和人类。人类类中成员就是个人，人类类还有一些自己专属的方法。或者汽车和零部件。</li><li>泛化 A继承B</li><li>实现 A实现B的接口</li></ul><p>依赖和关联不同。关联是对应实例（也就是定义出来的东西），而关联是定义类是两个类总监有关系</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Apr 18 2020 21:27:07 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;简单来说UML就是结构图，表示对象与类，类与类之间的联系。&lt;/p&gt;&lt;p&gt;UML主要包含以下框图：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;用例图 从用户角度描述系统功能
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>储存设备</title>
    <link href="http://xinhecuican.github.io/post/7d1c86da.html"/>
    <id>http://xinhecuican.github.io/post/7d1c86da.html</id>
    <published>2020-04-16T04:57:00.000Z</published>
    <updated>2020-04-22T13:08:09.448Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 22 2020 21:08:25 GMT+0800 (中国标准时间) --><h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p><img src="/images/%E7%A1%AC%E7%9B%98.jpg" alt></p><p>结构： 由若干个盘片组成，每个盘片有2两面，每一面上有若干个磁道，每个磁道上又划分成若干个扇区，扇区是数据访问的最小单位。中间的轴在不停转动。每个扇区都有一个编号。</p><p>显然如果扇区划分时是从中心发出多根射线的话是不好的。因为内圈的扇区划分小，外面的扇区划分大，因此每个扇区读写数据数目可能会有较大的差距。但是很可能只需要利用其中很小一部分，这样就造成了浪费。所以磁道与磁道之间扇区数目是不同的，尽量使数据分布均匀。</p><p>图中左边的架子是读写头，可以前后滑动。数据就是通过读写头进行读写的。</p><p><strong>大致过程</strong>：先移动到对应扇区（寻道），然后等待读写头划过我们要读取的扇区。之后在读取这个扇区。要注意即使只需要读取一个字节也要把这个扇区全部读取完。如果是写的话，先把扇区中数据读取出来，然后再在这些数据中进行更改，最后再把这些数据写入到扇区中。</p><p>一般寻道在2-9ms，旋转也是10ms左右，而读取只需要0.02ms，所以说大头都在寻找过程中。并且要比dram慢2500倍，比sram慢40000倍。</p><p>机械硬盘扇区的读取次数是由限制的，大概是十万到100万次左右。如果某一扇区坏了是不是会导致整个硬盘都异常呢？当然这是不可能的，那样也太不经用了。</p><p>为了解决这个问题，可以用逻辑编号代替物理编号，然后用一定的映射规则转换到物理编号，如果某一个扇区损坏，硬盘中有一些备用的扇区可以替补上，这样就可以解决某一个扇区损坏的问题。可能某些逻辑扇区会被频繁的使用，如果对应规则是确定的那么可能很快那个扇区就会损坏，所以对应规则也要不断变化使每个扇区利用大致平均。</p><h3 id="固态硬盘（ssd）"><a href="#固态硬盘（ssd）" class="headerlink" title="固态硬盘（ssd）"></a>固态硬盘（ssd）</h3><p>结构： 固态硬盘最小的结构是页，每一页有若干个字节。之后若干个页组成了块。它是由闪存构成的（就是usb所使用的）</p><p>读写过程：读的过程是以<strong>页</strong>作为单位，也需要通过一定的映射使之利用均衡。但是写的过程却是以<strong>块</strong>作为单位，就算只改一个字节也需要读取整个块，并且写的过程中需要先把原来的内容全部擦除，所以写过程比读过程慢的多。</p><p>ssd好处是读写较快，但是价格贵，并且读写次数少，只有1万到10万次。</p><h3 id="局部性和高速缓存"><a href="#局部性和高速缓存" class="headerlink" title="局部性和高速缓存"></a>局部性和高速缓存</h3><p>局部性分为时间局部性和空间局部性。</p><p>时间局部性指的是在短时间内多次重复使用某个内存。</p><p>空间局部性指的是一个内存被使用，很可能接下来会使用这段内存附近的数据。</p><p>现代计算机cpu运算速度已经很快了，但是内存的访问速度却跟不上cpu的运算速度。因此现在更重要的是解决内存读取速度的问题。</p><p>根据上面所说的局部性原理（这是人们通过大量观察总结得出的规律），人们想到可以把常用的数据放在一个更快的储存器里，这样就可以提高运算速度。</p><p>于是就有了高速缓存。高速缓存（cahce）是用sram制成的，它的速度很快但是容量很小，直接集成到了cpu内部，每次cpu访问内存的时候都会先从高速缓存中读取。如果高速缓存中没有才会去内存中查找。从内存中取出数据并不是只取那几个字节，而是把附近的指令都放到高速缓存中（因为局部性原理），这样就可以提高速度。</p><h3 id="高速缓存运行原理"><a href="#高速缓存运行原理" class="headerlink" title="高速缓存运行原理"></a>高速缓存运行原理</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png" alt></p><p>一共有S个组，每个组有E行，每行有B个字节。S，E，B都是2的n次方，记S是2的s次方，E是2的e次方，B是2的b次方。</p><p>每一行的B字节都是由三部分组成。最高位叫做有效位，用来判定这一行中是否储存了数据。之后又t字节标记位，用来进行判别，后面的位才是实际从内存中取出来的内容。</p><p>每次cpu访问一个地址时，可以把地址分成3个部分。最低b位是块偏移，中间s位是组索引，高t位是标记。</p><p>进行查询时，先用中间s位找出组索引。例如中间s位是010，那么组索引是2.找到组索引后就用高t位的标记进行比对，如果对应行中最高位为1且标记位正好符合那么就通过最后的b字节找到块偏移。然后取出数据。</p><p>注意，我们只需要找到对应的组就行了，cpu可以自动对该组所有行同时进行比对而不用一一比对。</p><p>例 cpu发出一个指令，要从0111位置取出两字节数据。首先高速缓存中有四组，每组一行。每行四字节。所以这里块偏移是1组索引是11，标记是0.那么我们先通过中间的11确定是第三组，之后再和第三组最高位为1的进行比对，如果有一行标记位正好是0，那么就算出偏移量是1，所以从后面开始的第一位（有第零位）取出两个字节。</p><h4 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h4><p>直接映射高速缓存的特点是每一组只有一行。所以找到组后直接进行比对即可。但是这里有一个问题，例如组索引是1，标记位有两位。那么可能频繁的取出组索引相同但是标记位不同的数据，那么我们就要频繁的从内存中取出数据（miss），这样就降低了速度。</p><h4 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h4><p>组相联高速缓存和直接告诉缓存的不同是组相联高速缓存中每一组有多个行，这样就更可以存放更多的标记位，miss的可能性也就越低。但是这个的问题是因为要同时访问多行，所以硬件设计比较困难。</p><h4 id="全相连高速缓存"><a href="#全相连高速缓存" class="headerlink" title="全相连高速缓存"></a>全相连高速缓存</h4><p>全相连高速缓存中只有一个组，因此没有组索引（想要有组索引最少要有两个组）。</p><p>因此把cpu发送的内存地址分成两个部分，块偏移和标记。因为没有组索引，所以这两部分一般比较大。它可以同时匹配所有的行，也就少了寻找组索引的计算，但是如果行太多设计极为困难，所以只适合做小的高速缓存。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 22 2020 21:08:25 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;机械硬盘&quot;&gt;&lt;a href=&quot;#机械硬盘&quot; class=&quot;headerlink&quot; title=&quot;机械硬盘&quot;&gt;&lt;/a&gt;机械硬盘&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>进程和作业控制</title>
    <link href="http://xinhecuican.github.io/post/31a6b40.html"/>
    <id>http://xinhecuican.github.io/post/31a6b40.html</id>
    <published>2020-04-14T13:14:00.000Z</published>
    <updated>2020-04-17T09:07:38.043Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Apr 17 2020 17:07:38 GMT+0800 (中国标准时间) --><p>进程就是加载到内存中准备执行的程序。当进程创建的时候，内核赋予了唯一的标识号，这个标识号叫做进程ID或PID。</p><p>进程同一时间内可达数百个之多，为了管理这么多的进程。系统提供了一个调度器来维护。调度器维护一个所有进程的列表，每次选择一个进程（实际上可以一次选择多个进程），然后执行一个短暂的时间（时间片）。</p><p>典型的时间片是10毫秒。为了为了下一个时间片还可以顺利的执行，系统必须要保存下一条指令的位置，环境的副本等。</p><h3 id="进程分叉到死亡"><a href="#进程分叉到死亡" class="headerlink" title="进程分叉到死亡"></a>进程分叉到死亡</h3><p>当进程需要使用内核的服务时，会使用<strong>系统调用</strong>发送请求。在编写程序时，系统调用的使用方法取决于语言。例如，c语言使用标准库中的函数进行调用。</p><p>下面列举一些常见的系统调用函数</p><table><thead><tr><th>系统调用</th><th>作用</th></tr></thead><tbody><tr><td><strong>进程控制</strong></td><td></td></tr><tr><td>fork</td><td>创建当前进程的一个副本</td></tr><tr><td>wait</td><td>等待另一个程序结束后执行（强制暂停当前进程）</td></tr><tr><td>exec</td><td>在当前进程中执行一个新进程</td></tr><tr><td>exit</td><td>中止当前进程</td></tr><tr><td>kill</td><td>杀死子进程</td></tr><tr><td><strong>文件I/O</strong></td><td></td></tr><tr><td>open</td><td>打开一个用于读取或写入的文件</td></tr><tr><td>read</td><td>从文件中读取数据</td></tr><tr><td>write</td><td>向文件中写入了数据</td></tr><tr><td>close</td><td>关闭文件</td></tr></tbody></table><p>fork打开的一个新进程叫做当前进程的子女，当前进程是新进程的双亲。</p><p>例如，shell打开内部命令时首先就要调用fork创建一个新进程，当子进程结束时会调用exit释放资源，被杀死的进程叫做僵进程。但是进程表中却仍然保存子进程的数据，因为父进程可能需要这些数据。。</p><p>当子进程创建时，父进程停止运行，等到子进程被杀死之后，父进程先看一眼进程表中子进程的数据，然后开始运行，与此同时，子进程从进程表中被销毁。</p><h3 id="孤儿进程，父进程，子进程"><a href="#孤儿进程，父进程，子进程" class="headerlink" title="孤儿进程，父进程，子进程"></a>孤儿进程，父进程，子进程</h3><p>孤儿进程指的是父进程意外死亡，这时只有子进程。所以当子进程结束时，因为没有人来接受它，会一直留在进程表中，直到系统结束才会死亡。</p><p>当然，现代系统没有这么傻。孤儿进程会自动被init进程收养，通过这种方式，每当产生孤儿进程时，都会迅速的被init进程销毁。</p><p>除了父进程意外死亡外子进程也可能一直不死，这种情况一般是程序出现bug无法正常退出时产生的，这个程序会一直消耗系统资源。kill可以解决这种问题。kill会杀死父进程然后让init进程托管，在适当的时候会杀死子进程（我估计是一定时间，猜测）。</p><p>关于父进程，fork创建一个和父进程一模一样的副本，那么这时如何知道谁是父进程，谁是子进程呢？其实fork创建子进程完成之后会返回给父进程和子进程一个值，子进程返回值是零，父进程返回值大于零。如果某个进程得到了零，那么他就会开始工作，得到大于零的就会停止工作（通过wait使自己暂停）</p><h3 id="init-第一个进程"><a href="#init-第一个进程" class="headerlink" title="init 第一个进程"></a>init 第一个进程</h3><p>假设进程是通过分叉创建的，那么除第一个进程外的进程一定会有父进程，也一定会有第一个进程。</p><p>实际上也是这样，Linux在启动时会创建一个特殊的进程，PID是0，这个进程叫做空闲进程。</p><p>在进行了一些操作之后，0号进程开始分叉创建1号进程。之后0号进程就会死亡，然后由1号进程进行剩余的初始化步骤，例如进行多次分叉创建其他进程。因为 他要执行初始化步骤，所以叫初始化进程，也就是init进程。</p><h3 id="前台和后台进程"><a href="#前台和后台进程" class="headerlink" title="前台和后台进程"></a>前台和后台进程</h3><p>前台进程就是当前需要我们交互的进程，后台进程就是自己跑的进程。</p><p>例如： sort &lt; temp &gt; temp2 &amp;。后面的与符号就是让程序自己去后面跑，这时我们就可以直接使用shell了。</p><p>但是后台进程不能从标准输入中读取，可以输出到标准输出中，这就带来一个问题。如果这个程序需要输入但是你却把它划分成后台程序，那么他会一直等待输入。</p><h3 id="sleep-创建延迟"><a href="#sleep-创建延迟" class="headerlink" title="sleep 创建延迟"></a>sleep 创建延迟</h3><p>语法： sleep interval [s | m | h | d ]</p><p>interval是时间间隔，后面是单位，默认是秒。</p><p>例如 sleep 5 表示中断5秒。</p><h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><p>作业就是每一条输入的指令，该作业有一个唯一的作业号来标识。作业控制就是对输入的指令进行调控。常见的作业控制命令如下表。</p><table><thead><tr><th>作业控制命令</th><th></th></tr></thead><tbody><tr><td>jobs</td><td>显示作业列表</td></tr><tr><td>ps</td><td>显示进程列表</td></tr><tr><td>fg</td><td>将作业移至前台</td></tr><tr><td>bg</td><td>将作业移至后台</td></tr><tr><td>suspend</td><td>挂起当前shell</td></tr><tr><td>^Z</td><td>挂起当前前台作业</td></tr><tr><td>kill</td><td>终止作业</td></tr><tr><td>suspend</td><td>挂起shell，例如超级用户暂时返回普通用户</td></tr></tbody></table><p>echo $$ 显示当前shell的PID</p><p>echo $! 显示上一条移至后台的PID</p><p>stty tostop 挂起试图向终端写数据的后台作业</p><p>set -o monitor 允许作业控制</p><p>set -o notify 当后台作业结束时立刻通报</p><h3 id="在后台运行作业"><a href="#在后台运行作业" class="headerlink" title="在后台运行作业"></a>在后台运行作业</h3><p>为了在后台运行作业，需要在命令的最后加一个&amp;符号。</p><p>每次在后台运行作业时，系统都会自动分配一个作业号，从1开始，依次向后增加。</p><p>每次后台作业完成时，都会向终端发送一个信息表示已经完成。</p><h3 id="fg-将作业移至前台"><a href="#fg-将作业移至前台" class="headerlink" title="fg 将作业移至前台"></a>fg 将作业移至前台</h3><p>挂起可能令人有些误解，其实就是暂停程序。可以用fg将挂起的作业恢复。</p><p>例如当你用vi编辑一个文件时，突然忘了某些东西想通过man查一下，可以先用ctrl+Z把vi挂起，然后查找，查找完了之后又用fg命令将vi唤醒。</p><p>如果有挂起的程序那么关机时系统会给你提示，你可以选择关机或者先把挂起的程序移至前台。</p><p>语法： fg %[job]</p><p>fg %%代表唤起当前进程。因为一般进程挂起后都是运行别的进程，运行完了才又唤醒进程，此时挂起的进程又成了最前面的进程。</p><p>后面的job是作业编号，可以通过jobs程序查看。</p><p>bg和fg大致相同。</p><h3 id="ps程序"><a href="#ps程序" class="headerlink" title="ps程序"></a>ps程序</h3><p>ps程序是用来显示进程状态的</p><p>语法： ps [-aefFly] [-p pid] [-u userid]</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ps</span> <span class="string">显示与当前用户标识和终端相关的进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-a 所有与用户标识进程与终端相关的非守护进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-e 所有进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-p pid 显示指定pid的进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-u userid 显示指定userid的进程</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-ef 显示所有用户的进程，完整输出</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">-t 显示所有守护进程</span></span><br></pre></td></tr></table></figure></div><p>下面列举了ps输出时的标题和所代表的含义</p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>ADDR</td><td>进程表中虚拟地址</td></tr><tr><td>C</td><td>处理器利用率</td></tr><tr><td>CMD</td><td>命令名称</td></tr><tr><td>F</td><td>进程相关的标志</td></tr><tr><td>NI</td><td>nice值，用于设置优先级</td></tr><tr><td>PID</td><td>进程ID</td></tr><tr><td>PPID</td><td>父进程ID</td></tr><tr><td>PRI</td><td>优先级（大数字 = 小优先级 ）</td></tr><tr><td>RSS</td><td>内存预留空间大小</td></tr><tr><td>S</td><td>状态代码（D,R,S,T,Z）</td></tr><tr><td>STIME</td><td>累计系统时间</td></tr><tr><td>SZ</td><td>物理页大小</td></tr><tr><td>TIME</td><td>累计cpu时间</td></tr><tr><td>TTY</td><td>控制终端完整名称</td></tr><tr><td>UID</td><td>用户标识</td></tr><tr><td>WCHAN</td><td>等待通道</td></tr></tbody></table><p>状态代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">D</span> <span class="string">不可中断睡眠，等待事件结束</span></span><br><span class="line"><span class="attr">I</span> <span class="string">空闲，超过20s的睡眠</span></span><br><span class="line"><span class="attr">R</span> <span class="string">正在运行或者可运行（可运行是在运行队列中等待）</span></span><br><span class="line"><span class="attr">S</span> <span class="string">可中断睡眠，等待时间结束</span></span><br><span class="line"><span class="attr">T</span> <span class="string">挂起</span></span><br><span class="line"><span class="attr">Z</span> <span class="string">僵进程</span></span><br></pre></td></tr></table></figure></div><p>-ly 显示状态代码</p><h3 id="监视系统进程"><a href="#监视系统进程" class="headerlink" title="监视系统进程"></a>监视系统进程</h3><p>语法： top [-d delay] [-n count] [p pid[,pid]…]</p><p>top的作用是动态显示进程信息。</p><p>-d 每隔多少秒刷新一次</p><p>-n 只在特定的时间进行刷新</p><p>-p 对某几个进程进行监视</p><h3 id="显示进程树"><a href="#显示进程树" class="headerlink" title="显示进程树"></a>显示进程树</h3><p>语法： pstree [-aAcGnpu] [pid | userid]</p><p>作用：因为进程几乎都是通过分叉产生的，所以这个作用是显示进程之间的关系（即谁是父进程谁是子进程）。</p><p>具体的可以去看联机手册</p><h3 id="kill-杀死进程，向进程发送信号"><a href="#kill-杀死进程，向进程发送信号" class="headerlink" title="kill 杀死进程，向进程发送信号"></a>kill 杀死进程，向进程发送信号</h3><p>语法： kill [-signal] pid… | jobid…</p><p>| signal | 含义 |<br>| 1 | 中止，注销或终端失去连接时发送给进程 |<br>| 2 | 中断，按下^C时发送 |<br>| 9 | 杀死，立刻杀死，进程不能捕获 |<br>| 15 | 终止，请求终止，进程不能捕获 |<br>| 18 | 继续，恢复挂起的进程，由fg或bg发送 |<br>| 19 | 停止（挂起），按^Z发送 |</p><h3 id="设置进程优先级-nice，renice"><a href="#设置进程优先级-nice，renice" class="headerlink" title="设置进程优先级 nice，renice"></a>设置进程优先级 nice，renice</h3><p>优先级决定了你能享有的系统资源。nice程序用于设定优先级。</p><p>语法： nice [-n adjustment] command</p><p>使用nice时要注意，只能对外部程序例如软件和自己写的程序设置优先级，系统内部命令不能设定优先级。其次，一般只对后台程序降低优先级，对前台程序降低优先级是自己找罪受。</p><p>不使用nice时优先级是0，使用nice默认的优先级是10，数字越大优先级越低，最大可以设到20，最小可以设到-20.当设负数的时候是提高优先级。</p><p><strong>renice</strong>重新设置优先级。</p><p>语法： renice niceness -p processid</p><p>niceness是nice值，processid是进程ID。</p><p>niec程序是在程序开始运行时确定的，使用nice程序后command程序便开始运行。而renice是对已运行的程序重新设置优先级。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>很多程序并不是由用户运行的，由系统运行的程序就是守护程序。相当于windows中的服务程序。这些程序不受终端控制</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Apr 17 2020 17:07:38 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;进程就是加载到内存中准备执行的程序。当进程创建的时候，内核赋予了唯一的标识号，这个标识号叫做进程ID或PID。&lt;/p&gt;&lt;p&gt;进程同一时间内可达数百个之
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>文件操作</title>
    <link href="http://xinhecuican.github.io/post/95495db.html"/>
    <id>http://xinhecuican.github.io/post/95495db.html</id>
    <published>2020-04-10T08:53:00.000Z</published>
    <updated>2020-04-20T08:32:06.237Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 20 2020 18:47:10 GMT+0800 (中国标准时间) --><h3 id="touch-创建文件"><a href="#touch-创建文件" class="headerlink" title="touch 创建文件"></a>touch 创建文件</h3><p>创建文件有许多种方式，例如用vi创建文件，利用重定向创建文件。</p><p>语法： touch [-acm] [-t time] file…</p><p>作用： 创建文件，改变文件的修改时间和访问时间。</p><p>-m 改变修改时间</p><p>-a 改变访问时间</p><p>-t 用一个具体的时间去替换</p><p>如果不加参数会将修改时间和访问时间全部修改。</p><p>例如： touch * ，这个命令会修改目录下的所有文件的访问时间和修改时间。</p><p>如果后面接的文件名不存在，touch将会创建一个文件。</p><p>-c 不创建文件。如果文件存在，会修改时间，如果文件不存在，不进行操作。</p><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>要求：</p><ol><li>文件名最长是255个字符</li><li>文件名可以包含除了/外的任何字符</li></ol><p>虽然说创建文件名的时候没有太多的要求，但是最好创建有意义的名字并且不要实用一些特殊字符。例如-，虽然创建的时候不会出现问题，但是使用命令进行操作的时候却会带来麻烦。</p><h3 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp 复制文件"></a>cp 复制文件</h3><p>语法： cp [-ip] file1 file2</p><p>file1是已有文件 file2是目标文件</p><p>例如： cp /etc/passwd ~/pword</p><p>这个命令会复制passwd文件到pword中，如果pword不存在，那么就会创建。这时需要特别小心，如果目标文件存在，那么复制完之后原来的内容咩有办法找回。</p><p>如果想追加数据，则不能用cp，只能用cat重定向追加内容。</p><p>cp很容易错误的清楚数据，为了保险起见，可以用-i选项。这个选项会在替换已有文件时先询问。可以在初始化文件中直接设定。</p><p>还有一个选项是-p，这个命令使目标文件和原文件有相同的修改时间访问时间和权限。</p><p><strong>-r</strong>，将一个目录复制到另一个目录中。</p><p><strong>将文件复制到不同目录中</strong></p><p>就是将file2变成directory。</p><h3 id="mv-移动文件"><a href="#mv-移动文件" class="headerlink" title="mv 移动文件"></a>mv 移动文件</h3><p><a href="https://xinhecuican.github.io/post/61312.html#more">在前面博客中已经提到</a></p><h3 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm 删除文件"></a>rm 删除文件</h3><p>语法： rm [-fir] file…</p><p>rm删除同样是不可恢复的。为了防止误删文件，可以使用-i选项，每次删除之前请求许可。</p><p>-f 强制删除文件，不考虑权限和-i。</p><p>-r 删除整个目录树，这个选项会将从工作目录开始的所有文件全部删除</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>权限一共有三种，读权限，写权限，执行权限。这些权限和用户标识也有关，如果是普通用户，可能对一些文件没有写权限和执行权限。</p><p>设置权限有两个目的，限制其他用户的访问和避免自己错误的使用。</p><p>下面是权限的作用</p><table><thead><tr><th>文件</th><th></th></tr></thead><tbody><tr><td>读</td><td>读取文件(没有这个权限使用命令也无法查看文件）</td></tr><tr><td>写</td><td>写入文件，没有写权限的话在删除和替换时都会先询问</td></tr><tr><td>执行</td><td>执行文件</td></tr><tr><td>** 目录**</td><td></td></tr><tr><td>读</td><td>读取（查看）目录</td></tr><tr><td>写</td><td>创建、移动、复制或删除目录</td></tr><tr><td>执行</td><td>搜索目录</td></tr></tbody></table><p>例如，有这个文件的写权限和执行权限，那么无法看到它（也就是点文件），但是如果知道它的位置，还是可以对他进行操作。</p><h4 id="id-groups-维护文件权限"><a href="#id-groups-维护文件权限" class="headerlink" title="id groups 维护文件权限"></a>id groups 维护文件权限</h4><p>创建文件的用户标识就是文件的属主。每个用户都属于一个组，第二组是组中其他人，第三组是其他人，可以为这三组设置读写和执行权限。</p><p>系统中组标识的列表在/etc/group中，这个文件可以自由查看</p><p>id就是用来查看当前用户标识和属于那个组的。groups命令是同样的作用。</p><h4 id="ls-l显示文件权限"><a href="#ls-l显示文件权限" class="headerlink" title="ls -l显示文件权限"></a>ls -l显示文件权限</h4><p>使用-l时，从左边开始会有一些字符。例如-rwx等等</p><p>首先第一个字符是-或者d，-代表普通文件，d代表目录。之后会有9个字符分成3组，分别代表个人权限，族权限，其他人权限。</p><p>除了这种表示方法，还可以用三个数字表示三中类型的权限</p><ul><li>r: 读权限 数字 4</li><li>w: 写权限 数字 2</li><li>x: 执行权限 数字 1</li><li>-: 没有权限 数字 0</li></ul><p>例如只有读写权限，那么就可以用6来代表。</p><h4 id="改变文件权限"><a href="#改变文件权限" class="headerlink" title="改变文件权限"></a>改变文件权限</h4><p>可以使用chmod（change file mode）来改变文件权限</p><p>语法： chmod mode file…</p><p>这里的mode是使用数字表示的，并且一次要写三种类型。</p><p>例如： chmod 644 file1</p><h3 id="shred-清空文件内容"><a href="#shred-清空文件内容" class="headerlink" title="shred 清空文件内容"></a>shred 清空文件内容</h3><p>前面讲的rm命令只是删除了文件，但是文件所在的空间还是可以重新被使用的。甚至这个时候如果用昂贵的设备，那么其中的内容还是可以恢复的。如果使用了shred，那么就会毁坏硬盘（后备隐藏能源？），这时数据就永远无法恢复了。这里就不展开了。</p><h3 id="stat-ls-i-链接的概念"><a href="#stat-ls-i-链接的概念" class="headerlink" title="stat ls -i 链接的概念"></a>stat ls -i 链接的概念</h3><p>当linux创建文件时，进行两个操作。在储存设备上保留一块空间来保存数据，之后创建一个索引节点（i节点）来存放数据的基本信息。i节点包含使用文件所需的全部信息</p><p>stat命令就是查看i节点的内容</p><p>所有的i节点存放于一个大表中，称为i节点表。在节点表中，每个i节点由索引号和i节点号表示。为了查看节点号，可以使用ls -i选项。如果想查看所有节点，可以使用ls -il。</p><p>处理目录时，其实我们处理的是i节点号和节点名称。所以目录实际上很小。只有一个名称，每一个名称对应一个i节点号。</p><p>例如，我们现在bin目录中创建swap文件。那么先保留一块空间，如果查看i节点表，查找一个空闲的i节点。然后linux将信息填充到属于这个文件的i节点中。之后在bin目录中放入一个条目，该条目有名称和i节点号。</p><p>文件名和i节点之间的连接叫链接。</p><h3 id="多重链接，一个文件，多个名字"><a href="#多重链接，一个文件，多个名字" class="headerlink" title="多重链接，一个文件，多个名字"></a>多重链接，一个文件，多个名字</h3><p>多重链接就是一个文件可以有不同的名称。因为文件标识实际上是i节点号，我们从目录中查询的时候也是查询i节点号然后根据节点号中的信息去访问。因此我们可以在不同目录中创建指向同一个节点号的文件，这其实就是快捷方式。</p><h4 id="ln-创建新链接"><a href="#ln-创建新链接" class="headerlink" title="ln 创建新链接"></a>ln 创建新链接</h4><p>语法： ln file newname</p><p>作用：每当创建文件时，系统都会自动在文件和文件名间创建一个链接。如果我们想为已有文件创建一个新链接，就可以用ln（link）。</p><p>我们也可以将newname改成directory，那么就是创建快捷方式</p><p><strong>移除链接</strong></p><p>直接用rm命令即可，除非所有链接都被删除，不然文件不会被删除。</p><h3 id="符号链接-ln-s"><a href="#符号链接-ln-s" class="headerlink" title="符号链接 ln -s"></a>符号链接 ln -s</h3><p>前面讲的链接有两点限制。一，不能为目录创建链接。二，不能为不同文件系统创建链接。（因为目录没有i节点）</p><p>如果想克服上述情况，就需要创建符号链接。符号链接包含的不是文件的i节点号，而是原文件的路径名。</p><p>但是用ls -l时，左边会有一个l代表链接。实际符号链接在右边。用一个-&gt;符号后面加上指向的真实文件名表示。因为符号链接只存一个路径，所以大小也只有4字节。注意这是符号链接才会有-&gt;符号，一般的链接不会显示。</p><p>一般的链接叫做硬链接，就是起了一个别名。符号链接叫做软链接，实际上并不是存放那个文件，只是存放一个指向文件的地址。</p><p>硬链接数量ls -l可以显示，但是软链接无法显示，因为系统也不知道有多少软链接。并且当文件被删除时，软链接也不会被删除，只是打开时发生错误</p><h4 id="目录使用符号链接"><a href="#目录使用符号链接" class="headerlink" title="目录使用符号链接"></a>目录使用符号链接</h4><p>当我们对目录使用符号链接之后，cd时到底应该显示真实的目录还是符号链接目录呢？实际上两种都可以。</p><p>如果使用cd -L选项，将把符号链接视为真实目录，使用-P选项将用真实目录替换符号链接，也就是直接进入真实目录。默认情况是-L。</p><p>我们使用-L情况是和-P一样的，使用-L时目录显示与原文件相同，就是实际对源文件进行操作的时候想要进行跳转。</p><h3 id="locate-通过数据库查看文件"><a href="#locate-通过数据库查看文件" class="headerlink" title="locate 通过数据库查看文件"></a>locate 通过数据库查看文件</h3><p>语法： locate [-bcirS] pattern…</p><p>作用： 在一个特殊的数据库（包含所有的可公共访问的文件，且定期更新）查找文件。</p><p>如果想使用正则表达式，可以使用-r选项 ，可以用^和$表示开头和结尾。</p><p>例如 locate -r ‘.jpg$’ 是找jpg图片</p><p>locate -ir ‘^/usr*x11$’ 是找以/usr开头，x11结尾的。</p><ul><li>-c 统计数目，而不显示位置</li><li>-i 忽略大小写</li></ul><h3 id="find-搜索目录树查找文件"><a href="#find-搜索目录树查找文件" class="headerlink" title="find 搜索目录树查找文件"></a>find 搜索目录树查找文件</h3><p>语法： find path… test… action…</p><p>输入命令后，find执行三步</p><ol><li>路径，先查看每个路径，检查这个路径代表的整个目录树</li><li>测试，对于遇到的每个文件，find用指定的测试条件进行测试，成功就进行下一步</li><li>动作，一旦搜索完成，对成功通过上面两个步骤的文件做的操作</li></ol><p>例如： find /home/harley -name important -print</p><p>路径： /home/harley。表示从harley目录开始进行搜索，也就是home目录不搜索。路径可以有多个</p><p>动作： -name important。这个的含义是查找名字是important的文件</p><p>动作： -print。输出路径名</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>下列是一些模式</p><table><thead><tr><th>文件名</th><th></th></tr></thead><tbody><tr><td>-name pattern</td><td>包含pattern的文件名</td></tr><tr><td>-iname pattern</td><td>不区分大小写</td></tr><tr><td><strong>文件特征</strong></td><td></td></tr><tr><td>-type [df]</td><td>文件类型 d：目录 f：普通文件</td></tr><tr><td>-perm mode</td><td>文件权限</td></tr><tr><td>-user userid</td><td>文件属主</td></tr><tr><td>-group groupid</td><td>组为groupid</td></tr><tr><td>-size [-+]n[cbkMG]</td><td>大小为n[字节，块，kb，mb，gb]</td></tr><tr><td>-empty</td><td>空文件</td></tr><tr><td><strong>访问时间，修改时间</strong></td><td></td></tr><tr><td>-amin [-+]n</td><td>n分钟之前访问，-是小于这个时间</td></tr><tr><td>-atime [-+]n</td><td>n天之前访问</td></tr><tr><td>-anewer file</td><td>file之后访问</td></tr><tr><td>-cmin [-+]n</td><td>n分钟之前状态改变</td></tr><tr><td>-cnewer file</td><td>file状态改变之后改变</td></tr><tr><td>-time [-+]n</td><td>…</td></tr><tr><td>-mmin [-+]n</td><td>n分钟之前修改</td></tr><tr><td>-mtime [-+]n</td><td>n天之前修改</td></tr><tr><td>-newer file</td><td>file文件之后修改</td></tr></tbody></table><p>最重要的是type和name。中括号中的加减号代表的是大于和小于。</p><p>type控制查找那些类型。除了上面的之外，还有b(块设备），c（字符设备），p（命名管道），l（符号链接）</p><p>例如： <code>find . -type f -name important -print</code></p><p>其中name后面的pattern可以用通配符。</p><p>cmin代表的是访问或修改。</p><p>例如： find ~ -cmin -10 -print</p><p>这个的含义是查找10分钟内被访问或修改的文件。</p><h4 id="使用！对测试求反"><a href="#使用！对测试求反" class="headerlink" title="使用！对测试求反"></a>使用！对测试求反</h4><p>使用!时要注意两个问题：</p><ol><li>！号两边要有空格</li><li>必须要引用！，可以<code>\!</code>,也可以’!’</li></ol><p>并且一个感叹号只对一个测试有效。</p><h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><table><thead><tr><th>动作</th><th></th></tr></thead><tbody><tr><td>-print</td><td>将路径名写入标准输出</td></tr><tr><td>-fprint file</td><td>将输出写入file中</td></tr><tr><td>-ls</td><td>显示长目录列表，和ls -l输出样式差不多</td></tr><tr><td>-fls file</td><td>输出写入file中</td></tr><tr><td>-delete</td><td>输出文件</td></tr><tr><td>-exec command {} ;</td><td>执行command，{}指示匹配的文件名</td></tr><tr><td>-ok command {} ;</td><td>同exec，在执行command前先确认</td></tr></tbody></table><p>exec后面的command是linux的程序例如ls，echo等。这条命令以;（封号）结尾，前面的\是转义字符。而{}有些系统必须要加转义字符。</p><p>例如： <code>find . -name &#39;*.backup&#39; -exec ls -dils {} \;</code></p><h4 id="xargs-处理查找到的文件"><a href="#xargs-处理查找到的文件" class="headerlink" title="xargs 处理查找到的文件"></a>xargs 处理查找到的文件</h4><p>对于查找到的文件可以用exec处理，但是这里专门有一个程序去处理。</p><p>语法： xargs [-prt] [-i string] [command | argument…]</p><p>command是希望运行的程序，string是占位符，argument是从标准输入中读取的参数。</p><p>例如： find ~ -type f | xargs ls -s</p><p>如果想多次运行同一命令，那么需要使用-i选项，并且后面要使用 { }作为占位符，占位符在命令开始之前会被参数替代。</p><p>例如： find . -type f | xargs -i echo { } { }</p><p>这条命令将会连续输出两次。如果想自己指定占位符，可以直接在-i后面添加字符串。</p><p>例如： find . -type f | xargs -iXX mv XX ~/backups/XX.old</p><p>这条命令即移动又进行了重命名（变成XX.old)</p><p>-p 运行命令之前先提示</p><p>-t 运行命令不会请求许可但是会显示在标准输出中。</p><p>-r 如果没有参数，则不执行。</p><p>例如： <code>find . -empty | xarg -r ls -l</code></p><p>原本如果是没有空文件的话ls将会输出整个目录，这当然不对，所以没有空文件的时候就可以让他忽略。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 20 2020 18:47:10 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;touch-创建文件&quot;&gt;&lt;a href=&quot;#touch-创建文件&quot; class=&quot;headerlink&quot; title=&quot;touch 创建文件
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>流水线</title>
    <link href="http://xinhecuican.github.io/post/b4c1d206.html"/>
    <id>http://xinhecuican.github.io/post/b4c1d206.html</id>
    <published>2020-04-09T08:25:00.000Z</published>
    <updated>2020-04-09T09:58:26.545Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>cpu运算可以简化成两大块，运算单元和寄存器。大致过程是先从寄存器中取值然后放入运算单元中运算完成之后又放入寄存器中。大致过程可分为六个部分</p><ol><li>fetch(取指），读入指令</li><li>decode(译码),解码然后把寄存器中的值放到运算单元中</li><li>execute(执行), 进行计算</li><li>memory(访存),把结果放到内存中</li><li>write back（写回），把结果放到寄存器中</li><li>PC（更新PC）</li></ol><p>这六个部分和把数据放到寄存器所用的总时间就是执行一条指令所需要的时间。cpu中有一个时钟，时钟以特定的周期进行高电压和低电压的变换。每一个周期内cpu执行一条指令，这个周期就是时钟周期。</p><p>但是这样速度不够快，因为cpu同一时间内只有一部分在工作，其他的都处于待机状态，所以可以用一种办法把其他部分利用起来。</p><p>之前我们之所以不能连续送入多条指令的原因是如果牵一条指令还未执行完成后一条指令便开始执行很可能导致电路出现问题（先这样理解吧）。如果我们在中间插入寄存器的话便不存在这个问题了。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GHERKIN"><figure class="iseeu highlight /gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> 算术单元 </span>|<span class="string"> 寄存器 </span>|</span><br><span class="line">|<span class="string"> 300ps   </span>|<span class="string">  20ps  </span>|</span><br><span class="line">|<span class="string"> 算术单元1 </span>|<span class="string"> 寄存器1 </span>|<span class="string"> 算术单元2 </span>|<span class="string"> 寄存器2 </span>|<span class="string"> 算术单元3 </span>|<span class="string"> 寄存器</span></span><br><span class="line">|<span class="string"> 100ps    </span>|<span class="string"> 20ps   </span>|<span class="string"> 100ps    </span>|<span class="string"> 20ps   </span>|<span class="string"> 100ps    </span>|<span class="string"> 20ps</span></span><br></pre></td></tr></table></figure></div><p>乍一看加了寄存器之后时钟周期反而变长了，便成360ps。但实际上现在可以每120ps送入一条指令，先前的运算结果可以先储存在寄存器中，新一个时钟周期时把寄存器中的值送入下一个运算单元，这样就节省了时间</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VIM"><figure class="iseeu highlight /vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果把时间分成<span class="number">3</span>部分来运算</span><br><span class="line">abcabcabc  不用流水线</span><br><span class="line"><span class="keyword">abc</span></span><br><span class="line"> <span class="keyword">abc</span>      用流水线</span><br><span class="line">  <span class="keyword">abc</span></span><br></pre></td></tr></table></figure></div><p>可以看出使用流水线后时间明显缩短</p><p>但是流水线也有一些问题。</p><ol><li>不能无限划分，随着划分的增多价格问题也越来越严重，性能提升却不大。甚至无限划分的时候，时间反而会变成无穷大（因为寄存器上时间过多，永远也执行不了指令）。</li><li>不一致的划分，因为流水线的时钟频率是根据耗时最长的那一阶段来确定的，所以如果划分不一致，就会导致最长的那段时间增大。正因如此，cpu一般把取指和PC这两个阶段当做一个阶段在最开始执行。</li><li>数据相关。 程序中上一条指令和下一条指令很可能有关联[例]<br>[例]: movq rax rbx movq rbx rcx</li><li>控制相关。 主要是条件跳转指令，因为一次输入了多条指令，所以很可能前面的判断没有完成的时候条件判断语句后面的指令已经开始计算了，这时候如果条件跳转指令跳转到了另一个地方，那前面开始计算的部分全部要清空，然后重新载入流水线。这样就会极大的影响效率。</li></ol><p>解决办法：</p><p>对于数据相关可以中间插入一个空命令例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a阶段只有命令的传入，并没有涉及到数据的传入,假设第一条和第二条有冲突</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br><span class="line">  空</span><br><span class="line">    <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br><span class="line">      <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  c</span><br></pre></td></tr></table></figure></div><p>但是这样还是会导致效率的降低。</p><p>一个更好的办法是在cpu内部对命令进行重排，但是又不影响运行逻辑。</p><p>对于控制相关可以使用数据传输指令，但是数据传输指令也具有局限性。</p><p>还可以通过分支预测的方法。如果是第一次进入分支，直接顺序传入指令，如果不是第一次，可以传入上一次分支运行时的指令。这样对循环具有优化作用。</p><p>此外在编译器层面，可以提前预测那种可能性比较大。然后把可能性大的部分放在分支语句的后面。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;cpu运算可以简化成两大块，运算单元和寄存器。大致过程是先从寄存器中取值然后放入运算单元中运算完成之后又放入寄存器中。大致过程可分为六个部分&lt;/p&gt;&lt;
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>linux目录操作</title>
    <link href="http://xinhecuican.github.io/post/61312.html"/>
    <id>http://xinhecuican.github.io/post/61312.html</id>
    <published>2020-04-05T11:24:00.000Z</published>
    <updated>2020-04-13T08:57:02.026Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 13 2020 16:57:02 GMT+0800 (中国标准时间) --><h3 id="目录名和工作目录"><a href="#目录名和工作目录" class="headerlink" title="目录名和工作目录"></a>目录名和工作目录</h3><p>斜杠表示根目录，如果最后一个名称代表的是文件名。当然，这个文件名也可以是一个目录。</p><p>工作目录又叫当前目录，也是进行操作的根目录（但不是系统的根目录），如果命令后面直接输入一个文件名，那么就是代表这个目录在工作目录中，系统也只会在当前目录中搜寻。</p><h3 id="绝对目录和相对目录"><a href="#绝对目录和相对目录" class="headerlink" title="绝对目录和相对目录"></a>绝对目录和相对目录</h3><p>绝对目录就是从根目录开始。在Linux系统中，根目录是home（这个根目录是当前用户的根目录）目录。</p><p>相对目录就是从工作目录（当前目录）开始。大多数时候我们输入一个文件名其实都是输入相对目录，我们也可以输入绝对目录，但那样过于麻烦。</p><h3 id="路径名缩写"><a href="#路径名缩写" class="headerlink" title="路径名缩写"></a>路径名缩写</h3><p><strong>第一个</strong>： ..（两个点号）。这个符号的含义是父目录，也就是上级目录。用..可以回到上级目录然后在进入子目录</p><p>例：现在绝对目录是 /home/abcd/ceshi，如果我想进入abcd的gongzuoqu目录，那么输入cd ../gongzuoqu即可。这是从左向右读的， ..代表进入父目录，然后再进入父目录中的工作区目录。</p><p><strong>第二个</strong>： .(一个点号）。代表的是当前目录，注意<strong>任何不以/开头的路径名都被认为相对于工作目录</strong>。所以大部分情况下直接输入文件名即可，但是在某些情况下必须输入完整的目录，因此这个时候就需要.代表当前目录便于输入。</p><p>unix只能运行它能找到的程序，也就是在path环境变量中的路径。但是如果我们输入绝对路径的话，程序也能运行，因此这里我们就可以简单的用 . 来代替长长的绝对路径名。</p><p>如果我们想运行new程序，而这个程序不在搜索路径中，那么可以用 ./new来运行它</p><p>一个点号和两个点号都是缩写，所以其实我们运用点号时都是输入<strong>绝对路径名</strong></p><p><strong>第三个</strong> ~(波浪号）。 用这个符号代表home目录（这里的home是系统的根，也就是没有目录包含它）。</p><h3 id="cd-pwd-在目录树中移动"><a href="#cd-pwd-在目录树中移动" class="headerlink" title="cd pwd 在目录树中移动"></a>cd pwd 在目录树中移动</h3><p>pwd命令是显示当前的绝对目录</p><p>cd 命令</p><p>语法： cd [-LP] [directory | - ]</p><p>其中dircetory是你想切换到的目录的名称。</p><p>如果只输入cd，那么会进入home目录下。如果输入cd -， 那么将会进入前一个目录，与cd ..命令效果相同。</p><p>如果使用绝对路径名，那么第一个符号是/。</p><p>例如 cd /home/abcd/gongzuoqu</p><p>如果使用相对路径名，那么第一个就没有/</p><p>例如 cd gongzuoqu/temp</p><h3 id="mkdir-rmdir新建目录和移除目录"><a href="#mkdir-rmdir新建目录和移除目录" class="headerlink" title="mkdir rmdir新建目录和移除目录"></a>mkdir rmdir新建目录和移除目录</h3><p>语法： mkdir [-P] dictory…</p><p>首先，可以使用字母，数字和没有特殊含义的标点符号作为文件名。</p><p>创建目录要遵循两条规则。第一条，不能在一个目录下创建两个同名的目录。第二条，默认情况下，如果父目录不存在，那么就无法创建目录。可以使用-p选项忽略第二条规则。</p><p>语法： redir [-p] directory …</p><p>这里要注意只能移除空的目录。如果想要移除非空的目录，可以使用rm程序</p><p>如果想一次性移除一串目录，那么可以使用-p选项。但是有一个不是空的就不行（除了在这条链上的目录外）</p><p>其次，不能移除根目录和工作目录之间的任何程序。也就是说就算是使用了绝对地址，如果它在工作目录外部，那么也无法移除它。</p><h3 id="mv-移动或重命名目录"><a href="#mv-移动或重命名目录" class="headerlink" title="mv 移动或重命名目录"></a>mv 移动或重命名目录</h3><p>语法： mv directory target</p><p>target如果是一个路径，那么一定是移动目录，如果是名字，那么要看情况。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HASKELL"><figure class="iseeu highlight /haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home/harley/<span class="class"><span class="keyword">data</span></span></span><br><span class="line">/home/harley/storge</span><br><span class="line"></span><br><span class="line"><span class="title">mv</span> <span class="class"><span class="keyword">data</span> storage</span></span><br><span class="line"></span><br><span class="line">现在的位置： /home/harley/storge/<span class="class"><span class="keyword">data</span></span></span><br></pre></td></tr></table></figure></div><p>也就是说，如果该路径下没有这个名字的目录，那么就会重命名，但是如果有这个名字的目录，那么就会移动到这个目录下。</p><h3 id="pushd-popd-dirs-使用目录栈"><a href="#pushd-popd-dirs-使用目录栈" class="headerlink" title="pushd,popd,dirs 使用目录栈"></a>pushd,popd,dirs 使用目录栈</h3><p>语法： pushd [directory | +n]</p><p>pop [+n]</p><p>dirs [-c] [-l] [-v]</p><p>push是将目录的名称压入栈中，pop是弹出栈中，dirs是显示栈的内容，n是标识符</p><table><thead><tr><th>命令</th><th>动作</th></tr></thead><tbody><tr><td>dirs</td><td>显示名称，home显示为~</td></tr><tr><td>dirs -l</td><td>home显示为完整路径</td></tr><tr><td>dirs -v</td><td>每行一个显示名称，并有标识符</td></tr><tr><td>pushd directory</td><td>将其压入栈中</td></tr><tr><td>push +n</td><td>把n移到栈顶</td></tr><tr><td>popd +n</td><td>把n移除</td></tr><tr><td>dirs -c</td><td>除当前目录外，移除所有目录</td></tr></tbody></table><p>在任何时候，栈顶都是存放当前工作目录的名称。每当改变工作目录时，栈顶元素也会随之改变。</p><p>如果我们使用了pushd命令，这时我们也会进入这个目录，同时只能进入自己的下级目录。</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>语法： ls [aCdFglrRs1] [name…]</p><p>作用，列举该目录下的文件名称。</p><p>参数：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-C 横的列举文件</span></span><br><span class="line"><span class="deletion">-1 竖的列举文件 可以与wc -l组成管道</span></span><br><span class="line"><span class="deletion">-r 按字母表相反顺序进行排序。</span></span><br><span class="line"><span class="deletion">-R 递归。也就是列举完这一层继续列举下一层。如果这个很长的话，可以用less程序</span></span><br><span class="line"><span class="deletion">-F 检查文件类型，会增加几种标识，如下表所示</span></span><br><span class="line"><span class="deletion">--color 使用不同颜色来显示不同类型文件</span></span><br><span class="line"><span class="deletion">-l 显示长列表</span></span><br><span class="line"><span class="deletion">-u 显示访问时间</span></span><br><span class="line"><span class="deletion">-r reverse 从旧的到新的</span></span><br><span class="line"><span class="deletion">-h 自动显示大小</span></span><br><span class="line"><span class="deletion">-d 显示目录本身的信息。</span></span><br><span class="line"><span class="deletion">-a 显示隐藏文件</span></span><br></pre></td></tr></table></figure></div><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>空</td><td>非可执行文件</td></tr><tr><td>*</td><td>可执行文件</td></tr><tr><td>/</td><td>目录</td></tr><tr><td>@</td><td>符号链接</td></tr><tr><td>竖线</td><td>命名管道 /FIFO</td></tr></tbody></table><h4 id="hs-du-df-quota-掌握磁盘空间使用情况"><a href="#hs-du-df-quota-掌握磁盘空间使用情况" class="headerlink" title="-hs du -df -quota 掌握磁盘空间使用情况"></a>-hs du -df -quota 掌握磁盘空间使用情况</h4><p>-s 前面以字节为单位输出文件的大小</p><p>-sh 自动选择合适的单位</p><p>du（disk usage) 显示文件的大小，这是一个程序</p><p>语法： du [-achs] [name…]</p><p>-h 显示单位</p><p>如果不指定名称，du会递归搜索整个目录树</p><p>-s 显示总和</p><p>-c 是先输出每个文件的大小，最后输出总量</p><p>df 显示磁盘可用空间</p><p>quota 显示配额</p><h3 id="file-检查文件类型"><a href="#file-检查文件类型" class="headerlink" title="file 检查文件类型"></a>file 检查文件类型</h3><p>file的使用相当直接，只需要file + 路径就可以检查那个路径下的文件类型，但是比ls显示的更为详细。</p><p>可能显示下列几种类型：</p><ul><li>ELF:可执行和链接模式</li><li>32-bit： 字长</li><li>LSB： 采用最低有效字节编译（小端序）</li><li>executable： 可执行文件</li><li>Intel 80386： 内部文件格式版本</li><li>GNU/linux2.6.9 操作系统和内核版本</li><li>dynamically linked 使用共享库</li><li>stripped 将符号表移除的可执行文件</li></ul><h3 id="块和分配单元"><a href="#块和分配单元" class="headerlink" title="块和分配单元"></a>块和分配单元</h3><p>在文件系统中，空间以固定大小进行分配，我们把固定大小的组块叫做块。块的大小在不同系统中不同。块的大小有512,1,2,4kb等。典型的linux系统是1kb。</p><p>此时我们只是说在文件系统中的分配方式。但是写入到磁盘中时出于效率的考虑，磁盘中也有特定的单元叫做分配单元或者簇。例如，分配单元为8kb代表即使只有1btye的数据系统也会自动分配8kb</p><h3 id="使用通配符进行通配"><a href="#使用通配符进行通配" class="headerlink" title="使用通配符进行通配"></a>使用通配符进行通配</h3><p>使用通配符可以指定特定的文件名，类似于正则表达式。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>匹配任何0个或多个字符组成的序列</td></tr><tr><td>？</td><td>匹配任何单个字符</td></tr><tr><td>[list]</td><td>匹配list中任意字符</td></tr><tr><td>[^list]</td><td>匹配不再list中任意字符</td></tr><tr><td>{string1竖线string2}</td><td>匹配任意一个字符串</td></tr></tbody></table><p>其实就是一个简化版的正则表达式。例如： ls h*表示显示所有以h为开头的文件或目录</p><p>此外，还可以使用一些预定义字符类，例如[[:lower:]]等</p><h3 id="显示目录树"><a href="#显示目录树" class="headerlink" title="显示目录树"></a>显示目录树</h3><p>语法： tree [-adfFilrst] [-L level] [directory…]</p><p>level是树的深度</p><p>作用：绘制文件系统中任意部分的图形（真的就是一个目录图表，可以自己试一下）。</p><p>选项：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-a 显示所有文件，包括点文件</span></span><br><span class="line"><span class="deletion">-s 显示文件大小</span></span><br><span class="line"><span class="deletion">-F 显示标识文件的标志</span></span><br><span class="line"><span class="deletion">-r 以相反顺序输出</span></span><br><span class="line"><span class="deletion">-t 按修改时间顺序输出</span></span><br><span class="line"><span class="deletion">-d 只显示目录</span></span><br><span class="line"><span class="deletion">-i 省略缩进，这种模式只会输出一条条路径，但是不会生成一个图标</span></span><br><span class="line"><span class="deletion">-L 限制树的深度。后面的数字就是树的深度</span></span><br></pre></td></tr></table></figure></div><p>个人意见可以重定向到一个文件中然后再文件中查找。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 13 2020 16:57:02 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;目录名和工作目录&quot;&gt;&lt;a href=&quot;#目录名和工作目录&quot; class=&quot;headerlink&quot; title=&quot;目录名和工作目录&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>gdb</title>
    <link href="http://xinhecuican.github.io/post/63002.html"/>
    <id>http://xinhecuican.github.io/post/63002.html</id>
    <published>2020-04-03T08:44:00.000Z</published>
    <updated>2020-04-23T13:34:08.308Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 23 2020 21:50:58 GMT+0800 (中国标准时间) --><h3 id="进入gdb"><a href="#进入gdb" class="headerlink" title="进入gdb"></a>进入gdb</h3><p>首先gdb一般都是用来调试c或c++的，gdb是要运行可执行文件的，所以先要进行编译。具体命令如下：</p><p><code>gcc -g 源文件.c -o 输出的目标文件</code></p><p>-g是用来插入编译所需的信息, -o是用来生成可执行文件</p><p>生成的时候会产生一大堆信息，如果不想看的话可以使用 -q 选项，如果想永久设定可以在bashrc中设置别名 alias gdb = ‘gdb -q’</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>start</td><td>进入main函数</td><td>无</td></tr><tr><td>run</td><td>重新开始运行 run-text 加载文本文件 run-bin加载二进制文件</td><td>r</td></tr><tr><td>next</td><td>执行一行程序，不进入函数，直接把函数执行完</td><td>n</td></tr><tr><td>step</td><td>执行一行程序，进入函数</td><td>s</td></tr><tr><td>list</td><td>查看程序，list+函数名查看函数</td><td>l</td></tr><tr><td>continue</td><td>继续执行到断点处</td><td>c</td></tr><tr><td>quit</td><td>终止程序</td><td>q</td></tr><tr><td>set 参数</td><td>设置断点</td><td>无</td></tr><tr><td>nexti</td><td>运行一条机器指令</td><td>ni</td></tr><tr><td>jump + 标号</td><td>跳转到某一位置执行</td><td>j</td></tr><tr><td>run &lt; input.txt</td><td>重定向</td><td>无</td></tr></tbody></table><p>注意jump命令跳转后仍是一直执行，所以要在某一位置手动设置断点</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>return</td><td>退出函数且不执行后面代码，也可以return+参数指定返回值</td><td>无</td></tr><tr><td>finish</td><td>退出函数且执行完剩下的代码</td><td>无</td></tr><tr><td>call/print</td><td>直接调用函数执行</td><td>无</td></tr><tr><td>info files</td><td>显示所有程序及位置</td><td>无</td></tr><tr><td>info functions（regex）</td><td>显示函数（可加正则表达式）</td><td>无</td></tr><tr><td>set step-mode on</td><td>进入不带调试信息的函数（如printf）</td><td>无</td></tr><tr><td>set args val1 val2…</td><td>设置函数参数</td><td>无</td></tr></tbody></table><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>break</td><td>设置断点</td><td>b</td></tr><tr><td>tbreak</td><td>设置临时断点（只能使用一次）</td><td>tb</td></tr><tr><td>info breakpoints</td><td>查看当前所有断点</td><td>i b</td></tr><tr><td>enable/disable breakpoints</td><td>启用/禁用断点</td><td>无</td></tr><tr><td>clear+编号</td><td>删除断点</td><td>无</td></tr><tr><td>** break参数 **</td><td></td><td><strong>例</strong></td></tr><tr><td>*+地址</td><td>在某一地址设置断点</td><td>b *0x400522</td></tr><tr><td>函数名</td><td>在某一函数进入前停止</td><td>b main</td></tr><tr><td>行号</td><td>在某一行号处设置断点</td><td>b 7</td></tr><tr><td>+offset/-offset</td><td>在当前行前后offset行设置</td><td>无</td></tr><tr><td>break … if &lt; condition&gt;</td><td>只有在条件满足时，断点才会被触发</td><td>b 10 if i==101</td></tr><tr><td>ignore bnum count</td><td>忽略bnum次编号为count的断点</td><td>ignore 1 5</td></tr><tr><td><strong>观察点</strong></td><td>观察变量值的变化</td><td></td></tr><tr><td>watch</td><td>当一个值发生变化时，程序会停下来，相当于是写观察点</td><td>无</td></tr><tr><td>reatch</td><td>当一个值发生读行为时，程序停止</td><td>无</td></tr><tr><td>awatch</td><td>每次读取或改变a的值都会让程序停下来</td><td>aw</td></tr><tr><td>info watch</td><td>显示观察点</td><td>i watch</td></tr><tr><td><strong>catchpoint</strong></td><td>当程序异常终止或加载链接库时停止运行，这里不展开</td><td></td></tr></tbody></table><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">）设置catchpoints:</span></span><br><span class="line"><span class="attr">a. catch event:</span> <span class="string">当事件event发生的时候，程序停止运行，这里event的取值有：</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">）throw:</span> <span class="string">C++抛出异常</span></span><br><span class="line"><span class="number">2</span><span class="string">）catch:</span> <span class="string">C++捕捉到异常</span></span><br><span class="line"><span class="number">3</span><span class="string">）exec:</span> <span class="string">exec被调用</span></span><br><span class="line"><span class="number">4</span><span class="string">）fork:</span> <span class="string">fork被调用</span></span><br><span class="line"><span class="number">5</span><span class="string">）vfork:</span> <span class="string">vfork被调用</span></span><br><span class="line"><span class="number">6</span><span class="string">）load:</span> <span class="string">加载动态库</span></span><br><span class="line"><span class="number">7</span><span class="string">）load</span> <span class="attr">libname:</span> <span class="string">加载名为libname的动态库</span></span><br><span class="line"><span class="number">8</span><span class="string">）unload:</span> <span class="string">卸载动态库</span></span><br><span class="line"><span class="number">9</span><span class="string">）unload</span> <span class="attr">libname:</span> <span class="string">卸载名为libname的动态库</span></span><br><span class="line"><span class="number">10</span><span class="string">）syscall</span> <span class="string">[args]:</span> <span class="string">调用系统调用，args可以指定系统调用号，或者系统名称</span></span><br><span class="line"><span class="attr">b. tcatch event:</span> <span class="string">设置只停一次的catchpoint，第一次生效后，该catchpoint被自动删除</span></span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/kevinx_xu/article/details/36261571" target="_blank" rel="external nofollow noopener noreferrer">这一段从网上扒的</a></p><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>disassemble 如果不带参数，会自动显示后面若干条汇编指令。简写disas</p><p>如果带一个参数，可以带函数名也可以带某一个地址，都是显示那个地址处的函数的汇编代码。</p><p>如果带两个参数，也就是起始地址和终止地址，那么就会显示两个之间的代码</p><h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>reverse-continue</td><td>反向运行程序知道遇到一个能使程序中断的事件（比如断点，观察点，异常）</td><td>无</td></tr><tr><td>reverse-step</td><td>返回到上一次执行的源代码行</td><td>无</td></tr><tr><td>reverse-stepi</td><td>返回上一条机器指令</td><td>无</td></tr><tr><td>reverse-next</td><td>返回上一次执行的源代码行，但不执行函数</td><td>无</td></tr><tr><td>reverse-nexti</td><td>反向运行到上一条机器指令，除非这条指令用来返回一个函数调用、整个函数将会被反向执行。</td><td>无</td></tr><tr><td>reverse-finish</td><td>反向运行程序回到调用当前函数的地方</td><td>无</td></tr></tbody></table><p>注意，想使用回退功能先要用record命令对指令进行录制</p><h3 id="调试带参数的程序"><a href="#调试带参数的程序" class="headerlink" title="调试带参数的程序"></a>调试带参数的程序</h3><p>方法1： gdb启动时候加参数</p><p>gdb –args ./main aaaa bb</p><p>方法2：</p><p>gdb main //先启动起来</p><p>(gdb)run aaaa bb</p><p>方法3</p><p>gdb main //先启动起来</p><p>(gdb)set args aaaa bb</p><p>(gdb)run //或者start</p><p>(gdb)show args</p><p><a href="https://blog.csdn.net/mw_nice/java/article/details/100991341" target="_blank" rel="external nofollow noopener noreferrer">这部分照搬的</a></p><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><table><thead><tr><th>名称</th><th>用途</th><th>简写</th></tr></thead><tbody><tr><td>** 函数栈帧打印**</td><td></td><td></td></tr><tr><td>i frame</td><td>输出了当前函数堆栈帧的地址，指令寄存器的值，局部变量地址及值等信息</td><td>无</td></tr><tr><td>frame n</td><td>打印第n层的函数栈帧</td><td>无</td></tr><tr><td>up/down n</td><td>向上/向下切换栈帧</td><td>无</td></tr><tr><td>print + 数组名</td><td>打印数组内容</td><td>p</td></tr><tr><td>set print array-indexes on</td><td>打印数组时打印下标</td><td>无</td></tr><tr><td>info locals</td><td>打印局部变量值</td><td>i locals</td></tr><tr><td>backtrace full n</td><td>由内向外显示n个栈帧的值</td><td>bt</td></tr><tr><td>set print pretty on</td><td>打印结构体</td><td>无</td></tr><tr><td>p *array@len</td><td>array数组名 len 数据长度</td><td>无</td></tr><tr><td>p $寄存器名</td><td>查看某个寄存器的值</td><td>无</td></tr><tr><td>info register</td><td>查看所有寄存器</td><td>i reg</td></tr></tbody></table><h4 id="x-显示内存中内容命令"><a href="#x-显示内存中内容命令" class="headerlink" title="x 显示内存中内容命令"></a>x 显示内存中内容命令</h4><p>格式: x /nfu<addr></addr></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">n表示要显示的内存单元的个数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">f表示显示方式,</span> <span class="string">可取如下值</span></span><br><span class="line"><span class="attr">x</span> <span class="string">按十六进制格式显示变量。</span></span><br><span class="line"><span class="attr">d</span> <span class="string">按十进制格式显示变量。</span></span><br><span class="line"><span class="attr">u</span> <span class="string">按十进制格式显示无符号整型。</span></span><br><span class="line"><span class="attr">o</span> <span class="string">按八进制格式显示变量。</span></span><br><span class="line"><span class="attr">t</span> <span class="string">按二进制格式显示变量。</span></span><br><span class="line"><span class="attr">a</span> <span class="string">按十六进制格式显示变量。</span></span><br><span class="line"><span class="attr">i</span> <span class="string">指令地址格式</span></span><br><span class="line"><span class="attr">c</span> <span class="string">按字符格式显示变量。</span></span><br><span class="line"><span class="attr">f</span> <span class="string">按浮点数格式显示变量。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">u表示一个地址单元的长度</span></span><br><span class="line"><span class="attr">b表示单字节，</span></span><br><span class="line"><span class="attr">h表示双字节，</span></span><br><span class="line"><span class="attr">w表示四字节，</span></span><br><span class="line"><span class="attr">g表示八字节</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 23 2020 21:50:58 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;进入gdb&quot;&gt;&lt;a href=&quot;#进入gdb&quot; class=&quot;headerlink&quot; title=&quot;进入gdb&quot;&gt;&lt;/a&gt;进入gdb&lt;/h3
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>unix文件系统</title>
    <link href="http://xinhecuican.github.io/post/35532.html"/>
    <id>http://xinhecuican.github.io/post/35532.html</id>
    <published>2020-03-30T12:50:00.000Z</published>
    <updated>2020-04-07T08:32:34.647Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><p>文件就是任意源，有一个名称，可以从中写入读出数据。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>unix中有三种文件类型，普通文件，目录和伪文件。</p><p>普通文件是大多数时候所使用的文件，包括文本文件和二进制文件。例如，纯文本，shell脚本，源程序，配置文件，html文件等。</p><p>目录不同之处在于他们用来组织，访问其他文件。从概念上讲，目录包含其他文件。这个文件其实类似于windows下的文件夹。</p><p>伪文件有时候也称为设备文件。这种文件是物理设备的内部表示。例如键盘，显示器，打印机等，这些设备都可以当成一个文件进行访问。</p><p>有一种特殊的伪文件时proc文件，这种文件可以访问linux内核中的信息，设置可以修改Linux内核中的数据。</p><h3 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h3><p>特殊文件就是表示物理设备的伪文件。这些文件都被存放于/dev下</p><p>一些常见的设备如下</p><table><thead><tr><th>位置</th><th>硬件</th></tr></thead><tbody><tr><td>/dev/sda</td><td>SCSI硬盘</td></tr><tr><td>/dev/sda</td><td>第一分区</td></tr><tr><td>/dev/hda</td><td>硬盘</td></tr><tr><td>/dev/Ip0</td><td>打印机</td></tr><tr><td>/dev/tty</td><td>当前终端</td></tr><tr><td>/dev/random</td><td>随机数生成器</td></tr><tr><td>/dev/null</td><td>放弃输入 输入不返回内容</td></tr><tr><td>/dev/zero</td><td>放弃送站，输入返回0</td></tr></tbody></table><p>写入到/dev/null 或/dev/zero 中的任何文件都会被抛弃，因此这些文件又叫做位桶。</p><p>如果想读取随即数，只需要读取/dev/random。</p><h3 id="mkfifo-命名管道"><a href="#mkfifo-命名管道" class="headerlink" title="mkfifo 命名管道"></a>mkfifo 命名管道</h3><p>在前面我们已经介绍过了管道，那种管道是匿名管道，就是只有当程序运行的时候它才被创建。</p><p>命名管道与匿名管道的显著区别就是必须显式的创建管道，其次，当命令结束之后，管道并不会消失，而是会继续存在，除非使用命令删除他们。</p><p>通常将命名管道称为FIFO，实际上就是队列。</p><p>语法： mkfifo [-m mode] pipe</p><p>其中，mode是chmod程序使用的一种文件类型，pipe是希望创建的管道名称。</p><p>用途：经常被用来两个进程中的通信。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfifo fifotest</span><br><span class="line"><span class="keyword">grep</span> bash <span class="regexp">/etc/</span>passwd &gt; fifotest <span class="comment">//第一个窗口上的命令</span></span><br><span class="line">wc -l &lt; fifotest <span class="comment">//这是第二个窗口上的命令</span></span><br></pre></td></tr></table></figure></div><p>如果想要去除管道，只需要rm + 管道名即可。</p><h3 id="proc文件"><a href="#proc文件" class="headerlink" title="proc文件"></a>proc文件</h3><p>proc文件时那些提供一些简单途径来检查多种类型的系统信息的伪文件。proc文件可以直接从内核中提取数据。</p><p>所有的proc文件都存放在/proc目录下，在这个目录中，可以发现每一个进程对应一个子目录。</p><p>如果想提取这些进程的信息，可以使用cat命令去找到当前有那些进程正在执行，如果进入这些目录，还可以知道这些进程的详细状态。</p><p>有一个特殊的proc文件，/proc/kcore，这个文件表示计算机的实际物理内存。可以使用ls -l选项查看这个文件的大小。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="根目录-子目录"><a href="#根目录-子目录" class="headerlink" title="根目录 子目录"></a>根目录 子目录</h4><p>目录是一个树形结构，对于每一层一定会有一个根，而用root过于麻烦，所以一般用/表示根目录。</p><p>例如 ls / 表示列举根目录下的所有文件。这样 ls /bin代表列bin目录下的所有文件。但是实际上如果列举根目录下的文件是不需要加/的，直接加上名字就好了，如果想访问根目录下子目录中的文件，就需要在子目录和子目录文件之间加一个/</p><p>例如： ls homework/bomb</p><h4 id="mount-umount挂载文件系统"><a href="#mount-umount挂载文件系统" class="headerlink" title="mount umount挂载文件系统"></a>mount umount挂载文件系统</h4><p>在系统中，有许多设备，也就有许多个文件系统。但是如果都是完全分隔的话，没办法在不同文件系统之间进行访问，所以一定有一颗主树，然后其他树挂载在主树上，这一个个文件系统其实类似于windows下的磁盘分区。</p><p>当小的文件系统连接上主树时，我们称为挂载。小文件系统附加到主树上的目录叫做挂载点</p><p>一般来说，系统已经自动挂载好了子树，但是有时候需要我们手动挂载子树（例如插入u盘时，当然现在也是自动挂载了）。这时需要mount程序。这里不再展开</p><h4 id="漫游根目录"><a href="#漫游根目录" class="headerlink" title="漫游根目录"></a>漫游根目录</h4><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>/</td><td>根目录</td></tr><tr><td>/bin</td><td>基本程序</td></tr><tr><td>/boot</td><td>启动系统时所需要的文件</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/dev</td><td>设备文件</td></tr><tr><td>/home</td><td>用户home目录</td></tr><tr><td>/lib</td><td>基本共享库，内核模块</td></tr><tr><td>/lost+found</td><td>由fsck恢复的受损文件</td></tr><tr><td>/media</td><td>可移动介质的挂载点</td></tr><tr><td>/mnt</td><td>不能挂载在其他位置的挂载点</td></tr><tr><td>/opt</td><td>第三方应用程序</td></tr><tr><td>/proc</td><td></td></tr><tr><td>/root</td><td>超级用户home目录</td></tr><tr><td>/srv</td><td>本地系统提供服务的数据</td></tr><tr><td>/tmp</td><td>临时文件</td></tr><tr><td>/usr</td><td>静态数据使用的文件系统</td></tr><tr><td>/var</td><td>可变数据使用的文件系统</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;文件就是任意源，有一个名称，可以从中写入读出数据。&lt;/p&gt;&lt;h3 id=&quot;文件类型&quot;&gt;&lt;a href=&quot;#文件类型&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>线索二叉树</title>
    <link href="http://xinhecuican.github.io/post/43817.html"/>
    <id>http://xinhecuican.github.io/post/43817.html</id>
    <published>2020-03-29T06:54:00.000Z</published>
    <updated>2020-04-07T08:32:34.885Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --><p>普通的二叉树中空节点数量很多，例如一个有2n条分支的二叉树，其中节点数只有n-1个，空节点有n+1个，因此就要想办法把这些没用到的节点利用起来。</p><p>可以用原来的空节点去存放指针，指向其他节点，这中指针叫做线索。</p><p>记ptr指向二叉链表中的一个结点，以下是建立线索的规则：</p><p>（1）如果ptr-&gt;lchild为空，则存放指向中序遍历序列中该结点的前驱结点。这个结点称为ptr的中序前驱；</p><p>（2）如果ptr-&gt;rchild为空，则存放指向中序遍历序列中该结点的后继结点。这个结点称为ptr的中序后继；</p><p>显然，在决定lchild是指向左孩子还是前驱，rchild是指向右孩子还是后继，需要一个区分标志的。因此，我们在每个结点再增设两个标志域ltag和rtag，注意ltag和rtag只是区分0或1数字的布尔型变量，其占用内存空间要小于像lchild和rchild的指针变量。结点结构如下所示。<br><img src="/images/26548237_13584034551s55.jpg" alt></p><p>ltag = 0 表示指向左孩子，= 1 表示指向前驱</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉线索存储结构定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;Link, Thread&#125;PointerTag;    <span class="comment">//Link = 0表示指向左右孩子指针；Thread = 1表示指向前驱或后继的线索</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="keyword">char</span> data;                                      <span class="comment">//结点数据</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>                <span class="comment">//左右孩子指针</span></span><br><span class="line">       PointerTag  Ltag;                               <span class="comment">//左右标志</span></span><br><span class="line">       PointerTag  rtal;</span><br><span class="line">&#125;BitNode, *BiTree;</span><br></pre></td></tr></table></figure></div><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以，线索化的过程就是在遍历的过程中修改空指针的过程。<br></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> BiTree pre = NULL;                 <span class="comment">//全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"><span class="comment">//中序遍历进行中序线索化</span></span><br><span class="line">void InThreading(BiTree p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>lchild);          <span class="comment">//递归左子树线索化</span></span><br><span class="line">                <span class="comment">//===</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(!p-&gt;</span>lchild)           <span class="comment">//没有左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>ltag = Thread;    <span class="comment">//前驱线索</span></span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>lchild = pre; <span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(!pre-&gt;</span>rchild)     <span class="comment">//没有右孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rtag = Thread;  <span class="comment">//后继线索</span></span><br><span class="line">            <span class="function"><span class="title">pre</span>-&gt;</span>rchild = p; <span class="comment">//前驱右孩子指针指向后继(当前结点p)</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">                <span class="comment">//===</span></span><br><span class="line">        I<span class="function"><span class="title">nThreading</span>(p-&gt;</span>rchild);      <span class="comment">//递归右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>上述代码除了//===之间的代码以外，和二叉树中序遍历的递归代码机会完全一样。只不过将打印结点的功能改成了线索化的功能。<p></p><p>因为此时p结点的后继还没有访问到，因此只能对它的前驱结点pre的右指针rchild做判断，if(!pre-&gt;rchild)表示如果为空，则p就是pre的后继，于是pre-&gt;rchild = p，并且设置pre-&gt;rtag = Thread，完成后继结点的线索化。</p><p>前驱指的是某种遍历顺序中在你前面的节点，而后继就是在你后面的节点，这也是为什么pre = p 要写在InThreading(p-&gt;lchild)后面的原因，中序遍历是先做子树的，那么它只能是右子树的前驱而不能是左子树的前驱</p><p>遍历代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点。</span></span><br><span class="line"><span class="comment">//中序遍历二叉线索树表示二叉树t</span></span><br><span class="line">int InOrderThraverse_Thr(BiTree t)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="function"><span class="title">p</span> = t-&gt;</span>lchild;                               <span class="comment">//p指向根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != t)                               <span class="comment">//空树或遍历结束时p == t</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span>ltag == Link)                       <span class="comment">//当ltag = 0时循环到中序序列的第一个结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">printf</span>("%c ", p-&gt;</span><span class="keyword">data</span>);                      <span class="comment">//显示结点数据，可以更改为其他对结点的操作</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">rtag</span> == Thread &amp;&amp; p-&gt;</span>rchild != t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;</span><br><span class="line">            <span class="function"><span class="title">printf</span>("%c ", p-&gt;</span><span class="keyword">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="title">p</span> = p-&gt;</span>rchild;                         <span class="comment">//p进入其右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 12 2020 08:17:32 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;普通的二叉树中空节点数量很多，例如一个有2n条分支的二叉树，其中节点数只有n-1个，空节点有n+1个，因此就要想办法把这些没用到的节点利用起来。&lt;/p
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树链表构建和应用</title>
    <link href="http://xinhecuican.github.io/post/11799.html"/>
    <id>http://xinhecuican.github.io/post/11799.html</id>
    <published>2020-03-29T01:23:00.000Z</published>
    <updated>2020-04-07T08:32:34.670Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>中序</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void inorder(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> != NULL)</span><br><span class="line">    &#123; </span><br><span class="line">        inorder(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">T</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">        inorder(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>前序</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void preorder(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">T</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">        preorder(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        preorder(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>后序遍历同理。</p><p>这个算法是以当前节点为基点，先输出当前节点数值，然后再去输出左子树数值，然后再递归输出左子树数值知道NULL，才又递归输出右子树数值。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="二叉树构建"><a href="#二叉树构建" class="headerlink" title="二叉树构建"></a>二叉树构建</h4><p>如果我们只给出数值和构建顺序，是无法构建二叉树的。例如，给出三个数，然后给出构建顺序是123这样总共有5中构建方法。因此还要把空节点加上才可以构建。空节点的值为-1或@</p><p>前序遍历构建</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="R"><figure class="iseeu highlight /r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void create(binarytree *<span class="literal">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'@'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">T</span> = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">T</span> = new binarynode;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">T</span> == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">T</span>-&gt;data = c;</span><br><span class="line">        create(<span class="literal">T</span>-&gt;left);</span><br><span class="line">        create(<span class="literal">T</span>-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里是先构造当前节点，如果当前节点不是空节点，那么构造左节点和右节点。如果是，直接空节点返回。</p><h4 id="计算叶结点个数"><a href="#计算叶结点个数" class="headerlink" title="计算叶结点个数"></a>计算叶结点个数</h4><p>叶节点的特点就是左右子树都是空。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="COQ"><figure class="iseeu highlight /coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int calculate(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)//空树</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;<span class="built_in">left</span> == NULL &amp;&amp; T-&gt;<span class="built_in">right</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(T-&gt;<span class="built_in">left</span>) + calculate(T-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="计算节点个数"><a href="#计算节点个数" class="headerlink" title="计算节点个数"></a>计算节点个数</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="COQ"><figure class="iseeu highlight /coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int calulate(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + calculate(T-&gt;<span class="built_in">left</span>) + calculate(T-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="计算二叉树高度"><a href="#计算二叉树高度" class="headerlink" title="计算二叉树高度"></a>计算二叉树高度</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> counthigh(binarytree *<span class="built_in">T</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">T</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> m = counthigh(<span class="built_in">T</span>-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">n</span> = counthigh(<span class="built_in">T</span>-&gt;<span class="built_in">right</span>);</span><br><span class="line">        return m &gt; <span class="built_in">n</span> ? m+<span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>它的思想是比较左子树和右子树高度，然后再加上根的高度。</p><h4 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h4><p>按前序遍历的方法最好复制</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">binode* <span class="keyword">copy</span>(binarytree *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    binode *<span class="keyword">temp</span> = <span class="built_in">new</span> node;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">temp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">exit</span>(overflow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">temp</span>-&gt;data = T-&gt;data;</span><br><span class="line">    <span class="keyword">temp</span>-&gt;left = <span class="keyword">copy</span>(T-&gt;left);</span><br><span class="line">    <span class="keyword">temp</span>-&gt;right = <span class="keyword">copy</span>(T-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="非递归搜索二叉树"><a href="#非递归搜索二叉树" class="headerlink" title="非递归搜索二叉树"></a>非递归搜索二叉树</h3><p>非递归构造二叉树主要用到了栈来模拟递归过程。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> inorder(binode *T)</span><br><span class="line">&#123;</span><br><span class="line">    binode *p;</span><br><span class="line">    stack&lt;binode*&gt; s;<span class="comment">//如果不行就自己构建一个栈</span></span><br><span class="line">    s.<span class="keyword">push</span>(T);<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( p == s.gettop() &amp;&amp; p != <span class="keyword">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">push</span>(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="comment">/*因为是push左子树，所以最后先push进一个空然后才会退出循环</span></span><br><span class="line"><span class="comment">        所以要先把这个NULL去掉*/</span></span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p = s.gettop();</span><br><span class="line">            cout &lt;&lt; p-&gt;data;</span><br><span class="line">            s.<span class="keyword">pop</span>();<span class="comment">//去掉p节点</span></span><br><span class="line">            s.<span class="keyword">push</span>(p-&gt;right);</span><br><span class="line">            <span class="comment">/*如果p是叶结点，那么push右边也是NULL,内层循环不会执行，然后</span></span><br><span class="line"><span class="comment">            执行pop取点NULL，之后if中又会取出上一层节点继续找右子树*/</span></span><br><span class="line">            <span class="comment">//如果右子树中还有分支，那么会继续这个过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段程序的含义是先找左节点，然后把中间节点退出去，找右节点，在右节点中重复找左节点。</p><p><strong>前序遍历</strong>又稍有不同，因为前序遍历是先直接输出根节点，所以根节点就不需要存入栈中，实际栈中存入的是右节点。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(binode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;binode*&gt; s;</span><br><span class="line">    binode *p = T;</span><br><span class="line">    s.push(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;left;<span class="comment">//进入左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s.gettop();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码是先输出根，然后把右子树拖入栈中，进入左子树，如果左子树遍历完了，p-&gt;left == NULL,之后就到右子树那边去遍历。</p><p><strong>后序遍历</strong>更为麻烦，stack要用自己的，设置一个标志位确定现在是左子树还是右子树</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stacknode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    binode *ptr;</span><br><span class="line">    <span class="keyword">enum</span> tag&#123;L,R&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(binode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> s;</span><br><span class="line">    stacknode w;</span><br><span class="line">    binode *p = T;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            w.ptr = p;</span><br><span class="line">            w.tag = L;</span><br><span class="line">            push(s,w);</span><br><span class="line">            p = p-&gt;leftchild;</span><br><span class="line">        &#125;<span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">continue</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">continue</span> != <span class="number">0</span> &amp;&amp; !stackempty(s))</span><br><span class="line">        &#123;</span><br><span class="line">             pop(s,w);</span><br><span class="line">             p = w.ptr;</span><br><span class="line">             <span class="keyword">switch</span>(w.tag)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">case</span> L: w.tag = R;<span class="comment">//这时算作根节点，根节点为R那么下次就会输出</span></span><br><span class="line">                      push(s,w);</span><br><span class="line">                      <span class="keyword">continue</span> = <span class="number">0</span>;<span class="comment">//退出循环</span></span><br><span class="line">                      p = p-&gt;right;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> R: <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(p != <span class="literal">NULL</span> || !stackempty(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 12 2020 08:17:31 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;递归遍历&quot;&gt;&lt;a href=&quot;#递归遍历&quot; class=&quot;headerlink&quot; title=&quot;递归遍历&quot;&gt;&lt;/a&gt;递归遍历&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
