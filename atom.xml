<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinhecuican&#39;s Blog</title>
  
  <subtitle>浏览器网页搜索挺好用的，站内搜索说不定有惊喜哟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-05-18T12:01:44.506Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>星河璀璨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java 数组</title>
    <link href="http://xinhecuican.github.io/post/325cdbf2.html"/>
    <id>http://xinhecuican.github.io/post/325cdbf2.html</id>
    <published>2020-05-14T11:54:00.000Z</published>
    <updated>2020-05-18T12:01:44.506Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>可以这样声明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] scores<span class="comment">;</span></span><br><span class="line">String[] names<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>也可以这样声明</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int scores[]<span class="comment">;</span></span><br><span class="line">String names[]<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>二维更为古怪</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-attr">[]</span><span class="selector-tag">x</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-attr">[]</span><span class="selector-tag">x</span><span class="selector-attr">[]</span>;</span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">x</span><span class="selector-attr">[]</span><span class="selector-attr">[]</span>;</span><br></pre></td></tr></table></figure></div><p>这里注意一点，声明时不能往括号中加东西，会报错。例如：<code>int x[1];//报错</code></p><p>java中推荐吧括号放到前面，可能int[]也成了一个对象？</p><h2 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h2><p>创建数组对象语法和c++中创建动态数组类似。</p><p><code>int[] scores = new int[100];</code></p><p>上面这个代码首先要在堆中分配空间，然后把里面的数据初始化。</p><p>括号中的数字可以使常量，也可以是变量，甚至可以是0(表示里面没有数据).</p><h2 id="访问数组的元素和长度"><a href="#访问数组的元素和长度" class="headerlink" title="访问数组的元素和长度"></a>访问数组的元素和长度</h2><p>和c++一样，下标索引。如果越界，会抛出ArrayIndexOutOfBoundsException异常</p><p>所有数组都有length属性，表示数组的长度: <code>public final length</code>.</p><p>所以我们可以直接输出这一属性，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x<span class="literal">[]</span> = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="number">40</span>]</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.length); <span class="comment">//输出length</span></span><br></pre></td></tr></table></figure></div><p>如果是对象数组，那么数组中的元素时对象的引用，因此当我们不使用数组的时候最好把值赋null触发垃圾回收机制。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> sb = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">String</span> sbs[] = <span class="keyword">new</span> <span class="built_in">String</span>[](sb,<span class="keyword">null</span>);</span><br><span class="line">...</span><br><span class="line">sbs[<span class="number">0</span>] = <span class="keyword">null</span>;<span class="comment">//清除数组对象的引用</span></span><br><span class="line">sbs = <span class="keyword">null</span>;<span class="comment">//清除数组引用</span></span><br></pre></td></tr></table></figure></div><h2 id="多维数组和不规则数组"><a href="#多维数组和不规则数组" class="headerlink" title="多维数组和不规则数组"></a>多维数组和不规则数组</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[<span class="string"></span>][<span class="symbol"></span>] rooms = new String[<span class="string">2</span>][<span class="symbol"></span>];</span><br><span class="line">rooms[<span class="string">0</span>] = new String[]("Tom","Mike");</span><br><span class="line">rooms[<span class="string">1</span>] = new String[]("Mary");</span><br></pre></td></tr></table></figure></div><p>可以用不等长数组是因为每一行都是一个数组元素，都有自己的length变量</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;rooms.<span class="built_in">length</span>; <span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">0</span>; k&lt;rooms[<span class="built_in">i</span>].<span class="built_in">length</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(rooms[<span class="built_in">i</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>第一个循环的length是rooms引用多少个数组，rooms[]指的是每个数组的长度。</p><p>要注意只有最后一个括号可以不加数字，我的理解是只有最后一层才是真正的数组对象，才有length，同时，前面不确定就不知道要开多少个数组对象。</p><h2 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h2><p>在c++中数组是不能作为返回值的，因为c++中数组是一个指针，而又不能像其他指针一样确定它的大小。而在java中数组是一个对象，可以返回它的引用。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>平常我们想找某一个值都是通过遍历数组得到的，我们也可以用值通过某种映射关系得到在数组中的位置。这就是哈希表</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>%<span class="number">10</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个例子中value就是值，返回的是下标。但是这时如果超过十就会出现重复，这叫做哈希冲突。我们可以设计更复杂的映射来处理哈希冲突。</p><p>判断重复的条件是 object1.equals(boject2)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    private</span> Object value;</span><br><span class="line">    private <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(Object</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getValue()</span><br><span class="line">    &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">Node</span> <span class="title">getNext</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNext(<span class="keyword">Node</span> <span class="title">next</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyhashSet</span><br><span class="line">&#123;</span><br><span class="line">    private <span class="keyword">Node</span><span class="title">[] array</span>;</span><br><span class="line">    private int size = <span class="number">0</span>;//数组元素数目</span><br><span class="line">    public MyHashSet(int length)</span><br><span class="line">    &#123;</span><br><span class="line">        array = new <span class="keyword">Node</span><span class="title">[length</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    public int size()</span><br><span class="line">    &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int hash(Object o)//哈希算法</span><br><span class="line">    &#123;</span><br><span class="line">        int h = o.hashCode();//Object类中有这个方法</span><br><span class="line">        h += ~(h <span class="tag">&lt;&lt; 9);</span></span><br><span class="line"><span class="tag">        h ^= (h &gt;</span>&gt;&gt; <span class="number">14</span>);</span><br><span class="line">        h += (h <span class="tag">&lt;&lt; 4);</span></span><br><span class="line"><span class="tag">        h ^= (h &gt;</span>&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int indexFor(int hashCode)</span><br><span class="line">    &#123;</span><br><span class="line">        return hashCode &amp; (array.length-<span class="number">1</span>);//返回索引</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void add(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">newNode</span> = new <span class="keyword">Node</span><span class="title">(value</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array(index);</span><br><span class="line">        if(<span class="keyword">node</span> <span class="title">== null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            array(index) = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        else//处理哈希冲突</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">Node</span> <span class="title">nextNode</span>;</span><br><span class="line">            while(!<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value) &amp;&amp;</span><br><span class="line">            (nextnode = <span class="keyword">node</span>.<span class="title">getNext</span>()) != null)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= nextNode</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //不允许加入重复元素</span><br><span class="line">            if(!<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">node</span>.<span class="title">setNext</span>(newNode);</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //测试是否有这个对象</span><br><span class="line">    public boolean contains(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array[index];</span><br><span class="line">        while(<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; !<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">node</span> <span class="title">= node</span>.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">!=null</span> &amp;&amp; <span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean remove(Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = indexFor(hash(value));</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = array[index];</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">!=null</span> &amp;&amp; <span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            array[index] = <span class="keyword">node</span>.<span class="title">getNext</span>();</span><br><span class="line">            size--;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">Node</span> <span class="title">lastNode</span> = null;</span><br><span class="line">        while(<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; !<span class="keyword">node</span>.<span class="title">getValue</span>().equals(value))</span><br><span class="line">        &#123;</span><br><span class="line">            lastNode.setNext(<span class="keyword">node</span>.<span class="title">getNext</span>());</span><br><span class="line">            size--;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object[] getAll()</span><br><span class="line">    &#123;</span><br><span class="line">        Object[] values = new Object[size];</span><br><span class="line">        int index = <span class="number">0</span>;</span><br><span class="line">        for(<span class="keyword">Node</span> node:<span class="title"> array</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            while(<span class="keyword">node</span> <span class="title">!= null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                values[index++] = <span class="keyword">node</span>.<span class="title">getValue</span>();</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= node</span>.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p>java.util.Arrays类，有一系列操作数组的方法。这是一个私有类</p><p>静态方法：</p><ul><li>equals(): 比较两个数组是否相同</li><li>fill(): 向数组中填充数据</li><li>sort(): 把数组升序排列</li><li>parallelSort(): 开启多个线程，以并发的方式对数组中元素进行排序，提高效率</li><li>asList()把一个数组变成List</li></ul><p>例： Arrays.sort(a);</p><h1 id="用-…-声明数目可变参数"><a href="#用-…-声明数目可变参数" class="headerlink" title="用 … 声明数目可变参数"></a>用 … 声明数目可变参数</h1><p>可以用int… a代替 int[] a;这种模式下如果输入立即数可以转化成数组类型：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>... datas)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">max</span>(<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//可以直接输入数据</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure></div><p>但是必须要放在参数列表的最后一位</p><p>```<br>pubilc void max(int… data, String p)//错误，int… 必须放在最后<br>{<br>…<br>}</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;声明&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟内存</title>
    <link href="http://xinhecuican.github.io/post/f79e4123.html"/>
    <id>http://xinhecuican.github.io/post/f79e4123.html</id>
    <published>2020-05-12T05:37:00.000Z</published>
    <updated>2020-05-19T06:30:23.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 14:30:29 GMT+0800 (中国标准时间) --><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>我们在生成程序的时候，会发现每个程序的起始地址都是一样的，那么这种一样的地址怎么赋给实际的物理地址上的呢？这就要依靠虚拟内存机制了。</p><p>虚拟内存着力于解决进程间内存分配的问题，并且它还有一个作用是使进程之间相互隔绝。例如不小心产生了一个野指针指向了其他内存的位置，但是实际上却不会破坏其他程序而只会破坏自己的程序，这是因为虚拟内存限制了每个程序所使用的空间，如果超出限制就会报错。</p><p>程序中所使用的空间叫做虚拟空间，一共有2的n次方。而系统上有一个物理地址空间。虚拟内存做的其实是把虚拟空间上的内存地址映射到物理空间上。在cpu中，有一个叫MMU的部件专门做虚拟地址和物理地址转化。</p><h1 id="虚拟内存的组织形式"><a href="#虚拟内存的组织形式" class="headerlink" title="虚拟内存的组织形式"></a>虚拟内存的组织形式</h1><p>虚拟内存中的内存其实是按页进行划分的。这类似与磁盘中的扇区概念，即使那个扇区中只有一个字节的数据，取数据时也是把一个扇区全取出来。</p><p>虚拟内存页的大小一般是4kb到2mb之间。而物理内存也是按页进行分块，并且块的大小和虚拟内存页的大小相同。</p><p>其实把程序加载到内存时也不是一股脑直接加载的，而是一块一块逐个加载，并且如果内存满了还有块替换策略，这实质上是把内存当做一级缓存使用。</p><p>虚拟页有三种情况：</p><ul><li>未分配的， 这部分内存就是虚拟内存预留出来的部分，例如malloc使用的空间，各个段之间预留出来的空间等。</li><li>缓存的， 就是加载到内存中的</li><li>未缓存的，是程序的组成部分但是还没有加载到缓存中。</li></ul><p>由于磁盘访问速度过慢（比SRAM小100000倍），所以我们要尽可能的降低未命中率。第一个办法就是增大每一块的大小（所以才会有一块甚至到2mb，有的小程序都没这么大）。第二个办法是全相连。全相连可以极大降低冲突不命中概率。第三个是使用复杂的块替换策略，这和缓存不同，因为缓存和内存之间速度也就十倍差距，所以块替换策略越简单越好，但是内存与磁盘间不命中惩罚太大，大到情愿花一些时间来找那个最不可能被替换掉。最后是使用回写策略。 <a href="https://xinhecuican.github.io/post/7d1c86da.html">缓存</a></p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>页表是存放于物理内存中的，页表中中的内容代表虚拟内存中这片地址是否被使用，如果被使用，还要存放实际的物理地址。</p><p>页表的大小是由虚拟内存大小和页大小决定的。假设虚拟内存大小矢2的n次方，页大小矢2的p次方，那么页表就有2的n-p次方条。这实际上是一种以空间换时间的策略。每个进程都有一个页表。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt></p><p>上图中左边就是页表，右下角代表磁盘。页表中灰色代表未缓存，未缓存的地址就指向磁盘。而白色代表未分配，地址直接是NULL。如果我们访问0，因为0是未缓存并且内存已满，所以要替换一块下来，假设替换第四块，那么就要把页表中三的地址给改为内存中的物理地址并且把4的地址改为磁盘中的地址。</p><p>所以当我们访问内存时，如果访问到未加载的地址，那么会触发<a href="https://xinhecuican.github.io/post/28877bf.html#more">故障异常</a>,故障异常就会把磁盘中的内存加载进来并且重新执行这条指令。</p><p>如果我们加载到页表地址是NULL的地方，那么就会抛出segmentation fault。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.PNG" alt></p><p>通过页表，我们可以让物理内存彼此分离。并且还可以让两个进程数据共享，这也使动态库可能实现。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.PNG" alt></p><p>虚拟内存还提供了安全保护机制</p><p>这个是比较完整的页表，其中多了一些权限位。后面三个是读写和执行标志位，如果读的时候没有权限，那么就会抛出保护异常，这种异常一般都会终止程序。</p><p>第一个是模式标志位。有些操作系统专有的指令用户不能执行，有些专用寄存器用户不能访问。例如关机的指令即使用户特意编写也不会执行，因为它没有权限。</p><p>操作系统下的内存空间普通用户是没有办法去访问的。如果想调用操作系统的函数，可以使用陷阱异常，产生陷阱异常时，会转到特权模式。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>首先虚拟地址的低p位是页内偏移，因为虚拟内存页的大小和实际内存页的大小相同，所以二者偏移量相同。虚拟地址高n-p位是页号。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%984.PNG" alt></p><p>这张图表示了大致过程。cpu发出虚拟地址，mmu把地址解析成两部分。然后从内存中取出对应页号的地址（cpu中有页的基地址寄存器，页地址是根据页号*每页的大小+基地址得出）。然后mmu又根据取回来的页决定是否要去取内容。如果取，那么这个页中包含了物理页号，然后根据物理页号和偏移量得出实际地址。</p><p>如果标志位是0，那么还要到磁盘中去取出对应页放到内存中并且更新页表。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%985.PNG" alt></p><p>虚拟内存最大的问题就是显著增加了访问时间，本来只要访问一遍的现在要访问两遍。所以在mmu中又加了tlb寄存器专门用来存放页表。现在访问页表不用找内存了，直接找这个寄存器就可以了。如果没有找到再去内存中找并且更新tlb。</p><p>但是现代cpu都是多进程的。每个进程都有自己独立的页表，即使对应的内存相同可能标志位不同，也就是说每次更换进程都要把tlb清空一遍。一种解决办法是传给tlb页号的同时也传递一个进程信息，tlb也储存一个进程信息。</p><h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>假设虚拟内存大小是2的48次方，每页大小矢4kb，每个页表项8字节，那么页表大小矢2的39次方也就是512G。这在现实中显然是不可能实现的，所以要想办法把页表压缩。</p><p>我们很容易想到的一个办法是那些未分配的虚拟内存就不要建立页表项了，但是这样会带来一个问题。原来我们在查找页表的时候都是直接寻址，这是因为假设页表中每一项都存在，现在我们有一些项缺失了，直接根据页号查表的方法也就不行了，只有一个个比对，这样有增大了时间消耗。</p><p>我们可以建立一个多级页表，外层页表每一个页表项缓存的比较大，例如2mb甚至4Gb等，然后这一项中的内容不是物理页号，而是下一级页表的地址，之后下一级页表比上一级小，到最后一级就存储物理页号。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982.jpg" alt></p><p>如上图，最外面一层就占着最高位，然后依次递减。这是因为一旦最外层选中了就说明最高几位是那几号，那么就不用管了。</p><p>这样看起来好像是用空间并没有减少，因为到最后一层还是要建立，并且中间几层还要额外消耗空间。实际上如果某个缓存块是未分配的，那么就不会建立下一级页表了。而外面几层页表锁包含的比较大，这样一下就可以排除几百个G的未分配空间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先补充一下前面tlb结构。tlb也是一个缓存并且是组相联结构，这就代表着传递信息中必须要包含组号，然后剩余的是标志位。</p><p><img src="/images/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%983.jpg" alt></p><p>上图中tlbi就是组号，前面的是标志位。mmu传给tlb的只有vpn。</p><p>先是cpu发出虚拟内存地址，然后mmu开始解析，解析处vpn传给tlb，如果tlb解析成功那么再传给mmu物理页号并与vpo合成成物理地址。之后在把物理地址发给缓存。按缓存的方式处理。</p><p>如果tlb未命中，那么会到内存系统（包括缓存）中用页表基地址寄存器（CR3）找到最外层的页表然后一层层解析找到物理页号，然后把页号发给mmu的同时缓存那一片区域给tlb。</p><p>如果内存系统中也没有命中（未缓存或者未分配），那么就出触发缺页异常，通过缺页异常判断是未分配还是未缓存还是其他情况。</p><p>缺页异常时判断与一个链表有关。我们知道虚拟内存时分为若干个段的，每个段都有起始地址和终止地址还有一些权限标志位，这个链表就是存放这些信息。当2发生缺页异常时，会判断这个地址是否是在这些段中，如果不在，那么直接抛出Segmentation Fault。如果在那么判断标志位，如果判断不成功会抛出保护异常，如果判断成功了然后再去磁盘中取数据。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 14:30:29 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;p&gt;我们在生成程序的
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="http://xinhecuican.github.io/post/28877bf.html"/>
    <id>http://xinhecuican.github.io/post/28877bf.html</id>
    <published>2020-05-11T23:44:00.000Z</published>
    <updated>2020-05-14T11:58:33.945Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 15 2020 17:23:19 GMT+0800 (中国标准时间) --><h3 id="产生过程"><a href="#产生过程" class="headerlink" title="产生过程"></a>产生过程</h3><p>当程序运行时，可能会产生异常，当cpu检测到这些时间发生时，就会通过异常表跳转到异常处理程序，然后进行处理。</p><p>异常表示常驻于内存中的，每个异常都有一个异常号，事件发送的是异常号，之后根据异常号找到异常表中的对应项再跳转过去。异常表的首地址存放在一个特殊的寄存器中。</p><p>当一场处理结束之后，可能会跳转到下一条语句，可能跳转到当前语句，也可能终止程序。</p><p>要注意，这里讲的异常是系统提供的异常，要把用户程序中设定的异常区分开。</p><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是用来和外部设备进行交互的，例如网卡，usb和磁盘。</p><p>每当这些设备有操作完成时，都会发给cpu一个信号叫cpu去取数据（cpu上有一个特殊的引脚专门去接受这些数据）。之后cpu就会执行中断程序然后去取数据。</p><p>一个显著的例子就是scanf，cpu不可能一到scanf就停止运行，肯定还要继续做各种各样的事。他只是调用了scanf函数给标准输入发出信号，有数据来了就告诉我。之后标准输入输入完成之后并不是直接存到内存中，而是先存到一个缓存中（例如键盘有usb缓存），然后告诉cpu要读数据，cpu才会执行中断去读数据。</p><p>执行中断程序之前，首先要把所有寄存器的值都保护好，之后才去执行。</p><h4 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h4><p>陷阱又叫系统调用。它是一种故意的中断，是执行一条指令的结果。执行完后回到下一条指令。</p><p>这是用户向系统请求服务，例如读文件，打开文件，创建文件，终止进程等。</p><p>系统提供了syscall n 指令专门用来调用这些功能。当这条指令执行时，会中断当前线程然后跳到内核中执行相应的代码，执行完成之后又会返回。</p><h4 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h4><p>故障是有可能修复的异常，这种异常执行完成之后会跳转到当前语句再执行一次。</p><p>一种典型的故障是缺页异常，缺页异常是虚拟内存的东西（现在还没学，就不瞎比比了）。</p><h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>终止是不可恢复的错误，通常是硬件错误，例如突然缺少什么信息等等。一般这种异常都会直接调用abort终止程序。</p><p><img src="/images/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri May 15 2020 17:23:19 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;产生过程&quot;&gt;&lt;a href=&quot;#产生过程&quot; class=&quot;headerlink&quot; title=&quot;产生过程&quot;&gt;&lt;/a&gt;产生过程&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>查找</title>
    <link href="http://xinhecuican.github.io/post/33cb1151.html"/>
    <id>http://xinhecuican.github.io/post/33cb1151.html</id>
    <published>2020-05-10T07:00:00.000Z</published>
    <updated>2020-05-18T06:08:10.150Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --><h3 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>就是一个个找，过程不必多少。</p><p>如果查找每个元素概率相等，那么查找第n个元素只需要一次，第n-1需要两次…。所以平均查找次数是 1+2+…+n / n = （n+1)/2</p><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>其实就是二分查找,<a href="https://xinhecuican.github.io/post/41829.html">代码</a></p><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>分块查找就是每个找出每个块中最大的元素然后单独建一个表，之后就可以先查找这个表然后根据表来查找。大致意思就是这样，<a href="https://blog.csdn.net/To_Be_IT_1/article/details/25333253" target="_blank" rel="external nofollow noopener noreferrer">具体代码</a></p><h3 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h3><h4 id="二叉排序树（查找树）"><a href="#二叉排序树（查找树）" class="headerlink" title="二叉排序树（查找树）"></a>二叉排序树（查找树）</h4><p>二叉查找树特点是左儿子都比父亲小，右儿子都比父亲大。</p><p><img src="/images/%E6%9F%A5%E6%89%BE.PNG" alt></p><p>上面就不是二叉排序树，因为66比50还要大。</p><p>用链表进行存储。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    node</span> *lchild;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*rchild</span>;</span><br><span class="line">    int val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>二叉树的查找算法：</p><ol><li>如果二叉树是空，那么直接返回</li><li>如果该节点的val正好是要查找的数，则查找成功</li><li>如果大，那么去右边找</li><li>如果小，去坐标找</li></ol><p><strong>插入</strong></p><p>先要进行查找，如果查找不成功才会插入。</p><p>插入过程最好单独写一个函数，因为使用递归。如果要插入的点比当前点大，那么就去右边，反之就去左边。知道这个点是空为止，把要插入的点插入到这个空的点中。</p><p><strong>删除</strong></p><p>如果要删除的点是叶结点，那么直接把这个点变成空（因为父亲节点的儿子指针就指向这个节点，现在把这个节点变成空，那么儿子指针就指向空）</p><p>如果要删除的节点只有左子树或者右子树，那么让父亲对应指针指向那个子树就可以了。所以最好把父亲节点也用一个变量存储。</p><p>如果要删除的节点左右子树都有，就用它的前驱替代，然后删除前驱。</p><p><img src="/images/%E6%9F%A5%E6%89%BE2.PNG" alt></p><p>左边是删除前，右边是删除后。</p><p><img src="/images/%E6%9F%A5%E6%89%BE3.PNG" alt></p><p>前面一段代码是找前驱，前驱是s，而q是s的父亲，如果p==q说明p的左孩子就是s并且没有没有其他分支</p><p>效率 2logn</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树的特点是左右子树深度之差小于等于1.</p><p><strong>构造方法</strong></p><p>加入一个代表深度差的标记bf，如果左边比右边深为正，右边比左边深为负。例如：</p><p><img src="/images/%E6%9F%A5%E6%89%BE4.PNG" alt></p><p>上面的数字就是bf值。这个例子中是失去平衡的右子树的右子树导致的，也就是右右，可以向左旋转。让5做8的左节点，8连接根节点，19连接右节点。</p><p>如果是左左，那么向右旋转。</p><p>如果是左右，那么先左旋再右旋。</p><p>如果是右左，那么先右旋再左旋。</p><p>那么现在就知道如果不平衡应该怎么做了。但是插入时怎么判断平不平衡呢？</p><p>如果是空树，那么把这个点做根节点。</p><p>否则就按照二叉排序树的方法进行插入，插入完成之后又从底部递归。如果最终插入到右边就让父亲-1，如果插入到左边就让父亲加一。如果父亲&gt;=2就找左儿子，如果左儿子是1那么就是左左的情况，那么右旋，反之先左旋再右旋。如果&lt;=-2也是同样的方法。</p><p><img src="/images/%E6%9F%A5%E6%89%BE5.PNG" alt></p><p><img src="/images/%E6%9F%A5%E6%89%BE6.PNG" alt></p><p>注意，左旋和右旋是以根节点为基准的。在左左或右右的情况中，根节点是最上面那个点p，右旋就是把p和lc互换。但是在左右和右左的情况中不是这样。</p><p>如果是左右的情况，先以第二层的点作为根，右旋就是第二层的点和第三层的点换一下位置，顺便把原来第三层的左儿子挂到原来第二层的右儿子上（因为原来第三层的点变成第二层，右儿子没有了）。</p><p><img src="/images/%E6%9F%A5%E6%89%BE7.PNG" alt></p><p>最后除此之外还要注意左右或右左的情况中旋转之后的bf值会不同。</p><p><img src="/images/%E6%9F%A5%E6%89%BE8.PNG" alt><br><img src="/images/%E6%9F%A5%E6%89%BE9.PNG" alt><br><img src="/images/%E6%9F%A5%E6%89%BE10.PNG" alt></p><p>可以通过c点来区分</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>一种多路平衡查找树</p><p>每个节点至多m个儿子，如果根节点不是叶子节点，那么<strong>最少2棵</strong>子树。根节点之外的非叶子节点都<strong>至少有 m/2</strong>个子树。</p><p>非终端节点包含n, A0, k1, A1, k1, A2…其中k是关键字，且k&lt;k+1.n是关键字的数目</p><p>所有叶子节点都在同一层次且是空指针。</p><p><img src="/images/%E6%9F%A5%E6%89%BE11.PNG" alt></p><p>从上图中可以看出，对于每一个节点还是符合左边小右边大的规律的。</p><p>结构：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> keynum;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*parent</span>;</span><br><span class="line">    int key[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*p</span>[m+<span class="number">1</span>];</span><br><span class="line">    int *record[m+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">struct result</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">node</span> <span class="title">*pt</span>;</span><br><span class="line">    int i;//节点中关键字序号</span><br><span class="line">    int success;//是否找到</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>查找</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="NIX"><figure class="iseeu highlight /nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">result search(node *head, int key)</span><br><span class="line">&#123;</span><br><span class="line">    node *<span class="attr">p</span> = head;</span><br><span class="line">    mode *q;</span><br><span class="line">    int <span class="attr">found</span> = <span class="number">0</span>;</span><br><span class="line">    while(p &amp;&amp; !found)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">n</span> = p-&gt;keynum;</span><br><span class="line">        int <span class="attr">i</span> = search(p, key);//这个函数是找第一个大于等于key的</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; p-&gt;key[i] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">found</span> = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">q</span> = p;</span><br><span class="line">            <span class="attr">p</span> = p-&gt;p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(found != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result a.<span class="attr">pt</span> = p;</span><br><span class="line">        a.<span class="attr">i</span> = i;</span><br><span class="line">        a.<span class="attr">success</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result a.<span class="attr">pt</span> = q;//因为没找到最后一定会到<span class="literal">null</span>，所以返回它父亲</span><br><span class="line">        a.<span class="attr">i</span> = i;</span><br><span class="line">        a.<span class="attr">success</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>插入</strong></p><p>节点插入首先是查找，前面查找的时候已经返回了他应该在的位置。但是如果插入后超过了上限那么还要把中间节点提到上面去（主要讲三叉）。同时让左右两边的做往上提节点的左右两边。</p><p><img src="/images/%E6%9F%A5%E6%89%BE12.PNG" alt><br>上面是插入85</p><p>算法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void insert(node *head, int key, node *<span class="built_in">in</span>, int position)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//in是要插入的节点，例如上面就是g节点</span></span><br><span class="line">    <span class="comment">//position是插入位置，也可以先用一次查找</span></span><br><span class="line">    int x = key；</span><br><span class="line">    node *ap = NULL;</span><br><span class="line">    int finish = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &amp;&amp; !finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(int k=position; k&lt;<span class="built_in">in</span>-&gt;</span>keynum-<span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">in</span>-&gt;</span><span class="function"><span class="title">key</span>[k+1] = <span class="built_in">in</span>-&gt;</span>key[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">for</span>(int i=position+1; i&lt;<span class="built_in">in</span>-&gt;</span>keynum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">in</span>-&gt;</span><span class="function"><span class="title">p</span>[i+1] = <span class="built_in">in</span>-&gt;</span>p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">in</span>-&gt;</span>key[position] = x;</span><br><span class="line">        <span class="function"><span class="title">in</span>-&gt;</span>keynum++;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="built_in">in</span>-&gt;</span>keynum &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            finish = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要把数往上提</span></span><br><span class="line">            int temp = (m%<span class="number">2</span>==<span class="number">0</span>) ? m/<span class="number">2</span> : m/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="title">x</span> = <span class="built_in">in</span>-&gt;</span>key[temp];</span><br><span class="line">            <span class="comment">//分裂</span></span><br><span class="line">            <span class="function"><span class="title">ap</span> = <span class="built_in">in</span>-&gt;</span>parent;</span><br><span class="line">            <span class="function"><span class="title">for</span>(int i=0; i&lt;ap-&gt;</span>keynum-<span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span>(ap-&gt;</span>key[i] &lt; x)</span><br><span class="line">                &#123;</span><br><span class="line">                    position = x;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//search</span></span><br><span class="line">            <span class="function"><span class="title">for</span>(int i=position+1; i&lt;ap-&gt;</span>keynum; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">ap</span>-&gt;</span><span class="function"><span class="title">p</span>[i+1] = ap-&gt;</span>p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            node *left = new node;<span class="comment">//拆分后左边节点</span></span><br><span class="line">            node *right = new node;<span class="comment">//拆封后右边节点</span></span><br><span class="line">            <span class="comment">//拆分具体过程就不写了，一系列的赋值</span></span><br><span class="line">            <span class="function"><span class="title">ap</span>-&gt;</span>p[position] = left;</span><br><span class="line">            <span class="function"><span class="title">ap</span>-&gt;</span>p[position+<span class="number">1</span>] = right;</span><br><span class="line">            <span class="built_in">in</span> = ap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">head</span>-&gt;</span>keynum++;</span><br><span class="line">        <span class="function"><span class="title">head</span>-&gt;</span>key[<span class="number">0</span>] = key;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这是自己写的并且没有验证，只有借鉴作用</span><br></pre></td></tr></table></figure></div><p><strong>删除</strong></p><ul><li>如果删除这个值后节点的key数大于 m/2-1（此时分支数是m/2)。那么只需要删除对应部分，其他不变。</li><li>如果删除节点后key=m/2-1<ol><li>如果它父亲左边或者右边Key数大于m/2-1，那么先把左边最大（右边最小）提到上面，再把那个值放下来<img src="/images/%E6%9F%A5%E6%89%BE13.PNG" alt></li><li>如果左右两边正好都等于m/2-1，那么把左边右边合并并且把这个值也放下来<img src="/images/%E6%9F%A5%E6%89%BE14.PNG" alt></li><li>不会有小于m/2-1的了，不符合定义</li></ol></li><li>如果删除后<strong>双亲</strong>key值小于m/2-1,层层向上合并（不清楚具体过程）</li></ul><p><strong>B+树</strong></p><p>b+树key和q一样多，并且子节点中包含父节点中的信息。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>基本思想：建立要存的数和存的位置之间的映射关系（最理想的情况是一一映射），此后在查找元素时，只需要用hash函数就可以找到再表中的位置。</p><p>哈希函数就是将值转化成存的位置的函数。</p><p>举个例子： 比如哈希函数是 x%10-1,那么可以输入x就可以得到元素在表中的位置。</p><p>但是这里有个问题，例如11的哈希值和1的哈希值相同，那么存的位置也相同，这显然是不允许的，这叫做哈希冲突。判断哈希函数优劣就是哈希冲突越少越好。</p><p><a href="https://xinhecuican.github.io/post/11491.html">字符串哈希</a></p><h5 id="直接定值法"><a href="#直接定值法" class="headerlink" title="直接定值法"></a>直接定值法</h5><p>hash(key) = key 或 hash(key) = a * key + b</p><p>这种方法仅适合哈希表和取值范围一样大的情况（如果取值到十亿我就呵呵）</p><h5 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h5><p>这是利用所选数字中的一些规律来的。例如某一串数字最高若干位都相同，只有一两位不同，那么我们就可以只取一两位</p><h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><p>就是先把数字平方然后再取中间几位，它的目的是扩大差别从而缩小冲突几率。适用于每一位都有高概率的重复数字。</p><h5 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h5><p>将关键字分成若干块然后叠加。可以直接分成若干块叠加。也可以正的加一块然后把数倒过来加一块，这种方法使用于位数多的情况。</p><h5 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h5><p>hash(key) = key % p;//p是不大于表长且不大于最大值的素数</p><h5 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h5><p>hash(key) = random(key);//这是伪随机数</p><h5 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h5><p><strong>开放地址法</strong></p><p>把冲突的地址求一个地址序列：h0,h1…</p><p>h(i) = (h(key) + d(i) ) mod m // m是表长</p><p>d(i) = c + i c可以随便取</p><p>或d(i) = (-1)^(i-1) * (i/2)^2 //这里的i/2是向上取整也就是1/2=1</p><p>或d(i)=random(i)//伪随机数</p><p>或d(i) = i*h2(key)</p><p>注意，这里的d(i)要保证完备性，也就是要保证s(m-1)个h(i)均不相同并且要覆盖到所有地址。那么就要求</p><ol><li>表长要是 4*k+3</li><li>m与d(i)没有公因子</li></ol><p><strong>链地址法</strong></p><p>把哈希值相同的记录在一个链表里。其实就是构建一个链表，如果不冲突就只有一个值，冲突就往后面加。</p><p><strong>再哈希法</strong></p><p>发生冲突时，选用另外一个哈希函数，直到不冲突。</p><p><strong>建立公共溢出区</strong></p><p>一旦发生冲突，就把有冲突的数据都填充到溢出表。</p><h5 id="哈希表查找"><a href="#哈希表查找" class="headerlink" title="哈希表查找"></a>哈希表查找</h5><p>就是先计算处hash(key)，如果找到直接填充，如果发现冲突就在通过冲突处理方法进行查找</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 19 2020 13:39:56 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;静态查找&quot;&gt;&lt;a href=&quot;#静态查找&quot; class=&quot;headerlink&quot; title=&quot;静态查找&quot;&gt;&lt;/a&gt;静态查找&lt;/h3&gt;&lt;h4
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>java 多线程</title>
    <link href="http://xinhecuican.github.io/post/f8648a1d.html"/>
    <id>http://xinhecuican.github.io/post/f8648a1d.html</id>
    <published>2020-05-04T11:40:00.000Z</published>
    <updated>2020-05-14T11:56:46.436Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 15 2020 17:23:19 GMT+0800 (中国标准时间) --><h3 id="java线程运行机制"><a href="#java线程运行机制" class="headerlink" title="java线程运行机制"></a>java线程运行机制</h3><p>java虚拟机中，执行程序是由线程完成的，每个线程都有独立的程序计数器（PC或rip<br>)和栈</p><p>栈中有三个区，局部变量区，操作数栈和栈数据区。</p><p>操作数栈是线程的工作区，用来存放运算过程产生的临时变量（怎么有种寄存器的感觉）。</p><p>栈数据区为线程执行指令提供相关信息，例如定位到堆区和方法区的特定数据（类成员变量），正常退出方法等（存放地址信息）。</p><p>每次java虚拟机启动一个虚拟机进程时，虚拟机都会创建一个主线程。该线程从main开始执行。</p><p>例如在一个类中定义了一个实例变量a,然后再main函数中调用了这个类的成员函数A()，这个函数会让成员变量加一。首先进入这个方法，然后发现a++;就去栈数据区取出a的地址，之后定位到堆区取出a进行操作。</p><ul><li>方法区存放了字节码</li><li>堆区存放了线程所需要长时间保存的数据（类）</li><li>栈区存放了临时数据，栈帧和跳转到其他区域地址。</li></ul><h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>我们现在免费有了一个主线程，如果我们还想要创建其他线程的话，有两种方式。</p><ul><li>扩展java.lang.Thread类</li><li>实现Runnable接口</li></ul><p>要注意一点，创建了线程并启动之后会有自己的栈区，堆区，方法区，也就是说可以把它看成一个新的程序，里面的变量都是最原始的，不要认为主线程中操作的变量还有用。但是有些时候也可以使用主线程的对象</p><p><strong>一个线程只可以被启动一次</strong>。</p><h4 id="扩展java-lang-Thread类"><a href="#扩展java-lang-Thread类" class="headerlink" title="扩展java.lang.Thread类"></a>扩展java.lang.Thread类</h4><p>thread是线程，它的最主要的两个方法是：</p><ul><li>run(): 包含线程运行时执行的代码（相当于main方法）</li><li>start()： 用于启动线程，不需要覆盖</li></ul><p>start方法用来确定什么时候开始执行，可以在别的main函数中执行，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Machine</span> <span class="symbol">extends</span> <span class="symbol">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">50</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Machine machine = new Machine();</span><br><span class="line">        machine.start(); <span class="comment">//启动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>注意</strong>，调用了start并不是指立刻执行这个线程，而是让这个线程进入就绪状态，如果想让这个线程执行可以使用yield。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>java不允许一个类继承多个类，所以一旦继承了Thread类，那么就不能继承其他类。所以说接口这时就体现出优越性了。定义如下：</p><p><code>public void run();</code></p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    [</span></span><br><span class="line"><span class="function">        Machine machine </span>= <span class="keyword">new</span> Machine();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> thread(machine);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Thread构造方法中有Runnable接口的，这个时候Thread就掌管了run方法，只要使用start就可以启动。</p><h4 id="主线程和用户自定义线程并发运行"><a href="#主线程和用户自定义线程并发运行" class="headerlink" title="主线程和用户自定义线程并发运行"></a>主线程和用户自定义线程并发运行</h4><p>并发运行指的是一个线程没有结束另一个线程开始执行，上面举的例子都是并发运行。</p><p>Thread中的currentThread()静态方法返回当前线程的引用，getname()返回当前线程的名字，main方法名字是main，用户创建的线程根据顺序从Thread-0，Thread-1一直往后排，可以用setName()设置名字。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line">相当于</span><br><span class="line">Thread thread = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">String name = thread.get<span class="constructor">Name()</span>;</span><br></pre></td></tr></table></figure></div><p>为了让每个线程轮流获得cpu，可以使用sleep(time)放弃cpu并睡眠若干时间。</p><h4 id="多个线程共享一个对象的实例变量"><a href="#多个线程共享一个对象的实例变量" class="headerlink" title="多个线程共享一个对象的实例变量"></a>多个线程共享一个对象的实例变量</h4><p>例：</p><ul><li>方法内部局部变量不共享</li></ul><p>这是因为这些数据都是动态在栈中分配的，每个线程都有自己的堆栈。</p><ul><li>成员变量，如果是指向同一个对象就共享</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Analy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Num i=<span class="keyword">new</span> Num(<span class="number">0</span>);    <span class="comment">//新建对象，准备传递给线程</span></span><br><span class="line">        <span class="keyword">new</span> OwnThread(i).start();    <span class="comment">//新建线程，并启动</span></span><br><span class="line">        <span class="keyword">new</span> OwnThread(i).start();    <span class="comment">//新建线程，并启动</span></span><br><span class="line">        System.out.println(<span class="string">"主线程中i的值变为了："</span>+i.i);    <span class="comment">//获取目前对象i的数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OwnThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Num id;    <span class="comment">//申明对象，默认null，就是没有指向任何实体</span></span><br><span class="line">    <span class="keyword">int</span> sno;    <span class="comment">//申明int变量。因为系统默认初始化为0，所以应该是定义一个int变量</span></span><br><span class="line">    OwnThread(Num id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sno=id.i;    <span class="comment">//保存id.i的数值，到线程私有变量sno</span></span><br><span class="line">                id.i++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">","</span>+sno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span>    //定义一个类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Num(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序中主函数定义了Num对象的实例i，定义线程是传递到了Thread0和Thread1这样三个变量就共享了一个Num对象的实例。而线程Thread0和线程Thread1又有自己的私有变量sno，可以用来保存某一时刻的共享变量的数值。</p><p>(1)Java中判断对象是否为同一个对象使用地址判断的。地址相同就是同一个对象，上面的三个就是同一个对象。</p><p>(2)如果把上面的例子中共享的对象实例用基本数据类型替换是不行的。因为基本数据类型程序会自动的用默认值初始化，也就是申明和定义时一起的。此时在main函数中定义线程，传递的基本数据类型参数，只能是初始化线程中的另一个对象，而不是同一个对象。</p><p>也就是说，只有类才可以共享，并且用同一个实例启动多个线程的时候这个实例是共享的，并且也只有这个实例时共享的，如果在线程中创建的新实例也不是共享的。</p><p><a href="https://www.cnblogs.com/xudong-bupt/archive/2013/05/22/3087864.html" target="_blank" rel="external nofollow noopener noreferrer">这里来自这篇博客</a></p><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><p><strong>新建状态</strong></p><p>也就是只有new没有start状态。</p><p><strong>就绪状态</strong></p><p>调用了start方法后，就进入了就绪状态。虚拟机会为他创建栈和rip，这个线程在运行池中等待cpu使用权。</p><p><strong>运行状态</strong></p><p>就是得到了cpu使用权，如果是多个cpu，那么可以同时运行多个线程。</p><p><strong>阻塞状态</strong></p><p>阻塞状态优先级比就绪状态低，阻塞状态过去后首先进入就绪状态然后进入运行状态。</p><ul><li><p>如果调用了某个对象的wait()方法，那么会进入这个对象等待池中。</p></li><li><p>如果试图获得某个对象的同步锁（后面说）但是被其他线程使用时，会把这个线程放到这个对象的锁池中。</p></li><li><p>调用sleep。</p></li><li><p><em>死亡状态*</em></p><p>当退出了run后，进入死亡状态。前面已经提到过一个线程不能呗start两次。可以用Thread的isAlive()方法判断这个线程是否活着。如果处于新建状态时，也是false。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3></li></ul><p>线程调度就是确定cpu的使用权在那个线程手上，cpu通常只有一个。有两种调度模型：分时调度和抢占型调度。</p><p>分时型调度就是让每个线程都执行一定时间。</p><p>抢占型是java虚拟机采用的方式。它是将所有线程规定一个优先级，优先让优先级高的线程运行，如果优先级都相同，那么随机选取一个线程。一旦抢到cpu，那么它将会一直运行直到被迫停止运行。</p><p>被迫停止运行的可能：</p><ul><li>虚拟机让当前线程放弃cpu。</li><li>当前线程进入阻塞状态</li><li>线程运行结束</li></ul><p>不同操作系统对抢占型的实现不同，有的是会一直让这个线程运行，有的是一段时间后停止运行。</p><h4 id="调整优先级"><a href="#调整优先级" class="headerlink" title="调整优先级"></a>调整优先级</h4><p>可以使用Thread的setPriority(int)和getPriority()设置优先级，可以使用currentThread().setPriority(?)设置等级。</p><p>三个静态常量：</p><ul><li>MAX_PRIORITY 10级，最高等级</li><li>MIN_PRIORITY 1,最低等级</li><li>NORM_PRIORITY 5, 默认等级</li></ul><p>如果将主线程优先级更改然后再创建其他线程，那么其他线程优先级也会更改。被创建者的默认优先级和创建者优先级保持相同。</p><p>注意，上面三个静态常量在不同操作系统中是不同的，例如windows只有七个优先级，所以最好只使用上面三种优先级。</p><h4 id="Thread-sleep-线程睡眠"><a href="#Thread-sleep-线程睡眠" class="headerlink" title="Thread.sleep()线程睡眠"></a>Thread.sleep()线程睡眠</h4><p>如果使用sleep方法，那么他会放弃cpu进入阻塞状态。sleep后面的数据是以毫秒做单位。完成之后也不是立刻重新开始执行，而是先进入就绪状态，如果没人和它抢cpu就开始执行。</p><p>例如： sleep(100);表示阻塞100毫秒</p><p>可以使用sleep让两个线程比较同步的执行。例如每个线程都会调用sleep(100)，那么第一个线程调用睡眠后第二个线程开始执行，如果执行时间小于100ms那么第二个线程执行完后第一个线程仍在睡眠，如果大于100ms第一个线程会立刻开始执行。因为它已经睡了100ms进入就绪状态了（同样也是只有两个线程的情况）。</p><p>可以使用sleep.interrupt()中断睡眠</p><p>如果线程在睡眠时被中断，那么就会抛出InterruptedException，程序跳到异常处理代码块。</p><h4 id="Thread-yield-线程让步"><a href="#Thread-yield-线程让步" class="headerlink" title="Thread.yield()线程让步"></a>Thread.yield()线程让步</h4><p>执行yield后，如果有相同或者更高优先级的线程在就绪状态，那么将会把当前线程放入运行池中并让优先级高的线程执行。</p><h4 id="join-等待其他线程结束"><a href="#join-等待其他线程结束" class="headerlink" title="join()等待其他线程结束"></a>join()等待其他线程结束</h4><p>当前线程可以调用另一个线程的join()方法，直到另一个线程结束这个线程才会又开始执行（进入就绪状态）。</p><p>如果加了参数，那么类似于sleep()将会休眠若干时间，不同的是join是给指定的线程执行。</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>例如垃圾回收线程，只有当前台所有线程都停止之后，后台线程才会结束生命周期。</p><p>主线程默认是前台线程，前台线程创建的线程默认也是前台线程。</p><p>可以调用Thread的setDaemon(true)方法，把线程设置成后台线程。可以用isDaemon()判断是否是后台线程。</p><p>只有在线程启动前（使用start())之前才可以设置成后台。并且后台创建的线程还是后台线程。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>java.util包中提供了定时器Timer，TimerTask类表示定时器执行的一项任务。例；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> usetimer;</span><br><span class="line">improt java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.start();<span class="comment">//想自定义start必须要先用父类的start</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(ture);<span class="comment">//把Timer关联的线程设为后台线程</span></span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;<span class="comment">//匿名类，便于设置定时任务</span></span><br><span class="line">        timer.schedule(task, <span class="number">10</span>, <span class="number">50</span>);<span class="comment">//设置定时任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">":"</span>+a++);</span><br><span class="line">        &#125;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>TimerTask类是一个抽象类，它实现了RUnnable接口。start()中匿名类继承了TimerTask类。</p><p>TImer(boolean isDaemon)可以把相关联的线程设置成后台线程。如果是true就是后台</p><p>schedule(TimerTask task, long delay, long period)用来设置定时任务。所以前面的匿名类就是用来启动定时任务的。delay是推迟多少毫秒之后执行，period是每次执行任务的间隔。其中delay只在第一次运行时有效。</p><p>还可以不要period参数，表示只执行一次。例如,timer.schedule(task, 10);</p><p>同一个定时器可以执行多个任务。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>有时候线程的抢占可能导致问题。例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//共享</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a+=i;</span><br><span class="line">            Thread.<span class="built_in">yield</span>();<span class="comment">//让给其他线程执行</span></span><br><span class="line">            a-=i;</span><br><span class="line">            System.out.<span class="built_in">println</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Mahcine();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(machine);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(machine);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个程序本来是要一直输出零的，但是因为让给了t2执行，所以会输出1 2 2 3 …。这样就和原来的逻辑不符。</p><p>逻辑紧密相关的一组操作叫做原子操作，为了防止原子操作被打断，就提出了线程同步思想。</p><h4 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h4><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">String</span> goods = <span class="built_in">buffer</span>[<span class="built_in">point</span>];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样就设置了this对象的锁。</p><ul><li>如果这个锁被其他线程占用，那么就会把该线程加入锁池中，进入阻塞状态</li><li>如果没有线程占用，那么他就会占用并执行代码块。</li></ul><p>也可以这样写；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized <span class="keyword">String</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意，在同步代码块中同样也可以使用sleep和yield，同样也是把cpu给其他线程。只是如果其他线程正好碰到了同步代码块那么又要将控制权归还，</p><p>synchronized不会被继承，也就是说哪怕父类中写了synchronized如果子类没写也不是同步的。</p><p>同步代码块中应包含尽量少的操作，因为操作多了可能一线程要在这里工作很久，其他线程就会都进入锁池中无法工作，这样会给一些需要即时反应的线程带来麻烦</p><h4 id="释放对象的锁"><a href="#释放对象的锁" class="headerlink" title="释放对象的锁"></a>释放对象的锁</h4><p>释放锁的情况：</p><ul><li>执行完同步代码块，会释放锁</li><li>线程异常终止时</li><li>执行了锁所属对象的wait()方法，这个线程会释放锁，并进入等待吃</li></ul><p>但是使用sleep或yield只会放弃cpu，并不会释放锁。还有suspend方法</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁指的是a在等b锁释放，b在等a锁释放，这样就永运无法释放，最为关键的是虚拟机并不会检查这类问题，所以只有程序员自己注意。</p><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>线程通信就是一个线程告诉另外一个线程某个信息，通过配合完成某件事。</p><p>java.lang.Object类中有两个用于线程通信的方法：</p><ul><li>wait() 释放对象的锁，然后把该线程放入等待池中，等待其他线程把它唤醒</li><li>notify() 唤醒在等待池中的线程。随机选取等待池中的线程，并加入锁池中。</li></ul><p>进入等待池后，锁和cpu全部放弃。如果使用notify也只是进入锁池，还要和其他线程争夺锁。</p><p>notifyAll() 唤醒所有在等待池中的线程。</p><p>注意：wait()方法必须放在一个循环中。因为在调用notify后并不是立刻可以得到执行，而是先要获得该对象的锁和cpu执行权限才可以运行。这个时候可能其他线程又将状态改变了，这时又要重新运行。</p><p><strong>要注意的是想要唤醒等待池中的线程首先自己要掌握这个锁</strong>，也就是说必须在同步代码块中写notify，不然会报IllegalMonitorStateException错误。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public synchronized String pop<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    this.notify<span class="constructor">All()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(point<span class="operator"> == </span>-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.ptintln(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">":wait"</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            this.wait<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="params">e</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面例子中，首先point是-1就要让一个线程处理，现在point是-1，然后一个线程调用wait()进入等待池，之后另一个线程操作了这个方法唤醒了该线程，但是这个时候线程并没有执行，而是先让其他的线程执行了一会才开始执行。但是其他线程执行过程中又把point变成-1了，这个时候处理线程已经结束，就会出现问题。</p><p>此外，<strong>wait必须写在synchronized中，不然运行时会报错。</strong></p><h3 id="中断阻塞"><a href="#中断阻塞" class="headerlink" title="中断阻塞"></a>中断阻塞</h3><p>当线程A处于阻塞状态的时候，B调用A的interrupt()方法，那么A会发送一个InterruptedExecption。</p><p>实际上interrupt方法如果处理处于阻塞状态的线程（如wait，sleep，join等）才会抛出异常，实际上它是把一个中断线程的标志位设为true，因为处于阻塞状态，所以抛出异常，仅此而已。决定是否退出线程还是由我们自己决定的，如果我们在catch块中没有退出，那么还是会继续运行。</p><p>如果interrput一个正在处于运行的线程，那么只会把标志位设置成true，不会做其他事。</p><p>可以通过isinterrupt来看标志位是否变成true</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Timer timer = <span class="keyword">new</span> Timer(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread = Thread.currentThread();</span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">publc <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"has waited for 3s"</span>);</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                timer.schedule(timerTask, <span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(InterruptException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(thread.getName);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a++;</span><br><span class="line">            System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Machine machine = <span class="keyword">new</span> Machine();</span><br><span class="line">        machine.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段程序作用是如果a&gt;3，那么就把线程放入等待池，如果等待时间超过三秒，那么就抛出InterruptException信号从而中断线程。</p><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><ul><li>start() 启动线程</li><li>suspend() 使线程暂停</li><li>resume() 使暂停的线程恢复运行</li><li>stop() 终止线程</li></ul><p>但是其实后面三种已经被废弃了，但是可以通过编程实现同样的功能</p><h4 id="用编程方式控制线程"><a href="#用编程方式控制线程" class="headerlink" title="用编程方式控制线程"></a>用编程方式控制线程</h4><p>可以设置一个标志变量来表示现在的状态，假设标志变量有三个值。</p><ul><li>SUSP， 暂停状态</li><li>STOP， 终止状态</li><li>RUN， 运行状态</li></ul><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Control</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUSP = <span class="number">1</span>;<span class="comment">//设置静态变量的话所有类都可以看到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUN = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> state = RUN;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">if</span>(state == RUN)</span><br><span class="line">        &#123;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">checkState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(state == SUSP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"wait"</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(state == STOP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过上面的两个方法，就可以对线程进行控制，但注意这种控制不是实时的，也就是说即使执行了setState也不会立刻进入暂停状态，而是machine先获得cpu，开始执行checkState方法时才会进入暂停状态。</p><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>ThreadGroup类表示线程组，他可以对一组线程集中管理。用户创建的线程都属于某个线程组。</p><p>指定线程组： <code>Thread(ThreadGroup group, String name)</code></p><p>如果线程A创建线程B且创建时没有指定线程组，那么会自动加入A的线程组中。一旦线程<strong>加入线程组，就不能退出</strong>。</p><p>用户创建的线程组都有父线程组，默认情况下，如果A创建了一个新线程组，那么A所在的线程组就是父亲线程组。</p><p>指定父亲线程组： <code>ThreadGroup(ThreadGroup parent, String name)</code></p><p>可以使用activeCount()返回当前活着的线程，enumerate(Thread[] tarray)把或者的线程复制到tarray中。</p><h3 id="处理线程未捕获的异常"><a href="#处理线程未捕获的异常" class="headerlink" title="处理线程未捕获的异常"></a>处理线程未捕获的异常</h3><p>如果线程没有捕获异常，那么虚拟机会找UncaughtExceptionHandler实例（这东西是个接口）。并且调用它的uncaughtException(Thread t, Throwable e)方法</p><p>设置异常处理类：</p><p><code>setDefaultUncaughtExcpetionHandler(Thread.UncaughtExceptionHandler eh)</code><br><code>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code></p><p>第一个是设置默认异常处理器（静态方法），第二个是设置当前异常处理器（实例方法）。</p><p>ThreadGroup线程组实现了这个接口。每次出现未捕获异常时，先找当前线程的异常处理器，如果没找到就用线程组的异常处理器。</p><p>并且线程组的异常处理器还不是直接调用。如果这个线程有父线程，那么就调用父线程的。如果没有父线程，那么如果自己实现了这个接口，那么就用。如果没有，那么就打印调用堆栈的异常信息。</p><h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><p>这个类用来存放线程的局部变量。这些局部变量是每个线程独有的，不会共享。</p><p>主要有三个方法：</p><p><code>public T get(): 返回当前线程局部变量 protected T initialValue(): 返回局部变量初始值 public void set(T value): 设置局部变量</code></p><p>其中initialValue()只会在第一次调用get()或set()时才会被使用，并且只会执行一次。</p><h3 id="concurrent并发包"><a href="#concurrent并发包" class="headerlink" title="concurrent并发包"></a>concurrent并发包</h3><p>在编写多线程程序时，既要考虑并发，又要防止死锁，还要考虑性能，难度很大。为了降低难度，增加了java.util.concurrent包。下面是包含的类和接口</p><h4 id="Lock外部锁"><a href="#Lock外部锁" class="headerlink" title="Lock外部锁"></a>Lock外部锁</h4><p>这个主要用于线程同步。这是由类提供的锁，区别于对象的锁（可以叫内部锁）。他有几个方法。</p><ul><li><p>lock() 获得当前线程的锁，如果被占用，那么进入阻塞状态。这和内部锁是一样的</p></li><li><p>tryLock() 试图获得当前线程的锁（看看现在锁是不是有人用），如果被占用，就返回false，否则返回true。</p></li><li><p>tryLock(long time, TimeUnit unit)，如果超过了设置时间没有获得锁，放回false。例如 tryLock(50L, TimeUnit.SECONDS)表示时间限制50s</p></li><li><p>unlock() 释放线程锁占用的锁。</p><p>Lock接口有一个实现类ReentrantLock，构造方法ReentrantLock(boolean fair).fair如果是真，那么会采用公平策略。公平策略是指让阻塞时间长的更有可能获得锁。这是以性能作为代价的。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();<span class="comment">//创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>外部锁可以用来弥补内部所的一些不足，我们可以直接用lock，unlock而不使用synchronized。</p><h4 id="Condition-线程通信接口"><a href="#Condition-线程通信接口" class="headerlink" title="Condition 线程通信接口"></a>Condition 线程通信接口</h4><p>java.lang.concurrent.locks.Conditon用于线程通信。Lock接口的newCondition()方法返回Condition的实例。</p><p>方法：</p></li><li><p>await() 和wait()相似</p></li><li><p>await(long time, TimeUnit unit):和上面类似，如果超过时间线程没有被唤醒，返回false。</p></li><li><p>signal()： 和notify()类似。</p></li><li><p>signalAll()：和notifyAll()类似</p><h4 id="Callable和Feture"><a href="#Callable和Feture" class="headerlink" title="Callable和Feture"></a>Callable和Feture</h4><p>这两个是用来做异步计算的。Runnable接口的返回值是void，如果其他线程需要这个线程的返回值怎么办呢？这个可以通过共享变量来实现，但是共享变量需要共享类，这又可能导致问题。所以这两个接口就是解决这类麻烦。</p><p>Callable接口：和Runnable接口类似，Runnable中的run()相当于Callable中的call()。但是call可以有泛型的返回值。此外，这个不能作为Thread类的参数。</p><p>Future接口： 保存运算结果，以下参数</p></li></ul><ul><li>get()：返回异步运算的结果。如果结果没有出来，当前线程就会被阻塞直到运算结束。</li><li>get(long timeout, TimeUnit unit): 和第一个类似。只是如果超出时间还没有得到结果就会抛出TimeoutException。</li><li>cancel(boolean mayInterrupt): 取消该运算，如果运算没有开始，就立刻取消。如果已经开始，如果mayInterrrupt为true，那么也取消。</li><li>isCancelled()：判断运算时候被取消</li><li>isDone()：判断运算是否已经完成。</li></ul><p>FutureTask：这是一个适配器，同时实现Runnable和Future接口。还关联了一个Callable实例。FutureTask可以作为Thread类的参数。FutureTask类的构造函数可以带Callable的参数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LASSO"><figure class="iseeu highlight /lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Callable myComputation = <span class="literal">new</span> <span class="params">...</span></span><br><span class="line">FutureTask&lt;<span class="built_in">Integer</span>&gt; task = <span class="literal">new</span> FutureTask&lt;<span class="built_in">Integer</span>&gt;(myComputation);<span class="comment">//Integer是返回值</span></span><br></pre></td></tr></table></figure></div><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Machine implements Callable&lt;<span class="type">Integer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">Integer</span> <span class="keyword">call</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            catch(<span class="keyword">Exception</span> e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(Stirng[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FutureTask&lt;<span class="type">Integer</span>&gt; task = <span class="built_in">new</span> FutureTask&lt;<span class="type">Integer</span>&gt;(<span class="built_in">new</span> Machine());</span><br><span class="line">        Thread thread = <span class="built_in">new</span> Thread(task);</span><br><span class="line">        threadMachine.<span class="keyword">start</span>();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("从1到100的和"+task.<span class="keyword">get</span>());//调用<span class="keyword">get</span>返回值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="通过线程池管理多个线程"><a href="#通过线程池管理多个线程" class="headerlink" title="通过线程池管理多个线程"></a>通过线程池管理多个线程</h4><p><img src="/images/java%E7%BA%BF%E7%A8%8B.jpg" alt></p><p>Executor表示线程池，execute方法用来执行command的run()中指定的任务，线程会调度空闲的线程来执行该任务。到底什么时候执行，这是由cpu决定的。</p><ul><li>shutdown(): 预备关闭线程池。如果有任务提交上去，那么要等这些任务执行完后，才会关闭线程池，并且拒绝新任务的入内。</li><li>shutdownNow(): 终止已经开始的任务，立刻关闭线程池</li><li>isTermination(): 判断线程池是否关闭，如果关闭返回true</li><li>awaitTermination(): 等待线程池关闭。</li></ul><p>submit(Callable<t>task)和submit(Runnable task)和execute(Runnable command)类似，但是这个支持异步运算。他们都会返回异步运算结果的Future对象。</t></p><p>Excutors中静态方法：</p><ul><li>newCachedThreadPool(): 创建有缓存的线程池，有任务才创建新线程，空闲的线程停留60s。</li><li>newFixedThreadPool(int nThreads): 创建有固定数目线程的线程池，空闲线程一直保留</li><li>newSingleThreadExecution(): 创建只有一个县城的线程池。这个与newFixedThreadPool(1)不同之处在于这个终止就终止了，Fixed的终止了还会创建一个新的。</li><li>newScheduledThreadPool(int corePoolSize): 线程池会按时间计划创建任务。corePoolsize是线程<strong>最小</strong>数目。</li><li>newSingleThreadScheduledExecutor(): 创建只有一个线程的线程池，这个线程池按计划进行任务。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Machine</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Machine(i));</span><br><span class="line">        &#125;</span><br><span class="line">        service.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里创建了5个线程给线程池，然后线程池中两个空白线程接到任务开始工作，工作完这两个线程后又执行下面两个线程，直到执行完5个线程。然后执行shutdown()关闭线程池。</p><h4 id="BlockingQueue-阻塞队列"><a href="#BlockingQueue-阻塞队列" class="headerlink" title="BlockingQueue 阻塞队列"></a>BlockingQueue 阻塞队列</h4><p>java.util.concurrent.BlockingQueue接口继承了java.util.Queue接口。BlockingQueue接口为多个线程同时操作一个队列提供了方案。</p><table><thead><tr><th>操作</th><th>抛出异常</th><th>放回特定值</th><th>线程阻塞</th><th>超时</th></tr></thead><tbody><tr><td>添加元素</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>删除元素</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>读取元素</td><td>element()</td><td>peek()</td><td>无</td><td>无</td></tr></tbody></table><p>前面两个是队列的，后面两个是阻塞队列的。这个具体等到队列那里再说。这里先把几个BlockingQueue的实现类列一下：</p><ul><li>LinkedBlockingQueue类： 默认情况下，LinkedBlockingQueue的容量是没有上限的，也可以指定大小，这是基于链表的队列</li><li>ArrayBlockingQueue类： ArrayBlockingQueue(int capacity, boolean fair)可以设定容量，并且可以选择是否采用公平策略。这是基于数组的队列。</li><li>PriorityBlockingQueue：这是优先队列（堆）</li><li>DelayQueue: 这个队列中存放的是延期元素。这些元素必须实现java.util.concurrent.Delayed接口。只有延期满的元素才可以被取出或者删除。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri May 15 2020 17:23:19 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;java线程运行机制&quot;&gt;&lt;a href=&quot;#java线程运行机制&quot; class=&quot;headerlink&quot; title=&quot;java线程运行机制
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>c 文件操作</title>
    <link href="http://xinhecuican.github.io/post/e0f8cb74.html"/>
    <id>http://xinhecuican.github.io/post/e0f8cb74.html</id>
    <published>2020-04-29T12:20:00.000Z</published>
    <updated>2020-04-30T00:23:59.687Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>文件总的来说其实就只有两个操作，打开（关闭）和读写。本文也围绕这两个方面展开</p><p><strong>文件格式</strong></p><p>文件一般由三部分组成：路径，文件名，后缀。</p><p>例：<code>&quot;E:\\ch10.doc&quot;或者&quot;E:/ch10.doc&quot;</code></p><p>之所以要两个\是因为在c语言中\作为转义字符。</p><p><strong>流</strong></p><p>流按方向分为：输入流和输出流。从文件获取数据的流称为输入流，向文件输出数据称为输出流。</p><p>例如，从键盘输入数据然后把该数据输出到屏幕上的过程，相当于从一个文件输入流（与键盘相关）中输入（读取）数据，然后通过另外一个文件输出流（与显示器相关）把获取的数据输出（写入）到文件（显示器）上。</p><p><strong>换行符</strong></p><p>在Linux系统中，换行符是0x0a（LF）。因为c是在unix上发展起来的，所以访问Linux文件时，不需要转换，直接可以访问。</p><p>在windows系统中使用0x0d(CR ‘\r’） 和 0x0a(LF ‘\n’)合起来作为换行符。所以把windows下文件给c程序还要先把CR-LF转换成LF</p><p><strong>缓冲文件系统</strong></p><p>缓冲文件系统：系统自动为每个打开的文件在内存开辟一块缓冲区，缓冲区的大小一般由系统决定。当程序向文件中输出（写入）数据时，程序先把数据输出到缓冲区，待缓冲区满或数据输出完成后，再把数据从缓冲区输出到文件；当程序从文件输入(读取)数据时，先把数据输入到缓冲区，待缓冲区满或数据输人完成后，再把数据从缓冲区逐个输入到程序。</p><p>c语言就是用的缓冲文件系统。其实这和vim有点像。</p><p>ANSI C 为正在使用的每个文件分配一个文件信息区，该信息区中包含文件描述信息、 该文件所使用的缓冲区大小及缓冲区位置、该文件当前读写到的位置等基本信息。这些信息保存在一个结构体类型变量中，该结构体类型为 FILE 在 stdio.h 头文件中定义，不允许用户改变。</p><h3 id="文件打开和关闭"><a href="#文件打开和关闭" class="headerlink" title="文件打开和关闭"></a>文件打开和关闭</h3><p>文件指针 file* 用来引用一个文件。</p><p><strong>打开</strong></p><p>原型：<code>FILE * fopen(char *filename, char *mode);</code></p><p>filename指的是文件名，可以包括路径。</p><p>mode是打开方式。下面列举了一些打开方式</p><table><thead><tr><th>模式</th><th>含 义</th><th>说 明</th></tr></thead><tbody><tr><td>r</td><td>只读</td><td>文件必须存在，否则打开失败</td></tr><tr><td>w</td><td>只写</td><td>若文件存在，则清除原文件内容后写入；否则，新建文件后写入</td></tr><tr><td>a</td><td>追加只写</td><td>若文件存在，则位置指针移到文件末尾，在文件尾部追加写人，故该方式不 删除原文件数据；若文件不存在，则打开失败</td></tr><tr><td>r+</td><td>读写</td><td>文件必须存在。在只读 r 的基础上加 ‘+’ 表示增加可写的功能。下同</td></tr><tr><td>w+</td><td>读写</td><td>新建一个文件，先向该文件中写人数据，然后可从该文件中读取数据</td></tr><tr><td>a+</td><td>读写</td><td>在” a”模式的基础上，增加可读功能</td></tr><tr><td>rb</td><td>二进制读</td><td>功能同模式”r”，区别：b表示以二进制模式打开。下同</td></tr><tr><td>wb</td><td>二进制写</td><td>功能同模式“w”。二进制模式</td></tr><tr><td>ab</td><td>二进制追加</td><td>功能同模式”a”。二进制模式</td></tr><tr><td>rb+</td><td>二进制读写</td><td>功能同模式”r+”。二进制模式</td></tr><tr><td>wb+</td><td>二进制读写</td><td>功能同模式”w+”。二进制模式</td></tr><tr><td>ab+</td><td>二进制读写</td><td>功能同模式”a+”。二进制模式</td></tr></tbody></table><p>按照mode 规定的方式，打开由pname指定的文件。若找不到由pname指定的相应文件，就按以下方式之一处理：</p><p>（1） 此时如mode 规定按写方式打开文件，就按由pname指定的名字建立一个新文件；<br>（2） 此时如mode 规定按读方式打开文件，就会产生一个错误。</p><p>例： fopen(“example.txt”, “rw”);</p><p>如果返回失败，那么将返回NULL。</p><p><strong>关闭</strong></p><p>int fclose(FILE *fp);</p><p>如果关闭不正常，返回-1（EOF).</p><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="按字符输入输出"><a href="#按字符输入输出" class="headerlink" title="按字符输入输出"></a>按字符输入输出</h4><p>原型：<code>int fgetc (FILE *fp);</code></p><p>作用：一次读入一个字符。如果读入出现问题，返回-1(EOF)</p><p>注意：由于 fgetc 是以 unsigned char 的形式从文件中输入（读取）一个字节，并在该字节前面补充若干 0 字节，使之扩展为该系统中的一个 int 型数并返回，而非直接返回 char 型。当输入失败时返回文本文件结束标志 EOF 即 -1，也是整数。故返回类型应为 int 型，而非 char 型。</p><p>也就是说最好不要用char类型去接收字符而使用unsigned_char，这样在碰到特殊字符就不会出现错误。</p><p>由于在 C 语言中把除磁盘文件外的输入输出设备也当成文件处理，故从键盘输入字符不仅可以使用宏 getchar() 实现，也可以使用 <strong>fgetc (stdin)</strong> 实现。其中，stdin 指向标准输入设备—键盘所对应的文件。stdin 不需要人工调用函数 fopen 打开和 fclose 关闭。</p><p><strong>按字符输出</strong></p><p>原型： <code>int fputc (int c, FILE *fp);</code></p><p>向fp文件中输出字符c。如果想输出到屏幕，可以<code>fputc(c, stdout)</code></p><p>对一个文件进行读写操作时，经常会把一个文件中读写位置重新调整到文件的开始处，可以使用函数 rewind 实现。</p><p>原型: <code>void rewind (FILE *fp);</code></p><p>作用：把<strong>读写</strong>位置跳到函数开头。</p><h4 id="按字符串输入输出"><a href="#按字符串输入输出" class="headerlink" title="按字符串输入输出"></a>按字符串输入输出</h4><p><strong>输入</strong></p><p>原型： <code>char * fgets (char *s, int size, FILE * fp);</code></p><p>作用： 从文件中读取长度为size（到了末尾会终止）的字符串，并且自动加入’\0’后输出，遇到空格不会终止。</p><p><strong>输出</strong></p><p>原型： <code>int fputs (const char *str, FILE *fp);</code></p><p>作用：把str输出到文件中。</p><h4 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h4><p>这个与scanf和printf类似，只是目标变成了文件。</p><p><strong>输入</strong></p><p>原型： <code>int fscanf (文件指针，格式控制串，输入地址表列);</code></p><p>作用：从文件中输入到格式化字符串中，遇到空格会终止输入。</p><p>返回值：返回整型，输入成功时，返回输入的数据个数；输入失败，或已读取到文件结尾处，返回 EOF(-1)</p><p>例： fscanf (fp,”%d,%d”, &amp;a, &amp;b); //两个%d之间也必须用逗号隔开</p><p><strong>输出</strong></p><p>int fprintf (文件指针，格式控制串，输出表列)；</p><p>作用： 把格式字符串中的数据输出到文件中。</p><h4 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h4><p><strong>输入</strong></p><p>原型：<code>unsigned fread (void *buf, unsigned size, unsigned count, FILE* fp);</code></p><p>作用：从 fp 指向的文件中读取 count 个数据块，每个数据块的大小为 size。把读取到的数据块存放到 buf 指针指向的内存空间中。</p><p>返回值：返回实际读取的数据块（非字节）个数，如果该值比 count 小，则说明已读到文件尾或有错误产生。这时一般采用函数 feof 及 ferror 来辅助判断。</p><p><strong>输出</strong></p><p>原型：<code>unsigned fwrite (const void *buf,unsigned size,unsigned count,FILE* fp);</code></p><p>作用： 把buf中count个大小为size的数据块写到文件中</p><p><strong>文件检查</strong></p><p>原型： <code>int feof (FILE * fp);</code></p><p>作用：检查是否到了文佳末尾，如果到了，返回非0</p><h4 id="随机读写"><a href="#随机读写" class="headerlink" title="随机读写"></a>随机读写</h4><p>随机读写就是不是在文件开头而是制定一个位置开始读写。首先要把文件指针移到对应位置，然后开始读写。</p><p>原型： <code>int fseek(FILE *fp, long offset, int origin);</code></p><p>作用：把fp读写指针设置到origin+offset的位置上，origin是起始位置。offset是偏移量。</p><p>起始位置有三种快捷的设置。分别是：</p><ul><li>SEEK_SET:文件开头，即第一个有效数据的起始位置。</li><li>SEEK_CUR：当前位置。</li><li>SEEK_END:文件结尾，即最后一个有效数据之后的位置。注意：此处并不能读取到最后一个有效数据，必须前移一个数据块所占的字节数，使该文件流的读写指针到达最后一个有效数据块的起始位置处。</li></ul><p>可以通过<code>long ftell (FILE *fp);</code>获得当前指针对于文件开始位置的偏移量</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;文件总的来说其实
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>java 内部类</title>
    <link href="http://xinhecuican.github.io/post/348d4e04.html"/>
    <id>http://xinhecuican.github.io/post/348d4e04.html</id>
    <published>2020-04-28T12:00:00.000Z</published>
    <updated>2020-04-29T10:21:52.123Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>内部类就是在类的内部又定义一个类。</p><h3 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h3><p>实例内部类就是没有static修饰的内部类。他有以下几点需要注意</p><ul><li>在创建内部类的实例时，外部类必须已经创立。例如：</li></ul><p><code>Outer.InnerTool tool = new Outer().newInnerTool();</code>这个语句相当于</p><p><code>Outer outer = new Outer(); Outer.InnerTool Tool = outer.new InnerTool();</code></p><ul><li><p>内部类也是在外部类的内部，可以访问外部类的任何级别的成员方法和成员变量。这是因为想要创建内部类，首先要创建外部类，这个时候可以看成内部类有外部类的引用。</p></li><li><p>一个外部类可以对应多个内部类，一个内部类对应一个外部类。外部类不能直接访问内部类的成员，必须要通过实例去访问。例如</p></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> b1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> b2 = <span class="number">2</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">C</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v1 = b1;<span class="comment">//不能直接访问内部类成员，错误</span></span><br><span class="line">        B.C c1 = <span class="keyword">new</span> C();<span class="comment">//错误</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();<span class="comment">//正确，因为在类内部相当于已经有实例</span></span><br><span class="line">        <span class="keyword">int</span> v2 = b.b1;<span class="comment">//正确，可以通过内部类实例直接访问</span></span><br><span class="line">        B.c c2 = b.<span class="keyword">new</span> C();<span class="comment">//正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>在内部类中不能定义静态成员。</li><li>如果内部类和外部类A有同名的成员。那么this代表外部，A.this代表内部</li><li>如果有两个内部类且一个定义成private，那么另一个类不能访问。因为两个是同级的，可以把两个内部类看成继承于同一个父类的类。并且如果想在一个内部类中使用另一个内部类，则必须用完整类名</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        A.B b = <span class="keyword">new</span> <span class="type">A</span>().<span class="keyword">new</span> <span class="type">B</span>();<span class="comment">//使用A.B而不能像前面一样直接使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类也是一种静态变量。但是这种类比较神奇，本来static是不能修饰类的，但是内部类的static和普通的静态变量有所不同。它可以创建实例，也就是说不局限于方法区，只是为了有特殊的权限而把static安上去而已。</p><p>静态变量可以直接创建，不必先创建外部类。例如<code>A.B b = new A.B();</code>。</p><p>正因为如此，所以静态内部类想访问外部类实例变量需要先创建实例。但是静态变量可以直接访问。</p><p>静态类的特点就是可以定义静态成员。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是在一个方法中定义的类，它的可见范围是这个方法。局部内部类不能使用访问权限修饰符（public等），其实本来就没有必要，只能在这个方法内了还要访问权限干什么。</p><p>局部类也不能包含静态成员。依我看这就是java中的struct（不知道java中有不）。</p><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>这种类的特殊之处就是没有名字，这种类实际上是内部类的简写形式（虽然也简单不到哪去），如果只需要创建一个内部类实例，就可以考虑匿名类。例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> A</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    A a = new A()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        void method()</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            System.out.println("from");</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line">        a<span class="function">.<span class="keyword">method</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>匿名类本身没有构造方法，但是他会调用父类的构造方法。匿名类和内部类的访问权限相同，也可以访问外部所有变量。</p><p>匿名类中也可以实现接口。</p><h3 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h3><p>如果一个外部类继承了另一个外部类的内部类的实例，那么这个外部类会自动引用另一个外部类。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    pubilc <span class="keyword">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> print()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("a="+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Sample extends <span class="keyword">Outer</span>.<span class="keyword">Inner</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">public</span> Sample(<span class="keyword">Outer</span> o)</span><br><span class="line">   &#123;</span><br><span class="line">       o.super();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">public</span> static <span class="type">void</span> main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">Outer</span> outer1 = <span class="built_in">new</span> <span class="keyword">Outer</span>();</span><br><span class="line">       <span class="keyword">Outer</span>.<span class="keyword">Inner</span> <span class="keyword">inner</span> = outer1.<span class="built_in">new</span> <span class="keyword">Inner</span>();</span><br><span class="line">       Sample s1 = <span class="built_in">new</span> Sample(outer1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Sample必须要提供如上所述的构造函数。因为如果不提供，那么就不知道引用的是哪一个Outer。此外，Java虚拟机会自动使内部类的实例引用外部类的实例。例如上面inner实例会自动引用outer1实例。</p><h3 id="内部类用途"><a href="#内部类用途" class="headerlink" title="内部类用途"></a>内部类用途</h3><p>第一个作用就是封装。例如顶层类只有public和默认级别，而内部类四种级别都可以有。</p><p>第二个作用是访问外部类的属性。这个访问不代表创建一个内部类的实例就可以直接访问外部类的属性了，那反而是对封装的破坏，这里指的是在定义的时候可以随意使用外部类的属性。</p><p>第三个作用是<strong>回调</strong>。这个的含义是可以实现类和接口中同名的方法。例如两个接口或一个类一个接口中定义了重名的方法，那么可以让内部类实现接口然后外部覆盖方法。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span>//<span class="title">Base</span>调节速度，<span class="title">Adjustable</span>调节温度</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> speed)</span><span class="comment">//覆盖</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustTemperature</span><span class="params">(<span class="keyword">int</span> temperature)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Adjustable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> temperature)</span><span class="comment">//实现</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            adjustTemperature(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Adjustable <span class="title">getCallBackReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意这里内部类是通过调用外部类的方法来实现的，虽然应该也可以直接在内部类中实现，频繁的跳转反而会带来性能的降低。但是某些时候想使用外部类的private类型时可以使用这种方法。</p><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>对于每个内部类，java都会生成.class文件。</p><ul><li>成员内部类 外部类名字$内部类名字. 例： A$B.class</li><li>局部内部类 外部类名字$数字加内部类名字</li><li>匿名类 外部类名字$数字</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;内部类就是在类的内部又定义一个类。&lt;/p&gt;&lt;h3 id=&quot;实例内部类&quot;&gt;&lt;a href=&quot;#实例内部类&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>链接</title>
    <link href="http://xinhecuican.github.io/post/4551c130.html"/>
    <id>http://xinhecuican.github.io/post/4551c130.html</id>
    <published>2020-04-28T07:15:00.000Z</published>
    <updated>2020-05-07T09:56:19.844Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>记得gcc编译器编译的步骤吗？预处理，编译，汇编，链接。首先前两步是为了生成.s的汇编文件，然后第三步就是生成机器码。但是如果第三步就已经完成了所有事为什么还要第四步呢？</p><p>首先我们要知道，编译时是各个文件独立编译的，也就是说这个时候如果分配了地址很可能发生这个函数的地址和另外一个文件中函数的地址相同的尴尬事情发生，为了避免这种事情，在编译到.o文件的时候一些其他文件要用的函数和变量使用一个符号来表示的，然后在链接阶段再来连连看把地址安上。</p><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p>目标文件有三种：</p><ul><li>可重定位目标文件，也就是汇编后形成的.o文件。可以和其他文件链接新城可执行文件</li><li>可执行目标文件，也就是可执行文件</li><li>共享目标文件，一种特殊的可重定向目标文件，可以在运行时重定向（动态链接）</li></ul><h4 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h4><p><img src="/images/elf.png" alt></p><p>上面是一个elf文件结构图，这是现在linux中目标文件格式。各种目标文件中都有类似的格式。</p><ol><li>ELF头，存放了一些基础信息，例如大端序还是小端序，文件类型等等。</li><li>.text节，已编译的机器代码。</li><li>.rodata。只读数据，例如printf中的格式串和跳转表</li><li>.data；以初始化全局和静态变量</li><li>.bss； 未初始化全局和静态变量</li><li>.symtab。符号表</li><li>rel.text； .text节位置列表。可执行文件中不存在，一般会省略</li><li>.rel.data； 同上</li><li>.line； 源程序中行号和.text节机器指令间的映射，可以使用-g选项启用它</li><li>…</li><li>节头部表； 存放每一节相对于elf开始位置的偏移量。</li></ol><h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><p>每个.o文件中都有一个符号表。总共有三种符号</p><ul><li>全局符号：由该文件定义并且能被其他模块引用的全局符号。全局符号表示非静态函数和全局变量</li><li>外部符号：有其他模块定义并且被该模块引用的符号。这些符号叫外部符号。对应其他模块（文件）的非静态函数和全局变量</li><li>局部符号。这是带static的函数和全局变量。这些符号在函数内部都可见，但是不能呗其他函数引用。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">符号表的构成：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Symbol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;<span class="comment">//在符号表中的字节偏移</span></span><br><span class="line">    <span class="keyword">char</span> type:<span class="number">4</span>,<span class="comment">//符号类型，是数据还是函数还是文件还是未定义</span></span><br><span class="line">       binding:<span class="number">4</span>;<span class="comment">//符号是本地（static）还是全局的</span></span><br><span class="line">    <span class="keyword">char</span> reserved;</span><br><span class="line">    <span class="keyword">short</span> section;</span><br><span class="line">    <span class="keyword">long</span> value;<span class="comment">//符号地址</span></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">size</span>;<span class="comment">//符号大小，对于函数是函数指令字节总个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>例：<img src="/images/%E7%AC%A6%E5%8F%B7%E8%A1%A8.webp" alt></p><p>其中ndx中的UND是undefine。</p><h3 id="静态链接完成的任务"><a href="#静态链接完成的任务" class="headerlink" title="静态链接完成的任务"></a>静态链接完成的任务</h3><p>静态链接就是编译时完成的链接，与之对应的运行时的链接。静态链接主要完成了两个任务，符号解析和重定位</p><h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><p>符号解析就是将上面的符号表一一对应起来，例如上面第二种符号就匹配其他文件的第一种符号。</p><p>但是这里还有一些问题，因为开始编译是各做各的，所以难免出现名字相同的情况，甚至一个文件中也有函数重载导致重名的情况。这是符号解析中的难题。</p><p>对于一个文件中的重载，gcc链接器会对这些符号进行重整。例如同样是A函数，可能通过链接器的重整一个符号名就成了A1，另外一个成了A2。</p><p>如果是全局（其他模块可见）的变量之间导致重名。有以下方法。</p><p>在编译时，编译器想汇编器输出每个全局符号，分成强弱两类。函数和以初始化的全局变量时强符号，未初始化全局变量时弱符号。</p><p>链接规则：</p><ol><li>不能出现同名的强符号</li><li>如果一个强符号，其他都是弱符号，那么其他弱符号都使用强符号地址</li><li>如果都是弱符号，那么随机选取一个弱符号，其他弱符号使用这个弱符号地址</li></ol><p>注意第二点和第三点，系统都只分配了一片内存空间，其他符号都是共用这片内存空间，这就可能导致一些奇奇怪怪的错误，例如数据莫名被修改。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sum.<span class="keyword">c</span></span><br><span class="line"></span><br><span class="line">int <span class="keyword">x</span><span class="comment">;</span></span><br><span class="line"><span class="comment">int y;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a.c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int x;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为x都是弱符号，所以随便选一个，然后让另一个共享内存空间，也就是在sum.c中进行更改会导致a.c中x的更改。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sum.c</span></span><br><span class="line"><span class="comment">int x;</span></span><br><span class="line"><span class="comment">int y;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a.c</span></span><br><span class="line"><span class="comment">double x;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这种问题更为严重，如果选到了a.c中的x，那么空间是8字节，而这时在sum.c中x和y是连到一起的也是8字节，这就意味着这次对a.c中x改变可能会导致y改变。</span></span><br></pre></td></tr></table></figure></div><p>上面这个问题在编译阶段很难发现，所以只有养成良好习惯，才可以减少这类问题。下面是几点建议。</p><ol><li>能不使用全局变量就不使用全局变量</li><li>使用全局变量记得初始化</li><li>确定要引用外部变量时用extern</li></ol><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>重定位有两步</p><ol><li>重定位节和符号定义：这一部分是把上面所说的每一个文件中的节。例如所有文件的.data节合成为一个节。之后就把内存地址赋给新的节，并且赋给每个符号。这时就有运行时的内存地址了。</li><li>重定位节的符号引用。</li></ol><h5 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h5><p>在重定位之前，符号并没有赋值，这个时候就有重定位条目确定我们要怎么把地址赋给每一个符号。</p><p>代码重定位条目存放在.rel.text中，数据重定位条目在.rel.data中。</p><p>重定位条目内容：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Rela</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> offset;<span class="comment">//相对于函数首地址的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> type:<span class="number">32</span>,<span class="comment">//类型</span></span><br><span class="line">        symbol:<span class="number">32</span>;<span class="comment">//对应的符号</span></span><br><span class="line">    <span class="keyword">long</span> addend; <span class="comment">//附加信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里只讲两种基本类型：R_X86_64_PC32(相对引用，32位），R_X86_64_32(绝对引用）。</p><p>这种重定位类型只支持小型代码模型，只能引用-2G到2G的范围。</p><p>下面讲怎么重定位。</p><p>如果是相对地址：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">refaddr = ADDR + <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>offset;<span class="comment">//ADDR是函数首地址，例如main函数首地址，offset是偏移量</span></span><br><span class="line"><span class="comment">//refaddr是需要修改内存的首地址，例如e8 00 00 00 00，后面四个零就是我们要填充的地址，那么refaddr是第一个00的地址</span></span><br><span class="line">*refptr(refaddr地址的内容) = <span class="constructor">ADDR(<span class="params">r</span>.<span class="params">symbol</span>)</span> + r.addend - refaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这一段就是计算相对跳转地址的，addr是对应符号的绝对地址，本来addr-refaddr就是相对跳转地址，但是注意这里的相对跳转地址是当前指令的，而我们要从下一条指令进行跳转，所以要加上一个addend，用下一个指令起始地址来减，所以这里的addend是-4，因为refaddr指向e8后面，加上4就是下一条指令，而因为是末地址减首地址所以addend是负数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绝对地址</span></span><br><span class="line"></span><br><span class="line">refaddr 同上;</span><br><span class="line">*refptr = <span class="constructor">ADDR(<span class="params">r</span>.<span class="params">symbol</span>)</span> + r.addend;</span><br><span class="line"><span class="comment">//这个相对简单，内容就是对应符号绝对地址嘛，但是这里也要加addend因为有可能是数组等因此还要加上数组的偏移量。</span></span><br></pre></td></tr></table></figure></div><h3 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h3><p>过去我们有两种选择进行连接，第一种是把一堆常用函数放到一个可重定向文件中，另一种是把所有常有函数都分开，然后一个个链接。第一种占用空间太大，可能为了一两个函数加了一两千个函数，第二中编译时太难写，所以使用了静态链接库。</p><p>静态链接库集合了上面两种方法，首先它是一个可重定向目标文件。但是不同在于他有一个符号表需要哪个函数就把那个函数链接进去，这样就兼顾上面二者的优点。</p><p>可以使用<code>gcc -static -o prog2c main2.c -L. -lvector</code>其中L是链接库的路径，l是库名，一般库开头都是lib所以lib可以省略，后缀名可以省略。</p><p>可以使用<code>ar rcs libvector.a addvec.o multvec.o</code>来创建静态库，libvector.a是库名</p><p>为了效率考虑，链接时从左向右每个文件只会扫描一次，这样就可能导致问题。例如，最右边的模块有外部符号（引用其他文件的），这时因为扫描已完毕，所以就会报错。</p><p>此外，对于一些常用函数如cout等，如果每个程序都复制一次，那么还是太浪费空间。</p><p>而且如果库函数有错误或者考虑不周需要修改，那么对于绝大多数程序来说都是一个灾难，因为大型程序重新编译一下可能会导致冲突等不可预料的后果。</p><p>为了解决这些问题，提出了动态链接</p><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>动态链接库指的是在程序加载或运行阶段进行链接。在程序开始时（程序不是从main开始，前面还有一段代码负责初始化）会启用动态链接器。</p><h4 id="pic数据引用"><a href="#pic数据引用" class="headerlink" title="pic数据引用"></a>pic数据引用</h4><p>GOT 全局偏移量表，这个表用来存全局变量的地址，在data段开始的地方，而静态链接的时候那些符号的跳转地址都是跳转到这个表中，然后在运行时这个跳转表才会真正赋予地址。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MEL"><figure class="iseeu highlight /mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov <span class="number">0x100010</span>(%rip), %rax</span><br><span class="line">addl $0x1, (%rax)</span><br><span class="line"></span><br><span class="line">第一行就是跳转到跳转表然后取出里面地址，然后第二段取出之歌地址中的值并加一</span><br></pre></td></tr></table></figure></div><p>PLT 过程链接表。举个例子</p><p><img src="/images/%E9%93%BE%E6%8E%A5.jpg" alt></p><p>这个例子是从右上角开始的，先调用函数到了PLT表，之后跳转到GOT[4]所指位置，第一次GOT[4]指向4005c6也就是下一条指令，第一次后GOT[4]就会变成函数地址。</p><p>4005c6是把addvec的ID拖入栈中，然后跳转到GOT[2]的位置同时把GOT[1]放到栈中，GOT[1]是解析函数用到的信息，GOT[2]是动态链接器地址。跳到GOT[2]后就根据栈中的内容链接函数并把GOT[4]的值变成函数首地址。</p><h3 id="库打桩技术"><a href="#库打桩技术" class="headerlink" title="库打桩技术"></a>库打桩技术</h3><p>总体来说库打桩是指自己写一个库然后先于系统库加载这时程序运行的就是你自己写的库了。</p><h4 id="链接时库打桩"><a href="#链接时库打桩" class="headerlink" title="链接时库打桩"></a>链接时库打桩</h4><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(ptr) myfree(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(%d)=%p\n"</span>, (<span class="keyword">int</span>)<span class="built_in">size</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"free(%p)\n"</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>通过上面就可以实现不使用库函数而使用自己的函数了。这个函数便于跟踪内存请求和释放情况。但是每个文件都要写太过麻烦。</p><p>也可以把这个单独写成一个文件，然后通过编译器<code>gcc -Wl ,--wrap,malloc -Wl,--wrap,free -o int1 int.0 mymalloc.o</code>进行链接</p><h4 id="运行时库打桩"><a href="#运行时库打桩" class="headerlink" title="运行时库打桩"></a>运行时库打桩</h4><p>运行时库打桩基于LD_PRELOAD环境变量。在这个变量路径下的库会先于系统库进行加载。</p><p><a href="https://blog.csdn.net/qq_18150497/article/details/78010331" target="_blank" rel="external nofollow noopener noreferrer">更多内容请看</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;记得gcc编译器
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>java 对象的生命周期</title>
    <link href="http://xinhecuican.github.io/post/53677394.html"/>
    <id>http://xinhecuican.github.io/post/53677394.html</id>
    <published>2020-04-27T03:43:00.000Z</published>
    <updated>2020-04-28T07:14:26.884Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><p>有四种显式创建的方式：</p><ul><li>new创建</li><li>运用反射，调用java.lang.Class或java.lang.reflect.Constructor类的newInstance()方法</li><li>调用对象的clone()方法</li><li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射创建</span></span><br><span class="line">Class objClass = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"Customer"</span>)</span>;</span><br><span class="line">Customer cl = (Customer)objClass.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line"><span class="comment">//通过克隆创建</span></span><br><span class="line">Customer c3 = (Customer)c2.clone<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></div><p>通过new或反射的方法创建的时候，都会调用构造方法。但是通过克隆创建不会执行构造方法。在Object类中就定义了clone()方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASPECTJ"><figure class="iseeu highlight /aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object clone()<span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Cloneable))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportException();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这种方式下如果对应类没有实现cloneable接口，那么clone（）方法会抛出异常。<strong>如果想用clone，那么必须要实现Cloneable接口</strong>。</p><p>clone会创建一个对象，对象的属性值相同，但是内存地址不同。</p><p><strong>隐式创建对象</strong></p><ul><li>输入main的参数都会转化成String对象</li><li>+号对String类型创建新对象</li><li>加载一个类时，会创建Class实例</li></ul><p><strong>创建对象步骤</strong></p><ol><li>给对象分配内存</li><li>将实例变量自动初始化成默认值</li><li>初始化对象。例如private int a = 1;在第二步赋值成0，在第三步中才会变成1.</li></ol><p>对于第三步，如果是通过clone的方法创建，那么将原来成员变量的值赋给新的成员变量。如果是用第四种方法，那么是通过输入流读入序列化数据。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法时负责初始化的，可以提供参数，也可以不提供，一般设置一个默认构造函数有好处。</p><ul><li>方法名要与类名相同</li><li>不声明返回类型</li><li>不能被static,final,synchronized,abstract,native修饰</li></ul><p><strong>重载构造方法</strong></p><p>这是为了满足多样化的需求。需要注意一点在一个构造方法中可以用this调用另一个构造方法。但是如果在一个构造方法中使用了this语句，那么它必须在第一行。</p><h4 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h4><p>其实和c++一样，在没有构造方法的时候会提供一个默认构造方法，如果写了一个构造方法那么系统就不会提供构造方法。但是最好要有一个不带参数的构造方法。</p><h4 id="子类调用父类构造方法"><a href="#子类调用父类构造方法" class="headerlink" title="子类调用父类构造方法"></a>子类调用父类构造方法</h4><p>父类构造方法不能被子类继承。在构造子类时，先执行祖先的构造方法，然后一次向下。这样可以确保子类从父类继承的东西可以被使用。可以用super(…)调用父类构造方法。如果没有用super显示构造，那么子类会用父类的默认构造方法。如果子类没有构造方法，将会出现编译错误</p><h4 id="构造方法的访问级别"><a href="#构造方法的访问级别" class="headerlink" title="构造方法的访问级别"></a>构造方法的访问级别</h4><p>这里主要将private的访问级别的意义。</p><p>当构造函数是private时，只有当前类可以访问它。这也代表不能有子类。所以只有一些特殊的场合才会使用它。</p><ol><li>只有静态方法，没有实例方法</li><li>禁止被继承。这个与final的区别就是private不允许其他类创建它的实例，而final可以。</li><li>这个类要把自己封装起来。</li></ol><h3 id="静态工厂办法"><a href="#静态工厂办法" class="headerlink" title="静态工厂办法"></a>静态工厂办法</h3><p>创建实例最常见的方法是用new调用类的构造方法。在这种情况下，可以创建任意多的实例。如果类想要进一步封装创建实例的细节，并控制实例数目，可以用静态工厂的方法。</p><p>静态工厂方法指的是在类中提供一个公有的静态方法，返回类的一个实例。</p><p>静态工厂实际上是一种普通的方法，但是它有平常创建实例时所不具有的灵活性。</p><p><strong>特点一</strong>： 可以有不同于类的名字，这样在重构构造方法时可以更清晰的说明其中的不同，使可读性增大。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Person get<span class="constructor">ManInstance(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">       return <span class="keyword">new</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>, SEX.<span class="params">man</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public static Person get<span class="constructor">WomanInstance(String <span class="params">name</span>, <span class="params">int</span> <span class="params">age</span>)</span>&#123;</span><br><span class="line">       return <span class="keyword">new</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>, SEX.<span class="params">woman</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>一般都喜欢把静态工厂取名为valueof或getInstance。</p><p><strong>特点二</strong>： 可以不创建新对象。重复利用原有对象</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> A init = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">getinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>特点三</strong>： 可以创建子类的实例</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public static <span class="type">A</span> getson()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Sub</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>因为静态工厂每次不一定创建新的实例，所以在一些特殊的场合有应用。</p><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>单例类就是只有一个实例的类，这种类只有一个实例。一般是系统中具有唯一性的组件才会使用。这种类一般要消耗很多内存，为了防止随便开然后爆内存，所以设置成单例类。</p><p>一种办法是提供public static final的静态常量，然后该常量引用唯一实例。在把构造方法定义成private类型。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Globalconfig</span><br><span class="line">&#123;</span><br><span class="line">    public static final GlobalConfig<span class="built_in"> INSTANCE </span>= new GlobalConfig();</span><br><span class="line">    private GlobalConfig();</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另一种办法就是把构造方法定义成private类型，然后提供构造工厂。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Globalconfig</span><br><span class="line">&#123;</span><br><span class="line">    public static final GlobalConfig<span class="built_in"> INSTANCE </span>= new GlobalConfig();</span><br><span class="line">    private GlobalConfig()&#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">    public static GlobalConfig getInstatnces()</span><br><span class="line">    &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>枚举类是实例数目有限的类。比如，表示性别的Gender类，他只会有两个类。</p><p>设计时，同样把构造方法定义成private，然后创建若干个public static final的静态变量。还可以提供静态工厂。另外如果想使用这些实例，直接用类名即可。</p><h4 id="不可变类和实例缓存"><a href="#不可变类和实例缓存" class="headerlink" title="不可变类和实例缓存"></a>不可变类和实例缓存</h4><p>不可变类指的是创建之后就不可以更改属性值，和final类似。例如Long类，String类。</p><p>创建不可变类时，要考虑一下内容：</p><ul><li>把属性定义成final类型</li><li>不对外公开的（private）set方法</li><li>public的get方法</li><li>在构造方法中初始化所有属性</li><li>覆盖Object类的equals()和hashCode()方法。</li></ul><p>对于不可变类，因为数据成员不会改变，所以在创建实例时，如果二者数据成员相同，那么可以共有一份空间，这样就减小了内存消耗。这叫做实例缓存。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(10)</span>;</span><br><span class="line">Integer b = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(10)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(a<span class="operator"> == </span>b);<span class="comment">//会打印true</span></span><br></pre></td></tr></table></figure></div><p>关于两个对象的等于，在<a href="https://xinhecuican.github.io/post/4b1879e3.html">前面一篇博客</a>中已有说明。</p><p>这就说明了两者共用了内存空间。那么我们应该如何实现实例缓存呢？</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> <span class="type">Name</span></span><br><span class="line">&#123;</span><br><span class="line">    private static final <span class="keyword">Set</span>&lt;SoftReference&lt;<span class="type">Name</span>&gt;&gt; names = <span class="built_in">new</span> HashSet&lt;SoftReference&lt;<span class="type">Name</span>&gt;&gt;();//实例缓存，存放<span class="type">Name</span>的软引用</span><br><span class="line">    <span class="built_in">public</span> sattic <span class="type">Name</span> valueOf(String firstname, Stirng lastname)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(SoftReference&lt;<span class="type">Name</span>&gt; <span class="keyword">ref</span>:names)//循环查看是否已经存在</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Name</span> <span class="type">name</span> = <span class="keyword">ref</span>.<span class="keyword">get</span>();//获得软引用的<span class="type">Name</span>对象</span><br><span class="line">            <span class="keyword">if</span>(<span class="type">name</span> != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; <span class="type">name</span>.firstname.equals(firstname)</span><br><span class="line">            &amp;&amp; <span class="type">name</span>.lastname.equals(lastname))</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果缓存中不存在<span class="type">Name</span>对象，就创建新对象，并加入到实例缓存</span><br><span class="line">            <span class="type">Name</span> <span class="type">name</span> = <span class="built_in">new</span> <span class="type">Name</span>(firstname, lastname);</span><br><span class="line">            names.<span class="keyword">add</span>(<span class="built_in">new</span> SoftReference&lt;<span class="type">Name</span>&gt;(<span class="type">name</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="type">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当然，实例缓存也需要消耗内存空间，如果对所有不可变类都使用，可能有的反而会减少内存。当有如下情况时，才会使用实例缓存。</p><ul><li>不可变类实例种类有限</li><li>需要频繁访问某些特定的实例。</li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>在c++中，内存回收是程序员自己负责，因为人难免犯错嘛，可能会导致一系列奇奇怪怪的错误。所以在java中，内存回收是java虚拟机做的。</p><p>只有对象不被任何变量引用时，它的内存才会被回收。当垃圾回收器回收内存时，会先调用该对象的finalize()方法，该方法可能使对象复活，导致垃圾回收器取消回收内存。</p><p>对垃圾回收器来说，程序由三种状态：</p><ol><li>可触及状态：只要还有引用变量引用对象，那么这个对象就处于可触及状态。</li><li>可复活状态： 当程序中没有引用2变量引用时，就进入了可复活状态，复活的关键是finalize方法，这个方法有可能使他复活</li><li>不可触及状态： 也就是调用了finalize状态并且没有复活之后。这种状态下虚拟机才会真正回收内存。</li></ol><h4 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h4><p>finalize()方法就是要销毁时执行的方法，如果finalize方法如果出现异常系统也不会报错而是直接清除。下面讲一下如何把它变成可触及状态。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ghost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Map&lt;<span class="keyword">String</span>, Ghost&gt; ghosts = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>,Ghost&gt;();</span><br><span class="line">    <span class="keyword">String</span> name ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ghost <span class="title">getInstance</span><span class="params">(<span class="keyword">String</span> name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Ghost ghost = ghost(name);</span><br><span class="line">        <span class="keyword">if</span>(ghost == null)</span><br><span class="line">        &#123;</span><br><span class="line">            ghost = <span class="keyword">new</span> Ghost(name);</span><br><span class="line">            ghosts.<span class="built_in">put</span>(name, ghost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ghost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ghosts.<span class="built_in">put</span>(name, <span class="keyword">this</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"execute finalize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个程序在将要被销毁时会调用finalize，之后就把这个对象有放回了Map中，又把这个对象复活了。</p><p>但是实际最好不要用finalize，因为这会扰乱正常的回收机制，导致永远无法回收。</p><p><strong>清除过期引用</strong></p><p>正常情况下，虚拟机都会很好的执行垃圾回收，但是在对象数组等线性结构中，如果只让指针减一，是无法进行垃圾回收的，因为这个数组仍保留对它的引用，但是这个被清除的数据已经无意义了，下面举个例子</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">Object</span>[] elements = <span class="keyword">new</span> <span class="keyword">Object</span>[capacity];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements[--<span class="built_in">size</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个方法的确没什么问题，也可以得到正确的执行，但是实际上size位置的引用并没有被清除，所以当你不断的增加然后开始不断的删除时，这个栈一直在占用大量的空间。所以要想办法除法java的回收机制</p><p>方法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">Object</span> object = elements[--<span class="built_in">size</span>];</span><br><span class="line">    elements[<span class="built_in">size</span>] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="强引用，弱引用，软引用，虚引用"><a href="#强引用，弱引用，软引用，虚引用" class="headerlink" title="强引用，弱引用，软引用，虚引用"></a>强引用，弱引用，软引用，虚引用</h3><p>在早期的java中，并没有各种引用。这些引用代表的是清除的级别，如果空间不够了，那么先清除级别低的，这样对程序造成的影响就小。</p><p>在java.lang.ref包中，有Reference的抽象父类，下面有SoftReference,WeakReference,PhantomRefence，分别代表软引用，弱引用，虚引用。<br>ReferenceQueue表示引用队列，它可以和上面三种引用联合使用，以便跟踪虚拟机回收所引起的对象的活动(具体的现在不清楚）。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用就是普通的引用。如果一个类是强引用，那么除非没有变量引用它，虚拟机绝对不会回收它，甚至空间不足的时候虚拟机抛出OutOfMemoryError也不会回收。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>如果一个对象只有软引用，那么空间足够就会留着它，空间不足就会回收它。前面就有一个软引用的例子。</p><p>软引用可以和引用队列（ReferenceQueue）配合使用，如果软引用所引用的对象被回收，那么虚拟机就会把这个软引用加入到与之关联的引用队列中</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用比软引用更没人权。一旦垃圾回收器发现了弱引用，不管有没有内存，都会回收它。只是因为垃圾回收是一个优先级比较低的线程，所以不一定会很快发现弱引用。</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>弱引用都如此了，虚引用肯定更倒霉。同样也是一旦被发现分分钟清除的货。而且优先级比弱引用还要低。虚引用并不会决定对象生命周期。对象持有虚引用和没有引用一样，如果只有虚引用，还是会被清除。</p><p>弱引用<strong>必须</strong>要和引用队列一起使用。当回收一个对象时，如果发现它有虚引用，那么就会在回收对象之前，把这个虚引用对象加入引用队列中。</p><p>那么它的作用是什么？因为虚引用会被放到引用队列中，所以可以设一个虚引用，然后通过虚引用是否在引用队列中来判断这个对象时候要被回收。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">"hello"</span>);<span class="comment">//创建强引用</span></span><br><span class="line">ReferenceQueue&lt;<span class="keyword">String</span>&gt; rq = <span class="keyword">new</span> <span class="type">ReferenceQueue</span>&lt;<span class="keyword">String</span>&gt;();<span class="comment">//创建引用队列</span></span><br><span class="line">WeakReference&lt;<span class="keyword">String</span>&gt; wf = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;<span class="keyword">String</span>&gt;(str,rq);<span class="comment">//创建弱引用</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;创建对象的方式&quot;&gt;&lt;a href=&quot;#创建对象的方式&quot; class=&quot;headerlink&quot; title=&quot;创建对象的方式&quot;&gt;&lt;/a&gt;创建对
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="http://xinhecuican.github.io/post/50daec4.html"/>
    <id>http://xinhecuican.github.io/post/50daec4.html</id>
    <published>2020-04-26T11:54:00.000Z</published>
    <updated>2020-04-26T13:44:22.709Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="AOV网络"><a href="#AOV网络" class="headerlink" title="AOV网络"></a>AOV网络</h3><p>aov网络指的是用顶点表示活动的网络。讲个例子吧</p><p>例如学习课程有个前后顺序，前面一门课没有学完后面一门课动不了手。这样就可以用顶点表示课程，然后用有向箭头表示学习的次序，这样就是一种AOV网络。并且显然每个点都要走，因为每门课都要学。</p><p><img src="/images/%E7%BD%91%E7%BB%9C1.PNG" alt="后面这个数字代表先修课程"><br><img src="/images/%E7%BD%91%E7%BB%9C2.PNG" alt></p><p>检测有向环可以用对AOV网络构造拓扑序列。构造方法等会讲，如果有环，那么就会出现永远都有入度的情况，就说明有环。</p><p><strong>构造过程</strong></p><p>就拿上面一个图来说吧。必须先要学完c1，c2才可以学c3.学了c1又可以学c8，按照这样的顺序就可以得出学习顺序是C1C2C3C5C4C8C9C7C6。当然，还有许多其他的次序。</p><p>从中我们可以发现一个规律，假如每当我们学一门课就删去这些边，那么我们可以学习一个课程时入度一定为0.例如我们学完1和2后3入度就是0所以现在我们可以学了。如果入度不为0说明我们还有前置知识我们没有掌握，就不能学。</p><p>总结：找出入度为0的点，删去与之相邻的边，然后找新的入度为0的点，重复上述过程。</p><p>下面给出模板：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAXIMA"><figure class="iseeu highlight /maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    int val;//边权</span><br><span class="line">    int <span class="built_in">last</span>;</span><br><span class="line">    edge* next;</span><br><span class="line">&#125;;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int insum;//入度</span><br><span class="line">    edge* <span class="built_in">first</span>;</span><br><span class="line">&#125;;</span><br><span class="line">node nod[<span class="number">100</span>];//随便设的数字，也可以<span class="built_in">new</span>来构建</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nod[i].<span class="built_in">first</span> = NULL;</span><br><span class="line">        nod[i].insum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void addedge(int <span class="built_in">sum</span>, int <span class="built_in">first</span>, int <span class="built_in">last</span>)</span><br><span class="line">&#123;</span><br><span class="line">    //用后插法</span><br><span class="line">    edge* temp = <span class="built_in">new</span> edge;//needfree</span><br><span class="line">    temp-&gt;val = <span class="built_in">sum</span>;</span><br><span class="line">    temp-&gt;<span class="built_in">last</span> = <span class="built_in">last</span>;</span><br><span class="line">    temp-&gt;next = nod[<span class="built_in">first</span>].<span class="built_in">first</span>;</span><br><span class="line">    nod[<span class="built_in">first</span>].<span class="built_in">first</span> = temp;</span><br><span class="line">    nod[<span class="built_in">last</span>].insum++;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">sum</span>, <span class="built_in">first</span>, <span class="built_in">last</span>;</span><br><span class="line">    node* tempnode;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;<span class="built_in">sum</span>&gt;&gt;<span class="built_in">first</span>&gt;&gt;<span class="built_in">last</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addedge(<span class="built_in">sum</span>, <span class="built_in">first</span>, <span class="built_in">last</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node* aovstack = <span class="built_in">new</span> node;//needfree,链栈，用来存放入度为<span class="number">0</span>的节点</span><br><span class="line">    int <span class="built_in">time</span> = <span class="number">0</span>;//记录栈中有多少元素</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nod[i].insum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tempnode = nod[i];</span><br><span class="line">            tempnode-&gt;<span class="built_in">first</span> = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">            aovstack-&gt;<span class="built_in">first</span> = tempnode;</span><br><span class="line">            <span class="built_in">time</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">time</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">time</span>--;</span><br><span class="line">        tempnode = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">        node* temp = aovstack;</span><br><span class="line">        aovstack = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">        <span class="built_in">delete</span> temp;</span><br><span class="line">        edge* tempedge = tempnode-&gt;<span class="built_in">first</span>;</span><br><span class="line">        <span class="keyword">while</span>(tempedge != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(--nod[tempedge-&gt;<span class="built_in">last</span>].insum == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">time</span>++;</span><br><span class="line">                tempnode = nod[tempedge-&gt;<span class="built_in">last</span>];</span><br><span class="line">                tempnode-&gt;<span class="built_in">first</span> = aovstack-&gt;<span class="built_in">first</span>;</span><br><span class="line">                aovstack-&gt;<span class="built_in">first</span> = tempnode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/******************</span></span><br><span class="line"><span class="comment">            *output...</span></span><br><span class="line"><span class="comment">            ***************/</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***************</span></span><br><span class="line"><span class="comment">    * delete...</span></span><br><span class="line"><span class="comment">    *******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="AOE网络"><a href="#AOE网络" class="headerlink" title="AOE网络"></a>AOE网络</h3><p>这个是用边表示活动，顶点表示事件。</p><p><img src="/images/%E7%BD%91%E7%BB%9C3.PNG" alt></p><p>这是一个AOE网络图，注意和上面类似这里每一条边都是要到的。我们要找的就是花费时间最长的那条路，因为那条路走完了所有活动才完成。那么这条路叫做关键路径，这条路径上的活动叫做关键活动。如果我们想缩短工期的时间，那么我们就要先缩短关键活动的时间。</p><p><strong>几个名词</strong></p><p>事件最早可能开始时间 ve(i)</p><p>事件最迟允许开始时间 vl(i)</p><p>活动最早可能开始时间 e[i]</p><p>活动最迟开始时间 l[i]</p><p><strong>所以关键活动就是 e[i] == l[i]</strong> ，因为最早时间和最晚时间相同说明耽误不得。</p><p><strong>求法</strong></p><p>代码比较简单，这里只讲一下思路。</p><p>同样使用邻接表。用四个数组分别表示上面四个名词。首先求前面两个。</p><p>事件最早时间这么多到那个点的路径中最晚的那个。例如上面的6点应该是40而不是30，因为只有最晚的那个完成了才能算真正到了那个点。</p><p>事件最晚开始时间要从后往前算。最后那个点的最晚开始时间我们一般是知道的，就是截至时间。然后往前面去减，如果有多条路径到那个点就选最小的。同样的道理因为所有边走完这件事才算做完了，如果你选大的相当于到最后那个点的所需时间少，结果这边走完了那个时间小的还没有走完。</p><p>举个例子：假设8点的截至时间是60，那么4点的截至时间应该是从8到7到5那一条。</p><p>活动最早开始时间是活动的起点的最早开始时间</p><p>活动的最晚开始时间是活动的终点的最晚开始时间减去这条边的权</p><p><img src="/images/aoe%E7%BD%91%E7%BB%9C.PNG" alt></p><p>从这个代码中我们看出每个顶点遍历就可以了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;AOV网络&quot;&gt;&lt;a href=&quot;#AOV网络&quot; class=&quot;headerlink&quot; title=&quot;AOV网络&quot;&gt;&lt;/a&gt;AOV网络&lt;/h3
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>java 类的生命周期</title>
    <link href="http://xinhecuican.github.io/post/61eaf19a.html"/>
    <id>http://xinhecuican.github.io/post/61eaf19a.html</id>
    <published>2020-04-26T03:33:00.000Z</published>
    <updated>2020-04-27T03:42:48.272Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="类的加载连接和初始化"><a href="#类的加载连接和初始化" class="headerlink" title="类的加载连接和初始化"></a>类的加载连接和初始化</h3><ol><li><p>加载： 查找并加载类的二进制数据</p></li><li><p>链接： 包括验证，准备和解析类的二进制数据</p><ul><li>验证： 确保加载类的正确性。</li><li>准备： 为类的静态变量分配内存，将其初始化为默认值（也就是0）</li><li>解析： 将类的符号引用<a href="符号引用就是在编译阶段，虚拟机并不知道所有引用类的地址（因为还没有加到内存中），就用一个符号表示地址。而直接引用就是真实的地址。">^1</a>变成直接引用</li></ul></li><li><p>初始化： 把类的静态变量赋予正确的初始值。</p></li></ol><h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><p>类的加载是指把类的.class文件中的二进制数据读入到内存中，把它存放在方法区中。然后再兑取川家一个java.lang.Class对象，用来封装类在方法区的数据结构。<strong>通俗的来讲就是把代码加载到内存中</strong>。</p><p>类的加载是由虚拟机自带的加载器来完成的，但是我们也可以自己去定义。用java.lang.ClassLoader类的子类的实例。</p><p>类加载器允许某个类将要被使用时预先加载它。如果预先加载过程中遇到了.class的错误。那么类加载器在首次主动使用这个类的时候报错（LinkageError)</p><h4 id="类的链接"><a href="#类的链接" class="headerlink" title="类的链接"></a>类的链接</h4><p><strong>类的验证</strong></p><p>类的验证主要验证一下内容：</p><ul><li>类文件格式， 看看后缀是否符合</li><li>语义检查 看看是否符合java语义（例如把一个String给int或final是否有子类）</li><li>字节码验证，字节码代表java方法。</li><li>二进制兼容验证。查看这个类引用的另一个类的方法的=在另一个类中是否存在。</li></ul><p><strong>类的准备</strong></p><p>为类的静态变量分配内存，并设置成0（boolean是false，char是’\u0000’)</p><p><strong>类的解析</strong></p><p>符号引用上面已经解释过了，其实也就是这个类引用的其他类或其他类的成员变量和方法等。因为这些类在编译阶段并没有加载，所以虚拟机也不知道要到哪里去找这些方法，所以先弄一个符号代表这个方法。</p><h4 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h4><p>静态变量的初始化有两种途径。（1） 声明时直接赋值 （2） 在静态代码块中初始化。</p><p>初始化并不是直接初始化。如果没有加载和链接，那么先加载和链接。如果父类没有初始化，那么先初始化父类。</p><p>虚拟机只有首次启用一个类的时候才会初始化它。也就是说，创建对象实例，或者访问使用静态变量，还有是某个正在初始化类的父类时都会初始化它。</p><p>此外，当final类型的静态变量，如果能直接计算出值，那么会当成常量，不会导致初始化。反之，会导致初始化。</p><h3 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h3><p>类加载和Linux进程生成类似，都是先有一个根加载器，然后其他类加载器只有一个父加载器。父加载器不是加载自己，而是加载子类，但是是子类请求父类加载自己。</p><p>有三类自带的加载器：</p><ul><li>根加载器，负责加载一些核心库，例如java.lang.*</li><li>扩展加载器，它的父加载器是根加载器。他从java.ext.dirs系统属性指定的目录中加载扩展。或者从JDK的jre\lib\ext中加载扩展</li><li>系统加载器：也叫应用类加载器。它的父加载器是扩展加载器。他从classpath环境变量或者子系统属性java.class.path中加载类，它是用户自定义加载器的默认父加载器。</li></ul><p><strong>类加载的过程</strong></p><p>例如要加载一个类，首先请求父类加载器代为加载，父类再向它的父类代为加载…。一直到根加载器，如果根加载器不能加载，那么就让扩展加载器加载，如果不能加载…。直到找到一个可以加载的。如果所有加载器都不能加载，那么返回ClassNotFoundException。</p><p>成功加载那个类的加载器叫定义类加载器。</p><p>这种机制是为了安全考虑，因为在这种严密的机制下，用户自定义的加载器不可能取代由父加载器完成的任务。</p><p>这里加载器并不一定是和类一样的父子关系。一对父子加载器可能是同一个类的两个实例。</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>每个类加载器都有自己的命名空间，命名空间由该加载器和所有父加载器所加载的类组成。在同一个命名空间中，不可能出现名字（包括包名）完全相同的两个类。不同的命名空间中就有可能出现。</p><h4 id="运行时包"><a href="#运行时包" class="headerlink" title="运行时包"></a>运行时包</h4><p>同一加载器加载的属于相同包的类组成了运行时包。包名相同不一定默认访问级别可以访问，必须要组成运行时包才可以访问默认访问级别。</p><h3 id="创建用户自定义加载器"><a href="#创建用户自定义加载器" class="headerlink" title="创建用户自定义加载器"></a>创建用户自定义加载器</h3><p>首先介绍自定义类的应用场景：</p><p>（1）加密：Java代码可以轻易的被反编译，如果你需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用Java的ClassLoader去加载类了，这时就需要自定义ClassLoader在加载类的时候先解密类，然后再加载。</p><p>（2）从非标准的来源加载代码：如果你的字节码是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。</p><p>（3）以上两种情况在实际中的综合运用：比如你的应用需要通过网络来传输 Java 类的字节码，为了安全性，这些字节码经过了加密处理。这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出在Java虚拟机中运行的类。</p><p>要扩展自己的类加载器，只需扩展java.lang.Classloader类，瑞啊后覆盖findClass(String name)方法。该方法根据参数指定类的名字，返回对应Class对象的引用。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.<span class="keyword">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyClassLoader <span class="keyword">extends</span> ClassLoader</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyClassLoader()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> MyClassLoader(ClassLoader parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"D:/People.class"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(<span class="keyword">file</span>);</span><br><span class="line">            <span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</span></span><br><span class="line">            <span class="keyword">Class</span>&lt;?&gt; c = <span class="keyword">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(<span class="keyword">File</span> <span class="keyword">file</span>) <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里要读入.class的字节，因此要使用字节流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">file</span>);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.<span class="keyword">read</span>(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.<span class="keyword">write</span>(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p><a href="https://blog.csdn.net/SEU_Calvin/article/details/52315125" target="_blank" rel="external nofollow noopener noreferrer">这段代码是扒下来的</a></p><h4 id="URLClassLoader加载类"><a href="#URLClassLoader加载类" class="headerlink" title="URLClassLoader加载类"></a>URLClassLoader加载类</h4><p>在java.net包中，提供了URLClassLoader类，它可以从网上下载类。可以直接使用这个类作为自定义加载器。</p><p>构造方法: <code>URLClassLoader(URL[] urls)//父加载器是系统加载器</code></p><p><code>URLClassLoader(URL[] urls, ClassLoader parent)//指定父加载器</code></p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>java自带类加载器所加载的类是永远不会被卸载的。而用户自定义的类加载器可以被卸载。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;类的加载连接和初始化&quot;&gt;&lt;a href=&quot;#类的加载连接和初始化&quot; class=&quot;headerlink&quot; title=&quot;类的加载连接和初始化
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 异常处理</title>
    <link href="http://xinhecuican.github.io/post/e058ffd8.html"/>
    <id>http://xinhecuican.github.io/post/e058ffd8.html</id>
    <published>2020-04-25T05:40:00.000Z</published>
    <updated>2020-04-26T03:18:26.332Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>有两种办法抛出异常：</p><ul><li>通过try-catch抛出，例如</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span> <span class="title">A</span><span class="params">(int money)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    try</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        if(--money&lt;=0)</span></span></span><br><span class="line"><span class="function"><span class="comment">        &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">            throw new SpecialException("Outof money");</span></span></span><br><span class="line"><span class="function"><span class="comment">        &#125;</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="title">catch</span><span class="params">(SpecialException e)</span></span></span><br><span class="line"><span class="function">    <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        处理异常</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><ul><li>在方法声明处声明抛出</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span> <span class="title">A</span><span class="params">(int money)</span><span class="title">throws</span> <span class="title">SpecialException</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    if(--money&lt;=0)</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        throw new SpecialException("Out of money");</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><p>每次抛出异常之后，都要找到catch块，如果在当前方法中没有找到，那么它将会弹出栈帧，到了上一级继续寻找知道找到。找到之后就执行catch块内容然后退出。</p><p>如果到最底部也没有找到catch块，那么就调用异常对象的printStackTrace()方法，打印异常信息。</p><p>如果该线程不是主线程，那么就会退出这一个线程，如果是主线程（main），那么就会退出程序。</p><p>抛出异常和处理异常最好在同一方法，不然对性能影响较大。</p><h4 id="finally-在任何情况下都要执行的代码"><a href="#finally-在任何情况下都要执行的代码" class="headerlink" title="finally 在任何情况下都要执行的代码"></a>finally 在任何情况下都要执行的代码</h4><p>因为异常处理会打断正常进程，所以可能会导致一些占用的资源不会被释放。在c++中就是动态内存分配的问题，在java中额例如关闭数据库链接，关闭输入流。</p><p>finally跟在catch后面，并且一定不能在前面。</p><h4 id="throws-抛出可能的异常"><a href="#throws-抛出可能的异常" class="headerlink" title="throws 抛出可能的异常"></a>throws 抛出可能的异常</h4><p>如果一个方法需要抛出异常，但没有能力解决异常，可以在方法头声明throws语句，在前面已经举过例子了。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>try后面可以有多个catch块，只能有至多一个finally块，也可以只跟finally块。</li><li>在try块中定义的变量，在catch和finally中不能访问。</li><li>每当try后面有多个catch时，会依次对catch块进行匹配，只需要匹配同一继承分支上的父类就会执行。例如， IOException是Exception的子类，如果抛出IOExpception且Exception的catch块在前那么就只会执行Exception。例：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code1;<span class="comment">//抛出FileNotfoundException</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLExceptio e)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"SOLException"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Exception"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"IOException"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个只会输出Exception，因为Exception和FileNotFoundException在还有IOException在同一继承分支上，每一次直接走Exception了，而不会走IOException。<strong>所以让子类的catch在前面，防止错误的catch</strong>。</p><ul><li>为了简化，可以用 | 分隔两个异常在一个catch块中进行处理。例如 catch( FileNotFoundException | InterruptedIOException e){…}</li><li>如果一个地方出现受检查异常，要么用throws，要么用try，不然会出现编译错误（这样也就方便些try了，不然写代码的时候还真不好说哪里有异常）。</li></ul><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p>正常流程是捕捉异常，执行catch，执行finally，退出。有两种退出方式</p><p>第一种使用System.exit(number);这种方法会直接退出程序，</p><p>第二种是return，退出本方法，这个时候如果有返回值还可以弄个返回值以便其他部分正常运行。finally执行于return之前。一般return是在catch中的，但是也可以在finally中，但是这样可能会导致问题。</p><ul><li>返回值覆盖，因为catch执行于return之前，所以如果要执行catch中的return，会先执行finally中的return，这个时候catch中的return就不会执行了。</li><li>丢失异常，如果在catch中抛出异常且finally中有return就可能发生异常丢失。这个时候catch中的异常就不会被抛出。此外，如果catch和finally中都抛出异常，那么catch中的异常将会丢失。</li></ul><p>为了解决丢失异常的问题，Throwable接口中有两个默认实现的方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> addSuppressed(Throwable exception)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Throwable[] getSuppressed()</span><br></pre></td></tr></table></figure></div><p>其中addSuppressed()方法就是把丢失的异常保存下来，getSuppressed就是返回所有保存下来的异常。当然，并不是系统自动添加，还要手动用这些方法去添加。</p><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p>java中用类来描述异常。所有异常的祖先是java.lang.Throwable类。它的实例就是具体的异常，可以通过throw抛出。它提供了一些常用方法，包括</p><ul><li>getMessage() 返回String类型的异常信息</li><li>printStackTrace() 打印跟踪方法调用栈获得的详细异常信息</li></ul><p>例如catch到这个异常后，可以<code>System.out.println(e.getMessage())</code>来输出异常信息。例如e里面的信息时Out of money（就是前面的），那么就会输出这个异常信息。</p><p>而如果用后面那个方法，将会说明哪个类，哪一行出现了异常。</p><p><img src="/images/20160603151809323" alt="异常类图"></p><ul><li>Error类，表示单靠程序本身无法恢复的严重错误，例如内存不足，或者栈溢出。</li><li>Exception类，表示程序可以处理的异常。出现这些异常时，可以进行处理而不退出程序。</li><li>IOException 输入输出时产生的异常。</li><li>ArithmeticException 数学异常。例如除以0</li><li>NullpointerException，空指针异常。当引用变量时null是，试图使用这个变量将会出现。</li><li>IndexOutOfBoundsException 下标越界异常</li><li>ClassCastException 类型转换异常，例如父类转子类</li><li>IllegalArgumentException 非法参数，例如 if(name==null)throw new IllegalArgumentException(“姓名不能为空”)。</li></ul><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>RuntimeException一个子树都可以叫运行时异常。这种异常特点是编译器不会检查他。例如上面说的数学异常。当这种异常出现的时候程序将异常终止。其他的都是受检查异常。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>可以通过继承来实现自定义异常。一般挂在Exception或RuntimeException上。</p><p>自定义异常要一般要写以下部分。</p><p>异常数据，异常原因（String类型），然后是一个带参数的构造函数。之后提供方法说明这个异常。</p><h4 id="异常转义异常链"><a href="#异常转义异常链" class="headerlink" title="异常转义异常链"></a>异常转义异常链</h4><p>原始的异常对于用户来说看不懂，这个时候我们就要抛出一些更人性化的异常。但是与此同时我们也要把原始异常保存易于我们排错。这个时候我们就可以在原始异常上进行扩展。扩展类的数据域中可以来一个Throwable的引用变量，然后在构造函数中把原始异常导入。这样就保存了原始异常。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Throwable</span> cause = <span class="literal">null</span>;</span><br><span class="line">    public <span class="type">BaseException</span>();</span><br><span class="line">    public <span class="type">BaseException</span>(<span class="type">Throwable</span> cause)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">BaseException</span>(<span class="type">String</span> msg, <span class="type">Throwable</span> cause)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div><h4 id="处理多样化异常"><a href="#处理多样化异常" class="headerlink" title="处理多样化异常"></a>处理多样化异常</h4><p>就是一次性抛出多个异常，这就需要先自定义一个异常类，收集多种异常然后一次性输出。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> int size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">List</span>&lt;<span class="type">Throwable</span>&gt;exceptions = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="type">Throwable</span>&gt;();</span><br><span class="line">    public void addExcpetion(<span class="type">BaseException</span> ex)</span><br><span class="line">    &#123;</span><br><span class="line">        exceptions.add(ex);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>记录日志的作用：监视代码中变量情况，周期性的记录到文件中供其他应用统计分析。承担继承开发环境中调试器作用。</p><p>要在程序中输出日志，最普通的办法是用println输出。比较好的做法是用一个日志操作类。</p><p>现在可以直接使用java.util.logging日志操作包。这个包中主要有四个类</p><ul><li>Logger类：生成日志，并对日志信息分级筛选，确定什么等级被输出，什么不输出。</li><li>Handler： 负责输出日志信息。它有两个子类：ConcoleHandler（输出到Dos控制台），FileHandler（输出到文件中）</li><li>Level类： 表示日志各个界别。</li></ul><h4 id="创建及设置级别"><a href="#创建及设置级别" class="headerlink" title="创建及设置级别"></a>创建及设置级别</h4><p>创建 <code>Logger mylogger = Logger.getLogger(&quot;mylogger&quot;);</code></p><p>getlogger就是用来创建对象的。如果mylogger存在，那么直接返回引用。</p><p>级别： SEVERE(严重）， WARNING(警告），INFO , CONFIG(确认），FINE（好），CONFIG,FINE,FINER,FINEST</p><p>默认情况下，只会输出最高三个级别的。可以使用Logger类的setLevel()来设置级别。例：<code>mylogger.setLevel(&quot;Level.FINE&quot;)//把日志设置成FINE级别</code>。这样设置FINE及以上级别都会被设置。还有Level.on开启所有级别和Level.off关闭所有级别。</p><p><code>mylogger.info(&quot;这是一条普通提示消息&quot;)</code>用级别的名字设置提示消息</p><h4 id="输出日志到文件"><a href="#输出日志到文件" class="headerlink" title="输出日志到文件"></a>输出日志到文件</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileHandler fileHandler = <span class="keyword">new</span> <span class="constructor">FileHandler(<span class="string">"C:\\test.log"</span>)</span>;</span><br><span class="line">fileHandler.set<span class="constructor">Level(Level.INFO)</span>;<span class="comment">//设定向文件中写日志的级别</span></span><br><span class="line">mylogger.add<span class="constructor">Handler(<span class="params">fileHandler</span>)</span>;<span class="comment">//将FileHandler与Logger关联</span></span><br></pre></td></tr></table></figure></div><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>语法： assert 条件表达式 或 assert 条件表达式 : 包含错误信息的表达式。</p><p>作用： 当条件表达式为false时，会抛出AssertError，这是一个错误。如果后面有包含错误信息的表达式，那么将会输出后面的内容</p><p>例如： assert b!=0 : ”b不能为0“；</p><p>启用断言需要-ea参数，而IDEA中默认是关闭的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;异常处理流程&quot;&gt;&lt;a href=&quot;#异常处理流程&quot; class=&quot;headerlink&quot; title=&quot;异常处理流程&quot;&gt;&lt;/a&gt;异常处理流程
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="http://xinhecuican.github.io/post/5951da65.html"/>
    <id>http://xinhecuican.github.io/post/5951da65.html</id>
    <published>2020-04-23T08:39:00.000Z</published>
    <updated>2020-04-29T06:54:03.005Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="接口的基本特征"><a href="#接口的基本特征" class="headerlink" title="接口的基本特征"></a>接口的基本特征</h3><p>在java中接口有两种意思</p><ul><li>第一种是概念性的接口，指的是封装的内容对外界提供的服务（一开始一听接口一定以为就是这个吧）</li><li>第二种是一种接口类型</li></ul><p>定义接口使用interface关键字，实现接口使用implement关键字。这个类似于父类和子类。</p><p>注意点：</p><ul><li>接口成员变量默认是public或static或final类型的，必须显示初始化。例如<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> b;</span><br><span class="line">    <span class="built_in">int</span> c = <span class="number">3</span>;<span class="comment">//正确，显式初始化表示定义同时要赋值，并且默认是上面三种类型</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure></div></li><li>方法默认是public abstract类型。JDK8开始才可以有默认方法和静态方法之前只能有抽象方法。默认方法用<strong>default关键字</strong>声明，可以有自己的实现，接口实现类可以直接访问默认方法，也可以覆盖它。静态方法可以在接口内部访问或者实现接口的类通过使用接口名字来访问。<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span>;<span class="comment">//默认是public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method3</span>(<span class="params"></span>)</span>;<span class="comment">//编译器默认是public的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span>(<span class="params"></span>)</span>;<span class="comment">//不可以，必须要有abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li>接口没有构造方法，不能够被实例化</li><li>接口可以继承于多个接口，但是不能实现接口。例如：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">&#125;</span><br><span class="line">public<span class="built_in"> interface </span>B</span><br><span class="line">&#123;&#125;</span><br><span class="line">public<span class="built_in"> interface </span>C extends A,B</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>与子类继承抽象父类相似，当类实现某个接口时，<strong>必须要重写接口中的所有抽象方法，否则这个类必须定义成抽象类</strong>。</li><li>不允许创建接口的实例，但允许创建接口类型的引用变量，该变量引用实现了接口的类的实例（也可以看成是子类的实例）</li><li>一个类只能够继承一个父类，但可以实现多个接口。例如：<br><code>public class A extends Base implement intera, interb{...}</code>。并且一个接口也可以由多个类来实现。</li></ul><p>接口可以在一定程度上弥补一个类只能有一个直接父类的遗憾，有利于扩展。</p><h3 id="接口模式"><a href="#接口模式" class="headerlink" title="接口模式"></a>接口模式</h3><h4 id="定制服务模式"><a href="#定制服务模式" class="headerlink" title="定制服务模式"></a>定制服务模式</h4><p>这种模式就是利用接口可以继承多个接口，把多个子功能整合到一起变成一个大的服务。例如一个套餐里面有流量服务，电话服务，语音服务等等。这些都是一个接口。之后整合成整个的套餐包含上述服务</p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>适配器就是用来做两个系统之间转换的。有两种方式实现转换。</p><p>第一种就是通过继承，继承源类的实例和目标类的接口。</p><p>第二种是通过组合，组合两种类的接口，然后实现。</p><p>例如，一个接口有add（a,b)函数，另一个有addone(a)函数，第二个函数不能作用是让a+1，但是它没有加法（假设）。这时我们设计一个接口，继承上面两个接口，这样我们就有办法用原接口的实现类从而实现加法完成第二个方法。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>这种适配器其实是一个类，因为接口中都是抽象函数，所以当你使用适配器的时候不得不实现所有功能-即使你只想实现一个。所以干脆实现了一种类，这个类实现了所有抽象方法，但是内容全是空。这样再用其他类继承这个类就可以一次实现一种了。</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理人其实就是中间人，代理类和代理人类似，这个类负责预处理一些消息，例如钱少于多少就直接拒绝。也负责向委托类传递信息。</p><h4 id="标识类型模式"><a href="#标识类型模式" class="headerlink" title="标识类型模式"></a>标识类型模式</h4><p>标识类型一般是标识某一类事物。例如事物，树，人物等等。使用这种接口而不是直接使用一个类的好处是便于同一管理。</p><h4 id="常量接口"><a href="#常量接口" class="headerlink" title="常量接口"></a>常量接口</h4><p>常量接口就是把一些常量放到一起。要使用的时候直接implements就可以了。</p><p>但是这种接口有一个弊端，就是破坏了封装性。为了解决这个问题，可以使用import static语句。import static允许直接访问另一个类的静态常量</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;接口的基本特征&quot;&gt;&lt;a href=&quot;#接口的基本特征&quot; class=&quot;headerlink&quot; title=&quot;接口的基本特征&quot;&gt;&lt;/a&gt;接口的
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 继承和多态</title>
    <link href="http://xinhecuican.github.io/post/17862176.html"/>
    <id>http://xinhecuican.github.io/post/17862176.html</id>
    <published>2020-04-22T09:00:00.000Z</published>
    <updated>2020-05-05T09:00:02.070Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>利用extends来进行继承，例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以上表明Sub类继承Base类，具体继承还要分两种情况。</p><ul><li>如果在同一个包中，那么Sub继承了Base中的public，protected和默认访问级别的成员变量和方法</li><li>如果在不同的包中，不继承默认访问级别的成员变量和成员方法，其他和上一个相同。</li></ul><p>默认访问级别就是前面没有加任何关键字。</p><p>java不支持多继承，一个类只能继承于一个类，但是父类可以有多个子类，就像一棵树。下级继承会继承同一分支上所有的成员和方法。</p><p>java中有一个所有类的祖先叫object类，如果没有使用extends关键字那么会自动继承这个类。</p><h3 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h3><p>覆盖指的是父类中的函数在子类中重新写。要满足下列条件：</p><ul><li>子类方法名称，函数签名（包括参数位置）和返回类型都要和父类方法一致</li><li>在子类中，必须要先覆盖函数，才可以重写函数</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OXYGENE"><figure class="iseeu highlight /oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Base类中：</span><br><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Sub</span>类中：</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">int</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">这样会报错</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果<span class="title">Sub</span>类这样</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">int</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function">这样可以编译通过</span></span><br></pre></td></tr></table></figure></div><ul><li>子类方法不可以缩小父类的访问权限，如果父类的方法时private那么子类就不能写public</li><li>子类不能抛出比父类更多的异常</li><li>子类无法覆盖父类的静态方法，只能够隐藏。这两者的区别是覆盖的话父类可以使用子类的，子类也可以使用父类的。隐藏的话父类只能使用父类的，子类只能使用子类的。这是由于static定义的区域所决定的。<br>例：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package newpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------</span><br><span class="line">package newpackage;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newsec</span> <span class="title">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Sub"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Sub"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base a = <span class="keyword">new</span> newsec();</span><br><span class="line">        a.method();</span><br><span class="line">        a.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出时Base和Sub</span><br></pre></td></tr></table></figure></div><ul><li>可以扩大访问权限。并且如果是抽象类，子类可以只扩大访问范围而不做任何事.但是必须要实现它，不然只能让子类也定义成抽象类。</li></ul><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">父类定义类A()的抽象方法，子类可以这样</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">这也算实现</span><br></pre></td></tr></table></figure></div><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super和this一样都是指向一个对象，不同的是super指向父类，this指向自己。</p><p>使用场合：</p><ul><li>局部变量和类变量重名</li><li>子类覆盖了父类的方法或成员变量时，可以用这种方法使用父类的方法</li></ul><p>需要注意，如果父类成员变量和方法被定义成private，那么子类无论如何都无法访问他们。不能再静态方法区使用super关键字。</p><p>此外如果在父类第一行使用super()是调用父类构造函数</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是父类可以使用子类，子类也可以使用父类（自我理解）。下面讲具体使用规范。<br>儿子可以用爸爸一切公有的，而爸爸如果引用了自己的实例就不能用儿子的，只有引用了儿子的实例才可以使用儿子继承于爸爸的。</p><ul><li>对于一个引用类型变量，编译器按声明变量进行处理。例如</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MIPSASM"><figure class="iseeu highlight /mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Base </span>who = new <span class="keyword">Sub();</span></span><br><span class="line"><span class="keyword">who.subVar </span>= <span class="string">"123"</span>;</span><br><span class="line">这里编译会出错，无论后面引用了谁，who都是<span class="keyword">Base类，而父类不能直接使用子类的变量</span></span><br></pre></td></tr></table></figure></div><ul><li><p>编译器允许继承分支关系的类进行类型转换。对于向上转型（子类使用父类的），编译器会自动类型转换。对于向下转型则需要强制类型转换。在运行时，子类可以转换成父类，但是父类实际上无法转换成子类。因为父类有的子类一定有，子类有的父类却不一定有。</p></li><li><p>对于引用对象绑定，遵循如下规则</p><ol><li>对于实例方法和引用变量是由实际使用的对象进行绑定。这个是动态的，也就是说方法的实际输出是由实际类型所决定。例如 Base a = new Sub();输出时Sub的。如果这个时候Sub的子类b = a;那么输出还是Sub的。但是如果使用了子类中独有的方法会报错</li><li>静态方法和成员变量由前面定义的类型所决定，这属于静态绑定，在编译时期已经决定。无论引用了谁都不会改变。</li></ol></li></ul><h3 id="继承的使用"><a href="#继承的使用" class="headerlink" title="继承的使用"></a>继承的使用</h3><p>继承树的最上层一般是抽象层。并且继承树上有接口类型，那么尽可能的把应用变量声明成继承树上层的接口类型。因为实例可以是子类，向上转型不会出现问题，这样便于使用多个子类，如果想用子类独有的东西就把引用变量定义成子类。</p><p>继承关系会打破封装，因为上层类改变会使下层类也跟着改变。所以对上层类定义要谨慎。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><table><thead><tr><th>修饰符</th><th>类</th><th>成员方法</th><th>构造方法</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>abstract（抽象的）</td><td>有</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>static（静态的）</td><td>无</td><td>有</td><td>无</td><td>有</td><td>无</td></tr><tr><td>public</td><td>有</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>protected</td><td>无</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>private</td><td>无</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>synchronized（同步的）</td><td>无</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>native（本地的）</td><td>无</td><td>有</td><td>无</td><td>无</td><td>无</td></tr><tr><td>transient（暂时的）</td><td>无</td><td>无</td><td>无</td><td>有</td><td>无</td></tr><tr><td>volatile（易失的）</td><td>无</td><td>无</td><td>无</td><td>有</td><td>无</td></tr><tr><td>final（不可改变的）</td><td>有</td><td>有</td><td>无</td><td>有</td><td>有</td></tr></tbody></table><p>表中的类指的是顶层类，与内部类相对应（内部类是定义在类或方法中的类）。</p><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><p>访问控制指的是其他类或对象可以查看的东西。一共有四种访问级别</p><ul><li>public 所有都是可以给外部看的</li><li>protected 只对子类和一个包中的类公开</li><li>默认级别 没有修饰符 只对同一个包中的类公开，不对子类公开</li><li>private 不对外公开</li></ul><p>public&gt;protected&gt;默认&gt;private。public与其他不同是其他包也可以查看</p><p>顶层类只能是public或protected，不然会出现编译错误。</p><p>访问级别是对成员变量和类来说的，对局部变量没有意义，局部变量的访问范围就是方法内部。</p><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p>用abstract修饰的类表示抽象类，抽象类不允许实例化，也就是抽象类不允许创建实例</p><p>用abstract修饰的方法表示抽象方法，抽象方法内部没有内容，只有一个函数头。</p><p>注意，如果有抽象方法，这个类必须定义成抽象类。此外，没有抽象静态方法，abstract和static是互相矛盾的。</p><p>抽象类本身不可以实例化，但是可以创建一个抽象类的引用变量然后引用具体类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HAXE"><figure class="iseeu highlight /haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base a = <span class="keyword">new</span> <span class="type">Base</span>();<span class="comment">//不可以，因为Base是抽象类</span></span><br><span class="line">Base b = <span class="keyword">new</span> <span class="type">Sub</span>(); <span class="comment">//Sub是具体类</span></span><br></pre></td></tr></table></figure></div><p>抽象方法不可以用private修饰，因为抽象出来本来就是要让子类去实现的，private一下子类就无法使用了。</p><p>子类必须实现抽象类的所有抽象方法。</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final有不可改变的含义。</p><p>用final修饰的类不能被继承，没有子类</p><p>用final修饰的方法不能被覆盖</p><p>final修饰的变量表示常量，只能赋一次值</p><p>final不能用来修饰构造方法。</p><p>final修饰引用变量，这个变量不能只能引用一个实例，但是可以对这个实例进行修改。</p><p>不允许覆盖就是不能用相同的函数签名去重写这个函数</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul><li>static修饰的成员变量时静态变量，可以直接通过类名进行访问，并且所有实例共用一个静态变量</li><li>修饰成员方法表示静态方法，可以直接通过类名访问</li><li>修饰的程序代码块叫做静态代码块，加载类时会执行这些代码块</li></ul><p>静态变量只有一份备份，处于方法区，在加载类的时候随之加载。</p><p>注意，在静态方法中没办法用this，因为静态方法时所有类共有的，this表示的是某个特定的类。所以在main方法中不能用this和super，因为main是static的，如果想访问这个类的内容，可以先定义一个该类的引用变量。</p><p>如果直接访问了，编译器会报<strong>在静态方法内不允许访问非静态变量</strong>。</p><p>main函数必须是static的原因是只要加载了main所在的类main就被加载了，可以直接去执行，不然还要先创建一个类然后使用main方法。</p><p>类中可以包含一些静态代码块，这些代码块不存在与任何方法中，加载类时一次执行这些代码块。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"First Static code i="</span> + i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>static代码块和静态方法一样，不可以直接调用实例变量和实例方法，只用通过先引用之后才可以进行调用。</p><h5 id="static进行静态导入"><a href="#static进行静态导入" class="headerlink" title="static进行静态导入"></a>static进行静态导入</h5><p>静态导入类似于c++中的using namespace std;可以简写代码。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARDUINO"><figure class="iseeu highlight /arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">import</span>.<span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out.<span class="built_in">println</span>(MIN_VALUE);<span class="comment">//原来是Integer.MIN_VALUE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>但是如果静态导入过多，可能会导致冲突，因此尽量导入的时候具体一点。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java switch foreach</title>
    <link href="http://xinhecuican.github.io/post/4c720881.html"/>
    <id>http://xinhecuican.github.io/post/4c720881.html</id>
    <published>2020-04-22T08:49:00.000Z</published>
    <updated>2020-04-22T09:00:38.545Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch的条件（switch括号中的内容）可以有一下几种。</p><ul><li>可以自动转换成int的类型（byte,short,int,char)</li><li>字符串类型<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AUTOIT"><figure class="iseeu highlight /autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> color = <span class="string">"red"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">switch</span>(color)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">   System.out.println(<span class="string">"红色"</span>)<span class="comment">;</span></span><br><span class="line">   <span class="built_in">break</span><span class="comment">;</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">"blue:</span></span><br><span class="line"><span class="string">   System.out.println("</span>蓝色<span class="string">");</span></span><br><span class="line"><span class="string">   break;</span></span><br><span class="line"><span class="string"> default:</span></span><br><span class="line"><span class="string">   System.out.println("</span>其他颜色<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div></li><li>枚举类型<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRYSTAL"><figure class="iseeu highlight /crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Colour</span>(<span class="title">red</span>,<span class="title">blue</span>);</span></span><br><span class="line">Colour c = Colour.red;</span><br><span class="line">Switch(c)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><h3 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h3></li></ul><p>foreach是for的特殊简化版本。用来遍历数组或集合</p><p>语法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(变量类型 变量名 : 待输出的集合或数组)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其实这也只能说是稍稍简化，直接写for就可以了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;switch&quot;&gt;&lt;a href=&quot;#switch&quot; class=&quot;headerlink&quot; title=&quot;switch&quot;&gt;&lt;/a&gt;switch
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 操作符</title>
    <link href="http://xinhecuican.github.io/post/4b1879e3.html"/>
    <id>http://xinhecuican.github.io/post/4b1879e3.html</id>
    <published>2020-04-21T10:23:00.000Z</published>
    <updated>2020-04-26T05:18:42.594Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>c++中没有 &gt;&gt;&gt;(逻辑右移）操作符，这是在java中才有的。c++想要实现逻辑右移的功能要么进行更复杂的运算要么用unsigned。<a href="https://xinhecuican.github.io/post/61738.html">这篇博客中详细讲了算术右移和逻辑右移</a></p><p>浮点数不支持移位运算。并且如果其中一个浮点数是double型，结果就是double型。</p><table><thead><tr><th>逻辑运算符（部分）</th><th>操作</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>短路与</td></tr><tr><td>&amp;</td><td>非短路与</td></tr><tr><td>两竖线</td><td>短路或</td></tr><tr><td>一竖线</td><td>非短路或</td></tr></tbody></table><p>短路与非短路的区别是对于短路运算符如果左边可以判断，那么就不会去判断右边。非短路运算符无论条件如何都会执行两边。</p><p>非短路运算符的作用是有时我们先要进行一些运算再判断，非短路运算符可以确保运算的执行。例如 if(b == true &amp; (output+=10) == 20 ).其中output+=10就是运算，</p><h3 id="操作符在对象中"><a href="#操作符在对象中" class="headerlink" title="==操作符在对象中"></a>==操作符在对象中</h3><p>当==操作符在对象中时，两个引用变量必须是引用同一个对象，结果才为true。</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Integer <span class="built_in">int</span>1 = new Integer(<span class="number">1</span>);</span><br><span class="line">Integer <span class="built_in">int</span>2 = new Integer(<span class="number">1</span>);</span><br><span class="line">Integer <span class="built_in">int</span>3 = <span class="built_in">int</span>1;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="built_in">int</span>1 == <span class="built_in">int</span>2);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="built_in">int</span>1 == <span class="built_in">int</span>3);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></div><p>可见哪怕赋了一样的值两个对象还是不同的。</p><h4 id="与多态"><a href="#与多态" class="headerlink" title="== 与多态"></a>== 与多态</h4><p>想要使用必须要两个类是相同的或者处于同一分支。例如 cat和dog都继承与animal类，cat可以和animal进行比较，但是cat不能和dog进行比较。</p><p>数组也是引用类型，可以用==进行比较，但是前提是两边变量类型必须相同，例如一个int型和一个long型进行比较就会报错。</p><h4 id="对象的equal（）方法"><a href="#对象的equal（）方法" class="headerlink" title="对象的equal（）方法"></a>对象的equal（）方法</h4><p>有些jdk中的一些类覆盖了object类的equal（）。这种情况下比较就是如果类型一致且内容一致（数据域），那么就返回true，否则返回false。例如String类。</p><p>所以如果要进行字符串比较的话，必须使用equal方法。不然除非是复制的两个字符串，不然即使内容相同也会出错。</p><h3 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h3><p>instanceof操作符用于判断引用类型所引用的对象是否是一个类或其祖先的实例。如果是返回true。</p><p>格式： 实例名 instanceof 类名或接口名</p><p>例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = <span class="keyword">new</span> <span class="constructor">Dog()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(dog instanceof Dog);</span><br><span class="line"></span><br><span class="line">output: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">同时如果Dog替换成dog的父类或祖先类，或Dog类或其祖先实现的接口时，都会返回<span class="literal">true</span></span><br></pre></td></tr></table></figure></div><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><strong>自动类型转换</strong></p><p>总的规则就是小的和大的相乘结果是大的。浮点数和整数相乘结果是浮点数。</p><p><strong>强制类型转换</strong></p><p>把高位类型赋值给低位类型，结果一定要进行强制类型转换（显式转换）。由小到大进行自动类型转换。</p><p>例 ：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">int</span> i = (<span class="built_in">int</span>)<span class="number">3.14</span>;</span><br><span class="line">long j = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">int</span> i2 = (<span class="built_in">int</span>)j;</span><br><span class="line"></span><br><span class="line">其中只有第一个是不合法的，因为浮点数默认是<span class="built_in">double</span>型。</span><br></pre></td></tr></table></figure></div><p>此外，如果超过了数据范围也必须强制类型转换。</p><p>char c = -1;//错误，因为超过了数据范围</p><p>char c = 97;//正确</p><p><strong>引用类型的强制转换</strong></p><p>子类复制给祖先类，会自动进行类型转换。而父类给子类则必须进行强制类型转换。</p><p>如果不在统一继承分支上则不可以进行转换。</p><p>例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EBNF"><figure class="iseeu highlight /ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Animal cat</span> = new Cat();</span><br><span class="line"><span class="attribute">Dog dog</span> = (Dog)cat;</span><br></pre></td></tr></table></figure></div><p>上面的代码可以通过编译，但是在运行时会跑出ClassCastException异常</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;c++中没有 &amp;
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java 数据类型和变量</title>
    <link href="http://xinhecuican.github.io/post/f201f9fd.html"/>
    <id>http://xinhecuican.github.io/post/f201f9fd.html</id>
    <published>2020-04-20T03:40:00.000Z</published>
    <updated>2020-04-21T12:14:45.593Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>因为是记笔记，这里只说一下和c++不同的地方。</p><p>定义及使用的方式和c++基本一致，就是有些名字改了而已。</p><p>类变量自动初始化，boolean初始化为false，其他初始化为0。但是普通的变量还有自己初始化。这里和c++不同的是如果没有初始化会报错。当然，如果一直没有使用的话不初始化也不会报错。</p><p>boolean 就是c++中的bool型。但是有一点不同，这里只能赋true or false，赋一个整数变成bool型是不可以的。但是无语的是底层实现其实还是非零是true，零是false。也就是说，在java中,int i = 1; if(i)的行为是不被允许的，因为整型不可以变成boolean型。</p><p>byte 一个字节，和char不同，这个是整型的。当然，java中也有char</p><p>在java中，如果数学表达式都是整数，则返回值只能是int或long型。如果把返回值赋给byte型，要进行强制类型转换。<strong>强制类型转换例：byte a = (byte)(1+1);</strong></p><p>可以用下划线分隔，例如：int a = 10_000_000;实际上就是1000万，这样可以增加可读性。</p><p>此外，可以在后面加尾标表示类型。例如 l是long型，f是float，D是double。S是short，C表示char。例如： 100L。</p><p>小数没有后缀默认是double型</p><h4 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h4><ul><li>如果int型直接赋给byte，short或char型的时候，如果在数据范围内，可以直接赋值，如果超出数据范围，必须要进行强制类型转换，而且是显式的，不然会报错。超出部分直接截断，没超出的再按对应编码方式解释。</li></ul><p>byte b = 129;//错</p><p>byte b = (byte)129;//对</p><ul><li>浮点型赋给整型必须要进行强制类型转换，而整型给浮点型不要</li><li>double给float要强制类型转换，而float给double不要</li></ul><p><strong>java语言编码</strong></p><p>java采用UCS-2编码，字符占两个字节，把字符看成无符号整数对待。一般来说不用记字符的编码，但是像一些特殊的例如<code>&#39;</code>如果直接char c = ‘’’就会出错。所以可以加反斜线进行转义。char c = ‘&#39;‘</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用可分为类引用，接口引用，数组引用。</p><p>类引用引用类的实例，接口引用引用接口的实例，数组引用引用数组的实例（数组页看成对象）。无论是哪种，都是引用一个对象</p><p>如果没有引用一个实例，可以赋值成null，例如：</p><p>Doll a = null;</p><p>Doll a = new Doll(“beibei”);</p><p>用new关键字可以创建一个对象，它做了下面的事：</p><ul><li>为对象分配空间，并将变量初始化</li><li>调用构造方法</li><li>返回对象引用</li></ul><h4 id="实例变量和静态变量和静态函数"><a href="#实例变量和静态变量和静态函数" class="headerlink" title="实例变量和静态变量和静态函数"></a>实例变量和静态变量和静态函数</h4><p>类的成员变量有两种，一种是static修饰的变量，叫做类变量，或静态变量。一种是普通的实例变量。</p><p>静态变量就是归所有实例所共享的。而普通变量就是每一个实例所独有的。</p><p>静态变量储存在方法区，而普通变量存放在堆区。想到java类方法的访问过程就可以知道方法区是存放一些共有的东西，例如方法的二进制代码。每个类使用方法时直接调用就可以了。</p><p>静态函数有几个特点：</p><p>如果不是类中的静态函数，那么只能在当前文件中使用，相当于权限是private。</p><p>如果是类中的静态函数，只能使用静态变量，也不能调用类中的非静态成员函数。</p><p><strong>this</strong></p><p>java中也有this指针，也是指向当前对象，但是使用的是点操作符而不是箭头。使用上与c++大致相同，</p><p>例： owner.setdog(this)//this代表当前dog的对象</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>如果传递的是基本数据类型，那么就传递参数的值（值传递？）。如果是对象或者数组，那么就是引用传递。注意数组不是指针传递了，因为java中好像没有指针的概念。所以这里数组应该也可以作为返回值（纯推测，还没看到）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;因为是记笔记，这
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java初探</title>
    <link href="http://xinhecuican.github.io/post/912b2566.html"/>
    <id>http://xinhecuican.github.io/post/912b2566.html</id>
    <published>2020-04-19T10:59:00.000Z</published>
    <updated>2020-04-20T03:40:13.593Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><h3 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h3><p>java源文件可能包含以下内容：</p><ul><li>包声明语句</li><li>包引入语句</li><li>类声明</li><li>接口声明</li></ul><p>这些内容都不是必须的。此外要注意只能有一个类或接口是public的（一般也是private）。</p><h4 id="包声明语句"><a href="#包声明语句" class="headerlink" title="包声明语句"></a>包声明语句</h4><p>包声明语句把类放到特定的包中。例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="NIMROD"><figure class="iseeu highlight /nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package com.abc.dollapp;</span><br><span class="line">public calss appmain<span class="meta">&#123;...&#125;</span>;</span><br><span class="line">class doll<span class="meta">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure></div><p>在这个例子中appmain和doll都在com.abc.dollapp包中。</p><p>在一个java文件中，只能有一个package语句。如果没有提供package，那么就表明在系统默认的包中。</p><h5 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h5><ol><li>用于区分名字相同的类。例如定义了两中车类名都叫car，一种实际上是奔驰，一种是宝马。把他们丢在不同的包中就可以区分他们，相当于使用了不同的命名空间[^1]。</li></ol><p>[^1]:命名空间实际上就是在函数前的一些附加消息。因为可能同时引入了多个库，库文件中可能某些函数名字相同，这个时候只有通过前面添加一些信息来辨别。典型例子就是using namespace std;这个含义就是使用标准命名空间。不然就要写std::cout来进行辨别。<br>2. 有助于访问权限的控制。但不同包之间进行访问时，就会受到访问权限的控制。<br>3. 有助于组织划分各个类。</p><h5 id="包的命名规范"><a href="#包的命名规范" class="headerlink" title="包的命名规范"></a>包的命名规范</h5><p>包的名字通常用小写，一般包含以下信息：</p><ol><li>类的创建者信息</li><li>类所属软件信息</li><li>类在具体项目中所处的位置</li></ol><p>jdk提供了一些基本包</p><ul><li>java.lang包，包含线程类（Thread)，异常类（Exception），系统类（System），整数类（Integer），字符串类（String）等。这个包系统会自动引入。</li><li>java.awt。抽象窗口工具包。用于构建GUI界面和绘图类</li><li>java.io 输入输出包。例如文件输入类（FileInputStream类）</li><li>java.util 实用类，例如日期类（Date）集合类（Collection）</li><li>java.net 支持TCP/IP网络协议。</li></ul><h5 id="包引入"><a href="#包引入" class="headerlink" title="包引入"></a>包引入</h5><p>如果一个类访问了另一个包的类，那么一定要引入这个类（就像c++中的库引入一样）。</p><p>语法： import 包名.类名</p><p>如果想引入一个包中所有类， 可以 import 包名.*</p><p>要注意最好使用第一种语法，因为第二种不仅耗时大并且还可能带来类名重复的问题，这个时候每写一个类都要写它的包名。</p><p>并且如果包中还有包的话，第二种语法是不会把内层包的类引入的。之所以可以包中有包是为了保证层次结构。例如前面提到的com.abc其实就是包中有包，com是外层，abc是内层。</p><p>package语句必须在import前</p><h4 id="方法（函数）声明"><a href="#方法（函数）声明" class="headerlink" title="方法（函数）声明"></a>方法（函数）声明</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DUST"><figure class="iseeu highlight /dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">返回值 函数名（参数）</span></span><br><span class="line"><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    主体</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure></div><p>这里的函数和c++大致相同</p><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>main方法和c++不一样了，要包含几个要素</p><ul><li>访问限制 public</li><li>静态方法 static</li><li>参数 main(String args[])</li><li>返回类型 void</li></ul><p>所以合起来就是 static public void main（String args[])</p><h5 id="给main传递参数"><a href="#给main传递参数" class="headerlink" title="给main传递参数"></a>给main传递参数</h5><p>格式： java classname [args…]</p><p>classname指的是类名</p><p>例如： java com.abc.dollapp.main.MainApp parameter0 parameter1</p><p>也就是c++中的argc，argv</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>第一种 //</p><p>第二种 <code>/*...*/</code></p><p>第三种 <code>/**...*/</code>，当这种注释出现在类的声明时，会作为javadoc的内容</p><h4 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h4><p>关键字之后慢慢就会知道</p><p>标识符命名规则：</p><ul><li>首字母必须是字母，下划线（_)，符号￥或符号$。</li><li>除开首字母其他字符可以用数字</li><li>没有长度限制</li></ul><h3 id="用jdk管理java应用"><a href="#用jdk管理java应用" class="headerlink" title="用jdk管理java应用"></a>用jdk管理java应用</h3><p>java常用目录（防止以后看到这些目录都不知道是干什么的）</p><table><thead><tr><th>src</th><th>存放源文件</th></tr></thead><tbody><tr><td>classes</td><td>存放编译生成的java文件</td></tr><tr><td>lib</td><td>存放第三方java软件的JAR文件（不要问我这是什么）</td></tr><tr><td>doc</td><td>存放帮助文档</td></tr><tr><td>doc\api</td><td>存放javadoc文档</td></tr><tr><td>deploy</td><td>存放打包文件，jar文件</td></tr></tbody></table><h3 id="使用javadoc文档"><a href="#使用javadoc文档" class="headerlink" title="使用javadoc文档"></a>使用javadoc文档</h3><p>java中有一个程序，可以识别类中的注释并将其转化成html文件。只有满足规范的文件才可以转化。</p><p>首先的规范就是注释要<code>/**...*/</code>才可以。里面可以有普通文件，html标记和javadoc标记。</p><p>范围：javadoc命令只处理类声明，接口声明，成员方法声明，成员变量声明，以及构造方法<strong>之前</strong>声明的注释。也就是说要在函数或类等的外面去声明。</p><h4 id="javadoc标记"><a href="#javadoc标记" class="headerlink" title="javadoc标记"></a>javadoc标记</h4><table><thead><tr><th>标记</th><th>说明</th></tr></thead><tbody><tr><td>@version</td><td>版本</td></tr><tr><td>@since</td><td>指定最早出现在哪个版本</td></tr><tr><td>@author</td><td>作者</td></tr><tr><td>@see</td><td>生成参考其他javadoc的链接</td></tr><tr><td>@link</td><td>生成链接，但是还可以添加其他的话</td></tr><tr><td>@deprecated</td><td>表示某些类或方法不提倡使用，之后可能会被废弃</td></tr><tr><td>@param</td><td>描述方法参数</td></tr><tr><td>@return</td><td>返回值</td></tr><tr><td>@throws</td><td>描述方法抛出的异常，指出抛出异常的条件</td></tr></tbody></table><p>@see用于生成到其他文档的链接。例如<code>@see #setWord</code>生成到setWord的链接。一共有三种格式</p><ul><li>set com.abc.dollapp.doll 生成到其他类的javadoc文档</li><li>set #setWord 生成当前类不同方法的javadoc文档</li><li>set com.abc.dollapp.doll#speak 生成到其他类的某一个方法的javadoc文档</li></ul><p>至于link在语法上与set大致相同，但是他可以用大括号插入到某一句话中，例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 如果&#123;<span class="variable">@link</span> <span class="comment">#word word成员变量&#125;不为NULL；</span></span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure></div><p>输出： 如果word<u>成员变量</u>不为NULL；</p><p>javadoc命令用法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="D"><figure class="iseeu highlight /d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">public</span> 仅为<span class="keyword">public</span>级别的类建立文档</span><br><span class="line">-<span class="keyword">protected</span> 进位<span class="keyword">public</span>和<span class="keyword">protected</span>建立文档 默认选项</span><br><span class="line">-<span class="keyword">package</span></span><br><span class="line">-<span class="keyword">private</span></span><br><span class="line">-<span class="keyword">version</span> 解析<span class="keyword">version</span>标记，默认情况会忽略</span><br><span class="line">-author </span><br><span class="line">-sourcepath&lt;path&gt; 指定源文件路径</span><br><span class="line">-classpath</span><br><span class="line">-d &lt;directory&gt; 指定javadoc的输出目录</span><br></pre></td></tr></table></figure></div><p>语法： javadoc [options] [packagenames] [sourcefiles]</p><h3 id="java虚拟机运行java的基本原理"><a href="#java虚拟机运行java的基本原理" class="headerlink" title="java虚拟机运行java的基本原理"></a>java虚拟机运行java的基本原理</h3><p>过程：先进行编译，之后进入虚拟机中变成机器指令。具体过程就不解释了，但是这里有一步就是根据操作系统进行运行。而java程序使运行在虚拟机上的。所以编译出来的文件可以在任何平台上运行。</p><p>系统会先给虚拟机分配一个空间。虚拟机又会把这个空间分成若干个部分。主要包括堆区，栈区，方法区等等。堆中存放对象，方法区中存放类的类型信息，方法信息和静态变量等等。</p><p>运行程序时，先要把程序的二进制加载到内存，然后对程序进行验证（包括初始化），之后再执行。</p><p>当生成一个实例时，虚拟机会先搜索方法区，如果方法区没有，那么就会先加载这个类。之后在堆区分配一片内存用来存放实例，实例有一个指向方法区的指针。这个实例用一个局部指针指向它（也就是实例名，和数组很像，不是说java不提供指针吗）。</p><p>所以运行一个java方法的过程是：先由类名到堆区，然后堆指向方法区的指针把对应的方法取出来（机器指令）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;源文件结构&quot;&gt;&lt;a href=&quot;#源文件结构&quot; class=&quot;headerlink&quot; title=&quot;源文件结构&quot;&gt;&lt;/a&gt;源文件结构&lt;/h3
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title> UML简介</title>
    <link href="http://xinhecuican.github.io/post/5f9e4eff.html"/>
    <id>http://xinhecuican.github.io/post/5f9e4eff.html</id>
    <published>2020-04-18T12:42:00.000Z</published>
    <updated>2020-04-18T13:26:53.845Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --><p>简单来说UML就是结构图，表示对象与类，类与类之间的联系。</p><p>UML主要包含以下框图：</p><ul><li>用例图 从用户角度描述系统功能，简单来说就是用户让系统干什么（也可以说是系统的输入）</li><li>类框图 表示类与类之间的联系</li><li>状态转换图 这是针对有不同状态的类。类如开关的开和关就是状态的转换</li><li>时序图和协作图 时序图是在时间维度上描述用户的输入和类的使用。协作图则用箭头表示而不是通过时间轴表示</li></ul><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>用例图的要素有</p><ul><li>用户 画成一个人型</li><li>用例 系统的某一个功能，大多数时候就是某一个函数，用椭圆表示</li><li>关系，用箭头表示</li></ul><p>也可以用用例文档补充描述。</p><ul><li>前置条件，什么时候才可以输入</li><li>主事件流，也就是这个用例干了什么事</li><li>其它事件流， 比如错误了该干什么事</li><li>后置条件 用例必须为真条件（个人理解是什么时候可以输出）</li></ul><h3 id="类框图"><a href="#类框图" class="headerlink" title="类框图"></a>类框图</h3><p>类框图是表示类与类之间的关系（静态）。这个意思就是这个关系使不变的，做了一个就要去做另一个。</p><p>要素： 用一个方框表示类，方框的上面是类名，下面是函数名。用箭头表示方框之间关系。</p><h3 id="时序图与协作图"><a href="#时序图与协作图" class="headerlink" title="时序图与协作图"></a>时序图与协作图</h3><p>时序图有两个要素，</p><p>垂直上表示时间，水平上表示发送消息的过程。（用函数名和箭头表示）</p><p><img src="/images/%E4%B8%8B%E8%BD%BD.png" alt></p><p>协作图就用一个个箭头表示时间之间关系的。</p><p><img src="/images/20151113162700894" alt></p><h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p>要素：</p><ul><li>初始点 实心圆</li><li>状态之间的转换 箭头</li><li>状态 用圆点表示</li><li>终止点 用一个圆里面再加一个实心圆表示</li></ul><p>例：<br><img src="/images/20170305152530328.png" alt></p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><ul><li>关联 一个类和另一个类的实例有联系，例如老师和学生有联系。</li><li>依赖 A类访问类B提供的服务。例如A调用B的函数</li><li>聚集 A为整体类，B为局部类。A对象有B的对象组合而成（有个体组合成整体）。例如个人和人类。人类类中成员就是个人，人类类还有一些自己专属的方法。或者汽车和零部件。</li><li>泛化 A继承B</li><li>实现 A实现B的接口</li></ul><p>依赖和关联不同。关联是对应实例（也就是定义出来的东西），而关联是定义类是两个类总监有关系</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 10 2020 11:10:06 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;简单来说UML就是结构图，表示对象与类，类与类之间的联系。&lt;/p&gt;&lt;p&gt;UML主要包含以下框图：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;用例图 从用户角度描述系统功能
      
    
    </summary>
    
    
      <category term="java" scheme="http://xinhecuican.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>储存设备</title>
    <link href="http://xinhecuican.github.io/post/7d1c86da.html"/>
    <id>http://xinhecuican.github.io/post/7d1c86da.html</id>
    <published>2020-04-16T04:57:00.000Z</published>
    <updated>2020-05-12T06:34:18.090Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 13 2020 09:52:30 GMT+0800 (中国标准时间) --><h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p><img src="/images/%E7%A1%AC%E7%9B%98.jpg" alt></p><p>结构： 由若干个盘片组成，每个盘片有2两面，每一面上有若干个磁道，每个磁道上又划分成若干个扇区，扇区是数据访问的最小单位。中间的轴在不停转动。每个扇区都有一个编号。</p><p>显然如果扇区划分时是从中心发出多根射线的话是不好的。因为内圈的扇区划分小，外面的扇区划分大，因此每个扇区读写数据数目可能会有较大的差距。但是很可能只需要利用其中很小一部分，这样就造成了浪费。所以磁道与磁道之间扇区数目是不同的，尽量使数据分布均匀。</p><p>图中左边的架子是读写头，可以前后滑动。数据就是通过读写头进行读写的。</p><p><strong>大致过程</strong>：先移动到对应扇区（寻道），然后等待读写头划过我们要读取的扇区。之后在读取这个扇区。要注意即使只需要读取一个字节也要把这个扇区全部读取完。如果是写的话，先把扇区中数据读取出来，然后再在这些数据中进行更改，最后再把这些数据写入到扇区中。</p><p>一般寻道在2-9ms，旋转也是10ms左右，而读取只需要0.02ms，所以说大头都在寻找过程中。并且要比dram慢2500倍，比sram慢40000倍。</p><p>机械硬盘扇区的读取次数是由限制的，大概是十万到100万次左右。如果某一扇区坏了是不是会导致整个硬盘都异常呢？当然这是不可能的，那样也太不经用了。</p><p>为了解决这个问题，可以用逻辑编号代替物理编号，然后用一定的映射规则转换到物理编号，如果某一个扇区损坏，硬盘中有一些备用的扇区可以替补上，这样就可以解决某一个扇区损坏的问题。可能某些逻辑扇区会被频繁的使用，如果对应规则是确定的那么可能很快那个扇区就会损坏，所以对应规则也要不断变化使每个扇区利用大致平均。</p><h3 id="固态硬盘（ssd）"><a href="#固态硬盘（ssd）" class="headerlink" title="固态硬盘（ssd）"></a>固态硬盘（ssd）</h3><p>结构： 固态硬盘最小的结构是页，每一页有若干个字节。之后若干个页组成了块。它是由闪存构成的（就是usb所使用的）</p><p>读写过程：读的过程是以<strong>页</strong>作为单位，也需要通过一定的映射使之利用均衡。但是写的过程却是以<strong>块</strong>作为单位，就算只改一个字节也需要读取整个块，并且写的过程中需要先把原来的内容全部擦除，所以写过程比读过程慢的多。</p><p>ssd好处是读写较快，但是价格贵，并且读写次数少，只有1万到10万次。</p><h3 id="局部性和高速缓存"><a href="#局部性和高速缓存" class="headerlink" title="局部性和高速缓存"></a>局部性和高速缓存</h3><p>局部性分为时间局部性和空间局部性。</p><p>时间局部性指的是在短时间内多次重复使用某个内存。</p><p>空间局部性指的是一个内存被使用，很可能接下来会使用这段内存附近的数据。</p><p>现代计算机cpu运算速度已经很快了，但是内存的访问速度却跟不上cpu的运算速度。因此现在更重要的是解决内存读取速度的问题。</p><p>根据上面所说的局部性原理（这是人们通过大量观察总结得出的规律），人们想到可以把常用的数据放在一个更快的储存器里，这样就可以提高运算速度。</p><p>于是就有了高速缓存。高速缓存（cahce）是用sram制成的，它的速度很快但是容量很小，直接集成到了cpu内部，每次cpu访问内存的时候都会先从高速缓存中读取。如果高速缓存中没有才会去内存中查找。从内存中取出数据并不是只取那几个字节，而是把附近的指令都放到高速缓存中（因为局部性原理），这样就可以提高速度。</p><h3 id="高速缓存运行原理"><a href="#高速缓存运行原理" class="headerlink" title="高速缓存运行原理"></a>高速缓存运行原理</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png" alt></p><p>一共有S个组，每个组有E行，每行有B个字节。S，E，B都是2的n次方，记S是2的s次方，E是2的e次方，B是2的b次方。</p><p>每一行的B字节都是由三部分组成。最高位叫做有效位，用来判定这一行中是否储存了数据。之后又t字节标记位，用来进行判别，后面的位才是实际从内存中取出来的内容。</p><p>每次cpu访问一个地址时，可以把地址分成3个部分。最低b位是块偏移，中间s位是组索引，高t位是标记。</p><p>进行查询时，先用中间s位找出组索引。例如中间s位是010，那么组索引是2.找到组索引后就用高t位的标记进行比对，如果对应行中最高位为1且标记位正好符合那么就通过最后的b字节找到块偏移。然后取出数据。</p><p>注意，我们只需要找到对应的组就行了，cpu可以自动对该组所有行同时进行比对而不用一一比对。</p><p>例 cpu发出一个指令，要从0111位置取出两字节数据。首先高速缓存中有四组，每组一行。每行四字节。所以这里块偏移是1组索引是11，标记是0.那么我们先通过中间的11确定是第三组，之后再和第三组最高位为1的进行比对，如果有一行标记位正好是0，那么就算出偏移量是1，所以从后面开始的第一位（有第零位）取出两个字节。</p><h4 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h4><p>直接映射高速缓存的特点是每一组只有一行。所以找到组后直接进行比对即可。但是这里有一个问题，例如组索引是1，标记位有两位。那么可能频繁的取出组索引相同但是标记位不同的数据，那么我们就要频繁的从内存中取出数据（miss），这样就降低了速度。</p><h4 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h4><p>组相联高速缓存和直接告诉缓存的不同是组相联高速缓存中每一组有多个行，这样就更可以存放更多的标记位，miss的可能性也就越低。但是这个的问题是因为要同时访问多行，所以硬件设计比较困难。</p><h4 id="全相连高速缓存"><a href="#全相连高速缓存" class="headerlink" title="全相连高速缓存"></a>全相连高速缓存</h4><p>全相连高速缓存中只有一个组，因此没有组索引（想要有组索引最少要有两个组）。</p><p>因此把cpu发送的内存地址分成两个部分，块偏移和标记。因为没有组索引，所以这两部分一般比较大。它可以同时匹配所有的行，也就少了寻找组索引的计算，但是如果行太多设计极为困难，所以只适合做小的高速缓存。</p><h4 id="直写与回写"><a href="#直写与回写" class="headerlink" title="直写与回写"></a>直写与回写</h4><p>直写就是每次都要写到内存或者硬盘中，回写就是每次先在缓存中写，等到这个缓存被替换的时候再写回。毫无疑问回写要快，但是直写也有用武之地。</p><h4 id="块替换策略"><a href="#块替换策略" class="headerlink" title="块替换策略"></a>块替换策略</h4><p>每次未命中时并且缓存中已经全部使用的时候就要进行块替换。块替换有两种策略，第一种是把最近没有使用的块替换出去，第二种是把最不经常使用的块替换出去。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 13 2020 09:52:30 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;机械硬盘&quot;&gt;&lt;a href=&quot;#机械硬盘&quot; class=&quot;headerlink&quot; title=&quot;机械硬盘&quot;&gt;&lt;/a&gt;机械硬盘&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
