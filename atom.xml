<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xinhecuican.github.io/"/>
  <updated>2020-03-17T13:51:40.185Z</updated>
  <id>http://xinhecuican.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>压缩矩阵</title>
    <link href="http://xinhecuican.github.io/2020/03/16/%E5%8E%8B%E7%BC%A9%E7%9F%A9%E9%98%B5/"/>
    <id>http://xinhecuican.github.io/2020/03/16/%E5%8E%8B%E7%BC%A9%E7%9F%A9%E9%98%B5/</id>
    <published>2020-03-16T02:39:00.000Z</published>
    <updated>2020-03-17T13:51:40.185Z</updated>
    
    <content type="html"><![CDATA[<p>对于特殊的矩阵，例如上下三角矩阵，对称矩阵，三对角矩阵，可以转化成1维矩阵，减小空间的消耗。</p><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>对称矩阵有 aij=aji的特性，因此可以只保存一边，也就是压缩成 <code>n(n+1)/2</code>个</p><p>如果我们用一个一维数组s[n(n+1)/2]来保存，那么它域原矩阵的对应关系</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k= <span class="built_in">i</span>(<span class="built_in">i</span><span class="number">-1</span>)/<span class="number">2</span>+<span class="built_in">j</span><span class="number">-1</span> <span class="built_in">i</span>&gt;=<span class="built_in">j</span></span><br><span class="line">    <span class="built_in">j</span>(<span class="built_in">j</span><span class="number">-1</span>)/<span class="number">2</span>+<span class="built_in">i</span><span class="number">-1</span>  <span class="built_in">i</span>&lt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure><p>这个式子先只考虑一边，先看i&gt;=j的情况。此时第一行中压缩矩阵只保存一个值，第二行两个值，依此类推。所以对于第i行先把前i-1行中对应压缩矩阵的值的数量加起来，也就死i(i-1)/2，之后再加上第j行的第j-1个（这里因为数组下标是从0开始）。</p><p>这个例子中的行数是从第一行开始，实际上应该从第0行开始，所以</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k= <span class="built_in">i</span>(<span class="built_in">i</span>+<span class="number">1</span>)/<span class="number">2</span>+<span class="built_in">j</span> <span class="built_in">i</span>&gt;=<span class="built_in">j</span></span><br><span class="line">  <span class="built_in">j</span>(<span class="built_in">j</span>+<span class="number">1</span>)/<span class="number">2</span>+<span class="built_in">i</span> <span class="built_in">i</span>&lt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure><p>举个例子，第0行第0个在k中对应位置就是0</p><h4 id="上下三角矩阵"><a href="#上下三角矩阵" class="headerlink" title="上下三角矩阵"></a>上下三角矩阵</h4><p>对称矩阵行数和列数相同</p><p>上三角矩阵其实就是对称矩阵中 i&gt;=j的那一段</p><p>下三角矩阵中第一行的压缩矩阵元素数量是n,第二行是n-1,以此类推，我们也可以得到相应的关系式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=（<span class="number">2</span>*n-<span class="built_in">i</span><span class="number">-1</span>)*<span class="built_in">i</span>/<span class="number">2</span>+<span class="built_in">j</span> <span class="built_in">i</span>&lt;=<span class="built_in">j</span></span><br><span class="line">  (<span class="number">2</span>*n-<span class="built_in">j</span><span class="number">-1</span>)*<span class="built_in">j</span>/<span class="number">2</span>+<span class="built_in">i</span> <span class="built_in">i</span>&gt;<span class="built_in">j</span></span><br></pre></td></tr></table></figure><h4 id="三对角矩阵"><a href="#三对角矩阵" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h4><p>除了第一行和最后一行有两个元素之外，其他行都有三个元素</p><p>对于<code>a[i][j]</code>来说，前面有 3*i-1个元素，本行它前面有j-i+1个位置。所以k=2 * i+j</p><p>反之，如果在压缩矩阵中是第k个位置，那么在原矩阵中 i=(k+1)/3 j=k-2*i</p><h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p>对于非零元素较少的矩阵，可以直接用一个结构体保存 i,j ,sum，然后再用一个结构体数组来保存所有的值。这个数组是从左至右扫描遍历的。</p><h5 id="稀疏矩阵转置的算法"><a href="#稀疏矩阵转置的算法" class="headerlink" title="稀疏矩阵转置的算法"></a>稀疏矩阵转置的算法</h5><p>首先，如果用朴素的算法，就是从第零行开始遍历每一列，然后把列变成行。</p><p>如果我们用两个数组分别保存 每一列中元素的数量以及每一列在新的稀疏矩阵中的位置，就有办法可以加快速度</p><p>例如：<img src="/images/%E6%8D%95%E8%8E%B71.PNG" alt=""></p><p><img src="/images/%E6%8D%95%E8%8E%B7.PNG" alt=""></p><p>for循环中注意q=cpot[col]，代表现在这个位置已经有东西了，所以再最后++cpot[col]代表现在这一列在新稀疏矩阵的首位置要后移一位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于特殊的矩阵，例如上下三角矩阵，对称矩阵，三对角矩阵，可以转化成1维矩阵，减小空间的消耗。&lt;/p&gt;
&lt;h3 id=&quot;特殊矩阵&quot;&gt;&lt;a href=&quot;#特殊矩阵&quot; class=&quot;headerlink&quot; title=&quot;特殊矩阵&quot;&gt;&lt;/a&gt;特殊矩阵&lt;/h3&gt;&lt;h4 id=&quot;对称矩
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>union</title>
    <link href="http://xinhecuican.github.io/2020/03/15/union/"/>
    <id>http://xinhecuican.github.io/2020/03/15/union/</id>
    <published>2020-03-15T04:52:00.000Z</published>
    <updated>2020-03-15T05:06:16.425Z</updated>
    
    <content type="html"><![CDATA[<p>首先看一下结构体，c语言中的结构体占用字节数是所有类型字节数的总和。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用sizeof测试一下结果是8，但是如果用union呢？会发现结果是4</p><p>union中的参数共用同一块内存空间，它们在内存中起始地址都相同，也就是说同一时间内联合体中其实只会有一个参数存在，当另一个参数被赋值时，此时内存中存的就是另一个参数的值，而前面的参数会被覆盖</p><p>但是size并不一定是根据最长的那个长度来决定的（实测不是，但是不懂），还要考虑内存对齐的问题</p><p>如果此时已经给某一变量赋上了值，再用另外一个变量输出，那么内存中的编码并不会改变，只是会按找相应类型的编码方式进行编码然后输出。</p><ul><li>在c++中的使用</li></ul><p>大致相同，但是union中不能有类，如果我们在再类CA中添加了构造函数，或者添加析构函数，我们就会发现程序就会出现错误。由于union里面的东西共享内存，所以不能定义静态、引用类型的变量。由于在union里也不允许存放带有构造函数、析构函数和复制构造函数等的类的对象，但是可以存放对应的类对象指针</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先看一下结构体，c语言中的结构体占用字节数是所有类型字节数的总和。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>广义表</title>
    <link href="http://xinhecuican.github.io/2020/03/15/%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <id>http://xinhecuican.github.io/2020/03/15/%E5%B9%BF%E4%B9%89%E8%A1%A8/</id>
    <published>2020-03-15T01:58:00.000Z</published>
    <updated>2020-03-15T06:30:17.957Z</updated>
    
    <content type="html"><![CDATA[<p>广义表一般记作：LS=（a1,a2,…)</p><p>其中ai在线性表中只可以是单个元素，而在广义表中即可以是单个元素，也可以是广义表。如果是单个元素，叫做原子，如果是广义表，叫做子表。当广义表非空时，第一个元素叫做广义表的表头，其余所有元素叫做广义表的表尾。</p><p>例如： A（），空表</p><p>B（e) 只有一个原子元素e,长度为1</p><p>c（a,(b,c,d)) 长度是2</p><p>d( a ( d)) 递归表</p><ul><li>广义表的储存结构</li></ul><p>通常用链式存储结构</p><p>每个节点有tag域（标志域），hp，tp三个域，但是原子节点（就是表头节点）只有两个域，标志域和值域</p><p>定义：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">glnnode</span></span></span><br><span class="line">&#123;</span><br><span class="line">    int tag;<span class="regexp">//</span>表示是原子节点还是表结点</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        int atom;<span class="regexp">//</span>原子节点值域</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ptr</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            glnnode *hp,*tp;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了空表表头指针为空外，其他表表头指针必定指向一个表节点</p><p>同一层次的表可以从第一个节点通过尾节点依次往后数，而头结点则指向一个原子节点或者是一个子表。</p><p>例如，画出c表的表示</p><p>| | | 代表tag， 头结点，尾结点</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c-&gt; 1|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> -&gt; 1</span>|<span class="string"> </span>|<span class="string"> NULL</span></span><br><span class="line"><span class="string">    </span>|<span class="string">      </span>|<span class="string">  </span></span><br><span class="line"><span class="string">    -&gt;0</span>|<span class="string">a</span>|<span class="string">   -&gt;1</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt;1</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt;1</span>|<span class="string"> </span>|NULL</span><br><span class="line">             |<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">             -&gt;0|<span class="string">b</span>|<span class="string">  -&gt;0</span>|<span class="string">c</span>|<span class="string">  -&gt;0</span>|<span class="string">c</span>|</span><br></pre></td></tr></table></figure><p>这个代表的是 c=（a,(b,c,d))，可以看到，第一层节点的数目就是表的长度，第一层如果头结点接一个原子节点，那么在表中代表一个数，如果接一个表节点，代表一个子表，同理，第二层头节点如果是一个数，那么就代表第二层增加一个元素，如果头结点接一个表节点，那么说明还有一个子表</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;广义表一般记作：LS=（a1,a2,…)&lt;/p&gt;
&lt;p&gt;其中ai在线性表中只可以是单个元素，而在广义表中即可以是单个元素，也可以是广义表。如果是单个元素，叫做原子，如果是广义表，叫做子表。当广义表非空时，第一个元素叫做广义表的表头，其余所有元素叫做广义表的表尾。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编指令 AT&amp;T版 64位</title>
    <link href="http://xinhecuican.github.io/2020/03/12/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4-AT-T%E7%89%88-64%E4%BD%8D/"/>
    <id>http://xinhecuican.github.io/2020/03/12/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4-AT-T%E7%89%88-64%E4%BD%8D/</id>
    <published>2020-03-11T23:46:00.000Z</published>
    <updated>2020-03-17T01:38:43.397Z</updated>
    
    <content type="html"><![CDATA[<p>用g++ -Og -s -masm=intel name.c 可以生成intel格式的汇编代码，-s是生成汇编代码，-Og是省去不重要的部分，如果不加这个，可能5条指令要变成十多条指令</p><p>-fno-if-conversion 分支语句不要采用条件传输的方式，条件跳转的方式</p><p>-g debug</p><p>objdump -d 反汇编</p><p>gdb 调试 b+ 标号 设置断点 info register 查看寄存器 r 执行到断点出</p><p>n（next） 执行下一条命令</p><h4 id="mov-移动指令"><a href="#mov-移动指令" class="headerlink" title="mov 移动指令"></a>mov 移动指令</h4><p>格式： movq a,b</p><p>a是原操作数，b是目标操作数</p><p>这个指令中的q代表的是64位</p><table><thead><tr><th>长度</th><th>类型</th><th>别名</th><th>缩写</th></tr></thead><tbody><tr><td>1</td><td>char</td><td>byte</td><td>b</td></tr><tr><td>2</td><td>short</td><td>word</td><td>w</td></tr><tr><td>4</td><td>int</td><td>double word（long word）</td><td>l</td></tr><tr><td>8</td><td>long</td><td>quad word</td><td>q</td></tr><tr><td>8</td><td>char*</td><td>quad word</td><td>q</td></tr><tr><td>4</td><td>float</td><td>…</td><td>s</td></tr><tr><td>8</td><td>double</td><td>…</td><td>l</td></tr></tbody></table><table><thead><tr><th>源操作数</th><th>目标操作数</th></tr></thead><tbody><tr><td>立即数（idata)</td><td>寄存器 ，地址</td></tr><tr><td>寄存器</td><td>寄存器，地址</td></tr><tr><td>地址</td><td>寄存器</td></tr></tbody></table><table><thead><tr><th>操作数</th><th>符号</th></tr></thead><tbody><tr><td>立即数</td><td>$</td></tr><tr><td>寄存器</td><td>%</td></tr><tr><td>地址</td><td>（）</td></tr></tbody></table><p>例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $2,%rax</span><br><span class="line">movq %rax,%rbx</span><br><span class="line">mov<span class="string">q (%rax)</span>,%rbx</span><br></pre></td></tr></table></figure><p>注意；</p><ul><li>当源操作数为地址的时候，目标操作数不能也是地址，因为一定要通过cpu进行调控，从地址到地址代表没有经过cpu（解释是这样，但我觉得不太合理）</li><li>立即数不能为8字节，使用 movabsq 可以让立即数为8字节</li><li>地址都是8字节，也就是上面的char*</li><li>如果把一个32位数给64位寄存器，那么高三十二位自动变成0.但是如果是16位或者8位的话高位不会改变</li></ul><p>例如：</p><p>movabsq $0x0011223344556677,%rax</p><p>movq $-1,%rax</p><p>%rax= 00000000ffffffff</p><h5 id="地址的写法"><a href="#地址的写法" class="headerlink" title="地址的写法"></a>地址的写法</h5><p>地址可以写为一个四元组 A（寄存器1，寄存器2，B）</p><p>这个四元组其实是  寄存器1+B*寄存器2+A</p><p>其中B可以是1,2,4,8。从数组的角度来看，寄存器1相当于起始地址，寄存器2相当于偏移地址，B是一个数据的字节数</p><p>同时 64位寄存器前缀是r，三十二位前缀是e，16位没有前缀，8位后面是l和h</p><p>例：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rax</span></span><br><span class="line"><span class="built_in">eax</span></span><br><span class="line"><span class="built_in">ax</span></span><br><span class="line"><span class="built_in">al</span></span><br><span class="line"><span class="number">ah</span></span><br></pre></td></tr></table></figure><h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>格式 movzab</p><p>a代表原格式，b代表现格式，一般是从小的转换成大的。而z代表多的位补0</p><p>例： movzlq</p><p>特殊形式： cltq 把32位寄存器扩展到64位并且赋值给自己，</p><p>movsab 有符号扩展，最高位为1那么扩展出来的位全是1。</p><h4 id="leaq-地址转移"><a href="#leaq-地址转移" class="headerlink" title="leaq 地址转移"></a>leaq 地址转移</h4><p>格式 leaq 地址，寄存器</p><p>看起来与mov没什么区别，但是mov中的地址是要取地址中的数，而这里的地址只是把对应地址给寄存器</p><p>例如： leaq (%rax,%rbx,4),%rdx 这条指令类似于把数组中某一元素的地址给了rdx</p><p>它还可用来求值</p><p>例如 要求x* 12</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mul(<span class="keyword">int</span> <span class="keyword">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">   lea<span class="string">q (%rdi,%rdi,2)</span>,%rax</span><br><span class="line">   salq %rax,<span class="number">2</span>//左移指令</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">x</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码只要看中间两条指令就可以了，leaq 中的数运算之后是3rdi，然后左移两位就是12了。</p><p>但是这条指令不会判断溢出，且不会改变标志寄存器</p><h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><p>这里涉及到标志寄存器，<a href="https://xinhecuican.github.io/2020/01/29/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/">在前面一篇博客中已经提到</a></p><p>cmpq 比较指令</p><p>textq 与比较</p><p>textq b a 把a与b相与，不改变a和b的值，只会改变标志寄存器中的zf和sf。</p><p>这个指令通常用来判断某一位是否是1，例如 textq a,0x1 ，如果最低位为1，那么zf就是0，说明最低位是1</p><h5 id="标志寄存器的访问"><a href="#标志寄存器的访问" class="headerlink" title="标志寄存器的访问"></a>标志寄存器的访问</h5><table><thead><tr><th>操作名</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>sete</td><td>ZF</td><td>Equal</td></tr><tr><td>setne</td><td>~ZF</td><td>not equal</td></tr><tr><td>sets</td><td>SF</td><td>sign</td></tr><tr><td>setns</td><td>~SF</td><td></td></tr><tr><td>setg</td><td><del>(SF^OF)&amp;</del>ZF</td><td>greater 有符号数</td></tr><tr><td>setge</td><td>~(SF^OF)</td><td>大于等于</td></tr><tr><td>setl</td><td>(SF^OF)</td><td>less</td></tr><tr><td>setle</td><td>…</td><td>小于等于</td></tr><tr><td>seta</td><td><del>CF&amp;</del>ZF</td><td>above 无符号数</td></tr><tr><td>setb</td><td>CF</td><td>below 小于</td></tr></tbody></table><p>这些指令都是返回到8位寄存器上，将高七位置0，最低位依据含义所进行的运算来判断是0还是1</p><p>之后可以 movzbl %al,%eax，这时高三十二位也会被清零</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p><a href="https://xinhecuican.github.io/2020/01/31/%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%8C%87%E4%BB%A4/">前面博客中也已谈到过</a></p><p>这里再补充jg和gb等，其实就是上面同样的模式</p><p>此外，由于是64位系统，没有cs寄存器，且intel使用cisc指令集，所以会自动根据指令长度进行判断用多少位长来储存位移</p><p>此外 x86 64位系统中 还提供了一种 jmp *(%rax) 也就是把rax作为地址，取内存中的内容</p><h4 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h4><p>格式： cmov +后缀 a b，后缀格式就是前面set的格式</p><p>作用: 如果满足条件，则把a赋值给b，如果不满足，则不做处理</p><p>现代编译器在遇到分支语句时会尽量用条件跳转的格式执行，因为cpu采用了流水线作业的模式（就是一次提前搬运多条指令） 但是条件跳转指令会使流水线停止运行，而流水线可以明显增加cpu速度。</p><p>条件跳转的格式就是先把 if 和else的内容都计算出来，然后在最后用条件跳转指令进行比较。</p><p>例如</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line"><span class="meta">if</span>(<span class="meta">x</span>&gt;y)</span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="meta">x</span>-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">else</span></span><br><span class="line">&#123;</span><br><span class="line">    a=y-<span class="meta">x</span>;</span><br><span class="line">&#125;</span><br><span class="line">汇编模式</span><br><span class="line">movq <span class="name">%rdi</span>,<span class="name">%rax</span></span><br><span class="line">subq <span class="name">%rsi</span>,<span class="name">%rax</span></span><br><span class="line">movq <span class="name">%rsi</span>,<span class="name">%rdx</span></span><br><span class="line">subq <span class="name">%rdi</span>,<span class="name">%rdx</span></span><br><span class="line">cmovle <span class="name">%rdx</span>,<span class="name">%rax</span></span><br></pre></td></tr></table></figure><p>可以看出，用条件跳转模式会多计算一些指令，不会破坏流水线，如果在流水线上减少的时间大于多进行指令所消耗的时间，那么用条件跳转指令比较合适。反之，直接用条件指令。</p><p>下列几种情况不适合用条件跳转指令</p><ol><li>分支语句计算量大（执行时间过多，划不来）</li><li>在要判断是否可以运算的情况，例如 var=p ？*p ： 0，这条语句意思是如果p不为空指针那么将p的内容赋给var，否则赋0.但是如果用条件跳转会出错，因为空指针不能取值</li><li>计算可能产生副作用（即前后两个分支之间会产生影响）。例如 var=x&gt;0 ? x*=3 : x+=6,这个分支前面对后面会产生影响，因此不能简单粗暴的直接条件跳转</li></ol><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ul><li>do-while循环</li></ul><p>do-while循环用goto语句表达成</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br></pre></td></tr></table></figure><p>这段代码便是先执行，后比较。很容易就可以转化成汇编。goto可以用条件转移指令代替。</p><ul><li>while循环</li></ul><p>while循环有两种形式，第一种是在最开始进行一次跳转，如果符合则进入循环，不符合则退出</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!x) <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">statement;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">goto</span> <span class="keyword">loop</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>第二种是先跳过第一次循环直接进行判断。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goto test;</span><br><span class="line">loop:</span><br><span class="line">statement;</span><br><span class="line">test:</span><br><span class="line">if(x) goto loop;</span><br></pre></td></tr></table></figure><p>由于cpu流水线的限制，两条连续的跳转指令会减慢cpu运行的速度，因此最好采用第一种办法（虽然代码多）</p><ul><li>for循环</li></ul><p>for(init; test; update)</p><p>可以转化成</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init<span class="comment">;</span></span><br><span class="line">while(test)</span><br><span class="line">&#123;</span><br><span class="line">  statement<span class="comment">;</span></span><br><span class="line">  update<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再然后就可以变成汇编代码</p><h4 id="switch-汇编实现"><a href="#switch-汇编实现" class="headerlink" title="switch 汇编实现"></a>switch 汇编实现</h4><p>首先要了解条件语句和switch的区别，if语句要从上倒下一条一条判断，如果数量多的话时间开销大。而switch是根据标号直接跳转，无论要跳转到哪一个时间开销都一定。</p><p>内存中实际上在编译时已经设定了一个跳转表，这个跳转表的标号是一个固定的地址，不能被改变，这个标号内的数据就是每一条指令的跳转地址，而且是8字节。</p><p>因此跳转语句可以这样写: jmp .L4(,%rdi,8)</p><p>其中.L4代表的是跳转表的标号（不一定是这个名字，举个例子）而rdi就是switch中的x，</p><p>如果标号很大，例如10000甚至1000000开始的时候，如果把前面的查找表一个个全部设置出来，空间开销会很大，所以编译器会先自动的减去一个数使他处于较小的范围，但是这种情况只适用于数据密集的情况。</p><p>如果数据稀疏例如一个是1一个是10000，这个时候偏移也不行了，只有通过先排序再二分搜索来查找标号，这个复杂度是logn</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用g++ -Og -s -masm=intel name.c 可以生成intel格式的汇编代码，-s是生成汇编代码，-Og是省去不重要的部分，如果不加这个，可能5条指令要变成十多条指令&lt;/p&gt;
&lt;p&gt;-fno-if-conversion 分支语句不要采用条件传输的方式，条件
      
    
    </summary>
    
    
      <category term="汇编" scheme="http://xinhecuican.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="AT&amp;T" scheme="http://xinhecuican.github.io/tags/AT-T/"/>
    
  </entry>
  
  <entry>
    <title>在不更改注册表的情况下把程序移出c盘</title>
    <link href="http://xinhecuican.github.io/2020/03/09/%E5%9C%A8%E4%B8%8D%E6%9B%B4%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%8A%8A%E7%A8%8B%E5%BA%8F%E7%A7%BB%E5%87%BAc%E7%9B%98/"/>
    <id>http://xinhecuican.github.io/2020/03/09/%E5%9C%A8%E4%B8%8D%E6%9B%B4%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%8A%8A%E7%A8%8B%E5%BA%8F%E7%A7%BB%E5%87%BAc%E7%9B%98/</id>
    <published>2020-03-09T03:37:00.000Z</published>
    <updated>2020-03-09T03:41:59.882Z</updated>
    
    <content type="html"><![CDATA[<p>这里用的类似于快捷方式。用mklink命令，这个命令可以将两个文件夹连接，一个是真实存放内容的文件夹，另一个只有名称，实际内容并不放在哪里。所以我们可以创建一个这样的文件夹来骗过程序。例如 office</p><p>首先要用cmd而不能用powershell，这是系统自带命令.然后在其他盘建一个同名的文件夹。注意c盘的文件夹不要创建，执行命令后系统自动创建。</p><p><code>mklink /J &quot;C:\Program Files (x86)\Microsoft Files&quot; &quot;D:\Program Files (x86)\Microsoft Files&quot;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里用的类似于快捷方式。用mklink命令，这个命令可以将两个文件夹连接，一个是真实存放内容的文件夹，另一个只有名称，实际内容并不放在哪里。所以我们可以创建一个这样的文件夹来骗过程序。例如 office&lt;/p&gt;
&lt;p&gt;首先要用cmd而不能用powershell，这是系统自带
      
    
    </summary>
    
    
      <category term="windows" scheme="http://xinhecuican.github.io/categories/windows/"/>
    
    
  </entry>
  
  <entry>
    <title>c语言的动态内存分配</title>
    <link href="http://xinhecuican.github.io/2020/03/02/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://xinhecuican.github.io/2020/03/02/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</id>
    <published>2020-03-02T08:39:00.000Z</published>
    <updated>2020-03-02T10:48:43.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>头文件： malloc.h</p><p>原型 void* malloc( size)（不标准写法）</p><p>其中size表示的是你想申请的字节数，为了准确我们一般使用sizeof函数，而返回的是一个void指针，这就导致了我们一般都要强制类型转换到对应的类型。</p><p>例： int* p=(int*)malloc(sizeof(int))</p><p>   int* p=(int<em>)malloc(10</em>sizeof(int)) //数组</p><p>   前面的int* 就是强制类型转换</p><p>此外，malloc一般分配完内存后还要进行检查看是否分配成功</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p==NULL)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);<span class="regexp">//</span>退出程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且malloc是不会自动初始化的，所以在分配完内存后最好先用NULL初始化一下。</p><h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><p>字面意思，就是给一个已经分配内存的指针增加内存,原内存中的数据不变</p><p>头文件 #include &lt;stdlib.h&gt; 有些编译器需要#include &lt;alloc.h&gt;</p><p>原型： void* realloc(void *mem_address, unsigned int newsize);</p><p>mem_address是原指针，newsize是原有空间加上新增的空间</p><p>可能有下列几种情况</p><ol><li>如果原有空间后面还有足够的内存空间，那么直接在后面增加内存空间</li><li>如果原有空间不足，会重新分配空间到其他地方，同时原地址中的数据也会复制过去</li><li>如果没有可供分配的空间，返回NULL。此时，原指针仍然有效</li></ol><p>注意，如果分配成功，无论是否分到新空间，原指针都会被释放掉</p><p>如果 mem_address为0 那么和malloc相似，也是分配一块内存空间</p><p>如果 newsize为0，相当于free</p><p>也就是说，最好不要出现 p=realloc(p,size)这种写法，防止分配失败后指针直接丢失。好的办法是先用另一个参数接受realloc的内容，如果不为null，再让p=q</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* q;</span><br><span class="line">q=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(p,newsize);</span><br><span class="line"><span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>释放动态申请的内存空间</p><p>原型： void free(void* ptr)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;malloc&quot;&gt;&lt;a href=&quot;#malloc&quot; class=&quot;headerlink&quot; title=&quot;malloc&quot;&gt;&lt;/a&gt;malloc&lt;/h3&gt;&lt;p&gt;头文件： malloc.h&lt;/p&gt;
&lt;p&gt;原型 void* malloc( size)（不标准写法）&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>程序的进入与退出</title>
    <link href="http://xinhecuican.github.io/2020/03/02/%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%9B%E5%85%A5%E4%B8%8E%E9%80%80%E5%87%BA/"/>
    <id>http://xinhecuican.github.io/2020/03/02/%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%9B%E5%85%A5%E4%B8%8E%E9%80%80%E5%87%BA/</id>
    <published>2020-03-02T06:18:00.000Z</published>
    <updated>2020-03-02T08:38:55.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="程序进入"><a href="#程序进入" class="headerlink" title="程序进入"></a>程序进入</h3><p>在c++中，程序的入口是main函数，并且main函数有两个参数</p><p>int main(int argc,char* argv[])</p><p>argc是用来记录输入的参数的数量，而argv是用来记录输入的参数。</p><p>例如： ls -la，这个输入中有两个参数，第一个参数是ls，第二个参数是-la</p><h3 id="程序退出"><a href="#程序退出" class="headerlink" title="程序退出"></a>程序退出</h3><p>return 是退出当前函数，例如退出主函数或者退出任意函数</p><p>而 exit 是退出当前进程，也就是说就算是在调用的函数中，这个程序也会直接结束</p><p>exit(0)表示正常退出，exit(1)表示异常退出，更深入的内容涉及到进程。</p><p>exit函数在stdlib.h头文件中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;程序进入&quot;&gt;&lt;a href=&quot;#程序进入&quot; class=&quot;headerlink&quot; title=&quot;程序进入&quot;&gt;&lt;/a&gt;程序进入&lt;/h3&gt;&lt;p&gt;在c++中，程序的入口是main函数，并且main函数有两个参数&lt;/p&gt;
&lt;p&gt;int main(int argc,char
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="c++" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/c/"/>
    
    
  </entry>
  
  <entry>
    <title>过滤器</title>
    <link href="http://xinhecuican.github.io/2020/03/01/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://xinhecuican.github.io/2020/03/01/%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-03-01T02:53:00.000Z</published>
    <updated>2020-03-17T13:17:25.270Z</updated>
    
    <content type="html"><![CDATA[<p>管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中），但是在最前面的和在最后面的不一定是过滤器。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="cat-复制"><a href="#cat-复制" class="headerlink" title="cat 复制"></a>cat 复制</h4><p>cat的用途就是把标准输入中的数据复制到标准输出中</p><p>应用：可以与重定向结合。cat &gt; data，这样从键盘中输入的数据将直接传到data文件中</p><p>此外还可以让文件内容显示在控制台上，有 cat &lt; data，标准输入变成了data文件，标准输出是屏幕。为了方便，直接cat 文件名也是可以的</p><p>此外，tail也有类似的功能，但是它只能显示最后的十行</p><p>另外一个应用就是把一个文件复制到另一个文件。例如，cat &lt; data &gt; newdata</p><h5 id="增强cat功能"><a href="#增强cat功能" class="headerlink" title="增强cat功能"></a>增强cat功能</h5><p>cat &lt; file…= cat file …</p><p>有三个点说明了可以同时输入多个文件，这样就为组合多个文件提供了途径</p><p>cat data1 data2 data3 &gt;file</p><p>后缀： </p><pre><code>-n 在每行后面加一个行号-b 与-n一起使用，不要对空白行加行号-s 将多个连续的空白行变成一个空白行</code></pre><h4 id="split-分为不同文件"><a href="#split-分为不同文件" class="headerlink" title="split 分为不同文件"></a>split 分为不同文件</h4><p>语法 split [-d] [-a num] [-l lines] [file [prefix]]</p><p>作用： 将一个大文件分解成几个小文件。默认情况下，split将创建1000行长的空间</p><p>参数： </p><pre><code>-l 创建一个5000行的空间-d 将文件名改为从00开始编号-a 后面加数字，例如3表示从000开始，总共1000个文件名</code></pre><p>默认情况下，split创建的文件将以x开头，后面加aa，ab等</p><h4 id="tac-反转复制"><a href="#tac-反转复制" class="headerlink" title="tac 反转复制"></a>tac 反转复制</h4><p>相关过滤器： cat，rev</p><p>作用：和cat类似，但是在写入文件时把文件内容反转（tac是将cat反过来）。注意，这里的反过来并不是指从后往前倒着写，而是把行与行将顺序反过来。</p><h4 id="rev-反转字符顺序"><a href="#rev-反转字符顺序" class="headerlink" title="rev 反转字符顺序"></a>rev 反转字符顺序</h4><p>相关过滤器： cat tac</p><p>作用： 将各行字符顺序反转</p><p>语法： rev [file…]</p><p>例如： 有一个文件data，里面有</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345</span></span><br><span class="line">abcde</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure><p>之后用rev后会变成</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54321</span></span><br><span class="line">edcba</span><br><span class="line">AxAxA</span><br></pre></td></tr></table></figure><p>rev也是直接输出到标准输出上的，也就是说并不会对源文件造成改变，如果想输出到文件中，还要重定向一下</p><h4 id="head，tail-从数据开头或者结尾读取"><a href="#head，tail-从数据开头或者结尾读取" class="headerlink" title="head，tail 从数据开头或者结尾读取"></a>head，tail 从数据开头或者结尾读取</h4><p>语法： head/tail [-n lines]，lines是希望选择的数据行</p><p>默认情况下，head和tail都只会选择十行数据，用-n可以选择任意行数</p><p>例： calculate | tail -n 15</p><h4 id="colrm-删除数据列"><a href="#colrm-删除数据列" class="headerlink" title="colrm 删除数据列"></a>colrm 删除数据列</h4><p>相关过滤器： cut paste</p><p>colrm（“column remove”)程序从标准输入中读取数据，删除指定数据列（也就是竖的删除），将剩余数据写入标准输出</p><p>语法： colrm [startcol [endcol]]，编号从1开始</p><p>例： colrm 14 30 &lt;students | less</p><h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><h4 id="cmp-比较两个任意文件"><a href="#cmp-比较两个任意文件" class="headerlink" title="cmp 比较两个任意文件"></a>cmp 比较两个任意文件</h4><p>相关过滤器：comm diff sdiff</p><p>语法: cmp file1 file2</p><p>cmp程序逐字节的比较文件，查看两个文件是否相同。如果两个文件相同，那么不做任何处理，如果不同，将会返回第一个不同的行和列</p><h4 id="comm-比较有序文件"><a href="#comm-比较有序文件" class="headerlink" title="comm 比较有序文件"></a>comm 比较有序文件</h4><p>语法：comm [-123] file1 file2</p><p>comm程序一行一行的比较两个有序的文本间，程序输出三列，第一列输出只包含在第一个文件中的行，第二列输出只包含在第二个文件中的行，第三列输出两个文件中都有的行。</p><p>因为comm是逐行比较，所以在比较之前最好使用sort进行排序</p><p>参数： -1 -2 -3 取消第一二三列的输出</p><h4 id="diff-比较无序文件"><a href="#diff-比较无序文件" class="headerlink" title="diff 比较无序文件"></a>diff 比较无序文件</h4><p>语法： diff [-bBiqswy] [-c| -Clines | -u | -Ulines] file1 file2</p><p>lines是说明上下文关系的行号</p><p>输出： diff的输出有三个不同的单字符指示： c（change） d（delete） a（append）。这三个字符说明了要想让两个文件相同需要做哪些改变。</p><p>这三个字符左右两边都会有数字，代表着需要修改的行号。例如，3c3代表把左边文件中的第三行变成右边文件中的第三行。</p><p>diff要求改变时，就会给出每一个文件的实际行，第一个文件中的行用小于号标记，第二个文件中的行用大于号标记。两组行之间还会有横线分隔开</p><p>例如，第一个文件为</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br><span class="line">asdf</span><br><span class="line"><span class="keyword">as</span> df</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>第二个文件为</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>     </span><br><span class="line"><span class="attribute">abcd</span></span><br><span class="line"><span class="attribute">asdf</span></span><br><span class="line"><span class="attribute">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">0a1</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">a</span>     </span><br><span class="line"><span class="number">3</span><span class="string">,4c4</span></span><br><span class="line"><span class="string">&lt;</span> <span class="string">as</span> <span class="string">df</span></span><br><span class="line"><span class="string">&lt;</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure><p>a左边的数代表在左边数后面追加一行，例如0a1代表在第0行后面加上右边的第一行</p><p>d一般只需要管左边的数字，它的意思是删去左边的那一行</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-i 忽略大小写区别</span></span><br><span class="line"><span class="deletion">-w（whitespace) 忽略所有空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别，就是把多个空白符看成一个</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行，</span></span><br><span class="line"><span class="deletion">-q 当两个文本不同时，忽略所有细节，只说两文本不同</span></span><br><span class="line"><span class="deletion">-s 会明确告诉两个文本相同</span></span><br><span class="line"><span class="deletion">-c 全文比较，+代表要增加，-代表要减少，！代表要替换</span></span><br><span class="line"><span class="deletion">-u 与-c类似，但是把两个文件混合在一起显示，两个重复行只输出一个</span></span><br><span class="line"><span class="deletion">-y 把两个文件并排输出</span></span><br></pre></td></tr></table></figure><h4 id="sdiff"><a href="#sdiff" class="headerlink" title="sdiff"></a>sdiff</h4><p>语法： sdiff [-bBilsW] [-w columns] file1 file2</p><p>作用：与 diff -y 类似，并排比较<br>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-l 当两个文件有共同行时，只显示左边的列</span></span><br><span class="line"><span class="deletion">-s 不显示两个文件中任何相同的行</span></span><br><span class="line"><span class="deletion">-w+数字 改变列的宽度</span></span><br><span class="line"><span class="deletion">-i 忽略大写和小写的区别</span></span><br><span class="line"><span class="deletion">-W 忽略所有的空白符</span></span><br><span class="line"><span class="deletion">-b 忽略空白符数量上的区别</span></span><br><span class="line"><span class="deletion">-B 忽略所有空白行</span></span><br></pre></td></tr></table></figure><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p>例如： diff game1_ver1.0.c game2_ver2.0.c &gt; game2_ver2.1</p><p>这个命令会把第一个文件和第二个文佳之间的差保存下来，这样可以节省空间，此外在日后不慎丢失文件时也有办法快速找回</p><h4 id="cut-抽取数据列"><a href="#cut-抽取数据列" class="headerlink" title="cut 抽取数据列"></a>cut 抽取数据列</h4><p>相关过滤器： colrm join paste</p><p>语法： cut -c list [file…]</p><p>list就是要抽取的数据列，各个列之间用逗号隔开，不能有空格，或者14-19表示从14列到19列</p><p>作用：抽取指定的列</p><p>这种按列切分遇到长度不同的数据时就显得无能为力，因此还有另一种抽取方式，抽取字段，即按照一定的定界符进行分割（如逗号，空格等）</p><p>参数：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c  <span class="meta">list</span> [<span class="meta">file</span>...] <span class="meta">list</span>表明抽取第几个字段</span><br><span class="line">-f  <span class="meta">list</span> [-d <span class="meta">delimiter</span>] [-s] [<span class="meta">file</span>...]  -d后面是定界符种类 -s（suppress 抑制）抛弃没有定界符的行。例如 cut -f 1 -d <span class="string">':'</span> ./temp</span><br></pre></td></tr></table></figure><h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>语法： paste [-d char…] [file…]</p><p>其中char是用来做分隔符的字符，默认情况为一个制表符或者是空格</p><p>作用： 把几个文件组合成一个表格（组合数据列）</p><p>如果指定了不止一个定界符，那么将会轮流使用定界符</p><p>例如： paste -d ‘|%’ name phone ，这个指令中就有两个定界符</p><h3 id="统计和格式化"><a href="#统计和格式化" class="headerlink" title="统计和格式化"></a>统计和格式化</h3><h4 id="nl-创建行号"><a href="#nl-创建行号" class="headerlink" title="nl 创建行号"></a>nl 创建行号</h4><p>语法： nl [-v start] [-i increment] [-b a] [-n ln|rn|rz] [file…]</p><p>start是起始行号 ，increment是增量</p><p>作用：希望在一些数据中永久的插入行号，在输出中临时插入行号。一般状况下，插入的行号都是临时的，原始数据并不会发生改变，除非重定向输出到文件中。</p><p>默认情况下，不会对空行编号</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-v 改变起始编号，默认起始编号是1</span></span><br><span class="line"><span class="deletion">-i 改变增量，默认增量为1</span></span><br><span class="line"><span class="deletion">-b a 对所有行编号，包括空行</span></span><br><span class="line"><span class="deletion">-n ln 左对齐 rn 右对齐 rz 右对齐，有前导0</span></span><br></pre></td></tr></table></figure><h4 id="wc（word-count）统计行单词和字符的数量"><a href="#wc（word-count）统计行单词和字符的数量" class="headerlink" title="wc（word count）统计行单词和字符的数量"></a>wc（word count）统计行单词和字符的数量</h4><p>语法： wc [-clLw] [file…]</p><p>作用：统计行，单词，字符的数量。所统计的数据可以来自另一个程序或者是一个或多个文件</p><p>输出依次输出行，单词数，字符数 和文件名。如果不止一个文件，那么会为每一个文件显示一个输出，然后最后一行是一个总输出。</p><p>参数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-l 统计行</span></span><br><span class="line"><span class="deletion">-w 统计单词</span></span><br><span class="line"><span class="deletion">-c 统计字符</span></span><br><span class="line"><span class="deletion">-L 该选项显示输入中最长行的长度</span></span><br></pre></td></tr></table></figure><p>此外，还可以用wc来统计某一目录中文件的数量，假设一个文件一行，用ls file | wc -l.</p><h4 id="制表符和空格"><a href="#制表符和空格" class="headerlink" title="制表符和空格"></a>制表符和空格</h4><p>在老式机器中，会在某些特定的为做一些机器标记，这些标记叫做制表位，如果按了制表位，那么机器会直接跳转到下一个制表位上，tab键与这个作用类似。一旦按了tab键，那么他将会自动跳转到下一个制表位。例如输入<code>A&lt;Tab&gt;BBBB&lt;Tab&gt;CCC</code>，实际上看起来中间有空格，实际上只有一个Tab</p><p>可视化制表符</p><p>第一种办法是在vi中，set list 那么制表符会转化成^I符号</p><h4 id="expand-将制表符转化成空格"><a href="#expand-将制表符转化成空格" class="headerlink" title="expand 将制表符转化成空格"></a>expand 将制表符转化成空格</h4><p>语法： expand [-i] [-t size] [-t list] [file…]</p><p>其中size是固定宽度制表符的大小（默认为8)，list是制表位列表</p><p>作用：expand将输入文件中所有的制表符转化成空格，别切维持与原文本相同的对齐方式</p><p>-i 只转换开头的制表符，其他的制表符保持不变</p><h4 id="unexpand-将空格转化成制表符"><a href="#unexpand-将空格转化成制表符" class="headerlink" title="unexpand 将空格转化成制表符"></a>unexpand 将空格转化成制表符</h4><p>语法： unexpand [-a] [-t size] [-t list] [file…]</p><p>其中size是制表符的大小（希望设置的），list是制表位列表</p><p>一般情况下，unexpand只转化第一行的空格，如果想要转换所有行的空格，那么需要-a选项</p><h4 id="fold-格式化行"><a href="#fold-格式化行" class="headerlink" title="fold 格式化行"></a>fold 格式化行</h4><p>相关过滤器： fmt ,pr</p><p>语法： fold [-s] [w witch] [file…]</p><p>其中witch是新行的宽度。</p><p>作用： 将长的行分割成短行。也就是把一行分成多行。其实就是在适当位置插入一个回车符</p><p>默认状态下，80个字符为一行。</p><p>-s选项是告诉程序不要分割单词，也就是说如果那个单词正好在要分割的位置，那么现在会先显示这个单词在转到下一行。</p><h4 id="fmt-格式化段落"><a href="#fmt-格式化段落" class="headerlink" title="fmt 格式化段落"></a>fmt 格式化段落</h4><p>语法： fmt [-su] [-w width] [file…]</p><p>作用：让各行连接在一起，并且不改变空白符。</p><p>当它读取文本时，假定段落由空行分隔。一个“段落”就是一个或多个连续的文本行，不包括空行。fmt根据下列规则读取一个段落</p><ul><li>行宽： 让每行尽可能的长，并且不超过指定的长度。默认情况下，每行最多75个字符</li><li>句子： 无论何时，尽可能在句子末尾分隔行。避免在句子的第一个单词之后或最后一个单词之前分隔行。</li><li>空白符： 保持单词及空行之间的所有缩进，空格。</li><li>制表符： 所有制表符转化成空格。并在最后输出时合适的位置插入制表符</li></ul><p>说起来复杂，其实就是让那些长短不一的段落尽量变得长。</p><p>例如</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">As we all know,</span><br><span class="line"><span class="keyword">success </span>cones slowly and</span><br><span class="line">is due to a number of different factors all coming</span><br><span class="line">together</span><br><span class="line">over a period of years</span><br></pre></td></tr></table></figure><p>使用命令后</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">As</span> we <span class="keyword">all</span> know, <span class="type">real</span> success comes slowly <span class="keyword">and</span> <span class="keyword">is</span></span><br><span class="line">due <span class="keyword">to</span> a number <span class="keyword">of</span> different factors <span class="keyword">all</span> coming</span><br><span class="line">together <span class="keyword">over</span> a period <span class="keyword">of</span> years.</span><br></pre></td></tr></table></figure><p>此外，它是一段的作用，如果两行之间有个空行就把他们当成两段单独处理，互不影响</p><p>参数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-u(uniform spacing 统一间距) 减少空格，每个单词之间最多只有一个空格，句子末尾最多只有两个空格。</span></span><br><span class="line"><span class="deletion">-w 设定宽度</span></span><br></pre></td></tr></table></figure><h4 id="pr-按页格式化文本"><a href="#pr-按页格式化文本" class="headerlink" title="pr 按页格式化文本"></a>pr 按页格式化文本</h4><p>语法： pr [-dt] [+beg[:end]] [-h text] [-l n] [-o margin] [-W width] [file…]</p><p>作用： 按页格式化文件，以便于打印。</p><p>其中 beg是需要格式化的第一页，end是最后一页，text是标题，n是每页的行数，margin是左边缘的大小，width是输出的宽度。</p><p>默认情况下，pr是通过顶端插入一个标题，左边插入一个边缘，底部插入一个页尾来格式化文件。标题包括修改时间，文件名称和页号。</p><p>如果想查看效果，最好在less程序中</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-d 双倍行距文本（word中的）</span></span><br><span class="line"><span class="addition">+begin;end 从那页到哪页格式化</span></span><br><span class="line"><span class="deletion">-l 改变每页总行数</span></span><br><span class="line"><span class="deletion">-o 设置左边缘</span></span><br><span class="line"><span class="deletion">-W 改变每一行的字符数（默认是72）</span></span><br></pre></td></tr></table></figure><p>还可以按列格式化文本</p><p>语法： pr [-mt] [-columns] [-l lines] [-W width] [file…]</p><p>column是输出列的数量，lines是每页的行数，width是每行的字符数。这个选项不建议用，会截断字符。</p><h3 id="选取，排序，组合，变换"><a href="#选取，排序，组合，变换" class="headerlink" title="选取，排序，组合，变换"></a>选取，排序，组合，变换</h3><h4 id="grep-选取特定模式的行"><a href="#grep-选取特定模式的行" class="headerlink" title="grep 选取特定模式的行"></a>grep 选取特定模式的行</h4><p>相关过滤器： look strings</p><p>语法： grep [-cilLnrsvwx] pattern [file…]</p><p>pattern是要搜索的格式</p><p>作用： 从标准输入或文件中读取数据，抽取所有包含特定模式的行，并写入标准输出。</p><p>这个模式可以是字符串标点符号等，但是如果是标号或者特殊字符时，最好用’’强引用，以防止歧义。</p><p>选项：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-c(count) 统计所抽取行的数量，但不显示行本身</span></span><br><span class="line"><span class="deletion">-i（ignore) 忽略大小写的区别</span></span><br><span class="line"><span class="deletion">-n 所选行在原文件中的位置</span></span><br><span class="line"><span class="deletion">-l（list），如果在不只一个文件中搜索，使用这个选项可以只把匹配的文件名列举出来，此时文件名也要输出多个</span></span><br><span class="line"><span class="deletion">-L 显示不包含该模式的文件名</span></span><br><span class="line"><span class="deletion">-v（reverse） 选取不包含模式的行</span></span><br><span class="line"><span class="deletion">-x 选取完全匹配的行</span></span><br><span class="line"><span class="deletion">-r（recursive递归） 搜索整个目录树</span></span><br></pre></td></tr></table></figure><h5 id="fgrep，egrep-grep变体"><a href="#fgrep，egrep-grep变体" class="headerlink" title="fgrep，egrep grep变体"></a>fgrep，egrep grep变体</h5><p>fgrep，历史上使用，现在基本不用</p><p>egrep grep扩展版本，功能比grep强大，可以通过 grep -E的方式<br>-w 只匹配完整的单词，并且最好配合-l使用。</p><h4 id="look-选取以特定模式开头的行"><a href="#look-选取以特定模式开头的行" class="headerlink" title="look 选取以特定模式开头的行"></a>look 选取以特定模式开头的行</h4><p>格式： look [-df] pattern file…</p><p>作用： 搜索以字母顺序排列的数据，并查找所有以特定模式开头的行。然后输出这些行</p><p>look其实并不是一个过滤器，它只能从文件中读入，因此只能写于管道线的开头</p><p>-d 忽略标点和其他字符，本来是指搜索第一个单词</p><p>-f（fold同等） 忽略大写和小写的区别</p><h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h4><p>格式 sort [-dfnru] [-o outfile] [infile…]</p><p>作用： 排序数据和查看数据是否已经有序。他可以比较整行，也可以从每行中选取一部分进行比较。</p><p>sort可以重定向输出到另一个文件，但是不能输出到输入文件</p><p>例如： sort temp &gt; temp 是不可以的</p><p>但是可以使用-o选项，此时该文件中原有数据将会被保存，排序后的数据也会被追加到这个文件中</p><h5 id="dfnr-控制数据排序的顺序"><a href="#dfnr-控制数据排序的顺序" class="headerlink" title="-dfnr 控制数据排序的顺序"></a>-dfnr 控制数据排序的顺序</h5><p>-d(dictionary) 只查看字母，数字和空白符，当确定有阻碍排序的因素（如标点符号等），可以使用这个选项。</p><p>-f（fold 等同）不区分大小写</p><p>-n（numeric 数字） 识别开头或者字段开头的数字，并按照数字进行排序</p><p>-r 反向排序</p><p>-u（unique 唯一） 对于相同行，只保留一行</p><h5 id="检测数据是否有序-c"><a href="#检测数据是否有序-c" class="headerlink" title="检测数据是否有序 -c"></a>检测数据是否有序 -c</h5><p>-c（check） 不会排列数据，只会告诉数据是否有序，如果有序，将不会显示任何内容</p><h4 id="uniq-查找重复的行"><a href="#uniq-查找重复的行" class="headerlink" title="uniq 查找重复的行"></a>uniq 查找重复的行</h4><p>语法： uniq [-cdu] [infile [outfile]</p><p>作用： 消除重复行，选取重复行，选取唯一行，统计重复行的数量。不加选项输出非重复行和只输出一次重复行</p><p>注意uniq的输入必须是有序的</p><p>-d 只查看重复行</p><p>-u 只查看非重复行</p><p>-c 统计重复行出现的次数</p><h4 id="join-合并两个文件的有序数据"><a href="#join-合并两个文件的有序数据" class="headerlink" title="join 合并两个文件的有序数据"></a>join 合并两个文件的有序数据</h4><p>相关过滤器： colrm cut paste</p><p>语法： join [-i] [-al|-vl] [-a2|-v2] [-l field1] [-2 field2] file1 file2</p><p>其中field是引用特定数段的数字</p><p>作用： 把两个文件中对应行合并到一起。但是这又和sort不同，sort是直接把两个文件拼接在一起，而join则是重复数据合并为一个输出。不重复数据直接输出。读取输入时，会忽略前导空白符。</p><p>不使用其他标号情况下，只会显示有匹配的连接字段（也就是两个文件对应行有相同字段），如果使用-a(all)选项，将会显示整个文件，后面要加a1或a2。a1代表把第一个文件中不匹配的内容也加上去。如果是v1，显示V1中不匹配的行</p><p>-1+sum 将第一个文件中的第sum个字段和第二个文件中的第一个字段进行匹配</p><h4 id="tsort-由偏序创建全序"><a href="#tsort-由偏序创建全序" class="headerlink" title="tsort 由偏序创建全序"></a>tsort 由偏序创建全序</h4><p>语法： tsort file</p><p>作用：将一系列的事一件一件从头到尾输出</p><p>例如：两个单词第二个单词代表在第一个单词后要做的事</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eat clean-<span class="keyword">dishes</span></span><br><span class="line"><span class="keyword">clean-dishes </span>watch-TV</span><br><span class="line"><span class="keyword">shop </span>cook</span><br><span class="line">cook eat</span><br></pre></td></tr></table></figure><p>在使用了tsort后，输出为</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shop</span></span><br><span class="line"><span class="keyword">cook</span></span><br><span class="line"><span class="keyword">eat</span></span><br><span class="line"><span class="keyword">clean-dishes</span></span><br><span class="line"><span class="keyword">watch-TV</span></span><br></pre></td></tr></table></figure><h4 id="strings-在二进制文件中搜索字符串"><a href="#strings-在二进制文件中搜索字符串" class="headerlink" title="strings 在二进制文件中搜索字符串"></a>strings 在二进制文件中搜索字符串</h4><p>语法： strings [-length] file…</p><p>在现代软件中基本都有这种功能，不再展开</p><h4 id="转换字符-tr"><a href="#转换字符-tr" class="headerlink" title="转换字符 tr"></a>转换字符 tr</h4><p>语法： tr [-cds] [set1 [set2]]</p><p>set1是字符组</p><p>作用：可以将一个字符转化成另一个字符，例如将小写转化成大写，将制表符转化成空格，或者将0转化成x等。此外，还可以将多个字符变成一个字符，例如将多个空格转化成一个空格。最后，还可以删除指定字符，例如删除制表符。</p><p>例如： tr a A &lt; old tr a-z A-Z &lt; old</p><p>当需要替换的字符中出现由特殊意义的字符时，需要引用他们</p><p>还有几种特殊的缩写 [:lower:] 代表小写字母，[:upper:]代表大写字母，[:digit:]代表数字</p><p>tr还可以转换不可见字符</p><p>例如： tr ‘\n’ ‘\t’ &lt; old</p><p>参数：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">s 多个字符变成一个字符 例如 tr -s <span class="string">' '</span> <span class="string">' '</span> &lt; old</span></span><br><span class="line"><span class="ruby">-d 删除指定字符</span></span><br><span class="line"><span class="ruby">-c 把没选上的字符变成另一个字符，例如 tr -c <span class="string">' \n'</span> x &lt; old，这个的意思就是除了空格和换行之外其他所有字符都变成x</span></span><br></pre></td></tr></table></figure><h4 id="sed-非交互式文本编辑"><a href="#sed-非交互式文本编辑" class="headerlink" title="sed 非交互式文本编辑"></a>sed 非交互式文本编辑</h4><p>交互式文本编辑就是有一个窗口，例如gedit vi等。而非交互式则需要提前设计命令，然后将命令发给程序。</p><p>语法： sed [-i] command | -e command… [file…]</p><p>command是sed命令</p><p>作用： sed是一个标准的过滤器，可以对标准输入或者标准输出进行修改</p><p>sed从输入流中每次读取一行。然后执行下面三个步骤</p><ol><li>从输入流中读取一行</li><li>执行指定的命令，对该行进行必要的修改</li><li>将该行写入输出流中</li></ol><p>因为是修改标准输入或者标准输出，所以源文件不会被修改，如果要修改原文件，可以加上-i(in-place)选项，这个选项会将输出保存到一个临时文件，一但所有数据处理完，sed就会把临时文件复制到原文件中</p><h5 id="使用sed进行替换"><a href="#使用sed进行替换" class="headerlink" title="使用sed进行替换"></a>使用sed进行替换</h5><p>想要用sed对标准输入或输出的内容进行修改，可以采用 s命令</p><p>形式： /address|pattern/ s /search/replacement/[g]</p><p>address 是输入流中一个行或者多个行的地址，pattern是一个字符串，search是正则表达式，replacement是一个替换文本</p><p>例如 sed s/harley/Harley,这个例子意思就是把每一行的第一个harley改成Harley，如果想把所有都改了，那么在后面要加上一个g</p><p>如果只对一些行进行操作，可以用下列语法：</p><p>number[,number] /regex/</p><p>number是行号</p><p>例如： sed ‘5s/harley/Harley/g’ names</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;管道线中一个个的命令就是过滤器（从标准输入中接受数据，然后再传到标准输出中），但是在最前面的和在最后面的不一定是过滤器。&lt;/p&gt;
&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>加法溢出和乘法溢出</title>
    <link href="http://xinhecuican.github.io/2020/02/29/%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA/"/>
    <id>http://xinhecuican.github.io/2020/02/29/%E5%8A%A0%E6%B3%95%E6%BA%A2%E5%87%BA/</id>
    <published>2020-02-29T03:07:00.000Z</published>
    <updated>2020-02-29T03:46:23.753Z</updated>
    
    <content type="html"><![CDATA[<p>无符号数加法便是两个数相加，如果超过最大值那么就截断超过的位数。截断超过的位数也就相当于mod2^n,因为这样做超过的位都会被模去变成0.</p><p>有符号数加法相对复杂。先是变成无符号数加法，加完 之后再按有符号数编码去理解，这样就会产生两种溢出，正溢出和负溢出。</p><p>首先，如果两个数一正一负，则不可能产生进位。</p><p>正溢出很好理解，最高一位为符号位，假如两个正数一加，超过了最大值，那么第2^w-1位就会变成1，这一位是符号位，因此这个数字便会变成负数。</p><p>如果是负溢出，因为两个数最高位一定为1，如果2^w-2位没有发生进位的话，那么就产生了溢出，此时最高位为0，变成正数</p><p>例如：10111111+10111111（-65）=01111110（126）</p><p>所以说如果是正数溢出，则需要-2^m,如果是负溢出，则需要加上2^m</p><p>判定是否发生溢出 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=a+b;</span><br><span class="line"><span class="keyword">if</span>((a&gt;<span class="number">0</span>==b&gt;<span class="number">0</span>)&amp;&amp;(a&lt;<span class="number">0</span>!=s&lt;<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"发生溢出"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"没有发生溢出"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a&gt;0==b&gt;0的意义是判断a和b的符号是否相同,相同为真.a&lt;0!=s&lt;0的含义是判断a和s的符号是否<br>乘法溢出相对简单粗暴，直接把高位全部截断，也就是对2^w取模，有符号数乘法是先不管符号位直接把后面的位相乘，然后再把符号位补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无符号数加法便是两个数相加，如果超过最大值那么就截断超过的位数。截断超过的位数也就相当于mod2^n,因为这样做超过的位都会被模去变成0.&lt;/p&gt;
&lt;p&gt;有符号数加法相对复杂。先是变成无符号数加法，加完 之后再按有符号数编码去理解，这样就会产生两种溢出，正溢出和负溢出。&lt;/
      
    
    </summary>
    
    
      <category term="计算机系统基础" scheme="http://xinhecuican.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>重定向与管道</title>
    <link href="http://xinhecuican.github.io/2020/02/29/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93/"/>
    <id>http://xinhecuican.github.io/2020/02/29/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93/</id>
    <published>2020-02-29T00:05:00.000Z</published>
    <updated>2020-02-29T02:50:22.437Z</updated>
    
    <content type="html"><![CDATA[<h3 id="标准输入-标准输出和标准错误"><a href="#标准输入-标准输出和标准错误" class="headerlink" title="标准输入 标准输出和标准错误"></a>标准输入 标准输出和标准错误</h3><p>基本思想：每个基于文本的程序都可以从任何源接受输入，并向任何目标输出</p><p>标准输入指的是一种读取数据的通用办法，标准输出有两种，一种是标准输出，另一种是标准错误</p><p>而输入输出其实正常情况下有shell决定。为了保证程序的输出，需要告诉shell将输出目标设置成文件。</p><h3 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h3><p>在登陆时，shell会自动将标准输入设置成键盘，将标准输出和标准错误设置成屏幕。</p><p>但是每次输入命令时，可以告诉shell在此命令执行期间更换输入输出对象。</p><p>如果想把一个命令输出送到一个文件中，例如sort命令 可以写成 sort &gt; names</p><p>以这种命令输出时，如果文件不存在，shell会自动创建这个文件。如果文件存在，那他将会把文件内容全部清空然后再把内容输入到里面去</p><p>如果我们只想追加内容到这个文件中，可以用 &gt;&gt; 。如果文件不存在，这个命令也会创建新文件，如果存在，那么会追加内容到后面。</p><p>如果取消清空文件重新输入的选项，可以设置nonclobber选项。但是设置完之后，如果确实想替换掉这个文件，可以临时忽略掉noclobber，这时需要用<code>&gt;|</code>替换 &gt;</p><h4 id="重定向标准输入"><a href="#重定向标准输入" class="headerlink" title="重定向标准输入"></a>重定向标准输入</h4><p>符号： &lt;</p><p>左边是你要运行的程序，右边是你有读入数据的文件</p><p>例如 sort &lt; /etc/passwd</p><p>标准输入和标准输出可以同时指定</p><p>例如 sort &lt; rawdata &gt; report，这个命令会把rawdata中的数据给sort处理，然后把结果给report文件</p><h4 id="重定向标准错误"><a href="#重定向标准错误" class="headerlink" title="重定向标准错误"></a>重定向标准错误</h4><p>shell提供两种输出目标，标准输出和标准错误。正常情况下，两种输出同时显示在屏幕上，在需要时，可以把两种输出分隔开。</p><p>首先对unix处理I/O过程了解。每个输入源和每个输出目标都有一个唯一的数字标识，，这个数字 称为文件描述符。例如一个进程可能从#8中读取数据，并将文件写入#6中</p><p>例如为了将输出写入到文件8中，可以sort 8&gt; results，results就是第8个文件</p><p>默认情况下，Unix为每个进程提供三个预定义的文件描述符。而且大多数时候都可以使用。0代表标准输入，1代表标准输出，3代表标准错误。</p><p>所以要想重定向输入，可以用 0&lt;</p><p>而要想重定向标准输出，可以用 1&gt; ,这样错误信息就会留在屏幕上便于我们查看，而输出信息在文件中。如果想让标准错误在文件中，可以 2&gt;</p><p>此外，平常写的 &gt; 实际上代表的是 1&gt;</p><h4 id="子shell"><a href="#子shell" class="headerlink" title="子shell"></a>子shell</h4><p>进程就是加载到内存中准备运行的程序，当进程需要启动另一个进程的时候，这个进程创建了一个副本进程，原始跌进程叫做父进程，而这个进程叫做子进程。</p><p>而子进程一旦结束，优惠唤醒父进程继续执行命令，此时子进程消失。</p><p>子shell指的是在父shell中重新开一个shell，这样在子shell中造成的改变不会影响父shell，甚至是环境变量也一样，除非把它写入初始化文件中，不然这个全局变量也会随着子shell进程的结束而消亡。</p><p>如果有时你想在子shell中执行一条指令，又不想启动一个全新的shell，那么一个办法就是在外面加上小括号(),例如 （date）</p><h4 id="组合标准重定向输出和错误"><a href="#组合标准重定向输出和错误" class="headerlink" title="组合标准重定向输出和错误"></a>组合标准重定向输出和错误</h4><p>在bash中，基本思想是建议将一种类型的输出重定向到一个文件，然后再追加</p><p>command x&gt; outputfile y&gt;&amp;x</p><blockquote><p>&amp; 符号的意思是替代</p></blockquote><p>y&gt;&amp; x的意思是把2的输出发送给1相同的位置。</p><p>例： sort 2&gt;&amp;1 &gt;output 这个意思是把2的输出发送到与一相同的位置，而一是发送到屏幕的，于是2也发送到屏幕了</p><h4 id="抛弃输出"><a href="#抛弃输出" class="headerlink" title="抛弃输出"></a>抛弃输出</h4><p>为什么要抛弃输出呢？</p><p>有时候，需要运行一个程序。因为可能你并不关心这个文件的输出。有时候，可能希望查看文件正常输出，而不关心错误信息。</p><p>那么这个时候只需要重定向输出到 /etc/null即可。这个文件的特殊之处在于发送给他的任何东西都会消失。所以 它有个奇怪的名字叫做 位桶(bit bucket)</p><h3 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h3><p>管道线的作用就是让各个程序组合发挥作用</p><p>shell允许创建一系列的命令，在这一系列的命令中，一个命令的标准输出可以发送给下一个程序的标准输入。当这样做时，两个程序之间的连接就是管道，而命令序列本身叫做管道线。</p><p>在创建管道线时，只需将希望键入的命令用竖线| （管道符号） 分隔开即可</p><p>能从标准输入读取文本，并向标准输出写入文本的程序，称为过滤器。</p><h4 id="管道线分流-tee"><a href="#管道线分流-tee" class="headerlink" title="管道线分流 tee"></a>管道线分流 tee</h4><p>有时候，可能希望把程序的输出发送到两个地方</p><p>语法： tee [-a] file…</p><p>file就是希望将数据发送到的文件的名称</p><p>例：cat name1 name2 | tee masterlist | grep Harley</p><p>这个指令中的tee 会将输出保存到masterlist中并且将cat的输出给grep</p><p>同样，如果这个文件存在，那么tee将会重写这个文件。如果想要追加内容，那么可以tee -a(append)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;标准输入-标准输出和标准错误&quot;&gt;&lt;a href=&quot;#标准输入-标准输出和标准错误&quot; class=&quot;headerlink&quot; title=&quot;标准输入 标准输出和标准错误&quot;&gt;&lt;/a&gt;标准输入 标准输出和标准错误&lt;/h3&gt;&lt;p&gt;基本思想：每个基于文本的程序都可以从任何源接
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>初始化文件</title>
    <link href="http://xinhecuican.github.io/2020/02/27/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6/"/>
    <id>http://xinhecuican.github.io/2020/02/27/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6/</id>
    <published>2020-02-27T13:04:00.000Z</published>
    <updated>2020-02-29T00:04:50.119Z</updated>
    
    <content type="html"><![CDATA[<p>有两个初始化文件，第一个文件是在启动时执行的，叫做登录文件（login file).第二个文件是在启动shell时执行的，叫做环境文件(environment file)。<br>有的shell还有注销文件，注销文件指的是在shell关闭时执行的文件</p><p>bash shell中登录文件文件名（.Bash_profile .bash_login)，环境文件（.bashrc),注销文件（.bash_logout)</p><p>这些文件名都是以点开头，点文件的别名是隐藏文件，意义是除非你用ls指令去查看，通常状况你无法看到这个文件</p><p>登录shell指的是登录时默认启动的shell，非登录shel则需要在登录shell中执行命令才可以启动</p><p>登录shell执行登录文件和环境文件，非登录shell只执行环境文件</p><h4 id="初始化文件中放什么内容"><a href="#初始化文件中放什么内容" class="headerlink" title="初始化文件中放什么内容"></a>初始化文件中放什么内容</h4><p>登录文件有两项任务，设置环境和初始化工作对话（不知道什么意思）</p><p>所以登录文件有两项任务</p><ol><li>创建或修改环境变量的命令（PATH,PAGER等）</li><li>执行所有一次性操作的命令</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有两个初始化文件，第一个文件是在启动时执行的，叫做登录文件（login file).第二个文件是在启动shell时执行的，叫做环境文件(environment file)。&lt;br&gt;有的shell还有注销文件，注销文件指的是在shell关闭时执行的文件&lt;/p&gt;
&lt;p&gt;bash
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>宏定义</title>
    <link href="http://xinhecuican.github.io/2020/02/27/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <id>http://xinhecuican.github.io/2020/02/27/%E5%AE%8F%E5%AE%9A%E4%B9%89/</id>
    <published>2020-02-27T01:53:00.000Z</published>
    <updated>2020-02-27T02:02:14.262Z</updated>
    
    <content type="html"><![CDATA[<p>宏定义就是在开始用井号（#）定义一个函数或者是常量，这种定义在编译器中被处理，运算速度快，但使用宏定义时可能会出现一些隐蔽的问题</p><p>例如：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="keyword">DATA</span> sizeof(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">for(<span class="built_in">int</span> i=cnt;i-<span class="keyword">DATA</span>&gt;=<span class="number">0</span>;i-=<span class="keyword">DATA</span>)</span><br></pre></td></tr></table></figure><p>乍一看这样做似乎没什么问题，要注意sizeof返回的是一个无符号数，有符号数和无符号数做比较的时候会先把有符号数变成无符号数。而负数的有符号数最高位一定为1，这样就可能会导致数据异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宏定义就是在开始用井号（#）定义一个函数或者是常量，这种定义在编译器中被处理，运算速度快，但使用宏定义时可能会出现一些隐蔽的问题&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight fortran&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>delete的一个注意事项</title>
    <link href="http://xinhecuican.github.io/2020/02/26/delete%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://xinhecuican.github.io/2020/02/26/delete%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2020-02-26T07:34:00.000Z</published>
    <updated>2020-02-26T08:10:04.183Z</updated>
    
    <content type="html"><![CDATA[<p>实际上delete后的指针并不会变成空指针，仍指向堆里的地址。但是这个时候这块空间已经可以被其他的new申请了，如果你没有把原指针更改的话，有可能对原指针进行的修改会影响到新指针。因此每次delete完之后最好把这个指针变成空指针</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实际上delete后的指针并不会变成空指针，仍指向堆里的地址。但是这个时候这块空间已经可以被其他的new申请了，如果你没有把原指针更改的话，有可能对原指针进行的修改会影响到新指针。因此每次delete完之后最好把这个指针变成空指针&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="c++" scheme="http://xinhecuican.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>位运算和移位运算</title>
    <link href="http://xinhecuican.github.io/2020/02/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E4%B8%80%E4%BD%8D%E5%8E%9F%E9%85%B8/"/>
    <id>http://xinhecuican.github.io/2020/02/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E4%B8%80%E4%BD%8D%E5%8E%9F%E9%85%B8/</id>
    <published>2020-02-25T07:56:00.000Z</published>
    <updated>2020-03-07T12:44:37.507Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h3><p>这里的与运算并不是平常的bool运算，而是按位与。这种运算比加减法快</p><p>符号： &amp;</p><p>例： 1010&amp;1000=1000 1001&amp;0110=0000</p><p>含义： 1&amp;1=1,1&amp;0=0,0&amp;1=0,0&amp;0=0，只要不是两个都是,1，那么结果就是0</p><p>应用：</p><ul><li>替换指定位的值</li></ul><p>一个典型应用就是大小写转换，如果平常转换我们可能要写一大堆，但是经过仔细观察后发现大写字母和小写字母之间差距只有第5位，如果第五位为0，就是大写字母，为1就是小写字母，所以只要<code>a&amp;0b11011111</code>这一段代码就可以完成小写到大写的转换</p><ul><li>清零</li></ul><p>通过 a&amp;0b00000000 ,可以快速的把某个数变成零</p><ul><li>消去最后一位 1</li></ul><p>x &amp; (x-1) 例如 x 1010 x-1 1001 ，计算之后1000。减1就是让最小的那个1变成0然后后面全是1</p><ul><li>找到最小一位1</li></ul><p>x &amp; (-x) 在lowbit函数中用到， -x=~（x-1），大于最小一位1的都由于取反变成0，然后最小一位1及其后面本来是0111…,取反变成1000…，而原来是100…，所以最终是00…0100…</p><h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h3><p>符号： |</p><p>例： 1010|1000=1010 1001|0110=1111</p><p>含义： 1|1=1,1|0=1，0|1=1，0|0=0</p><p>应用：</p><ul><li>设定某一个数据位为1，例如想把第五位设为1，只要 a|0b00100000</li></ul><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>符号： ^</p><p>例： 1010^1000=0010, 1001^0110=1111</p><p>含义： 1^1=0,1^0=1,0^1=1,0^0=0，同为假，异为真</p><p>应用：</p><ul><li><p>x^11111…=~x;</p></li><li><p>异或满足交换率，结合率</p></li><li><p>x^x=0,x^0=x,自己是自己的逆元，0是幺元</p></li><li><p>a^b^a=b,因此可以用这种性质做许多应用，一个应用就是交换两个变量的值</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*&amp; a,<span class="keyword">int</span>*&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a=*a ^ *b;  <span class="comment">//a=a^b</span></span><br><span class="line">    *b=*a ^ *b; <span class="comment">//b=a^b^b=a</span></span><br><span class="line">    *a=*a ^ *b; <span class="comment">//a=a^b^a=b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还可以用来检查重复数或者在其余都是偶数个重复数字中找到一个奇数</p><p>例：1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现<br>一次。每个数组元素只能访问一次</p><p>将所有的数全部异或，得到的结果与1^2^3^…^1000的结果进行异或，得到的结果就是重复数。</p><h3 id="按位非"><a href="#按位非" class="headerlink" title="按位非"></a>按位非</h3><p>符号： ~</p><p>例： ~1001=0110， ~1010=0101</p><p>含义： <del>1=0，</del>0=1 ,取反</p><p>应用：</p><ul><li><p>对于有符号数 <del>a=-(a+1),因为一般采用补码，而补码的负数就是正数-1再取反得到，所以</del>(a-1)=-a，可得~a=-(a+1)</p></li><li><p>把最低位变成0，a&amp;~1</p><h3 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h3></li></ul><p>符号： &lt;&lt;</p><p>例 00001010&lt;&lt;1 =&gt; 00010100</p><p>含义： 把所有的位向左移位，高位删去，低位补零，相当于乘上2的n次方</p><p>注意：如果移动次数超过了最高位，那么这是一个未定义行为。所以不同编译器，不同cpu对其有不同解释。gcc会将其自动变成0，而微软的编译器会先将移动位数模上最大位数然后再左移相应位数。cpu中也是取模的方式。</p><p>例如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;</span><br><span class="line">b=a&lt;&lt;<span class="number">40</span>;<span class="comment">//此时b=0，因为这个命令是在编译器中完成的</span></span><br><span class="line">a&lt;&lt;=<span class="number">40</span>;<span class="comment">//此时a！=0，因为这个命令是在cpu中完成的</span></span><br></pre></td></tr></table></figure><h3 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h3><p>符号： &gt;&gt;</p><p>含义 将所有位向右移位，高位视情况而定，低位舍弃</p><p>视情况而定是因为实际上有两种右移，第一种是逻辑右移，第二种是算术右移</p><ul><li>逻辑右移，高位直接取0</li><li>算术右移，高位要看情况，如果原来最高位是0，则取0。如果最高位是1，则后面加的都是1.</li></ul><p><strong>逻辑右移的符号： &gt;&gt;&gt;</strong>(java)</p><p>那什么时候用逻辑右移还是算术右移呢？一般来说，有符号数算术右移，无符号数逻辑右移。因为有符号数用的是补码，如果是负数右移最高位补1才能让这个数还是负数</p><p>应用：</p><ul><li>不用-号把1变成-1<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;</span><br><span class="line">a&gt;&gt;=<span class="number">31</span>;<span class="comment">//最高位为1，其余都为0</span></span><br><span class="line">a&lt;&lt;=<span class="number">31</span>;<span class="comment">//都为1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="右移运算对整数的影响"><a href="#右移运算对整数的影响" class="headerlink" title="右移运算对整数的影响"></a>右移运算对整数的影响</h4><p>右移运算相当于除2，之后低位相当于小数点后面的数字。这时我们把它截断相当于取整，对于无符号数和有符号数中的非负数，这个取整是没什么影响的，但对于有符号数中的负数，取整却与除法取整有所偏差。</p><p>除法取整是趋向于零。也就是说，非负数向下取整，负数向上取整。而右移确是把小数后面的数全部舍弃，就相当于让这个数更小了。</p><p>例如： 假如右移后是 -1234.32423，结果是-1235.因为把小数点舍弃会使这个数更小。</p><p>有一种情况除外。就是右移产生的小数点位中全是0，这时舍弃它并不会产生影响，所以不会发生向下取整。</p><p>为了解决这个问题，一种办法就是 <code>(x+2^k-1)&gt;&gt;k</code>，为了加快速度，可以写成<code>(x+1&lt;&lt;k-1)&gt;&gt;k</code></p><p>现在来看这个式子的正确性，当最后几位全为0时，例如1000000右移三位，那么2^3-1=0b111,因为本来这个结果就是正确答案，现在加上111并没有改变它的值，0b1111000.111后面三位舍弃与原来相同，因此这个时候结论正确</p><p>如果后面不是全为0，那么这时必定产生进位，例如1101右移三位那么加上之后必定会使第四位进一位，这时我们再右移三位，便相当于让原来的答案加一，达到了向上取整的效果</p><p>最后，只有在有符号数中的负数中才要采用这种算法，在非负数中直接右移即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;与运算&quot;&gt;&lt;a href=&quot;#与运算&quot; class=&quot;headerlink&quot; title=&quot;与运算&quot;&gt;&lt;/a&gt;与运算&lt;/h3&gt;&lt;p&gt;这里的与运算并不是平常的bool运算，而是按位与。这种运算比加减法快&lt;/p&gt;
&lt;p&gt;符号： &amp;amp;&lt;/p&gt;
&lt;p&gt;例： 1010
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>c++输出16进制，10进制和2进制</title>
    <link href="http://xinhecuican.github.io/2020/02/22/c-%E8%BE%93%E5%87%BA16%E8%BF%9B%E5%88%B6%EF%BC%8C10%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6/"/>
    <id>http://xinhecuican.github.io/2020/02/22/c-%E8%BE%93%E5%87%BA16%E8%BF%9B%E5%88%B6%EF%BC%8C10%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6/</id>
    <published>2020-02-22T06:17:00.000Z</published>
    <updated>2020-02-22T06:29:45.858Z</updated>
    
    <content type="html"><![CDATA[<p>hex是输出16进制，例如<br><code>cout&lt;&lt;hex&lt;&lt;18&lt;&lt;endl;</code></p><p>dec十进制</p><p>另外这两种用了之后后面输出一直是这种进制，如果用了hex之后想要用十进制要写dec</p><p>二进制bitset</p><p>bitset有头文件 <code>&lt;bitset&gt;</code></p><p>  使用方法 bitset&lt;8&gt;(数字），其中8的含义是要输处几位二进制数，所以如果用int型是32，如果想把字符型转换就直接写8</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hex是输出16进制，例如&lt;br&gt;&lt;code&gt;cout&amp;lt;&amp;lt;hex&amp;lt;&amp;lt;18&amp;lt;&amp;lt;endl;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;dec十进制&lt;/p&gt;
&lt;p&gt;另外这两种用了之后后面输出一直是这种进制，如果用了hex之后想要用十进制要写dec&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="基础" scheme="http://xinhecuican.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>shell内部命令与外部命令与搜索路径</title>
    <link href="http://xinhecuican.github.io/2020/02/22/shell%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://xinhecuican.github.io/2020/02/22/shell%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-02-22T01:09:00.000Z</published>
    <updated>2020-02-24T12:50:25.583Z</updated>
    
    <content type="html"><![CDATA[<p>有些命令是shell外部的，shell会解析参数然后调用外部的程序去处理它，另外还有一些是对shell起作用的，叫shell内置命令</p><p>如果先查看内部命令，需要 man + shell名称 ，例如，man bash</p><h3 id="外部命令和搜索路径"><a href="#外部命令和搜索路径" class="headerlink" title="外部命令和搜索路径"></a>外部命令和搜索路径</h3><p>shell是如何知道那些程序都在哪呢？ 实际上shell是检查PATH环境变量，PATH包含一串字符，这串字符就是一系列目录名称，称作搜索路径。如果输入一个命令，shell会依次按这些目录去搜索命令</p><p>先要看PATH 直接 echo $PATH即可</p><h3 id="修改搜索路径"><a href="#修改搜索路径" class="headerlink" title="修改搜索路径"></a>修改搜索路径</h3><p>可以用export命令，export命令可以使PATH变量变成环境变量，这就意味着shell和随后所有进程都可以使用它，例如<code>export PATH=&quot;/bin:/usr/bin:/usr/ucb:/usr/local/bin&quot;</code></p><p>如果希望在搜索路径的末尾加上一条路径，可以 <code>export PATH=&quot;$PATH:$HOME/bin&quot;</code><br>如果想在最后加上一条指令，可以<code>export PATH=&quot;$HOME/bin:$PATH&quot;</code></p><p>如果把自己写的date命令放在开头，系统将会执行自己写的date命令，而不会执行系统本身的命令</p><p>实际上用export设置的环境变量在下次启动时就会失效，如果想一直保存需要修改一些特定的文件</p><h3 id="修改命令行提示"><a href="#修改命令行提示" class="headerlink" title="修改命令行提示"></a>修改命令行提示</h3><p>命令行提示的路径在PS1的环境变量当中,因此要修改的话只需要export PS1=”$ “就可以了</p><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>用反引号<code></code> `,用了这种符号会先执行反引号你饿不的命令然后再执行外部命令，</p><p>例如 <code>echo &quot;Date is</code>date` “</p><p>这个命令会显示Date is + 具体时间，注意要用双引号，单引号会把反引号引用掉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有些命令是shell外部的，shell会解析参数然后调用外部的程序去处理它，另外还有一些是对shell起作用的，叫shell内置命令&lt;/p&gt;
&lt;p&gt;如果先查看内部命令，需要 man + shell名称 ，例如，man bash&lt;/p&gt;
&lt;h3 id=&quot;外部命令和搜索路径&quot;&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>元字符的使用</title>
    <link href="http://xinhecuican.github.io/2020/02/22/%E4%BA%91%E5%AD%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xinhecuican.github.io/2020/02/22/%E4%BA%91%E5%AD%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-22T00:39:00.000Z</published>
    <updated>2020-02-22T01:07:20.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>元字符指的是Linux中有特殊含义的字符，例如 ； 换行符等。</p><h3 id="字符引用和转义"><a href="#字符引用和转义" class="headerlink" title="字符引用和转义"></a>字符引用和转义</h3><p>如果不想用元字符内在含义，只想打出这个字符，那么就需要用到引用字符。</p><p>字符引用的方法有三种，使用反斜线，使用一对单引号或者使用一对双引号</p><p>例如 echo a ; b 这样就会把他们当成不同的指令，但是如果 echo a; b,这样就会当成同一个指令，实际上\是转义字符，转义字符指的是把一个字符从一中状态转移到另一种状态</p><p>单引号会将一切字符引用，这样有时例如我需要引用其中一个变量的值的时候就会出现问题</p><p>这时我们就可以用到双引号，双引号不会引用 $ , \ , `(反引号），</p><p>引用能力强弱 ，&gt;‘’&gt;””</p><p>如果输入换行字符，单引号并不会转义它，但是\会转义它</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;元字符&quot;&gt;&lt;a href=&quot;#元字符&quot; class=&quot;headerlink&quot; title=&quot;元字符&quot;&gt;&lt;/a&gt;元字符&lt;/h3&gt;&lt;p&gt;元字符指的是Linux中有特殊含义的字符，例如 ； 换行符等。&lt;/p&gt;
&lt;h3 id=&quot;字符引用和转义&quot;&gt;&lt;a href=&quot;#字符引
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>顺序表</title>
    <link href="http://xinhecuican.github.io/2020/02/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <id>http://xinhecuican.github.io/2020/02/17/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</id>
    <published>2020-02-17T08:20:00.000Z</published>
    <updated>2020-02-17T08:51:30.974Z</updated>
    
    <content type="html"><![CDATA[<p>顺序表就是将元素放入一个连续的内存空间里，它的优点是可以快速访问，缺点是插入和删除操作时间复杂度高</p><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> datasize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>* p;<span class="comment">//存储空间的基址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//现在有的元素数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(node&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.p=<span class="keyword">new</span> <span class="keyword">int</span>[datasize];</span><br><span class="line">    <span class="keyword">if</span>(a.p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"储存分配失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> [] a.p;</span><br><span class="line">    &#125;</span><br><span class="line">    a.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化有两点要注意的地方，第一点是用了传引用，第二点是动态分配内存，这就表示如果使用完了要delete</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">find</span>(node&amp; a,int x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;a.<span class="built_in">length</span>;<span class="built_in">i</span>++)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(a.p[<span class="built_in">i</span>]==x)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">i</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入操作是把一个数插入第i位，其他位顺序后移</p><p>如果插入某一位概率相同，那么在第0位插入需要移动n个数，第一位插入需要移动n-1个数……在第n位插入需要移动0个数，总共有n-1中可能，总共需要移动的次数为n(n+1)/2,所以平均需要移动次数为n/2</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int insert(node&amp; a,int x,int <span class="built_in">i</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">i</span>&lt;<span class="number">0</span>||<span class="built_in">i</span>&gt;a.<span class="built_in">length</span>||a.<span class="built_in">length</span>==datasize)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">j</span>=a.<span class="built_in">length</span>;<span class="built_in">j</span>&gt;<span class="built_in">i</span>;<span class="built_in">j</span>--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="built_in">j</span>]=a[<span class="built_in">j</span><span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="built_in">i</span>]=x;</span><br><span class="line">    a.<span class="built_in">length</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>与上面操作类似，这里需要前移，并且平均操作次数为(n-1)/2</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> Delete(node&amp; a,<span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k=i;k&lt;a.length<span class="number">-1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.p[k]=a.p[k+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a.length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;顺序表就是将元素放入一个连续的内存空间里，它的优点是可以快速访问，缺点是插入和删除操作时间复杂度高&lt;/p&gt;
&lt;h3 id=&quot;建立&quot;&gt;&lt;a href=&quot;#建立&quot; class=&quot;headerlink&quot; title=&quot;建立&quot;&gt;&lt;/a&gt;建立&lt;/h3&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://xinhecuican.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>linux指令学习</title>
    <link href="http://xinhecuican.github.io/2020/02/16/linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <id>http://xinhecuican.github.io/2020/02/16/linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-02-16T02:20:00.000Z</published>
    <updated>2020-03-18T12:26:52.537Z</updated>
    
    <content type="html"><![CDATA[<h5 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h5><p>一次输入多条命令，可以在命令之间用 <code>;</code>分割开来</p><p>语法： 命令名称 选项 参数</p><p><strong>选项</strong>有时被称为开关（switches）或标志（flags），选项通常是由一个连字符后面接着一些字母，或者两个连字符后接着一个单词构成。例如 –help，–version（显示版本信息）</p><p>使用多个单字符选项时，可以把他们连接在一起，用一个连字符来表示。例如 ls -lF<br>。注意，unix的选项区分大小写</p><p>实际上许多长参数有着对应的短参数，但是长参数是一个完整的单词，为了便于记忆，有时也是用长参数，这时就要用两个连字符</p><p>输入命令时，必须要把每个选项和参数用空格分隔开</p><p>有些命令有默认值，有些命令没有默认值，例如 ls 如果只输入ls的话他会返回当前工作目录下所有文件</p><p>手册中提示的语法</p><ol><li>方括号中的项是可选的</li><li>不再方括号中的项是必选项</li><li>黑体字必须原样输入</li><li>斜体字可以用适当的值代替</li><li>有省略号代表可以重复多次</li><li>如果一个单独的选项和参数组合在一起，这二者必须同时出现</li><li>由竖线（|）字符分开的两个或者多个项，宝石可以从这个列表中选择任意一项</li></ol><h5 id="用户提醒命令"><a href="#用户提醒命令" class="headerlink" title="用户提醒命令"></a>用户提醒命令</h5><ul><li>who 用来显示用这个计算机的用户</li><li>whoami 用来显示当前用户标识</li><li>quota 用来看自己拥有多少空间</li><li>lock 临时上锁 lock -5 锁5分钟</li><li>leave leave +15 十五分钟后离开 leave 1344 13点44分离开，到了时间它会不停的提醒你，相当于一个闹钟</li><li>id 用来显示你的基本信息</li><li>date 时间 date -u 协调世界时间（UTC时间）</li><li>cal 显示日历 cal+某一年份可以显示某一年份的日历 cal 7 2019 显示2019年7月的日历 cal -j +… 会显示第几天，所以想要知道这一年是不是闰年只需 cal -j 12 + 年份，看看12月最后一天是不是366天就可以了</li><li>su（substitute user） 这个指令是用来切换用户的，如果你知道一个用户的口令，那么就可以采用su+用户名的方式切换，这个时候用户标识改变了，但是你仍位于旧的环境之中。就像你让别人来你家做事，如果你想让别人在自己家做事，就要用su+’-‘+用户名</li></ul><p>特别的，如果你想拥有root权限，你需要 su - root ，这时你输入的是你自己的口令而不是root口令，因为在计算机中有特殊的配置文件，这个文件只有管理员能操作，他可以修改那些人可以通过su口令获得root权限</p><ul><li>man 联机文档帮助 当你查看联机文档时，可以用/符加上你想搜索的内容进行搜索，用n来显示下一个，用N来显示上一个。？符是向下搜索。<br>如果想在查看man文档时执行指令，只需输入！在输入命令，之后按enter键又能回到man文档中</li><li>foo bar 可以指代任意标识<br>man文档显示的内容</li></ul><ol><li>命令</li><li>系统调用</li><li>库函数</li><li>特殊文件</li><li>文件格式</li><li>游戏</li><li>杂项</li><li>系统管理</li></ol><ul><li><p>whatis 显示说明书页的第一行（名字和用途）例如 whatis time date，这样同时显示两条指令的信息。这种指令可以用 man -f 替换</p></li><li><p>apropos 搜索命令 他将显示所有带有该字符的命令。这种命令可以用man -k代替</p></li><li><p>info 另一种搜索命令，这种命令的特点是它有到其他命令的连接，就好像网页一样。这时一种树形结构，n跳转到下一个节点，p跳转到上一个节点，t跳转到当前文件的顶节点</p><h5 id="登入登出命令"><a href="#登入登出命令" class="headerlink" title="登入登出命令"></a>登入登出命令</h5></li><li><p>exit 退出当前用户，例如想从root模式退出用exit</p></li><li><p>sudo 以超级用户模式运行一条指令。如果你经常使用超级用户，可能在无意间删去一些重要文件导致系统出现故障，因此超级用户需慎用。因此要用可以用sudo命令。</p></li><li><p>less 浏览配置文件。例如我想浏览passwd文件，只需 less /etc/passwd</p></li></ul><p>配置文件就像windows系统下的注册表和ini文件</p><ul><li>dmesg 显示启动信息，但是这种显示太快，看不清</li><li>dmesg | less 显示启动信息</li><li>init 设置运行级别，1为单用户，2为多用户，等等，0是关机，6是重启</li></ul><p>如果想重启，可以用 sudo init 6</p><ul><li>reboot 重启 sudo reboot</li><li>shutdown 关机，这个要说关机时间，经常用的是sudo shutdown now</li></ul><h5 id="快捷键和便捷输入命令"><a href="#快捷键和便捷输入命令" class="headerlink" title="快捷键和便捷输入命令"></a>快捷键和便捷输入命令</h5><ul><li>erase 删除最好一个键入的字符，Ctrl+H</li><li>werase 删除最后一个单词 Ctrl+W</li><li>kill 删除一行 Ctrl+U</li><li>intr 停止程序 有些系统是Ctrl+C，有些是delete</li><li>quit 停止程序 Ctrl+\ 它不仅会停止程序，还会生成一个副本保存在core的文件中</li><li>stop 停止屏幕显示，Ctrl+S</li><li>start 开始屏幕显示 Ctrl+Q</li><li>eof 文件终止信号 Ctrl+D<br>可以通过Ctrl+D终止shell，但是有时候会不小心按到。为了让shell忽略eof，需要使用一个叫IGNOREEOF的环境变量，这个变量表示注销前BASH会忽略多少次eof，设置这个变量时，要 IGNOREEOF = 数字</li><li>stty -a 显示键盘映射，这个命令是表示各个快捷方式如erase的快捷键。stty是set terminal(设置终端）-a表示显示所有设置</li><li>stty 修改键映射。例如想修改kill命令 ，可以 stty kill Ctrl a</li><li>返回字符 ^M，指的是返回到这一行的开头</li><li>换行字符 ^J<br>文件每一行最后一定是一个返回加换行</li><li>stty sane，reset 候终端的设置被弄乱，可以采用这个命令是终端恢复到初始值</li><li>up 向上键，会转到上一条指令</li><li>down 转到下一条指令</li><li>fc 查看历史命令列表，用fc -l来查看，前面都有一个编号。如果想转到某一条指令，可以 fc -s(substitute) 编号。如果后面不接编号，则默认为上一条指令。但是用fc -s会立刻执行这条指令</li></ul><p>可以对这条命令进行小范围修改，格式为 fc -s pattern=replacement number<br>。pattern和replacement 都是字符串，而number是要修改时间的编号</p><ul><li>tab 自动补全命令，按一下如果有歧义，会发出提示声<h5 id="立即使用的程序"><a href="#立即使用的程序" class="headerlink" title="立即使用的程序"></a>立即使用的程序</h5></li><li>which 看某个命令会使用那些程序，如果显示地址，则说明有这些程序，如果没有输出，或者输出错误信息，则说明这个命令无法使用</li><li>quit 终止程序命令，但是也可以输入eof使程序终止</li><li>bc 计算器 如果想用bc内部的函数，要用bc -l命令（library)。如果是多个算式，中间要用”;”号隔开</li></ul><p>常用函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">s</span><span class="params">(x)</span></span> sinx  弧度制</span><br><span class="line"><span class="function"><span class="title">c</span><span class="params">(x)</span></span> cosx</span><br><span class="line"><span class="function"><span class="title">a</span><span class="params">(x)</span></span> arctanx</span><br><span class="line"><span class="function"><span class="title">ln</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"><span class="title">j</span><span class="params">(n,x)</span></span>  x的n次整阶贝塞尔函数</span><br></pre></td></tr></table></figure><p>如果想用小数运算，先要设置标度因子 scale 来确定精确到小数点后多少位。如果输入scale 则会返回scale的当前值 scale=3，则设置小数点后三位</p><p>有一点需要注意，当你用来 bc -l时，scale会自动设置为20</p><p>bc实际上是一套功能完整的数学编程语言，可以使用的变量有26个字母<br>例如 x=100 就是将x变量设为100</p><h5 id="变量显示命令"><a href="#变量显示命令" class="headerlink" title="变量显示命令"></a>变量显示命令</h5><p>环境变量实际上就是全局变量，用env显示环境变量，如果想让输出按字母表排序，可以用 env | sort | less</p><ul><li><p>set 显示shell变量</p></li><li><p>echo 显示赋予它对象的值，例如 echo I 将会输出I</p></li></ul><p>如果要显示一个变量的值，可以用$(美元符号），后面的变量最好加花括号（{}）</p><p>例如 echo ${TERM}</p><p>实际上，很多标点符号都有特殊的用途，为了能正确显示他们，要在最外面用双引号</p><ul><li><p>变量创建只需要一边写变量名，另一边写值即可。例如，HARLEY=cool，如果希望变量中有空格，则需使用双引号</p></li><li><p>export 将变量导出环境中（即变成全局变量）。还可以在创建同时导出。用 export 变量名=值即可</p></li><li><p>unset 删除变量。实际上没有办法简单的从环境中移除变量，因此最简单的办法是直接删除它。</p></li><li><p>set 显示shell所有选项的当前值，如果用 -o 则会简要的显示 +o是详细的显示。例如，set -o ignoreeof 这样在按 Ctrl+D的时候就不会突出shell了，如果想复位，只要+o</p></li><li><p>alias 建立别名，语法为alias name=command 例如 <code>alias It=&#39;-l temp*&#39;</code>。这种时候，单引号就比双引号要好，因为这样可以防止一些特殊字符被转义。此外，可以通过alias name 知道这个别名的当前值。可以只输入alias得知所有别名，通过unalias删去别名。如果想暂时不用别名，可以在命令之前输入” \ “</p></li></ul><h5 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h5><ul><li>gedit 文本编辑器，相当于windows下的记事本</li><li>#注释</li></ul><h5 id="条件执行指令"><a href="#条件执行指令" class="headerlink" title="条件执行指令"></a>条件执行指令</h5><p>command1 &amp;&amp; command2</p><p>在条件1满足的情况下执行command2</p><p>command1|| command2</p><p>在条件1不满足的情况下也执行command2</p><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>regular expression 通常简写成regex或re，是一种指定字符串模式的输出方式。</p><p>例如： harley1 harley2 harley3 ，作为正则表达式，可以用harley[123]表达这组模式。</p><p>从这里我们可以了解到，正则表达式就像把许多字符串化为一个表达式。</p><p>下面介绍一些常用的正则表达式</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>除新行字符外，匹配任意的单个字符</td></tr><tr><td>^</td><td>锚，匹配行的开头</td></tr><tr><td>$</td><td>锚，匹配行的末尾</td></tr><tr><td>&lt;</td><td>锚，匹配单词的开头</td></tr><tr><td>\ &gt;</td><td>锚，匹配单词的末尾</td></tr><tr><td>[list]</td><td>字符类，匹配list中的任意字符</td></tr><tr><td>^[list]</td><td>子父类，匹配不再list中的任意字符</td></tr><tr><td>()</td><td>组，视为一个单独的单元</td></tr><tr><td>竖线</td><td>匹配选择之一</td></tr><tr><td>\</td><td>引用： 从字面上解释元字符</td></tr><tr><td><strong>注意</strong></td><td><strong>下面是判定匹配次数的字符</strong></td></tr><tr><td>*</td><td>匹配0次或者多次</td></tr><tr><td>+</td><td>匹配一次或者多次</td></tr><tr><td>？</td><td>匹配0次或1次</td></tr><tr><td>{n}</td><td>匹配n次</td></tr><tr><td>{0，m}</td><td>最多匹配m次</td></tr><tr><td>{n,}</td><td>最少匹配n次</td></tr><tr><td>{，m}</td><td>最多匹配m次</td></tr><tr><td>{n,m}</td><td>最少n次，最多m次</td></tr><tr><td><strong>注意</strong></td><td><strong>预定义字符类</strong></td></tr><tr><td>[:lower:]</td><td>小写字母</td></tr><tr><td>[:upper:]</td><td>大写字母</td></tr><tr><td>[:alpha:]</td><td>大小写字母</td></tr><tr><td>[:alnum:]</td><td>大小写字母，数字</td></tr><tr><td>[:digit:]</td><td>数字</td></tr><tr><td>[:punct:]</td><td>标点符号</td></tr><tr><td>[:blank:]</td><td>制表符或者空格</td></tr></tbody></table><h6 id="基本和扩展正则表达式"><a href="#基本和扩展正则表达式" class="headerlink" title="基本和扩展正则表达式"></a>基本和扩展正则表达式</h6><h6 id="匹配行和单词"><a href="#匹配行和单词" class="headerlink" title="匹配行和单词"></a>匹配行和单词</h6><p>有些元字符具有定位的作用，这些字符叫做<strong>锚</strong>。例如，harley$仍是匹配字符串harley，但是这个时候只匹配行末尾的字符了。</p><p>如果我们要找以harley开头的行，可以</p><p>grep ‘^harley’ data</p><p>注意，当我们使用含有元字符的表达式时，为了不干扰，最好加上单引号</p><p>通过使用 ^$ ，我们可以很方便的查找空行。这个的意思就是既找行首又找行尾，只有空行才满足这个条件。</p><p>例如： grep ‘^$’ data | wc -l</p><p>如果我们要找 某个字符位于开头的，可以用 &lt;</p><p>例如： grep ‘&lt;kn’ data，这个就是找kn为于单词开头的单词。或者grep ‘kn&gt;‘ data</p><p>在linux系统中，可以采用\b代替&lt;和&gt;，\b相当于边界标记。此外，要尊重客观规律，不能把开头标记和结尾标记都写在开头。</p><p>如果想匹配所有包含字母 H ，后面加a或者A的，可以用 grep ‘H[aA]’ data</p><p>如果想表示一个范围，可以用 [a-b]，例如 [3-6] 或 [a-z]，这应该是按ascii码来的</p><p>grep ‘[^A-Z,a-z]’ data可以用来搜索所有不包含字母的行</p><h6 id="重复使用运算符"><a href="#重复使用运算符" class="headerlink" title="重复使用运算符"></a>重复使用运算符</h6><p>例如，如果我想找首字母是大写H，后面接了0个或者多个字母的行，可以使用</p><p>grep ‘H[[:alpha:]]*’ data</p><p>如果想搜索一个或者多个，可以用+号，</p><p>例如： grep ‘variable[0-9]+’ data</p><p>到现在，我们一直使用单个字符作为查找对象，如果想用多个字符作为查找对象，就需要用到组（小括号）</p><p>例如： (xyz){5},这条命令就是查找重复出现xyz五次的字符串</p><p>如果我们想搜索多个单词，可以用 | 分隔开来。</p><p>例如： grep ‘(cat | dog | bird) ‘ data</p><p>如果我们想搜索有特殊含义的元字符，可以用(转义字符）把这些字符的含义变成常规字符，如果我们想搜索 \ 本身，那么可以用两个 \ </p><p>例如： grep ‘$‘ data</p><h6 id="字典文件"><a href="#字典文件" class="headerlink" title="字典文件"></a>字典文件</h6><p>字典顾名思义，就是许多经常用的单词放到一起，每个单词一行，并且按照字母表顺序排列。一般储存在 /usr/share/dict/words中。</p><p>利用这个文件，我们就可以很方便的查找单词。例如，那些单词以qu开头并且以y结尾呢？</p><p>grep ‘^qu[a-z]+y$’ /usr/share/dict/words</p><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td>PATH</td><td>设置shell搜索路径</td></tr><tr><td>PS1</td><td>设置标识符</td></tr><tr><td>SHELL</td><td>shell路径</td></tr><tr><td>HISTSIZE</td><td>fc中最大保存的指令数</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;命令语法&quot;&gt;&lt;a href=&quot;#命令语法&quot; class=&quot;headerlink&quot; title=&quot;命令语法&quot;&gt;&lt;/a&gt;命令语法&lt;/h5&gt;&lt;p&gt;一次输入多条命令，可以在命令之间用 &lt;code&gt;;&lt;/code&gt;分割开来&lt;/p&gt;
&lt;p&gt;语法： 命令名称 选项 参数&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>开始使用unix</title>
    <link href="http://xinhecuican.github.io/2020/02/13/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8unix/"/>
    <id>http://xinhecuican.github.io/2020/02/13/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8unix/</id>
    <published>2020-02-13T11:10:00.000Z</published>
    <updated>2020-02-16T02:19:49.105Z</updated>
    
    <content type="html"><![CDATA[<p>当你使用Unix系统的时候，第一件要你做的事便是输入用户标识和口令（账号密码），注意，在Unix中，密码是完全不可见的，甚至连*号都不会出现。</p><p>登陆之后出现的欢迎界面，这一部分源于一个特殊的初始化文档，这就意味着你可以对文档内容进行修改从而定制化你的初始化界面。</p><p>一旦初始化命令结束执行，Unix将启动shell，并将控制权交给他。这时shell会出现一个提示-称为shell提示，并等待命令。接下来就可以输入各种命令了。</p><p>最终，没有命令时，你可以通过注销结束工作会话，此时shell将停止运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当你使用Unix系统的时候，第一件要你做的事便是输入用户标识和口令（账号密码），注意，在Unix中，密码是完全不可见的，甚至连*号都不会出现。&lt;/p&gt;
&lt;p&gt;登陆之后出现的欢迎界面，这一部分源于一个特殊的初始化文档，这就意味着你可以对文档内容进行修改从而定制化你的初始化界面
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xinhecuican.github.io/categories/Linux/"/>
    
    
  </entry>
  
</feed>
