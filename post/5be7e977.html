<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java I/O | Xinhecuican's Blog</title><meta name="author" content="星河璀璨"><meta name="copyright" content="星河璀璨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述 java.io.InputStream代表字节输入流，java.io.OutputStream代表输出流。他们都是抽象类，InputStream中有以下方法：  int read():读入一个字节，并且转化成unsigned int型整数 int read(byte[] b): 从输入流中读取若干字节，保存在b数组中。如果到了输入流的结尾，返回1 int read(byte[] b, in">
<meta property="og:type" content="article">
<meta property="og:title" content="java I&#x2F;O">
<meta property="og:url" content="http://xinhecuican.github.io/post/5be7e977.html">
<meta property="og:site_name" content="Xinhecuican&#39;s Blog">
<meta property="og:description" content="概述 java.io.InputStream代表字节输入流，java.io.OutputStream代表输出流。他们都是抽象类，InputStream中有以下方法：  int read():读入一个字节，并且转化成unsigned int型整数 int read(byte[] b): 从输入流中读取若干字节，保存在b数组中。如果到了输入流的结尾，返回1 int read(byte[] b, in">
<meta property="og:locale">
<meta property="og:image" content="https://api.ghser.com/random/fengjing.php">
<meta property="article:published_time" content="2020-05-24T10:21:00.000Z">
<meta property="article:modified_time" content="2020-06-07T06:45:14.328Z">
<meta property="article:author" content="星河璀璨">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.ghser.com/random/fengjing.php"><link rel="shortcut icon" href="/img/favicon.png"><!--link(rel="canonical" href=urlNoIndex())--><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="zmX9zYZL0QVB6fFG_e98QsQogwE11Vdf5hOd4xMbgN4"><meta name="baidu-site-verification" content="EVZv9BO5R3"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-06-07 14:45:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@500&display=swap" rel="stylesheet"><link rel="stylesheet" href="footer.min.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Xinhecuican's Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">175</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">25</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.ghser.com/random/fengjing.php')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Xinhecuican's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java I/O</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-05-24T10:21:00.000Z" title="Created 2020-05-24 18:21:00">2020-05-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-06-07T06:45:14.328Z" title="Updated 2020-06-07 14:45:14">2020-06-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>17min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<p>java.io.InputStream代表字节输入流，java.io.OutputStream代表输出流。他们都是抽象类，InputStream中有以下方法：</p>
<ul>
<li>int read():读入一个字节，并且转化成unsigned int型整数</li>
<li>int read(byte[] b): 从输入流中读取若干字节，保存在b数组中。如果到了输入流的结尾，返回1</li>
<li>int read(byte[] b, int off, int len): 如上，这里只是多了在b数组中的开始位置和读取数目</li>
<li>void close()： 关闭输入流。如果不关闭的话其他需要这个文件的就无法读取这个文件信息。类似于打开了一个应用程序再打开就说有一个实例正在运行。</li>
<li>int available(): 放回从输入流中读取字节数目</li>
<li>skip(long n): 从输入流中跳过n个字节</li>
<li>boolean markSupported(),void mark(int readLimit), void reset(): 如果想要重复读入数据，就先用markSupported()判断这个流是否支持重复读入数据，如果支持，通过mark在当前位置开始设置readLimit字节的标记，然后用reset()可以使输入流定位到做标记的起始位置，然后通过read()就可以重复读数据了。</li>
</ul>
<p>OutputStream中方法：</p>
<ul>
<li>void write(): 输出一个字节</li>
<li>void write(byte[] b): 同上</li>
<li>void write(byte[] b, int off, int len): 同上</li>
<li>void close()</li>
<li>void flush(): OutputStream本身的flush()不执行操作。但是如果是一些有缓冲区机制的实现类就有用了。在有缓冲区的输出流中，一般都是先把输出存在缓冲区中，等到了一定大小才会输出，<strong>这个方法的作用是强制输出缓冲区中数据</strong>。</li>
</ul>
<p>设置缓冲区的原因是输出并不是直接输出到屏幕中间要经历一系列的过程，耗时比较长，如果先存到缓冲区然后一次性输出就可以减少时间。</p>
<h1 id="输入流"><a class="markdownIt-Anchor" href="#输入流"></a> 输入流</h1>
<h2 id="bytearrayinputstream字节数组输入流"><a class="markdownIt-Anchor" href="#bytearrayinputstream字节数组输入流"></a> ByteArrayInputStream,字节数组输入流</h2>
<p>这个类从字节数组读取数据，可能会想直接用字符数组不就行了吗，为什么还要弄一个输入流类。ByteArrayInputStream实际上是一个<a href="https://xinhecuican.github.io/post/5951da65.html">适配器</a></p>
<p>构造方法：</p>
<p>ByteArrayInputStream(byte[] buf)</p>
<p>ByteArrayInputStream(byte[] buf, int offset, int length)</p>
<p>使用就是用上面的方法</p>
<h2 id="fileinputstream文件输入流"><a class="markdownIt-Anchor" href="#fileinputstream文件输入流"></a> FileInputStream文件输入流</h2>
<p>构造方法：</p>
<p>FileInputStream(File file)</p>
<p>FileInputStream(String name):通过name指定路径</p>
<p>例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamTester</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span>((data=in.<span class="built_in">read</span>()) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(data+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果文件很大，为了提高读取效率，可以利用一个缓冲区。例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">1024</span>;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FIleOutputStream(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">        <span class="keyword">int</span> len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        <span class="keyword">while</span>(len != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            out.<span class="built_in">write</span>(buff, <span class="number">0</span>, len);</span><br><span class="line">            len = in.<span class="built_in">read</span>(buff);</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">        out.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要打开的文件和这个类在同一文件夹下，可以用Class类的个体ResourceAsStream()方法,<strong>这时可以用相对路径</strong>。例如：</p>
<p><code>InputStream in = UseBuffer.getClass().getResourceAsStream(&quot;test.txt&quot;);</code></p>
<h2 id="pipedinputstream管道输入流"><a class="markdownIt-Anchor" href="#pipedinputstream管道输入流"></a> PipedInputStream管道输入流</h2>
<p>管道输入流是从管道输出流中读取数据的。一般是一个线程从管道中输出，然后另外一个接受。使用管道的优点是如果管道中没有数据就会阻塞，有数据才会恢复运行，这样就可以对产生的数据进行处理。</p>
<p>例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Sender <span class="keyword">extends</span> Thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PipedOnputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">    <span class="keyword">public</span> PipedOutputStream getPipedOutputStream()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i=-<span class="number">127</span>; i&lt;=<span class="number">128</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">                <span class="keyword">yield</span>();<span class="comment">//让步给sender处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedInputStream <span class="keyword">in</span>;</span><br><span class="line">        <span class="keyword">public</span> Receiver(Sender sender)<span class="keyword">throw</span> IOException</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过这个构造方法确定了两者的关系</span></span><br><span class="line">            <span class="keyword">in</span> = <span class="keyword">new</span> PipedInputStream(sender.getPepedOutputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> run()</span><br><span class="line">        &#123;</span><br><span class="line">            int data;</span><br><span class="line">            <span class="keyword">while</span>((data=<span class="keyword">in</span>.read()) != -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(data):</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">in</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="sequenceinputstream-顺序输入流"><a class="markdownIt-Anchor" href="#sequenceinputstream-顺序输入流"></a> SequenceInputStream 顺序输入流</h2>
<p>它可以把几个输入流混合到一起输入。</p>
<p>构造方法：</p>
<p>SequenceInputStream(Enumeration e): e是枚举类型，包含若干个输入流</p>
<p>SequenceInputStream(InputStream s1, InputStream s2):只合并两个</p>
<p>它关闭的时候只需要关闭SequenceInputStream就会一次关闭所有的输入流。</p>
<h2 id="装饰器设计模式"><a class="markdownIt-Anchor" href="#装饰器设计模式"></a> 装饰器设计模式</h2>
<p>假设有一个类要子类实现三种方法，并且有的子类只需要实现一个，有的要实现多个，那么就要2^3-1个子类，数量过多。我们可以采用装饰器思想减少子类数目。</p>
<p>装饰器也是一个子类。这个子类的特殊之处在于他实现了某一个方法并且它内部封装了父类的实例。它的构造方法是：<code>decorate(Base base)</code></p>
<p>例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">B </span><span class="keyword">extends </span>A</span><br><span class="line"></span><br><span class="line"><span class="keyword">B </span><span class="keyword">b </span>= new <span class="keyword">B();</span></span><br><span class="line"><span class="keyword">decorate1 </span>dec1 = new decorate1(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec1.method1();</span></span><br><span class="line"><span class="keyword">decorate2 </span>dec2 = new decorate2(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword">dec2.method2();</span></span><br></pre></td></tr></table></figure>
<h2 id="filterinputstream-过滤输入流"><a class="markdownIt-Anchor" href="#filterinputstream-过滤输入流"></a> FilterInputStream 过滤输入流</h2>
<p>过滤输入流其实就是一个装饰器</p>
<p><strong>种类</strong></p>
<table>
<thead>
<tr>
<th>过滤输入流</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataInputStream</td>
<td>与DataOutputStream搭配使用，按照和平台无关的方式从流中读取基本类型（int，char，long等）</td>
</tr>
<tr>
<td>BufferedInputStream</td>
<td>利用缓冲区提高效率</td>
</tr>
<tr>
<td>PushbackInputStream</td>
<td>把督导的一个字节压回缓冲区中，编译器用</td>
</tr>
</tbody>
</table>
<p>这些都是FileterInputStream的子类,并且也是装饰器。</p>
<h3 id="datainputstream类"><a class="markdownIt-Anchor" href="#datainputstream类"></a> DataInputStream类</h3>
<p>它的不同方法可以按不同编码读取数据，并且都是以read开头：</p>
<ul>
<li>readByte()</li>
<li>readLong()</li>
<li>readFloat()</li>
<li>readUTF(): 从输入流中读取若干字节，并转化成UTF-8编码字符串</li>
</ul>
<p>UTF-8如果是ascii就只用一个字节，如果是其他字符就用两个或两个以上字节。</p>
<p>DataInputStream应该和DataOutputStream配套使用。只有配套使用才会保证数据的正确性（因为这里的UTF-8是java本土化的UTF-8,本来的UTF-8好像是稳定3个字节的）。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FileOutputStream out1 = <span class="keyword">new</span> <span class="type">FileOutputStream</span>();</span><br><span class="line">        BufferedOutputStream out2 = <span class="keyword">new</span> <span class="type">BufferedOutputStream</span>(out1);</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> <span class="type">DataOutputStream</span>(out2);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bufferedinputstream"><a class="markdownIt-Anchor" href="#bufferedinputstream"></a> BufferedInputStream</h3>
<p>BufferedInputStream覆盖了读数据的行为，它利用缓冲区提高读取的效率。</p>
<p>构造方法：</p>
<ul>
<li>BufferedInputStream(InputStream in)</li>
<li>BufferedInputStream(InputStream in, int size):size指定缓冲区大小</li>
</ul>
<p>当数据源是文件时，可以用BufferedInputStream装饰数据流，然后再进行其他操作可以提高效率。</p>
<h3 id="pushbackinputstream"><a class="markdownIt-Anchor" href="#pushbackinputstream"></a> PushbackInputStream</h3>
<p>它有一个后推缓冲区，用于存放已经读入的字节。</p>
<h1 id="输出流"><a class="markdownIt-Anchor" href="#输出流"></a> 输出流</h1>
<p>输出流种类和输入流大致类似，sequenceInputStream对应的没有了，多了ObjectOutputStream。</p>
<p>ByteArrayOutputStream是把信息输出到字节数组中。例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        out.<span class="built_in">write</span>(<span class="string">&quot;你好&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//String的getBytes可以放回制定类型的编码</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = out.toByteArray();<span class="comment">//获得字符数组的方法</span></span><br><span class="line">        out.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先用write把要输入的数据输入到输出流中，然后通过toByteArray方法输出到字节数组中。</p>
<p><strong>文件输出流</strong></p>
<p>前面大致类似，多了一种构造方法<code>FileOutputStream(String name, boolean append)</code></p>
<p>其中append是为了确定是不是要在末尾追加数据。</p>
<h2 id="filteroutputstream-过滤输出流"><a class="markdownIt-Anchor" href="#filteroutputstream-过滤输出流"></a> FilterOutputStream 过滤输出流</h2>
<p>同样有DataOutputStream和BufferedOutputStream，大致和输入流类似，多了一种PrintStream类</p>
<h3 id="printstream"><a class="markdownIt-Anchor" href="#printstream"></a> PrintStream</h3>
<p>PrintStream和DataOutputStream类似，都可以输出格式化数据。他有如下方法。</p>
<ul>
<li>print(int i): 输出一个int</li>
<li>print(float i):</li>
<li>print(String i):</li>
<li>println(int i): 输出int型数据和换行符</li>
<li>println(float f):</li>
<li>println(String s):</li>
</ul>
<p>前面提到过，DataOutputStream和DataInputStream最好匹配使用是因为他们使用了特殊化的UTF-8编码。而PrintStream使用的是普通的UTF-8编码。</p>
<p>PrintStream的print()没有抛出IOException，但是他有checkError()判断写数据是否成功，如果返回true，则代表出现了错误。</p>
<p>PrintStream自带缓冲区。但是这和BufferedInputStream提供的缓冲区还有所不同。后者只有缓冲区满的时候才会输出，前者可以由用户决定数据量多少的时候输出。当然，默认还是满的时候输出。PrintStream还提供了一个自动化的输出方案：</p>
<ul>
<li>PrintStream(OutputStream out, boolean autoFlash)。当满足以下情况就会自动输出
<ul>
<li>输出一个字节数组</li>
<li>输出一个换行符，即执行print(&quot;\n&quot;)或println()</li>
</ul>
</li>
</ul>
<h1 id="readerwriter"><a class="markdownIt-Anchor" href="#readerwriter"></a> Reader/Writer</h1>
<p>InputStream和OutputStream处理的是字节，但是在很多场合要处理的是字符（java中字符时2字节）。Reader和Writer就是处理这些的。</p>
<p>java中字符时Unicode编码，但是文本文件中不一定是Unidcode编码，还有可能是UTF-8，GBK甚至ascii，因此如何处理不同类型编码就是一个难点。</p>
<p>String的getBytes(String encode)返回特定类型的编码，encode参数指定编码类型。如果不带参数就使用本地操作系统默认编码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">获得本地编码</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">&quot;file.encoding&quot;</span>)</span>);</span><br><span class="line">或：</span><br><span class="line">Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(cs);</span><br></pre></td></tr></table></figure>
<p>Reader类可以把其他类型的编码转换成java所使用的编码。Writer可以把Unicode转换成其他类型的编码。</p>
<h2 id="reader"><a class="markdownIt-Anchor" href="#reader"></a> Reader</h2>
<p>Reader和InputStream类的种类大致类似.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CharArrayReader</td>
<td>把字符数组转换成Reader，从字符数组中读取字符</td>
</tr>
<tr>
<td>BufferedReader</td>
<td>装饰器，提供缓冲区。同时他的readLine()方法还可以读入一个字符串</td>
</tr>
<tr>
<td>LineNumberReader</td>
<td>提供缓冲区。并且可以跟踪字符输入流中中的行号</td>
</tr>
<tr>
<td>StringReader</td>
<td>把字符串转成Reader（数据源是字符串，和CharArrayReader类似），从字符串中读字符</td>
</tr>
<tr>
<td>PipedReader</td>
<td>连接PipedWriter</td>
</tr>
<tr>
<td>FilterReader</td>
<td>扩展其他Reader功能</td>
</tr>
<tr>
<td>InputStreamReader</td>
<td>把InputStream转换成Reader，可以指定数据源编码</td>
</tr>
<tr>
<td>FileReader</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="inputstreamreader"><a class="markdownIt-Anchor" href="#inputstreamreader"></a> InputStreamReader</h3>
<p>构造方法：</p>
<ul>
<li>InputStreamReader(InputStream in): 按照本地的字符编码解读输入流中的字符</li>
<li>InputStreamReader(InputStream in, String charsetName): 按照charsetName指定的方式读取输入流中的字符</li>
</ul>
<p>这里的read读出来的不是一个字节而是一个字符</p>
<p>一些常用的方法：</p>
<ul>
<li>readLine(),一次读入一行</li>
<li>readFile(String fileName, String charsetName):从文件中读取字符串，并输出到控制台中</li>
<li>copyFile(String from, String charsetFrom, String to, String charsetTo): 把原文件复制到目标文件中，可以指定文件编码</li>
</ul>
<h2 id="writer"><a class="markdownIt-Anchor" href="#writer"></a> Writer</h2>
<p>Writer和OutputStream大致类似，也有PrintWriter,区别是PrintStream只能用系统本地编码，而PrintWriter可以使用任意编码。PrintWriter构造方法：</p>
<ul>
<li>PrintWriter(Writer writer, boolean autoFlush)</li>
<li>PrintWriter(OutputStream out, boolean autoFlush)</li>
</ul>
<h1 id="标准io"><a class="markdownIt-Anchor" href="#标准io"></a> 标准I/O</h1>
<p>在System类中，有三个静态变量：</p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://System.in">System.in</a>: 代表标准输入流。默认输入时键盘</li>
<li>System.out: 是PrintStream类型（所以方法和PrintStream一样）。</li>
<li>System.err: 代表错误输出流，默认输出时输出到控制台。</li>
</ul>
<h2 id="对标准输入输出包装"><a class="markdownIt-Anchor" href="#对标准输入输出包装"></a> 对标准输入输出包装</h2>
<p>可以利用到前面所学的只是对标准输入输出进行包装。System.in是InputStream类型，可以先用InputStreamReader变成Reader，然后在用BufferedReader装饰。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> <span class="constructor">InputStreamReader(System.<span class="params">in</span>)</span>;</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> <span class="constructor">BufferedReader(<span class="params">reader</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向</h2>
<p>重定向方法：</p>
<ul>
<li>setIn(InputStream, in): 对标准输入重定向</li>
<li>setOut(printStream out):</li>
<li>setErr(PrintStream out):</li>
</ul>
<p>这些方法时System的静态方法，所以写的时候是System.setIn()</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void redirect(InputStream <span class="keyword">in</span>, PrintStream out, PrintStream err)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">In(<span class="params">in</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Out(<span class="params">out</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>set<span class="constructor">Err(<span class="params">err</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String<span class="literal">[]</span> args)throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    InputStream stdin = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span><span class="keyword">in</span>;</span><br><span class="line">    PrintStream stdout = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out;</span><br><span class="line">    PrintStream stderr = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>err;</span><br><span class="line">    InputStream <span class="keyword">in</span> = <span class="keyword">new</span> <span class="constructor">BufferedInputStream(<span class="string">&quot;D:\\temp.txt&quot;</span>)</span>;</span><br><span class="line">    PrintStream out = <span class="keyword">new</span> <span class="constructor">BufferedOutputStream(<span class="string">&quot;D:\\tempout.txt&quot;</span>)</span>;</span><br><span class="line">    redirect(<span class="keyword">in</span>, out, stderr);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="randomaccessfile-随机访问文件"><a class="markdownIt-Anchor" href="#randomaccessfile-随机访问文件"></a> RandomAccessFile 随机访问文件</h1>
<p>随机访问文件就是可以从文件任意位置读写数据，他有如下定位方法：</p>
<ul>
<li>getFilePointer(): 返回当前位置</li>
<li>seeek(long pos): 设置位置，与未见开头相距pos</li>
<li>skipBytes(int n): 从当前开始跳过n个字节</li>
<li>length(): 返回文件包含的字节数</li>
</ul>
<p>RandomAccessFile实现了DataInput和DataOutput接口，可以读取格式化数据；</p>
<ul>
<li>RandomAccessFile(File file, String mode)</li>
<li>RandomAccessFile(String name, String mode):name指定路径</li>
</ul>
<p>其中mode是访问模式，可以有&quot;r&quot;和&quot;rw&quot;。表示只读和读写，但是&quot;w&quot;是非法的。</p>
<h1 id="新-io库"><a class="markdownIt-Anchor" href="#新-io库"></a> 新 I/O库</h1>
<p>这些类位于java.nio包中，nio是newio。他映入了四个数据类型</p>
<ul>
<li>Buffer： 缓冲区</li>
<li>Charset： 把Unicode和其他类型相互转换</li>
<li>Channel： 数据传送通道，把Buffer内容输出或读入到Buffer</li>
<li>Selector： 支持异步I/O操作，也叫非阻塞I/O操作</li>
</ul>
<h2 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> Buffer</h2>
<p>缓冲区有两个作用：</p>
<ul>
<li>减少读取次数</li>
<li>和<a href="https://xinhecuican.github.io/post/7d1c86da.html">高速缓存</a>有关，这一段内存一直被重用。</li>
</ul>
<p>层次：<br>
<img src="/images/java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.jpg" alt></p>
<p>他有以下属性：</p>
<ul>
<li>容量</li>
<li>极限： 表示当前所使用缓冲区大小.极限可以修改</li>
<li>位置： 表示<strong>下一个</strong>读写单元位置</li>
</ul>
<p>他有如下设置属性方法：</p>
<ul>
<li>clear(): 把极限设置成容量，并且把位置变成0</li>
<li>flip(): 把极限设置成位置，然后把位置变成0</li>
<li>rewind(): 不改变极限，把位置变成0</li>
</ul>
<p>Buffer类是一个抽象类，他有8个具体类。最基本的是ByteBuffer类，他没有公开构造方法，但是有静态工厂。</p>
<ul>
<li>allocate(int capacity):</li>
<li>directAllocate(int capacity): 返回一个直接缓冲区。直接缓冲区速度较快，但是分配所需时间较多，所以一般只在所需空间较大并且长期使用的情况下才会用它。</li>
</ul>
<p>除了boolean类型之外，其他类型都有缓冲区（感觉和c的allocate有点类似），例如LongBuffer。此外，还有一种MappedByteBuffer，这是ByteBuffer的子类。它可以把缓冲区和文件某个区域直接映射（输出）。</p>
<p>共用方法：</p>
<ul>
<li>get(): 从当前位置读一个单元，然后位置加*ex位置读一个单元</li>
<li>put(): 向当前位置写入一个数据，然后位置加1</li>
<li>put(int index):</li>
</ul>
<h2 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h2>
<p>Channel用来连接缓冲区和数据源。它是一个接口，有两个方法：</p>
<ul>
<li>close(): 关闭通道</li>
<li>isOpen(): 判断通道是否打开</li>
</ul>
<p>通道会在创建时被打开，一旦被关闭就不能再次打开。</p>
<p>子接口ReadableByteChannel声明了read(ByteBuffer dst),把数据源数据读入到缓冲区中。WritableByteChannel声明了write(ByteBuffer src)，这个把src缓冲区中的数据输出。</p>
<p>ByteChannel扩展了上面说的两个接口，可以同时读写</p>
<p>ScatteringByteChannel扩展了ReadableByteChannel，可以分散读取数据。分散读取是指可以一次把数据放到多个缓冲区中。</p>
<p>GatheringByteChannel接口扩展了WritableByteChannel,可以把多个缓冲区中的数据一次性输出。他的wirte(ByteBuffer[] srcs)用来输出数据。</p>
<p><strong>这些方法都是缓冲区没满就继续读入</strong></p>
<p>FileChannel是Channel的实现类，他实现了ByteChannel，ScatteringByteChannel，GatheringByteChannel接口。支持上面所有操作。但是他没有公开构造方法，但是FileInputStream，FileOutputStream，RandomAccessFile类中提供了getChannel()方法，返回相应的FileChannel对象。</p>
<h2 id="charset"><a class="markdownIt-Anchor" href="#charset"></a> Charset</h2>
<p>Charset类每个实例代表特定的字符编码类型。他有以下用于编码转换的方法：</p>
<ul>
<li>ByteBuffer encode(String str): 把str转换成当前编码</li>
<li>ByteBuffer encode(CharBuffer cb): 把cb指定的字符缓冲区变成当前编码</li>
<li>CharBuffer decode(ByteBuffer bb): 把bb指定的ByteBuffer变成Unicode编码</li>
</ul>
<p>Charset有一个defaultCharset(): 返回代表本地平台编码的Charset对象。</p>
<h2 id="filechannel读写文件"><a class="markdownIt-Anchor" href="#filechannel读写文件"></a> FileChannel读写文件</h2>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">&#123;</span><br><span class="line">    final <span class="built_in">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    FileChannel fc = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="string">&quot;D:\\temp.txt&quot;</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">&quot;你好&quot;</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//向文件末尾添加</span></span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">RandomAccessFile(<span class="string">&quot;D:\\temp.txt&quot;</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    fc.position(fc.size<span class="literal">()</span>);<span class="comment">//定位到文件末尾</span></span><br><span class="line">    fc.write(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>wrap(<span class="string">&quot;朋友&quot;</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">    </span><br><span class="line">    fc = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="string">&quot;D:\\temp.txt&quot;</span>)</span>.get<span class="constructor">Channel()</span>;</span><br><span class="line">    ByteBuffer buff = <span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span>allocate(BSIZE);</span><br><span class="line">    fc.read(buff);</span><br><span class="line">    buff.flip<span class="literal">()</span>;</span><br><span class="line">    Charset cs = <span class="module-access"><span class="module"><span class="identifier">Charset</span>.</span></span>default<span class="constructor">Charset()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(cs.decode(buff));</span><br><span class="line">    fc.close<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2>
<p><strong>控制缓冲区</strong></p>
<p>前面说的clear(),flip，rewind看似没用，但是它可以方便我们读入输出数据</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span><span class="keyword">buff </span>= <span class="keyword">ByteBuffer.allocate(BSIZE);</span></span><br><span class="line"><span class="keyword">while(in.read(buff) </span>!= -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">buff.flip();</span></span><br><span class="line"><span class="keyword"> </span>   out.write(<span class="keyword">buff);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">buff.clear();</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这段代码前面的flip是为了保证只操作当前数据，而clear()是为了保证接受尽可能多的数据。</p>
<p><strong>字符编码转换</strong></p>
<p>CharBuffer存放的数据单元室Unicode字符，ByteBuffer中的asCharBuffer()可以把Byte中数据转换成Unicode字符，并且存放在CharBuffer中。</p>
<h2 id="缓冲区视图"><a class="markdownIt-Anchor" href="#缓冲区视图"></a> 缓冲区视图</h2>
<p>ByteBuffer类提供了asCharBuffer(),asIntBuffer(),和asFloatBuffer()来生成视图。通过视图，可以读取或写入各种类型的数据。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span>(bb.hasRemaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    bb.rewind();</span><br><span class="line">    CharBuffer cb = bb.asCharBuffer();</span><br><span class="line">    cb.<span class="built_in">put</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    whlie(bb.hasremaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(bb.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mappedbytebuffer"><a class="markdownIt-Anchor" href="#mappedbytebuffer"></a> MappedByteBuffer</h2>
<p>用于创建和修改那些因为太大而不能放入内存的文件。</p>
<p>FIleChannel类提供了获得MappedByteBuffer的map方法：</p>
<ul>
<li>MappedByteBuffer map(FIleChannel.MapMode mode, long position, long size)</li>
</ul>
<p>position是文件映射起始位置，size是映射区域大小，mode是模式，有三种：</p>
<ul>
<li>MapMode.READ_ONLY</li>
<li>READ_WRITE</li>
<li>MapMode.PRIVATE: 对MappedByteBuffer的修改不会保存到文件中，且其他程序不可见。</li>
</ul>
<p>例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">0x8000000</span>;</span><br><span class="line">    MappedByteBuffer mb = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D:\\test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>).getChannel()</span><br><span class="line">    .<span class="built_in">map</span>(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, capacity);</span><br><span class="line">    mb.flip();</span><br><span class="line">    System.out.<span class="built_in">println</span>(Charset.forName(<span class="string">&quot;GBK&quot;</span>).decode(mb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件加锁"><a class="markdownIt-Anchor" href="#文件加锁"></a> 文件加锁</h2>
<p>他允许程序同步访问作为共享资源的文件，但是可能发生同一时间多个线程同时访问的情况，甚至还有可能要和其他进程竞争。所以java中的文件锁是其他线程可见的。</p>
<p>FileChannel的tryLock()或Lock()用于锁定文件，如果成功放回FileLock对象，如果不成功就立刻返回null。lock()是阻塞式的，如果没有获得线程就会进入阻塞状态。</p>
<p>也可以部分加锁</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br><span class="line">lock(<span class="keyword">long</span> <span class="built_in">position</span>, <span class="keyword">long</span> <span class="built_in">size</span>, <span class="keyword">boolean</span> shared)</span><br></pre></td></tr></table></figure>
<p>上面的shared如果为true表示共享锁，如果是false是排他锁。</p>
<ul>
<li>共享锁，如果一个线程获得了共享锁，那么其他线程还可以获得共享锁，但是不能获得排他锁</li>
<li>排他锁，如果一个县城获得了排他锁，那么其他线程不可以获得共享锁或排他锁。</li>
</ul>
<p>可以用FileLock的isShared()判断锁的类型，如果是true，则是共享锁。release()用于释放文件锁。</p>
<h1 id="自动释放资源"><a class="markdownIt-Anchor" href="#自动释放资源"></a> 自动释放资源</h1>
<p>因为和c++中的delete一样，经常会忘了close(),所以从JDK7开始，绝大多数I/O类都实现了AutoCloseable接口。他会在一定条件下自动关闭：</p>
<ul>
<li>定义在try块中，退出try块时会自动调用close()(无论是正常出去还是非正常退出）。</li>
</ul>
<h1 id="用file来查看创建删除文件目录"><a class="markdownIt-Anchor" href="#用file来查看创建删除文件目录"></a> 用File来查看，创建，删除文件目录</h1>
<p>File表示真实系统中的一个文件，他有如下构造方法：</p>
<ul>
<li>File(String pathname):</li>
<li>File(String parent, String child):parent表示根路径，child表示子路径。</li>
<li>File(File parent, String child)</li>
</ul>
<p>一般来说，如果只要处理一个文件，那么使用第一种构造方法，否则就用后面几种。</p>
<p>还提供管理文件方法：</p>
<ul>
<li>boolean canRead().测试程序是否能对进行读操作</li>
<li>boolean canWrite()</li>
<li>boolean delete():删除文件，如果删除的是目录并且目录中有东西就不能删除</li>
<li>boolean exists():看这个文件时候存在</li>
<li>String getAbsolutePath():获取文件绝对目录</li>
<li>String getChanonicalPath(): 获取真正的路径，没有<code>.</code>和<code>..</code></li>
<li>String getName()</li>
<li>String getParent()</li>
<li>String getPath(): 相对目录</li>
<li>String[] list(): 返回当前目录下所有文件列表</li>
<li>File[] listFiles().返回目录下的所有文件和目录的File对象</li>
<li>boolean mkdir(): 创建目录</li>
<li>boolean createNewFile(): 如果FIle表示文件且在当前目录下不存在，就创建</li>
</ul>
<h2 id="操作目录树"><a class="markdownIt-Anchor" href="#操作目录树"></a> 操作目录树</h2>
<p>Files类： 有移动文件的move(),复制文件的copy()，搜索目录树的find().此外newDirectoryStream()回创建一个目录流，程序可以通过这个目录流遍历整个目录，用walkFileTree()遍历。</p>
<p>Path接口： 表示一个路径。</p>
<p>Paths类： 提供创建Path的静态方法，他的get(String first, String… more)返回一个Path对象，这个对象以first为根路径，以more为子路径.例如：<code>Paths.get(&quot;/root&quot;, &quot;dir1&quot;, &quot;dir2&quot;)</code>返回路径<code>/root/dir1/dir2</code>.</p>
<p><strong>查看zip</strong></p>
<p>可以通过FileSystems的newFileSystem()创建表示zip文件的FileSystem对象。然后可以用walkFileTree()遍历zip中所有文件。</p>
<p>其中walkFileTree可以查看官方文档。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">星河璀璨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://xinhecuican.github.io/post/5be7e977.html">http://xinhecuican.github.io/post/5be7e977.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://api.ghser.com/random/fengjing.php" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/a444b428.html"><img class="prev-cover" src="http://api.btstu.cn/sjbz/?lx=dongman" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">排序</div></div></a></div><div class="next-post pull-right"><a href="/post/d431fab4.html"><img class="next-cover" src="https://api.ixiaowai.cn/gqapi/gqapi.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Lambda</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text"> 输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bytearrayinputstream%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">2.1.</span> <span class="toc-text"> ByteArrayInputStream,字节数组输入流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fileinputstream%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">2.2.</span> <span class="toc-text"> FileInputStream文件输入流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipedinputstream%E7%AE%A1%E9%81%93%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">2.3.</span> <span class="toc-text"> PipedInputStream管道输入流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sequenceinputstream-%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">2.4.</span> <span class="toc-text"> SequenceInputStream 顺序输入流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text"> 装饰器设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filterinputstream-%E8%BF%87%E6%BB%A4%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">2.6.</span> <span class="toc-text"> FilterInputStream 过滤输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#datainputstream%E7%B1%BB"><span class="toc-number">2.6.1.</span> <span class="toc-text"> DataInputStream类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bufferedinputstream"><span class="toc-number">2.6.2.</span> <span class="toc-text"> BufferedInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pushbackinputstream"><span class="toc-number">2.6.3.</span> <span class="toc-text"> PushbackInputStream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">3.</span> <span class="toc-text"> 输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#filteroutputstream-%E8%BF%87%E6%BB%A4%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">3.1.</span> <span class="toc-text"> FilterOutputStream 过滤输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#printstream"><span class="toc-number">3.1.1.</span> <span class="toc-text"> PrintStream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#readerwriter"><span class="toc-number">4.</span> <span class="toc-text"> Reader&#x2F;Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#reader"><span class="toc-number">4.1.</span> <span class="toc-text"> Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inputstreamreader"><span class="toc-number">4.1.1.</span> <span class="toc-text"> InputStreamReader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#writer"><span class="toc-number">4.2.</span> <span class="toc-text"> Writer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E5%87%86io"><span class="toc-number">5.</span> <span class="toc-text"> 标准I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%8C%85%E8%A3%85"><span class="toc-number">5.1.</span> <span class="toc-text"> 对标准输入输出包装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.2.</span> <span class="toc-text"> 重定向</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#randomaccessfile-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text"> RandomAccessFile 随机访问文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0-io%E5%BA%93"><span class="toc-number">7.</span> <span class="toc-text"> 新 I&#x2F;O库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer"><span class="toc-number">7.1.</span> <span class="toc-text"> Buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#channel"><span class="toc-number">7.2.</span> <span class="toc-text"> Channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#charset"><span class="toc-number">7.3.</span> <span class="toc-text"> Charset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filechannel%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">7.4.</span> <span class="toc-text"> FileChannel读写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">7.5.</span> <span class="toc-text"> 应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E8%A7%86%E5%9B%BE"><span class="toc-number">7.6.</span> <span class="toc-text"> 缓冲区视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mappedbytebuffer"><span class="toc-number">7.7.</span> <span class="toc-text"> MappedByteBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="toc-number">7.8.</span> <span class="toc-text"> 文件加锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">8.</span> <span class="toc-text"> 自动释放资源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8file%E6%9D%A5%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">9.</span> <span class="toc-text"> 用File来查看，创建，删除文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95%E6%A0%91"><span class="toc-number">9.1.</span> <span class="toc-text"> 操作目录树</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 星河璀璨</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="Increase font size"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="Decrease font size"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'UJ3adzdUjnlMT2KmVU6dfoyO-MdYXbMMI',
      appKey: 'SGFIXvul1h4NATEJbvSGuU0i',
      placeholder: '昵称可以直接填QQ号哟，就不用填邮箱了',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      master: '1ee9943f931df37af9dc1c57f5859da4',
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/mychange.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>